# Design Specification: AIntern v0.6.1d "Tool Validation"

## Overview

**Version**: v0.6.1d
**Parent**: v0.6.1 Tool Framework
**Focus**: Validation system for tool parameters, including results, errors, warnings, and JSON schema integration

### Purpose

This sub-version defines the validation infrastructure for tool parameters:
1. Create `ToolValidationResult` with factory methods for common cases
2. Create `ToolValidationError` with comprehensive error types
3. Create `ToolValidationWarning` for non-blocking issues
4. Create `IToolValidator` interface for schema-based validation
5. Implement `ToolValidator` service with JSON Schema Draft 7 support
6. Enable path validation for security enforcement

### Dependencies

**From v0.6.1a (Tool Core Models)**:
- `ITool.Validate()` returns `ToolValidationResult`
- `ToolValidationResult` forward declaration to be replaced
- `ToolValidationError` forward declaration to be replaced

**From v0.6.1e (JSON Schema System)**:
- `JsonSchema` for schema definitions
- `JsonSchemaProperty` for property validation

**Future consumers**:
- v0.6.1c: `ToolResult.ValidationFailed()` factory
- v0.6.1f: Tool Base Class validation helpers
- v0.6.1i: Tool Execution Service pre-validation
- v0.6.3: Built-in Tools parameter validation

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                    v0.6.1d Tool Validation Architecture                        │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  src/AIntern.Core/Tools/                                                     │
│  ├─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  ToolValidationResult                                                    │ │
│  │  ┌─────────────────────────────────────────────────────────────────────┐│ │
│  │  │                                                                      ││ │
│  │  │  Properties                                                          ││ │
│  │  │  ├── IsValid: bool                                                   ││ │
│  │  │  ├── Errors: IReadOnlyList<ToolValidationError>                      ││ │
│  │  │  └── Warnings: IReadOnlyList<ToolValidationWarning>                  ││ │
│  │  │                                                                      ││ │
│  │  │  Factory Methods                                                     ││ │
│  │  │  ├── Valid()                                                         ││ │
│  │  │  ├── ValidWithWarnings(warnings)                                     ││ │
│  │  │  ├── Invalid(errors)                                                 ││ │
│  │  │  ├── MissingRequired(parameterName)                                  ││ │
│  │  │  ├── InvalidValue(parameterName, message)                            ││ │
│  │  │  └── Combine(results...)                                             ││ │
│  │  │                                                                      ││ │
│  │  │  Methods                                                             ││ │
│  │  │  └── GetErrorMessage() → string                                      ││ │
│  │  │                                                                      ││ │
│  │  └─────────────────────────────────────────────────────────────────────┘│ │
│  │                                                                          │ │
│  │  ToolValidationError                                                     │ │
│  │  ┌─────────────────────────────────────────────────────────────────────┐│ │
│  │  │                                                                      ││ │
│  │  │  Properties                                                          ││ │
│  │  │  ├── ParameterName: string                                           ││ │
│  │  │  ├── Message: string                                                 ││ │
│  │  │  ├── ErrorCode: string                                               ││ │
│  │  │  ├── ProvidedValue: object?                                          ││ │
│  │  │  └── ExpectedDescription: string?                                    ││ │
│  │  │                                                                      ││ │
│  │  │  Factory Methods                                                     ││ │
│  │  │  ├── Required(parameterName)                                         ││ │
│  │  │  ├── InvalidValue(parameterName, message, providedValue)             ││ │
│  │  │  ├── TypeMismatch(parameterName, expectedType, actualType)           ││ │
│  │  │  ├── OutOfRange(parameterName, value, min, max)                      ││ │
│  │  │  ├── PatternMismatch(parameterName, value, pattern)                  ││ │
│  │  │  ├── InvalidEnum(parameterName, value, allowedValues)                ││ │
│  │  │  ├── PathNotFound(parameterName, path)                               ││ │
│  │  │  └── PathOutsideWorkspace(parameterName, path)                       ││ │
│  │  │                                                                      ││ │
│  │  └─────────────────────────────────────────────────────────────────────┘│ │
│  │                                                                          │ │
│  │  ToolValidationWarning                                                   │ │
│  │  ┌─────────────────────────────────────────────────────────────────────┐│ │
│  │  │                                                                      ││ │
│  │  │  Properties                                                          ││ │
│  │  │  ├── ParameterName: string                                           ││ │
│  │  │  ├── Message: string                                                 ││ │
│  │  │  └── WarningCode: string                                             ││ │
│  │  │                                                                      ││ │
│  │  │  Factory Methods                                                     ││ │
│  │  │  ├── Deprecated(parameterName, alternative)                          ││ │
│  │  │  ├── LargeValue(parameterName, details)                              ││ │
│  │  │  └── SlowOperation(parameterName, reason)                            ││ │
│  │  │                                                                      ││ │
│  │  └─────────────────────────────────────────────────────────────────────┘│ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  src/AIntern.Core/Interfaces/                                                │
│  ├─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  IToolValidator                                                          │ │
│  │  ┌─────────────────────────────────────────────────────────────────────┐│ │
│  │  │  ├── ValidateAgainstSchema(parameters, schema) → ToolValidationResult││ │
│  │  │  ├── ValidateParameter(name, value, property) → IEnumerable<Error>   ││ │
│  │  │  ├── ValidatePath(path, workspacePath, mustExist) → Error?           ││ │
│  │  │  └── ValidateEnum(value, allowedValues) → Error?                     ││ │
│  │  └─────────────────────────────────────────────────────────────────────┘│ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  src/AIntern.Services/Tools/                                                 │
│  ├─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  ToolValidator : IToolValidator                                          │ │
│  │  ┌─────────────────────────────────────────────────────────────────────┐│ │
│  │  │  Implementation:                                                     ││ │
│  │  │  ├── JSON Schema Draft 7 validation                                  ││ │
│  │  │  ├── Required property checking                                      ││ │
│  │  │  ├── Type validation (string, integer, number, boolean, array)       ││ │
│  │  │  ├── Numeric range validation (minimum, maximum)                     ││ │
│  │  │  ├── String constraints (minLength, maxLength, pattern)              ││ │
│  │  │  ├── Array constraints (minItems, maxItems, uniqueItems)             ││ │
│  │  │  ├── Enum validation                                                 ││ │
│  │  │  ├── Nested object validation                                        ││ │
│  │  │  └── Path security validation                                        ││ │
│  │  └─────────────────────────────────────────────────────────────────────┘│ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Validation Flow

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                          Validation Flow Diagram                              │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Tool Call Request                                                           │
│  ┌───────────────────────────────────────────────────────────────────────┐   │
│  │ {                                                                      │   │
│  │   "tool": "file-write",                                               │   │
│  │   "parameters": {                                                      │   │
│  │     "path": "../../../etc/passwd",                                    │   │
│  │     "content": "malicious content"                                    │   │
│  │   }                                                                    │   │
│  │ }                                                                      │   │
│  └───────────────────────────────────────────────────────────────────────┘   │
│         │                                                                    │
│         ▼                                                                    │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │ IToolValidator.ValidateAgainstSchema()                                 │  │
│  │                                                                         │  │
│  │ Step 1: Check required parameters                                      │  │
│  │         ✓ "path" present                                               │  │
│  │         ✓ "content" present                                            │  │
│  │                                                                         │  │
│  │ Step 2: Validate parameter types                                       │  │
│  │         ✓ "path" is string                                             │  │
│  │         ✓ "content" is string                                          │  │
│  │                                                                         │  │
│  │ Step 3: Validate constraints                                           │  │
│  │         ✓ "path" matches pattern (if specified)                        │  │
│  │         ✓ "content" within length limits                               │  │
│  │                                                                         │  │
│  │ Step 4: Path security validation                                       │  │
│  │         ✗ "path" resolves outside workspace!                           │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│         │                                                                    │
│         ▼                                                                    │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │ ToolValidationResult                                                    │  │
│  │                                                                         │  │
│  │ IsValid: false                                                         │  │
│  │ Errors: [                                                              │  │
│  │   {                                                                    │  │
│  │     ParameterName: "path",                                             │  │
│  │     Message: "Path is outside the workspace: ../../../etc/passwd",     │  │
│  │     ErrorCode: "path_outside_workspace",                               │  │
│  │     ProvidedValue: "../../../etc/passwd"                               │  │
│  │   }                                                                    │  │
│  │ ]                                                                      │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│         │                                                                    │
│         ▼                                                                    │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │ Tool Execution BLOCKED                                                  │  │
│  │ Error returned to LLM for correction                                   │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Error Code Reference

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                          Validation Error Codes                               │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Error Code              │ Description                │ Example              │
│  ────────────────────────┼────────────────────────────┼──────────────────────│
│  required                │ Required parameter missing │ "path" not provided  │
│  invalid_value           │ Value fails validation     │ Empty string         │
│  type_mismatch           │ Wrong JSON type            │ String instead of int│
│  out_of_range            │ Numeric value out of range │ count = -1           │
│  pattern_mismatch        │ String doesn't match regex │ Invalid file path    │
│  invalid_enum            │ Value not in allowed set   │ mode = "invalid"     │
│  path_not_found          │ File/directory doesn't exist│ Missing file        │
│  path_outside_workspace  │ Path escapes workspace     │ ../../../etc/passwd  │
│  string_too_short        │ Below minLength            │ name = ""            │
│  string_too_long         │ Above maxLength            │ 10MB content         │
│  array_too_few           │ Below minItems             │ tags = []            │
│  array_too_many          │ Above maxItems             │ 1000 items           │
│  items_not_unique        │ uniqueItems violated       │ [1, 1, 2]            │
│                                                                              │
│  Warning Codes                                                               │
│  ────────────────────────┼────────────────────────────┼──────────────────────│
│  deprecated              │ Parameter is deprecated    │ Use "newParam"       │
│  large_value             │ Value is unusually large   │ 5MB file content     │
│  slow_operation          │ May take significant time  │ Large directory scan │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Specifications

### 1. ToolValidationResult.cs

**Location**: `src/AIntern.Core/Tools/ToolValidationResult.cs`

```csharp
namespace AIntern.Core.Tools;

/// <summary>
/// Result of validating tool parameters.
/// </summary>
/// <remarks>
/// <para>
/// Validation occurs before tool execution to catch parameter errors early.
/// This allows the system to provide immediate feedback to the LLM without
/// requiring user interaction for invalid tool calls.
/// </para>
/// <para>
/// A validation result can be:
/// </para>
/// <list type="bullet">
/// <item><b>Valid</b>: All parameters pass validation, execution can proceed</item>
/// <item><b>Valid with warnings</b>: Parameters are valid but have concerns</item>
/// <item><b>Invalid</b>: One or more errors prevent execution</item>
/// </list>
/// </remarks>
public sealed class ToolValidationResult
{
    /// <summary>
    /// Whether all parameters are valid.
    /// </summary>
    /// <remarks>
    /// True only when there are no errors. Warnings do not affect validity.
    /// </remarks>
    public bool IsValid { get; init; }

    /// <summary>
    /// List of validation errors that prevent execution.
    /// </summary>
    /// <remarks>
    /// Empty when <see cref="IsValid"/> is true.
    /// Each error identifies the problematic parameter and describes the issue.
    /// </remarks>
    public IReadOnlyList<ToolValidationError> Errors { get; init; } = Array.Empty<ToolValidationError>();

    /// <summary>
    /// List of validation warnings (non-blocking issues).
    /// </summary>
    /// <remarks>
    /// Warnings indicate potential problems that don't prevent execution:
    /// <list type="bullet">
    /// <item>Deprecated parameters</item>
    /// <item>Large values that may impact performance</item>
    /// <item>Operations that may take significant time</item>
    /// </list>
    /// Warnings are surfaced in the UI but don't block the tool call.
    /// </remarks>
    public IReadOnlyList<ToolValidationWarning> Warnings { get; init; } = Array.Empty<ToolValidationWarning>();

    #region Factory Methods

    /// <summary>
    /// Create a valid result with no errors or warnings.
    /// </summary>
    /// <returns>A valid validation result.</returns>
    public static ToolValidationResult Valid() =>
        new() { IsValid = true };

    /// <summary>
    /// Create a valid result with warnings.
    /// </summary>
    /// <param name="warnings">Warnings to include.</param>
    /// <returns>A valid validation result with warnings.</returns>
    public static ToolValidationResult ValidWithWarnings(params ToolValidationWarning[] warnings) =>
        new() { IsValid = true, Warnings = warnings };

    /// <summary>
    /// Create a valid result with warnings from an enumerable.
    /// </summary>
    /// <param name="warnings">Warnings to include.</param>
    /// <returns>A valid validation result with warnings.</returns>
    public static ToolValidationResult ValidWithWarnings(IEnumerable<ToolValidationWarning> warnings) =>
        new() { IsValid = true, Warnings = warnings.ToList() };

    /// <summary>
    /// Create an invalid result with errors.
    /// </summary>
    /// <param name="errors">Errors that caused validation to fail.</param>
    /// <returns>An invalid validation result.</returns>
    public static ToolValidationResult Invalid(params ToolValidationError[] errors) =>
        new() { IsValid = false, Errors = errors };

    /// <summary>
    /// Create an invalid result with errors from an enumerable.
    /// </summary>
    /// <param name="errors">Errors that caused validation to fail.</param>
    /// <returns>An invalid validation result.</returns>
    public static ToolValidationResult Invalid(IEnumerable<ToolValidationError> errors) =>
        new() { IsValid = false, Errors = errors.ToList() };

    /// <summary>
    /// Create an invalid result for a missing required parameter.
    /// </summary>
    /// <param name="parameterName">Name of the missing parameter.</param>
    /// <returns>An invalid validation result with a required error.</returns>
    public static ToolValidationResult MissingRequired(string parameterName) =>
        Invalid(ToolValidationError.Required(parameterName));

    /// <summary>
    /// Create an invalid result for an invalid parameter value.
    /// </summary>
    /// <param name="parameterName">Name of the invalid parameter.</param>
    /// <param name="message">Description of why the value is invalid.</param>
    /// <returns>An invalid validation result with an invalid value error.</returns>
    public static ToolValidationResult InvalidValue(string parameterName, string message) =>
        Invalid(ToolValidationError.InvalidValue(parameterName, message));

    /// <summary>
    /// Create an invalid result for a path outside the workspace.
    /// </summary>
    /// <param name="parameterName">Name of the path parameter.</param>
    /// <param name="path">The path that is outside the workspace.</param>
    /// <returns>An invalid validation result with a path security error.</returns>
    public static ToolValidationResult PathOutsideWorkspace(string parameterName, string path) =>
        Invalid(ToolValidationError.PathOutsideWorkspace(parameterName, path));

    #endregion

    #region Combination Methods

    /// <summary>
    /// Combine multiple validation results into one.
    /// </summary>
    /// <remarks>
    /// The combined result is:
    /// <list type="bullet">
    /// <item>Invalid if any input result has errors</item>
    /// <item>Valid if all input results are error-free</item>
    /// </list>
    /// All errors and warnings from input results are aggregated.
    /// </remarks>
    /// <param name="results">Results to combine.</param>
    /// <returns>Combined validation result.</returns>
    public static ToolValidationResult Combine(params ToolValidationResult[] results)
    {
        if (results.Length == 0)
            return Valid();

        var errors = results.SelectMany(r => r.Errors).ToList();
        var warnings = results.SelectMany(r => r.Warnings).ToList();

        return new ToolValidationResult
        {
            IsValid = errors.Count == 0,
            Errors = errors,
            Warnings = warnings
        };
    }

    /// <summary>
    /// Combine this result with another.
    /// </summary>
    /// <param name="other">The other result to combine with.</param>
    /// <returns>Combined validation result.</returns>
    public ToolValidationResult CombineWith(ToolValidationResult other) =>
        Combine(this, other);

    /// <summary>
    /// Add a warning to this result.
    /// </summary>
    /// <param name="warning">Warning to add.</param>
    /// <returns>New result with the additional warning.</returns>
    public ToolValidationResult WithWarning(ToolValidationWarning warning) =>
        new()
        {
            IsValid = IsValid,
            Errors = Errors,
            Warnings = Warnings.Append(warning).ToList()
        };

    /// <summary>
    /// Add an error to this result.
    /// </summary>
    /// <param name="error">Error to add.</param>
    /// <returns>New result with the additional error (always invalid).</returns>
    public ToolValidationResult WithError(ToolValidationError error) =>
        new()
        {
            IsValid = false,
            Errors = Errors.Append(error).ToList(),
            Warnings = Warnings
        };

    #endregion

    #region Formatting Methods

    /// <summary>
    /// Get a formatted error message for display.
    /// </summary>
    /// <remarks>
    /// Returns a multi-line string with one error per line, formatted as:
    /// <code>- {ParameterName}: {Message}</code>
    /// Returns empty string if valid.
    /// </remarks>
    /// <returns>Formatted error message.</returns>
    public string GetErrorMessage()
    {
        if (IsValid) return string.Empty;

        return string.Join(Environment.NewLine,
            Errors.Select(e => $"- {e.ParameterName}: {e.Message}"));
    }

    /// <summary>
    /// Get a formatted warning message for display.
    /// </summary>
    /// <returns>Formatted warning message.</returns>
    public string GetWarningMessage()
    {
        if (Warnings.Count == 0) return string.Empty;

        return string.Join(Environment.NewLine,
            Warnings.Select(w => $"- {w.ParameterName}: {w.Message}"));
    }

    /// <summary>
    /// Get a human-readable summary of the validation result.
    /// </summary>
    /// <returns>Summary string.</returns>
    public string GetSummary()
    {
        if (IsValid && Warnings.Count == 0)
            return "Validation passed";

        if (IsValid)
            return $"Validation passed with {Warnings.Count} warning(s)";

        return $"Validation failed with {Errors.Count} error(s)";
    }

    /// <summary>
    /// Convert to LLM-friendly format for error feedback.
    /// </summary>
    /// <returns>String formatted for LLM context.</returns>
    public string ToLlmContext()
    {
        if (IsValid) return "Parameters validated successfully.";

        var sb = new System.Text.StringBuilder();
        sb.AppendLine("Parameter validation failed:");

        foreach (var error in Errors)
        {
            sb.AppendLine($"- {error.ParameterName}: {error.Message}");
            if (error.ExpectedDescription != null)
            {
                sb.AppendLine($"  Expected: {error.ExpectedDescription}");
            }
        }

        return sb.ToString();
    }

    #endregion

    /// <inheritdoc />
    public override string ToString() => GetSummary();
}
```

### 2. ToolValidationError.cs

**Location**: `src/AIntern.Core/Tools/ToolValidationError.cs`

```csharp
namespace AIntern.Core.Tools;

/// <summary>
/// A validation error for a tool parameter.
/// </summary>
/// <remarks>
/// <para>
/// Validation errors describe specific problems with parameter values that
/// prevent tool execution. Each error identifies:
/// </para>
/// <list type="bullet">
/// <item>The parameter with the problem</item>
/// <item>A human-readable description of the issue</item>
/// <item>A machine-readable error code for programmatic handling</item>
/// <item>Optionally, the provided value and expected format</item>
/// </list>
/// <para>
/// Error codes follow a consistent naming convention (snake_case) and can
/// be used for error handling logic or localization.
/// </para>
/// </remarks>
public sealed class ToolValidationError
{
    /// <summary>
    /// Name of the parameter with the error.
    /// </summary>
    /// <remarks>
    /// Uses the parameter name as defined in the tool's JSON schema.
    /// For nested properties, uses dot notation: "options.recursive".
    /// </remarks>
    public string ParameterName { get; init; } = string.Empty;

    /// <summary>
    /// Human-readable error message.
    /// </summary>
    /// <remarks>
    /// Should be clear and actionable, helping the LLM understand how to
    /// correct the parameter value.
    /// </remarks>
    public string Message { get; init; } = string.Empty;

    /// <summary>
    /// Error code for programmatic handling.
    /// </summary>
    /// <remarks>
    /// Uses snake_case convention. Common codes:
    /// <list type="bullet">
    /// <item>required - Missing required parameter</item>
    /// <item>invalid_value - Value fails validation</item>
    /// <item>type_mismatch - Wrong JSON type</item>
    /// <item>out_of_range - Numeric value outside bounds</item>
    /// <item>pattern_mismatch - String doesn't match pattern</item>
    /// <item>invalid_enum - Value not in allowed set</item>
    /// <item>path_not_found - Path doesn't exist</item>
    /// <item>path_outside_workspace - Path escapes workspace</item>
    /// </list>
    /// </remarks>
    public string ErrorCode { get; init; } = string.Empty;

    /// <summary>
    /// The invalid value that was provided.
    /// </summary>
    /// <remarks>
    /// May be null if no value was provided (e.g., for missing required parameters).
    /// Useful for error messages and debugging.
    /// </remarks>
    public object? ProvidedValue { get; init; }

    /// <summary>
    /// Description of what was expected.
    /// </summary>
    /// <remarks>
    /// Helps the LLM understand the correct format.
    /// Examples:
    /// <list type="bullet">
    /// <item>"string" (for type mismatch)</item>
    /// <item>"value between 1 and 100" (for range)</item>
    /// <item>"one of: read, write, execute" (for enum)</item>
    /// </list>
    /// </remarks>
    public string? ExpectedDescription { get; init; }

    #region Factory Methods

    /// <summary>
    /// Create error for missing required parameter.
    /// </summary>
    /// <param name="parameterName">Name of the missing parameter.</param>
    /// <returns>Validation error for required parameter.</returns>
    public static ToolValidationError Required(string parameterName) =>
        new()
        {
            ParameterName = parameterName,
            Message = $"Required parameter '{parameterName}' is missing",
            ErrorCode = "required"
        };

    /// <summary>
    /// Create error for invalid value.
    /// </summary>
    /// <param name="parameterName">Name of the parameter.</param>
    /// <param name="message">Description of why the value is invalid.</param>
    /// <param name="providedValue">The invalid value that was provided.</param>
    /// <returns>Validation error for invalid value.</returns>
    public static ToolValidationError InvalidValue(
        string parameterName,
        string message,
        object? providedValue = null) =>
        new()
        {
            ParameterName = parameterName,
            Message = message,
            ErrorCode = "invalid_value",
            ProvidedValue = providedValue
        };

    /// <summary>
    /// Create error for type mismatch.
    /// </summary>
    /// <param name="parameterName">Name of the parameter.</param>
    /// <param name="expectedType">The expected JSON type.</param>
    /// <param name="actualType">The actual JSON type provided.</param>
    /// <returns>Validation error for type mismatch.</returns>
    public static ToolValidationError TypeMismatch(
        string parameterName,
        string expectedType,
        string actualType) =>
        new()
        {
            ParameterName = parameterName,
            Message = $"Expected {expectedType} but got {actualType}",
            ErrorCode = "type_mismatch",
            ExpectedDescription = expectedType
        };

    /// <summary>
    /// Create error for value out of range.
    /// </summary>
    /// <param name="parameterName">Name of the parameter.</param>
    /// <param name="value">The out-of-range value.</param>
    /// <param name="min">Minimum allowed value (null for no minimum).</param>
    /// <param name="max">Maximum allowed value (null for no maximum).</param>
    /// <returns>Validation error for out of range.</returns>
    public static ToolValidationError OutOfRange(
        string parameterName,
        object value,
        object? min,
        object? max) =>
        new()
        {
            ParameterName = parameterName,
            Message = FormatRangeMessage(value, min, max),
            ErrorCode = "out_of_range",
            ProvidedValue = value,
            ExpectedDescription = FormatRangeExpected(min, max)
        };

    /// <summary>
    /// Create error for pattern mismatch.
    /// </summary>
    /// <param name="parameterName">Name of the parameter.</param>
    /// <param name="value">The value that doesn't match.</param>
    /// <param name="pattern">The regex pattern that should match.</param>
    /// <returns>Validation error for pattern mismatch.</returns>
    public static ToolValidationError PatternMismatch(
        string parameterName,
        string value,
        string pattern) =>
        new()
        {
            ParameterName = parameterName,
            Message = $"Value does not match required pattern: {pattern}",
            ErrorCode = "pattern_mismatch",
            ProvidedValue = value,
            ExpectedDescription = $"Pattern: {pattern}"
        };

    /// <summary>
    /// Create error for invalid enum value.
    /// </summary>
    /// <param name="parameterName">Name of the parameter.</param>
    /// <param name="value">The invalid value.</param>
    /// <param name="allowedValues">The allowed enum values.</param>
    /// <returns>Validation error for invalid enum.</returns>
    public static ToolValidationError InvalidEnum(
        string parameterName,
        object value,
        IEnumerable<string> allowedValues) =>
        new()
        {
            ParameterName = parameterName,
            Message = $"Invalid value. Allowed: {string.Join(", ", allowedValues)}",
            ErrorCode = "invalid_enum",
            ProvidedValue = value,
            ExpectedDescription = $"One of: {string.Join(", ", allowedValues)}"
        };

    /// <summary>
    /// Create error for path not found.
    /// </summary>
    /// <param name="parameterName">Name of the path parameter.</param>
    /// <param name="path">The path that doesn't exist.</param>
    /// <returns>Validation error for path not found.</returns>
    public static ToolValidationError PathNotFound(string parameterName, string path) =>
        new()
        {
            ParameterName = parameterName,
            Message = $"Path does not exist: {path}",
            ErrorCode = "path_not_found",
            ProvidedValue = path
        };

    /// <summary>
    /// Create error for path outside workspace.
    /// </summary>
    /// <param name="parameterName">Name of the path parameter.</param>
    /// <param name="path">The path that escapes the workspace.</param>
    /// <returns>Validation error for path outside workspace.</returns>
    public static ToolValidationError PathOutsideWorkspace(string parameterName, string path) =>
        new()
        {
            ParameterName = parameterName,
            Message = $"Path is outside the workspace: {path}",
            ErrorCode = "path_outside_workspace",
            ProvidedValue = path
        };

    /// <summary>
    /// Create error for string too short.
    /// </summary>
    /// <param name="parameterName">Name of the parameter.</param>
    /// <param name="actualLength">Actual string length.</param>
    /// <param name="minLength">Required minimum length.</param>
    /// <returns>Validation error for string too short.</returns>
    public static ToolValidationError StringTooShort(
        string parameterName,
        int actualLength,
        int minLength) =>
        new()
        {
            ParameterName = parameterName,
            Message = $"String length {actualLength} is below minimum {minLength}",
            ErrorCode = "string_too_short",
            ProvidedValue = actualLength,
            ExpectedDescription = $"At least {minLength} characters"
        };

    /// <summary>
    /// Create error for string too long.
    /// </summary>
    /// <param name="parameterName">Name of the parameter.</param>
    /// <param name="actualLength">Actual string length.</param>
    /// <param name="maxLength">Maximum allowed length.</param>
    /// <returns>Validation error for string too long.</returns>
    public static ToolValidationError StringTooLong(
        string parameterName,
        int actualLength,
        int maxLength) =>
        new()
        {
            ParameterName = parameterName,
            Message = $"String length {actualLength} exceeds maximum {maxLength}",
            ErrorCode = "string_too_long",
            ProvidedValue = actualLength,
            ExpectedDescription = $"At most {maxLength} characters"
        };

    /// <summary>
    /// Create error for array with too few items.
    /// </summary>
    /// <param name="parameterName">Name of the parameter.</param>
    /// <param name="actualCount">Actual item count.</param>
    /// <param name="minItems">Required minimum items.</param>
    /// <returns>Validation error for too few items.</returns>
    public static ToolValidationError ArrayTooFew(
        string parameterName,
        int actualCount,
        int minItems) =>
        new()
        {
            ParameterName = parameterName,
            Message = $"Array has {actualCount} items, minimum is {minItems}",
            ErrorCode = "array_too_few",
            ProvidedValue = actualCount,
            ExpectedDescription = $"At least {minItems} items"
        };

    /// <summary>
    /// Create error for array with too many items.
    /// </summary>
    /// <param name="parameterName">Name of the parameter.</param>
    /// <param name="actualCount">Actual item count.</param>
    /// <param name="maxItems">Maximum allowed items.</param>
    /// <returns>Validation error for too many items.</returns>
    public static ToolValidationError ArrayTooMany(
        string parameterName,
        int actualCount,
        int maxItems) =>
        new()
        {
            ParameterName = parameterName,
            Message = $"Array has {actualCount} items, maximum is {maxItems}",
            ErrorCode = "array_too_many",
            ProvidedValue = actualCount,
            ExpectedDescription = $"At most {maxItems} items"
        };

    /// <summary>
    /// Create error for non-unique array items.
    /// </summary>
    /// <param name="parameterName">Name of the parameter.</param>
    /// <param name="duplicateValue">The duplicate value found.</param>
    /// <returns>Validation error for non-unique items.</returns>
    public static ToolValidationError ItemsNotUnique(
        string parameterName,
        object duplicateValue) =>
        new()
        {
            ParameterName = parameterName,
            Message = $"Array contains duplicate value: {duplicateValue}",
            ErrorCode = "items_not_unique",
            ProvidedValue = duplicateValue,
            ExpectedDescription = "All items must be unique"
        };

    #endregion

    #region Private Helpers

    private static string FormatRangeMessage(object value, object? min, object? max)
    {
        if (min != null && max != null)
            return $"Value {value} is outside range [{min}, {max}]";
        if (min != null)
            return $"Value {value} is below minimum {min}";
        if (max != null)
            return $"Value {value} exceeds maximum {max}";
        return $"Value {value} is out of range";
    }

    private static string FormatRangeExpected(object? min, object? max)
    {
        if (min != null && max != null)
            return $"Between {min} and {max}";
        if (min != null)
            return $"At least {min}";
        if (max != null)
            return $"At most {max}";
        return "Within valid range";
    }

    #endregion

    /// <inheritdoc />
    public override string ToString() => $"[{ErrorCode}] {ParameterName}: {Message}";
}
```

### 3. ToolValidationWarning.cs

**Location**: `src/AIntern.Core/Tools/ToolValidationWarning.cs`

```csharp
namespace AIntern.Core.Tools;

/// <summary>
/// A validation warning for a tool parameter.
/// </summary>
/// <remarks>
/// <para>
/// Warnings indicate potential issues that don't prevent execution but should
/// be noted. Unlike errors, warnings don't block the tool call.
/// </para>
/// <para>
/// Common warning scenarios:
/// </para>
/// <list type="bullet">
/// <item><b>Deprecated</b>: Parameter still works but has a preferred alternative</item>
/// <item><b>Large value</b>: Value is valid but may impact performance</item>
/// <item><b>Slow operation</b>: Operation may take significant time</item>
/// </list>
/// <para>
/// Warnings are surfaced in the UI and included in tool execution logs
/// but do not require user approval beyond what the operation normally requires.
/// </para>
/// </remarks>
public sealed class ToolValidationWarning
{
    /// <summary>
    /// Name of the parameter with the warning.
    /// </summary>
    /// <remarks>
    /// Uses the parameter name as defined in the tool's JSON schema.
    /// May be empty for tool-level warnings not tied to a specific parameter.
    /// </remarks>
    public string ParameterName { get; init; } = string.Empty;

    /// <summary>
    /// Human-readable warning message.
    /// </summary>
    /// <remarks>
    /// Should clearly explain the concern and any recommended actions.
    /// </remarks>
    public string Message { get; init; } = string.Empty;

    /// <summary>
    /// Warning code for programmatic handling.
    /// </summary>
    /// <remarks>
    /// Uses snake_case convention. Common codes:
    /// <list type="bullet">
    /// <item>deprecated - Parameter is deprecated</item>
    /// <item>large_value - Value is unusually large</item>
    /// <item>slow_operation - Operation may be slow</item>
    /// <item>security_concern - Potential security issue</item>
    /// <item>compatibility - May not work in all environments</item>
    /// </list>
    /// </remarks>
    public string WarningCode { get; init; } = string.Empty;

    /// <summary>
    /// Severity level of the warning (for UI display).
    /// </summary>
    /// <remarks>
    /// Higher values indicate more serious concerns.
    /// Default is 1 (informational).
    /// </remarks>
    public int Severity { get; init; } = 1;

    #region Factory Methods

    /// <summary>
    /// Create warning for deprecated parameter.
    /// </summary>
    /// <param name="parameterName">Name of the deprecated parameter.</param>
    /// <param name="alternative">Suggested alternative parameter (optional).</param>
    /// <returns>Deprecation warning.</returns>
    public static ToolValidationWarning Deprecated(string parameterName, string? alternative = null) =>
        new()
        {
            ParameterName = parameterName,
            Message = alternative != null
                ? $"Parameter '{parameterName}' is deprecated. Use '{alternative}' instead."
                : $"Parameter '{parameterName}' is deprecated.",
            WarningCode = "deprecated",
            Severity = 2
        };

    /// <summary>
    /// Create warning for large value.
    /// </summary>
    /// <param name="parameterName">Name of the parameter.</param>
    /// <param name="details">Description of the size concern.</param>
    /// <returns>Large value warning.</returns>
    public static ToolValidationWarning LargeValue(string parameterName, string details) =>
        new()
        {
            ParameterName = parameterName,
            Message = details,
            WarningCode = "large_value",
            Severity = 1
        };

    /// <summary>
    /// Create warning for potentially slow operation.
    /// </summary>
    /// <param name="parameterName">Name of the parameter causing slow operation.</param>
    /// <param name="reason">Why the operation may be slow.</param>
    /// <returns>Slow operation warning.</returns>
    public static ToolValidationWarning SlowOperation(string parameterName, string reason) =>
        new()
        {
            ParameterName = parameterName,
            Message = $"This may be slow: {reason}",
            WarningCode = "slow_operation",
            Severity = 1
        };

    /// <summary>
    /// Create warning for potential security concern.
    /// </summary>
    /// <param name="parameterName">Name of the parameter.</param>
    /// <param name="concern">Description of the security concern.</param>
    /// <returns>Security warning.</returns>
    public static ToolValidationWarning SecurityConcern(string parameterName, string concern) =>
        new()
        {
            ParameterName = parameterName,
            Message = concern,
            WarningCode = "security_concern",
            Severity = 3
        };

    /// <summary>
    /// Create warning for compatibility issues.
    /// </summary>
    /// <param name="parameterName">Name of the parameter.</param>
    /// <param name="details">Compatibility concern details.</param>
    /// <returns>Compatibility warning.</returns>
    public static ToolValidationWarning Compatibility(string parameterName, string details) =>
        new()
        {
            ParameterName = parameterName,
            Message = details,
            WarningCode = "compatibility",
            Severity = 2
        };

    /// <summary>
    /// Create a custom warning.
    /// </summary>
    /// <param name="parameterName">Name of the parameter.</param>
    /// <param name="message">Warning message.</param>
    /// <param name="warningCode">Warning code.</param>
    /// <param name="severity">Severity level (default 1).</param>
    /// <returns>Custom warning.</returns>
    public static ToolValidationWarning Custom(
        string parameterName,
        string message,
        string warningCode,
        int severity = 1) =>
        new()
        {
            ParameterName = parameterName,
            Message = message,
            WarningCode = warningCode,
            Severity = severity
        };

    #endregion

    /// <inheritdoc />
    public override string ToString() => $"[{WarningCode}] {ParameterName}: {Message}";
}
```

### 4. IToolValidator.cs

**Location**: `src/AIntern.Core/Interfaces/IToolValidator.cs`

```csharp
namespace AIntern.Core.Interfaces;

using System.Text.Json;
using AIntern.Core.Tools;

/// <summary>
/// Service for validating tool parameters against JSON schemas.
/// </summary>
/// <remarks>
/// <para>
/// The tool validator provides comprehensive parameter validation including:
/// </para>
/// <list type="bullet">
/// <item>JSON Schema Draft 7 validation</item>
/// <item>Required property checking</item>
/// <item>Type validation</item>
/// <item>Constraint validation (ranges, lengths, patterns)</item>
/// <item>Path security validation</item>
/// </list>
/// <para>
/// Validation occurs before tool execution and before user approval requests.
/// This ensures invalid tool calls are rejected early, providing immediate
/// feedback to the LLM without requiring user interaction.
/// </para>
/// </remarks>
public interface IToolValidator
{
    /// <summary>
    /// Validate parameters against a JSON schema.
    /// </summary>
    /// <remarks>
    /// Performs complete validation including:
    /// <list type="bullet">
    /// <item>All required properties are present</item>
    /// <item>All properties have correct types</item>
    /// <item>All constraints are satisfied</item>
    /// <item>No unknown properties (if additionalProperties is false)</item>
    /// </list>
    /// </remarks>
    /// <param name="parameters">Parameters to validate as a JSON element.</param>
    /// <param name="schema">JSON schema to validate against.</param>
    /// <returns>Validation result with any errors found.</returns>
    ToolValidationResult ValidateAgainstSchema(JsonElement parameters, JsonSchema schema);

    /// <summary>
    /// Validate a single parameter value against its schema property definition.
    /// </summary>
    /// <remarks>
    /// Validates type, constraints, and format for a single parameter.
    /// Returns an empty enumerable if valid.
    /// </remarks>
    /// <param name="parameterName">Name of the parameter being validated.</param>
    /// <param name="value">The value to validate.</param>
    /// <param name="property">Schema property definition.</param>
    /// <returns>Enumerable of validation errors (empty if valid).</returns>
    IEnumerable<ToolValidationError> ValidateParameter(
        string parameterName,
        JsonElement value,
        JsonSchemaProperty property);

    /// <summary>
    /// Validate that a path is within the workspace bounds.
    /// </summary>
    /// <remarks>
    /// Security validation to prevent path traversal attacks.
    /// Resolves the path and ensures it doesn't escape the workspace directory.
    /// </remarks>
    /// <param name="path">The path to validate.</param>
    /// <param name="workspacePath">The workspace root path.</param>
    /// <param name="mustExist">Whether the path must exist on disk.</param>
    /// <returns>Validation error if path is invalid, null if valid.</returns>
    ToolValidationError? ValidatePath(
        string path,
        string workspacePath,
        bool mustExist = false);

    /// <summary>
    /// Validate that a value is one of the allowed enum values.
    /// </summary>
    /// <param name="parameterName">Name of the parameter.</param>
    /// <param name="value">The value to validate.</param>
    /// <param name="allowedValues">The allowed values.</param>
    /// <returns>Validation error if not in allowed values, null if valid.</returns>
    ToolValidationError? ValidateEnum(
        string parameterName,
        string value,
        IEnumerable<string> allowedValues);

    /// <summary>
    /// Validate a numeric value against range constraints.
    /// </summary>
    /// <param name="parameterName">Name of the parameter.</param>
    /// <param name="value">The numeric value.</param>
    /// <param name="minimum">Minimum allowed value (null for no minimum).</param>
    /// <param name="maximum">Maximum allowed value (null for no maximum).</param>
    /// <returns>Validation error if out of range, null if valid.</returns>
    ToolValidationError? ValidateRange(
        string parameterName,
        double value,
        double? minimum,
        double? maximum);

    /// <summary>
    /// Validate a string against length constraints.
    /// </summary>
    /// <param name="parameterName">Name of the parameter.</param>
    /// <param name="value">The string value.</param>
    /// <param name="minLength">Minimum length (null for no minimum).</param>
    /// <param name="maxLength">Maximum length (null for no maximum).</param>
    /// <returns>Validation error if length invalid, null if valid.</returns>
    ToolValidationError? ValidateStringLength(
        string parameterName,
        string value,
        int? minLength,
        int? maxLength);

    /// <summary>
    /// Validate a string against a regex pattern.
    /// </summary>
    /// <param name="parameterName">Name of the parameter.</param>
    /// <param name="value">The string value.</param>
    /// <param name="pattern">The regex pattern.</param>
    /// <returns>Validation error if pattern doesn't match, null if valid.</returns>
    ToolValidationError? ValidatePattern(
        string parameterName,
        string value,
        string pattern);

    /// <summary>
    /// Validate an array against item count constraints.
    /// </summary>
    /// <param name="parameterName">Name of the parameter.</param>
    /// <param name="itemCount">Number of items in the array.</param>
    /// <param name="minItems">Minimum items (null for no minimum).</param>
    /// <param name="maxItems">Maximum items (null for no maximum).</param>
    /// <returns>Validation error if count invalid, null if valid.</returns>
    ToolValidationError? ValidateArrayLength(
        string parameterName,
        int itemCount,
        int? minItems,
        int? maxItems);
}
```

### 5. ToolValidator.cs

**Location**: `src/AIntern.Services/Tools/ToolValidator.cs`

```csharp
namespace AIntern.Services.Tools;

using System.Text.Json;
using System.Text.RegularExpressions;
using Microsoft.Extensions.Logging;
using AIntern.Core.Interfaces;
using AIntern.Core.Tools;

/// <summary>
/// Implementation of the tool parameter validator.
/// </summary>
/// <remarks>
/// Provides comprehensive JSON Schema Draft 7 compatible validation for tool parameters.
/// Includes special handling for path security to prevent workspace escapes.
/// </remarks>
public sealed class ToolValidator : IToolValidator
{
    private readonly ILogger<ToolValidator>? _logger;
    private readonly Dictionary<string, Regex> _patternCache = new();

    /// <summary>
    /// Initializes a new instance of the <see cref="ToolValidator"/> class.
    /// </summary>
    /// <param name="logger">Optional logger for validation diagnostics.</param>
    public ToolValidator(ILogger<ToolValidator>? logger = null)
    {
        _logger = logger;
    }

    /// <inheritdoc />
    public ToolValidationResult ValidateAgainstSchema(JsonElement parameters, JsonSchema schema)
    {
        var errors = new List<ToolValidationError>();
        var warnings = new List<ToolValidationWarning>();

        _logger?.LogDebug("Validating parameters against schema");

        // Check that parameters is an object
        if (parameters.ValueKind != JsonValueKind.Object)
        {
            errors.Add(ToolValidationError.TypeMismatch(
                "parameters", "object", parameters.ValueKind.ToString().ToLowerInvariant()));
            return ToolValidationResult.Invalid(errors);
        }

        // Check required properties
        foreach (var required in schema.Required)
        {
            if (!parameters.TryGetProperty(required, out _))
            {
                _logger?.LogDebug("Missing required parameter: {Parameter}", required);
                errors.Add(ToolValidationError.Required(required));
            }
        }

        // Validate each provided property
        foreach (var property in parameters.EnumerateObject())
        {
            var propertyName = property.Name;

            if (!schema.Properties.TryGetValue(propertyName, out var schemaProperty))
            {
                // Unknown property
                if (!schema.AdditionalProperties)
                {
                    _logger?.LogDebug("Unknown parameter: {Parameter}", propertyName);
                    errors.Add(ToolValidationError.InvalidValue(
                        propertyName,
                        $"Unknown parameter '{propertyName}'"));
                }
                continue;
            }

            // Validate the property value
            var propertyErrors = ValidateParameter(propertyName, property.Value, schemaProperty);
            errors.AddRange(propertyErrors);
        }

        _logger?.LogDebug(
            "Validation complete: {ErrorCount} errors, {WarningCount} warnings",
            errors.Count, warnings.Count);

        if (errors.Count > 0)
        {
            return new ToolValidationResult
            {
                IsValid = false,
                Errors = errors,
                Warnings = warnings
            };
        }

        return warnings.Count > 0
            ? ToolValidationResult.ValidWithWarnings(warnings)
            : ToolValidationResult.Valid();
    }

    /// <inheritdoc />
    public IEnumerable<ToolValidationError> ValidateParameter(
        string parameterName,
        JsonElement value,
        JsonSchemaProperty property)
    {
        var errors = new List<ToolValidationError>();

        // Skip validation for null values (handled by required check)
        if (value.ValueKind == JsonValueKind.Null)
        {
            return errors;
        }

        // Type validation
        var typeError = ValidateType(parameterName, value, property.Type);
        if (typeError != null)
        {
            errors.Add(typeError);
            return errors; // Stop validation on type mismatch
        }

        // Type-specific validation
        switch (property.Type.ToLowerInvariant())
        {
            case "string":
                errors.AddRange(ValidateStringProperty(parameterName, value, property));
                break;

            case "integer":
            case "number":
                errors.AddRange(ValidateNumericProperty(parameterName, value, property));
                break;

            case "array":
                errors.AddRange(ValidateArrayProperty(parameterName, value, property));
                break;

            case "object":
                errors.AddRange(ValidateObjectProperty(parameterName, value, property));
                break;
        }

        return errors;
    }

    /// <inheritdoc />
    public ToolValidationError? ValidatePath(
        string path,
        string workspacePath,
        bool mustExist = false)
    {
        if (string.IsNullOrWhiteSpace(path))
        {
            return ToolValidationError.InvalidValue("path", "Path cannot be empty");
        }

        try
        {
            // Resolve the full path
            var fullPath = Path.IsPathRooted(path)
                ? Path.GetFullPath(path)
                : Path.GetFullPath(Path.Combine(workspacePath, path));

            var normalizedWorkspace = Path.GetFullPath(workspacePath);

            // Check if path is within workspace
            if (!fullPath.StartsWith(normalizedWorkspace, StringComparison.OrdinalIgnoreCase))
            {
                return ToolValidationError.PathOutsideWorkspace("path", path);
            }

            // Check existence if required
            if (mustExist && !File.Exists(fullPath) && !Directory.Exists(fullPath))
            {
                return ToolValidationError.PathNotFound("path", path);
            }

            return null;
        }
        catch (Exception ex)
        {
            _logger?.LogWarning(ex, "Path validation failed for: {Path}", path);
            return ToolValidationError.InvalidValue("path", $"Invalid path: {ex.Message}");
        }
    }

    /// <inheritdoc />
    public ToolValidationError? ValidateEnum(
        string parameterName,
        string value,
        IEnumerable<string> allowedValues)
    {
        var allowedList = allowedValues.ToList();

        if (!allowedList.Contains(value, StringComparer.OrdinalIgnoreCase))
        {
            return ToolValidationError.InvalidEnum(parameterName, value, allowedList);
        }

        return null;
    }

    /// <inheritdoc />
    public ToolValidationError? ValidateRange(
        string parameterName,
        double value,
        double? minimum,
        double? maximum)
    {
        if (minimum.HasValue && value < minimum.Value)
        {
            return ToolValidationError.OutOfRange(parameterName, value, minimum, maximum);
        }

        if (maximum.HasValue && value > maximum.Value)
        {
            return ToolValidationError.OutOfRange(parameterName, value, minimum, maximum);
        }

        return null;
    }

    /// <inheritdoc />
    public ToolValidationError? ValidateStringLength(
        string parameterName,
        string value,
        int? minLength,
        int? maxLength)
    {
        if (minLength.HasValue && value.Length < minLength.Value)
        {
            return ToolValidationError.StringTooShort(parameterName, value.Length, minLength.Value);
        }

        if (maxLength.HasValue && value.Length > maxLength.Value)
        {
            return ToolValidationError.StringTooLong(parameterName, value.Length, maxLength.Value);
        }

        return null;
    }

    /// <inheritdoc />
    public ToolValidationError? ValidatePattern(
        string parameterName,
        string value,
        string pattern)
    {
        try
        {
            var regex = GetOrCreateRegex(pattern);
            if (!regex.IsMatch(value))
            {
                return ToolValidationError.PatternMismatch(parameterName, value, pattern);
            }
            return null;
        }
        catch (ArgumentException ex)
        {
            _logger?.LogWarning(ex, "Invalid regex pattern: {Pattern}", pattern);
            return ToolValidationError.InvalidValue(
                parameterName,
                $"Invalid pattern in schema: {pattern}");
        }
    }

    /// <inheritdoc />
    public ToolValidationError? ValidateArrayLength(
        string parameterName,
        int itemCount,
        int? minItems,
        int? maxItems)
    {
        if (minItems.HasValue && itemCount < minItems.Value)
        {
            return ToolValidationError.ArrayTooFew(parameterName, itemCount, minItems.Value);
        }

        if (maxItems.HasValue && itemCount > maxItems.Value)
        {
            return ToolValidationError.ArrayTooMany(parameterName, itemCount, maxItems.Value);
        }

        return null;
    }

    #region Private Validation Methods

    private ToolValidationError? ValidateType(
        string parameterName,
        JsonElement value,
        string expectedType)
    {
        var actualKind = value.ValueKind;
        var isValid = expectedType.ToLowerInvariant() switch
        {
            "string" => actualKind == JsonValueKind.String,
            "integer" => actualKind == JsonValueKind.Number && IsInteger(value),
            "number" => actualKind == JsonValueKind.Number,
            "boolean" => actualKind == JsonValueKind.True || actualKind == JsonValueKind.False,
            "array" => actualKind == JsonValueKind.Array,
            "object" => actualKind == JsonValueKind.Object,
            _ => true // Unknown types pass
        };

        if (!isValid)
        {
            return ToolValidationError.TypeMismatch(
                parameterName,
                expectedType,
                GetJsonTypeName(actualKind));
        }

        return null;
    }

    private IEnumerable<ToolValidationError> ValidateStringProperty(
        string parameterName,
        JsonElement value,
        JsonSchemaProperty property)
    {
        var errors = new List<ToolValidationError>();
        var stringValue = value.GetString() ?? string.Empty;

        // Enum validation
        if (property.Enum is { Length: > 0 })
        {
            var enumError = ValidateEnum(parameterName, stringValue, property.Enum);
            if (enumError != null)
            {
                errors.Add(enumError);
                return errors; // Stop if enum fails
            }
        }

        // Length validation
        var lengthError = ValidateStringLength(
            parameterName, stringValue, property.MinLength, property.MaxLength);
        if (lengthError != null)
            errors.Add(lengthError);

        // Pattern validation
        if (!string.IsNullOrEmpty(property.Pattern))
        {
            var patternError = ValidatePattern(parameterName, stringValue, property.Pattern);
            if (patternError != null)
                errors.Add(patternError);
        }

        return errors;
    }

    private IEnumerable<ToolValidationError> ValidateNumericProperty(
        string parameterName,
        JsonElement value,
        JsonSchemaProperty property)
    {
        var errors = new List<ToolValidationError>();

        if (!value.TryGetDouble(out var numericValue))
        {
            errors.Add(ToolValidationError.InvalidValue(
                parameterName, "Cannot parse as number"));
            return errors;
        }

        var rangeError = ValidateRange(
            parameterName, numericValue, property.Minimum, property.Maximum);
        if (rangeError != null)
            errors.Add(rangeError);

        return errors;
    }

    private IEnumerable<ToolValidationError> ValidateArrayProperty(
        string parameterName,
        JsonElement value,
        JsonSchemaProperty property)
    {
        var errors = new List<ToolValidationError>();
        var itemCount = value.GetArrayLength();

        // Count validation
        var countError = ValidateArrayLength(
            parameterName, itemCount, property.MinItems, property.MaxItems);
        if (countError != null)
            errors.Add(countError);

        // Unique items validation
        if (property.UniqueItems)
        {
            var seen = new HashSet<string>();
            foreach (var item in value.EnumerateArray())
            {
                var itemString = item.ToString();
                if (!seen.Add(itemString))
                {
                    errors.Add(ToolValidationError.ItemsNotUnique(parameterName, itemString));
                    break;
                }
            }
        }

        // Item validation
        if (property.Items != null)
        {
            int index = 0;
            foreach (var item in value.EnumerateArray())
            {
                var itemErrors = ValidateParameter(
                    $"{parameterName}[{index}]", item, property.Items);
                errors.AddRange(itemErrors);
                index++;
            }
        }

        return errors;
    }

    private IEnumerable<ToolValidationError> ValidateObjectProperty(
        string parameterName,
        JsonElement value,
        JsonSchemaProperty property)
    {
        var errors = new List<ToolValidationError>();

        if (property.ObjectProperties == null)
            return errors;

        // Check required nested properties
        if (property.ObjectRequired != null)
        {
            foreach (var required in property.ObjectRequired)
            {
                if (!value.TryGetProperty(required, out _))
                {
                    errors.Add(ToolValidationError.Required($"{parameterName}.{required}"));
                }
            }
        }

        // Validate nested properties
        foreach (var nestedProp in value.EnumerateObject())
        {
            if (property.ObjectProperties.TryGetValue(nestedProp.Name, out var nestedSchema))
            {
                var nestedErrors = ValidateParameter(
                    $"{parameterName}.{nestedProp.Name}",
                    nestedProp.Value,
                    nestedSchema);
                errors.AddRange(nestedErrors);
            }
        }

        return errors;
    }

    private Regex GetOrCreateRegex(string pattern)
    {
        if (_patternCache.TryGetValue(pattern, out var cached))
            return cached;

        var regex = new Regex(pattern, RegexOptions.Compiled);
        _patternCache[pattern] = regex;
        return regex;
    }

    private static bool IsInteger(JsonElement value)
    {
        if (value.TryGetInt64(out _))
            return true;

        // Check if the double value is a whole number
        if (value.TryGetDouble(out var d))
            return Math.Abs(d % 1) < double.Epsilon;

        return false;
    }

    private static string GetJsonTypeName(JsonValueKind kind) => kind switch
    {
        JsonValueKind.String => "string",
        JsonValueKind.Number => "number",
        JsonValueKind.True or JsonValueKind.False => "boolean",
        JsonValueKind.Array => "array",
        JsonValueKind.Object => "object",
        JsonValueKind.Null => "null",
        _ => "undefined"
    };

    #endregion
}
```

---

## Directory Structure

```
src/AIntern.Core/
├── Tools/
│   ├── ToolValidationResult.cs            (NEW - replaces forward declaration)
│   ├── ToolValidationError.cs             (NEW - replaces forward declaration)
│   └── ToolValidationWarning.cs           (NEW)
└── Interfaces/
    └── IToolValidator.cs                  (NEW)

src/AIntern.Services/
└── Tools/
    └── ToolValidator.cs                   (NEW)
```

---

## Unit Test Plan

| Test Class | Test | Description |
|------------|------|-------------|
| **ToolValidationResultTests** | | |
| | `Valid_ReturnsIsValidTrue` | Factory method creates valid result |
| | `ValidWithWarnings_PreservesWarnings` | Warnings are included in valid result |
| | `Invalid_ReturnsIsValidFalse` | Factory method creates invalid result |
| | `Invalid_PreservesErrors` | Errors are included in result |
| | `MissingRequired_CreatesCorrectError` | Convenience factory works correctly |
| | `InvalidValue_CreatesCorrectError` | Convenience factory works correctly |
| | `Combine_AllValid_ReturnsValid` | Combining valid results is valid |
| | `Combine_AnyInvalid_ReturnsInvalid` | Combining with invalid is invalid |
| | `Combine_AggregatesAllErrors` | All errors from inputs preserved |
| | `Combine_AggregatesAllWarnings` | All warnings from inputs preserved |
| | `GetErrorMessage_ValidResult_ReturnsEmpty` | No message for valid result |
| | `GetErrorMessage_InvalidResult_FormatsErrors` | Errors formatted correctly |
| | `ToLlmContext_ValidResult_ReturnsSuccessMessage` | LLM format for valid |
| | `ToLlmContext_InvalidResult_FormatsAllErrors` | LLM format includes errors |
| **ToolValidationErrorTests** | | |
| | `Required_CreatesCorrectErrorCode` | Error code is "required" |
| | `Required_IncludesParameterName` | Parameter name in message |
| | `InvalidValue_CreatesCorrectErrorCode` | Error code is "invalid_value" |
| | `TypeMismatch_IncludesExpectedAndActual` | Both types in message |
| | `OutOfRange_FormatsRangeCorrectly` | Range formatted in message |
| | `OutOfRange_MinOnly_FormatsCorrectly` | "At least" format |
| | `OutOfRange_MaxOnly_FormatsCorrectly` | "At most" format |
| | `PatternMismatch_IncludesPattern` | Pattern in expected description |
| | `InvalidEnum_ListsAllowedValues` | Allowed values in message |
| | `PathNotFound_IncludesPath` | Path in message |
| | `PathOutsideWorkspace_IncludesPath` | Path in message |
| | `StringTooShort_IncludesLengths` | Actual and min in message |
| | `StringTooLong_IncludesLengths` | Actual and max in message |
| | `ArrayTooFew_IncludesCounts` | Actual and min in message |
| | `ArrayTooMany_IncludesCounts` | Actual and max in message |
| **ToolValidationWarningTests** | | |
| | `Deprecated_WithAlternative_IncludesAlternative` | Alternative in message |
| | `Deprecated_WithoutAlternative_OmitsAlternative` | No "use X" text |
| | `LargeValue_IncludesDetails` | Details in message |
| | `SlowOperation_IncludesReason` | Reason in message |
| | `Custom_PreservesAllProperties` | All properties set correctly |
| **ToolValidatorTests** | | |
| | `ValidateAgainstSchema_ValidParameters_ReturnsValid` | Complete valid case |
| | `ValidateAgainstSchema_MissingRequired_ReturnsError` | Required check works |
| | `ValidateAgainstSchema_WrongType_ReturnsError` | Type check works |
| | `ValidateAgainstSchema_UnknownProperty_ReturnsError` | additionalProperties=false |
| | `ValidateParameter_String_ValidatesLength` | Length constraints |
| | `ValidateParameter_String_ValidatesPattern` | Pattern constraints |
| | `ValidateParameter_String_ValidatesEnum` | Enum constraints |
| | `ValidateParameter_Integer_ValidatesRange` | Integer range |
| | `ValidateParameter_Number_ValidatesRange` | Number range |
| | `ValidateParameter_Array_ValidatesItemCount` | minItems/maxItems |
| | `ValidateParameter_Array_ValidatesUniqueItems` | Uniqueness check |
| | `ValidateParameter_Array_ValidatesItemTypes` | Nested item validation |
| | `ValidateParameter_Object_ValidatesNestedRequired` | Nested required |
| | `ValidateParameter_Object_ValidatesNestedProperties` | Recursive validation |
| | `ValidatePath_WithinWorkspace_ReturnsNull` | Valid path |
| | `ValidatePath_OutsideWorkspace_ReturnsError` | Path traversal blocked |
| | `ValidatePath_Relative_ResolvesCorrectly` | Relative paths work |
| | `ValidatePath_MustExist_ChecksExistence` | Existence check |
| | `ValidateEnum_ValidValue_ReturnsNull` | Valid enum value |
| | `ValidateEnum_InvalidValue_ReturnsError` | Invalid enum value |
| | `ValidateEnum_CaseInsensitive_Passes` | Case handling |
| | `ValidateRange_WithinRange_ReturnsNull` | Valid range |
| | `ValidateRange_BelowMin_ReturnsError` | Below minimum |
| | `ValidateRange_AboveMax_ReturnsError` | Above maximum |
| | `ValidateStringLength_Valid_ReturnsNull` | Valid length |
| | `ValidateStringLength_TooShort_ReturnsError` | Too short |
| | `ValidateStringLength_TooLong_ReturnsError` | Too long |
| | `ValidatePattern_Matches_ReturnsNull` | Pattern matches |
| | `ValidatePattern_NoMatch_ReturnsError` | Pattern fails |
| | `ValidatePattern_InvalidRegex_ReturnsError` | Bad pattern handling |

**Total Tests**: 52

---

## Integration Points

### With v0.6.1a (Tool Core Models)

The forward declarations in `ToolTypes.cs` should be removed and replaced with these implementations:
- `ToolValidationResult` class
- `ToolValidationError` class

### With v0.6.1c (Tool Result System)

The `ToolResult.ValidationFailed()` factory method uses `ToolValidationResult`:
```csharp
public static ToolResult ValidationFailed(ToolValidationResult validation) =>
    new()
    {
        Success = false,
        Error = string.Join("; ", validation.Errors.Select(e => e.Message)),
        ErrorCode = "ValidationFailed",
        Message = "Parameter validation failed"
    };
```

### With v0.6.1f (Tool Base Class)

The `ToolBase.Validate()` method returns `ToolValidationResult`:
```csharp
public virtual ToolValidationResult Validate(JsonElement parameters)
{
    // Validate required parameters against schema
    var errors = new List<ToolValidationError>();
    foreach (var required in InputSchema.Required)
    {
        if (!parameters.TryGetProperty(required, out _))
        {
            errors.Add(ToolValidationError.Required(required));
        }
    }
    return errors.Count > 0
        ? ToolValidationResult.Invalid(errors.ToArray())
        : ToolValidationResult.Valid();
}
```

---

## File Summary

### Files to Create

| File | Location | Lines | Purpose |
|------|----------|-------|---------|
| `ToolValidationResult.cs` | `Core/Tools/` | ~220 | Validation result with factory methods |
| `ToolValidationError.cs` | `Core/Tools/` | ~280 | Error model with factory methods |
| `ToolValidationWarning.cs` | `Core/Tools/` | ~130 | Warning model with factory methods |
| `IToolValidator.cs` | `Core/Interfaces/` | ~120 | Validator interface |
| `ToolValidator.cs` | `Services/Tools/` | ~350 | Validator implementation |
| **Total** | | **~1100** | |

### Files to Modify

| File | Changes |
|------|---------|
| `Core/Tools/ToolTypes.cs` | Remove `ToolValidationResult` and `ToolValidationError` forward declarations |
| `Services/ServiceCollectionExtensions.cs` | Register `IToolValidator` → `ToolValidator` |

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | `ToolValidationResult` compiles with all factory methods |
| AC-2 | `ToolValidationError` has factory methods for all error codes |
| AC-3 | `ToolValidationWarning` has factory methods for common warnings |
| AC-4 | `IToolValidator.ValidateAgainstSchema` validates all JSON Schema features |
| AC-5 | Path validation prevents workspace escapes |
| AC-6 | Enum validation is case-insensitive |
| AC-7 | Numeric range validation handles min-only and max-only cases |
| AC-8 | Array validation checks count and item types |
| AC-9 | Nested object validation is recursive |
| AC-10 | All 52 unit tests pass |

---

## Changelog Entry

```markdown
## v0.6.1d - Tool Validation

### Added
- `ToolValidationResult` with:
  - IsValid, Errors, Warnings properties
  - Factory methods: Valid(), ValidWithWarnings(), Invalid(), MissingRequired(), InvalidValue()
  - Combination methods: Combine(), CombineWith(), WithWarning(), WithError()
  - Formatting methods: GetErrorMessage(), GetWarningMessage(), ToLlmContext()

- `ToolValidationError` with:
  - ParameterName, Message, ErrorCode, ProvidedValue, ExpectedDescription properties
  - Factory methods for all error types: Required(), InvalidValue(), TypeMismatch(),
    OutOfRange(), PatternMismatch(), InvalidEnum(), PathNotFound(), PathOutsideWorkspace(),
    StringTooShort(), StringTooLong(), ArrayTooFew(), ArrayTooMany(), ItemsNotUnique()

- `ToolValidationWarning` with:
  - ParameterName, Message, WarningCode, Severity properties
  - Factory methods: Deprecated(), LargeValue(), SlowOperation(), SecurityConcern(),
    Compatibility(), Custom()

- `IToolValidator` interface with:
  - ValidateAgainstSchema() for complete schema validation
  - ValidateParameter() for single parameter validation
  - Specialized validators: ValidatePath(), ValidateEnum(), ValidateRange(),
    ValidateStringLength(), ValidatePattern(), ValidateArrayLength()

- `ToolValidator` implementation with:
  - JSON Schema Draft 7 compatible validation
  - Path security validation (workspace boundary enforcement)
  - Compiled regex caching for performance
  - Nested object and array validation

### Changed
- Removed forward declarations from `ToolTypes.cs`
```

---

## Implementation Notes

### Error Code Conventions

All error codes use snake_case:
- `required` - Missing required parameter
- `invalid_value` - General invalid value
- `type_mismatch` - Wrong JSON type
- `out_of_range` - Numeric range violation
- `pattern_mismatch` - Regex pattern failure
- `invalid_enum` - Not in allowed set
- `path_not_found` - Path doesn't exist
- `path_outside_workspace` - Security violation

### Path Security

Path validation is critical for preventing:
- Path traversal attacks (`../../../etc/passwd`)
- Absolute path escapes (`/etc/passwd`, `C:\Windows\System32`)
- Symbolic link escapes

The validator resolves paths to absolute form and compares with the workspace root.

### Performance Considerations

- Regex patterns are compiled and cached
- Validation stops early on type mismatches
- Array item validation is lazy

### LLM Error Formatting

The `ToLlmContext()` method formats errors for LLM consumption:
```
Parameter validation failed:
- path: Path is outside the workspace: ../../../etc/passwd
  Expected: Path within workspace directory
```

This helps the LLM understand and correct parameter errors.

---

## Timeline Estimate

| Task | Estimated Effort |
|------|------------------|
| ToolValidationResult | 0.25 day |
| ToolValidationError | 0.25 day |
| ToolValidationWarning | 0.1 day |
| IToolValidator | 0.1 day |
| ToolValidator | 0.5 day |
| Unit Tests | 0.5 day |
| **Total** | **1.7 days** |
