# Design Specification: AIntern v0.6.4b "Risk Classification Engine"

## Overview

**Version**: v0.6.4b
**Parent**: v0.6.4 Safety & Approval
**Focus**: Risk classification logic that analyzes tool calls and determines effective risk levels

### Purpose

Implement the RiskClassifier that:
1. Analyzes tool call requests to determine their effective risk level
2. Evaluates policy rules (blocked tools, trusted tools, overrides)
3. Detects dangerous command patterns in terminal operations
4. Checks operations against protected path patterns
5. Aggregates multiple risk factors into a final classification
6. Caches compiled regex patterns for performance
7. Provides detailed factor breakdown for transparency

### Dependencies

**From v0.6.4a (Permission Policy Models)**:
- `PermissionPolicy`
- `BlockedPattern`, `ProtectedPath`
- `ToolPermissionOverride`, `OverrideAction`

**From v0.6.1 (Tool Framework)**:
- `ITool`, `RiskLevel`, `ToolCategory`
- `ToolCallRequest`

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                   v0.6.4b Risk Classification Architecture                    │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Input: ToolCallRequest + ITool                                              │
│      │                                                                       │
│      ▼                                                                       │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                          RiskClassifier                                  │ │
│  │  ┌─────────────────────────────────────────────────────────────────────┐│ │
│  │  │                                                                      ││ │
│  │  │  1. Policy Checks (Immediate Decisions)                             ││ │
│  │  │     ├── Is tool in BlockedTools? → Blocked                          ││ │
│  │  │     ├── Is category in DisabledCategories? → Blocked               ││ │
│  │  │     ├── ToolOverride = Block? → Blocked                            ││ │
│  │  │     ├── ToolOverride = AlwaysAllow? → Safe + Trusted               ││ │
│  │  │     └── Is tool in TrustedTools? → Safe + Trusted                  ││ │
│  │  │                                                                      ││ │
│  │  │  2. Category-Specific Analysis                                       ││ │
│  │  │     ├── Terminal → ClassifyTerminalCommand()                        ││ │
│  │  │     │   ├── Check BlockedCommandPatterns                            ││ │
│  │  │     │   ├── Detect sudo/admin commands                              ││ │
│  │  │     │   ├── Detect package installation                             ││ │
│  │  │     │   ├── Detect git push/force push                              ││ │
│  │  │     │   └── Detect network commands                                 ││ │
│  │  │     │                                                                ││ │
│  │  │     ├── FileSystem → ClassifyFileOperation()                        ││ │
│  │  │     │   ├── Check ProtectedPaths                                    ││ │
│  │  │     │   └── Check sensitive file extensions                         ││ │
│  │  │     │                                                                ││ │
│  │  │     ├── Git → ClassifyGitOperation()                                ││ │
│  │  │     │   ├── Detect push operations                                  ││ │
│  │  │     │   └── Detect history-modifying operations                     ││ │
│  │  │     │                                                                ││ │
│  │  │     └── Network → ClassifyNetworkOperation()                        ││ │
│  │  │                                                                      ││ │
│  │  │  3. Tool-Specific Analysis                                           ││ │
│  │  │     └── tool.GetEffectiveRiskLevel(parameters)                      ││ │
│  │  │                                                                      ││ │
│  │  └─────────────────────────────────────────────────────────────────────┘│ │
│  │                                                                          │ │
│  │  Regex Cache: ConcurrentDictionary<string, Regex>                        │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│      │                                                                       │
│      ▼                                                                       │
│  Output: RiskClassificationResult                                            │
│  ├── FinalRisk: RiskLevel                                                   │
│  ├── IsBlocked: bool                                                        │
│  ├── BlockReason: string?                                                   │
│  ├── IsTrusted: bool                                                        │
│  └── Factors: RiskFactor[]                                                  │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Classification Flow

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                   Risk Classification Decision Flow                          │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Classify(request, tool)                                                     │
│      │                                                                       │
│      ▼                                                                       │
│  ┌───────────────────────────────┐                                           │
│  │ 1. Check BlockedTools         │                                           │
│  │    tool.Id in BlockedTools?   │                                           │
│  └───────────────┬───────────────┘                                           │
│         Yes ─────┤                                                           │
│         │        │ No                                                        │
│         ▼        ▼                                                           │
│  ┌──────────┐  ┌───────────────────────────────┐                             │
│  │ BLOCKED  │  │ 2. Check DisabledCategories   │                             │
│  └──────────┘  │    tool.Category disabled?    │                             │
│                └───────────────┬───────────────┘                             │
│                       Yes ─────┤                                             │
│                       │        │ No                                          │
│                       ▼        ▼                                             │
│                ┌──────────┐  ┌───────────────────────────────┐               │
│                │ BLOCKED  │  │ 3. Check ToolOverrides        │               │
│                └──────────┘  │    override.Action = ?       │               │
│                              └───────────────┬───────────────┘               │
│                                              │                               │
│              ┌────────────────┬──────────────┼────────────────┐              │
│              ▼                ▼              ▼                ▼              │
│         [Block]        [AlwaysAllow]   [AlwaysAsk]     [UseDefault]          │
│              │                │              │                │              │
│              ▼                ▼              ▼                ▼              │
│         ┌──────────┐   ┌──────────────┐ ┌─────────┐   ┌──────────────┐       │
│         │ BLOCKED  │   │ SAFE+TRUSTED │ │ Factor: │   │ Continue with│       │
│         └──────────┘   └──────────────┘ │ AlwaysAsk│   │ base risk   │       │
│                                          └─────────┘   └──────┬───────┘       │
│                                                               │              │
│                                                               ▼              │
│                              ┌───────────────────────────────────────────┐   │
│                              │ 4. Check TrustedTools                     │   │
│                              │    tool.Id in TrustedTools?               │   │
│                              └───────────────────┬───────────────────────┘   │
│                                         Yes ─────┤                           │
│                                         │        │ No                        │
│                                         ▼        ▼                           │
│                                  ┌──────────────┐ │                          │
│                                  │ SAFE+TRUSTED │ │                          │
│                                  └──────────────┘ │                          │
│                                                   ▼                          │
│                              ┌───────────────────────────────────────────┐   │
│                              │ 5. Category-Specific Classification       │   │
│                              │    Terminal / FileSystem / Git / Network  │   │
│                              └───────────────────┬───────────────────────┘   │
│                                                  ▼                           │
│                              ┌───────────────────────────────────────────┐   │
│                              │ 6. Tool-Specific Risk Analysis            │   │
│                              │    tool.GetEffectiveRiskLevel()           │   │
│                              └───────────────────┬───────────────────────┘   │
│                                                  ▼                           │
│                              ┌───────────────────────────────────────────┐   │
│                              │ 7. Return RiskClassificationResult        │   │
│                              │    Max(baseRisk, categoryRisk, toolRisk)  │   │
│                              └───────────────────────────────────────────┘   │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Terminal Command Analysis

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                    Terminal Command Risk Patterns                             │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Pattern Category         Regex Pattern                    Risk Level        │
│  ────────────────────────────────────────────────────────────────────────── │
│                                                                              │
│  BLOCKED (Immediate block, no override):                                     │
│  ├── rm -rf /             rm\s+-rf\s+/                     Critical (Block) │
│  ├── rm -rf ~             rm\s+-rf\s+~                     Critical (Block) │
│  ├── sudo rm -rf          sudo\s+rm\s+-rf                  Critical (Block) │
│  ├── format drive         format\s+[a-zA-Z]:               Critical (Block) │
│  ├── mkfs                 mkfs\.                           Critical (Block) │
│  ├── fork bomb            :\(\)\{:\|:&\};:                 Critical (Block) │
│  ├── dd to device         dd\s+if=.*/dev/                  Critical (Block) │
│  ├── write to block       >\s*/dev/sd[a-z]                 Critical (Block) │
│  ├── chmod 777 /          chmod\s+(-R\s+)?777\s+/          Critical (Block) │
│  └── chown root /         chown\s+(-R\s+)?root\s+/         Critical (Block) │
│                                                                              │
│  ELEVATED (Increase risk level):                                             │
│  ├── sudo/admin           sudo\s+|su\s+-                   → Critical       │
│  ├── package install      (npm|pip|gem|cargo|apt|yum|brew)\s+(install|add)  │
│  │                                                         → High           │
│  ├── git push             git\s+push                       → High           │
│  ├── git force push       --force|-f                       → Critical       │
│  ├── network commands     (curl|wget|nc|netcat|ssh|scp)   → High           │
│  └── file deletion        rm\b.*-[rf]                     → High           │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Specifications

### 1. RiskClassifier.cs

**Location**: `src/SeniorIntern.Services/Permissions/RiskClassifier.cs`

```csharp
namespace SeniorIntern.Services.Permissions;

using System.Collections.Concurrent;
using System.Text.Json;
using System.Text.RegularExpressions;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models.Permissions;
using SeniorIntern.Core.Tools;

/// <summary>
/// Classifies the risk level of tool call requests.
/// Analyzes parameters, patterns, and policy to determine effective risk.
/// </summary>
/// <remarks>
/// <para>
/// The RiskClassifier performs a multi-stage analysis:
/// </para>
/// <list type="number">
/// <item>Policy checks (blocked tools, disabled categories, overrides)</item>
/// <item>Category-specific analysis (terminal, filesystem, git, network)</item>
/// <item>Tool-specific parameter analysis</item>
/// <item>Aggregation of all risk factors</item>
/// </list>
/// </remarks>
public sealed class RiskClassifier : IRiskClassifier
{
    #region Dependencies

    private readonly PermissionPolicy _policy;
    private readonly ILogger<RiskClassifier> _logger;

    #endregion

    #region Regex Cache

    /// <summary>
    /// Compiled regex cache for performance.
    /// </summary>
    private readonly ConcurrentDictionary<string, Regex> _regexCache = new();

    #endregion

    #region Constants

    /// <summary>
    /// Maximum command length to log.
    /// </summary>
    private const int MaxLogLength = 100;

    /// <summary>
    /// Sensitive file extensions that elevate risk.
    /// </summary>
    private static readonly HashSet<string> SensitiveExtensions = new(StringComparer.OrdinalIgnoreCase)
    {
        ".pem", ".key", ".crt", ".pfx", ".p12", ".jks",
        ".keystore", ".cer", ".der", ".p7b", ".p7c"
    };

    #endregion

    public RiskClassifier(
        IOptions<PermissionPolicy> policy,
        ILogger<RiskClassifier> logger)
    {
        _policy = policy?.Value ?? throw new ArgumentNullException(nameof(policy));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    #region Public API

    /// <summary>
    /// Classify the risk of a tool call request.
    /// </summary>
    /// <param name="request">The tool call request to classify.</param>
    /// <param name="tool">The tool being invoked.</param>
    /// <returns>Classification result with risk level and factors.</returns>
    public RiskClassificationResult Classify(ToolCallRequest request, ITool tool)
    {
        ArgumentNullException.ThrowIfNull(request);
        ArgumentNullException.ThrowIfNull(tool);

        _logger.LogDebug(
            "Classifying risk for tool {ToolId} with request {RequestId}",
            tool.Id, request.RequestId);

        var factors = new List<RiskFactor>();
        var baseRisk = tool.DefaultRiskLevel;

        // Stage 1: Policy Checks (can result in immediate decision)
        var policyResult = EvaluatePolicyRules(request, tool, factors);
        if (policyResult.HasValue)
        {
            return policyResult.Value;
        }

        // Stage 2: Category-Specific Analysis
        var categoryResult = ClassifyByCategory(request, tool, factors);
        if (categoryResult.IsBlocked)
        {
            return categoryResult;
        }
        baseRisk = MaxRisk(baseRisk, categoryResult.FinalRisk);

        // Stage 3: Tool-Specific Parameter Analysis
        var toolEffectiveRisk = tool.GetEffectiveRiskLevel(request.Parameters);
        if (toolEffectiveRisk > baseRisk)
        {
            baseRisk = toolEffectiveRisk;
            factors.Add(new RiskFactor("Tool parameter analysis", toolEffectiveRisk));
        }

        _logger.LogDebug(
            "Risk classification complete: tool={Tool}, finalRisk={Risk}, factors={FactorCount}",
            tool.Id, baseRisk, factors.Count);

        return new RiskClassificationResult
        {
            FinalRisk = baseRisk,
            IsBlocked = false,
            Factors = factors
        };
    }

    #endregion

    #region Stage 1: Policy Rules

    /// <summary>
    /// Evaluate policy rules for immediate decisions.
    /// </summary>
    private RiskClassificationResult? EvaluatePolicyRules(
        ToolCallRequest request, ITool tool, List<RiskFactor> factors)
    {
        // Check if tool is blocked
        if (_policy.BlockedTools.Contains(tool.Id))
        {
            _logger.LogWarning("Tool {ToolId} is blocked by policy", tool.Id);
            return RiskClassificationResult.Blocked(
                "Tool is blocked by policy",
                new RiskFactor("Blocked tool", RiskLevel.Critical));
        }

        // Check if category is disabled
        if (_policy.DisabledCategories.Contains(tool.Category))
        {
            _logger.LogWarning(
                "Tool {ToolId} category {Category} is disabled",
                tool.Id, tool.Category);
            return RiskClassificationResult.Blocked(
                $"Tool category '{tool.Category}' is disabled",
                new RiskFactor("Disabled category", RiskLevel.Critical));
        }

        // Check tool-specific override
        if (_policy.ToolOverrides.TryGetValue(tool.Id, out var toolOverride))
        {
            // Check if override has expired
            if (!toolOverride.IsExpired)
            {
                var overrideResult = EvaluateOverride(toolOverride, tool, factors);
                if (overrideResult.HasValue)
                {
                    return overrideResult.Value;
                }
            }
        }

        // Check if tool is trusted
        if (_policy.TrustedTools.Contains(tool.Id))
        {
            _logger.LogDebug("Tool {ToolId} is trusted", tool.Id);
            return new RiskClassificationResult
            {
                FinalRisk = RiskLevel.Safe,
                IsBlocked = false,
                IsTrusted = true,
                Factors = new[] { new RiskFactor("Trusted tool", RiskLevel.Safe) }
            };
        }

        return null; // Continue to next stage
    }

    /// <summary>
    /// Evaluate a tool override.
    /// </summary>
    private RiskClassificationResult? EvaluateOverride(
        ToolPermissionOverride toolOverride, ITool tool, List<RiskFactor> factors)
    {
        switch (toolOverride.Action)
        {
            case OverrideAction.Block:
                _logger.LogWarning(
                    "Tool {ToolId} blocked by override: {Reason}",
                    tool.Id, toolOverride.Reason);
                return RiskClassificationResult.Blocked(
                    toolOverride.Reason ?? "Blocked by tool override",
                    new RiskFactor("Tool override: Block", RiskLevel.Critical));

            case OverrideAction.AlwaysAllow:
                _logger.LogDebug("Tool {ToolId} always allowed by override", tool.Id);
                return new RiskClassificationResult
                {
                    FinalRisk = RiskLevel.Safe,
                    IsBlocked = false,
                    IsTrusted = true,
                    Factors = new[] { new RiskFactor("Tool override: AlwaysAllow", RiskLevel.Safe) }
                };

            case OverrideAction.AlwaysAsk:
                factors.Add(new RiskFactor("Tool override: AlwaysAsk", RiskLevel.High));
                // Don't return - let normal flow continue with elevated risk
                return null;

            case OverrideAction.UseDefault when toolOverride.CustomRiskLevel.HasValue:
                factors.Add(new RiskFactor(
                    $"Custom risk level: {toolOverride.CustomRiskLevel.Value}",
                    toolOverride.CustomRiskLevel.Value));
                return null;

            default:
                return null;
        }
    }

    #endregion

    #region Stage 2: Category-Specific Analysis

    /// <summary>
    /// Classify based on tool category.
    /// </summary>
    private RiskClassificationResult ClassifyByCategory(
        ToolCallRequest request, ITool tool, List<RiskFactor> factors)
    {
        return tool.Category switch
        {
            ToolCategory.Terminal => ClassifyTerminalCommand(request, factors),
            ToolCategory.FileSystem => ClassifyFileOperation(request, tool, factors),
            ToolCategory.Git => ClassifyGitOperation(request, factors),
            ToolCategory.Network => ClassifyNetworkOperation(request, factors),
            _ => new RiskClassificationResult { FinalRisk = tool.DefaultRiskLevel, Factors = factors }
        };
    }

    #endregion

    #region Terminal Command Classification

    /// <summary>
    /// Classify a terminal command for risk.
    /// </summary>
    private RiskClassificationResult ClassifyTerminalCommand(
        ToolCallRequest request, List<RiskFactor> factors)
    {
        if (!request.Parameters.TryGetProperty("command", out var cmdProp))
        {
            return new RiskClassificationResult
            {
                FinalRisk = RiskLevel.High,
                Factors = factors
            };
        }

        var command = cmdProp.GetString() ?? string.Empty;

        // Check blocked patterns first
        foreach (var blocked in _policy.BlockedCommandPatterns.Where(p => p.IsEnabled))
        {
            if (blocked.Matches(command))
            {
                _logger.LogWarning(
                    "Blocked dangerous command pattern: {Pattern} in: {Command}",
                    blocked.Name, TruncateForLog(command));

                return RiskClassificationResult.Blocked(
                    $"Command matches blocked pattern: {blocked.Name}. {blocked.Reason}",
                    new RiskFactor(blocked.Name, RiskLevel.Critical));
            }
        }

        var risk = RiskLevel.High; // Terminal commands are high risk by default
        var commandLower = command.ToLowerInvariant();

        // Analyze specific command patterns
        AnalyzeSudoCommands(commandLower, factors, ref risk);
        AnalyzePackageInstallation(command, factors);
        AnalyzeGitPushCommands(commandLower, factors, ref risk);
        AnalyzeNetworkCommands(command, factors);
        AnalyzeFileDeletion(command, factors);

        return new RiskClassificationResult
        {
            FinalRisk = risk,
            Factors = factors
        };
    }

    /// <summary>
    /// Analyze sudo/admin commands.
    /// </summary>
    private void AnalyzeSudoCommands(
        string command, List<RiskFactor> factors, ref RiskLevel risk)
    {
        if (command.StartsWith("sudo ") || command.Contains(" sudo ") ||
            command.StartsWith("su -") || command.Contains(" su -"))
        {
            risk = RiskLevel.Critical;
            factors.Add(new RiskFactor("Sudo/admin command", RiskLevel.Critical));
        }
    }

    /// <summary>
    /// Analyze package installation commands.
    /// </summary>
    private void AnalyzePackageInstallation(string command, List<RiskFactor> factors)
    {
        var packagePattern = @"\b(npm|pip|gem|cargo|apt|yum|brew|pnpm|yarn)\s+(install|add|i)\b";
        if (MatchesPattern(command, packagePattern))
        {
            factors.Add(new RiskFactor("Package installation", RiskLevel.High));
        }
    }

    /// <summary>
    /// Analyze git push commands.
    /// </summary>
    private void AnalyzeGitPushCommands(
        string command, List<RiskFactor> factors, ref RiskLevel risk)
    {
        if (command.Contains("git push"))
        {
            factors.Add(new RiskFactor("Git push to remote", RiskLevel.High));

            if (command.Contains("--force") || Regex.IsMatch(command, @"\s-f\s"))
            {
                risk = RiskLevel.Critical;
                factors.Add(new RiskFactor("Force push", RiskLevel.Critical));
            }
        }
    }

    /// <summary>
    /// Analyze network commands.
    /// </summary>
    private void AnalyzeNetworkCommands(string command, List<RiskFactor> factors)
    {
        var networkPattern = @"\b(curl|wget|nc|netcat|ssh|scp|rsync|ftp)\b";
        if (MatchesPattern(command, networkPattern))
        {
            factors.Add(new RiskFactor("Network command", RiskLevel.High));
        }
    }

    /// <summary>
    /// Analyze file deletion commands.
    /// </summary>
    private void AnalyzeFileDeletion(string command, List<RiskFactor> factors)
    {
        if (MatchesPattern(command, @"\brm\b.*-[rf]"))
        {
            factors.Add(new RiskFactor("File deletion with flags", RiskLevel.High));
        }
    }

    #endregion

    #region File Operation Classification

    /// <summary>
    /// Classify a file operation for risk.
    /// </summary>
    private RiskClassificationResult ClassifyFileOperation(
        ToolCallRequest request, ITool tool, List<RiskFactor> factors)
    {
        var path = ExtractPath(request.Parameters);

        if (string.IsNullOrEmpty(path))
        {
            return new RiskClassificationResult
            {
                FinalRisk = tool.DefaultRiskLevel,
                Factors = factors
            };
        }

        var risk = tool.DefaultRiskLevel;

        // Check protected paths
        foreach (var protectedPath in _policy.ProtectedPaths.Where(pp => pp.IsEnabled))
        {
            if (protectedPath.Matches(path))
            {
                factors.Add(new RiskFactor(
                    $"Protected path: {protectedPath.Description}",
                    protectedPath.ElevatedRiskLevel));

                risk = MaxRisk(risk, protectedPath.ElevatedRiskLevel);

                _logger.LogDebug(
                    "Path {Path} matches protected pattern: {Pattern}",
                    TruncateForLog(path), protectedPath.Pattern);
            }
        }

        // Check for write operations to sensitive extensions
        if (IsWriteOperation(tool.Id))
        {
            var extension = Path.GetExtension(path);
            if (SensitiveExtensions.Contains(extension))
            {
                factors.Add(new RiskFactor("Sensitive file extension", RiskLevel.High));
                risk = MaxRisk(risk, RiskLevel.High);
            }
        }

        return new RiskClassificationResult
        {
            FinalRisk = risk,
            Factors = factors
        };
    }

    /// <summary>
    /// Extract path from parameters.
    /// </summary>
    private static string? ExtractPath(JsonElement parameters)
    {
        if (parameters.TryGetProperty("path", out var pathProp))
            return pathProp.GetString();
        if (parameters.TryGetProperty("source", out var sourceProp))
            return sourceProp.GetString();
        if (parameters.TryGetProperty("file", out var fileProp))
            return fileProp.GetString();
        return null;
    }

    /// <summary>
    /// Check if tool is a write operation.
    /// </summary>
    private static bool IsWriteOperation(string toolId) =>
        toolId is "file-write" or "file-patch" or "file-delete" or "file-move";

    #endregion

    #region Git Operation Classification

    /// <summary>
    /// Classify a Git operation for risk.
    /// </summary>
    private RiskClassificationResult ClassifyGitOperation(
        ToolCallRequest request, List<RiskFactor> factors)
    {
        var risk = RiskLevel.Safe; // Most git tools are read-only

        // Git operations that modify remote
        if (request.ToolId is "git-push")
        {
            risk = RiskLevel.High;
            factors.Add(new RiskFactor("Git push operation", RiskLevel.High));

            // Check for force push
            if (request.Parameters.TryGetProperty("force", out var forceProp) &&
                forceProp.GetBoolean())
            {
                risk = RiskLevel.Critical;
                factors.Add(new RiskFactor("Force push", RiskLevel.Critical));
            }
        }

        // Git operations that modify history
        if (request.ToolId is "git-rebase" or "git-reset" or "git-amend")
        {
            risk = RiskLevel.High;
            factors.Add(new RiskFactor("Git history modification", RiskLevel.High));
        }

        return new RiskClassificationResult
        {
            FinalRisk = risk,
            Factors = factors
        };
    }

    #endregion

    #region Network Operation Classification

    /// <summary>
    /// Classify a network operation for risk.
    /// </summary>
    private RiskClassificationResult ClassifyNetworkOperation(
        ToolCallRequest request, List<RiskFactor> factors)
    {
        factors.Add(new RiskFactor("Network operation", RiskLevel.Medium));

        // Check for external URLs
        if (request.Parameters.TryGetProperty("url", out var urlProp))
        {
            var url = urlProp.GetString();
            if (!string.IsNullOrEmpty(url) && !url.StartsWith("http://localhost") &&
                !url.StartsWith("http://127.0.0.1"))
            {
                factors.Add(new RiskFactor("External network request", RiskLevel.High));
                return new RiskClassificationResult
                {
                    FinalRisk = RiskLevel.High,
                    Factors = factors
                };
            }
        }

        return new RiskClassificationResult
        {
            FinalRisk = RiskLevel.Medium,
            Factors = factors
        };
    }

    #endregion

    #region Helper Methods

    /// <summary>
    /// Check if a string matches a regex pattern.
    /// </summary>
    private bool MatchesPattern(string input, string pattern)
    {
        var regex = GetOrCreateRegex(pattern);
        return regex.IsMatch(input);
    }

    /// <summary>
    /// Get or create a compiled regex.
    /// </summary>
    private Regex GetOrCreateRegex(string pattern)
    {
        return _regexCache.GetOrAdd(pattern, p =>
            new Regex(p, RegexOptions.Compiled | RegexOptions.IgnoreCase));
    }

    /// <summary>
    /// Get the maximum of two risk levels.
    /// </summary>
    private static RiskLevel MaxRisk(RiskLevel a, RiskLevel b) =>
        (RiskLevel)Math.Max((int)a, (int)b);

    /// <summary>
    /// Truncate a string for logging.
    /// </summary>
    private static string TruncateForLog(string value) =>
        value.Length <= MaxLogLength
            ? value
            : value[..(MaxLogLength - 3)] + "...";

    #endregion
}
```

### 2. IRiskClassifier.cs

**Location**: `src/SeniorIntern.Core/Interfaces/IRiskClassifier.cs`

```csharp
namespace SeniorIntern.Core.Interfaces;

using SeniorIntern.Core.Models.Permissions;
using SeniorIntern.Core.Tools;

/// <summary>
/// Service for classifying the risk level of tool call requests.
/// </summary>
public interface IRiskClassifier
{
    /// <summary>
    /// Classify the risk of a tool call request.
    /// </summary>
    /// <param name="request">The tool call request to classify.</param>
    /// <param name="tool">The tool being invoked.</param>
    /// <returns>Classification result with risk level and factors.</returns>
    RiskClassificationResult Classify(ToolCallRequest request, ITool tool);
}
```

### 3. RiskClassificationResult.cs

**Location**: `src/SeniorIntern.Core/Models/Permissions/RiskClassificationResult.cs`

```csharp
namespace SeniorIntern.Core.Models.Permissions;

using SeniorIntern.Core.Tools;

/// <summary>
/// Result of risk classification for a tool call.
/// </summary>
/// <remarks>
/// Contains the final risk assessment, blocking status, and detailed
/// breakdown of factors that contributed to the classification.
/// </remarks>
public sealed class RiskClassificationResult
{
    /// <summary>
    /// Final calculated risk level.
    /// </summary>
    /// <remarks>
    /// This is the maximum of all contributing factors and overrides.
    /// </remarks>
    public RiskLevel FinalRisk { get; init; }

    /// <summary>
    /// Whether the operation is blocked entirely.
    /// </summary>
    /// <remarks>
    /// Blocked operations cannot proceed regardless of user approval.
    /// This occurs when matching blocked patterns or blocked tools.
    /// </remarks>
    public bool IsBlocked { get; init; }

    /// <summary>
    /// Reason for blocking (if blocked).
    /// </summary>
    public string? BlockReason { get; init; }

    /// <summary>
    /// Whether this tool is trusted (auto-approved).
    /// </summary>
    /// <remarks>
    /// Trusted tools bypass the normal approval flow.
    /// </remarks>
    public bool IsTrusted { get; init; }

    /// <summary>
    /// Factors that contributed to the risk assessment.
    /// </summary>
    /// <remarks>
    /// Provides transparency into why a particular risk level was assigned.
    /// Useful for audit logging and user understanding.
    /// </remarks>
    public IReadOnlyList<RiskFactor> Factors { get; init; } = Array.Empty<RiskFactor>();

    /// <summary>
    /// Create a blocked result.
    /// </summary>
    /// <param name="reason">Reason for blocking.</param>
    /// <param name="factors">Contributing factors.</param>
    public static RiskClassificationResult Blocked(string reason, params RiskFactor[] factors) => new()
    {
        FinalRisk = RiskLevel.Critical,
        IsBlocked = true,
        BlockReason = reason,
        Factors = factors
    };

    /// <summary>
    /// Create a safe/trusted result.
    /// </summary>
    /// <param name="reason">Reason for trusting.</param>
    public static RiskClassificationResult Trusted(string reason) => new()
    {
        FinalRisk = RiskLevel.Safe,
        IsBlocked = false,
        IsTrusted = true,
        Factors = new[] { new RiskFactor(reason, RiskLevel.Safe) }
    };

    /// <summary>
    /// Create a result with a specific risk level.
    /// </summary>
    public static RiskClassificationResult WithRisk(RiskLevel risk, params RiskFactor[] factors) => new()
    {
        FinalRisk = risk,
        IsBlocked = false,
        Factors = factors
    };

    /// <summary>
    /// Check if approval is required based on threshold.
    /// </summary>
    public bool RequiresApproval(RiskLevel threshold) =>
        !IsTrusted && !IsBlocked && FinalRisk > threshold;
}
```

### 4. RiskFactor.cs

**Location**: `src/SeniorIntern.Core/Models/Permissions/RiskFactor.cs`

```csharp
namespace SeniorIntern.Core.Models.Permissions;

using SeniorIntern.Core.Tools;

/// <summary>
/// A factor contributing to risk assessment.
/// </summary>
/// <remarks>
/// Risk factors provide detailed insight into why a particular risk level
/// was assigned. They are collected during classification and stored for
/// audit and display purposes.
/// </remarks>
public sealed record RiskFactor
{
    /// <summary>
    /// Description of this risk factor.
    /// </summary>
    /// <example>Sudo/admin command, Protected path: SSH keys</example>
    public string Description { get; init; }

    /// <summary>
    /// Risk level contribution of this factor.
    /// </summary>
    public RiskLevel Contribution { get; init; }

    /// <summary>
    /// Category of this factor.
    /// </summary>
    public RiskFactorCategory Category { get; init; } = RiskFactorCategory.General;

    /// <summary>
    /// Additional details about this factor.
    /// </summary>
    public string? Details { get; init; }

    public RiskFactor(string description, RiskLevel contribution)
    {
        Description = description ?? throw new ArgumentNullException(nameof(description));
        Contribution = contribution;
    }

    public RiskFactor(string description, RiskLevel contribution, RiskFactorCategory category)
        : this(description, contribution)
    {
        Category = category;
    }

    /// <summary>
    /// Create a factor for a blocked pattern match.
    /// </summary>
    public static RiskFactor FromBlockedPattern(BlockedPattern pattern) => new(
        pattern.Name,
        RiskLevel.Critical,
        RiskFactorCategory.BlockedPattern)
    {
        Details = pattern.Reason
    };

    /// <summary>
    /// Create a factor for a protected path match.
    /// </summary>
    public static RiskFactor FromProtectedPath(ProtectedPath path) => new(
        $"Protected path: {path.Description}",
        path.ElevatedRiskLevel,
        RiskFactorCategory.ProtectedPath)
    {
        Details = path.Pattern
    };
}

/// <summary>
/// Categories of risk factors.
/// </summary>
public enum RiskFactorCategory
{
    /// <summary>General risk factor.</summary>
    General,

    /// <summary>Factor from policy configuration.</summary>
    PolicyOverride,

    /// <summary>Factor from blocked pattern match.</summary>
    BlockedPattern,

    /// <summary>Factor from protected path match.</summary>
    ProtectedPath,

    /// <summary>Factor from command analysis.</summary>
    CommandAnalysis,

    /// <summary>Factor from tool parameter analysis.</summary>
    ParameterAnalysis
}
```

---

## Risk Level Aggregation

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                        Risk Level Aggregation Logic                           │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Final Risk = Max(baseRisk, overrideRisk, categoryRisk, toolRisk)            │
│                                                                              │
│  Example:                                                                     │
│  ┌────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                         │ │
│  │  Tool: file-write                                                       │ │
│  │  ├── Base Risk: Medium                                                  │ │
│  │  │                                                                      │ │
│  │  │  Classification Factors:                                             │ │
│  │  │  ├── Protected path (~/.ssh/config) → High                          │ │
│  │  │  └── Sensitive extension (.key) → High                              │ │
│  │  │                                                                      │ │
│  │  │  Tool Parameter Analysis:                                            │ │
│  │  │  └── Large file size → Medium                                       │ │
│  │  │                                                                      │ │
│  │  Final Risk = Max(Medium, High, High, Medium) = High                    │ │
│  │                                                                         │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  Factors collected for approval dialog:                                      │
│  ┌────────────────────────────────────────────────────────────────────────┐ │
│  │  1. Protected path: SSH keys and configuration          [High]         │ │
│  │  2. Sensitive file extension                             [High]         │ │
│  │  3. Large file size                                      [Medium]       │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Summary

| File | Location | Purpose | Lines |
|------|----------|---------|-------|
| `RiskClassifier.cs` | `Services/Permissions/` | Main classification logic | ~350 |
| `IRiskClassifier.cs` | `Core/Interfaces/` | Service interface | ~20 |
| `RiskClassificationResult.cs` | `Core/Models/Permissions/` | Result model | ~90 |
| `RiskFactor.cs` | `Core/Models/Permissions/` | Factor model | ~70 |

---

## Unit Test Plan

| Test | Description |
|------|-------------|
| `Classify_BlockedTool_ReturnsBlocked` | Tool in BlockedTools |
| `Classify_DisabledCategory_ReturnsBlocked` | Category disabled |
| `Classify_OverrideBlock_ReturnsBlocked` | Override with Block action |
| `Classify_OverrideAlwaysAllow_ReturnsTrusted` | Override with AlwaysAllow |
| `Classify_TrustedTool_ReturnsSafe` | Tool in TrustedTools |
| `ClassifyTerminal_BlockedPattern_ReturnsBlocked` | rm -rf / detection |
| `ClassifyTerminal_SudoCommand_ReturnsCritical` | Sudo detection |
| `ClassifyTerminal_GitForcePush_ReturnsCritical` | Force push detection |
| `ClassifyTerminal_PackageInstall_ReturnsHigh` | npm install detection |
| `ClassifyFile_ProtectedPath_ElevatesRisk` | ~/.ssh/* detection |
| `ClassifyFile_SensitiveExtension_ElevatesRisk` | .pem file detection |
| `ClassifyGit_Push_ReturnsHigh` | Git push detection |
| `ClassifyNetwork_ExternalUrl_ReturnsHigh` | External URL detection |
| `RegexCache_CompiledOnce_ReusedForPerformance` | Cache behavior |
| `FactorAggregation_MaxRiskUsed` | Risk level max logic |

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | RiskClassifier evaluates all policy rules |
| AC-2 | Blocked patterns are detected and blocked |
| AC-3 | Protected paths elevate risk level |
| AC-4 | Tool overrides are respected |
| AC-5 | Terminal commands are analyzed for dangerous patterns |
| AC-6 | Regex patterns are cached for performance |

---

## Changelog Entry

```markdown
## v0.6.4b - Risk Classification Engine

### Added
- `RiskClassifier` for comprehensive risk analysis
  - Policy rule evaluation (blocked tools, disabled categories)
  - Tool override handling (Block, AlwaysAllow, AlwaysAsk, UseDefault)
  - Trusted tool detection
- `IRiskClassifier` interface for dependency injection
- Terminal command analysis
  - Blocked pattern detection (10 built-in patterns)
  - Sudo/admin command detection
  - Package installation detection
  - Git force push detection
  - Network command detection
- File operation analysis
  - Protected path matching (13 built-in patterns)
  - Sensitive file extension detection
- Git operation analysis
  - Push operation detection
  - History modification detection
- Network operation analysis
  - External URL detection
- `RiskClassificationResult` model
  - Final risk level
  - Block status and reason
  - Trust status
  - Detailed factor breakdown
- `RiskFactor` model
  - Description and contribution level
  - Category classification
  - Factory methods for patterns and paths
- Compiled regex caching for performance
- Factor aggregation with max-risk logic
```

---

## Timeline Estimate

| Version | Estimated Effort |
|---------|------------------|
| v0.6.4b | 0.75 day |
