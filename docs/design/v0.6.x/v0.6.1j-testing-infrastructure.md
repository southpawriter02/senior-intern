# Design Specification: AIntern v0.6.1j "Testing Infrastructure"

## Overview

**Version**: v0.6.1j
**Parent**: v0.6.1 Tool Framework
**Focus**: Comprehensive testing infrastructure including mock tools, unit tests, and integration tests

### Purpose

This sub-version creates the testing infrastructure for the tool framework:
1. Create `MockTool` class for configurable test scenarios
2. Create `MockToolBuilder` for fluent test tool construction
3. Create test fixtures for all tool framework components
4. Create unit tests for models, services, and utilities
5. Create integration tests for end-to-end flows
6. Establish test helpers and common utilities

### Dependencies

**From v0.6.1a (Tool Core Models)**:
- `ITool` interface for mock implementation
- `ToolCategory` for categorization
- `RiskLevel` for risk classification

**From v0.6.1b (Tool Execution Context)**:
- `ToolExecutionContext` for test execution
- `ToolProgress` for progress testing

**From v0.6.1c (Tool Result System)**:
- `ToolResult` for result verification

**From v0.6.1d (Tool Validation)**:
- `ToolValidationResult` for validation testing
- `ToolValidationError` for error testing

**From v0.6.1e (JSON Schema System)**:
- `JsonSchema` for schema testing
- `JsonSchemaBuilder` for schema construction

**From v0.6.1f (Tool Base Class)**:
- `ToolBase` as mock tool base

**From v0.6.1g (Tool Registry Interface)**:
- `IToolRegistry` for registry testing
- `ToolAvailabilityContext` for filtering tests

**From v0.6.1h (Tool Registry Implementation)**:
- `ToolRegistry` for implementation testing

**From v0.6.1i (Tool Execution Service)**:
- `IToolExecutionService` for execution testing
- `ToolExecutionResult` for result testing

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│              v0.6.1j Testing Infrastructure Architecture                      │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  tests/AIntern.Tests/                                                        │
│  ├─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  Mocks/                                                                  │ │
│  │  ┌─────────────────────────────────────────────────────────────────────┐│ │
│  │  │                                                                      ││ │
│  │  │  MockTool : ToolBase                                                 ││ │
│  │  │  ├── Configurable behavior via constructor/delegates                ││ │
│  │  │  ├── Call tracking (ExecuteCallCount, ValidateCallCount)            ││ │
│  │  │  ├── Parameter capture (ExecutedParameters)                         ││ │
│  │  │  └── Factory methods (Succeeding, Failing, Throwing, Delayed)       ││ │
│  │  │                                                                      ││ │
│  │  │  MockToolBuilder                                                     ││ │
│  │  │  ├── Fluent API for tool construction                               ││ │
│  │  │  ├── WithId, WithName, WithDescription                              ││ │
│  │  │  ├── WithCategory, WithRiskLevel                                    ││ │
│  │  │  ├── WithSchema, WithExecute, WithValidate                          ││ │
│  │  │  └── Build()                                                        ││ │
│  │  │                                                                      ││ │
│  │  │  MockServiceProvider                                                 ││ │
│  │  │  └── Simple service provider for testing                            ││ │
│  │  │                                                                      ││ │
│  │  └─────────────────────────────────────────────────────────────────────┘│ │
│  │                                                                          │ │
│  │  Helpers/                                                                │ │
│  │  ┌─────────────────────────────────────────────────────────────────────┐│ │
│  │  │                                                                      ││ │
│  │  │  TestContextBuilder                                                  ││ │
│  │  │  ├── Build execution contexts for tests                             ││ │
│  │  │  ├── WithParameters, WithWorkspace, WithApproval                    ││ │
│  │  │  └── Build()                                                        ││ │
│  │  │                                                                      ││ │
│  │  │  JsonTestHelpers                                                     ││ │
│  │  │  ├── ParseJson(string) → JsonElement                                ││ │
│  │  │  ├── ToJsonElement(object) → JsonElement                            ││ │
│  │  │  └── AssertJsonEquals(expected, actual)                             ││ │
│  │  │                                                                      ││ │
│  │  │  ToolTestHelpers                                                     ││ │
│  │  │  ├── CreateRegistryWithTools(...)                                   ││ │
│  │  │  ├── CreateExecutionService(...)                                    ││ │
│  │  │  └── WaitForEvent(...)                                              ││ │
│  │  │                                                                      ││ │
│  │  └─────────────────────────────────────────────────────────────────────┘│ │
│  │                                                                          │ │
│  │  Unit/                                                                   │ │
│  │  ├── Tools/                                                             │ │
│  │  │   ├── ToolRegistryTests.cs                                          │ │
│  │  │   ├── ToolExecutionServiceTests.cs                                  │ │
│  │  │   ├── JsonSchemaBuilderTests.cs                                     │ │
│  │  │   ├── ToolValidationTests.cs                                        │ │
│  │  │   ├── ToolResultTests.cs                                            │ │
│  │  │   ├── ToolExecutionResultTests.cs                                   │ │
│  │  │   ├── ToolExecutionContextTests.cs                                  │ │
│  │  │   └── ToolBaseTests.cs                                              │ │
│  │  │                                                                       │ │
│  │  Integration/                                                            │ │
│  │  └── Tools/                                                             │ │
│  │      └── ToolFrameworkIntegrationTests.cs                              │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Test Coverage Strategy

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                       Test Coverage Strategy                                  │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Coverage Targets by Component                                               │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │                                                                         │  │
│  │  Component                    Target    Focus Areas                     │  │
│  │  ─────────────────────────────────────────────────────────────────────  │  │
│  │  ToolRegistry                 >90%      Registration, filtering, events │  │
│  │  ToolExecutionService         >90%      Execution, timeout, cancellation│  │
│  │  JsonSchemaBuilder            >85%      Builder patterns, all types     │  │
│  │  ToolValidator                >85%      All validation scenarios        │  │
│  │  ToolBase                     >80%      Parameter extraction, paths     │  │
│  │  ToolResult                   >95%      All factory methods             │  │
│  │  ToolExecutionResult          >95%      All factory methods             │  │
│  │  ToolExecutionContext         >80%      Path resolution, service access │  │
│  │                                                                         │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│                                                                              │
│  Test Categories                                                             │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │                                                                         │  │
│  │  1. Unit Tests                                                          │  │
│  │     ├── Model tests (constructors, properties, factories)              │  │
│  │     ├── Service tests (logic, error handling)                          │  │
│  │     ├── Builder tests (fluent API, validation)                         │  │
│  │     └── Extension tests (helpers, utilities)                           │  │
│  │                                                                         │  │
│  │  2. Integration Tests                                                   │  │
│  │     ├── Full execution lifecycle                                       │  │
│  │     ├── DI container integration                                       │  │
│  │     ├── Event propagation                                              │  │
│  │     └── Multi-tool scenarios                                           │  │
│  │                                                                         │  │
│  │  3. Edge Case Tests                                                     │  │
│  │     ├── Null/empty inputs                                              │  │
│  │     ├── Boundary conditions                                            │  │
│  │     ├── Race conditions (concurrent registration)                      │  │
│  │     └── Error propagation                                              │  │
│  │                                                                         │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Specifications

### 1. MockTool.cs

**Location**: `tests/AIntern.Tests/Mocks/MockTool.cs`

```csharp
namespace AIntern.Tests.Mocks;

using System.Text.Json;
using AIntern.Core.Tools;

/// <summary>
/// Configurable mock tool for testing.
/// </summary>
/// <remarks>
/// <para>
/// MockTool provides a flexible tool implementation for unit and integration
/// testing. It supports:
/// </para>
/// <list type="bullet">
/// <item><description>Custom execution behavior via delegates</description></item>
/// <item><description>Custom validation behavior via delegates</description></item>
/// <item><description>Call tracking for verification</description></item>
/// <item><description>Parameter capture for assertions</description></item>
/// </list>
/// <para>
/// Use the factory methods for common scenarios:
/// </para>
/// <code>
/// var successTool = MockTool.Succeeding("my-tool");
/// var failingTool = MockTool.Failing("my-tool", "Error message");
/// var slowTool = MockTool.Delayed("my-tool", TimeSpan.FromSeconds(5));
/// </code>
/// </remarks>
public sealed class MockTool : ToolBase
{
    private readonly string _id;
    private readonly string _name;
    private readonly string _description;
    private readonly ToolCategory _category;
    private readonly RiskLevel _riskLevel;
    private readonly JsonSchema _schema;
    private readonly bool _isAvailable;
    private readonly IReadOnlyList<string> _tags;
    private readonly Func<ToolExecutionContext, CancellationToken, Task<ToolResult>>? _executeFunc;
    private readonly Func<JsonElement, ToolValidationResult>? _validateFunc;
    private readonly Func<JsonElement, string>? _summaryFunc;
    private readonly Func<JsonElement, RiskLevel>? _riskFunc;

    /// <summary>
    /// Initializes a new instance of the <see cref="MockTool"/> class.
    /// </summary>
    /// <param name="id">Tool ID. Defaults to "mock-tool".</param>
    /// <param name="name">Tool display name. Defaults to "Mock Tool".</param>
    /// <param name="description">Tool description. Defaults to "A mock tool for testing".</param>
    /// <param name="category">Tool category. Defaults to Custom.</param>
    /// <param name="riskLevel">Default risk level. Defaults to Safe.</param>
    /// <param name="schema">Input schema. Defaults to empty schema.</param>
    /// <param name="isAvailable">Whether the tool is available. Defaults to true.</param>
    /// <param name="tags">Tool tags. Defaults to empty.</param>
    /// <param name="executeFunc">Custom execution function.</param>
    /// <param name="validateFunc">Custom validation function.</param>
    /// <param name="summaryFunc">Custom summary function.</param>
    /// <param name="riskFunc">Custom risk level function.</param>
    public MockTool(
        string id = "mock-tool",
        string name = "Mock Tool",
        string description = "A mock tool for testing",
        ToolCategory category = ToolCategory.Custom,
        RiskLevel riskLevel = RiskLevel.Safe,
        JsonSchema? schema = null,
        bool isAvailable = true,
        IReadOnlyList<string>? tags = null,
        Func<ToolExecutionContext, CancellationToken, Task<ToolResult>>? executeFunc = null,
        Func<JsonElement, ToolValidationResult>? validateFunc = null,
        Func<JsonElement, string>? summaryFunc = null,
        Func<JsonElement, RiskLevel>? riskFunc = null)
    {
        _id = id;
        _name = name;
        _description = description;
        _category = category;
        _riskLevel = riskLevel;
        _schema = schema ?? JsonSchema.Empty;
        _isAvailable = isAvailable;
        _tags = tags ?? Array.Empty<string>();
        _executeFunc = executeFunc;
        _validateFunc = validateFunc;
        _summaryFunc = summaryFunc;
        _riskFunc = riskFunc;
    }

    #region ITool Implementation

    /// <inheritdoc />
    public override string Id => _id;

    /// <inheritdoc />
    public override string Name => _name;

    /// <inheritdoc />
    public override string Description => _description;

    /// <inheritdoc />
    public override ToolCategory Category => _category;

    /// <inheritdoc />
    public override RiskLevel DefaultRiskLevel => _riskLevel;

    /// <inheritdoc />
    public override JsonSchema InputSchema => _schema;

    /// <inheritdoc />
    public override bool IsAvailable => _isAvailable;

    /// <inheritdoc />
    public override IReadOnlyList<string> Tags => _tags;

    #endregion

    #region Tracking Properties

    /// <summary>
    /// Number of times ExecuteAsync was called.
    /// </summary>
    public int ExecuteCallCount { get; private set; }

    /// <summary>
    /// Number of times Validate was called.
    /// </summary>
    public int ValidateCallCount { get; private set; }

    /// <summary>
    /// Number of times GetExecutionSummary was called.
    /// </summary>
    public int SummaryCallCount { get; private set; }

    /// <summary>
    /// Number of times GetEffectiveRiskLevel was called.
    /// </summary>
    public int RiskCallCount { get; private set; }

    /// <summary>
    /// Parameters passed to each ExecuteAsync call.
    /// </summary>
    public List<JsonElement> ExecutedParameters { get; } = new();

    /// <summary>
    /// Contexts passed to each ExecuteAsync call.
    /// </summary>
    public List<ToolExecutionContext> ExecutedContexts { get; } = new();

    /// <summary>
    /// Parameters passed to each Validate call.
    /// </summary>
    public List<JsonElement> ValidatedParameters { get; } = new();

    /// <summary>
    /// Reset all tracking counters and lists.
    /// </summary>
    public void Reset()
    {
        ExecuteCallCount = 0;
        ValidateCallCount = 0;
        SummaryCallCount = 0;
        RiskCallCount = 0;
        ExecutedParameters.Clear();
        ExecutedContexts.Clear();
        ValidatedParameters.Clear();
    }

    #endregion

    #region ToolBase Overrides

    /// <inheritdoc />
    protected override async Task<ToolResult> ExecuteCoreAsync(
        ToolExecutionContext context,
        CancellationToken ct)
    {
        ExecuteCallCount++;
        ExecutedParameters.Add(context.EffectiveParameters);
        ExecutedContexts.Add(context);

        if (_executeFunc != null)
        {
            return await _executeFunc(context, ct);
        }

        return ToolResult.Succeeded(new { executed = true }, "Mock tool executed");
    }

    /// <inheritdoc />
    public override ToolValidationResult Validate(JsonElement parameters)
    {
        ValidateCallCount++;
        ValidatedParameters.Add(parameters);

        if (_validateFunc != null)
        {
            return _validateFunc(parameters);
        }

        return base.Validate(parameters);
    }

    /// <inheritdoc />
    public override string GetExecutionSummary(JsonElement parameters)
    {
        SummaryCallCount++;

        if (_summaryFunc != null)
        {
            return _summaryFunc(parameters);
        }

        return base.GetExecutionSummary(parameters);
    }

    /// <inheritdoc />
    public override RiskLevel GetEffectiveRiskLevel(JsonElement parameters)
    {
        RiskCallCount++;

        if (_riskFunc != null)
        {
            return _riskFunc(parameters);
        }

        return base.GetEffectiveRiskLevel(parameters);
    }

    #endregion

    #region Factory Methods

    /// <summary>
    /// Create a mock tool that always succeeds.
    /// </summary>
    /// <param name="id">Tool ID.</param>
    /// <param name="data">Data to return in the result.</param>
    /// <returns>A mock tool that succeeds.</returns>
    public static MockTool Succeeding(string id = "success-tool", object? data = null) =>
        new(id, executeFunc: (_, _) => Task.FromResult(
            ToolResult.Succeeded(data ?? new { success = true })));

    /// <summary>
    /// Create a mock tool that always fails.
    /// </summary>
    /// <param name="id">Tool ID.</param>
    /// <param name="error">Error message.</param>
    /// <param name="errorCode">Optional error code.</param>
    /// <returns>A mock tool that fails.</returns>
    public static MockTool Failing(
        string id = "fail-tool",
        string error = "Test error",
        string? errorCode = null) =>
        new(id, executeFunc: (_, _) => Task.FromResult(
            ToolResult.Failed(error, errorCode)));

    /// <summary>
    /// Create a mock tool that throws an exception.
    /// </summary>
    /// <param name="id">Tool ID.</param>
    /// <param name="ex">Exception to throw. Defaults to a generic Exception.</param>
    /// <returns>A mock tool that throws.</returns>
    public static MockTool Throwing(string id = "throw-tool", Exception? ex = null) =>
        new(id, executeFunc: (_, _) => throw (ex ?? new Exception("Test exception")));

    /// <summary>
    /// Create a mock tool that delays execution.
    /// </summary>
    /// <param name="id">Tool ID.</param>
    /// <param name="delay">Delay duration. Defaults to 100ms.</param>
    /// <returns>A mock tool that delays.</returns>
    public static MockTool Delayed(string id = "delay-tool", TimeSpan delay = default) =>
        new(id, executeFunc: async (_, ct) =>
        {
            await Task.Delay(delay == default ? TimeSpan.FromMilliseconds(100) : delay, ct);
            return ToolResult.Succeeded();
        });

    /// <summary>
    /// Create a mock tool that reports progress.
    /// </summary>
    /// <param name="id">Tool ID.</param>
    /// <param name="steps">Number of progress steps.</param>
    /// <param name="stepDelay">Delay between steps.</param>
    /// <returns>A mock tool that reports progress.</returns>
    public static MockTool WithProgress(
        string id = "progress-tool",
        int steps = 5,
        TimeSpan stepDelay = default) =>
        new(id, executeFunc: async (ctx, ct) =>
        {
            var delay = stepDelay == default ? TimeSpan.FromMilliseconds(50) : stepDelay;
            for (int i = 1; i <= steps; i++)
            {
                ct.ThrowIfCancellationRequested();
                ctx.ReportProgress($"Step {i} of {steps}", (double)i / steps * 100);
                await Task.Delay(delay, ct);
            }
            return ToolResult.Succeeded(new { steps });
        });

    /// <summary>
    /// Create a mock tool that is unavailable.
    /// </summary>
    /// <param name="id">Tool ID.</param>
    /// <returns>An unavailable mock tool.</returns>
    public static MockTool Unavailable(string id = "unavailable-tool") =>
        new(id, isAvailable: false);

    /// <summary>
    /// Create a mock tool with specific category and risk level.
    /// </summary>
    /// <param name="id">Tool ID.</param>
    /// <param name="category">Tool category.</param>
    /// <param name="riskLevel">Risk level.</param>
    /// <returns>A mock tool with specified category and risk.</returns>
    public static MockTool WithCategoryAndRisk(
        string id,
        ToolCategory category,
        RiskLevel riskLevel) =>
        new(id, category: category, riskLevel: riskLevel);

    /// <summary>
    /// Create a mock tool with validation that always fails.
    /// </summary>
    /// <param name="id">Tool ID.</param>
    /// <param name="errorMessage">Validation error message.</param>
    /// <returns>A mock tool with failing validation.</returns>
    public static MockTool WithFailingValidation(
        string id = "invalid-tool",
        string errorMessage = "Validation failed") =>
        new(id, validateFunc: _ => ToolValidationResult.Invalid(
            ToolValidationError.Required("test", errorMessage)));

    #endregion
}
```

### 2. MockToolBuilder.cs

**Location**: `tests/AIntern.Tests/Mocks/MockToolBuilder.cs`

```csharp
namespace AIntern.Tests.Mocks;

using System.Text.Json;
using AIntern.Core.Tools;

/// <summary>
/// Fluent builder for creating MockTool instances.
/// </summary>
/// <remarks>
/// <para>
/// The builder provides a fluent API for constructing mock tools:
/// </para>
/// <code>
/// var tool = MockToolBuilder.Create()
///     .WithId("file-read")
///     .WithName("Read File")
///     .WithCategory(ToolCategory.FileSystem)
///     .WithRiskLevel(RiskLevel.Safe)
///     .WithSchema(schema => schema
///         .AddString("path", "File path", required: true))
///     .ExecutesWith(async (ctx, ct) => {
///         var path = ctx.GetRequiredString("path");
///         return ToolResult.Succeeded(new { content = "file contents" });
///     })
///     .Build();
/// </code>
/// </remarks>
public sealed class MockToolBuilder
{
    private string _id = "mock-tool";
    private string _name = "Mock Tool";
    private string _description = "A mock tool for testing";
    private ToolCategory _category = ToolCategory.Custom;
    private RiskLevel _riskLevel = RiskLevel.Safe;
    private JsonSchema? _schema;
    private bool _isAvailable = true;
    private List<string> _tags = new();
    private Func<ToolExecutionContext, CancellationToken, Task<ToolResult>>? _executeFunc;
    private Func<JsonElement, ToolValidationResult>? _validateFunc;
    private Func<JsonElement, string>? _summaryFunc;
    private Func<JsonElement, RiskLevel>? _riskFunc;

    /// <summary>
    /// Create a new builder instance.
    /// </summary>
    /// <returns>A new MockToolBuilder.</returns>
    public static MockToolBuilder Create() => new();

    /// <summary>
    /// Set the tool ID.
    /// </summary>
    /// <param name="id">The tool ID.</param>
    /// <returns>The builder for chaining.</returns>
    public MockToolBuilder WithId(string id)
    {
        _id = id;
        return this;
    }

    /// <summary>
    /// Set the tool name.
    /// </summary>
    /// <param name="name">The display name.</param>
    /// <returns>The builder for chaining.</returns>
    public MockToolBuilder WithName(string name)
    {
        _name = name;
        return this;
    }

    /// <summary>
    /// Set the tool description.
    /// </summary>
    /// <param name="description">The description.</param>
    /// <returns>The builder for chaining.</returns>
    public MockToolBuilder WithDescription(string description)
    {
        _description = description;
        return this;
    }

    /// <summary>
    /// Set the tool category.
    /// </summary>
    /// <param name="category">The category.</param>
    /// <returns>The builder for chaining.</returns>
    public MockToolBuilder WithCategory(ToolCategory category)
    {
        _category = category;
        return this;
    }

    /// <summary>
    /// Set the default risk level.
    /// </summary>
    /// <param name="riskLevel">The risk level.</param>
    /// <returns>The builder for chaining.</returns>
    public MockToolBuilder WithRiskLevel(RiskLevel riskLevel)
    {
        _riskLevel = riskLevel;
        return this;
    }

    /// <summary>
    /// Set the input schema.
    /// </summary>
    /// <param name="schema">The schema.</param>
    /// <returns>The builder for chaining.</returns>
    public MockToolBuilder WithSchema(JsonSchema schema)
    {
        _schema = schema;
        return this;
    }

    /// <summary>
    /// Set the input schema using a builder action.
    /// </summary>
    /// <param name="configure">Action to configure the schema builder.</param>
    /// <returns>The builder for chaining.</returns>
    public MockToolBuilder WithSchema(Action<JsonSchemaBuilder> configure)
    {
        var builder = JsonSchemaBuilder.Create();
        configure(builder);
        _schema = builder.Build();
        return this;
    }

    /// <summary>
    /// Set whether the tool is available.
    /// </summary>
    /// <param name="isAvailable">Availability flag.</param>
    /// <returns>The builder for chaining.</returns>
    public MockToolBuilder IsAvailable(bool isAvailable)
    {
        _isAvailable = isAvailable;
        return this;
    }

    /// <summary>
    /// Add tags to the tool.
    /// </summary>
    /// <param name="tags">Tags to add.</param>
    /// <returns>The builder for chaining.</returns>
    public MockToolBuilder WithTags(params string[] tags)
    {
        _tags.AddRange(tags);
        return this;
    }

    /// <summary>
    /// Set the execution behavior.
    /// </summary>
    /// <param name="executeFunc">The execution function.</param>
    /// <returns>The builder for chaining.</returns>
    public MockToolBuilder ExecutesWith(
        Func<ToolExecutionContext, CancellationToken, Task<ToolResult>> executeFunc)
    {
        _executeFunc = executeFunc;
        return this;
    }

    /// <summary>
    /// Set the execution to always succeed with specific data.
    /// </summary>
    /// <param name="data">Data to return.</param>
    /// <returns>The builder for chaining.</returns>
    public MockToolBuilder Succeeds(object? data = null)
    {
        _executeFunc = (_, _) => Task.FromResult(
            ToolResult.Succeeded(data ?? new { success = true }));
        return this;
    }

    /// <summary>
    /// Set the execution to always fail with a message.
    /// </summary>
    /// <param name="error">Error message.</param>
    /// <param name="errorCode">Optional error code.</param>
    /// <returns>The builder for chaining.</returns>
    public MockToolBuilder Fails(string error = "Test error", string? errorCode = null)
    {
        _executeFunc = (_, _) => Task.FromResult(ToolResult.Failed(error, errorCode));
        return this;
    }

    /// <summary>
    /// Set the execution to throw an exception.
    /// </summary>
    /// <param name="exception">Exception to throw.</param>
    /// <returns>The builder for chaining.</returns>
    public MockToolBuilder Throws(Exception? exception = null)
    {
        _executeFunc = (_, _) => throw (exception ?? new Exception("Test exception"));
        return this;
    }

    /// <summary>
    /// Set the execution to delay for a duration.
    /// </summary>
    /// <param name="delay">Delay duration.</param>
    /// <returns>The builder for chaining.</returns>
    public MockToolBuilder DelaysFor(TimeSpan delay)
    {
        _executeFunc = async (_, ct) =>
        {
            await Task.Delay(delay, ct);
            return ToolResult.Succeeded();
        };
        return this;
    }

    /// <summary>
    /// Set the validation behavior.
    /// </summary>
    /// <param name="validateFunc">The validation function.</param>
    /// <returns>The builder for chaining.</returns>
    public MockToolBuilder ValidatesWith(Func<JsonElement, ToolValidationResult> validateFunc)
    {
        _validateFunc = validateFunc;
        return this;
    }

    /// <summary>
    /// Set validation to always pass.
    /// </summary>
    /// <returns>The builder for chaining.</returns>
    public MockToolBuilder ValidationPasses()
    {
        _validateFunc = _ => ToolValidationResult.Valid();
        return this;
    }

    /// <summary>
    /// Set validation to always fail.
    /// </summary>
    /// <param name="parameterName">Parameter name for error.</param>
    /// <param name="message">Error message.</param>
    /// <returns>The builder for chaining.</returns>
    public MockToolBuilder ValidationFails(string parameterName = "test", string message = "Validation failed")
    {
        _validateFunc = _ => ToolValidationResult.Invalid(
            ToolValidationError.Required(parameterName, message));
        return this;
    }

    /// <summary>
    /// Set the execution summary function.
    /// </summary>
    /// <param name="summaryFunc">The summary function.</param>
    /// <returns>The builder for chaining.</returns>
    public MockToolBuilder WithSummary(Func<JsonElement, string> summaryFunc)
    {
        _summaryFunc = summaryFunc;
        return this;
    }

    /// <summary>
    /// Set a static execution summary.
    /// </summary>
    /// <param name="summary">The summary string.</param>
    /// <returns>The builder for chaining.</returns>
    public MockToolBuilder WithSummary(string summary)
    {
        _summaryFunc = _ => summary;
        return this;
    }

    /// <summary>
    /// Set the effective risk level function.
    /// </summary>
    /// <param name="riskFunc">The risk level function.</param>
    /// <returns>The builder for chaining.</returns>
    public MockToolBuilder WithEffectiveRisk(Func<JsonElement, RiskLevel> riskFunc)
    {
        _riskFunc = riskFunc;
        return this;
    }

    /// <summary>
    /// Build the MockTool instance.
    /// </summary>
    /// <returns>A configured MockTool.</returns>
    public MockTool Build() =>
        new(
            _id,
            _name,
            _description,
            _category,
            _riskLevel,
            _schema,
            _isAvailable,
            _tags,
            _executeFunc,
            _validateFunc,
            _summaryFunc,
            _riskFunc);
}
```

### 3. TestContextBuilder.cs

**Location**: `tests/AIntern.Tests/Helpers/TestContextBuilder.cs`

```csharp
namespace AIntern.Tests.Helpers;

using System.Text.Json;
using Microsoft.Extensions.DependencyInjection;
using AIntern.Core.Tools;

/// <summary>
/// Builder for creating ToolExecutionContext instances in tests.
/// </summary>
/// <remarks>
/// <para>
/// This builder simplifies test setup by providing sensible defaults:
/// </para>
/// <code>
/// var context = TestContextBuilder.Create()
///     .WithToolId("file-read")
///     .WithParametersFromObject(new { path = "test.txt" })
///     .WithWorkspace("/tmp/workspace")
///     .Build();
/// </code>
/// </remarks>
public sealed class TestContextBuilder
{
    private Guid _executionId = Guid.NewGuid();
    private Guid _sessionId = Guid.NewGuid();
    private string _toolId = "test-tool";
    private string? _workspacePath;
    private JsonElement _parameters = JsonDocument.Parse("{}").RootElement;
    private IServiceProvider? _services;
    private bool _isApproved = true;
    private JsonElement? _modifiedParameters;
    private Dictionary<string, object>? _metadata;

    /// <summary>
    /// Create a new builder instance.
    /// </summary>
    /// <returns>A new TestContextBuilder.</returns>
    public static TestContextBuilder Create() => new();

    /// <summary>
    /// Set the execution ID.
    /// </summary>
    public TestContextBuilder WithExecutionId(Guid executionId)
    {
        _executionId = executionId;
        return this;
    }

    /// <summary>
    /// Set the session ID.
    /// </summary>
    public TestContextBuilder WithSessionId(Guid sessionId)
    {
        _sessionId = sessionId;
        return this;
    }

    /// <summary>
    /// Set the tool ID.
    /// </summary>
    public TestContextBuilder WithToolId(string toolId)
    {
        _toolId = toolId;
        return this;
    }

    /// <summary>
    /// Set the workspace path.
    /// </summary>
    public TestContextBuilder WithWorkspace(string workspacePath)
    {
        _workspacePath = workspacePath;
        return this;
    }

    /// <summary>
    /// Set the parameters from a JSON string.
    /// </summary>
    public TestContextBuilder WithParameters(string json)
    {
        _parameters = JsonDocument.Parse(json).RootElement;
        return this;
    }

    /// <summary>
    /// Set the parameters from a JsonElement.
    /// </summary>
    public TestContextBuilder WithParameters(JsonElement parameters)
    {
        _parameters = parameters;
        return this;
    }

    /// <summary>
    /// Set the parameters from an object.
    /// </summary>
    public TestContextBuilder WithParametersFromObject(object obj)
    {
        var json = JsonSerializer.Serialize(obj);
        _parameters = JsonDocument.Parse(json).RootElement;
        return this;
    }

    /// <summary>
    /// Set the service provider.
    /// </summary>
    public TestContextBuilder WithServices(IServiceProvider services)
    {
        _services = services;
        return this;
    }

    /// <summary>
    /// Add services using a configuration action.
    /// </summary>
    public TestContextBuilder WithServices(Action<IServiceCollection> configure)
    {
        var services = new ServiceCollection();
        configure(services);
        _services = services.BuildServiceProvider();
        return this;
    }

    /// <summary>
    /// Set whether the execution is approved.
    /// </summary>
    public TestContextBuilder WithApproval(bool isApproved = true)
    {
        _isApproved = isApproved;
        return this;
    }

    /// <summary>
    /// Set modified parameters.
    /// </summary>
    public TestContextBuilder WithModifiedParameters(string json)
    {
        _modifiedParameters = JsonDocument.Parse(json).RootElement;
        return this;
    }

    /// <summary>
    /// Set modified parameters from an object.
    /// </summary>
    public TestContextBuilder WithModifiedParametersFromObject(object obj)
    {
        var json = JsonSerializer.Serialize(obj);
        _modifiedParameters = JsonDocument.Parse(json).RootElement;
        return this;
    }

    /// <summary>
    /// Add metadata.
    /// </summary>
    public TestContextBuilder WithMetadata(string key, object value)
    {
        _metadata ??= new Dictionary<string, object>();
        _metadata[key] = value;
        return this;
    }

    /// <summary>
    /// Build the ToolExecutionContext.
    /// </summary>
    public ToolExecutionContext Build()
    {
        return new ToolExecutionContext
        {
            ExecutionId = _executionId,
            SessionId = _sessionId,
            ToolId = _toolId,
            WorkspacePath = _workspacePath,
            Parameters = _parameters,
            Services = _services ?? new ServiceCollection().BuildServiceProvider(),
            IsApproved = _isApproved,
            ModifiedParameters = _modifiedParameters,
            Metadata = _metadata
        };
    }
}
```

### 4. JsonTestHelpers.cs

**Location**: `tests/AIntern.Tests/Helpers/JsonTestHelpers.cs`

```csharp
namespace AIntern.Tests.Helpers;

using System.Text.Json;

/// <summary>
/// Helper methods for JSON operations in tests.
/// </summary>
public static class JsonTestHelpers
{
    /// <summary>
    /// Parse a JSON string to a JsonElement.
    /// </summary>
    /// <param name="json">The JSON string.</param>
    /// <returns>The parsed JsonElement.</returns>
    public static JsonElement ParseJson(string json) =>
        JsonDocument.Parse(json).RootElement;

    /// <summary>
    /// Convert an object to a JsonElement.
    /// </summary>
    /// <param name="obj">The object to convert.</param>
    /// <returns>The JsonElement representation.</returns>
    public static JsonElement ToJsonElement(object obj)
    {
        var json = JsonSerializer.Serialize(obj);
        return JsonDocument.Parse(json).RootElement;
    }

    /// <summary>
    /// Create an empty JSON object element.
    /// </summary>
    /// <returns>An empty object JsonElement.</returns>
    public static JsonElement EmptyObject() =>
        JsonDocument.Parse("{}").RootElement;

    /// <summary>
    /// Create a JSON object with a single property.
    /// </summary>
    /// <param name="name">Property name.</param>
    /// <param name="value">Property value.</param>
    /// <returns>A JsonElement with the property.</returns>
    public static JsonElement WithProperty(string name, object? value)
    {
        var dict = new Dictionary<string, object?> { [name] = value };
        return ToJsonElement(dict);
    }

    /// <summary>
    /// Assert that two JSON elements are equivalent.
    /// </summary>
    /// <param name="expected">Expected JSON.</param>
    /// <param name="actual">Actual JSON.</param>
    public static void AssertJsonEquals(JsonElement expected, JsonElement actual)
    {
        var expectedJson = JsonSerializer.Serialize(expected);
        var actualJson = JsonSerializer.Serialize(actual);
        Assert.That(actualJson, Is.EqualTo(expectedJson));
    }

    /// <summary>
    /// Assert that a JSON element contains a property with expected value.
    /// </summary>
    /// <param name="element">The JSON element.</param>
    /// <param name="propertyName">Property name.</param>
    /// <param name="expectedValue">Expected value.</param>
    public static void AssertPropertyEquals(
        JsonElement element,
        string propertyName,
        object expectedValue)
    {
        Assert.That(element.TryGetProperty(propertyName, out var actual), Is.True,
            $"Property '{propertyName}' not found");

        var expectedElement = ToJsonElement(expectedValue);
        var actualJson = JsonSerializer.Serialize(actual);
        var expectedJson = JsonSerializer.Serialize(expectedElement);

        Assert.That(actualJson, Is.EqualTo(expectedJson),
            $"Property '{propertyName}' value mismatch");
    }

    /// <summary>
    /// Assert that a JSON element is an object with expected property count.
    /// </summary>
    public static void AssertIsObject(JsonElement element, int? expectedProperties = null)
    {
        Assert.That(element.ValueKind, Is.EqualTo(JsonValueKind.Object));

        if (expectedProperties.HasValue)
        {
            var count = element.EnumerateObject().Count();
            Assert.That(count, Is.EqualTo(expectedProperties.Value));
        }
    }

    /// <summary>
    /// Assert that a JSON element is an array with expected count.
    /// </summary>
    public static void AssertIsArray(JsonElement element, int? expectedCount = null)
    {
        Assert.That(element.ValueKind, Is.EqualTo(JsonValueKind.Array));

        if (expectedCount.HasValue)
        {
            Assert.That(element.GetArrayLength(), Is.EqualTo(expectedCount.Value));
        }
    }
}
```

### 5. ToolTestHelpers.cs

**Location**: `tests/AIntern.Tests/Helpers/ToolTestHelpers.cs`

```csharp
namespace AIntern.Tests.Helpers;

using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.Extensions.Options;
using AIntern.Core.Interfaces;
using AIntern.Core.Tools;
using AIntern.Services.Tools;
using AIntern.Tests.Mocks;

/// <summary>
/// Helper methods for tool framework testing.
/// </summary>
public static class ToolTestHelpers
{
    /// <summary>
    /// Create a tool registry with optional tools.
    /// </summary>
    /// <param name="tools">Tools to register.</param>
    /// <returns>A configured ToolRegistry.</returns>
    public static ToolRegistry CreateRegistry(params ITool[] tools)
    {
        var registry = new ToolRegistry(NullLogger<ToolRegistry>.Instance);
        foreach (var tool in tools)
        {
            registry.TryRegisterTool(tool);
        }
        return registry;
    }

    /// <summary>
    /// Create a tool execution service with optional configuration.
    /// </summary>
    /// <param name="registry">The tool registry.</param>
    /// <param name="configureOptions">Options configuration.</param>
    /// <returns>A configured ToolExecutionService.</returns>
    public static ToolExecutionService CreateExecutionService(
        IToolRegistry registry,
        Action<ToolExecutionOptions>? configureOptions = null)
    {
        var options = new ToolExecutionOptions();
        configureOptions?.Invoke(options);

        return new ToolExecutionService(
            registry,
            NullLogger<ToolExecutionService>.Instance,
            Options.Create(options));
    }

    /// <summary>
    /// Create a service provider with tool framework services.
    /// </summary>
    /// <param name="configureServices">Additional service configuration.</param>
    /// <returns>A configured ServiceProvider.</returns>
    public static ServiceProvider CreateServiceProvider(
        Action<IServiceCollection>? configureServices = null)
    {
        var services = new ServiceCollection()
            .AddLogging(builder => builder.AddProvider(NullLoggerProvider.Instance))
            .AddToolRegistry()
            .AddToolExecutionService();

        configureServices?.Invoke(services);

        return services.BuildServiceProvider();
    }

    /// <summary>
    /// Wait for an event to fire with a timeout.
    /// </summary>
    /// <typeparam name="TArgs">Event args type.</typeparam>
    /// <param name="subscribe">Action to subscribe to the event.</param>
    /// <param name="action">Action that triggers the event.</param>
    /// <param name="timeout">Maximum wait time.</param>
    /// <returns>The event args if fired, or null.</returns>
    public static async Task<TArgs?> WaitForEvent<TArgs>(
        Action<EventHandler<TArgs>> subscribe,
        Func<Task> action,
        TimeSpan? timeout = null)
        where TArgs : EventArgs
    {
        var tcs = new TaskCompletionSource<TArgs>();
        var handler = new EventHandler<TArgs>((_, args) => tcs.TrySetResult(args));

        subscribe(handler);

        try
        {
            var task = action();
            var waitTask = tcs.Task;
            var timeoutTask = Task.Delay(timeout ?? TimeSpan.FromSeconds(5));

            var completed = await Task.WhenAny(waitTask, timeoutTask);

            if (completed == waitTask)
            {
                await task;
                return await waitTask;
            }

            return default;
        }
        finally
        {
            // Note: Actual unsubscription would require storing and calling unsubscribe
        }
    }

    /// <summary>
    /// Create multiple mock tools for testing.
    /// </summary>
    /// <param name="count">Number of tools to create.</param>
    /// <param name="prefix">ID prefix.</param>
    /// <returns>Array of mock tools.</returns>
    public static MockTool[] CreateMockTools(int count, string prefix = "tool")
    {
        return Enumerable.Range(1, count)
            .Select(i => new MockTool($"{prefix}-{i}", name: $"Tool {i}"))
            .ToArray();
    }

    /// <summary>
    /// Create mock tools for each category.
    /// </summary>
    /// <returns>Dictionary of category to tool.</returns>
    public static Dictionary<ToolCategory, MockTool> CreateToolsByCategory()
    {
        return Enum.GetValues<ToolCategory>()
            .ToDictionary(
                c => c,
                c => new MockTool($"{c.ToString().ToLower()}-tool", category: c));
    }

    /// <summary>
    /// Create mock tools for each risk level.
    /// </summary>
    /// <returns>Dictionary of risk level to tool.</returns>
    public static Dictionary<RiskLevel, MockTool> CreateToolsByRiskLevel()
    {
        return Enum.GetValues<RiskLevel>()
            .ToDictionary(
                r => r,
                r => new MockTool($"risk-{(int)r}-tool", riskLevel: r));
    }
}
```

### 6. ToolRegistryTests.cs

**Location**: `tests/AIntern.Tests/Unit/Tools/ToolRegistryTests.cs`

```csharp
namespace AIntern.Tests.Unit.Tools;

using AIntern.Core.Tools;
using AIntern.Services.Tools;
using AIntern.Tests.Mocks;
using AIntern.Tests.Helpers;
using Microsoft.Extensions.Logging.Abstractions;

[TestFixture]
public class ToolRegistryTests
{
    private ToolRegistry _registry = null!;

    [SetUp]
    public void SetUp()
    {
        _registry = new ToolRegistry(NullLogger<ToolRegistry>.Instance);
    }

    #region Registration Tests

    [Test]
    public void RegisterTool_AddsTool()
    {
        var tool = new MockTool("test-tool");

        _registry.RegisterTool(tool);

        Assert.That(_registry.Count, Is.EqualTo(1));
        Assert.That(_registry.HasTool("test-tool"), Is.True);
    }

    [Test]
    public void RegisterTool_Duplicate_ThrowsException()
    {
        var tool1 = new MockTool("test-tool");
        var tool2 = new MockTool("test-tool");

        _registry.RegisterTool(tool1);

        Assert.Throws<InvalidOperationException>(() => _registry.RegisterTool(tool2));
    }

    [Test]
    public void TryRegisterTool_AddsTool()
    {
        var tool = new MockTool("test-tool");

        var result = _registry.TryRegisterTool(tool);

        Assert.That(result, Is.True);
        Assert.That(_registry.Count, Is.EqualTo(1));
    }

    [Test]
    public void TryRegisterTool_Duplicate_ReturnsFalse()
    {
        var tool1 = new MockTool("test-tool");
        var tool2 = new MockTool("test-tool");

        _registry.TryRegisterTool(tool1);
        var result = _registry.TryRegisterTool(tool2);

        Assert.That(result, Is.False);
        Assert.That(_registry.Count, Is.EqualTo(1));
    }

    [Test]
    public void UnregisterTool_RemovesTool()
    {
        var tool = new MockTool("test-tool");
        _registry.RegisterTool(tool);

        var removed = _registry.UnregisterTool("test-tool");

        Assert.That(removed, Is.True);
        Assert.That(_registry.Count, Is.EqualTo(0));
    }

    [Test]
    public void UnregisterTool_NotFound_ReturnsFalse()
    {
        var removed = _registry.UnregisterTool("nonexistent");

        Assert.That(removed, Is.False);
    }

    #endregion

    #region Lookup Tests

    [Test]
    public void GetTool_ReturnsCorrectTool()
    {
        var tool = new MockTool("test-tool", name: "Test Tool");
        _registry.RegisterTool(tool);

        var retrieved = _registry.GetTool("test-tool");

        Assert.That(retrieved, Is.Not.Null);
        Assert.That(retrieved!.Name, Is.EqualTo("Test Tool"));
    }

    [Test]
    public void GetTool_NotFound_ReturnsNull()
    {
        var tool = _registry.GetTool("nonexistent");

        Assert.That(tool, Is.Null);
    }

    [Test]
    public void HasTool_Existing_ReturnsTrue()
    {
        _registry.RegisterTool(new MockTool("test-tool"));

        Assert.That(_registry.HasTool("test-tool"), Is.True);
    }

    [Test]
    public void HasTool_NotFound_ReturnsFalse()
    {
        Assert.That(_registry.HasTool("nonexistent"), Is.False);
    }

    [Test]
    public void HasTool_CaseInsensitive()
    {
        _registry.RegisterTool(new MockTool("Test-Tool"));

        Assert.That(_registry.HasTool("test-tool"), Is.True);
        Assert.That(_registry.HasTool("TEST-TOOL"), Is.True);
    }

    [Test]
    public void Tools_ReturnsAllRegistered()
    {
        _registry.RegisterTool(new MockTool("tool-1"));
        _registry.RegisterTool(new MockTool("tool-2"));
        _registry.RegisterTool(new MockTool("tool-3"));

        Assert.That(_registry.Tools, Has.Count.EqualTo(3));
    }

    [Test]
    public void Count_ReturnsCorrectCount()
    {
        _registry.RegisterTool(new MockTool("tool-1"));
        _registry.RegisterTool(new MockTool("tool-2"));

        Assert.That(_registry.Count, Is.EqualTo(2));
    }

    #endregion

    #region Filtering Tests

    [Test]
    public void GetAvailableTools_FiltersByIsAvailable()
    {
        _registry.RegisterTool(new MockTool("available", isAvailable: true));
        _registry.RegisterTool(MockTool.Unavailable("unavailable"));

        var tools = _registry.GetAvailableTools();

        Assert.That(tools, Has.Count.EqualTo(1));
        Assert.That(tools[0].Id, Is.EqualTo("available"));
    }

    [Test]
    public void GetToolsByCategory_FiltersCorrectly()
    {
        _registry.RegisterTool(new MockTool("file-1", category: ToolCategory.FileSystem));
        _registry.RegisterTool(new MockTool("file-2", category: ToolCategory.FileSystem));
        _registry.RegisterTool(new MockTool("term-1", category: ToolCategory.Terminal));

        var fileTools = _registry.GetToolsByCategory(ToolCategory.FileSystem);

        Assert.That(fileTools, Has.Count.EqualTo(2));
    }

    [Test]
    public void GetToolsByTag_FiltersCorrectly()
    {
        _registry.RegisterTool(new MockTool("tool-1", tags: new[] { "read", "file" }));
        _registry.RegisterTool(new MockTool("tool-2", tags: new[] { "write", "file" }));
        _registry.RegisterTool(new MockTool("tool-3", tags: new[] { "execute" }));

        var fileTools = _registry.GetToolsByTag("file");

        Assert.That(fileTools, Has.Count.EqualTo(2));
    }

    [Test]
    public void GetToolsByRiskLevel_FiltersCorrectly()
    {
        _registry.RegisterTool(new MockTool("safe", riskLevel: RiskLevel.Safe));
        _registry.RegisterTool(new MockTool("low", riskLevel: RiskLevel.Low));
        _registry.RegisterTool(new MockTool("high", riskLevel: RiskLevel.High));

        var safeTools = _registry.GetToolsByRiskLevel(RiskLevel.Low);

        Assert.That(safeTools, Has.Count.EqualTo(2));
    }

    [Test]
    public void GetAvailableTools_WithContext_FiltersCorrectly()
    {
        _registry.RegisterTool(new MockTool("file-tool", category: ToolCategory.FileSystem));
        _registry.RegisterTool(new MockTool("term-tool", category: ToolCategory.Terminal));

        var context = ToolAvailabilityContext.Create()
            .WithTerminal(false)
            .Build();
        var tools = _registry.GetAvailableTools(context);

        Assert.That(tools, Has.Count.EqualTo(1));
        Assert.That(tools[0].Id, Is.EqualTo("file-tool"));
    }

    [Test]
    public void GetAvailableTools_WithWhitelist_FiltersCorrectly()
    {
        _registry.RegisterTool(new MockTool("tool-1"));
        _registry.RegisterTool(new MockTool("tool-2"));
        _registry.RegisterTool(new MockTool("tool-3"));

        var context = ToolAvailabilityContext.Create()
            .WithEnabledTools("tool-1", "tool-2")
            .Build();
        var tools = _registry.GetAvailableTools(context);

        Assert.That(tools, Has.Count.EqualTo(2));
    }

    [Test]
    public void GetAvailableTools_WithBlacklist_FiltersCorrectly()
    {
        _registry.RegisterTool(new MockTool("tool-1"));
        _registry.RegisterTool(new MockTool("tool-2"));
        _registry.RegisterTool(new MockTool("tool-3"));

        var context = ToolAvailabilityContext.Create()
            .WithDisabledTools("tool-2")
            .Build();
        var tools = _registry.GetAvailableTools(context);

        Assert.That(tools, Has.Count.EqualTo(2));
        Assert.That(tools.Any(t => t.Id == "tool-2"), Is.False);
    }

    [Test]
    public void SearchTools_MatchesId()
    {
        _registry.RegisterTool(new MockTool("file-read"));
        _registry.RegisterTool(new MockTool("file-write"));
        _registry.RegisterTool(new MockTool("terminal"));

        var results = _registry.SearchTools("file");

        Assert.That(results, Has.Count.EqualTo(2));
    }

    [Test]
    public void SearchTools_MatchesName()
    {
        _registry.RegisterTool(new MockTool("tool-1", name: "Read File"));
        _registry.RegisterTool(new MockTool("tool-2", name: "Write File"));
        _registry.RegisterTool(new MockTool("tool-3", name: "Execute Command"));

        var results = _registry.SearchTools("file");

        Assert.That(results, Has.Count.EqualTo(2));
    }

    [Test]
    public void SearchTools_MatchesDescription()
    {
        _registry.RegisterTool(new MockTool("tool-1", description: "Reads content from files"));
        _registry.RegisterTool(new MockTool("tool-2", description: "Executes commands"));

        var results = _registry.SearchTools("content");

        Assert.That(results, Has.Count.EqualTo(1));
    }

    [Test]
    public void SearchTools_EmptyQuery_ReturnsAll()
    {
        _registry.RegisterTool(new MockTool("tool-1"));
        _registry.RegisterTool(new MockTool("tool-2"));

        var results = _registry.SearchTools("");

        Assert.That(results, Has.Count.EqualTo(2));
    }

    #endregion

    #region Event Tests

    [Test]
    public void ToolsChanged_FiresOnRegister()
    {
        ToolRegistryChangedEventArgs? eventArgs = null;
        _registry.ToolsChanged += (_, args) => eventArgs = args;

        _registry.RegisterTool(new MockTool("test-tool"));

        Assert.That(eventArgs, Is.Not.Null);
        Assert.That(eventArgs!.ChangeType, Is.EqualTo(ToolRegistryChangeType.Added));
        Assert.That(eventArgs.Tool.Id, Is.EqualTo("test-tool"));
    }

    [Test]
    public void ToolsChanged_FiresOnUnregister()
    {
        _registry.RegisterTool(new MockTool("test-tool"));

        ToolRegistryChangedEventArgs? eventArgs = null;
        _registry.ToolsChanged += (_, args) => eventArgs = args;

        _registry.UnregisterTool("test-tool");

        Assert.That(eventArgs, Is.Not.Null);
        Assert.That(eventArgs!.ChangeType, Is.EqualTo(ToolRegistryChangeType.Removed));
    }

    #endregion

    #region Function Definition Tests

    [Test]
    public void GetFunctionDefinitions_ReturnsForAllAvailable()
    {
        _registry.RegisterTool(new MockTool("tool-1"));
        _registry.RegisterTool(new MockTool("tool-2"));

        var definitions = _registry.GetFunctionDefinitions();

        Assert.That(definitions, Has.Count.EqualTo(2));
    }

    [Test]
    public void GetFunctionDefinition_ExistingTool_ReturnsDefinition()
    {
        _registry.RegisterTool(new MockTool("test-tool", description: "Test description"));

        var definition = _registry.GetFunctionDefinition("test-tool");

        Assert.That(definition, Is.Not.Null);
        Assert.That(definition!.Name, Is.EqualTo("test-tool"));
        Assert.That(definition.Description, Is.EqualTo("Test description"));
    }

    [Test]
    public void GetFunctionDefinition_NotFound_ReturnsNull()
    {
        var definition = _registry.GetFunctionDefinition("nonexistent");

        Assert.That(definition, Is.Null);
    }

    #endregion
}
```

### 7. ToolExecutionServiceTests.cs

**Location**: `tests/AIntern.Tests/Unit/Tools/ToolExecutionServiceTests.cs`

```csharp
namespace AIntern.Tests.Unit.Tools;

using AIntern.Core.Tools;
using AIntern.Services.Tools;
using AIntern.Tests.Mocks;
using AIntern.Tests.Helpers;

[TestFixture]
public class ToolExecutionServiceTests
{
    private ToolRegistry _registry = null!;
    private ToolExecutionService _service = null!;

    [SetUp]
    public void SetUp()
    {
        _registry = ToolTestHelpers.CreateRegistry();
        _service = ToolTestHelpers.CreateExecutionService(_registry);
    }

    #region Execution Tests

    [Test]
    public async Task ExecuteAsync_Success_ReturnsSuccessResult()
    {
        var tool = MockTool.Succeeding("test-tool", new { value = 42 });
        _registry.RegisterTool(tool);

        var context = TestContextBuilder.Create()
            .WithToolId("test-tool")
            .Build();
        var result = await _service.ExecuteAsync("test-tool", context);

        Assert.That(result.Status, Is.EqualTo(ToolExecutionStatus.Completed));
        Assert.That(result.IsSuccess, Is.True);
        Assert.That(result.Result.Success, Is.True);
    }

    [Test]
    public async Task ExecuteAsync_Failure_ReturnsFailedResult()
    {
        var tool = MockTool.Failing("test-tool", "Test failure");
        _registry.RegisterTool(tool);

        var context = TestContextBuilder.Create()
            .WithToolId("test-tool")
            .Build();
        var result = await _service.ExecuteAsync("test-tool", context);

        Assert.That(result.Status, Is.EqualTo(ToolExecutionStatus.Failed));
        Assert.That(result.IsFailure, Is.True);
        Assert.That(result.Result.ErrorMessage, Is.EqualTo("Test failure"));
    }

    [Test]
    public async Task ExecuteAsync_ToolNotFound_ReturnsNotFoundResult()
    {
        var context = TestContextBuilder.Create()
            .WithToolId("nonexistent")
            .Build();
        var result = await _service.ExecuteAsync("nonexistent", context);

        Assert.That(result.Status, Is.EqualTo(ToolExecutionStatus.Failed));
        Assert.That(result.Result.ErrorCode, Is.EqualTo("ToolNotFound"));
    }

    [Test]
    public async Task ExecuteAsync_ToolNotAvailable_ReturnsUnavailableResult()
    {
        var tool = MockTool.Unavailable("test-tool");
        _registry.RegisterTool(tool);

        var context = TestContextBuilder.Create()
            .WithToolId("test-tool")
            .Build();
        var result = await _service.ExecuteAsync("test-tool", context);

        Assert.That(result.Status, Is.EqualTo(ToolExecutionStatus.Failed));
        Assert.That(result.Result.ErrorCode, Is.EqualTo("ToolNotAvailable"));
    }

    [Test]
    public async Task ExecuteAsync_ToolThrows_ReturnsFailedResult()
    {
        var tool = MockTool.Throwing("test-tool", new InvalidOperationException("Test exception"));
        _registry.RegisterTool(tool);

        var context = TestContextBuilder.Create()
            .WithToolId("test-tool")
            .Build();
        var result = await _service.ExecuteAsync("test-tool", context);

        Assert.That(result.Status, Is.EqualTo(ToolExecutionStatus.Failed));
        Assert.That(result.Result.ErrorMessage, Does.Contain("Test exception"));
    }

    [Test]
    public async Task ExecuteAsync_TracksCallCount()
    {
        var tool = MockTool.Succeeding("test-tool");
        _registry.RegisterTool(tool);

        var context = TestContextBuilder.Create()
            .WithToolId("test-tool")
            .Build();

        await _service.ExecuteAsync("test-tool", context);
        await _service.ExecuteAsync("test-tool", context);

        Assert.That(tool.ExecuteCallCount, Is.EqualTo(2));
    }

    [Test]
    public async Task ExecuteAsync_CapturesParameters()
    {
        var tool = MockTool.Succeeding("test-tool");
        _registry.RegisterTool(tool);

        var context = TestContextBuilder.Create()
            .WithToolId("test-tool")
            .WithParametersFromObject(new { path = "test.txt" })
            .Build();

        await _service.ExecuteAsync("test-tool", context);

        Assert.That(tool.ExecutedParameters, Has.Count.EqualTo(1));
        Assert.That(
            tool.ExecutedParameters[0].GetProperty("path").GetString(),
            Is.EqualTo("test.txt"));
    }

    #endregion

    #region Timeout Tests

    [Test]
    public async Task ExecuteAsync_Timeout_ReturnsTimeoutResult()
    {
        var tool = MockTool.Delayed("test-tool", TimeSpan.FromSeconds(10));
        _registry.RegisterTool(tool);

        var service = ToolTestHelpers.CreateExecutionService(_registry, options =>
        {
            options.ExecutionTimeout = TimeSpan.FromMilliseconds(50);
        });

        var context = TestContextBuilder.Create()
            .WithToolId("test-tool")
            .Build();
        var result = await service.ExecuteAsync("test-tool", context);

        Assert.That(result.TimedOut, Is.True);
        Assert.That(result.Status, Is.EqualTo(ToolExecutionStatus.Failed));
    }

    [Test]
    public async Task ExecuteAsync_WithinTimeout_Succeeds()
    {
        var tool = MockTool.Delayed("test-tool", TimeSpan.FromMilliseconds(10));
        _registry.RegisterTool(tool);

        var service = ToolTestHelpers.CreateExecutionService(_registry, options =>
        {
            options.ExecutionTimeout = TimeSpan.FromSeconds(5);
        });

        var context = TestContextBuilder.Create()
            .WithToolId("test-tool")
            .Build();
        var result = await service.ExecuteAsync("test-tool", context);

        Assert.That(result.IsSuccess, Is.True);
    }

    #endregion

    #region Cancellation Tests

    [Test]
    public async Task ExecuteAsync_Cancellation_ReturnsCancelledResult()
    {
        var tool = MockTool.Delayed("test-tool", TimeSpan.FromSeconds(10));
        _registry.RegisterTool(tool);

        using var cts = new CancellationTokenSource();
        var context = TestContextBuilder.Create()
            .WithToolId("test-tool")
            .Build();

        var task = _service.ExecuteAsync("test-tool", context, cts.Token);
        cts.Cancel();

        var result = await task;

        Assert.That(result.WasCancelled, Is.True);
        Assert.That(result.Status, Is.EqualTo(ToolExecutionStatus.Cancelled));
    }

    [Test]
    public async Task ExecuteAsync_CancellationBeforeStart_ReturnsCancelled()
    {
        var tool = MockTool.Succeeding("test-tool");
        _registry.RegisterTool(tool);

        using var cts = new CancellationTokenSource();
        cts.Cancel();

        var context = TestContextBuilder.Create()
            .WithToolId("test-tool")
            .Build();

        var result = await _service.ExecuteAsync("test-tool", context, cts.Token);

        Assert.That(result.WasCancelled, Is.True);
    }

    #endregion

    #region Event Tests

    [Test]
    public async Task ExecuteAsync_FiresStartedEvent()
    {
        var tool = MockTool.Succeeding("test-tool");
        _registry.RegisterTool(tool);

        ToolExecutionStartedEventArgs? eventArgs = null;
        _service.ExecutionStarted += (_, args) => eventArgs = args;

        var context = TestContextBuilder.Create()
            .WithToolId("test-tool")
            .Build();
        await _service.ExecuteAsync("test-tool", context);

        Assert.That(eventArgs, Is.Not.Null);
        Assert.That(eventArgs!.ToolId, Is.EqualTo("test-tool"));
        Assert.That(eventArgs.ExecutionId, Is.EqualTo(context.ExecutionId));
    }

    [Test]
    public async Task ExecuteAsync_FiresCompletedEvent()
    {
        var tool = MockTool.Succeeding("test-tool");
        _registry.RegisterTool(tool);

        ToolExecutionCompletedEventArgs? eventArgs = null;
        _service.ExecutionCompleted += (_, args) => eventArgs = args;

        var context = TestContextBuilder.Create()
            .WithToolId("test-tool")
            .Build();
        await _service.ExecuteAsync("test-tool", context);

        Assert.That(eventArgs, Is.Not.Null);
        Assert.That(eventArgs!.ToolId, Is.EqualTo("test-tool"));
        Assert.That(eventArgs.IsSuccess, Is.True);
    }

    [Test]
    public async Task ExecuteAsync_ReportsProgress()
    {
        var tool = MockTool.WithProgress("test-tool", steps: 3);
        _registry.RegisterTool(tool);

        var progressReports = new List<ToolExecutionProgressEventArgs>();
        _service.ExecutionProgress += (_, args) => progressReports.Add(args);

        var context = TestContextBuilder.Create()
            .WithToolId("test-tool")
            .Build();
        await _service.ExecuteAsync("test-tool", context);

        Assert.That(progressReports, Has.Count.EqualTo(3));
    }

    #endregion

    #region Validation Tests

    [Test]
    public void Validate_ToolNotFound_ReturnsError()
    {
        var result = _service.Validate("nonexistent", JsonTestHelpers.EmptyObject());

        Assert.That(result.IsValid, Is.False);
        Assert.That(result.Errors[0].ErrorCode, Is.EqualTo("tool_not_found"));
    }

    [Test]
    public void Validate_ValidParameters_ReturnsValid()
    {
        var tool = new MockTool("test-tool");
        _registry.RegisterTool(tool);

        var result = _service.Validate("test-tool", JsonTestHelpers.EmptyObject());

        Assert.That(result.IsValid, Is.True);
    }

    [Test]
    public void Validate_InvalidParameters_ReturnsErrors()
    {
        var tool = MockTool.WithFailingValidation("test-tool", "Invalid parameter");
        _registry.RegisterTool(tool);

        var result = _service.Validate("test-tool", JsonTestHelpers.EmptyObject());

        Assert.That(result.IsValid, Is.False);
    }

    #endregion

    #region Summary and Risk Tests

    [Test]
    public void GetExecutionSummary_ToolFound_ReturnsSummary()
    {
        var tool = MockToolBuilder.Create()
            .WithId("test-tool")
            .WithSummary("Execute test operation")
            .Build();
        _registry.RegisterTool(tool);

        var summary = _service.GetExecutionSummary("test-tool", JsonTestHelpers.EmptyObject());

        Assert.That(summary, Is.EqualTo("Execute test operation"));
    }

    [Test]
    public void GetExecutionSummary_ToolNotFound_ReturnsDefault()
    {
        var summary = _service.GetExecutionSummary("nonexistent", JsonTestHelpers.EmptyObject());

        Assert.That(summary, Is.EqualTo("Execute nonexistent"));
    }

    [Test]
    public void GetEffectiveRiskLevel_ToolFound_ReturnsLevel()
    {
        var tool = new MockTool("test-tool", riskLevel: RiskLevel.High);
        _registry.RegisterTool(tool);

        var risk = _service.GetEffectiveRiskLevel("test-tool", JsonTestHelpers.EmptyObject());

        Assert.That(risk, Is.EqualTo(RiskLevel.High));
    }

    [Test]
    public void GetEffectiveRiskLevel_ToolNotFound_ReturnsMedium()
    {
        var risk = _service.GetEffectiveRiskLevel("nonexistent", JsonTestHelpers.EmptyObject());

        Assert.That(risk, Is.EqualTo(RiskLevel.Medium));
    }

    #endregion

    #region Input Validation Tests

    [Test]
    public void ExecuteAsync_NullToolId_ThrowsArgumentException()
    {
        var context = TestContextBuilder.Create().Build();

        Assert.ThrowsAsync<ArgumentException>(async () =>
            await _service.ExecuteAsync(null!, context));
    }

    [Test]
    public void ExecuteAsync_EmptyToolId_ThrowsArgumentException()
    {
        var context = TestContextBuilder.Create().Build();

        Assert.ThrowsAsync<ArgumentException>(async () =>
            await _service.ExecuteAsync("", context));
    }

    [Test]
    public void ExecuteAsync_NullContext_ThrowsArgumentNullException()
    {
        Assert.ThrowsAsync<ArgumentNullException>(async () =>
            await _service.ExecuteAsync("test-tool", null!));
    }

    #endregion
}
```

### 8. ToolFrameworkIntegrationTests.cs

**Location**: `tests/AIntern.Tests/Integration/Tools/ToolFrameworkIntegrationTests.cs`

```csharp
namespace AIntern.Tests.Integration.Tools;

using Microsoft.Extensions.DependencyInjection;
using AIntern.Core.Interfaces;
using AIntern.Core.Tools;
using AIntern.Services.Tools;
using AIntern.Tests.Mocks;
using AIntern.Tests.Helpers;

[TestFixture]
public class ToolFrameworkIntegrationTests
{
    private ServiceProvider _services = null!;
    private IToolRegistry _registry = null!;
    private IToolExecutionService _executionService = null!;

    [SetUp]
    public void SetUp()
    {
        _services = ToolTestHelpers.CreateServiceProvider(services =>
        {
            services.Configure<ToolExecutionOptions>(o =>
            {
                o.ExecutionTimeout = TimeSpan.FromSeconds(5);
            });
        });

        _registry = _services.GetRequiredService<IToolRegistry>();
        _executionService = _services.GetRequiredService<IToolExecutionService>();
    }

    [TearDown]
    public void TearDown()
    {
        _services.Dispose();
    }

    [Test]
    public async Task FullExecutionLifecycle_WorksCorrectly()
    {
        // Register tool
        var tool = MockToolBuilder.Create()
            .WithId("integration-tool")
            .WithName("Integration Test Tool")
            .WithSchema(schema => schema
                .AddString("input", "Input value", required: true))
            .ExecutesWith((ctx, _) =>
            {
                var input = ctx.EffectiveParameters.GetProperty("input").GetString();
                return Task.FromResult(ToolResult.Succeeded(new { output = input + " processed" }));
            })
            .Build();

        _registry.RegisterTool(tool);

        // Verify registration
        Assert.That(_registry.HasTool("integration-tool"), Is.True);

        // Validate
        var parameters = JsonTestHelpers.ToJsonElement(new { input = "test" });
        var validation = _executionService.Validate("integration-tool", parameters);
        Assert.That(validation.IsValid, Is.True);

        // Get summary
        var summary = _executionService.GetExecutionSummary("integration-tool", parameters);
        Assert.That(summary, Is.Not.Empty);

        // Execute
        var context = TestContextBuilder.Create()
            .WithToolId("integration-tool")
            .WithParameters(parameters)
            .WithServices(_services)
            .WithApproval()
            .Build();

        var result = await _executionService.ExecuteAsync("integration-tool", context);

        // Verify result
        Assert.That(result.Status, Is.EqualTo(ToolExecutionStatus.Completed));
        Assert.That(result.IsSuccess, Is.True);
        Assert.That(
            result.Result.Data?.GetProperty("output").GetString(),
            Is.EqualTo("test processed"));
    }

    [Test]
    public void FunctionDefinitions_AreCorrectlyGenerated()
    {
        _registry.RegisterTool(MockToolBuilder.Create()
            .WithId("test-tool")
            .WithDescription("A test tool for function definitions")
            .WithSchema(schema => schema
                .AddString("path", "File path", required: true)
                .AddBoolean("recursive", "Search recursively"))
            .Build());

        var definitions = _registry.GetFunctionDefinitions();

        Assert.That(definitions, Has.Count.EqualTo(1));

        var def = definitions[0];
        Assert.That(def.Name, Is.EqualTo("test-tool"));
        Assert.That(def.Description, Is.EqualTo("A test tool for function definitions"));
        Assert.That(def.Parameters.Required, Contains.Item("path"));
    }

    [Test]
    public async Task MultipleToolsExecution_WorksIndependently()
    {
        var tool1 = MockToolBuilder.Create()
            .WithId("tool-1")
            .Succeeds(new { source = "tool-1" })
            .Build();

        var tool2 = MockToolBuilder.Create()
            .WithId("tool-2")
            .Succeeds(new { source = "tool-2" })
            .Build();

        _registry.RegisterTool(tool1);
        _registry.RegisterTool(tool2);

        var context1 = TestContextBuilder.Create()
            .WithToolId("tool-1")
            .WithServices(_services)
            .Build();

        var context2 = TestContextBuilder.Create()
            .WithToolId("tool-2")
            .WithServices(_services)
            .Build();

        var result1 = await _executionService.ExecuteAsync("tool-1", context1);
        var result2 = await _executionService.ExecuteAsync("tool-2", context2);

        Assert.That(result1.IsSuccess, Is.True);
        Assert.That(result2.IsSuccess, Is.True);
        Assert.That(
            result1.Result.Data?.GetProperty("source").GetString(),
            Is.EqualTo("tool-1"));
        Assert.That(
            result2.Result.Data?.GetProperty("source").GetString(),
            Is.EqualTo("tool-2"));
    }

    [Test]
    public async Task EventPropagation_WorksCorrectly()
    {
        var tool = MockTool.Succeeding("event-test");
        _registry.RegisterTool(tool);

        var events = new List<string>();
        _executionService.ExecutionStarted += (_, _) => events.Add("started");
        _executionService.ExecutionCompleted += (_, _) => events.Add("completed");

        var context = TestContextBuilder.Create()
            .WithToolId("event-test")
            .WithServices(_services)
            .Build();

        await _executionService.ExecuteAsync("event-test", context);

        Assert.That(events, Is.EqualTo(new[] { "started", "completed" }));
    }

    [Test]
    public void RegistryFiltering_WithDIContext_WorksCorrectly()
    {
        // Register tools with different categories
        _registry.RegisterTool(MockTool.WithCategoryAndRisk(
            "file-tool", ToolCategory.FileSystem, RiskLevel.Safe));
        _registry.RegisterTool(MockTool.WithCategoryAndRisk(
            "terminal-tool", ToolCategory.Terminal, RiskLevel.Medium));
        _registry.RegisterTool(MockTool.WithCategoryAndRisk(
            "git-tool", ToolCategory.Git, RiskLevel.Low));

        // Filter by context
        var context = ToolAvailabilityContext.Create()
            .WithTerminal(false)
            .WithGitRepository(false)
            .Build();

        var availableTools = _registry.GetAvailableTools(context);

        Assert.That(availableTools, Has.Count.EqualTo(1));
        Assert.That(availableTools[0].Id, Is.EqualTo("file-tool"));
    }

    [Test]
    public async Task ToolCallTracking_AcrossMultipleExecutions()
    {
        var tool = new MockTool("tracking-tool");
        _registry.RegisterTool(tool);

        for (int i = 0; i < 5; i++)
        {
            var context = TestContextBuilder.Create()
                .WithToolId("tracking-tool")
                .WithParametersFromObject(new { iteration = i })
                .WithServices(_services)
                .Build();

            await _executionService.ExecuteAsync("tracking-tool", context);
        }

        Assert.That(tool.ExecuteCallCount, Is.EqualTo(5));
        Assert.That(tool.ExecutedParameters, Has.Count.EqualTo(5));
    }

    [Test]
    public void DIExtensions_RegisterCorrectly()
    {
        var services = new ServiceCollection()
            .AddToolFramework()
            .AddTool<MockTool>();

        using var provider = services.BuildServiceProvider();
        provider.ConfigureTools();

        var registry = provider.GetRequiredService<IToolRegistry>();
        var executionService = provider.GetRequiredService<IToolExecutionService>();

        Assert.That(registry, Is.Not.Null);
        Assert.That(executionService, Is.Not.Null);
        Assert.That(registry.Count, Is.EqualTo(1));
    }
}
```

---

## Directory Structure

```
tests/AIntern.Tests/
├── Mocks/
│   ├── MockTool.cs                                (NEW)
│   ├── MockToolBuilder.cs                         (NEW)
│   └── MockServiceProvider.cs                     (NEW)
├── Helpers/
│   ├── TestContextBuilder.cs                      (NEW)
│   ├── JsonTestHelpers.cs                         (NEW)
│   └── ToolTestHelpers.cs                         (NEW)
├── Unit/
│   └── Tools/
│       ├── ToolRegistryTests.cs                   (NEW)
│       ├── ToolExecutionServiceTests.cs           (NEW)
│       ├── JsonSchemaBuilderTests.cs              (NEW)
│       ├── ToolValidationTests.cs                 (NEW)
│       ├── ToolResultTests.cs                     (NEW)
│       ├── ToolExecutionResultTests.cs            (NEW)
│       ├── ToolExecutionContextTests.cs           (NEW)
│       └── ToolBaseTests.cs                       (NEW)
└── Integration/
    └── Tools/
        └── ToolFrameworkIntegrationTests.cs       (NEW)
```

---

## Unit Test Plan Summary

| Test File | Test Count | Focus |
|-----------|------------|-------|
| `ToolRegistryTests.cs` | 24 | Registration, lookup, filtering, events |
| `ToolExecutionServiceTests.cs` | 26 | Execution, timeout, cancellation, events |
| `JsonSchemaBuilderTests.cs` | 18 | Schema building, property types |
| `ToolValidationTests.cs` | 14 | Parameter validation, error handling |
| `ToolResultTests.cs` | 12 | Factory methods, properties |
| `ToolExecutionResultTests.cs` | 10 | Factory methods, duration calculation |
| `ToolExecutionContextTests.cs` | 10 | Path resolution, service access |
| `ToolBaseTests.cs` | 12 | Parameter extraction, progress |
| `ToolFrameworkIntegrationTests.cs` | 8 | End-to-end flows |
| **Total** | **134** | |

---

## File Summary

### Files to Create

| File | Location | Lines | Purpose |
|------|----------|-------|---------|
| `MockTool.cs` | `Tests/Mocks/` | ~280 | Configurable mock tool |
| `MockToolBuilder.cs` | `Tests/Mocks/` | ~200 | Fluent tool builder |
| `TestContextBuilder.cs` | `Tests/Helpers/` | ~130 | Context builder for tests |
| `JsonTestHelpers.cs` | `Tests/Helpers/` | ~100 | JSON test utilities |
| `ToolTestHelpers.cs` | `Tests/Helpers/` | ~120 | Tool framework helpers |
| `ToolRegistryTests.cs` | `Tests/Unit/Tools/` | ~320 | Registry unit tests |
| `ToolExecutionServiceTests.cs` | `Tests/Unit/Tools/` | ~360 | Execution service tests |
| `JsonSchemaBuilderTests.cs` | `Tests/Unit/Tools/` | ~180 | Schema builder tests |
| `ToolValidationTests.cs` | `Tests/Unit/Tools/` | ~140 | Validation tests |
| `ToolResultTests.cs` | `Tests/Unit/Tools/` | ~120 | Result model tests |
| `ToolExecutionResultTests.cs` | `Tests/Unit/Tools/` | ~100 | Execution result tests |
| `ToolExecutionContextTests.cs` | `Tests/Unit/Tools/` | ~100 | Context tests |
| `ToolBaseTests.cs` | `Tests/Unit/Tools/` | ~120 | Base class tests |
| `ToolFrameworkIntegrationTests.cs` | `Tests/Integration/Tools/` | ~180 | Integration tests |
| **Total** | | **~2,450** | |

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | `MockTool` supports configurable execution behavior |
| AC-2 | `MockTool` supports configurable validation behavior |
| AC-3 | `MockTool` tracks call counts and parameters |
| AC-4 | `MockTool` factory methods cover common scenarios |
| AC-5 | `MockToolBuilder` provides fluent API |
| AC-6 | `TestContextBuilder` creates valid contexts |
| AC-7 | `JsonTestHelpers` simplify JSON operations |
| AC-8 | `ToolTestHelpers` reduce test boilerplate |
| AC-9 | Unit tests cover all public APIs |
| AC-10 | Integration tests verify end-to-end flows |
| AC-11 | Test coverage exceeds 80% for core classes |
| AC-12 | All 134 tests pass |

---

## Changelog Entry

```markdown
## v0.6.1j - Testing Infrastructure

### Added
- `MockTool` class with:
  - Configurable execution behavior via delegates
  - Configurable validation behavior via delegates
  - Call tracking (ExecuteCallCount, ValidateCallCount)
  - Parameter capture (ExecutedParameters, ValidatedParameters)
  - Factory methods: Succeeding, Failing, Throwing, Delayed
  - Factory methods: WithProgress, Unavailable, WithCategoryAndRisk
  - Factory method: WithFailingValidation

- `MockToolBuilder` fluent API with:
  - WithId, WithName, WithDescription
  - WithCategory, WithRiskLevel
  - WithSchema (direct and builder action)
  - IsAvailable, WithTags
  - ExecutesWith, Succeeds, Fails, Throws, DelaysFor
  - ValidatesWith, ValidationPasses, ValidationFails
  - WithSummary, WithEffectiveRisk

- Test helpers:
  - TestContextBuilder for execution context creation
  - JsonTestHelpers for JSON operations (ParseJson, ToJsonElement)
  - ToolTestHelpers for registry and service creation

- Unit tests:
  - ToolRegistryTests (24 tests)
  - ToolExecutionServiceTests (26 tests)
  - JsonSchemaBuilderTests (18 tests)
  - ToolValidationTests (14 tests)
  - ToolResultTests (12 tests)
  - ToolExecutionResultTests (10 tests)
  - ToolExecutionContextTests (10 tests)
  - ToolBaseTests (12 tests)

- Integration tests:
  - ToolFrameworkIntegrationTests (8 tests)
  - Full execution lifecycle validation
  - Multi-tool scenarios
  - DI integration tests
```

---

## Implementation Notes

### MockTool Design
The `MockTool` class is designed to be highly configurable while remaining simple to use. The constructor accepts optional parameters for all aspects of tool behavior, and factory methods provide shortcuts for common scenarios. Call tracking enables verification of tool interactions in tests.

### Builder Pattern
Both `MockToolBuilder` and `TestContextBuilder` use the fluent builder pattern for readability. Each method returns `this` to enable method chaining, and the `Build()` method creates the final object.

### Test Isolation
Each test creates its own registry and service instances to ensure isolation. The `SetUp` method creates fresh instances, and integration tests use a dedicated `ServiceProvider` that is disposed in `TearDown`.

### Coverage Strategy
Unit tests focus on individual methods and edge cases, while integration tests verify that components work together correctly. The test plan targets >80% coverage for core classes, with higher coverage (>90%) for critical components like `ToolRegistry` and `ToolExecutionService`.

### Async Test Patterns
Async tests use `async Task` return types and `await` for asynchronous operations. Cancellation tests use `CancellationTokenSource` to trigger cancellation during execution.

---

## Timeline Estimate

| Task | Estimated Effort |
|------|------------------|
| MockTool and MockToolBuilder | 0.3 day |
| Test helpers | 0.25 day |
| ToolRegistryTests | 0.3 day |
| ToolExecutionServiceTests | 0.35 day |
| Other unit tests | 0.4 day |
| Integration tests | 0.25 day |
| Documentation and review | 0.15 day |
| **Total** | **2.0 days** |
