# Design Specification: AIntern v0.6.3a "File Read Tools"

## Overview

**Version**: v0.6.3a
**Parent**: v0.6.3 Built-in Tools
**Focus**: ReadFileTool with line filtering, encoding detection, and large file handling

### Purpose

Implement the ReadFileTool that enables the AI agent to:
1. Read file contents from the workspace
2. Filter by line range (start_line, end_line)
3. Limit lines returned with truncation warnings
4. Include optional line numbers in output
5. Detect file encoding
6. Handle large files with clear size limits
7. Validate paths to prevent directory traversal

### Dependencies

**From v0.6.1 (Tool Framework)**:
- `ToolBase` abstract class
- `ITool` interface
- `ToolResult`, `ToolValidationResult`
- `JsonSchema`, `JsonSchemaBuilder`
- `RiskLevel`, `ToolCategory`

**From v0.3.x (Workspace Awareness)**:
- `IWorkspaceService` for workspace paths
- `IFileSystemService` for file operations

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                    v0.6.3a File Read Tools Architecture                       │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  src/SeniorIntern.Services/Tools/FileSystem/                                 │
│  ├─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  ReadFileTool : ToolBase                                                 │ │
│  │  ┌─────────────────────────────────────────────────────────────────────┐│ │
│  │  │  Properties                                                          ││ │
│  │  │  ├── Id: "file-read"                                                 ││ │
│  │  │  ├── Name: "Read File"                                               ││ │
│  │  │  ├── Category: FileSystem                                             ││ │
│  │  │  └── DefaultRiskLevel: Safe                                           ││ │
│  │  │                                                                      ││ │
│  │  │  Parameters                                                           ││ │
│  │  │  ├── path: string (required) - Relative path to file                 ││ │
│  │  │  ├── start_line: int (optional) - Starting line (1-based)            ││ │
│  │  │  ├── end_line: int (optional) - Ending line (1-based)                ││ │
│  │  │  ├── max_lines: int (optional) - Max lines to read (default: 1000)   ││ │
│  │  │  └── include_line_numbers: bool (optional, default: true)            ││ │
│  │  │                                                                      ││ │
│  │  │  Dependencies                                                         ││ │
│  │  │  ├── IFileSystemService _fileSystem                                  ││ │
│  │  │  ├── IWorkspaceService _workspace                                    ││ │
│  │  │  └── ILogger<ReadFileTool> _logger                                   ││ │
│  │  │                                                                      ││ │
│  │  │  Constants                                                            ││ │
│  │  │  ├── DefaultMaxLines = 1000                                          ││ │
│  │  │  └── MaxFileSizeBytes = 10 * 1024 * 1024 (10 MB)                     ││ │
│  │  └─────────────────────────────────────────────────────────────────────┘│ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  src/SeniorIntern.Services/Tools/                                            │
│  ├─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  ToolPathHelper (static)                                                 │ │
│  │  ├── ResolvePath(workspacePath, relativePath) → fullPath                │ │
│  │  ├── ValidatePath(fullPath, workspacePath) → PathValidationResult       │ │
│  │  ├── IsWithinWorkspace(fullPath, workspacePath) → bool                  │ │
│  │  ├── NormalizePath(path) → string                                       │ │
│  │  └── FormatFileSize(bytes) → string                                     │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  src/SeniorIntern.Core/Models/                                               │
│  ├─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  ReadFileResultData                                                      │ │
│  │  ├── Path: string                                                        │ │
│  │  ├── TotalLines: int                                                     │ │
│  │  ├── StartLine: int                                                      │ │
│  │  ├── EndLine: int                                                        │ │
│  │  ├── LinesReturned: int                                                  │ │
│  │  ├── WasTruncated: bool                                                  │ │
│  │  ├── Encoding: string                                                    │ │
│  │  ├── FileSize: long                                                      │ │
│  │  └── LastModified: DateTime?                                             │ │
│  │                                                                          │ │
│  │  FileInfoResult                                                          │ │
│  │  ├── Path: string                                                        │ │
│  │  ├── Size: long                                                          │ │
│  │  ├── LastModified: DateTime?                                             │ │
│  │  ├── Created: DateTime?                                                  │ │
│  │  ├── Encoding: string?                                                   │ │
│  │  ├── IsReadOnly: bool                                                    │ │
│  │  └── IsHidden: bool                                                      │ │
│  │                                                                          │ │
│  │  PathValidationResult                                                    │ │
│  │  ├── IsValid: bool                                                       │ │
│  │  ├── ErrorMessage: string?                                               │ │
│  │  └── NormalizedPath: string?                                             │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Execution Flow

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                        ReadFileTool Execution Flow                            │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ExecuteAsync(context)                                                       │
│      │                                                                       │
│      ▼                                                                       │
│  ┌─────────────────────────────┐                                             │
│  │  1. Extract Parameters      │                                             │
│  │  ├── path (required)        │                                             │
│  │  ├── start_line (optional)  │                                             │
│  │  ├── end_line (optional)    │                                             │
│  │  ├── max_lines (default 1000)│                                            │
│  │  └── include_line_numbers   │                                             │
│  └─────────────┬───────────────┘                                             │
│                │                                                             │
│                ▼                                                             │
│  ┌─────────────────────────────┐                                             │
│  │  2. Resolve & Validate Path │                                             │
│  │  ├── Join workspace + path  │                                             │
│  │  ├── Normalize (no ..)      │                                             │
│  │  └── Check within workspace │                                             │
│  └─────────────┬───────────────┘                                             │
│                │                                                             │
│       ┌────────┴────────┐                                                    │
│       │ Invalid path    │ Valid path                                         │
│       ▼                 ▼                                                    │
│  ┌──────────┐    ┌─────────────────────────────┐                             │
│  │  RETURN  │    │  3. Check File Exists       │                             │
│  │  Failed  │    │  FileExistsAsync(fullPath)  │                             │
│  └──────────┘    └─────────────┬───────────────┘                             │
│                                │                                             │
│                       ┌────────┴────────┐                                    │
│                       │ Not found       │ Found                              │
│                       ▼                 ▼                                    │
│                  ┌──────────┐    ┌─────────────────────────────┐             │
│                  │  RETURN  │    │  4. Check File Size         │             │
│                  │  Failed  │    │  GetFileInfoAsync(fullPath) │             │
│                  └──────────┘    └─────────────┬───────────────┘             │
│                                                │                             │
│                                       ┌────────┴────────┐                    │
│                                       │ > 10 MB         │ ≤ 10 MB            │
│                                       ▼                 ▼                    │
│                                  ┌──────────┐    ┌─────────────────────────┐ │
│                                  │  RETURN  │    │  5. Read File Content   │ │
│                                  │  Failed  │    │  ReadFileAsync(fullPath)│ │
│                                  └──────────┘    └─────────────┬───────────┘ │
│                                                                │             │
│                                                                ▼             │
│                                                 ┌─────────────────────────┐  │
│                                                 │  6. Apply Line Filter   │  │
│                                                 │  ├── start_line adjust  │  │
│                                                 │  ├── end_line adjust    │  │
│                                                 │  └── max_lines truncate │  │
│                                                 └─────────────┬───────────┘  │
│                                                                │             │
│                                                                ▼             │
│                                                 ┌─────────────────────────┐  │
│                                                 │  7. Format Output       │  │
│                                                 │  ├── Add line numbers   │  │
│                                                 │  └── Join lines         │  │
│                                                 └─────────────┬───────────┘  │
│                                                                │             │
│                                                                ▼             │
│                                                 ┌─────────────────────────┐  │
│                                                 │  8. Build Result        │  │
│                                                 │  ├── Content string     │  │
│                                                 │  ├── ReadFileResultData │  │
│                                                 │  └── Success message    │  │
│                                                 └─────────────────────────┘  │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Specifications

### 1. ReadFileTool.cs

**Location**: `src/SeniorIntern.Services/Tools/FileSystem/ReadFileTool.cs`

```csharp
namespace SeniorIntern.Services.Tools.FileSystem;

using System.Text;
using System.Text.Json;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Core.Tools;
using SeniorIntern.Services.Tools;

/// <summary>
/// Tool for reading file contents from the workspace.
/// </summary>
/// <remarks>
/// <para>
/// ReadFileTool provides the AI agent with the ability to examine file contents
/// before making changes. It supports:
/// </para>
/// <list type="bullet">
/// <item>Reading entire files or specific line ranges</item>
/// <item>Automatic encoding detection</item>
/// <item>Large file handling with truncation warnings</item>
/// <item>Optional line number formatting</item>
/// </list>
/// </remarks>
public sealed class ReadFileTool : ToolBase
{
    #region Tool Metadata

    public override string Id => "file-read";

    public override string Name => "Read File";

    public override string Description => """
        Read the contents of a file from the workspace.
        Returns the file content as text with optional line filtering.
        Use this when you need to examine file contents before making changes.

        Supports:
        - Reading entire files or specific line ranges
        - Automatic encoding detection
        - Large file handling with truncation warnings
        """;

    public override ToolCategory Category => ToolCategory.FileSystem;

    public override RiskLevel DefaultRiskLevel => RiskLevel.Safe;

    public override IReadOnlyList<string> Tags => new[] { "file", "read", "view", "content" };

    public override JsonSchema InputSchema => JsonSchemaBuilder.Create()
        .WithDescription("Parameters for reading a file")
        .AddString("path", "Relative path to the file within the workspace", required: true)
        .AddInteger("start_line", "Starting line number (1-based, inclusive)", required: false)
        .AddInteger("end_line", "Ending line number (1-based, inclusive)", required: false)
        .AddInteger("max_lines", "Maximum number of lines to read (default: 1000)", required: false)
        .AddBoolean("include_line_numbers", "Include line numbers in output (default: true)", required: false)
        .Build();

    #endregion

    #region Dependencies

    private readonly IFileSystemService _fileSystem;
    private readonly IWorkspaceService _workspace;
    private readonly ILogger<ReadFileTool> _logger;

    #endregion

    #region Constants

    /// <summary>
    /// Default maximum lines to return if not specified.
    /// </summary>
    public const int DefaultMaxLines = 1000;

    /// <summary>
    /// Maximum file size in bytes that can be read (10 MB).
    /// </summary>
    public const int MaxFileSizeBytes = 10 * 1024 * 1024;

    #endregion

    public ReadFileTool(
        IFileSystemService fileSystem,
        IWorkspaceService workspace,
        ILogger<ReadFileTool> logger)
    {
        _fileSystem = fileSystem ?? throw new ArgumentNullException(nameof(fileSystem));
        _workspace = workspace ?? throw new ArgumentNullException(nameof(workspace));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <summary>
    /// Tool is available when a workspace is active.
    /// </summary>
    public override bool IsAvailable => _workspace.CurrentWorkspace != null;

    #region ExecuteAsync

    public override async Task<ToolResult> ExecuteAsync(
        ToolExecutionContext context,
        CancellationToken ct = default)
    {
        // Extract parameters
        var path = GetRequiredParameter<string>(context.Parameters, "path");
        var startLine = GetOptionalParameter<int?>(context.Parameters, "start_line");
        var endLine = GetOptionalParameter<int?>(context.Parameters, "end_line");
        var maxLines = GetOptionalParameter(context.Parameters, "max_lines", DefaultMaxLines);
        var includeLineNumbers = GetOptionalParameter(context.Parameters, "include_line_numbers", true);

        _logger.LogDebug(
            "ReadFileTool executing: path={Path}, lines={Start}-{End}, max={Max}",
            path, startLine, endLine, maxLines);

        // Resolve and validate path
        var fullPath = ToolPathHelper.ResolvePath(context.WorkspacePath, path);
        var pathValidation = ToolPathHelper.ValidatePath(fullPath, context.WorkspacePath);

        if (!pathValidation.IsValid)
        {
            _logger.LogWarning("Path validation failed: {Error}", pathValidation.ErrorMessage);
            return ToolResult.Failed(pathValidation.ErrorMessage!);
        }

        // Check file exists
        if (!await _fileSystem.FileExistsAsync(fullPath, ct))
        {
            _logger.LogWarning("File not found: {Path}", fullPath);
            return ToolResult.Failed($"File not found: {path}");
        }

        // Check file size
        var fileInfo = await _fileSystem.GetFileInfoAsync(fullPath, ct);
        if (fileInfo.Size > MaxFileSizeBytes)
        {
            _logger.LogWarning("File too large: {Size} bytes", fileInfo.Size);
            return ToolResult.Failed(
                $"File too large ({ToolPathHelper.FormatFileSize(fileInfo.Size)}). " +
                $"Maximum size: {ToolPathHelper.FormatFileSize(MaxFileSizeBytes)}. " +
                "Consider using start_line/end_line parameters to read a portion.");
        }

        try
        {
            // Read file content
            var content = await _fileSystem.ReadFileAsync(fullPath, ct);
            var lines = content.Split('\n');
            var totalLines = lines.Length;

            _logger.LogDebug("Read {TotalLines} lines from file", totalLines);

            // Apply line filtering
            var (filteredLines, actualStart, actualEnd, wasTruncated) =
                ApplyLineFilter(lines, startLine, endLine, maxLines);

            // Format output
            var output = FormatOutput(filteredLines, actualStart, includeLineNumbers);

            // Build result data
            var resultData = new ReadFileResultData
            {
                Path = path,
                TotalLines = totalLines,
                StartLine = actualStart,
                EndLine = actualEnd,
                LinesReturned = filteredLines.Length,
                WasTruncated = wasTruncated,
                Encoding = fileInfo.Encoding ?? "utf-8",
                FileSize = fileInfo.Size,
                LastModified = fileInfo.LastModified
            };

            var message = wasTruncated
                ? $"Read lines {actualStart}-{actualEnd} of {totalLines} (truncated to {maxLines} lines)"
                : $"Read {filteredLines.Length} lines from {path}";

            _logger.LogInformation(
                "ReadFileTool success: {Path}, lines {Start}-{End}, truncated={Truncated}",
                path, actualStart, actualEnd, wasTruncated);

            return ToolResult.Success(output, resultData, message);
        }
        catch (UnauthorizedAccessException ex)
        {
            _logger.LogWarning(ex, "Access denied to file: {Path}", path);
            return ToolResult.Failed($"Access denied: {path}");
        }
        catch (IOException ex)
        {
            _logger.LogError(ex, "Failed to read file: {Path}", path);
            return ToolResult.Failed($"Failed to read file: {ex.Message}");
        }
    }

    #endregion

    #region Line Filtering

    /// <summary>
    /// Apply line range filtering and truncation.
    /// </summary>
    private static (string[] Lines, int Start, int End, bool Truncated) ApplyLineFilter(
        string[] lines, int? startLine, int? endLine, int maxLines)
    {
        // Clamp start/end to valid range
        var start = Math.Max(1, startLine ?? 1);
        var end = Math.Min(lines.Length, endLine ?? lines.Length);

        // Handle invalid range
        if (start > lines.Length)
        {
            return (Array.Empty<string>(), start, start, false);
        }

        // Adjust for 0-based indexing
        var startIndex = start - 1;
        var endIndex = Math.Min(end, lines.Length);

        var selectedLines = lines[startIndex..endIndex];
        var truncated = false;

        // Apply max_lines limit
        if (selectedLines.Length > maxLines)
        {
            selectedLines = selectedLines[..maxLines];
            truncated = true;
            end = start + maxLines - 1;
        }

        return (selectedLines, start, end, truncated);
    }

    #endregion

    #region Output Formatting

    /// <summary>
    /// Format lines with optional line numbers.
    /// </summary>
    private static string FormatOutput(string[] lines, int startLine, bool includeLineNumbers)
    {
        if (lines.Length == 0)
        {
            return string.Empty;
        }

        if (!includeLineNumbers)
        {
            return string.Join('\n', lines);
        }

        var sb = new StringBuilder();
        var lineNumWidth = (startLine + lines.Length - 1).ToString().Length;

        for (int i = 0; i < lines.Length; i++)
        {
            var lineNum = (startLine + i).ToString().PadLeft(lineNumWidth);
            sb.AppendLine($"{lineNum} | {lines[i]}");
        }

        return sb.ToString().TrimEnd();
    }

    #endregion

    #region Overrides

    public override string GetExecutionSummary(JsonElement parameters)
    {
        var path = parameters.TryGetProperty("path", out var p) 
            ? p.GetString() ?? "unknown" 
            : "unknown";
        var shortPath = path.Length > 40 ? "..." + path[^37..] : path;

        if (parameters.TryGetProperty("start_line", out var start))
        {
            var startLine = start.GetInt32();
            if (parameters.TryGetProperty("end_line", out var end))
            {
                return $"Read '{shortPath}' lines {startLine}-{end.GetInt32()}";
            }
            return $"Read '{shortPath}' from line {startLine}";
        }

        return $"Read file '{shortPath}'";
    }

    public override ToolValidationResult Validate(JsonElement parameters)
    {
        var errors = new List<ToolValidationError>();

        // Validate required path
        if (!parameters.TryGetProperty("path", out var pathProp) ||
            string.IsNullOrWhiteSpace(pathProp.GetString()))
        {
            errors.Add(ToolValidationError.Required("path"));
        }

        // Validate start_line
        if (parameters.TryGetProperty("start_line", out var start))
        {
            var startLine = start.GetInt32();
            if (startLine < 1)
            {
                errors.Add(new ToolValidationError
                {
                    ParameterName = "start_line",
                    Message = "Start line must be at least 1",
                    Code = "INVALID_RANGE"
                });
            }
        }

        // Validate end_line
        if (parameters.TryGetProperty("end_line", out var end))
        {
            var endLine = end.GetInt32();
            if (endLine < 1)
            {
                errors.Add(new ToolValidationError
                {
                    ParameterName = "end_line",
                    Message = "End line must be at least 1",
                    Code = "INVALID_RANGE"
                });
            }

            if (parameters.TryGetProperty("start_line", out start) && endLine < start.GetInt32())
            {
                errors.Add(new ToolValidationError
                {
                    ParameterName = "end_line",
                    Message = "End line must be >= start line",
                    Code = "INVALID_RANGE"
                });
            }
        }

        // Validate max_lines
        if (parameters.TryGetProperty("max_lines", out var max))
        {
            var maxLines = max.GetInt32();
            if (maxLines < 1)
            {
                errors.Add(new ToolValidationError
                {
                    ParameterName = "max_lines",
                    Message = "Max lines must be at least 1",
                    Code = "INVALID_RANGE"
                });
            }
        }

        return errors.Count > 0
            ? ToolValidationResult.Invalid(errors)
            : ToolValidationResult.Valid();
    }

    #endregion
}
```

### 2. ReadFileResultData.cs

**Location**: `src/SeniorIntern.Core/Models/ReadFileResultData.cs`

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Structured result data for file read operations.
/// </summary>
/// <remarks>
/// Contains metadata about the read operation that can be used
/// by the agent to understand context (e.g., truncation warnings).
/// </remarks>
public sealed class ReadFileResultData
{
    /// <summary>
    /// Relative path to the file that was read.
    /// </summary>
    public string Path { get; init; } = string.Empty;

    /// <summary>
    /// Total number of lines in the file.
    /// </summary>
    public int TotalLines { get; init; }

    /// <summary>
    /// First line number returned (1-based).
    /// </summary>
    public int StartLine { get; init; }

    /// <summary>
    /// Last line number returned (1-based).
    /// </summary>
    public int EndLine { get; init; }

    /// <summary>
    /// Actual number of lines returned.
    /// </summary>
    public int LinesReturned { get; init; }

    /// <summary>
    /// Whether the output was truncated due to max_lines.
    /// </summary>
    public bool WasTruncated { get; init; }

    /// <summary>
    /// Detected file encoding.
    /// </summary>
    public string Encoding { get; init; } = "utf-8";

    /// <summary>
    /// File size in bytes.
    /// </summary>
    public long FileSize { get; init; }

    /// <summary>
    /// Last modification time.
    /// </summary>
    public DateTime? LastModified { get; init; }

    /// <summary>
    /// Lines remaining after EndLine.
    /// </summary>
    public int RemainingLines => TotalLines - EndLine;

    /// <summary>
    /// Percentage of file that was read.
    /// </summary>
    public double PercentageRead => TotalLines > 0 ? (double)LinesReturned / TotalLines * 100 : 100;
}
```

### 3. ToolPathHelper.cs

**Location**: `src/SeniorIntern.Services/Tools/ToolPathHelper.cs`

```csharp
namespace SeniorIntern.Services.Tools;

/// <summary>
/// Helper utilities for path validation and resolution in tools.
/// </summary>
/// <remarks>
/// Provides centralized path handling to ensure security across all
/// file system tools, preventing directory traversal attacks.
/// </remarks>
public static class ToolPathHelper
{
    /// <summary>
    /// Resolve a relative path against a workspace root.
    /// </summary>
    /// <param name="workspacePath">Workspace root path.</param>
    /// <param name="relativePath">Relative path within workspace.</param>
    /// <returns>Full absolute path.</returns>
    public static string ResolvePath(string? workspacePath, string relativePath)
    {
        if (string.IsNullOrEmpty(workspacePath))
        {
            throw new InvalidOperationException("No workspace path configured");
        }

        // Handle absolute paths by making them relative
        if (Path.IsPathRooted(relativePath))
        {
            relativePath = relativePath.TrimStart('/', '\\');
        }

        // Combine and normalize
        var combined = Path.Combine(workspacePath, relativePath);
        return Path.GetFullPath(combined);
    }

    /// <summary>
    /// Validate that a path is safe and within the workspace.
    /// </summary>
    public static PathValidationResult ValidatePath(string fullPath, string? workspacePath)
    {
        if (string.IsNullOrEmpty(workspacePath))
        {
            return PathValidationResult.Error("No workspace configured");
        }

        // Normalize paths for comparison
        var normalizedPath = NormalizePath(fullPath);
        var normalizedWorkspace = NormalizePath(workspacePath);

        // Check path is within workspace (prevent directory traversal)
        if (!normalizedPath.StartsWith(normalizedWorkspace, StringComparison.OrdinalIgnoreCase))
        {
            return PathValidationResult.Error(
                "Path is outside the workspace. Only files within the workspace can be accessed.");
        }

        // Check for suspicious patterns
        var relativePart = fullPath[workspacePath.Length..].TrimStart(Path.DirectorySeparatorChar);
        if (ContainsSuspiciousPatterns(relativePart))
        {
            return PathValidationResult.Error(
                "Path contains invalid characters or patterns.");
        }

        return PathValidationResult.Ok(normalizedPath);
    }

    /// <summary>
    /// Check if a path is within the workspace bounds.
    /// </summary>
    public static bool IsWithinWorkspace(string fullPath, string workspacePath)
    {
        var normalized = NormalizePath(fullPath);
        var normalizedWorkspace = NormalizePath(workspacePath);
        return normalized.StartsWith(normalizedWorkspace, StringComparison.OrdinalIgnoreCase);
    }

    /// <summary>
    /// Normalize a path for consistent comparison.
    /// </summary>
    public static string NormalizePath(string path)
    {
        var fullPath = Path.GetFullPath(path);
        
        // Ensure consistent trailing separator for directories
        if (Directory.Exists(fullPath) && !fullPath.EndsWith(Path.DirectorySeparatorChar))
        {
            fullPath += Path.DirectorySeparatorChar;
        }

        return fullPath;
    }

    /// <summary>
    /// Format file size for human-readable output.
    /// </summary>
    public static string FormatFileSize(long bytes)
    {
        return bytes switch
        {
            < 1024 => $"{bytes} B",
            < 1024 * 1024 => $"{bytes / 1024.0:F1} KB",
            < 1024 * 1024 * 1024 => $"{bytes / (1024.0 * 1024):F1} MB",
            _ => $"{bytes / (1024.0 * 1024 * 1024):F2} GB"
        };
    }

    /// <summary>
    /// Get the relative path from workspace root.
    /// </summary>
    public static string GetRelativePath(string fullPath, string workspacePath)
    {
        return Path.GetRelativePath(workspacePath, fullPath);
    }

    /// <summary>
    /// Check for suspicious path patterns.
    /// </summary>
    private static bool ContainsSuspiciousPatterns(string path)
    {
        var suspicious = new[]
        {
            "..",           // Parent directory traversal
            "~",            // Home directory expansion
            "\0",           // Null byte injection
            "|", ">", "<",  // Shell redirection
            "$(",           // Command substitution
        };

        return suspicious.Any(s => path.Contains(s));
    }
}

/// <summary>
/// Result of path validation.
/// </summary>
public sealed class PathValidationResult
{
    public bool IsValid { get; init; }
    public string? ErrorMessage { get; init; }
    public string? NormalizedPath { get; init; }

    public static PathValidationResult Ok(string normalizedPath) => new()
    {
        IsValid = true,
        NormalizedPath = normalizedPath
    };

    public static PathValidationResult Error(string message) => new()
    {
        IsValid = false,
        ErrorMessage = message
    };
}
```

### 4. FileInfoResult.cs

**Location**: `src/SeniorIntern.Core/Models/FileInfoResult.cs`

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Extended file information for tool operations.
/// </summary>
public sealed class FileInfoResult
{
    /// <summary>
    /// Full path to the file.
    /// </summary>
    public string Path { get; init; } = string.Empty;

    /// <summary>
    /// File size in bytes.
    /// </summary>
    public long Size { get; init; }

    /// <summary>
    /// Last modification timestamp.
    /// </summary>
    public DateTime? LastModified { get; init; }

    /// <summary>
    /// Creation timestamp.
    /// </summary>
    public DateTime? Created { get; init; }

    /// <summary>
    /// Detected encoding (if text file).
    /// </summary>
    public string? Encoding { get; init; }

    /// <summary>
    /// Whether the file is read-only.
    /// </summary>
    public bool IsReadOnly { get; init; }

    /// <summary>
    /// Whether the file is hidden.
    /// </summary>
    public bool IsHidden { get; init; }

    /// <summary>
    /// File extension (including dot).
    /// </summary>
    public string Extension => System.IO.Path.GetExtension(Path);

    /// <summary>
    /// File name without directory.
    /// </summary>
    public string FileName => System.IO.Path.GetFileName(Path);
}
```

---

## IFileSystemService Extensions

Add these methods to the existing `IFileSystemService` interface:

```csharp
// In src/SeniorIntern.Core/Interfaces/IFileSystemService.cs

/// <summary>
/// Get detailed file information.
/// </summary>
Task<FileInfoResult> GetFileInfoAsync(string path, CancellationToken ct = default);

/// <summary>
/// Check if a file exists.
/// </summary>
Task<bool> FileExistsAsync(string path, CancellationToken ct = default);

/// <summary>
/// Read file content as string with encoding detection.
/// </summary>
Task<string> ReadFileAsync(string path, CancellationToken ct = default);
```

---

## File Summary

| File | Location | Purpose | Lines |
|------|----------|---------|-------|
| `ReadFileTool.cs` | `Services/Tools/FileSystem/` | Main read tool | ~280 |
| `ReadFileResultData.cs` | `Core/Models/` | Result data model | ~60 |
| `ToolPathHelper.cs` | `Services/Tools/` | Path validation utilities | ~120 |
| `FileInfoResult.cs` | `Core/Models/` | File metadata model | ~50 |

---

## Unit Test Plan

| Test | Description |
|------|-------------|
| `ReadFileTool_ValidPath_ReturnsContent` | Basic file reading |
| `ReadFileTool_LineRange_ReturnsFilteredContent` | Line filtering |
| `ReadFileTool_MaxLines_TruncatesOutput` | Truncation behavior |
| `ReadFileTool_LineNumbers_FormatsCorrectly` | Line number formatting |
| `ReadFileTool_LargeFile_RejectsWithMessage` | Size limit enforcement |
| `ReadFileTool_FileNotFound_ReturnsError` | Missing file handling |
| `ReadFileTool_PathTraversal_Blocked` | Security validation |
| `ToolPathHelper_ResolvePath_CombinesCorrectly` | Path resolution |
| `ToolPathHelper_ValidatePath_BlocksTraversal` | Security checks |
| `ToolPathHelper_FormatFileSize_FormatsCorrectly` | Size formatting |

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | ReadFileTool reads files from workspace |
| AC-2 | Line filtering works with start_line and end_line |
| AC-3 | Large files are rejected with clear message |
| AC-4 | Line numbers are optionally included |
| AC-5 | File encoding is detected |
| AC-6 | Path validation prevents directory traversal |

---

## Changelog Entry

```markdown
## v0.6.3a - File Read Tools

### Added
- `ReadFileTool` for reading file contents from workspace
  - Line range filtering (start_line, end_line)
  - Configurable max lines with truncation warnings
  - Optional line number formatting
  - 10 MB file size limit
- `ToolPathHelper` for secure path validation
  - Directory traversal prevention
  - Workspace boundary enforcement
  - File size formatting
- `ReadFileResultData` for structured result metadata
- `FileInfoResult` for file metadata
- `PathValidationResult` for validation responses
```

---

## Timeline Estimate

| Version | Estimated Effort |
|---------|------------------|
| v0.6.3a | 0.5 day |
