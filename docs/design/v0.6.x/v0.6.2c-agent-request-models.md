# Design Specification: AIntern v0.6.2c "Agent Request Models"

## Overview

**Version**: v0.6.2c
**Parent**: v0.6.2 Semantic Kernel Integration
**Focus**: Request models, context classes, and factory methods for agent invocation

### Purpose

This sub-version defines the data models for agent request processing:
1. Create `AgentRequest` to encapsulate all request information
2. Create `ToolAvailabilityContext` for tool filtering and permissions
3. Create `FileContext` for file attachments and code context
4. Create `TextSelection` for editor selection information
5. Create `ToolPermission` for session-based permission grants
6. Create `AgentRequestBuilder` for fluent request construction
7. Create validation and factory methods for all models

### Dependencies

**From v0.6.1a (Tool Core Models)**:
- `ToolCategory` enum for category filtering
- `RiskLevel` enum for auto-approval thresholds

**From Existing Infrastructure**:
- `ChatMessage` for conversation history
- `InferenceOptions` for LLM parameters

**Future Consumers**:
- v0.6.2h: IAgentService Interface
- v0.6.2i: AgentService Implementation
- v0.6.4: Permission Manager

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                   v0.6.2c Agent Request Models Architecture                   │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  src/SeniorIntern.Core/Models/                                               │
│  ├─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  AgentRequest                                                            │ │
│  │  ┌─────────────────────────────────────────────────────────────────────┐│ │
│  │  │  Identity                                                            ││ │
│  │  │  ├── Message: string                    (user's input)              ││ │
│  │  │  ├── ConversationId: Guid               (session tracking)          ││ │
│  │  │  ├── RequestId: Guid                    (request tracking)          ││ │
│  │  │  └── CreatedAt: DateTime                (timestamp)                 ││ │
│  │  │                                                                      ││ │
│  │  │  Context                                                              ││ │
│  │  │  ├── History: IReadOnlyList<ChatMessage>?                            ││ │
│  │  │  ├── AttachedFiles: IReadOnlyList<FileContext>?                      ││ │
│  │  │  ├── SystemPrompt: string?                                           ││ │
│  │  │  └── ToolContext: ToolAvailabilityContext?                           ││ │
│  │  │                                                                      ││ │
│  │  │  Options                                                              ││ │
│  │  │  ├── InferenceOptions: InferenceOptions?                             ││ │
│  │  │  ├── EnableTools: bool                  (default: true)             ││ │
│  │  │  └── MaxIterations: int?                (override config)           ││ │
│  │  └─────────────────────────────────────────────────────────────────────┘│ │
│  │                                                                          │ │
│  │  ToolAvailabilityContext                                                  │ │
│  │  ┌─────────────────────────────────────────────────────────────────────┐│ │
│  │  │  Workspace                                                           ││ │
│  │  │  ├── WorkspacePath: string?             (project root)              ││ │
│  │  │  ├── ActiveFilePath: string?            (current file)              ││ │
│  │  │  └── ActiveSelection: TextSelection?    (current selection)         ││ │
│  │  │                                                                      ││ │
│  │  │  Tool Filtering                                                       ││ │
│  │  │  ├── EnabledToolIds: IReadOnlySet<string>?                           ││ │
│  │  │  ├── DisabledToolIds: IReadOnlySet<string>?                          ││ │
│  │  │  └── EnabledCategories: IReadOnlySet<ToolCategory>?                  ││ │
│  │  │                                                                      ││ │
│  │  │  Permissions                                                          ││ │
│  │  │  ├── MaxAutoApprovalRiskLevel: RiskLevel                             ││ │
│  │  │  ├── AllowTerminalTools: bool                                        ││ │
│  │  │  ├── AllowNetworkTools: bool                                         ││ │
│  │  │  ├── AllowFileWrites: bool                                           ││ │
│  │  │  └── SessionPermissions: Dictionary<string, ToolPermission>?        ││ │
│  │  └─────────────────────────────────────────────────────────────────────┘│ │
│  │                                                                          │ │
│  │  FileContext                    │  TextSelection                         │ │
│  │  ┌─────────────────────────────┐│  ┌──────────────────────────────────┐ │ │
│  │  │  Path: string               ││  │  StartLine/Column: int           │ │ │
│  │  │  Content: string            ││  │  EndLine/Column: int             │ │ │
│  │  │  Language: string?          ││  │  Text: string                    │ │ │
│  │  │  IsTruncated: bool          ││  │  IsEmpty: bool                   │ │ │
│  │  │  StartLine/EndLine: int?    ││  └──────────────────────────────────┘ │ │
│  │  │  FileSizeBytes: long        ││                                       │ │
│  │  │  LastModified: DateTime?    ││  ToolPermission                       │ │
│  │  └─────────────────────────────┘│  ┌──────────────────────────────────┐ │ │
│  │                                 │  │  ToolId: string                  │ │ │
│  │                                 │  │  AutoApproved: bool              │ │ │
│  │                                 │  │  ApprovalPattern: string?        │ │ │
│  │                                 │  │  GrantedAt: DateTime             │ │ │
│  │                                 │  │  IsPersistent: bool              │ │ │
│  │                                 │  └──────────────────────────────────┘ │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Request Flow

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                          Agent Request Flow                                   │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  User Input                                                                  │
│      │                                                                       │
│      ▼                                                                       │
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │  AgentRequestBuilder.Create()                                         │   │
│  │      .WithMessage(userInput)                                          │   │
│  │      .WithConversationId(conversationId)                              │   │
│  │      .WithHistory(chatHistory)                                        │   │
│  │      .WithAttachedFiles(files)                                        │   │
│  │      .WithToolContext(toolContext)                                    │   │
│  │      .Build()                                                         │   │
│  └──────────────────────────────────┬───────────────────────────────────┘   │
│                                     │                                        │
│                                     ▼                                        │
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │  AgentRequest Validation                                              │   │
│  │  ├── Message not empty                                                │   │
│  │  ├── RequestId is unique                                              │   │
│  │  ├── History messages are valid                                       │   │
│  │  └── ToolContext workspace exists (if specified)                      │   │
│  └──────────────────────────────────┬───────────────────────────────────┘   │
│                                     │                                        │
│                                     ▼                                        │
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │  IAgentService.ProcessAsync(request)                                  │   │
│  │  ├── Resolve available tools from ToolContext                         │   │
│  │  ├── Build system prompt with tool definitions                        │   │
│  │  ├── Execute agent loop                                               │   │
│  │  └── Return AgentResponse                                             │   │
│  └──────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Specifications

### 1. AgentRequest.cs

**Location**: `src/SeniorIntern.Core/Models/AgentRequest.cs`

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Represents a request to the agent service for processing.
/// </summary>
/// <remarks>
/// <para>
/// AgentRequest encapsulates all information needed to process an agentic AI request:
/// </para>
/// <list type="bullet">
/// <item>User's message text</item>
/// <item>Conversation history for context</item>
/// <item>Attached files for code understanding</item>
/// <item>Tool availability and permission context</item>
/// <item>Inference options for LLM behavior</item>
/// </list>
/// <para>
/// The request is immutable once created. Use <see cref="AgentRequestBuilder"/>
/// for fluent construction of requests.
/// </para>
/// </remarks>
public sealed class AgentRequest
{
    #region Identity

    /// <summary>
    /// The user's message to process.
    /// </summary>
    /// <remarks>
    /// This is the primary input that drives the agent's behavior.
    /// May contain natural language instructions, code snippets, or questions.
    /// </remarks>
    public string Message { get; init; } = string.Empty;

    /// <summary>
    /// Unique identifier for this conversation.
    /// </summary>
    /// <remarks>
    /// Used for:
    /// <list type="bullet">
    /// <item>Session-based permission caching</item>
    /// <item>History management across requests</item>
    /// <item>Logging and debugging</item>
    /// </list>
    /// Multiple requests can share the same ConversationId.
    /// </remarks>
    public Guid ConversationId { get; init; } = Guid.NewGuid();

    /// <summary>
    /// Request identifier for tracking and logging.
    /// </summary>
    /// <remarks>
    /// Unique per request. Used for tracing individual request processing.
    /// </remarks>
    public Guid RequestId { get; init; } = Guid.NewGuid();

    /// <summary>
    /// When this request was created.
    /// </summary>
    public DateTime CreatedAt { get; init; } = DateTime.UtcNow;

    #endregion

    #region Context

    /// <summary>
    /// Previous conversation history.
    /// </summary>
    /// <remarks>
    /// Includes user messages, assistant responses, and tool results.
    /// Provides context for multi-turn conversations.
    /// </remarks>
    public IReadOnlyList<ChatMessage>? History { get; init; }

    /// <summary>
    /// Files attached to this request.
    /// </summary>
    /// <remarks>
    /// Provides code context for the agent. May include:
    /// <list type="bullet">
    /// <item>Currently open file</item>
    /// <item>Files referenced in the message</item>
    /// <item>Related configuration files</item>
    /// </list>
    /// </remarks>
    public IReadOnlyList<FileContext>? AttachedFiles { get; init; }

    /// <summary>
    /// Custom system prompt to prepend.
    /// </summary>
    /// <remarks>
    /// Combined with tool use prompts when tools are available.
    /// Allows customization per-request.
    /// </remarks>
    public string? SystemPrompt { get; init; }

    /// <summary>
    /// Context for determining which tools are available.
    /// </summary>
    /// <remarks>
    /// When null, uses default tool availability based on configuration.
    /// </remarks>
    public ToolAvailabilityContext? ToolContext { get; init; }

    #endregion

    #region Options

    /// <summary>
    /// Inference options for this request.
    /// </summary>
    /// <remarks>
    /// Overrides default inference settings (temperature, max tokens, etc.).
    /// When null, uses settings from the active model profile.
    /// </remarks>
    public InferenceOptions? InferenceOptions { get; init; }

    /// <summary>
    /// Whether to enable tool calling for this request.
    /// </summary>
    /// <remarks>
    /// When false, acts as a simple chat without tool access.
    /// Useful for pure conversational queries.
    /// </remarks>
    public bool EnableTools { get; init; } = true;

    /// <summary>
    /// Maximum iterations for this specific request.
    /// </summary>
    /// <remarks>
    /// Overrides configuration default when set.
    /// Useful for limiting tool calls on specific requests.
    /// </remarks>
    public int? MaxIterations { get; init; }

    /// <summary>
    /// Cancellation token for this request.
    /// </summary>
    /// <remarks>
    /// Used to cancel long-running requests.
    /// </remarks>
    public CancellationToken CancellationToken { get; init; }

    #endregion

    #region Computed Properties

    /// <summary>
    /// Whether this request has any attached files.
    /// </summary>
    public bool HasAttachedFiles => AttachedFiles?.Count > 0;

    /// <summary>
    /// Whether this request has conversation history.
    /// </summary>
    public bool HasHistory => History?.Count > 0;

    /// <summary>
    /// Total character count of attached file contents.
    /// </summary>
    public int TotalAttachedContentLength => 
        AttachedFiles?.Sum(f => f.Content.Length) ?? 0;

    /// <summary>
    /// Number of messages in history.
    /// </summary>
    public int HistoryMessageCount => History?.Count ?? 0;

    /// <summary>
    /// Gets the effective workspace path from tool context.
    /// </summary>
    public string? WorkspacePath => ToolContext?.WorkspacePath;

    #endregion

    #region Factory Methods

    /// <summary>
    /// Create a simple request with just a message.
    /// </summary>
    public static AgentRequest Simple(string message) => new() { Message = message };

    /// <summary>
    /// Create a request without tool access.
    /// </summary>
    public static AgentRequest ChatOnly(string message) => new()
    {
        Message = message,
        EnableTools = false
    };

    /// <summary>
    /// Create a request within an existing conversation.
    /// </summary>
    public static AgentRequest InConversation(
        string message,
        Guid conversationId,
        IReadOnlyList<ChatMessage>? history = null) => new()
    {
        Message = message,
        ConversationId = conversationId,
        History = history
    };

    #endregion

    /// <summary>
    /// Create a copy with modified properties.
    /// </summary>
    public AgentRequest With(
        string? message = null,
        IReadOnlyList<FileContext>? attachedFiles = null,
        ToolAvailabilityContext? toolContext = null,
        bool? enableTools = null,
        int? maxIterations = null,
        CancellationToken? cancellationToken = null) => new()
    {
        Message = message ?? Message,
        ConversationId = ConversationId,
        RequestId = Guid.NewGuid(), // New request gets new ID
        CreatedAt = DateTime.UtcNow,
        History = History,
        AttachedFiles = attachedFiles ?? AttachedFiles,
        SystemPrompt = SystemPrompt,
        ToolContext = toolContext ?? ToolContext,
        InferenceOptions = InferenceOptions,
        EnableTools = enableTools ?? EnableTools,
        MaxIterations = maxIterations ?? MaxIterations,
        CancellationToken = cancellationToken ?? CancellationToken
    };

    /// <inheritdoc />
    public override string ToString() =>
        $"AgentRequest({RequestId:N8}): {Message.Truncate(50)} " +
        $"[Files: {AttachedFiles?.Count ?? 0}, History: {HistoryMessageCount}]";
}
```

### 2. ToolAvailabilityContext.cs

**Location**: `src/SeniorIntern.Core/Models/ToolAvailabilityContext.cs`

```csharp
namespace SeniorIntern.Core.Models;

using SeniorIntern.Core.Tools;

/// <summary>
/// Context for determining which tools are available for a request.
/// </summary>
/// <remarks>
/// <para>
/// This context controls tool availability based on:
/// </para>
/// <list type="bullet">
/// <item>Workspace state (path, active file, selection)</item>
/// <item>Explicit enable/disable lists</item>
/// <item>Category filtering</item>
/// <item>Risk level thresholds</item>
/// <item>Session permissions</item>
/// </list>
/// <para>
/// Tool filtering precedence:
/// </para>
/// <list type="number">
/// <item>DisabledToolIds (highest - always blocks)</item>
/// <item>EnabledToolIds (whitelist mode if set)</item>
/// <item>EnabledCategories (category filter)</item>
/// <item>Capability flags (AllowTerminal, AllowNetwork, etc.)</item>
/// <item>RiskLevel threshold</item>
/// </list>
/// </remarks>
public sealed class ToolAvailabilityContext
{
    #region Workspace Context

    /// <summary>
    /// Current workspace path for file system operations.
    /// </summary>
    /// <remarks>
    /// Null if no workspace is open. Some tools require an active workspace
    /// (file operations, project analysis, etc.).
    /// </remarks>
    public string? WorkspacePath { get; init; }

    /// <summary>
    /// Whether a workspace is currently open.
    /// </summary>
    public bool HasWorkspace => !string.IsNullOrEmpty(WorkspacePath);

    /// <summary>
    /// Currently active file in the editor.
    /// </summary>
    /// <remarks>
    /// Used as default context for file-related tools.
    /// Null if no file is open.
    /// </remarks>
    public string? ActiveFilePath { get; init; }

    /// <summary>
    /// Whether there is an active file.
    /// </summary>
    public bool HasActiveFile => !string.IsNullOrEmpty(ActiveFilePath);

    /// <summary>
    /// Current selection in the editor.
    /// </summary>
    /// <remarks>
    /// Used by code modification tools for targeted edits.
    /// Null if no selection.
    /// </remarks>
    public TextSelection? ActiveSelection { get; init; }

    /// <summary>
    /// Whether there is an active non-empty selection.
    /// </summary>
    public bool HasSelection => ActiveSelection != null && !ActiveSelection.IsEmpty;

    #endregion

    #region Tool Filtering

    /// <summary>
    /// Explicit list of enabled tool IDs.
    /// </summary>
    /// <remarks>
    /// When set, operates in whitelist mode - only these tools are available.
    /// When null, all tools are potentially available (subject to other filters).
    /// </remarks>
    public IReadOnlySet<string>? EnabledToolIds { get; init; }

    /// <summary>
    /// Explicit list of disabled tool IDs.
    /// </summary>
    /// <remarks>
    /// Takes precedence over EnabledToolIds. Tools in this list are never available.
    /// </remarks>
    public IReadOnlySet<string>? DisabledToolIds { get; init; }

    /// <summary>
    /// Tool categories to include.
    /// </summary>
    /// <remarks>
    /// When set, only tools in these categories are available.
    /// When null, all categories are included.
    /// </remarks>
    public IReadOnlySet<ToolCategory>? EnabledCategories { get; init; }

    /// <summary>
    /// Whether whitelist mode is active.
    /// </summary>
    public bool IsWhitelistMode => EnabledToolIds != null;

    #endregion

    #region Permission Settings

    /// <summary>
    /// Maximum risk level allowed for auto-approval.
    /// </summary>
    /// <remarks>
    /// Tools at or below this level execute without user confirmation.
    /// Tools above require explicit approval.
    /// </remarks>
    public RiskLevel MaxAutoApprovalRiskLevel { get; init; } = RiskLevel.Safe;

    /// <summary>
    /// Whether terminal/shell tools are enabled.
    /// </summary>
    /// <remarks>
    /// May be restricted in secure environments.
    /// </remarks>
    public bool AllowTerminalTools { get; init; } = true;

    /// <summary>
    /// Whether network tools are enabled.
    /// </summary>
    /// <remarks>
    /// May be restricted for security or offline operation.
    /// </remarks>
    public bool AllowNetworkTools { get; init; } = true;

    /// <summary>
    /// Whether file write operations are enabled.
    /// </summary>
    /// <remarks>
    /// Can be disabled for read-only sessions.
    /// </remarks>
    public bool AllowFileWrites { get; init; } = true;

    /// <summary>
    /// Session-specific tool permissions already granted.
    /// </summary>
    /// <remarks>
    /// Tools with session permissions bypass approval prompts.
    /// </remarks>
    public IReadOnlyDictionary<string, ToolPermission>? SessionPermissions { get; init; }

    #endregion

    #region Query Methods

    /// <summary>
    /// Check if a tool is explicitly disabled.
    /// </summary>
    public bool IsToolDisabled(string toolId) =>
        DisabledToolIds?.Contains(toolId) ?? false;

    /// <summary>
    /// Check if a tool is explicitly enabled (whitelist mode).
    /// </summary>
    public bool IsToolExplicitlyEnabled(string toolId) =>
        EnabledToolIds?.Contains(toolId) ?? true;

    /// <summary>
    /// Check if a category is enabled.
    /// </summary>
    public bool IsCategoryEnabled(ToolCategory category) =>
        EnabledCategories?.Contains(category) ?? true;

    /// <summary>
    /// Check if a tool has session permission.
    /// </summary>
    public bool HasSessionPermission(string toolId) =>
        SessionPermissions?.ContainsKey(toolId) ?? false;

    /// <summary>
    /// Get session permission for a tool.
    /// </summary>
    public ToolPermission? GetSessionPermission(string toolId) =>
        SessionPermissions?.GetValueOrDefault(toolId);

    /// <summary>
    /// Check if a risk level is auto-approvable.
    /// </summary>
    public bool IsAutoApprovable(RiskLevel riskLevel) =>
        riskLevel <= MaxAutoApprovalRiskLevel;

    #endregion

    #region Factory Methods

    /// <summary>
    /// Create default context with all tools available.
    /// </summary>
    public static ToolAvailabilityContext Default => new();

    /// <summary>
    /// Create context with workspace.
    /// </summary>
    public static ToolAvailabilityContext ForWorkspace(string workspacePath) => new()
    {
        WorkspacePath = workspacePath
    };

    /// <summary>
    /// Create context for read-only operations.
    /// </summary>
    public static ToolAvailabilityContext ReadOnly => new()
    {
        AllowFileWrites = false,
        AllowTerminalTools = false
    };

    /// <summary>
    /// Create context with specific tools only.
    /// </summary>
    public static ToolAvailabilityContext WithTools(params string[] toolIds) => new()
    {
        EnabledToolIds = toolIds.ToHashSet()
    };

    /// <summary>
    /// Create context with specific categories only.
    /// </summary>
    public static ToolAvailabilityContext WithCategories(params ToolCategory[] categories) => new()
    {
        EnabledCategories = categories.ToHashSet()
    };

    #endregion

    /// <summary>
    /// Create a copy with modified properties.
    /// </summary>
    public ToolAvailabilityContext With(
        string? workspacePath = null,
        string? activeFilePath = null,
        TextSelection? activeSelection = null,
        IReadOnlySet<string>? enabledToolIds = null,
        IReadOnlySet<string>? disabledToolIds = null,
        RiskLevel? maxAutoApprovalRiskLevel = null) => new()
    {
        WorkspacePath = workspacePath ?? WorkspacePath,
        ActiveFilePath = activeFilePath ?? ActiveFilePath,
        ActiveSelection = activeSelection ?? ActiveSelection,
        EnabledToolIds = enabledToolIds ?? EnabledToolIds,
        DisabledToolIds = disabledToolIds ?? DisabledToolIds,
        EnabledCategories = EnabledCategories,
        MaxAutoApprovalRiskLevel = maxAutoApprovalRiskLevel ?? MaxAutoApprovalRiskLevel,
        AllowTerminalTools = AllowTerminalTools,
        AllowNetworkTools = AllowNetworkTools,
        AllowFileWrites = AllowFileWrites,
        SessionPermissions = SessionPermissions
    };
}
```

### 3. FileContext.cs

**Location**: `src/SeniorIntern.Core/Models/FileContext.cs`

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Represents a file attached to an agent request for context.
/// </summary>
/// <remarks>
/// <para>
/// FileContext provides file content to the agent for understanding code.
/// Large files may be truncated to fit within context limits.
/// </para>
/// <para>
/// Common usage patterns:
/// </para>
/// <list type="bullet">
/// <item>Full file: StartLine/EndLine are null</item>
/// <item>File excerpt: StartLine/EndLine specify range</item>
/// <item>Truncated file: IsTruncated is true</item>
/// </list>
/// </remarks>
public sealed class FileContext
{
    #region Properties

    /// <summary>
    /// Relative or absolute path to the file.
    /// </summary>
    public string Path { get; init; } = string.Empty;

    /// <summary>
    /// File content (may be truncated for large files).
    /// </summary>
    public string Content { get; init; } = string.Empty;

    /// <summary>
    /// Programming language identifier.
    /// </summary>
    /// <remarks>
    /// Inferred from extension. Used for syntax highlighting hints.
    /// Examples: "csharp", "python", "javascript", "markdown"
    /// </remarks>
    public string? Language { get; init; }

    /// <summary>
    /// Whether the content was truncated.
    /// </summary>
    public bool IsTruncated { get; init; }

    /// <summary>
    /// Starting line number if only a portion of the file.
    /// </summary>
    /// <remarks>
    /// 1-based line number. Null if showing from beginning.
    /// </remarks>
    public int? StartLine { get; init; }

    /// <summary>
    /// Ending line number if only a portion of the file.
    /// </summary>
    /// <remarks>
    /// 1-based line number. Null if showing to end.
    /// </remarks>
    public int? EndLine { get; init; }

    /// <summary>
    /// Total size of the file in bytes.
    /// </summary>
    public long FileSizeBytes { get; init; }

    /// <summary>
    /// Last modification time.
    /// </summary>
    public DateTime? LastModified { get; init; }

    #endregion

    #region Computed Properties

    /// <summary>
    /// File name without directory path.
    /// </summary>
    public string FileName => System.IO.Path.GetFileName(Path);

    /// <summary>
    /// File extension without dot.
    /// </summary>
    public string Extension => System.IO.Path.GetExtension(Path).TrimStart('.');

    /// <summary>
    /// Whether this is a partial file excerpt.
    /// </summary>
    public bool IsPartial => StartLine.HasValue || EndLine.HasValue;

    /// <summary>
    /// Number of lines in the content.
    /// </summary>
    public int LineCount => Content.Split('\n').Length;

    /// <summary>
    /// Content length in characters.
    /// </summary>
    public int ContentLength => Content.Length;

    /// <summary>
    /// Approximate token count (rough estimate: 4 chars per token).
    /// </summary>
    public int EstimatedTokens => Content.Length / 4;

    #endregion

    #region Factory Methods

    /// <summary>
    /// Create from file path (reads content).
    /// </summary>
    public static FileContext FromFile(string path, int? maxLines = null)
    {
        var fileInfo = new System.IO.FileInfo(path);
        var content = System.IO.File.ReadAllText(path);
        var language = InferLanguage(path);

        if (maxLines.HasValue)
        {
            var lines = content.Split('\n');
            if (lines.Length > maxLines.Value)
            {
                content = string.Join('\n', lines.Take(maxLines.Value));
                return new FileContext
                {
                    Path = path,
                    Content = content,
                    Language = language,
                    IsTruncated = true,
                    EndLine = maxLines.Value,
                    FileSizeBytes = fileInfo.Length,
                    LastModified = fileInfo.LastWriteTimeUtc
                };
            }
        }

        return new FileContext
        {
            Path = path,
            Content = content,
            Language = language,
            FileSizeBytes = fileInfo.Length,
            LastModified = fileInfo.LastWriteTimeUtc
        };
    }

    /// <summary>
    /// Create with explicit content.
    /// </summary>
    public static FileContext FromContent(string path, string content, string? language = null) =>
        new()
        {
            Path = path,
            Content = content,
            Language = language ?? InferLanguage(path),
            FileSizeBytes = content.Length
        };

    /// <summary>
    /// Create for a file excerpt (line range).
    /// </summary>
    public static FileContext FromExcerpt(
        string path,
        string content,
        int startLine,
        int endLine,
        long totalFileSize) =>
        new()
        {
            Path = path,
            Content = content,
            Language = InferLanguage(path),
            StartLine = startLine,
            EndLine = endLine,
            FileSizeBytes = totalFileSize
        };

    #endregion

    #region Helper Methods

    /// <summary>
    /// Infer language from file extension.
    /// </summary>
    private static string? InferLanguage(string path)
    {
        var ext = System.IO.Path.GetExtension(path).ToLowerInvariant();
        return ext switch
        {
            ".cs" => "csharp",
            ".py" => "python",
            ".js" => "javascript",
            ".ts" => "typescript",
            ".jsx" => "jsx",
            ".tsx" => "tsx",
            ".json" => "json",
            ".xml" => "xml",
            ".html" => "html",
            ".css" => "css",
            ".scss" => "scss",
            ".md" => "markdown",
            ".yaml" or ".yml" => "yaml",
            ".sh" or ".bash" => "bash",
            ".ps1" => "powershell",
            ".sql" => "sql",
            ".java" => "java",
            ".go" => "go",
            ".rs" => "rust",
            ".cpp" or ".cc" or ".cxx" => "cpp",
            ".c" => "c",
            ".h" or ".hpp" => "cpp",
            ".rb" => "ruby",
            ".php" => "php",
            ".swift" => "swift",
            ".kt" or ".kts" => "kotlin",
            _ => null
        };
    }

    /// <summary>
    /// Format for inclusion in LLM prompt.
    /// </summary>
    public string ToPromptFormat()
    {
        var header = IsPartial
            ? $"File: {Path} (lines {StartLine}-{EndLine})"
            : $"File: {Path}";

        if (IsTruncated)
            header += " [TRUNCATED]";

        var langHint = Language ?? "";

        return $"""
            {header}
            ```{langHint}
            {Content}
            ```
            """;
    }

    #endregion

    /// <inheritdoc />
    public override string ToString() =>
        $"FileContext({FileName}, {LineCount} lines, {Language ?? "unknown"})";
}
```

### 4. TextSelection.cs

**Location**: `src/SeniorIntern.Core/Models/TextSelection.cs`

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Represents a text selection in the editor.
/// </summary>
/// <remarks>
/// <para>
/// TextSelection captures the user's current selection for context-aware operations.
/// All positions are 1-based (first line is 1, first column is 1).
/// </para>
/// <para>
/// Selection types:
/// </para>
/// <list type="bullet">
/// <item>Empty (cursor position): StartLine==EndLine AND StartColumn==EndColumn</item>
/// <item>Single line: StartLine==EndLine, different columns</item>
/// <item>Multi-line: StartLine &lt; EndLine</item>
/// </list>
/// </remarks>
public sealed class TextSelection
{
    /// <summary>
    /// Starting line (1-based).
    /// </summary>
    public int StartLine { get; init; }

    /// <summary>
    /// Starting column (1-based).
    /// </summary>
    public int StartColumn { get; init; }

    /// <summary>
    /// Ending line (1-based).
    /// </summary>
    public int EndLine { get; init; }

    /// <summary>
    /// Ending column (1-based).
    /// </summary>
    public int EndColumn { get; init; }

    /// <summary>
    /// The selected text content.
    /// </summary>
    public string Text { get; init; } = string.Empty;

    #region Computed Properties

    /// <summary>
    /// Whether this is an empty selection (cursor position only).
    /// </summary>
    public bool IsEmpty => StartLine == EndLine && StartColumn == EndColumn;

    /// <summary>
    /// Whether this is a single-line selection.
    /// </summary>
    public bool IsSingleLine => StartLine == EndLine;

    /// <summary>
    /// Whether this spans multiple lines.
    /// </summary>
    public bool IsMultiLine => StartLine < EndLine;

    /// <summary>
    /// Number of lines in the selection.
    /// </summary>
    public int LineCount => EndLine - StartLine + 1;

    /// <summary>
    /// Character count of selected text.
    /// </summary>
    public int CharacterCount => Text.Length;

    #endregion

    #region Factory Methods

    /// <summary>
    /// Create a cursor position (empty selection).
    /// </summary>
    public static TextSelection Cursor(int line, int column) => new()
    {
        StartLine = line,
        StartColumn = column,
        EndLine = line,
        EndColumn = column,
        Text = string.Empty
    };

    /// <summary>
    /// Create a single-line selection.
    /// </summary>
    public static TextSelection SingleLine(int line, int startColumn, int endColumn, string text) =>
        new()
        {
            StartLine = line,
            StartColumn = startColumn,
            EndLine = line,
            EndColumn = endColumn,
            Text = text
        };

    /// <summary>
    /// Create a multi-line selection.
    /// </summary>
    public static TextSelection MultiLine(
        int startLine, int startColumn,
        int endLine, int endColumn,
        string text) =>
        new()
        {
            StartLine = startLine,
            StartColumn = startColumn,
            EndLine = endLine,
            EndColumn = endColumn,
            Text = text
        };

    #endregion

    /// <summary>
    /// Get a display string for the selection range.
    /// </summary>
    public string ToRangeString() =>
        IsEmpty ? $"L{StartLine}:C{StartColumn}"
        : IsSingleLine ? $"L{StartLine}:C{StartColumn}-C{EndColumn}"
        : $"L{StartLine}:C{StartColumn} - L{EndLine}:C{EndColumn}";

    /// <inheritdoc />
    public override string ToString() =>
        IsEmpty ? $"Cursor({ToRangeString()})"
        : $"Selection({ToRangeString()}, {CharacterCount} chars)";
}
```

### 5. ToolPermission.cs

**Location**: `src/SeniorIntern.Core/Models/ToolPermission.cs`

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Represents a permission grant for a tool in a session.
/// </summary>
/// <remarks>
/// <para>
/// ToolPermission tracks user approval for tool execution:
/// </para>
/// <list type="bullet">
/// <item>Auto-approval allows executing without prompts</item>
/// <item>Patterns restrict auto-approval to specific parameters</item>
/// <item>Session permissions last for the conversation</item>
/// <item>Persistent permissions are saved across sessions</item>
/// </list>
/// </remarks>
public sealed class ToolPermission
{
    /// <summary>
    /// Tool ID this permission applies to.
    /// </summary>
    public string ToolId { get; init; } = string.Empty;

    /// <summary>
    /// Whether the tool is auto-approved.
    /// </summary>
    /// <remarks>
    /// When true, the tool executes without user confirmation.
    /// May be limited by ApprovalPattern.
    /// </remarks>
    public bool AutoApproved { get; init; }

    /// <summary>
    /// Pattern for conditional auto-approval.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Provides fine-grained control over auto-approval:
    /// </para>
    /// <list type="bullet">
    /// <item>File tools: glob pattern for paths (e.g., "src/**/*.cs")</item>
    /// <item>Terminal: command prefix pattern</item>
    /// <item>Null: auto-approve all invocations</item>
    /// </list>
    /// </remarks>
    public string? ApprovalPattern { get; init; }

    /// <summary>
    /// When this permission was granted.
    /// </summary>
    public DateTime GrantedAt { get; init; } = DateTime.UtcNow;

    /// <summary>
    /// When this permission expires.
    /// </summary>
    /// <remarks>
    /// Null for session-only permissions (expire on app close).
    /// </remarks>
    public DateTime? ExpiresAt { get; init; }

    /// <summary>
    /// Whether this permission persists beyond the session.
    /// </summary>
    public bool IsPersistent { get; init; }

    /// <summary>
    /// Number of times this permission has been used.
    /// </summary>
    public int UseCount { get; init; }

    /// <summary>
    /// Who granted this permission.
    /// </summary>
    /// <remarks>
    /// "user" for explicit approval, "system" for auto-granted safe tools.
    /// </remarks>
    public string GrantedBy { get; init; } = "user";

    #region Computed Properties

    /// <summary>
    /// Whether this permission has expired.
    /// </summary>
    public bool IsExpired => ExpiresAt.HasValue && DateTime.UtcNow > ExpiresAt.Value;

    /// <summary>
    /// Whether this permission is currently valid.
    /// </summary>
    public bool IsValid => AutoApproved && !IsExpired;

    /// <summary>
    /// Whether this permission has a pattern restriction.
    /// </summary>
    public bool HasPattern => !string.IsNullOrEmpty(ApprovalPattern);

    #endregion

    #region Factory Methods

    /// <summary>
    /// Create a session-only auto-approval.
    /// </summary>
    public static ToolPermission SessionAutoApproval(string toolId) => new()
    {
        ToolId = toolId,
        AutoApproved = true,
        IsPersistent = false
    };

    /// <summary>
    /// Create a persistent auto-approval.
    /// </summary>
    public static ToolPermission PersistentAutoApproval(string toolId) => new()
    {
        ToolId = toolId,
        AutoApproved = true,
        IsPersistent = true
    };

    /// <summary>
    /// Create a pattern-based auto-approval.
    /// </summary>
    public static ToolPermission PatternAutoApproval(string toolId, string pattern) => new()
    {
        ToolId = toolId,
        AutoApproved = true,
        ApprovalPattern = pattern,
        IsPersistent = false
    };

    /// <summary>
    /// Create a time-limited auto-approval.
    /// </summary>
    public static ToolPermission TimeLimitedAutoApproval(string toolId, TimeSpan duration) => new()
    {
        ToolId = toolId,
        AutoApproved = true,
        ExpiresAt = DateTime.UtcNow.Add(duration),
        IsPersistent = false
    };

    /// <summary>
    /// Create a system-granted permission (for safe tools).
    /// </summary>
    public static ToolPermission SystemGranted(string toolId) => new()
    {
        ToolId = toolId,
        AutoApproved = true,
        GrantedBy = "system",
        IsPersistent = true
    };

    #endregion

    /// <summary>
    /// Check if a parameter value matches the approval pattern.
    /// </summary>
    public bool MatchesPattern(string value)
    {
        if (!HasPattern) return true;
        // Simple glob matching - could be extended
        return GlobMatch(ApprovalPattern!, value);
    }

    private static bool GlobMatch(string pattern, string value)
    {
        // Simple implementation - ** matches any path, * matches segment
        var regex = "^" + System.Text.RegularExpressions.Regex.Escape(pattern)
            .Replace("\\*\\*", ".*")
            .Replace("\\*", "[^/]*") + "$";
        return System.Text.RegularExpressions.Regex.IsMatch(
            value, regex, System.Text.RegularExpressions.RegexOptions.IgnoreCase);
    }

    /// <inheritdoc />
    public override string ToString() =>
        $"ToolPermission({ToolId}, Auto={AutoApproved}, Pattern={ApprovalPattern ?? "none"})";
}
```

### 6. AgentRequestBuilder.cs

**Location**: `src/SeniorIntern.Core/Models/AgentRequestBuilder.cs`

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Fluent builder for constructing AgentRequest instances.
/// </summary>
public sealed class AgentRequestBuilder
{
    private string _message = string.Empty;
    private Guid _conversationId = Guid.NewGuid();
    private List<ChatMessage>? _history;
    private List<FileContext>? _files;
    private string? _systemPrompt;
    private ToolAvailabilityContext? _toolContext;
    private InferenceOptions? _inferenceOptions;
    private bool _enableTools = true;
    private int? _maxIterations;
    private CancellationToken _cancellationToken;

    private AgentRequestBuilder() { }

    /// <summary>
    /// Create a new builder.
    /// </summary>
    public static AgentRequestBuilder Create() => new();

    /// <summary>
    /// Set the user message.
    /// </summary>
    public AgentRequestBuilder WithMessage(string message)
    {
        _message = message;
        return this;
    }

    /// <summary>
    /// Set the conversation ID.
    /// </summary>
    public AgentRequestBuilder WithConversationId(Guid conversationId)
    {
        _conversationId = conversationId;
        return this;
    }

    /// <summary>
    /// Add conversation history.
    /// </summary>
    public AgentRequestBuilder WithHistory(IEnumerable<ChatMessage> history)
    {
        _history = history.ToList();
        return this;
    }

    /// <summary>
    /// Add attached files.
    /// </summary>
    public AgentRequestBuilder WithAttachedFiles(IEnumerable<FileContext> files)
    {
        _files = files.ToList();
        return this;
    }

    /// <summary>
    /// Add a single attached file.
    /// </summary>
    public AgentRequestBuilder WithFile(FileContext file)
    {
        _files ??= new List<FileContext>();
        _files.Add(file);
        return this;
    }

    /// <summary>
    /// Set the system prompt.
    /// </summary>
    public AgentRequestBuilder WithSystemPrompt(string systemPrompt)
    {
        _systemPrompt = systemPrompt;
        return this;
    }

    /// <summary>
    /// Set the tool availability context.
    /// </summary>
    public AgentRequestBuilder WithToolContext(ToolAvailabilityContext toolContext)
    {
        _toolContext = toolContext;
        return this;
    }

    /// <summary>
    /// Configure tool context with workspace.
    /// </summary>
    public AgentRequestBuilder WithWorkspace(string workspacePath)
    {
        _toolContext = ToolAvailabilityContext.ForWorkspace(workspacePath);
        return this;
    }

    /// <summary>
    /// Set inference options.
    /// </summary>
    public AgentRequestBuilder WithInferenceOptions(InferenceOptions options)
    {
        _inferenceOptions = options;
        return this;
    }

    /// <summary>
    /// Enable or disable tools.
    /// </summary>
    public AgentRequestBuilder WithTools(bool enabled)
    {
        _enableTools = enabled;
        return this;
    }

    /// <summary>
    /// Disable tools (chat-only mode).
    /// </summary>
    public AgentRequestBuilder WithoutTools()
    {
        _enableTools = false;
        return this;
    }

    /// <summary>
    /// Set maximum iterations.
    /// </summary>
    public AgentRequestBuilder WithMaxIterations(int maxIterations)
    {
        _maxIterations = maxIterations;
        return this;
    }

    /// <summary>
    /// Set cancellation token.
    /// </summary>
    public AgentRequestBuilder WithCancellation(CancellationToken token)
    {
        _cancellationToken = token;
        return this;
    }

    /// <summary>
    /// Build the AgentRequest.
    /// </summary>
    public AgentRequest Build() => new()
    {
        Message = _message,
        ConversationId = _conversationId,
        History = _history,
        AttachedFiles = _files,
        SystemPrompt = _systemPrompt,
        ToolContext = _toolContext,
        InferenceOptions = _inferenceOptions,
        EnableTools = _enableTools,
        MaxIterations = _maxIterations,
        CancellationToken = _cancellationToken
    };

    /// <summary>
    /// Implicit conversion to AgentRequest.
    /// </summary>
    public static implicit operator AgentRequest(AgentRequestBuilder builder) => builder.Build();
}
```

---

## File Summary

| File | Location | Purpose | Lines |
|------|----------|---------|-------|
| `AgentRequest.cs` | `Core/Models/` | Main request model | ~170 |
| `ToolAvailabilityContext.cs` | `Core/Models/` | Tool availability | ~180 |
| `FileContext.cs` | `Core/Models/` | File attachments | ~180 |
| `TextSelection.cs` | `Core/Models/` | Editor selection | ~100 |
| `ToolPermission.cs` | `Core/Models/` | Permission grants | ~150 |
| `AgentRequestBuilder.cs` | `Core/Models/` | Fluent builder | ~120 |

---

## Unit Test Plan

| Test | Description |
|------|-------------|
| `AgentRequest_Simple_HasDefaultValues` | Factory creates valid request |
| `AgentRequest_With_CreatesNewInstance` | Immutable modification |
| `ToolAvailabilityContext_IsToolDisabled_ReturnsTrueWhenInList` | Disable check |
| `ToolAvailabilityContext_WhitelistMode_OnlyAllowsEnabled` | Whitelist behavior |
| `FileContext_FromFile_ReadsContent` | File loading |
| `FileContext_InferLanguage_IdentifiesCSharp` | Language detection |
| `TextSelection_IsEmpty_TrueForCursor` | Cursor detection |
| `TextSelection_LineCount_CalculatesCorrectly` | Line counting |
| `ToolPermission_IsExpired_AfterExpiryTime` | Expiry logic |
| `ToolPermission_MatchesPattern_GlobWorks` | Pattern matching |
| `AgentRequestBuilder_Build_CreatesValidRequest` | Builder works |

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | AgentRequest captures all needed context |
| AC-2 | ToolAvailabilityContext enables flexible tool filtering |
| AC-3 | FileContext supports partial file content |
| AC-4 | TextSelection correctly identifies empty/multi-line |
| AC-5 | ToolPermission supports pattern-based approval |
| AC-6 | All models are immutable with init-only setters |
| AC-7 | Factory methods and builders work correctly |

---

## Changelog Entry

```markdown
## v0.6.2c - Agent Request Models

### Added
- `AgentRequest` for encapsulating agent requests with full context
- `ToolAvailabilityContext` for controlling tool availability
- `FileContext` for file attachments with language detection
- `TextSelection` for editor selection information
- `ToolPermission` for session-based permission management
- `AgentRequestBuilder` for fluent request construction
- Factory methods for common request patterns
```

---

## Timeline Estimate

| Version | Estimated Effort |
|---------|------------------|
| v0.6.2c | 0.5 day |
