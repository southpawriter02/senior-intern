# Design Specification: AIntern v0.6.2g "Function Call Parser"

## Overview

**Version**: v0.6.2g
**Parent**: v0.6.2 Semantic Kernel Integration
**Focus**: Robust parsing of tool calls from LLM output with batch and streaming support

### Purpose

This sub-version implements tool call parsing from LLM responses:
1. Create `FunctionCallParser` for batch parsing of complete responses
2. Create `StreamingFunctionCallParser` for token-by-token streaming detection
3. Create `ParseResult` for parser output representation
4. Create `ParserConfiguration` for customizable parsing behavior
5. Support multiple tool call formats (fenced blocks, inline JSON)
6. Handle malformed JSON gracefully with error recovery
7. Extract non-tool-call text separately from tool calls

### Dependencies

**From v0.6.1b (Tool Registry)**:
- `IToolRegistry` for tool lookup and metadata

**From v0.6.2f (Tool Call Request Models)**:
- `ToolCallRequest` for parsed requests
- `ToolCallRequestBuilder` for construction

**Future Consumers**:
- v0.6.2i: AgentService (uses parsers during response processing)

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                    v0.6.2g Function Call Parser Architecture                  │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  src/SeniorIntern.Services/AI/                                               │
│  ├─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  FunctionCallParser                                                      │ │
│  │  ┌─────────────────────────────────────────────────────────────────────┐│ │
│  │  │  Dependencies                                                        ││ │
│  │  │  ├── IToolRegistry _toolRegistry                                     ││ │
│  │  │  ├── ILogger<FunctionCallParser> _logger                             ││ │
│  │  │  └── ParserConfiguration _config                                     ││ │
│  │  │                                                                      ││ │
│  │  │  Regex Patterns (Source Generated)                                   ││ │
│  │  │  ├── ToolCallBlockRegex()     : ```tool_call\n{...}\n```            ││ │
│  │  │  ├── InlineToolCallRegex()    : {"tool": "...", "parameters": ...}  ││ │
│  │  │  ├── ToolCallOpenRegex()      : ```tool_call                        ││ │
│  │  │  └── JsonBlockRegex()         : ```json\n{...}\n```                 ││ │
│  │  │                                                                      ││ │
│  │  │  Methods                                                              ││ │
│  │  │  ├── Parse(content) → IReadOnlyList<ToolCallRequest>                ││ │
│  │  │  ├── ParseSingle(content) → ToolCallRequest?                        ││ │
│  │  │  ├── ExtractText(content) → string                                  ││ │
│  │  │  ├── HasToolCalls(content) → bool                                   ││ │
│  │  │  └── SplitContent(content) → ParsedContent                          ││ │
│  │  └─────────────────────────────────────────────────────────────────────┘│ │
│  │                                                                          │ │
│  │  StreamingFunctionCallParser                                             │ │
│  │  ┌─────────────────────────────────────────────────────────────────────┐│ │
│  │  │  State                                                               ││ │
│  │  │  ├── _buffer: StringBuilder                                          ││ │
│  │  │  ├── _state: ParserState                                             ││ │
│  │  │  └── _braceDepth: int                                                ││ │
│  │  │                                                                      ││ │
│  │  │  Methods                                                              ││ │
│  │  │  ├── ProcessToken(token) → ParseResult                              ││ │
│  │  │  ├── Reset()                                                         ││ │
│  │  │  ├── Flush() → string                                                ││ │
│  │  │  └── GetBufferedContent() → string                                   ││ │
│  │  │                                                                      ││ │
│  │  │  ParserState                                                          ││ │
│  │  │  ├── Text                      (normal text output)                 ││ │
│  │  │  ├── InToolCallOpening         (```tool_call detected)              ││ │
│  │  │  ├── InToolCallJson            (parsing JSON body)                  ││ │
│  │  │  └── InToolCallClosing         (waiting for ```)                    ││ │
│  │  └─────────────────────────────────────────────────────────────────────┘│ │
│  │                                                                          │ │
│  │  ParseResult                      ParsedContent                          │ │
│  │  ┌────────────────────────────┐   ┌─────────────────────────────────┐   │ │
│  │  │  IsText: bool              │   │  TextBefore: string             │   │ │
│  │  │  Text: string?             │   │  TextAfter: string              │   │ │
│  │  │  IsToolCall: bool          │   │  ToolCalls: List<ToolCallRequest>│  │ │
│  │  │  ToolCall: ToolCallRequest?│   │  RawBlocks: List<string>        │   │ │
│  │  │  IsBuffering: bool         │   └─────────────────────────────────┘   │ │
│  │  │  Error: string?            │                                          │ │
│  │  └────────────────────────────┘                                          │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Parsing Flow

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                         Batch Parsing Flow                                    │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  LLM Response:                                                               │
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │  "I'll read that file for you.                                        │   │
│  │                                                                       │   │
│  │  ```tool_call                                                         │   │
│  │  {                                                                    │   │
│  │    "tool": "file-read",                                               │   │
│  │    "parameters": {                                                    │   │
│  │      "path": "/src/Program.cs"                                        │   │
│  │    }                                                                  │   │
│  │  }                                                                    │   │
│  │  ```                                                                  │   │
│  │                                                                       │   │
│  │  Let me check the contents."                                          │   │
│  └──────────────────────────────────────────────────────────────────────┘   │
│                                  │                                           │
│                                  ▼                                           │
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │  FunctionCallParser.Parse(content)                                    │   │
│  │  1. ToolCallBlockRegex().Matches(content)                             │   │
│  │  2. For each match: ParseToolCallJson(match.Groups["json"])           │   │
│  │  3. If no matches: try InlineToolCallRegex()                          │   │
│  └────────────────────────────────┬─────────────────────────────────────┘   │
│                                   │                                          │
│                                   ▼                                          │
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │  ParseToolCallJson(jsonString)                                        │   │
│  │  1. JsonDocument.Parse(json)                                          │   │
│  │  2. Extract "tool" property                                           │   │
│  │  3. Extract "parameters" property                                     │   │
│  │  4. Lookup tool in IToolRegistry                                      │   │
│  │  5. Create ToolCallRequest with risk level and summary                │   │
│  └────────────────────────────────┬─────────────────────────────────────┘   │
│                                   │                                          │
│                                   ▼                                          │
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │  Result: IReadOnlyList<ToolCallRequest>                               │   │
│  │  [                                                                    │   │
│  │    ToolCallRequest {                                                  │   │
│  │      ToolId: "file-read",                                             │   │
│  │      ToolName: "Read File",                                           │   │
│  │      Parameters: { "path": "/src/Program.cs" },                       │   │
│  │      RiskLevel: Safe,                                                 │   │
│  │      ExecutionSummary: "Read file /src/Program.cs"                    │   │
│  │    }                                                                  │   │
│  │  ]                                                                    │   │
│  └──────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Streaming Parser State Machine

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                    Streaming Parser State Machine                             │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│                          ┌─────────────────┐                                 │
│                          │      Text       │◄──────────────────────────┐     │
│                          │  (emit tokens)  │                           │     │
│                          └────────┬────────┘                           │     │
│                                   │                                    │     │
│                                   │ detect "```tool_call"              │     │
│                                   ▼                                    │     │
│                          ┌─────────────────┐                           │     │
│                          │ InToolCallOpening                           │     │
│                          │  (buffering)    │                           │     │
│                          └────────┬────────┘                           │     │
│                                   │                                    │     │
│                                   │ detect "{"                         │     │
│                                   ▼                                    │     │
│                          ┌─────────────────┐                           │     │
│                          │ InToolCallJson  │                           │     │
│                          │  (track braces) │                           │     │
│                          └────────┬────────┘                           │     │
│                                   │                                    │     │
│                                   │ braceDepth == 0                    │     │
│                                   ▼                                    │     │
│                          ┌─────────────────┐                           │     │
│                          │InToolCallClosing│                           │     │
│                          │ (wait for ```)  │                           │     │
│                          └────────┬────────┘                           │     │
│                                   │                                    │     │
│                                   │ detect closing "```"               │     │
│                                   ▼                                    │     │
│                          ┌─────────────────┐                           │     │
│                          │  Emit ToolCall  │───────────────────────────┘     │
│                          │  Reset to Text  │                                 │
│                          └─────────────────┘                                 │
│                                                                              │
│  Buffer Management:                                                          │
│  • Text state: emit immediately, clear buffer                                │
│  • Opening/JSON/Closing: buffer tokens, don't emit                          │
│  • On complete tool call: parse buffer, emit ToolCall, clear buffer         │
│  • On malformed: emit buffered as text, reset to Text state                  │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Specifications

### 1. FunctionCallParser.cs

**Location**: `src/SeniorIntern.Services/AI/FunctionCallParser.cs`

```csharp
namespace SeniorIntern.Services.AI;

using System.Text.Json;
using System.Text.RegularExpressions;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Core.Tools;

/// <summary>
/// Parses tool call requests from LLM output.
/// </summary>
/// <remarks>
/// <para>
/// The parser supports multiple tool call formats:
/// </para>
/// <list type="bullet">
/// <item><b>Fenced blocks</b>: ```tool_call\n{json}\n```</item>
/// <item><b>JSON blocks</b>: ```json\n{json with "tool" property}\n```</item>
/// <item><b>Inline JSON</b>: {"tool": "...", "parameters": {...}}</item>
/// </list>
/// <para>
/// The parser is tolerant of formatting variations and handles malformed
/// JSON gracefully by logging warnings and skipping invalid blocks.
/// </para>
/// </remarks>
public sealed partial class FunctionCallParser
{
    private readonly IToolRegistry _toolRegistry;
    private readonly ILogger<FunctionCallParser> _logger;
    private readonly ParserConfiguration _config;

    #region Regex Patterns

    /// <summary>
    /// Primary pattern: ```tool_call\n{json}\n```
    /// </summary>
    [GeneratedRegex(
        @"```tool_call\s*\n(?<json>\{[\s\S]*?\})\s*\n?```",
        RegexOptions.Multiline | RegexOptions.Compiled)]
    private static partial Regex ToolCallBlockRegex();

    /// <summary>
    /// Alternative pattern: ```json with tool property
    /// </summary>
    [GeneratedRegex(
        @"```json\s*\n(?<json>\{[\s\S]*?""tool""[\s\S]*?\})\s*\n?```",
        RegexOptions.Multiline | RegexOptions.Compiled)]
    private static partial Regex JsonBlockWithToolRegex();

    /// <summary>
    /// Inline pattern: JSON object with "tool" and "parameters"
    /// </summary>
    [GeneratedRegex(
        @"\{[^{}]*""tool""\s*:\s*""(?<tool>[^""]+)""[^{}]*""parameters""\s*:\s*(?<params>\{[^{}]*\})[^{}]*\}",
        RegexOptions.Compiled)]
    private static partial Regex InlineToolCallRegex();

    /// <summary>
    /// Opening pattern for streaming detection.
    /// </summary>
    [GeneratedRegex(@"```tool_call\s*\n?", RegexOptions.Compiled)]
    private static partial Regex ToolCallOpenRegex();

    /// <summary>
    /// Pattern to find any fenced code block.
    /// </summary>
    [GeneratedRegex(@"```(?<lang>\w+)?\s*\n(?<content>[\s\S]*?)\n?```", RegexOptions.Compiled)]
    private static partial Regex FencedBlockRegex();

    #endregion

    /// <summary>
    /// Create a new function call parser.
    /// </summary>
    public FunctionCallParser(
        IToolRegistry toolRegistry,
        ILogger<FunctionCallParser> logger,
        ParserConfiguration? config = null)
    {
        _toolRegistry = toolRegistry;
        _logger = logger;
        _config = config ?? ParserConfiguration.Default;
    }

    #region Public Methods

    /// <summary>
    /// Parse all tool calls from a complete response.
    /// </summary>
    /// <param name="content">The complete LLM response.</param>
    /// <returns>List of parsed tool call requests.</returns>
    public IReadOnlyList<ToolCallRequest> Parse(string content)
    {
        if (string.IsNullOrWhiteSpace(content))
        {
            return Array.Empty<ToolCallRequest>();
        }

        var requests = new List<ToolCallRequest>();

        // Try primary pattern first: ```tool_call
        var matches = ToolCallBlockRegex().Matches(content);
        foreach (Match match in matches)
        {
            var request = TryParseToolCallJson(match.Groups["json"].Value, match.Value);
            if (request != null)
            {
                requests.Add(request);
            }
        }

        // Try JSON blocks with tool property if enabled
        if (requests.Count == 0 && _config.AllowJsonBlocks)
        {
            matches = JsonBlockWithToolRegex().Matches(content);
            foreach (Match match in matches)
            {
                var request = TryParseToolCallJson(match.Groups["json"].Value, match.Value);
                if (request != null)
                {
                    requests.Add(request);
                }
            }
        }

        // Try inline pattern as fallback if enabled
        if (requests.Count == 0 && _config.AllowInlineJson)
        {
            var inlineMatches = InlineToolCallRegex().Matches(content);
            foreach (Match match in inlineMatches)
            {
                var request = TryParseInlineToolCall(
                    match.Groups["tool"].Value,
                    match.Groups["params"].Value,
                    match.Value);
                if (request != null)
                {
                    requests.Add(request);
                }
            }
        }

        _logger.LogDebug("Parsed {Count} tool calls from response", requests.Count);
        return requests;
    }

    /// <summary>
    /// Parse a single tool call (for responses expected to have exactly one).
    /// </summary>
    /// <param name="content">The complete LLM response.</param>
    /// <returns>The first parsed tool call, or null if none found.</returns>
    public ToolCallRequest? ParseSingle(string content)
    {
        var requests = Parse(content);
        return requests.Count > 0 ? requests[0] : null;
    }

    /// <summary>
    /// Check if content contains any tool calls.
    /// </summary>
    /// <param name="content">The content to check.</param>
    /// <returns>True if at least one tool call pattern is found.</returns>
    public bool HasToolCalls(string content)
    {
        if (string.IsNullOrWhiteSpace(content))
        {
            return false;
        }

        return ToolCallBlockRegex().IsMatch(content) ||
               (_config.AllowJsonBlocks && JsonBlockWithToolRegex().IsMatch(content)) ||
               (_config.AllowInlineJson && InlineToolCallRegex().IsMatch(content));
    }

    /// <summary>
    /// Extract non-tool-call text from a response.
    /// </summary>
    /// <param name="content">The complete LLM response.</param>
    /// <returns>The response with tool call blocks removed.</returns>
    public string ExtractText(string content)
    {
        if (string.IsNullOrWhiteSpace(content))
        {
            return string.Empty;
        }

        // Remove tool call blocks
        var text = ToolCallBlockRegex().Replace(content, "");

        // Remove JSON blocks with tool property if they were parsed
        if (_config.AllowJsonBlocks)
        {
            text = JsonBlockWithToolRegex().Replace(text, "");
        }

        // Clean up extra whitespace
        text = Regex.Replace(text, @"\n{3,}", "\n\n");

        return text.Trim();
    }

    /// <summary>
    /// Split content into text and tool calls.
    /// </summary>
    /// <param name="content">The complete LLM response.</param>
    /// <returns>Parsed content with text and tool calls separated.</returns>
    public ParsedContent SplitContent(string content)
    {
        var toolCalls = Parse(content);
        var text = ExtractText(content);

        // Find text before first tool call
        var firstBlockMatch = ToolCallBlockRegex().Match(content);
        var textBefore = firstBlockMatch.Success
            ? content[..firstBlockMatch.Index].Trim()
            : text;

        // Find text after last tool call
        var lastBlockMatch = ToolCallBlockRegex().Matches(content).LastOrDefault();
        var textAfter = lastBlockMatch != null
            ? content[(lastBlockMatch.Index + lastBlockMatch.Length)..].Trim()
            : string.Empty;

        return new ParsedContent
        {
            TextBefore = textBefore,
            TextAfter = textAfter,
            ToolCalls = toolCalls.ToList(),
            FullText = text
        };
    }

    #endregion

    #region Private Parsing Methods

    private ToolCallRequest? TryParseToolCallJson(string json, string rawBlock)
    {
        try
        {
            return ParseToolCallJson(json, rawBlock);
        }
        catch (JsonException ex)
        {
            _logger.LogWarning(ex, "Failed to parse tool call JSON: {Json}", json.Truncate(100));
            return null;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unexpected error parsing tool call");
            return null;
        }
    }

    private ToolCallRequest ParseToolCallJson(string json, string rawBlock)
    {
        using var doc = JsonDocument.Parse(json, new JsonDocumentOptions
        {
            AllowTrailingCommas = true,
            CommentHandling = JsonCommentHandling.Skip
        });

        var root = doc.RootElement;

        // Extract tool ID (required)
        if (!root.TryGetProperty("tool", out var toolProp))
        {
            throw new JsonException("Missing required 'tool' property");
        }
        var toolId = toolProp.GetString()
            ?? throw new JsonException("'tool' property is null");

        // Extract parameters (optional, default to empty object)
        var parameters = root.TryGetProperty("parameters", out var paramsProp)
            ? paramsProp.Clone()
            : JsonDocument.Parse("{}").RootElement;

        // Look up tool in registry
        var tool = _toolRegistry.GetTool(toolId);

        // Compute risk level and summary
        var riskLevel = tool?.GetEffectiveRiskLevel(parameters)
            ?? _config.UnknownToolRiskLevel;
        var summary = tool?.GetExecutionSummary(parameters)
            ?? $"Execute unknown tool: {toolId}";

        // Build warnings for unknown tools
        var warnings = new List<string>();
        if (tool == null)
        {
            warnings.Add($"Tool '{toolId}' is not registered");
        }

        return new ToolCallRequest
        {
            ToolId = toolId,
            ToolName = tool?.Name ?? toolId,
            Parameters = parameters,
            RiskLevel = riskLevel,
            ExecutionSummary = summary,
            RawJson = rawBlock,
            Warnings = warnings.Count > 0 ? warnings : null,
            RequiresApproval = riskLevel > _config.AutoApprovalThreshold
        };
    }

    private ToolCallRequest? TryParseInlineToolCall(string toolId, string paramsJson, string rawBlock)
    {
        try
        {
            var parameters = JsonDocument.Parse(paramsJson).RootElement.Clone();
            var tool = _toolRegistry.GetTool(toolId);

            return new ToolCallRequest
            {
                ToolId = toolId,
                ToolName = tool?.Name ?? toolId,
                Parameters = parameters,
                RiskLevel = tool?.GetEffectiveRiskLevel(parameters) ?? _config.UnknownToolRiskLevel,
                ExecutionSummary = tool?.GetExecutionSummary(parameters) ?? $"Execute {toolId}",
                RawJson = rawBlock,
                RequiresApproval = true // Inline always requires approval for safety
            };
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Failed to parse inline tool call: {Tool}", toolId);
            return null;
        }
    }

    #endregion

    /// <summary>
    /// Create a streaming parser backed by this batch parser.
    /// </summary>
    public StreamingFunctionCallParser CreateStreamingParser() =>
        new(this);
}
```

### 2. StreamingFunctionCallParser.cs

**Location**: `src/SeniorIntern.Services/AI/StreamingFunctionCallParser.cs`

```csharp
namespace SeniorIntern.Services.AI;

using System.Text;
using SeniorIntern.Core.Models;

/// <summary>
/// Parses tool calls from streaming LLM output token by token.
/// </summary>
/// <remarks>
/// <para>
/// The streaming parser maintains internal state to detect tool call blocks
/// as tokens arrive. It buffers content when a potential tool call is
/// detected and emits complete tool calls once the closing ``` is found.
/// </para>
/// <para>
/// Usage pattern:
/// </para>
/// <code>
/// var parser = batchParser.CreateStreamingParser();
/// foreach (var token in tokenStream)
/// {
///     var result = parser.ProcessToken(token);
///     if (result.IsText) { /* emit text */ }
///     else if (result.IsToolCall) { /* process tool call */ }
///     // else buffering, wait for more tokens
/// }
/// var remaining = parser.Flush();
/// </code>
/// </remarks>
public sealed class StreamingFunctionCallParser
{
    private readonly FunctionCallParser _batchParser;
    private readonly StringBuilder _buffer = new();
    private readonly StringBuilder _textBuffer = new();

    private ParserState _state = ParserState.Text;
    private int _braceDepth;
    private int _toolCallStartIndex;

    /// <summary>
    /// Create a streaming parser backed by a batch parser.
    /// </summary>
    public StreamingFunctionCallParser(FunctionCallParser batchParser)
    {
        _batchParser = batchParser;
    }

    /// <summary>
    /// Current parser state.
    /// </summary>
    public ParserState CurrentState => _state;

    /// <summary>
    /// Whether we're currently buffering a potential tool call.
    /// </summary>
    public bool IsBuffering => _state != ParserState.Text;

    /// <summary>
    /// Current buffer contents.
    /// </summary>
    public string BufferedContent => _buffer.ToString();

    /// <summary>
    /// Process a streaming token and detect tool calls.
    /// </summary>
    /// <param name="token">The token to process.</param>
    /// <returns>Parse result indicating text, tool call, or buffering.</returns>
    public ParseResult ProcessToken(string token)
    {
        if (string.IsNullOrEmpty(token))
        {
            return ParseResult.Buffering();
        }

        _buffer.Append(token);
        var content = _buffer.ToString();

        return _state switch
        {
            ParserState.Text => ProcessTextState(token, content),
            ParserState.InToolCallOpening => ProcessToolCallOpening(content),
            ParserState.InToolCallJson => ProcessToolCallJson(token, content),
            ParserState.InToolCallClosing => ProcessToolCallClosing(content),
            _ => ParseResult.Text(token)
        };
    }

    #region State Processing

    private ParseResult ProcessTextState(string token, string content)
    {
        // Check for start of tool call block
        if (content.Contains("```tool_call"))
        {
            _state = ParserState.InToolCallOpening;
            _toolCallStartIndex = content.IndexOf("```tool_call", StringComparison.Ordinal);

            // Emit any text before the tool call
            if (_toolCallStartIndex > 0)
            {
                var textBefore = content[.._toolCallStartIndex];
                _buffer.Clear();
                _buffer.Append(content[_toolCallStartIndex..]);
                return ParseResult.Text(textBefore);
            }

            return ParseResult.Buffering();
        }

        // Check for potential start of tool call (partial match)
        if (CouldBeToolCallStart(content))
        {
            // Buffer but don't emit yet
            return ParseResult.Buffering();
        }

        // Regular text - emit immediately
        _buffer.Clear();
        return ParseResult.Text(token);
    }

    private ParseResult ProcessToolCallOpening(string content)
    {
        // Look for the opening brace after ```tool_call
        var newlineIndex = content.IndexOf('\n');
        if (newlineIndex >= 0)
        {
            var afterNewline = content[(newlineIndex + 1)..];
            var braceIndex = afterNewline.IndexOf('{');

            if (braceIndex >= 0)
            {
                _state = ParserState.InToolCallJson;
                _braceDepth = 1;

                // Count any additional braces in the remaining content
                for (int i = braceIndex + 1; i < afterNewline.Length; i++)
                {
                    if (afterNewline[i] == '{') _braceDepth++;
                    else if (afterNewline[i] == '}') _braceDepth--;
                }

                if (_braceDepth == 0)
                {
                    _state = ParserState.InToolCallClosing;
                }
            }
        }

        return ParseResult.Buffering();
    }

    private ParseResult ProcessToolCallJson(string token, string content)
    {
        // Track brace depth
        foreach (var c in token)
        {
            if (c == '{') _braceDepth++;
            else if (c == '}') _braceDepth--;
        }

        if (_braceDepth == 0)
        {
            _state = ParserState.InToolCallClosing;
        }

        return ParseResult.Buffering();
    }

    private ParseResult ProcessToolCallClosing(string content)
    {
        // Look for closing ```
        var jsonEnd = FindJsonEnd(content);
        if (jsonEnd >= 0)
        {
            var afterJson = content[(jsonEnd + 1)..];
            if (afterJson.Contains("```"))
            {
                // Complete tool call block found
                var closingIndex = afterJson.IndexOf("```", StringComparison.Ordinal);
                var fullBlock = content[..(jsonEnd + 1 + closingIndex + 3)];

                // Parse the complete block
                var request = _batchParser.ParseSingle(fullBlock);

                // Check if there's content after the tool call
                var remainingContent = content[(jsonEnd + 1 + closingIndex + 3)..];

                _buffer.Clear();
                if (!string.IsNullOrEmpty(remainingContent))
                {
                    _buffer.Append(remainingContent);
                }
                _state = ParserState.Text;

                if (request != null)
                {
                    return ParseResult.ToolCall(request);
                }
                else
                {
                    // Parsing failed, treat as text
                    return ParseResult.Text(fullBlock);
                }
            }
        }

        return ParseResult.Buffering();
    }

    #endregion

    #region Helper Methods

    private static bool CouldBeToolCallStart(string content)
    {
        // Check if content ends with partial "```tool_call"
        var patterns = new[] { "`", "``", "```", "```t", "```to", "```too", "```tool", "```tool_", "```tool_c", "```tool_ca", "```tool_cal" };
        return patterns.Any(p => content.EndsWith(p, StringComparison.Ordinal));
    }

    private static int FindJsonEnd(string content)
    {
        // Find the position after the JSON object ends (after the final })
        var depth = 0;
        var inJson = false;

        for (int i = 0; i < content.Length; i++)
        {
            if (content[i] == '{')
            {
                inJson = true;
                depth++;
            }
            else if (content[i] == '}')
            {
                depth--;
                if (inJson && depth == 0)
                {
                    return i;
                }
            }
        }

        return -1;
    }

    #endregion

    /// <summary>
    /// Reset parser state for a new response.
    /// </summary>
    public void Reset()
    {
        _buffer.Clear();
        _textBuffer.Clear();
        _state = ParserState.Text;
        _braceDepth = 0;
        _toolCallStartIndex = 0;
    }

    /// <summary>
    /// Get any remaining buffered content.
    /// </summary>
    /// <remarks>
    /// Call this at the end of streaming to get any incomplete content.
    /// If a tool call was incomplete, returns it as text.
    /// </remarks>
    public string Flush()
    {
        var remaining = _buffer.ToString();
        Reset();
        return remaining;
    }

    /// <summary>
    /// Get remaining as parse result.
    /// </summary>
    public ParseResult FlushAsResult()
    {
        var remaining = Flush();
        return string.IsNullOrEmpty(remaining)
            ? ParseResult.Empty()
            : ParseResult.Text(remaining);
    }
}

/// <summary>
/// Parser state for streaming detection.
/// </summary>
public enum ParserState
{
    /// <summary>Processing regular text.</summary>
    Text,

    /// <summary>Detected ```tool_call, waiting for JSON.</summary>
    InToolCallOpening,

    /// <summary>Inside JSON body, tracking braces.</summary>
    InToolCallJson,

    /// <summary>JSON complete, waiting for closing ```.</summary>
    InToolCallClosing
}
```

### 3. ParseResult.cs

**Location**: `src/SeniorIntern.Services/AI/ParseResult.cs`

```csharp
namespace SeniorIntern.Services.AI;

using SeniorIntern.Core.Models;

/// <summary>
/// Result of parsing a streaming token.
/// </summary>
/// <remarks>
/// <para>
/// ParseResult has three mutually exclusive states:
/// </para>
/// <list type="bullet">
/// <item><b>IsText</b>: Regular text to emit to UI</item>
/// <item><b>IsToolCall</b>: Complete tool call detected</item>
/// <item><b>IsBuffering</b>: Potential tool call, waiting for more tokens</item>
/// </list>
/// </remarks>
public sealed class ParseResult
{
    /// <summary>
    /// This is regular text content.
    /// </summary>
    public bool IsText { get; init; }

    /// <summary>
    /// The text content (when IsText is true).
    /// </summary>
    public string? Text { get; init; }

    /// <summary>
    /// A complete tool call was detected.
    /// </summary>
    public bool IsToolCall { get; init; }

    /// <summary>
    /// The parsed tool call (when IsToolCall is true).
    /// </summary>
    public ToolCallRequest? ToolCall { get; init; }

    /// <summary>
    /// Content is being buffered (potential tool call in progress).
    /// </summary>
    public bool IsBuffering { get; init; }

    /// <summary>
    /// Error message if parsing failed.
    /// </summary>
    public string? Error { get; init; }

    /// <summary>
    /// Whether parsing encountered an error.
    /// </summary>
    public bool HasError => !string.IsNullOrEmpty(Error);

    /// <summary>
    /// Whether this result is empty (no content).
    /// </summary>
    public bool IsEmpty => !IsText && !IsToolCall && !IsBuffering;

    #region Factory Methods

    /// <summary>
    /// Create a text result.
    /// </summary>
    public static ParseResult Text(string text) => new()
    {
        IsText = true,
        Text = text
    };

    /// <summary>
    /// Create a tool call result.
    /// </summary>
    public static ParseResult ToolCall(ToolCallRequest request) => new()
    {
        IsToolCall = true,
        ToolCall = request
    };

    /// <summary>
    /// Create a buffering result.
    /// </summary>
    public static ParseResult Buffering() => new()
    {
        IsBuffering = true
    };

    /// <summary>
    /// Create an error result.
    /// </summary>
    public static ParseResult WithError(string error, string? text = null) => new()
    {
        IsText = !string.IsNullOrEmpty(text),
        Text = text,
        Error = error
    };

    /// <summary>
    /// Create an empty result.
    /// </summary>
    public static ParseResult Empty() => new();

    #endregion

    /// <inheritdoc />
    public override string ToString() =>
        IsText ? $"Text: \"{Text?.Truncate(30)}\""
        : IsToolCall ? $"ToolCall: {ToolCall?.ToolName}"
        : IsBuffering ? "Buffering..."
        : "Empty";
}

/// <summary>
/// Separated content from a parsed response.
/// </summary>
public sealed class ParsedContent
{
    /// <summary>
    /// Text that appeared before any tool calls.
    /// </summary>
    public string TextBefore { get; init; } = string.Empty;

    /// <summary>
    /// Text that appeared after all tool calls.
    /// </summary>
    public string TextAfter { get; init; } = string.Empty;

    /// <summary>
    /// Full extracted text (all non-tool-call content).
    /// </summary>
    public string FullText { get; init; } = string.Empty;

    /// <summary>
    /// All tool calls found in the response.
    /// </summary>
    public List<ToolCallRequest> ToolCalls { get; init; } = new();

    /// <summary>
    /// Raw tool call blocks as they appeared in the response.
    /// </summary>
    public List<string>? RawBlocks { get; init; }

    /// <summary>
    /// Whether any tool calls were found.
    /// </summary>
    public bool HasToolCalls => ToolCalls.Count > 0;

    /// <summary>
    /// Number of tool calls found.
    /// </summary>
    public int ToolCallCount => ToolCalls.Count;

    /// <summary>
    /// Whether there is any text content.
    /// </summary>
    public bool HasText => !string.IsNullOrWhiteSpace(FullText);
}
```

### 4. ParserConfiguration.cs

**Location**: `src/SeniorIntern.Services/AI/ParserConfiguration.cs`

```csharp
namespace SeniorIntern.Services.AI;

using SeniorIntern.Core.Tools;

/// <summary>
/// Configuration options for function call parsing.
/// </summary>
public sealed class ParserConfiguration
{
    /// <summary>
    /// Whether to allow ```json blocks as tool calls.
    /// </summary>
    /// <remarks>
    /// When enabled, JSON blocks containing a "tool" property are parsed.
    /// Default: true
    /// </remarks>
    public bool AllowJsonBlocks { get; init; } = true;

    /// <summary>
    /// Whether to allow inline JSON tool calls.
    /// </summary>
    /// <remarks>
    /// When enabled, inline JSON like {"tool": "...", "parameters": {...}}
    /// is detected. This is less reliable and always requires approval.
    /// Default: false (only as fallback)
    /// </remarks>
    public bool AllowInlineJson { get; init; } = false;

    /// <summary>
    /// Risk level assigned to unknown tools.
    /// </summary>
    /// <remarks>
    /// When a tool ID isn't in the registry, this risk level is used.
    /// Default: Medium
    /// </remarks>
    public RiskLevel UnknownToolRiskLevel { get; init; } = RiskLevel.Medium;

    /// <summary>
    /// Auto-approval threshold.
    /// </summary>
    /// <remarks>
    /// Tools with risk levels at or below this don't require approval.
    /// Default: Safe
    /// </remarks>
    public RiskLevel AutoApprovalThreshold { get; init; } = RiskLevel.Safe;

    /// <summary>
    /// Whether to attempt JSON repair for malformed blocks.
    /// </summary>
    /// <remarks>
    /// When enabled, attempts to fix common JSON issues like trailing commas.
    /// Default: true
    /// </remarks>
    public bool AttemptJsonRepair { get; init; } = true;

    /// <summary>
    /// Maximum buffer size for streaming parser (characters).
    /// </summary>
    /// <remarks>
    /// If a tool call block exceeds this size, it's treated as malformed.
    /// Default: 50000
    /// </remarks>
    public int MaxBufferSize { get; init; } = 50000;

    /// <summary>
    /// Default configuration.
    /// </summary>
    public static ParserConfiguration Default => new();

    /// <summary>
    /// Strict configuration (only ```tool_call blocks).
    /// </summary>
    public static ParserConfiguration Strict => new()
    {
        AllowJsonBlocks = false,
        AllowInlineJson = false
    };

    /// <summary>
    /// Lenient configuration (all formats).
    /// </summary>
    public static ParserConfiguration Lenient => new()
    {
        AllowJsonBlocks = true,
        AllowInlineJson = true
    };
}
```

---

## File Summary

| File | Location | Purpose | Lines |
|------|----------|---------|-------|
| `FunctionCallParser.cs` | `Services/AI/` | Batch parsing with multiple formats | ~240 |
| `StreamingFunctionCallParser.cs` | `Services/AI/` | Token-by-token streaming detection | ~200 |
| `ParseResult.cs` | `Services/AI/` | Parser output model | ~100 |
| `ParserConfiguration.cs` | `Services/AI/` | Parser settings | ~70 |
| `ParsedContent.cs` | (in ParseResult) | Split content model | ~40 |

---

## Unit Test Plan

| Test | Description |
|------|-------------|
| `FunctionCallParser_Parse_DetectsToolCallBlock` | Primary pattern |
| `FunctionCallParser_Parse_DetectsMultipleToolCalls` | Multiple blocks |
| `FunctionCallParser_Parse_DetectsJsonBlock` | Alternative format |
| `FunctionCallParser_Parse_HandlesInlineJson` | Inline fallback |
| `FunctionCallParser_Parse_ReturnsEmptyForNoToolCalls` | No matches |
| `FunctionCallParser_Parse_HandlesMalformedJson` | Error recovery |
| `FunctionCallParser_ExtractText_RemovesToolCallBlocks` | Text extraction |
| `FunctionCallParser_SplitContent_SeparatesTextAndCalls` | Content splitting |
| `StreamingParser_ProcessToken_DetectsToolCallStart` | Opening detection |
| `StreamingParser_ProcessToken_TracksJsonBraces` | Brace tracking |
| `StreamingParser_ProcessToken_DetectsToolCallComplete` | Closing detection |
| `StreamingParser_ProcessToken_EmitsTextDuringBuffering` | Text before call |
| `StreamingParser_Flush_ReturnsBufferedContent` | Flush behavior |
| `StreamingParser_Reset_ClearsState` | State reset |
| `ParseResult_Factory_CreatesCorrectTypes` | Factory methods |

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | Batch parser handles ```tool_call``` blocks |
| AC-2 | Batch parser handles alternative JSON formats |
| AC-3 | Streaming parser detects tool calls token-by-token |
| AC-4 | Parser extracts text content separately from tool calls |
| AC-5 | Parser handles malformed JSON gracefully |
| AC-6 | Streaming parser correctly tracks brace depth |
| AC-7 | Parser integrates with IToolRegistry for metadata |

---

## Changelog Entry

```markdown
## v0.6.2g - Function Call Parser

### Added
- `FunctionCallParser` for batch parsing of complete LLM responses
- `StreamingFunctionCallParser` for token-by-token streaming detection
- `ParseResult` with Text, ToolCall, and Buffering states
- `ParsedContent` for split text/tool call content
- `ParserConfiguration` with format and safety options
- Multiple format support: ```tool_call```, ```json```, inline JSON
- Source-generated regex patterns for performance
- Integration with IToolRegistry for tool metadata and risk assessment
- Graceful error handling for malformed JSON
```

---

## Timeline Estimate

| Version | Estimated Effort |
|---------|------------------|
| v0.6.2g | 0.75 day |
