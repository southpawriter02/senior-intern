# Design Specification: AIntern v0.6.4e "PermissionManager Implementation"

## Overview

**Version**: v0.6.4e
**Parent**: v0.6.4 Safety & Approval
**Focus**: Core permission management service integrating all safety components

### Purpose

Implement the PermissionManager that:
1. Integrates risk classification, session caching, and rate limiting
2. Evaluates policy rules to make permission decisions
3. Manages approval workflows with async event-based UI integration
4. Persists remembered decisions to settings
5. Records audit log entries
6. Provides policy CRUD operations
7. Raises events for UI synchronization

### Dependencies

**From v0.6.4a (Permission Policy Models)**:
- `PermissionPolicy`, `PolicyMode`
- `ToolPermissionOverride`, `OverrideAction`
- `BlockedPattern`, `ProtectedPath`

**From v0.6.4b (Risk Classification Engine)**:
- `IRiskClassifier`, `RiskClassifier`
- `RiskClassificationResult`, `RiskFactor`

**From v0.6.4c (Permission Check System)**:
- `PermissionCheckResult`, `PermissionSource`
- `ApprovalDecision`, `RememberOption`
- `IRateLimiter`, `RateLimiter`
- `ISessionPermissionCache`, `SessionPermissionCache`
- `RateLimitStatus`, `CachedDecision`

**From v0.6.4d (IPermissionManager Interface)**:
- `IPermissionManager`
- `ApprovalRequestedEventArgs`
- `PolicyChangedEventArgs`, `PolicyChangeType`
- `DecisionRememberedEventArgs`
- `AuditLogQuery`

**From Core Services**:
- `ISettingsService`
- `IAuditLogRepository`

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                   v0.6.4e PermissionManager Architecture                      │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  PermissionManager                                                           │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  Dependencies:                                                           │ │
│  │  ├── IRiskClassifier         (Risk analysis)                            │ │
│  │  ├── IRateLimiter            (Rate enforcement)                         │ │
│  │  ├── ISessionPermissionCache (Session decisions)                        │ │
│  │  ├── IAuditLogRepository     (Audit persistence)                        │ │
│  │  ├── ISettingsService        (Policy persistence)                       │ │
│  │  └── ILogger<PermissionManager>                                         │ │
│  │                                                                          │ │
│  │  State:                                                                  │ │
│  │  ├── _policy: PermissionPolicy (current policy)                         │ │
│  │  ├── _policyLock: SemaphoreSlim (thread safety)                         │ │
│  │  └── _pendingApprovals: ConcurrentDictionary<Guid, EventArgs>           │ │
│  │                                                                          │ │
│  │  Events:                                                                 │ │
│  │  ├── ApprovalRequested                                                  │ │
│  │  ├── PolicyChanged                                                      │ │
│  │  └── DecisionRemembered                                                 │ │
│  │                                                                          │ │
│  │  Methods:                                                                │ │
│  │  ├── CheckPermissionAsync()    → Integrates all components              │ │
│  │  ├── ClassifyRisk()            → Delegates to RiskClassifier            │ │
│  │  ├── RequestApprovalAsync()    → Event-based approval flow              │ │
│  │  ├── SubmitDecision()          → Completes pending approvals            │ │
│  │  ├── RememberDecisionAsync()   → Session + persistent storage           │ │
│  │  ├── UpdatePolicyAsync()       → Save + notify change                   │ │
│  │  └── RecordAuditAsync()        → Audit with filtering                   │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  Component Integration:                                                      │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │                                                                         │  │
│  │    ┌───────────────┐    ┌────────────────┐    ┌──────────────────┐     │  │
│  │    │  RateLimiter  │───►│ RiskClassifier │───►│  SessionCache    │     │  │
│  │    └───────────────┘    └────────────────┘    └──────────────────┘     │  │
│  │           │                     │                      │               │  │
│  │           ▼                     ▼                      ▼               │  │
│  │    ┌─────────────────────────────────────────────────────────────┐    │  │
│  │    │                    PermissionManager                         │    │  │
│  │    │                    (Coordinator)                             │    │  │
│  │    └─────────────────────────────────────────────────────────────┘    │  │
│  │           │                     │                      │               │  │
│  │           ▼                     ▼                      ▼               │  │
│  │    ┌───────────────┐    ┌────────────────┐    ┌──────────────────┐     │  │
│  │    │SettingsService│    │AuditRepository │    │   UI (Events)    │     │  │
│  │    └───────────────┘    └────────────────┘    └──────────────────┘     │  │
│  │                                                                         │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Permission Check Flow

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                   CheckPermissionAsync Execution Flow                         │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  CheckPermissionAsync(request, tool)                                         │
│      │                                                                       │
│      ▼                                                                       │
│  ┌─────────────────────────────────────┐                                     │
│  │ 1. Check Rate Limit                 │                                     │
│  │    _rateLimiter.CheckLimit()        │                                     │
│  └─────────────────┬───────────────────┘                                     │
│           exceeded─┤                                                          │
│                    ▼                                                          │
│           PermissionCheckResult.RateLimited()                                 │
│                    │ allowed                                                  │
│                    ▼                                                          │
│  ┌─────────────────────────────────────┐                                     │
│  │ 2. Check Policy Mode                │                                     │
│  │    _policy.Mode == Disabled?        │                                     │
│  └─────────────────┬───────────────────┘                                     │
│            disabled─┤                                                         │
│                    ▼                                                          │
│           PermissionCheckResult.Blocked("disabled")                           │
│                    │ not disabled                                             │
│                    ▼                                                          │
│  ┌─────────────────────────────────────┐                                     │
│  │ 3. Classify Risk                    │                                     │
│  │    _riskClassifier.Classify()       │                                     │
│  └─────────────────┬───────────────────┘                                     │
│                    │                                                          │
│                    ▼                                                          │
│  ┌─────────────────────────────────────┐                                     │
│  │ 4. Check Blocked                    │                                     │
│  │    classification.IsBlocked?        │                                     │
│  └─────────────────┬───────────────────┘                                     │
│            blocked─┤                                                          │
│                    ▼                                                          │
│           PermissionCheckResult.Blocked(reason)                               │
│                    │ not blocked                                              │
│                    ▼                                                          │
│  ┌─────────────────────────────────────┐                                     │
│  │ 5. Check Trusted                    │                                     │
│  │    classification.IsTrusted?        │                                     │
│  └─────────────────┬───────────────────┘                                     │
│            trusted─┤                                                          │
│                    ▼                                                          │
│           PermissionCheckResult.Allowed(TrustedTool)                          │
│                    │ not trusted                                              │
│                    ▼                                                          │
│  ┌─────────────────────────────────────┐                                     │
│  │ 6. Check Session Cache              │                                     │
│  │    _sessionCache.TryGetDecision()   │                                     │
│  └─────────────────┬───────────────────┘                                     │
│        cached hit──┤                                                          │
│                    ▼                                                          │
│           PermissionCheckResult (WasCached=true)                              │
│                    │ cache miss                                               │
│                    ▼                                                          │
│  ┌─────────────────────────────────────┐                                     │
│  │ 7. Check Persistent Overrides       │                                     │
│  │    _policy.ToolOverrides[toolId]    │                                     │
│  └─────────────────┬───────────────────┘                                     │
│     AlwaysAllow───┤                                                          │
│                    ▼                                                          │
│           PermissionCheckResult.Allowed(Persistent)                           │
│                    │ no override/other                                        │
│                    ▼                                                          │
│  ┌─────────────────────────────────────┐                                     │
│  │ 8. Apply Policy Mode                │                                     │
│  │    AutoApprove / AlwaysAsk /        │                                     │
│  │    AskForRisky                      │                                     │
│  └─────────────────┬───────────────────┘                                     │
│                    │                                                          │
│           ┌────────┼────────┬────────────────┐                               │
│           ▼        ▼        ▼                ▼                               │
│      AutoApprove  AlwaysAsk  Risk≥Threshold  Risk<Threshold                  │
│           │        │              │                │                          │
│           ▼        ▼              ▼                ▼                          │
│       Allowed   NeedsApproval  NeedsApproval    Allowed                       │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Approval Request Flow

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                     RequestApprovalAsync Execution Flow                       │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  RequestApprovalAsync(request, classification, ct)                           │
│      │                                                                       │
│      ▼                                                                       │
│  ┌─────────────────────────────────────┐                                     │
│  │ 1. Create Request ID                │                                     │
│  │    requestId = Guid.NewGuid()       │                                     │
│  └─────────────────┬───────────────────┘                                     │
│                    │                                                          │
│                    ▼                                                          │
│  ┌─────────────────────────────────────┐                                     │
│  │ 2. Create Event Args                │                                     │
│  │    ApprovalRequestedEventArgs {     │                                     │
│  │      RequestId,                     │                                     │
│  │      ToolRequest,                   │                                     │
│  │      Tool,                          │                                     │
│  │      Classification,                │                                     │
│  │      DecisionTask = new TCS(),      │                                     │
│  │      Timeout                        │                                     │
│  │    }                                │                                     │
│  └─────────────────┬───────────────────┘                                     │
│                    │                                                          │
│                    ▼                                                          │
│  ┌─────────────────────────────────────┐                                     │
│  │ 3. Store Pending Approval           │                                     │
│  │    _pendingApprovals[requestId]     │                                     │
│  └─────────────────┬───────────────────┘                                     │
│                    │                                                          │
│                    ▼                                                          │
│  ┌─────────────────────────────────────┐                                     │
│  │ 4. Raise Event                      │                                     │
│  │    ApprovalRequested?.Invoke()      │                                     │
│  └─────────────────┬───────────────────┘                                     │
│                    │                                                          │
│                    ▼                                                          │
│  ┌─────────────────────────────────────┐                                     │
│  │ 5. Wait for Decision                │                                     │
│  │    using timeout + linked CT        │                                     │
│  │    await DecisionTask.WaitAsync()   │                                     │
│  └─────────────────┬───────────────────┘                                     │
│                    │                                                          │
│        ┌───────────┼───────────┬────────────────┐                            │
│        ▼           ▼           ▼                ▼                            │
│   User Decides  Timeout   Cancelled      Exception                           │
│        │           │           │                │                            │
│        ▼           ▼           ▼                ▼                            │
│   return decision  TimedOut   Cancelled      rethrow                         │
│                                                                              │
│  ┌─────────────────────────────────────┐                                     │
│  │ 6. Cleanup Pending                  │                                     │
│  │    _pendingApprovals.Remove()       │                                     │
│  └─────────────────────────────────────┘                                     │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Specifications

### 1. PermissionManager.cs

**Location**: `src/SeniorIntern.Services/Permissions/PermissionManager.cs`

```csharp
namespace SeniorIntern.Services.Permissions;

using System.Collections.Concurrent;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models.Permissions;
using SeniorIntern.Core.Tools;

/// <summary>
/// Implementation of the permission management system.
/// </summary>
/// <remarks>
/// <para>
/// Coordinates all safety components including:
/// </para>
/// <list type="bullet">
/// <item>Risk classification</item>
/// <item>Rate limiting</item>
/// <item>Session caching</item>
/// <item>Policy evaluation</item>
/// <item>Audit logging</item>
/// </list>
/// </remarks>
public sealed class PermissionManager : IPermissionManager, IDisposable
{
    #region Dependencies

    private readonly IRiskClassifier _riskClassifier;
    private readonly IRateLimiter _rateLimiter;
    private readonly ISessionPermissionCache _sessionCache;
    private readonly IAuditLogRepository _auditRepository;
    private readonly ISettingsService _settingsService;
    private readonly ILogger<PermissionManager> _logger;

    #endregion

    #region State

    /// <summary>
    /// Current permission policy.
    /// </summary>
    private PermissionPolicy _policy;

    /// <summary>
    /// Lock for thread-safe policy updates.
    /// </summary>
    private readonly SemaphoreSlim _policyLock = new(1, 1);

    /// <summary>
    /// Pending approval requests awaiting user response.
    /// </summary>
    private readonly ConcurrentDictionary<Guid, ApprovalRequestedEventArgs> _pendingApprovals = new();

    #endregion

    #region Events

    /// <inheritdoc />
    public event EventHandler<ApprovalRequestedEventArgs>? ApprovalRequested;

    /// <inheritdoc />
    public event EventHandler<PolicyChangedEventArgs>? PolicyChanged;

    /// <inheritdoc />
    public event EventHandler<DecisionRememberedEventArgs>? DecisionRemembered;

    #endregion

    #region Constructor

    public PermissionManager(
        IRiskClassifier riskClassifier,
        IRateLimiter rateLimiter,
        ISessionPermissionCache sessionCache,
        IAuditLogRepository auditRepository,
        ISettingsService settingsService,
        ILogger<PermissionManager> logger)
    {
        _riskClassifier = riskClassifier ?? throw new ArgumentNullException(nameof(riskClassifier));
        _rateLimiter = rateLimiter ?? throw new ArgumentNullException(nameof(rateLimiter));
        _sessionCache = sessionCache ?? throw new ArgumentNullException(nameof(sessionCache));
        _auditRepository = auditRepository ?? throw new ArgumentNullException(nameof(auditRepository));
        _settingsService = settingsService ?? throw new ArgumentNullException(nameof(settingsService));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));

        _policy = _settingsService.GetPermissionPolicy() ?? PermissionPolicy.CreateBalanced();

        _logger.LogInformation(
            "PermissionManager initialized with mode {Mode}, threshold {Threshold}",
            _policy.Mode, _policy.ApprovalThreshold);
    }

    #endregion

    #region Permission Checking

    /// <inheritdoc />
    public async Task<PermissionCheckResult> CheckPermissionAsync(
        ToolCallRequest request,
        ITool tool)
    {
        ArgumentNullException.ThrowIfNull(request);
        ArgumentNullException.ThrowIfNull(tool);

        _logger.LogDebug("Checking permission for tool: {ToolId}", tool.Id);

        // Step 1: Check rate limit first
        var rateLimitResult = _rateLimiter.CheckLimit();
        if (!rateLimitResult.IsAllowed)
        {
            _logger.LogWarning(
                "Rate limit exceeded for tool call: {ToolId} - {Reason}",
                tool.Id, rateLimitResult.Reason);

            return PermissionCheckResult.RateLimited(
                rateLimitResult.Reason!,
                rateLimitResult.RetryAfter);
        }

        // Step 2: Check policy mode
        if (_policy.Mode == PolicyMode.Disabled)
        {
            _logger.LogWarning("Tool execution is disabled by policy");
            return PermissionCheckResult.Blocked("Tool execution is disabled by policy");
        }

        // Step 3: Classify risk
        var classification = _riskClassifier.Classify(request, tool);

        // Step 4: Handle blocked tools/patterns
        if (classification.IsBlocked)
        {
            _logger.LogWarning(
                "Tool call blocked: {ToolId} - {Reason}",
                tool.Id, classification.BlockReason);

            return PermissionCheckResult.Blocked(
                classification.BlockReason!,
                classification.FinalRisk);
        }

        // Step 5: Handle trusted tools
        if (classification.IsTrusted)
        {
            _logger.LogDebug("Tool is trusted, auto-approving: {ToolId}", tool.Id);
            return PermissionCheckResult.Allowed(
                RiskLevel.Safe,
                PermissionSource.TrustedTool,
                "Tool is in trusted list");
        }

        // Step 6: Check session cache
        if (_sessionCache.TryGetDecision(tool.Id, out var cached))
        {
            if (cached!.Decision.IsApproved)
            {
                _logger.LogDebug("Using cached approval for tool: {ToolId}", tool.Id);
                return PermissionCheckResult.FromCache(cached.Decision, classification.FinalRisk);
            }
            else if (cached.Decision.IsDenied)
            {
                _logger.LogDebug("Using cached denial for tool: {ToolId}", tool.Id);
                return PermissionCheckResult.Blocked(
                    "Previously denied this session",
                    classification.FinalRisk);
            }
        }

        // Step 7: Check persistent overrides
        if (_policy.ToolOverrides.TryGetValue(tool.Id, out var toolOverride) &&
            !toolOverride.IsExpired)
        {
            switch (toolOverride.Action)
            {
                case OverrideAction.AlwaysAllow:
                    _logger.LogDebug("Tool always allowed by override: {ToolId}", tool.Id);
                    return PermissionCheckResult.Allowed(
                        classification.FinalRisk,
                        PermissionSource.Persistent,
                        toolOverride.Reason ?? "Always allowed by user preference");

                case OverrideAction.Block:
                    _logger.LogDebug("Tool blocked by override: {ToolId}", tool.Id);
                    return PermissionCheckResult.Blocked(
                        toolOverride.Reason ?? "Blocked by user preference",
                        classification.FinalRisk);

                case OverrideAction.AlwaysAsk:
                    _logger.LogDebug("Tool requires approval by override: {ToolId}", tool.Id);
                    return PermissionCheckResult.NeedsApproval(
                        classification.FinalRisk,
                        classification.Factors,
                        "Always ask (user preference)");
            }
        }

        // Step 8: Apply policy mode
        return ApplyPolicyMode(tool.Id, classification);
    }

    /// <summary>
    /// Apply the policy mode to determine final decision.
    /// </summary>
    private PermissionCheckResult ApplyPolicyMode(
        string toolId,
        RiskClassificationResult classification)
    {
        switch (_policy.Mode)
        {
            case PolicyMode.AutoApprove:
                _logger.LogDebug(
                    "Auto-approving {ToolId} (AutoApprove mode)",
                    toolId);
                return PermissionCheckResult.Allowed(
                    classification.FinalRisk,
                    PermissionSource.Policy,
                    "Auto-approve mode enabled");

            case PolicyMode.AlwaysAsk:
                _logger.LogDebug(
                    "Requesting approval for {ToolId} (AlwaysAsk mode)",
                    toolId);
                return PermissionCheckResult.NeedsApproval(
                    classification.FinalRisk,
                    classification.Factors,
                    "Always-ask mode enabled");

            case PolicyMode.AskForRisky:
                if (classification.FinalRisk >= _policy.ApprovalThreshold)
                {
                    _logger.LogDebug(
                        "Requesting approval for {ToolId} (risk {Risk} >= threshold {Threshold})",
                        toolId, classification.FinalRisk, _policy.ApprovalThreshold);

                    return PermissionCheckResult.NeedsApproval(
                        classification.FinalRisk,
                        classification.Factors,
                        $"Risk level {classification.FinalRisk} >= threshold {_policy.ApprovalThreshold}");
                }
                else
                {
                    _logger.LogDebug(
                        "Auto-approving {ToolId} (risk {Risk} < threshold {Threshold})",
                        toolId, classification.FinalRisk, _policy.ApprovalThreshold);

                    return PermissionCheckResult.Allowed(
                        classification.FinalRisk,
                        PermissionSource.Policy,
                        $"Risk level {classification.FinalRisk} < threshold {_policy.ApprovalThreshold}");
                }

            default:
                _logger.LogError("Unknown policy mode: {Mode}", _policy.Mode);
                return PermissionCheckResult.Blocked("Unknown policy mode");
        }
    }

    /// <inheritdoc />
    public RiskClassificationResult ClassifyRisk(ToolCallRequest request, ITool tool)
    {
        return _riskClassifier.Classify(request, tool);
    }

    #endregion

    #region Approval Workflow

    /// <inheritdoc />
    public async Task<ApprovalDecision> RequestApprovalAsync(
        ToolCallRequest request,
        RiskClassificationResult classificationResult,
        CancellationToken ct = default)
    {
        ArgumentNullException.ThrowIfNull(request);
        ArgumentNullException.ThrowIfNull(classificationResult);

        var requestId = Guid.NewGuid();

        var eventArgs = new ApprovalRequestedEventArgs
        {
            RequestId = requestId,
            ToolRequest = request,
            Classification = classificationResult,
            Timeout = TimeSpan.FromSeconds(_policy.ApprovalTimeoutSeconds),
            AllowParameterEditing = _policy.AllowParameterEditing,
            ShowParameters = _policy.ShowParametersInApproval
        };

        // Store pending approval
        _pendingApprovals[requestId] = eventArgs;

        _logger.LogInformation(
            "Requesting approval for tool {ToolId} (RequestId: {RequestId}, Risk: {Risk})",
            request.ToolId, requestId, classificationResult.FinalRisk);

        try
        {
            // Raise event for UI to handle
            ApprovalRequested?.Invoke(this, eventArgs);

            // Wait for decision with timeout
            using var timeoutCts = new CancellationTokenSource(eventArgs.Timeout);
            using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(ct, timeoutCts.Token);

            var decision = await eventArgs.DecisionTask.Task.WaitAsync(linkedCts.Token);

            _logger.LogInformation(
                "Approval decision for {ToolId}: {Decision} (Remember: {Remember})",
                request.ToolId,
                decision.IsApproved ? "Approved" : "Denied",
                decision.RememberChoice);

            // Handle remember choice
            if (decision.RememberChoice != RememberOption.None)
            {
                await RememberDecisionAsync(request.ToolId, decision);
            }

            return decision;
        }
        catch (OperationCanceledException) when (!ct.IsCancellationRequested)
        {
            // Timeout occurred
            _logger.LogWarning(
                "Approval request timed out for tool {ToolId} (RequestId: {RequestId})",
                request.ToolId, requestId);

            return ApprovalDecision.TimedOut(request.ToolId, requestId);
        }
        catch (OperationCanceledException)
        {
            // User cancellation
            _logger.LogInformation(
                "Approval request cancelled for tool {ToolId} (RequestId: {RequestId})",
                request.ToolId, requestId);

            return ApprovalDecision.Cancelled(request.ToolId, requestId);
        }
        finally
        {
            // Cleanup pending approval
            _pendingApprovals.TryRemove(requestId, out _);
        }
    }

    /// <inheritdoc />
    public void SubmitDecision(Guid requestId, ApprovalDecision decision)
    {
        if (_pendingApprovals.TryGetValue(requestId, out var eventArgs))
        {
            _logger.LogDebug(
                "Submitting decision for request {RequestId}: {Decision}",
                requestId, decision.IsApproved ? "Approved" : "Denied");

            eventArgs.DecisionTask.TrySetResult(decision);
        }
        else
        {
            _logger.LogWarning(
                "Attempted to submit decision for unknown request: {RequestId}",
                requestId);
        }
    }

    /// <inheritdoc />
    public void CancelApproval(Guid requestId)
    {
        if (_pendingApprovals.TryGetValue(requestId, out var eventArgs))
        {
            _logger.LogDebug("Cancelling approval request: {RequestId}", requestId);
            eventArgs.DecisionTask.TrySetResult(
                ApprovalDecision.Cancelled(eventArgs.ToolRequest.ToolId, requestId));
        }
    }

    /// <inheritdoc />
    public IReadOnlyList<ApprovalRequestedEventArgs> GetPendingApprovals()
    {
        return _pendingApprovals.Values.ToList();
    }

    #endregion

    #region Decision Memory

    /// <inheritdoc />
    public async Task RememberDecisionAsync(string toolId, ApprovalDecision decision)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(toolId);
        ArgumentNullException.ThrowIfNull(decision);

        bool replacedExisting = false;

        switch (decision.RememberChoice)
        {
            case RememberOption.ForSession:
                replacedExisting = _sessionCache.TryGetDecision(toolId, out _);
                _sessionCache.CacheDecision(toolId, decision);
                _logger.LogInformation(
                    "Cached decision for session: {ToolId} -> {Decision}",
                    toolId, decision.IsApproved ? "Approved" : "Denied");
                break;

            case RememberOption.Always:
                await _policyLock.WaitAsync();
                try
                {
                    replacedExisting = _policy.ToolOverrides.ContainsKey(toolId);

                    var action = decision.IsApproved
                        ? OverrideAction.AlwaysAllow
                        : OverrideAction.Block;

                    _policy.ToolOverrides[toolId] = new ToolPermissionOverride
                    {
                        ToolId = toolId,
                        Action = action,
                        Reason = decision.Reason ??
                            (decision.IsApproved ? "User always allowed" : "User blocked"),
                        IsUserDefined = true
                    };

                    await _settingsService.SavePermissionPolicyAsync(_policy);

                    _logger.LogInformation(
                        "Saved persistent permission for tool: {ToolId} -> {Action}",
                        toolId, action);
                }
                finally
                {
                    _policyLock.Release();
                }
                break;
        }

        // Raise event
        DecisionRemembered?.Invoke(this, new DecisionRememberedEventArgs
        {
            ToolId = toolId,
            Decision = decision,
            RememberOption = decision.RememberChoice,
            ReplacedExisting = replacedExisting
        });
    }

    /// <inheritdoc />
    public async Task ClearRememberedDecisionsAsync(string? toolId = null)
    {
        if (toolId != null)
        {
            // Clear specific tool
            _sessionCache.Clear(toolId);

            await _policyLock.WaitAsync();
            try
            {
                if (_policy.ToolOverrides.Remove(toolId))
                {
                    await _settingsService.SavePermissionPolicyAsync(_policy);
                    _logger.LogInformation("Cleared remembered decisions for tool: {ToolId}", toolId);
                }
            }
            finally
            {
                _policyLock.Release();
            }
        }
        else
        {
            // Clear all
            _sessionCache.Clear();

            await _policyLock.WaitAsync();
            try
            {
                var count = _policy.ToolOverrides.Count;
                _policy.ToolOverrides.Clear();
                await _settingsService.SavePermissionPolicyAsync(_policy);
                _logger.LogInformation("Cleared all {Count} remembered decisions", count);
            }
            finally
            {
                _policyLock.Release();
            }
        }
    }

    /// <inheritdoc />
    public IReadOnlyList<CachedDecision> GetRememberedDecisions()
    {
        return _sessionCache.GetAll();
    }

    #endregion

    #region Policy Management

    /// <inheritdoc />
    public PermissionPolicy GetPolicy() => _policy;

    /// <inheritdoc />
    public async Task UpdatePolicyAsync(PermissionPolicy policy)
    {
        ArgumentNullException.ThrowIfNull(policy);

        await _policyLock.WaitAsync();
        try
        {
            var oldPolicy = _policy;
            _policy = policy;

            await _settingsService.SavePermissionPolicyAsync(policy);

            var changeType = DetermineChangeType(oldPolicy, policy);

            _logger.LogInformation(
                "Permission policy updated: {ChangeType}",
                changeType);

            PolicyChanged?.Invoke(this, new PolicyChangedEventArgs
            {
                OldPolicy = oldPolicy,
                NewPolicy = policy,
                ChangeType = changeType
            });
        }
        finally
        {
            _policyLock.Release();
        }
    }

    /// <inheritdoc />
    public async Task SetToolOverrideAsync(ToolPermissionOverride @override)
    {
        await _policyLock.WaitAsync();
        try
        {
            var oldPolicy = _policy with { }; // Shallow copy
            _policy.ToolOverrides[@override.ToolId] = @override;

            await _settingsService.SavePermissionPolicyAsync(_policy);

            PolicyChanged?.Invoke(this, new PolicyChangedEventArgs
            {
                OldPolicy = oldPolicy,
                NewPolicy = _policy,
                ChangeType = PolicyChangeType.ToolOverrides
            });

            _logger.LogInformation(
                "Set tool override: {ToolId} -> {Action}",
                @override.ToolId, @override.Action);
        }
        finally
        {
            _policyLock.Release();
        }
    }

    /// <inheritdoc />
    public async Task RemoveToolOverrideAsync(string toolId)
    {
        await _policyLock.WaitAsync();
        try
        {
            if (_policy.ToolOverrides.Remove(toolId))
            {
                await _settingsService.SavePermissionPolicyAsync(_policy);

                _logger.LogInformation("Removed tool override: {ToolId}", toolId);
            }
        }
        finally
        {
            _policyLock.Release();
        }
    }

    /// <inheritdoc />
    public async Task TrustToolAsync(string toolId)
    {
        await _policyLock.WaitAsync();
        try
        {
            if (_policy.TrustedTools.Add(toolId))
            {
                _policy.BlockedTools.Remove(toolId); // Ensure not in both
                await _settingsService.SavePermissionPolicyAsync(_policy);

                _logger.LogInformation("Added tool to trusted list: {ToolId}", toolId);
            }
        }
        finally
        {
            _policyLock.Release();
        }
    }

    /// <inheritdoc />
    public async Task UntrustToolAsync(string toolId)
    {
        await _policyLock.WaitAsync();
        try
        {
            if (_policy.TrustedTools.Remove(toolId))
            {
                await _settingsService.SavePermissionPolicyAsync(_policy);

                _logger.LogInformation("Removed tool from trusted list: {ToolId}", toolId);
            }
        }
        finally
        {
            _policyLock.Release();
        }
    }

    /// <inheritdoc />
    public async Task BlockToolAsync(string toolId)
    {
        await _policyLock.WaitAsync();
        try
        {
            if (_policy.BlockedTools.Add(toolId))
            {
                _policy.TrustedTools.Remove(toolId); // Ensure not in both
                await _settingsService.SavePermissionPolicyAsync(_policy);

                _logger.LogInformation("Added tool to blocked list: {ToolId}", toolId);
            }
        }
        finally
        {
            _policyLock.Release();
        }
    }

    /// <inheritdoc />
    public async Task UnblockToolAsync(string toolId)
    {
        await _policyLock.WaitAsync();
        try
        {
            if (_policy.BlockedTools.Remove(toolId))
            {
                await _settingsService.SavePermissionPolicyAsync(_policy);

                _logger.LogInformation("Removed tool from blocked list: {ToolId}", toolId);
            }
        }
        finally
        {
            _policyLock.Release();
        }
    }

    #endregion

    #region Audit & Monitoring

    /// <inheritdoc />
    public async Task RecordAuditAsync(AuditLogEntry entry)
    {
        ArgumentNullException.ThrowIfNull(entry);

        // Apply audit filtering based on policy
        if (!_policy.AuditAllExecutions &&
            entry.Decision == AuditDecision.Allowed)
        {
            return;
        }

        if (!_policy.AuditDeniedCalls &&
            entry.Decision is AuditDecision.Denied or AuditDecision.Blocked)
        {
            return;
        }

        await _auditRepository.AddAsync(entry);
        _rateLimiter.RecordCall();

        _logger.LogTrace(
            "Recorded audit entry: {ToolId} - {Decision}",
            entry.ToolId, entry.Decision);
    }

    /// <inheritdoc />
    public async Task<IReadOnlyList<AuditLogEntry>> GetAuditLogAsync(
        AuditLogQuery? query = null,
        CancellationToken ct = default)
    {
        return await _auditRepository.QueryAsync(query ?? new AuditLogQuery(), ct);
    }

    /// <inheritdoc />
    public async Task<int> GetAuditLogCountAsync(AuditLogQuery? query = null)
    {
        return await _auditRepository.CountAsync(query ?? new AuditLogQuery());
    }

    /// <inheritdoc />
    public RateLimitStatus GetRateLimitStatus() => _rateLimiter.GetStatus();

    /// <inheritdoc />
    public void ResetRateLimits()
    {
        _rateLimiter.Reset();
        _logger.LogInformation("Rate limits reset");
    }

    #endregion

    #region Helper Methods

    /// <summary>
    /// Determine what changed between two policies.
    /// </summary>
    private static PolicyChangeType DetermineChangeType(
        PermissionPolicy oldPolicy,
        PermissionPolicy newPolicy)
    {
        var changes = PolicyChangeType.None;

        if (oldPolicy.Mode != newPolicy.Mode)
            changes |= PolicyChangeType.Mode;

        if (oldPolicy.ApprovalThreshold != newPolicy.ApprovalThreshold)
            changes |= PolicyChangeType.Threshold;

        if (!oldPolicy.ToolOverrides.Keys.SequenceEqual(newPolicy.ToolOverrides.Keys))
            changes |= PolicyChangeType.ToolOverrides;

        if (!oldPolicy.BlockedTools.SetEquals(newPolicy.BlockedTools))
            changes |= PolicyChangeType.BlockedTools;

        if (!oldPolicy.TrustedTools.SetEquals(newPolicy.TrustedTools))
            changes |= PolicyChangeType.TrustedTools;

        if (oldPolicy.BlockedCommandPatterns.Count != newPolicy.BlockedCommandPatterns.Count)
            changes |= PolicyChangeType.BlockedPatterns;

        if (oldPolicy.ProtectedPaths.Count != newPolicy.ProtectedPaths.Count)
            changes |= PolicyChangeType.ProtectedPaths;

        if (oldPolicy.RateLimitPerMinute != newPolicy.RateLimitPerMinute ||
            oldPolicy.RateLimitPerHour != newPolicy.RateLimitPerHour)
            changes |= PolicyChangeType.RateLimits;

        if (oldPolicy.AuditAllExecutions != newPolicy.AuditAllExecutions ||
            oldPolicy.AuditDeniedCalls != newPolicy.AuditDeniedCalls ||
            oldPolicy.AuditRetentionDays != newPolicy.AuditRetentionDays)
            changes |= PolicyChangeType.AuditSettings;

        if (oldPolicy.ShowParametersInApproval != newPolicy.ShowParametersInApproval ||
            oldPolicy.AllowParameterEditing != newPolicy.AllowParameterEditing)
            changes |= PolicyChangeType.UISettings;

        return changes == PolicyChangeType.None ? PolicyChangeType.Other : changes;
    }

    #endregion

    #region IDisposable

    /// <inheritdoc />
    public void Dispose()
    {
        // Cancel any pending approvals
        foreach (var pending in _pendingApprovals.Values)
        {
            pending.DecisionTask.TrySetCanceled();
        }
        _pendingApprovals.Clear();

        _policyLock.Dispose();

        _logger.LogDebug("PermissionManager disposed");
    }

    #endregion
}
```

### 2. IAuditLogRepository.cs

**Location**: `src/SeniorIntern.Core/Interfaces/IAuditLogRepository.cs`

```csharp
namespace SeniorIntern.Core.Interfaces;

using SeniorIntern.Core.Models.Permissions;

/// <summary>
/// Repository for audit log persistence.
/// </summary>
public interface IAuditLogRepository
{
    /// <summary>
    /// Add an entry to the audit log.
    /// </summary>
    Task AddAsync(AuditLogEntry entry);

    /// <summary>
    /// Query audit log entries.
    /// </summary>
    Task<IReadOnlyList<AuditLogEntry>> QueryAsync(
        AuditLogQuery query,
        CancellationToken ct = default);

    /// <summary>
    /// Count audit log entries matching query.
    /// </summary>
    Task<int> CountAsync(AuditLogQuery query);

    /// <summary>
    /// Delete entries older than the specified date.
    /// </summary>
    Task<int> DeleteOlderThanAsync(DateTime cutoff);

    /// <summary>
    /// Get the most recent entries.
    /// </summary>
    Task<IReadOnlyList<AuditLogEntry>> GetRecentAsync(int count);
}
```

### 3. ISettingsService Extensions

**Location**: To be added to `src/SeniorIntern.Core/Interfaces/ISettingsService.cs`

```csharp
// Add to existing ISettingsService interface

/// <summary>
/// Get the current permission policy.
/// </summary>
PermissionPolicy? GetPermissionPolicy();

/// <summary>
/// Save the permission policy.
/// </summary>
Task SavePermissionPolicyAsync(PermissionPolicy policy);
```

### 4. ServiceCollectionExtensions (Permission Services)

**Location**: To be added to `src/SeniorIntern.Services/ServiceCollectionExtensions.cs`

```csharp
/// <summary>
/// Register permission management services.
/// </summary>
public static IServiceCollection AddPermissionServices(
    this IServiceCollection services)
{
    // Core services
    services.AddSingleton<IRiskClassifier, RiskClassifier>();
    services.AddSingleton<IRateLimiter, RateLimiter>();
    services.AddSingleton<ISessionPermissionCache, SessionPermissionCache>();

    // Main manager
    services.AddSingleton<IPermissionManager, PermissionManager>();

    // Configure default policy via options
    services.AddOptions<PermissionPolicy>()
        .Configure<ISettingsService>((policy, settings) =>
        {
            var saved = settings.GetPermissionPolicy();
            if (saved != null)
            {
                policy.Mode = saved.Mode;
                policy.ApprovalThreshold = saved.ApprovalThreshold;
                // Copy other properties...
            }
        });

    return services;
}
```

---

## File Summary

| File | Location | Purpose | Lines |
|------|----------|---------|-------|
| `PermissionManager.cs` | `Services/Permissions/` | Main implementation | ~550 |
| `IAuditLogRepository.cs` | `Core/Interfaces/` | Audit repository interface | ~35 |
| (Modified) `ISettingsService.cs` | `Core/Interfaces/` | Add policy methods | +10 |
| (Modified) `ServiceCollectionExtensions.cs` | `Services/` | DI registration | +30 |

---

## Unit Test Plan

| Test | Description |
|------|-------------|
| `CheckPermission_RateLimitExceeded_ReturnsRateLimited` | Rate limit |
| `CheckPermission_Disabled_ReturnsBlocked` | Policy mode |
| `CheckPermission_BlockedTool_ReturnsBlocked` | Classification |
| `CheckPermission_TrustedTool_ReturnsAllowed` | Trusted |
| `CheckPermission_CachedApproval_ReturnsFromCache` | Session cache |
| `CheckPermission_PersistentOverride_ReturnsAllowed` | Override |
| `CheckPermission_AutoApprove_AllowsAll` | Policy mode |
| `CheckPermission_AlwaysAsk_NeedsApproval` | Policy mode |
| `CheckPermission_AskForRisky_AboveThreshold_NeedsApproval` | Threshold |
| `CheckPermission_AskForRisky_BelowThreshold_Allowed` | Threshold |
| `RequestApproval_UserApproves_ReturnsApproved` | Approval flow |
| `RequestApproval_Timeout_ReturnsTimedOut` | Timeout |
| `RequestApproval_Cancelled_ReturnsCancelled` | Cancellation |
| `SubmitDecision_CompletesWaitingTask` | Submit |
| `RememberDecision_ForSession_CachesDecision` | Session remember |
| `RememberDecision_Always_PersistsToSettings` | Persistent remember |
| `ClearRememberedDecisions_ClearsBothCaches` | Clear |
| `UpdatePolicy_SavesAndNotifies` | Policy update |
| `TrustTool_AddsToTrustedList` | Trust |
| `BlockTool_AddsToBlockedList` | Block |
| `RecordAudit_RespectsFilterSettings` | Audit filtering |

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | Permission checking integrates all components |
| AC-2 | Session cache is checked before policy |
| AC-3 | Rate limiting prevents excessive calls |
| AC-4 | Approval events are raised for UI |
| AC-5 | Decisions are persisted correctly |
| AC-6 | Policy updates are saved and notify subscribers |

---

## Changelog Entry

```markdown
## v0.6.4e - PermissionManager Implementation

### Added
- `PermissionManager` implementing `IPermissionManager`
  - Integrates RiskClassifier, RateLimiter, SessionCache
  - 8-step CheckPermissionAsync flow
  - Rate limit → Policy mode → Classification → Blocked →
    Trusted → Session cache → Persistent → Policy evaluation
- Approval workflow with event-based UI integration
  - RequestApprovalAsync with timeout support
  - SubmitDecision for UI completion
  - CancelApproval for cancellation
  - Pending approvals tracking
- Decision memory management
  - RememberDecisionAsync (session + persistent)
  - ClearRememberedDecisionsAsync
  - GetRememberedDecisions
- Policy management operations
  - UpdatePolicyAsync with change detection
  - SetToolOverrideAsync, RemoveToolOverrideAsync
  - TrustToolAsync, UntrustToolAsync
  - BlockToolAsync, UnblockToolAsync
- Audit & monitoring
  - RecordAuditAsync with filtering
  - GetAuditLogAsync, GetAuditLogCountAsync
  - GetRateLimitStatus, ResetRateLimits
- Event notifications
  - ApprovalRequested, PolicyChanged, DecisionRemembered
- `IAuditLogRepository` interface for persistence
- ISettingsService extensions for policy persistence
- DI registration via AddPermissionServices()
```

---

## Timeline Estimate

| Version | Estimated Effort |
|---------|------------------|
| v0.6.4e | 1 day |
