# Design Specification: AIntern v0.6.5 "Agent Loop & Polish"

## Overview

This document provides a comprehensive design specification for v0.6.5 of The Senior Intern project. This version finalizes the agent system with multi-step execution, tool chaining, comprehensive settings UI, activity visualization, and thorough testing.

### Objectives
- Implement agent activity visualization panel
- Create comprehensive agent settings UI
- Build audit log viewer for transparency
- Integrate keyboard shortcuts for efficient interaction
- Update ChatViewModel for full agent mode support
- Implement end-to-end testing infrastructure

### Prerequisites
- v0.6.4 (Safety & Approval) completed
- Permission system fully functional
- All built-in tools operational
- Semantic Kernel integration complete

---

## Sub-version Breakdown

| Version | Focus | Files to Create | Files to Modify |
|---------|-------|-----------------|-----------------|
| v0.6.5a | Agent Activity Models | 4 | 0 |
| v0.6.5b | Agent Activity Panel XAML | 3 | 0 |
| v0.6.5c | Agent Activity ViewModel | 2 | 0 |
| v0.6.5d | Agent Settings Panel XAML | 3 | 0 |
| v0.6.5e | Agent Settings ViewModel | 2 | 0 |
| v0.6.5f | Audit Log Viewer | 4 | 0 |
| v0.6.5g | Keyboard Shortcuts System | 3 | 1 |
| v0.6.5h | ChatViewModel Agent Integration | 2 | 2 |
| v0.6.5i | AppSettings Agent Configuration | 1 | 2 |
| v0.6.5j | End-to-End Testing | 8 | 0 |

---

## v0.6.5a: Agent Activity Models

### Objective
Define models for tracking and displaying agent activity during multi-step execution.

### File: `src/SeniorIntern.Core/Models/AgentActivityItem.cs`

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Represents a single activity item during agent execution.
/// </summary>
public sealed class AgentActivityItem
{
    /// <summary>
    /// Unique identifier for the activity.
    /// </summary>
    public Guid Id { get; init; } = Guid.NewGuid();

    /// <summary>
    /// Timestamp when the activity occurred.
    /// </summary>
    public DateTime Timestamp { get; init; } = DateTime.Now;

    /// <summary>
    /// Type of activity (thinking, tool execution, approval, etc.).
    /// </summary>
    public ActivityType Type { get; init; }

    /// <summary>
    /// Human-readable message describing the activity.
    /// </summary>
    public string Message { get; init; } = string.Empty;

    /// <summary>
    /// Optional detailed information about the activity.
    /// </summary>
    public string? Details { get; init; }

    /// <summary>
    /// Associated tool ID, if applicable.
    /// </summary>
    public string? ToolId { get; init; }

    /// <summary>
    /// Duration of the activity, if completed.
    /// </summary>
    public TimeSpan? Duration { get; init; }

    /// <summary>
    /// Whether the activity was successful (for completable activities).
    /// </summary>
    public bool? Success { get; init; }

    /// <summary>
    /// Icon resource key for UI display.
    /// </summary>
    public string Icon => Type switch
    {
        ActivityType.Thinking => "ThinkingIcon",
        ActivityType.Tool => "ToolIcon",
        ActivityType.Approval => "ApprovalIcon",
        ActivityType.Success => "SuccessIcon",
        ActivityType.Error => "ErrorIcon",
        ActivityType.Warning => "WarningIcon",
        ActivityType.Info => "InfoIcon",
        ActivityType.Cancelled => "CancelledIcon",
        _ => "DefaultIcon"
    };
}
```

### File: `src/SeniorIntern.Core/Models/ActivityType.cs`

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Types of agent activities that can occur during execution.
/// </summary>
public enum ActivityType
{
    /// <summary>
    /// Agent is thinking/generating response.
    /// </summary>
    Thinking,

    /// <summary>
    /// Tool is being executed.
    /// </summary>
    Tool,

    /// <summary>
    /// Waiting for user approval.
    /// </summary>
    Approval,

    /// <summary>
    /// Activity completed successfully.
    /// </summary>
    Success,

    /// <summary>
    /// Activity failed with an error.
    /// </summary>
    Error,

    /// <summary>
    /// Warning or non-critical issue.
    /// </summary>
    Warning,

    /// <summary>
    /// Informational message.
    /// </summary>
    Info,

    /// <summary>
    /// Activity was cancelled by user.
    /// </summary>
    Cancelled
}
```

### File: `src/SeniorIntern.Core/Models/AgentExecutionSummary.cs`

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Summary of an agent execution session.
/// </summary>
public sealed class AgentExecutionSummary
{
    /// <summary>
    /// Unique identifier for the execution session.
    /// </summary>
    public Guid SessionId { get; init; } = Guid.NewGuid();

    /// <summary>
    /// Associated conversation ID.
    /// </summary>
    public Guid ConversationId { get; init; }

    /// <summary>
    /// Time when execution started.
    /// </summary>
    public DateTime StartTime { get; init; } = DateTime.UtcNow;

    /// <summary>
    /// Time when execution completed.
    /// </summary>
    public DateTime? EndTime { get; set; }

    /// <summary>
    /// Total duration of the execution.
    /// </summary>
    public TimeSpan Duration => EndTime.HasValue
        ? EndTime.Value - StartTime
        : DateTime.UtcNow - StartTime;

    /// <summary>
    /// Number of iterations (LLM calls) made.
    /// </summary>
    public int IterationCount { get; set; }

    /// <summary>
    /// Number of tool calls executed.
    /// </summary>
    public int ToolCallsExecuted { get; set; }

    /// <summary>
    /// Number of tool calls that succeeded.
    /// </summary>
    public int ToolCallsSucceeded { get; set; }

    /// <summary>
    /// Number of tool calls that failed.
    /// </summary>
    public int ToolCallsFailed { get; set; }

    /// <summary>
    /// Number of tool calls approved by user.
    /// </summary>
    public int ToolCallsApproved { get; set; }

    /// <summary>
    /// Number of tool calls denied by user.
    /// </summary>
    public int ToolCallsDenied { get; set; }

    /// <summary>
    /// Number of tool calls auto-approved.
    /// </summary>
    public int ToolCallsAutoApproved { get; set; }

    /// <summary>
    /// How the execution ended.
    /// </summary>
    public ExecutionEndReason EndReason { get; set; } = ExecutionEndReason.InProgress;

    /// <summary>
    /// Error message if execution failed.
    /// </summary>
    public string? ErrorMessage { get; set; }

    /// <summary>
    /// Total tokens used during execution.
    /// </summary>
    public int TotalTokensUsed { get; set; }
}

/// <summary>
/// Reasons why an agent execution ended.
/// </summary>
public enum ExecutionEndReason
{
    /// <summary>
    /// Execution is still in progress.
    /// </summary>
    InProgress,

    /// <summary>
    /// Agent completed the task successfully.
    /// </summary>
    Completed,

    /// <summary>
    /// User cancelled the execution.
    /// </summary>
    UserCancelled,

    /// <summary>
    /// Maximum iterations reached.
    /// </summary>
    MaxIterationsReached,

    /// <summary>
    /// An error occurred during execution.
    /// </summary>
    Error,

    /// <summary>
    /// User denied a required tool approval.
    /// </summary>
    ToolDenied,

    /// <summary>
    /// Rate limit exceeded.
    /// </summary>
    RateLimited,

    /// <summary>
    /// Execution timed out.
    /// </summary>
    Timeout
}
```

### File: `src/SeniorIntern.Core/Models/ToolResultDisplay.cs`

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Display model for tool results shown in the chat.
/// </summary>
public sealed class ToolResultDisplay
{
    /// <summary>
    /// Name of the tool that was executed.
    /// </summary>
    public string ToolName { get; init; } = string.Empty;

    /// <summary>
    /// Unique identifier for this tool execution.
    /// </summary>
    public string ExecutionId { get; init; } = string.Empty;

    /// <summary>
    /// Whether the tool execution succeeded.
    /// </summary>
    public bool Success { get; init; }

    /// <summary>
    /// Short summary of the result.
    /// </summary>
    public string Summary { get; init; } = string.Empty;

    /// <summary>
    /// Full result content for expansion.
    /// </summary>
    public string? FullContent { get; init; }

    /// <summary>
    /// Duration of the tool execution.
    /// </summary>
    public TimeSpan Duration { get; init; }

    /// <summary>
    /// Whether the content is expandable.
    /// </summary>
    public bool IsExpandable => !string.IsNullOrEmpty(FullContent);

    /// <summary>
    /// Risk level of the executed tool.
    /// </summary>
    public RiskLevel RiskLevel { get; init; }

    /// <summary>
    /// How the tool was approved.
    /// </summary>
    public ApprovalMethod ApprovalMethod { get; init; }
}

/// <summary>
/// Methods by which a tool can be approved.
/// </summary>
public enum ApprovalMethod
{
    /// <summary>
    /// Auto-approved based on policy.
    /// </summary>
    AutoApproved,

    /// <summary>
    /// User approved via dialog.
    /// </summary>
    UserApproved,

    /// <summary>
    /// Approved via remembered session decision.
    /// </summary>
    SessionRemembered,

    /// <summary>
    /// Approved via remembered permanent decision.
    /// </summary>
    PermanentlyAllowed
}
```

### Acceptance Criteria (v0.6.5a)
- [ ] `AgentActivityItem` class created with all properties
- [ ] `ActivityType` enum covers all activity types
- [ ] `AgentExecutionSummary` tracks comprehensive execution statistics
- [ ] `ToolResultDisplay` model supports chat display
- [ ] All models are immutable where appropriate
- [ ] Documentation comments complete

---

## v0.6.5b: Agent Activity Panel XAML

### Objective
Create the visual UI component for displaying agent activity during execution.

### File: `src/SeniorIntern.Desktop/Views/AgentActivityPanel.axaml`

```xml
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             xmlns:vm="using:SeniorIntern.Desktop.ViewModels"
             xmlns:converters="using:SeniorIntern.Desktop.Converters"
             mc:Ignorable="d"
             x:Class="SeniorIntern.Desktop.Views.AgentActivityPanel"
             x:DataType="vm:AgentActivityViewModel">

    <UserControl.Resources>
        <converters:EnumToBoolConverter x:Key="EnumConverter" />
        <converters:ActivityTypeToIconConverter x:Key="ActivityIconConverter" />
        <converters:ActivityTypeToBrushConverter x:Key="ActivityBrushConverter" />
    </UserControl.Resources>

    <UserControl.Styles>
        <Style Selector="Border.agent-activity">
            <Setter Property="Background" Value="{DynamicResource SurfaceBackground}" />
            <Setter Property="BorderBrush" Value="{DynamicResource BorderBrush}" />
            <Setter Property="BorderThickness" Value="0,1,0,0" />
            <Setter Property="CornerRadius" Value="0" />
        </Style>

        <Style Selector="Border.activity-icon">
            <Setter Property="Width" Value="20" />
            <Setter Property="Height" Value="20" />
            <Setter Property="CornerRadius" Value="10" />
            <Setter Property="Padding" Value="4" />
        </Style>

        <Style Selector="Border.activity-icon.thinking">
            <Setter Property="Background" Value="{DynamicResource AccentBrush}" />
        </Style>

        <Style Selector="Border.activity-icon.tool">
            <Setter Property="Background" Value="{DynamicResource InfoBrush}" />
        </Style>

        <Style Selector="Border.activity-icon.approval">
            <Setter Property="Background" Value="{DynamicResource WarningBrush}" />
        </Style>

        <Style Selector="Border.activity-icon.success">
            <Setter Property="Background" Value="{DynamicResource SuccessBrush}" />
        </Style>

        <Style Selector="Border.activity-icon.error">
            <Setter Property="Background" Value="{DynamicResource ErrorBrush}" />
        </Style>

        <Style Selector="Border.activity-icon.warning">
            <Setter Property="Background" Value="{DynamicResource WarningBrush}" />
        </Style>

        <Style Selector="Border.activity-icon.cancelled">
            <Setter Property="Background" Value="{DynamicResource MutedBrush}" />
        </Style>
    </UserControl.Styles>

    <Border Classes="agent-activity" IsVisible="{Binding IsAgentActive}">
        <Grid RowDefinitions="Auto, Auto, *">

            <!-- Header with State and Controls -->
            <Grid ColumnDefinitions="Auto, *, Auto" Margin="12,8">
                <StackPanel Orientation="Horizontal" Spacing="8">
                    <!-- Activity Indicator -->
                    <ProgressRing Width="16" Height="16"
                                  IsActive="{Binding IsProcessing}"
                                  IsVisible="{Binding IsProcessing}" />

                    <!-- Paused Indicator -->
                    <PathIcon Data="{StaticResource PauseIcon}"
                              Width="16" Height="16"
                              IsVisible="{Binding IsPaused}"
                              Foreground="{DynamicResource WarningBrush}" />

                    <!-- State Text -->
                    <TextBlock Text="{Binding AgentStateText}"
                               FontWeight="SemiBold"
                               VerticalAlignment="Center" />
                </StackPanel>

                <!-- Iteration Counter -->
                <StackPanel Grid.Column="1"
                            Orientation="Horizontal"
                            HorizontalAlignment="Center"
                            Spacing="4">
                    <TextBlock Text="Iteration"
                               Foreground="{DynamicResource TextMuted}"
                               FontSize="12" />
                    <TextBlock Text="{Binding CurrentIteration}"
                               FontWeight="SemiBold"
                               FontSize="12" />
                    <TextBlock Text="/"
                               Foreground="{DynamicResource TextMuted}"
                               FontSize="12" />
                    <TextBlock Text="{Binding MaxIterations}"
                               Foreground="{DynamicResource TextMuted}"
                               FontSize="12" />
                </StackPanel>

                <!-- Cancel Button -->
                <Button Grid.Column="2"
                        Content="Cancel"
                        Command="{Binding CancelCommand}"
                        Classes="secondary"
                        ToolTip.Tip="Cancel agent execution (Escape)"
                        IsEnabled="{Binding CanCancel}" />
            </Grid>

            <!-- Progress Bar -->
            <Grid Grid.Row="1">
                <ProgressBar Value="{Binding ProgressPercent}"
                             IsIndeterminate="{Binding IsIndeterminate}"
                             Height="3"
                             Minimum="0"
                             Maximum="100" />
            </Grid>

            <!-- Activity Log -->
            <ScrollViewer Grid.Row="2"
                          MaxHeight="200"
                          VerticalScrollBarVisibility="Auto"
                          HorizontalScrollBarVisibility="Disabled">
                <ItemsControl ItemsSource="{Binding Activities}">
                    <ItemsControl.ItemTemplate>
                        <DataTemplate>
                            <Grid ColumnDefinitions="60, Auto, *" Margin="12,4">
                                <!-- Timestamp -->
                                <TextBlock Text="{Binding Timestamp, StringFormat='{}{0:HH:mm:ss}'}"
                                           Foreground="{DynamicResource TextMuted}"
                                           FontSize="11"
                                           FontFamily="{StaticResource MonoFont}"
                                           VerticalAlignment="Center" />

                                <!-- Activity Icon -->
                                <Border Grid.Column="1"
                                        Classes="activity-icon"
                                        Classes.thinking="{Binding Type, Converter={StaticResource EnumConverter}, ConverterParameter=Thinking}"
                                        Classes.tool="{Binding Type, Converter={StaticResource EnumConverter}, ConverterParameter=Tool}"
                                        Classes.approval="{Binding Type, Converter={StaticResource EnumConverter}, ConverterParameter=Approval}"
                                        Classes.success="{Binding Type, Converter={StaticResource EnumConverter}, ConverterParameter=Success}"
                                        Classes.error="{Binding Type, Converter={StaticResource EnumConverter}, ConverterParameter=Error}"
                                        Classes.warning="{Binding Type, Converter={StaticResource EnumConverter}, ConverterParameter=Warning}"
                                        Classes.cancelled="{Binding Type, Converter={StaticResource EnumConverter}, ConverterParameter=Cancelled}"
                                        Margin="8,0">
                                    <PathIcon Data="{Binding Type, Converter={StaticResource ActivityIconConverter}}"
                                              Width="12" Height="12"
                                              Foreground="White" />
                                </Border>

                                <!-- Message -->
                                <StackPanel Grid.Column="2" Orientation="Horizontal" Spacing="8">
                                    <TextBlock Text="{Binding Message}"
                                               TextTrimming="CharacterEllipsis"
                                               VerticalAlignment="Center"
                                               ToolTip.Tip="{Binding Details}" />

                                    <!-- Duration Badge -->
                                    <Border IsVisible="{Binding Duration, Converter={x:Static ObjectConverters.IsNotNull}}"
                                            Background="{DynamicResource SurfaceBackgroundAlt}"
                                            CornerRadius="4"
                                            Padding="4,2">
                                        <TextBlock Text="{Binding Duration, StringFormat='{}{0:F1}s'}"
                                                   FontSize="10"
                                                   Foreground="{DynamicResource TextMuted}" />
                                    </Border>
                                </StackPanel>
                            </Grid>
                        </DataTemplate>
                    </ItemsControl.ItemTemplate>
                </ItemsControl>
            </ScrollViewer>
        </Grid>
    </Border>
</UserControl>
```

### File: `src/SeniorIntern.Desktop/Views/AgentActivityPanel.axaml.cs`

```csharp
using Avalonia.Controls;

namespace SeniorIntern.Desktop.Views;

/// <summary>
/// Panel displaying agent activity during execution.
/// </summary>
public partial class AgentActivityPanel : UserControl
{
    public AgentActivityPanel()
    {
        InitializeComponent();
    }
}
```

### File: `src/SeniorIntern.Desktop/Converters/ActivityTypeConverters.cs`

```csharp
using System;
using System.Globalization;
using Avalonia.Data.Converters;
using Avalonia.Media;
using SeniorIntern.Core.Models;

namespace SeniorIntern.Desktop.Converters;

/// <summary>
/// Converts ActivityType to corresponding icon geometry.
/// </summary>
public class ActivityTypeToIconConverter : IValueConverter
{
    public object? Convert(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        if (value is not ActivityType type)
            return null;

        // Return geometry key names that reference app resources
        return type switch
        {
            ActivityType.Thinking => "ThinkingGeometry",
            ActivityType.Tool => "ToolGeometry",
            ActivityType.Approval => "QuestionGeometry",
            ActivityType.Success => "CheckGeometry",
            ActivityType.Error => "ErrorGeometry",
            ActivityType.Warning => "WarningGeometry",
            ActivityType.Info => "InfoGeometry",
            ActivityType.Cancelled => "CancelGeometry",
            _ => "DefaultGeometry"
        };
    }

    public object? ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        throw new NotImplementedException();
    }
}

/// <summary>
/// Converts ActivityType to corresponding brush for styling.
/// </summary>
public class ActivityTypeToBrushConverter : IValueConverter
{
    public object? Convert(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        if (value is not ActivityType type)
            return Brushes.Gray;

        return type switch
        {
            ActivityType.Thinking => new SolidColorBrush(Color.Parse("#3B82F6")),   // Blue
            ActivityType.Tool => new SolidColorBrush(Color.Parse("#8B5CF6")),       // Purple
            ActivityType.Approval => new SolidColorBrush(Color.Parse("#F59E0B")),   // Amber
            ActivityType.Success => new SolidColorBrush(Color.Parse("#10B981")),    // Green
            ActivityType.Error => new SolidColorBrush(Color.Parse("#EF4444")),      // Red
            ActivityType.Warning => new SolidColorBrush(Color.Parse("#F59E0B")),    // Amber
            ActivityType.Info => new SolidColorBrush(Color.Parse("#6B7280")),       // Gray
            ActivityType.Cancelled => new SolidColorBrush(Color.Parse("#6B7280")),  // Gray
            _ => Brushes.Gray
        };
    }

    public object? ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        throw new NotImplementedException();
    }
}
```

### Acceptance Criteria (v0.6.5b)
- [ ] Agent activity panel XAML created with all elements
- [ ] Progress ring shows during processing
- [ ] Iteration counter displays current/max iterations
- [ ] Cancel button functional with tooltip
- [ ] Progress bar shows determinate/indeterminate progress
- [ ] Activity log scrolls and displays items correctly
- [ ] Activity icons colored by type
- [ ] Duration badges display when available
- [ ] Converters handle all ActivityType values

---

## v0.6.5c: Agent Activity ViewModel

### Objective
Implement the ViewModel for the agent activity panel with full state management.

### File: `src/SeniorIntern.Desktop/ViewModels/AgentActivityViewModel.cs`

```csharp
using System;
using System.Collections.ObjectModel;
using System.Threading;
using System.Threading.Tasks;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;

namespace SeniorIntern.Desktop.ViewModels;

/// <summary>
/// ViewModel for the agent activity panel.
/// </summary>
public partial class AgentActivityViewModel : ViewModelBase
{
    private readonly IAgentService _agentService;
    private CancellationTokenSource? _cancellationTokenSource;

    /// <summary>
    /// Whether the agent is currently active.
    /// </summary>
    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(CanCancel))]
    private bool _isAgentActive;

    /// <summary>
    /// Whether the agent is currently processing (thinking or executing).
    /// </summary>
    [ObservableProperty]
    private bool _isProcessing;

    /// <summary>
    /// Whether the agent is paused (waiting for approval).
    /// </summary>
    [ObservableProperty]
    private bool _isPaused;

    /// <summary>
    /// Human-readable text describing the current agent state.
    /// </summary>
    [ObservableProperty]
    private string _agentStateText = "Idle";

    /// <summary>
    /// Current iteration number (1-based).
    /// </summary>
    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(ProgressPercent))]
    private int _currentIteration;

    /// <summary>
    /// Maximum allowed iterations.
    /// </summary>
    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(ProgressPercent))]
    private int _maxIterations = 10;

    /// <summary>
    /// Whether the progress bar should be indeterminate.
    /// </summary>
    [ObservableProperty]
    private bool _isIndeterminate = true;

    /// <summary>
    /// Collection of activity items to display.
    /// </summary>
    [ObservableProperty]
    private ObservableCollection<AgentActivityItem> _activities = new();

    /// <summary>
    /// Current execution summary.
    /// </summary>
    [ObservableProperty]
    private AgentExecutionSummary? _executionSummary;

    /// <summary>
    /// Progress percentage (0-100).
    /// </summary>
    public double ProgressPercent => MaxIterations > 0
        ? (double)CurrentIteration / MaxIterations * 100
        : 0;

    /// <summary>
    /// Whether cancellation is possible.
    /// </summary>
    public bool CanCancel => IsAgentActive && !_cancellationTokenSource?.IsCancellationRequested == true;

    public AgentActivityViewModel(IAgentService agentService)
    {
        _agentService = agentService;
        _agentService.StateChanged += OnAgentStateChanged;
    }

    /// <summary>
    /// Start tracking a new agent execution.
    /// </summary>
    public void StartTracking(Guid conversationId, int maxIterations, CancellationTokenSource cts)
    {
        _cancellationTokenSource = cts;
        MaxIterations = maxIterations;
        CurrentIteration = 0;
        IsAgentActive = true;
        IsProcessing = true;
        IsPaused = false;
        IsIndeterminate = true;
        Activities.Clear();

        ExecutionSummary = new AgentExecutionSummary
        {
            ConversationId = conversationId
        };

        AddActivity(ActivityType.Info, "Agent execution started");
    }

    /// <summary>
    /// Stop tracking and reset state.
    /// </summary>
    public void StopTracking(ExecutionEndReason reason, string? errorMessage = null)
    {
        IsAgentActive = false;
        IsProcessing = false;
        IsPaused = false;

        if (ExecutionSummary is not null)
        {
            ExecutionSummary.EndTime = DateTime.UtcNow;
            ExecutionSummary.EndReason = reason;
            ExecutionSummary.ErrorMessage = errorMessage;
        }

        var endMessage = reason switch
        {
            ExecutionEndReason.Completed => "Agent completed successfully",
            ExecutionEndReason.UserCancelled => "Cancelled by user",
            ExecutionEndReason.MaxIterationsReached => "Maximum iterations reached",
            ExecutionEndReason.Error => $"Error: {errorMessage}",
            ExecutionEndReason.ToolDenied => "Stopped: Tool approval denied",
            ExecutionEndReason.RateLimited => "Rate limit exceeded",
            ExecutionEndReason.Timeout => "Execution timed out",
            _ => "Agent stopped"
        };

        var endType = reason == ExecutionEndReason.Completed
            ? ActivityType.Success
            : reason == ExecutionEndReason.UserCancelled
                ? ActivityType.Cancelled
                : ActivityType.Error;

        AddActivity(endType, endMessage);

        _cancellationTokenSource = null;
    }

    /// <summary>
    /// Add an activity item to the log.
    /// </summary>
    public void AddActivity(ActivityType type, string message, string? details = null, string? toolId = null)
    {
        var activity = new AgentActivityItem
        {
            Type = type,
            Message = message,
            Details = details,
            ToolId = toolId
        };

        // Ensure UI thread
        Avalonia.Threading.Dispatcher.UIThread.Post(() =>
        {
            Activities.Add(activity);

            // Auto-scroll would be handled by the view
        });
    }

    /// <summary>
    /// Update an existing activity with completion info.
    /// </summary>
    public void CompleteActivity(Guid activityId, bool success, TimeSpan duration, string? details = null)
    {
        // Activities are immutable, so we'd need to replace
        // For simplicity, we add a completion activity instead
        AddActivity(
            success ? ActivityType.Success : ActivityType.Error,
            success ? "Completed" : "Failed",
            details
        );
    }

    /// <summary>
    /// Increment the iteration counter.
    /// </summary>
    public void IncrementIteration()
    {
        CurrentIteration++;
        IsIndeterminate = false;

        if (ExecutionSummary is not null)
        {
            ExecutionSummary.IterationCount = CurrentIteration;
        }
    }

    /// <summary>
    /// Record a tool execution.
    /// </summary>
    public void RecordToolExecution(string toolName, bool success, TimeSpan duration)
    {
        if (ExecutionSummary is null) return;

        ExecutionSummary.ToolCallsExecuted++;
        if (success)
            ExecutionSummary.ToolCallsSucceeded++;
        else
            ExecutionSummary.ToolCallsFailed++;
    }

    /// <summary>
    /// Record an approval decision.
    /// </summary>
    public void RecordApproval(bool approved, bool wasAutoApproved)
    {
        if (ExecutionSummary is null) return;

        if (wasAutoApproved)
            ExecutionSummary.ToolCallsAutoApproved++;
        else if (approved)
            ExecutionSummary.ToolCallsApproved++;
        else
            ExecutionSummary.ToolCallsDenied++;
    }

    /// <summary>
    /// Cancel the current agent execution.
    /// </summary>
    [RelayCommand(CanExecute = nameof(CanCancel))]
    private void Cancel()
    {
        _cancellationTokenSource?.Cancel();
        AddActivity(ActivityType.Cancelled, "Cancellation requested");
        AgentStateText = "Cancelling...";
    }

    private void OnAgentStateChanged(object? sender, AgentState newState)
    {
        AgentStateText = newState switch
        {
            AgentState.Idle => "Idle",
            AgentState.Thinking => "Thinking...",
            AgentState.ParsingToolCall => "Parsing tool call...",
            AgentState.WaitingForApproval => "Waiting for approval",
            AgentState.ExecutingTool => "Executing tool...",
            AgentState.ProcessingResult => "Processing result...",
            AgentState.GeneratingResponse => "Generating response...",
            AgentState.Error => "Error",
            AgentState.Completed => "Completed",
            AgentState.Cancelled => "Cancelled",
            _ => "Unknown"
        };

        IsProcessing = newState is AgentState.Thinking
            or AgentState.ParsingToolCall
            or AgentState.ExecutingTool
            or AgentState.ProcessingResult
            or AgentState.GeneratingResponse;

        IsPaused = newState == AgentState.WaitingForApproval;
    }

    /// <summary>
    /// Clean up resources.
    /// </summary>
    public void Dispose()
    {
        _agentService.StateChanged -= OnAgentStateChanged;
        _cancellationTokenSource?.Dispose();
    }
}
```

### File: `src/SeniorIntern.Core/Events/AgentStateChangedEventArgs.cs`

```csharp
using System;

namespace SeniorIntern.Core.Events;

/// <summary>
/// Event args for agent state changes.
/// </summary>
public class AgentStateChangedEventArgs : EventArgs
{
    /// <summary>
    /// Previous state.
    /// </summary>
    public AgentState PreviousState { get; init; }

    /// <summary>
    /// New state.
    /// </summary>
    public AgentState NewState { get; init; }

    /// <summary>
    /// Additional context about the state change.
    /// </summary>
    public string? Context { get; init; }
}
```

### Acceptance Criteria (v0.6.5c)
- [ ] ViewModel tracks agent active state
- [ ] Progress tracking with iteration counter
- [ ] Activity log population via AddActivity
- [ ] Execution summary statistics updated correctly
- [ ] Cancel command functional with proper state
- [ ] Agent state changes reflected in UI text
- [ ] Processing/paused states tracked separately
- [ ] Proper cleanup on dispose

---

## v0.6.5d: Agent Settings Panel XAML

### Objective
Create the comprehensive settings UI for configuring agent behavior.

### File: `src/SeniorIntern.Desktop/Views/AgentSettingsPanel.axaml`

```xml
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             xmlns:vm="using:SeniorIntern.Desktop.ViewModels"
             xmlns:converters="using:SeniorIntern.Desktop.Converters"
             mc:Ignorable="d"
             x:Class="SeniorIntern.Desktop.Views.AgentSettingsPanel"
             x:DataType="vm:AgentSettingsViewModel">

    <UserControl.Resources>
        <converters:EnumToBoolConverter x:Key="EnumConverter" />
        <converters:RiskLevelToTextConverter x:Key="RiskLevelTextConverter" />
    </UserControl.Resources>

    <ScrollViewer VerticalScrollBarVisibility="Auto">
        <StackPanel Spacing="24" Padding="16" MaxWidth="600">

            <!-- Header -->
            <TextBlock Text="Agent Settings"
                       FontSize="20"
                       FontWeight="SemiBold" />

            <!-- Agent Mode Section -->
            <Border Classes="settings-section" Padding="16" CornerRadius="8">
                <StackPanel Spacing="16">
                    <TextBlock Text="Agent Mode"
                               FontWeight="SemiBold"
                               FontSize="14" />

                    <TextBlock Text="Control how the AI agent executes tools and interacts with your system."
                               Foreground="{DynamicResource TextMuted}"
                               TextWrapping="Wrap"
                               FontSize="12" />

                    <StackPanel Spacing="8">
                        <RadioButton GroupName="AgentMode"
                                     IsChecked="{Binding PolicyMode, Converter={StaticResource EnumConverter}, ConverterParameter=Disabled}">
                            <StackPanel>
                                <TextBlock Text="Disabled" FontWeight="SemiBold" />
                                <TextBlock Text="No tool execution - chat only mode"
                                           Foreground="{DynamicResource TextMuted}"
                                           FontSize="11" />
                            </StackPanel>
                        </RadioButton>

                        <RadioButton GroupName="AgentMode"
                                     IsChecked="{Binding PolicyMode, Converter={StaticResource EnumConverter}, ConverterParameter=AlwaysAsk}">
                            <StackPanel>
                                <TextBlock Text="Always Ask" FontWeight="SemiBold" />
                                <TextBlock Text="Require approval for every tool execution"
                                           Foreground="{DynamicResource TextMuted}"
                                           FontSize="11" />
                            </StackPanel>
                        </RadioButton>

                        <RadioButton GroupName="AgentMode"
                                     IsChecked="{Binding PolicyMode, Converter={StaticResource EnumConverter}, ConverterParameter=AskForRisky}">
                            <StackPanel>
                                <StackPanel Orientation="Horizontal" Spacing="8">
                                    <TextBlock Text="Ask for Risky" FontWeight="SemiBold" />
                                    <Border Background="{DynamicResource AccentBrush}"
                                            CornerRadius="4"
                                            Padding="6,2">
                                        <TextBlock Text="Recommended"
                                                   FontSize="10"
                                                   Foreground="White" />
                                    </Border>
                                </StackPanel>
                                <TextBlock Text="Auto-approve safe operations, ask for risky ones"
                                           Foreground="{DynamicResource TextMuted}"
                                           FontSize="11" />
                            </StackPanel>
                        </RadioButton>

                        <RadioButton GroupName="AgentMode"
                                     IsChecked="{Binding PolicyMode, Converter={StaticResource EnumConverter}, ConverterParameter=AutoApprove}">
                            <StackPanel>
                                <StackPanel Orientation="Horizontal" Spacing="8">
                                    <TextBlock Text="Auto-Approve" FontWeight="SemiBold" />
                                    <Border Background="{DynamicResource ErrorBrush}"
                                            CornerRadius="4"
                                            Padding="6,2">
                                        <TextBlock Text="Dangerous"
                                                   FontSize="10"
                                                   Foreground="White" />
                                    </Border>
                                </StackPanel>
                                <TextBlock Text="No confirmations - use with caution!"
                                           Foreground="{DynamicResource ErrorBrush}"
                                           FontSize="11" />
                            </StackPanel>
                        </RadioButton>
                    </StackPanel>
                </StackPanel>
            </Border>

            <!-- Risk Threshold Section -->
            <Border Classes="settings-section"
                    Padding="16"
                    CornerRadius="8"
                    IsVisible="{Binding IsRiskThresholdVisible}">
                <StackPanel Spacing="16">
                    <TextBlock Text="Approval Threshold"
                               FontWeight="SemiBold"
                               FontSize="14" />

                    <TextBlock Text="Tools with this risk level or higher will require your approval."
                               Foreground="{DynamicResource TextMuted}"
                               TextWrapping="Wrap"
                               FontSize="12" />

                    <Grid ColumnDefinitions="*, 80">
                        <Slider Minimum="0" Maximum="4"
                                Value="{Binding RiskThresholdValue}"
                                TickFrequency="1"
                                IsSnapToTickEnabled="True"
                                TickPlacement="BottomRight" />

                        <Border Grid.Column="1"
                                Background="{Binding RiskThresholdBrush}"
                                CornerRadius="4"
                                Padding="8,4"
                                HorizontalAlignment="Right">
                            <TextBlock Text="{Binding RiskThresholdText}"
                                       Foreground="White"
                                       FontWeight="SemiBold"
                                       FontSize="12" />
                        </Border>
                    </Grid>

                    <!-- Risk Level Legend -->
                    <ItemsControl ItemsSource="{Binding RiskLevelDescriptions}">
                        <ItemsControl.ItemsPanel>
                            <ItemsPanelTemplate>
                                <StackPanel Spacing="4" />
                            </ItemsPanelTemplate>
                        </ItemsControl.ItemsPanel>
                        <ItemsControl.ItemTemplate>
                            <DataTemplate>
                                <Grid ColumnDefinitions="Auto, Auto, *">
                                    <Ellipse Width="10" Height="10"
                                             Fill="{Binding Brush}"
                                             Margin="0,0,8,0" />
                                    <TextBlock Grid.Column="1"
                                               Text="{Binding Name}"
                                               Width="80"
                                               FontWeight="SemiBold"
                                               FontSize="11" />
                                    <TextBlock Grid.Column="2"
                                               Text="{Binding Description}"
                                               Foreground="{DynamicResource TextMuted}"
                                               FontSize="11" />
                                </Grid>
                            </DataTemplate>
                        </ItemsControl.ItemTemplate>
                    </ItemsControl>
                </StackPanel>
            </Border>

            <!-- Tool Permissions Section -->
            <Border Classes="settings-section" Padding="16" CornerRadius="8">
                <StackPanel Spacing="16">
                    <Grid ColumnDefinitions="*, Auto">
                        <TextBlock Text="Tool Permissions"
                                   FontWeight="SemiBold"
                                   FontSize="14" />
                        <Button Grid.Column="1"
                                Content="Reset All"
                                Command="{Binding ResetToolPermissionsCommand}"
                                Classes="link-button"
                                FontSize="12" />
                    </Grid>

                    <TextBlock Text="Enable or disable specific tools, and override their approval behavior."
                               Foreground="{DynamicResource TextMuted}"
                               TextWrapping="Wrap"
                               FontSize="12" />

                    <TextBox Watermark="Search tools..."
                             Text="{Binding ToolSearchText}"
                             Classes="search-box" />

                    <ListBox ItemsSource="{Binding FilteredTools}"
                             MaxHeight="300"
                             SelectionMode="Single">
                        <ListBox.ItemTemplate>
                            <DataTemplate>
                                <Grid ColumnDefinitions="Auto, *, Auto" Margin="4">
                                    <CheckBox IsChecked="{Binding IsEnabled}"
                                              ToolTip.Tip="Enable or disable this tool"
                                              VerticalAlignment="Center" />

                                    <StackPanel Grid.Column="1" Margin="8,0" VerticalAlignment="Center">
                                        <StackPanel Orientation="Horizontal" Spacing="8">
                                            <TextBlock Text="{Binding Name}" FontWeight="SemiBold" />
                                            <Border Background="{Binding RiskLevelBrush}"
                                                    CornerRadius="4"
                                                    Padding="4,1">
                                                <TextBlock Text="{Binding RiskLevelText}"
                                                           FontSize="10"
                                                           Foreground="White" />
                                            </Border>
                                        </StackPanel>
                                        <TextBlock Text="{Binding Description}"
                                                   FontSize="11"
                                                   Foreground="{DynamicResource TextMuted}"
                                                   TextTrimming="CharacterEllipsis"
                                                   MaxLines="1" />
                                    </StackPanel>

                                    <ComboBox Grid.Column="2"
                                              ItemsSource="{Binding OverrideOptions}"
                                              SelectedItem="{Binding OverrideAction}"
                                              Width="130"
                                              VerticalAlignment="Center" />
                                </Grid>
                            </DataTemplate>
                        </ListBox.ItemTemplate>
                    </ListBox>
                </StackPanel>
            </Border>

            <!-- Execution Limits Section -->
            <Border Classes="settings-section" Padding="16" CornerRadius="8">
                <StackPanel Spacing="16">
                    <TextBlock Text="Execution Limits"
                               FontWeight="SemiBold"
                               FontSize="14" />

                    <TextBlock Text="Set limits on agent execution to prevent runaway operations."
                               Foreground="{DynamicResource TextMuted}"
                               TextWrapping="Wrap"
                               FontSize="12" />

                    <!-- Max Iterations -->
                    <Grid ColumnDefinitions="200, *, 50">
                        <TextBlock Text="Max iterations per request"
                                   VerticalAlignment="Center" />
                        <Slider Grid.Column="1"
                                Minimum="1" Maximum="50"
                                Value="{Binding MaxIterations}"
                                TickFrequency="5"
                                IsSnapToTickEnabled="False" />
                        <TextBlock Grid.Column="2"
                                   Text="{Binding MaxIterations}"
                                   TextAlignment="Right"
                                   VerticalAlignment="Center"
                                   FontWeight="SemiBold" />
                    </Grid>

                    <!-- Tool Timeout -->
                    <Grid ColumnDefinitions="200, *, 50">
                        <TextBlock Text="Tool execution timeout (sec)"
                                   VerticalAlignment="Center" />
                        <Slider Grid.Column="1"
                                Minimum="10" Maximum="300"
                                Value="{Binding ToolTimeoutSeconds}"
                                TickFrequency="30"
                                IsSnapToTickEnabled="False" />
                        <TextBlock Grid.Column="2"
                                   Text="{Binding ToolTimeoutSeconds}"
                                   TextAlignment="Right"
                                   VerticalAlignment="Center"
                                   FontWeight="SemiBold" />
                    </Grid>

                    <!-- Rate Limit -->
                    <Grid ColumnDefinitions="200, *, 50">
                        <TextBlock Text="Rate limit (calls/min)"
                                   VerticalAlignment="Center" />
                        <Slider Grid.Column="1"
                                Minimum="5" Maximum="60"
                                Value="{Binding RateLimitPerMinute}"
                                TickFrequency="5"
                                IsSnapToTickEnabled="False" />
                        <TextBlock Grid.Column="2"
                                   Text="{Binding RateLimitPerMinute}"
                                   TextAlignment="Right"
                                   VerticalAlignment="Center"
                                   FontWeight="SemiBold" />
                    </Grid>

                    <!-- Hourly Rate Limit -->
                    <Grid ColumnDefinitions="200, *, 50">
                        <TextBlock Text="Rate limit (calls/hour)"
                                   VerticalAlignment="Center" />
                        <Slider Grid.Column="1"
                                Minimum="50" Maximum="500"
                                Value="{Binding RateLimitPerHour}"
                                TickFrequency="50"
                                IsSnapToTickEnabled="False" />
                        <TextBlock Grid.Column="2"
                                   Text="{Binding RateLimitPerHour}"
                                   TextAlignment="Right"
                                   VerticalAlignment="Center"
                                   FontWeight="SemiBold" />
                    </Grid>
                </StackPanel>
            </Border>

            <!-- Audit Section -->
            <Border Classes="settings-section" Padding="16" CornerRadius="8">
                <StackPanel Spacing="16">
                    <TextBlock Text="Audit & Logging"
                               FontWeight="SemiBold"
                               FontSize="14" />

                    <TextBlock Text="Track all tool executions for security and debugging."
                               Foreground="{DynamicResource TextMuted}"
                               TextWrapping="Wrap"
                               FontSize="12" />

                    <CheckBox Content="Log all tool executions"
                              IsChecked="{Binding AuditAllExecutions}" />

                    <CheckBox Content="Log tool parameters (may contain sensitive data)"
                              IsChecked="{Binding AuditIncludeParameters}"
                              IsEnabled="{Binding AuditAllExecutions}" />

                    <CheckBox Content="Log tool results"
                              IsChecked="{Binding AuditIncludeResults}"
                              IsEnabled="{Binding AuditAllExecutions}" />

                    <StackPanel Orientation="Horizontal" Spacing="8">
                        <Button Content="View Audit Log"
                                Command="{Binding ViewAuditLogCommand}" />
                        <Button Content="Export Log"
                                Command="{Binding ExportAuditLogCommand}"
                                Classes="secondary" />
                        <Button Content="Clear Log"
                                Command="{Binding ClearAuditLogCommand}"
                                Classes="danger" />
                    </StackPanel>

                    <TextBlock Text="{Binding AuditLogStats}"
                               Foreground="{DynamicResource TextMuted}"
                               FontSize="11" />
                </StackPanel>
            </Border>

            <!-- Protected Paths Section -->
            <Border Classes="settings-section" Padding="16" CornerRadius="8">
                <StackPanel Spacing="16">
                    <Grid ColumnDefinitions="*, Auto">
                        <TextBlock Text="Protected Paths"
                                   FontWeight="SemiBold"
                                   FontSize="14" />
                        <Button Grid.Column="1"
                                Content="Add Path"
                                Command="{Binding AddProtectedPathCommand}"
                                Classes="link-button"
                                FontSize="12" />
                    </Grid>

                    <TextBlock Text="Paths that tools cannot access or modify."
                               Foreground="{DynamicResource TextMuted}"
                               TextWrapping="Wrap"
                               FontSize="12" />

                    <ListBox ItemsSource="{Binding ProtectedPaths}"
                             MaxHeight="200"
                             SelectionMode="Single">
                        <ListBox.ItemTemplate>
                            <DataTemplate>
                                <Grid ColumnDefinitions="Auto, *, Auto">
                                    <PathIcon Data="{StaticResource FolderIcon}"
                                              Width="16" Height="16"
                                              Margin="0,0,8,0" />
                                    <TextBlock Grid.Column="1"
                                               Text="{Binding Path}"
                                               FontFamily="{StaticResource MonoFont}"
                                               VerticalAlignment="Center" />
                                    <Button Grid.Column="2"
                                            Command="{Binding $parent[ListBox].((vm:AgentSettingsViewModel)DataContext).RemoveProtectedPathCommand}"
                                            CommandParameter="{Binding}"
                                            Classes="icon-button danger"
                                            ToolTip.Tip="Remove">
                                        <PathIcon Data="{StaticResource DeleteIcon}" Width="14" Height="14" />
                                    </Button>
                                </Grid>
                            </DataTemplate>
                        </ListBox.ItemTemplate>
                    </ListBox>
                </StackPanel>
            </Border>

            <!-- Save Button -->
            <Button Content="Save Settings"
                    Command="{Binding SaveSettingsCommand}"
                    HorizontalAlignment="Right"
                    Classes="accent"
                    Padding="24,8" />

        </StackPanel>
    </ScrollViewer>
</UserControl>
```

### File: `src/SeniorIntern.Desktop/Views/AgentSettingsPanel.axaml.cs`

```csharp
using Avalonia.Controls;

namespace SeniorIntern.Desktop.Views;

/// <summary>
/// Settings panel for agent configuration.
/// </summary>
public partial class AgentSettingsPanel : UserControl
{
    public AgentSettingsPanel()
    {
        InitializeComponent();
    }
}
```

### File: `src/SeniorIntern.Desktop/Models/ToolPermissionItem.cs`

```csharp
using CommunityToolkit.Mvvm.ComponentModel;
using Avalonia.Media;
using SeniorIntern.Core.Models;

namespace SeniorIntern.Desktop.Models;

/// <summary>
/// UI model for tool permission settings.
/// </summary>
public partial class ToolPermissionItem : ObservableObject
{
    /// <summary>
    /// Tool identifier.
    /// </summary>
    public string Id { get; init; } = string.Empty;

    /// <summary>
    /// Display name of the tool.
    /// </summary>
    public string Name { get; init; } = string.Empty;

    /// <summary>
    /// Tool description.
    /// </summary>
    public string Description { get; init; } = string.Empty;

    /// <summary>
    /// Default risk level of the tool.
    /// </summary>
    public RiskLevel RiskLevel { get; init; }

    /// <summary>
    /// Whether the tool is enabled.
    /// </summary>
    [ObservableProperty]
    private bool _isEnabled = true;

    /// <summary>
    /// Override action for this tool.
    /// </summary>
    [ObservableProperty]
    private ToolOverrideAction _overrideAction = ToolOverrideAction.Default;

    /// <summary>
    /// Text representation of risk level.
    /// </summary>
    public string RiskLevelText => RiskLevel.ToString();

    /// <summary>
    /// Brush for risk level display.
    /// </summary>
    public IBrush RiskLevelBrush => RiskLevel switch
    {
        RiskLevel.Safe => new SolidColorBrush(Color.Parse("#10B981")),
        RiskLevel.Low => new SolidColorBrush(Color.Parse("#6B7280")),
        RiskLevel.Medium => new SolidColorBrush(Color.Parse("#F59E0B")),
        RiskLevel.High => new SolidColorBrush(Color.Parse("#EF4444")),
        RiskLevel.Critical => new SolidColorBrush(Color.Parse("#7F1D1D")),
        _ => Brushes.Gray
    };

    /// <summary>
    /// Available override options.
    /// </summary>
    public ToolOverrideAction[] OverrideOptions { get; } =
    {
        ToolOverrideAction.Default,
        ToolOverrideAction.AlwaysAllow,
        ToolOverrideAction.AlwaysAsk,
        ToolOverrideAction.AlwaysDeny
    };
}

/// <summary>
/// Override action for tool permissions.
/// </summary>
public enum ToolOverrideAction
{
    /// <summary>
    /// Use default policy behavior.
    /// </summary>
    Default,

    /// <summary>
    /// Always allow without asking.
    /// </summary>
    AlwaysAllow,

    /// <summary>
    /// Always ask for approval.
    /// </summary>
    AlwaysAsk,

    /// <summary>
    /// Always deny execution.
    /// </summary>
    AlwaysDeny
}
```

### Acceptance Criteria (v0.6.5d)
- [ ] Agent mode section with all four options
- [ ] Risk threshold slider with visual feedback
- [ ] Tool permissions list with search functionality
- [ ] Execution limits sliders with current values
- [ ] Audit section with all logging options
- [ ] Protected paths management
- [ ] Save button triggers settings persistence
- [ ] Responsive layout within max width

---

## v0.6.5e: Agent Settings ViewModel

### Objective
Implement the ViewModel for the agent settings panel with full configuration management.

### File: `src/SeniorIntern.Desktop/ViewModels/AgentSettingsViewModel.cs`

```csharp
using System;
using System.Collections.ObjectModel;
using System.Linq;
using System.Threading.Tasks;
using Avalonia.Media;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Desktop.Models;
using SeniorIntern.Desktop.Services;

namespace SeniorIntern.Desktop.ViewModels;

/// <summary>
/// ViewModel for agent settings panel.
/// </summary>
public partial class AgentSettingsViewModel : ViewModelBase
{
    private readonly ISettingsService _settingsService;
    private readonly IToolRegistry _toolRegistry;
    private readonly IAuditLogRepository _auditLogRepository;
    private readonly IDialogService _dialogService;

    /// <summary>
    /// Current policy mode.
    /// </summary>
    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(IsRiskThresholdVisible))]
    private PolicyMode _policyMode = PolicyMode.AskForRisky;

    /// <summary>
    /// Risk threshold value (0-4 mapping to RiskLevel enum).
    /// </summary>
    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(RiskThresholdText))]
    [NotifyPropertyChangedFor(nameof(RiskThresholdBrush))]
    private int _riskThresholdValue = 2;

    /// <summary>
    /// Maximum iterations per agent request.
    /// </summary>
    [ObservableProperty]
    private int _maxIterations = 10;

    /// <summary>
    /// Tool execution timeout in seconds.
    /// </summary>
    [ObservableProperty]
    private int _toolTimeoutSeconds = 60;

    /// <summary>
    /// Rate limit per minute.
    /// </summary>
    [ObservableProperty]
    private int _rateLimitPerMinute = 30;

    /// <summary>
    /// Rate limit per hour.
    /// </summary>
    [ObservableProperty]
    private int _rateLimitPerHour = 200;

    /// <summary>
    /// Whether to audit all tool executions.
    /// </summary>
    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(AuditLogStats))]
    private bool _auditAllExecutions = true;

    /// <summary>
    /// Whether to include parameters in audit log.
    /// </summary>
    [ObservableProperty]
    private bool _auditIncludeParameters = true;

    /// <summary>
    /// Whether to include results in audit log.
    /// </summary>
    [ObservableProperty]
    private bool _auditIncludeResults = true;

    /// <summary>
    /// Search text for tool filtering.
    /// </summary>
    [ObservableProperty]
    private string _toolSearchText = string.Empty;

    /// <summary>
    /// All available tools.
    /// </summary>
    [ObservableProperty]
    private ObservableCollection<ToolPermissionItem> _tools = new();

    /// <summary>
    /// Protected paths.
    /// </summary>
    [ObservableProperty]
    private ObservableCollection<ProtectedPathItem> _protectedPaths = new();

    /// <summary>
    /// Whether risk threshold section is visible.
    /// </summary>
    public bool IsRiskThresholdVisible => PolicyMode == PolicyMode.AskForRisky;

    /// <summary>
    /// Text representation of current risk threshold.
    /// </summary>
    public string RiskThresholdText => ((RiskLevel)RiskThresholdValue).ToString();

    /// <summary>
    /// Brush for risk threshold display.
    /// </summary>
    public IBrush RiskThresholdBrush => RiskThresholdValue switch
    {
        0 => new SolidColorBrush(Color.Parse("#10B981")),
        1 => new SolidColorBrush(Color.Parse("#6B7280")),
        2 => new SolidColorBrush(Color.Parse("#F59E0B")),
        3 => new SolidColorBrush(Color.Parse("#EF4444")),
        4 => new SolidColorBrush(Color.Parse("#7F1D1D")),
        _ => Brushes.Gray
    };

    /// <summary>
    /// Filtered tools based on search text.
    /// </summary>
    public ObservableCollection<ToolPermissionItem> FilteredTools
    {
        get
        {
            if (string.IsNullOrWhiteSpace(ToolSearchText))
                return Tools;

            var filtered = Tools.Where(t =>
                t.Name.Contains(ToolSearchText, StringComparison.OrdinalIgnoreCase) ||
                t.Description.Contains(ToolSearchText, StringComparison.OrdinalIgnoreCase));

            return new ObservableCollection<ToolPermissionItem>(filtered);
        }
    }

    /// <summary>
    /// Risk level descriptions for the legend.
    /// </summary>
    public RiskLevelDescription[] RiskLevelDescriptions { get; } = new[]
    {
        new RiskLevelDescription("Safe", "Read-only operations", new SolidColorBrush(Color.Parse("#10B981"))),
        new RiskLevelDescription("Low", "Non-destructive changes", new SolidColorBrush(Color.Parse("#6B7280"))),
        new RiskLevelDescription("Medium", "File modifications", new SolidColorBrush(Color.Parse("#F59E0B"))),
        new RiskLevelDescription("High", "System commands", new SolidColorBrush(Color.Parse("#EF4444"))),
        new RiskLevelDescription("Critical", "Dangerous operations", new SolidColorBrush(Color.Parse("#7F1D1D")))
    };

    /// <summary>
    /// Audit log statistics text.
    /// </summary>
    public string AuditLogStats
    {
        get
        {
            if (!AuditAllExecutions)
                return "Audit logging disabled";

            // This would be loaded asynchronously
            return "Loading stats...";
        }
    }

    private int _totalAuditEntries;
    private DateTime? _oldestEntry;

    public AgentSettingsViewModel(
        ISettingsService settingsService,
        IToolRegistry toolRegistry,
        IAuditLogRepository auditLogRepository,
        IDialogService dialogService)
    {
        _settingsService = settingsService;
        _toolRegistry = toolRegistry;
        _auditLogRepository = auditLogRepository;
        _dialogService = dialogService;
    }

    /// <summary>
    /// Load settings from storage.
    /// </summary>
    public async Task LoadSettingsAsync()
    {
        var settings = await _settingsService.GetAgentSettingsAsync();

        PolicyMode = settings.PolicyMode;
        RiskThresholdValue = (int)settings.ApprovalThreshold;
        MaxIterations = settings.MaxIterations;
        ToolTimeoutSeconds = (int)settings.ToolTimeout.TotalSeconds;
        RateLimitPerMinute = settings.RateLimitPerMinute;
        RateLimitPerHour = settings.RateLimitPerHour;
        AuditAllExecutions = settings.AuditAllExecutions;
        AuditIncludeParameters = settings.AuditIncludeParameters;
        AuditIncludeResults = settings.AuditIncludeResults;

        // Load tools
        var tools = _toolRegistry.GetAllTools();
        Tools = new ObservableCollection<ToolPermissionItem>(
            tools.Select(t => new ToolPermissionItem
            {
                Id = t.Id,
                Name = t.Name,
                Description = t.Description,
                RiskLevel = t.DefaultRiskLevel,
                IsEnabled = settings.GetToolEnabled(t.Id),
                OverrideAction = settings.GetToolOverride(t.Id)
            }));

        // Load protected paths
        ProtectedPaths = new ObservableCollection<ProtectedPathItem>(
            settings.ProtectedPaths.Select(p => new ProtectedPathItem { Path = p }));

        // Load audit stats
        await LoadAuditStatsAsync();
    }

    private async Task LoadAuditStatsAsync()
    {
        _totalAuditEntries = await _auditLogRepository.GetCountAsync();
        _oldestEntry = await _auditLogRepository.GetOldestEntryDateAsync();
        OnPropertyChanged(nameof(AuditLogStats));
    }

    partial void OnToolSearchTextChanged(string value)
    {
        OnPropertyChanged(nameof(FilteredTools));
    }

    /// <summary>
    /// Save settings to storage.
    /// </summary>
    [RelayCommand]
    private async Task SaveSettingsAsync()
    {
        var settings = new AgentSettings
        {
            PolicyMode = PolicyMode,
            ApprovalThreshold = (RiskLevel)RiskThresholdValue,
            MaxIterations = MaxIterations,
            ToolTimeout = TimeSpan.FromSeconds(ToolTimeoutSeconds),
            RateLimitPerMinute = RateLimitPerMinute,
            RateLimitPerHour = RateLimitPerHour,
            AuditAllExecutions = AuditAllExecutions,
            AuditIncludeParameters = AuditIncludeParameters,
            AuditIncludeResults = AuditIncludeResults,
            ProtectedPaths = ProtectedPaths.Select(p => p.Path).ToList()
        };

        // Save tool overrides
        foreach (var tool in Tools)
        {
            settings.SetToolEnabled(tool.Id, tool.IsEnabled);
            settings.SetToolOverride(tool.Id, tool.OverrideAction);
        }

        await _settingsService.SaveAgentSettingsAsync(settings);

        await _dialogService.ShowInfoAsync("Settings Saved", "Agent settings have been saved successfully.");
    }

    /// <summary>
    /// Reset all tool permissions to default.
    /// </summary>
    [RelayCommand]
    private async Task ResetToolPermissionsAsync()
    {
        var result = await _dialogService.ShowConfirmAsync(
            "Reset Tool Permissions",
            "Are you sure you want to reset all tool permissions to their defaults?");

        if (!result) return;

        foreach (var tool in Tools)
        {
            tool.IsEnabled = true;
            tool.OverrideAction = ToolOverrideAction.Default;
        }
    }

    /// <summary>
    /// Open the audit log viewer.
    /// </summary>
    [RelayCommand]
    private async Task ViewAuditLogAsync()
    {
        await _dialogService.ShowAuditLogViewerAsync();
    }

    /// <summary>
    /// Export the audit log to a file.
    /// </summary>
    [RelayCommand]
    private async Task ExportAuditLogAsync()
    {
        var path = await _dialogService.ShowSaveFileDialogAsync(
            "Export Audit Log",
            "audit_log.json",
            new[] { "JSON files|*.json", "CSV files|*.csv" });

        if (string.IsNullOrEmpty(path)) return;

        var entries = await _auditLogRepository.GetAllAsync();

        if (path.EndsWith(".json"))
        {
            await ExportAsJsonAsync(path, entries);
        }
        else
        {
            await ExportAsCsvAsync(path, entries);
        }

        await _dialogService.ShowInfoAsync("Export Complete", $"Audit log exported to {path}");
    }

    private async Task ExportAsJsonAsync(string path, IEnumerable<AuditLogEntry> entries)
    {
        var json = System.Text.Json.JsonSerializer.Serialize(entries, new System.Text.Json.JsonSerializerOptions
        {
            WriteIndented = true
        });
        await System.IO.File.WriteAllTextAsync(path, json);
    }

    private async Task ExportAsCsvAsync(string path, IEnumerable<AuditLogEntry> entries)
    {
        var lines = new System.Collections.Generic.List<string>
        {
            "Timestamp,ToolId,ToolName,RiskLevel,Decision,ExecutionSuccess,Duration"
        };

        foreach (var entry in entries)
        {
            lines.Add($"{entry.Timestamp:O},{entry.ToolId},{entry.ToolName},{entry.RiskLevel},{entry.Decision},{entry.ExecutionSuccess},{entry.ExecutionDuration?.TotalMilliseconds}");
        }

        await System.IO.File.WriteAllLinesAsync(path, lines);
    }

    /// <summary>
    /// Clear the audit log.
    /// </summary>
    [RelayCommand]
    private async Task ClearAuditLogAsync()
    {
        var result = await _dialogService.ShowConfirmAsync(
            "Clear Audit Log",
            "Are you sure you want to clear the audit log? This action cannot be undone.",
            isDangerous: true);

        if (!result) return;

        await _auditLogRepository.ClearAsync();
        await LoadAuditStatsAsync();

        await _dialogService.ShowInfoAsync("Audit Log Cleared", "The audit log has been cleared.");
    }

    /// <summary>
    /// Add a protected path.
    /// </summary>
    [RelayCommand]
    private async Task AddProtectedPathAsync()
    {
        var path = await _dialogService.ShowFolderPickerAsync("Select Protected Path");

        if (string.IsNullOrEmpty(path)) return;

        if (ProtectedPaths.Any(p => p.Path.Equals(path, StringComparison.OrdinalIgnoreCase)))
        {
            await _dialogService.ShowWarningAsync("Path Already Protected", "This path is already in the protected list.");
            return;
        }

        ProtectedPaths.Add(new ProtectedPathItem { Path = path });
    }

    /// <summary>
    /// Remove a protected path.
    /// </summary>
    [RelayCommand]
    private void RemoveProtectedPath(ProtectedPathItem item)
    {
        ProtectedPaths.Remove(item);
    }
}

/// <summary>
/// Description of a risk level for the UI legend.
/// </summary>
public record RiskLevelDescription(string Name, string Description, IBrush Brush);

/// <summary>
/// UI model for protected paths.
/// </summary>
public class ProtectedPathItem
{
    public string Path { get; init; } = string.Empty;
}
```

### File: `src/SeniorIntern.Core/Models/AgentSettings.cs`

```csharp
using System;
using System.Collections.Generic;
using SeniorIntern.Desktop.Models;

namespace SeniorIntern.Core.Models;

/// <summary>
/// Agent configuration settings.
/// </summary>
public sealed class AgentSettings
{
    /// <summary>
    /// Policy mode for tool approval.
    /// </summary>
    public PolicyMode PolicyMode { get; set; } = PolicyMode.AskForRisky;

    /// <summary>
    /// Risk level threshold for approval in AskForRisky mode.
    /// </summary>
    public RiskLevel ApprovalThreshold { get; set; } = RiskLevel.Medium;

    /// <summary>
    /// Maximum iterations per agent request.
    /// </summary>
    public int MaxIterations { get; set; } = 10;

    /// <summary>
    /// Timeout for individual tool executions.
    /// </summary>
    public TimeSpan ToolTimeout { get; set; } = TimeSpan.FromSeconds(60);

    /// <summary>
    /// Maximum tool calls per minute.
    /// </summary>
    public int RateLimitPerMinute { get; set; } = 30;

    /// <summary>
    /// Maximum tool calls per hour.
    /// </summary>
    public int RateLimitPerHour { get; set; } = 200;

    /// <summary>
    /// Whether to log all tool executions.
    /// </summary>
    public bool AuditAllExecutions { get; set; } = true;

    /// <summary>
    /// Whether to include parameters in audit log.
    /// </summary>
    public bool AuditIncludeParameters { get; set; } = true;

    /// <summary>
    /// Whether to include results in audit log.
    /// </summary>
    public bool AuditIncludeResults { get; set; } = true;

    /// <summary>
    /// Paths that tools cannot access.
    /// </summary>
    public List<string> ProtectedPaths { get; set; } = new();

    /// <summary>
    /// Per-tool enabled state.
    /// </summary>
    private Dictionary<string, bool> _toolEnabled = new();

    /// <summary>
    /// Per-tool override actions.
    /// </summary>
    private Dictionary<string, ToolOverrideAction> _toolOverrides = new();

    /// <summary>
    /// Get whether a tool is enabled.
    /// </summary>
    public bool GetToolEnabled(string toolId) =>
        _toolEnabled.GetValueOrDefault(toolId, true);

    /// <summary>
    /// Set whether a tool is enabled.
    /// </summary>
    public void SetToolEnabled(string toolId, bool enabled) =>
        _toolEnabled[toolId] = enabled;

    /// <summary>
    /// Get the override action for a tool.
    /// </summary>
    public ToolOverrideAction GetToolOverride(string toolId) =>
        _toolOverrides.GetValueOrDefault(toolId, ToolOverrideAction.Default);

    /// <summary>
    /// Set the override action for a tool.
    /// </summary>
    public void SetToolOverride(string toolId, ToolOverrideAction action) =>
        _toolOverrides[toolId] = action;
}
```

### Acceptance Criteria (v0.6.5e)
- [ ] Settings loaded from storage on initialization
- [ ] Policy mode changes reflected in UI
- [ ] Risk threshold updates text and brush
- [ ] Tool search filters the list
- [ ] Save command persists all settings
- [ ] Reset tool permissions confirms before resetting
- [ ] Audit log export supports JSON and CSV
- [ ] Protected path management works correctly

---

## v0.6.5f: Audit Log Viewer

### Objective
Create a detailed viewer for browsing and filtering the audit log.

### File: `src/SeniorIntern.Desktop/Views/AuditLogViewer.axaml`

```xml
<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:vm="using:SeniorIntern.Desktop.ViewModels"
        xmlns:converters="using:SeniorIntern.Desktop.Converters"
        mc:Ignorable="d"
        x:Class="SeniorIntern.Desktop.Views.AuditLogViewer"
        x:DataType="vm:AuditLogViewerViewModel"
        Title="Audit Log Viewer"
        Width="900"
        Height="600"
        WindowStartupLocation="CenterOwner">

    <Window.Resources>
        <converters:AuditDecisionToBrushConverter x:Key="DecisionBrushConverter" />
        <converters:RiskLevelToBrushConverter x:Key="RiskBrushConverter" />
        <converters:BoolToVisibilityConverter x:Key="BoolToVisibility" />
    </Window.Resources>

    <Grid RowDefinitions="Auto, Auto, *, Auto">

        <!-- Header -->
        <Border Grid.Row="0"
                Background="{DynamicResource SurfaceBackground}"
                Padding="16">
            <Grid ColumnDefinitions="*, Auto">
                <StackPanel>
                    <TextBlock Text="Audit Log" FontSize="20" FontWeight="SemiBold" />
                    <TextBlock Text="{Binding SummaryText}"
                               Foreground="{DynamicResource TextMuted}"
                               FontSize="12" />
                </StackPanel>

                <Button Grid.Column="1"
                        Content="Refresh"
                        Command="{Binding RefreshCommand}"
                        Classes="secondary" />
            </Grid>
        </Border>

        <!-- Filters -->
        <Border Grid.Row="1"
                Background="{DynamicResource SurfaceBackgroundAlt}"
                Padding="16,12">
            <WrapPanel Orientation="Horizontal">
                <!-- Date Range -->
                <StackPanel Orientation="Horizontal" Spacing="8" Margin="0,0,16,0">
                    <TextBlock Text="From:" VerticalAlignment="Center" />
                    <CalendarDatePicker SelectedDate="{Binding StartDate}" Width="130" />
                    <TextBlock Text="To:" VerticalAlignment="Center" />
                    <CalendarDatePicker SelectedDate="{Binding EndDate}" Width="130" />
                </StackPanel>

                <!-- Tool Filter -->
                <StackPanel Orientation="Horizontal" Spacing="8" Margin="0,0,16,0">
                    <TextBlock Text="Tool:" VerticalAlignment="Center" />
                    <ComboBox ItemsSource="{Binding AvailableTools}"
                              SelectedItem="{Binding SelectedTool}"
                              Width="150"
                              PlaceholderText="All tools" />
                </StackPanel>

                <!-- Decision Filter -->
                <StackPanel Orientation="Horizontal" Spacing="8" Margin="0,0,16,0">
                    <TextBlock Text="Decision:" VerticalAlignment="Center" />
                    <ComboBox ItemsSource="{Binding AvailableDecisions}"
                              SelectedItem="{Binding SelectedDecision}"
                              Width="130"
                              PlaceholderText="All" />
                </StackPanel>

                <!-- Risk Filter -->
                <StackPanel Orientation="Horizontal" Spacing="8" Margin="0,0,16,0">
                    <TextBlock Text="Min Risk:" VerticalAlignment="Center" />
                    <ComboBox ItemsSource="{Binding AvailableRiskLevels}"
                              SelectedItem="{Binding SelectedMinRisk}"
                              Width="100"
                              PlaceholderText="Any" />
                </StackPanel>

                <!-- Search -->
                <TextBox Text="{Binding SearchText}"
                         Watermark="Search..."
                         Width="150" />
            </WrapPanel>
        </Border>

        <!-- Log Entries -->
        <DataGrid Grid.Row="2"
                  ItemsSource="{Binding FilteredEntries}"
                  SelectedItem="{Binding SelectedEntry}"
                  AutoGenerateColumns="False"
                  IsReadOnly="True"
                  GridLinesVisibility="Horizontal"
                  HeadersVisibility="Column"
                  CanUserResizeColumns="True"
                  CanUserSortColumns="True">

            <DataGrid.Columns>
                <DataGridTextColumn Header="Time"
                                    Binding="{Binding Timestamp, StringFormat='{}{0:yyyy-MM-dd HH:mm:ss}'}"
                                    Width="150" />

                <DataGridTextColumn Header="Tool"
                                    Binding="{Binding ToolName}"
                                    Width="120" />

                <DataGridTemplateColumn Header="Risk" Width="80">
                    <DataGridTemplateColumn.CellTemplate>
                        <DataTemplate>
                            <Border Background="{Binding RiskLevel, Converter={StaticResource RiskBrushConverter}}"
                                    CornerRadius="4"
                                    Padding="6,2"
                                    HorizontalAlignment="Center">
                                <TextBlock Text="{Binding RiskLevel}"
                                           Foreground="White"
                                           FontSize="11" />
                            </Border>
                        </DataTemplate>
                    </DataGridTemplateColumn.CellTemplate>
                </DataGridTemplateColumn>

                <DataGridTemplateColumn Header="Decision" Width="100">
                    <DataGridTemplateColumn.CellTemplate>
                        <DataTemplate>
                            <Border Background="{Binding Decision, Converter={StaticResource DecisionBrushConverter}}"
                                    CornerRadius="4"
                                    Padding="6,2"
                                    HorizontalAlignment="Center">
                                <TextBlock Text="{Binding Decision}"
                                           Foreground="White"
                                           FontSize="11" />
                            </Border>
                        </DataTemplate>
                    </DataGridTemplateColumn.CellTemplate>
                </DataGridTemplateColumn>

                <DataGridTemplateColumn Header="Result" Width="70">
                    <DataGridTemplateColumn.CellTemplate>
                        <DataTemplate>
                            <PathIcon Data="{Binding ExecutionSuccess, Converter={StaticResource BoolToIconConverter}}"
                                      Width="16" Height="16"
                                      Foreground="{Binding ExecutionSuccess, Converter={StaticResource BoolToBrushConverter}}"
                                      IsVisible="{Binding ExecutionSuccess, Converter={x:Static ObjectConverters.IsNotNull}}" />
                        </DataTemplate>
                    </DataGridTemplateColumn.CellTemplate>
                </DataGridTemplateColumn>

                <DataGridTextColumn Header="Duration"
                                    Binding="{Binding ExecutionDuration, StringFormat='{}{0:F0}ms'}"
                                    Width="80" />

                <DataGridTextColumn Header="Summary"
                                    Binding="{Binding ExecutionSummary}"
                                    Width="*" />
            </DataGrid.Columns>
        </DataGrid>

        <!-- Details Panel -->
        <Border Grid.Row="3"
                Background="{DynamicResource SurfaceBackgroundAlt}"
                Padding="16"
                IsVisible="{Binding HasSelectedEntry}">
            <Grid ColumnDefinitions="*, *" RowDefinitions="Auto, Auto, Auto">

                <!-- Parameters -->
                <StackPanel Grid.Column="0" Grid.Row="0" Margin="0,0,8,8">
                    <TextBlock Text="Parameters" FontWeight="SemiBold" Margin="0,0,0,4" />
                    <TextBox Text="{Binding SelectedEntry.ParametersFormatted}"
                             IsReadOnly="True"
                             AcceptsReturn="True"
                             FontFamily="{StaticResource MonoFont}"
                             MaxHeight="100"
                             FontSize="11" />
                </StackPanel>

                <!-- Error -->
                <StackPanel Grid.Column="1" Grid.Row="0" Margin="8,0,0,8"
                            IsVisible="{Binding SelectedEntry.ExecutionError, Converter={x:Static StringConverters.IsNotNullOrEmpty}}">
                    <TextBlock Text="Error" FontWeight="SemiBold" Margin="0,0,0,4"
                               Foreground="{DynamicResource ErrorBrush}" />
                    <TextBox Text="{Binding SelectedEntry.ExecutionError}"
                             IsReadOnly="True"
                             AcceptsReturn="True"
                             FontFamily="{StaticResource MonoFont}"
                             MaxHeight="100"
                             FontSize="11"
                             Foreground="{DynamicResource ErrorBrush}" />
                </StackPanel>

                <!-- Denial Reason -->
                <StackPanel Grid.Column="0" Grid.ColumnSpan="2" Grid.Row="1"
                            IsVisible="{Binding SelectedEntry.DenialReason, Converter={x:Static StringConverters.IsNotNullOrEmpty}}">
                    <TextBlock Text="Denial Reason" FontWeight="SemiBold" Margin="0,0,0,4" />
                    <TextBlock Text="{Binding SelectedEntry.DenialReason}"
                               TextWrapping="Wrap"
                               FontSize="12" />
                </StackPanel>

                <!-- Conversation Link -->
                <StackPanel Grid.Column="0" Grid.ColumnSpan="2" Grid.Row="2"
                            Orientation="Horizontal"
                            Spacing="8"
                            Margin="0,8,0,0"
                            IsVisible="{Binding SelectedEntry.ConversationId, Converter={x:Static ObjectConverters.IsNotNull}}">
                    <TextBlock Text="Conversation:" VerticalAlignment="Center" />
                    <Button Content="View Conversation"
                            Command="{Binding ViewConversationCommand}"
                            CommandParameter="{Binding SelectedEntry.ConversationId}"
                            Classes="link-button" />
                </StackPanel>
            </Grid>
        </Border>
    </Grid>
</Window>
```

### File: `src/SeniorIntern.Desktop/Views/AuditLogViewer.axaml.cs`

```csharp
using Avalonia.Controls;

namespace SeniorIntern.Desktop.Views;

/// <summary>
/// Window for viewing the audit log.
/// </summary>
public partial class AuditLogViewer : Window
{
    public AuditLogViewer()
    {
        InitializeComponent();
    }
}
```

### File: `src/SeniorIntern.Desktop/ViewModels/AuditLogViewerViewModel.cs`

```csharp
using System;
using System.Collections.ObjectModel;
using System.Linq;
using System.Threading.Tasks;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;

namespace SeniorIntern.Desktop.ViewModels;

/// <summary>
/// ViewModel for the audit log viewer.
/// </summary>
public partial class AuditLogViewerViewModel : ViewModelBase
{
    private readonly IAuditLogRepository _auditLogRepository;
    private readonly INavigationService _navigationService;

    private ObservableCollection<AuditLogEntry> _allEntries = new();

    /// <summary>
    /// Start date filter.
    /// </summary>
    [ObservableProperty]
    private DateTimeOffset? _startDate;

    /// <summary>
    /// End date filter.
    /// </summary>
    [ObservableProperty]
    private DateTimeOffset? _endDate;

    /// <summary>
    /// Selected tool filter.
    /// </summary>
    [ObservableProperty]
    private string? _selectedTool;

    /// <summary>
    /// Selected decision filter.
    /// </summary>
    [ObservableProperty]
    private AuditDecision? _selectedDecision;

    /// <summary>
    /// Selected minimum risk level.
    /// </summary>
    [ObservableProperty]
    private RiskLevel? _selectedMinRisk;

    /// <summary>
    /// Search text.
    /// </summary>
    [ObservableProperty]
    private string _searchText = string.Empty;

    /// <summary>
    /// Currently selected entry.
    /// </summary>
    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(HasSelectedEntry))]
    private AuditLogEntry? _selectedEntry;

    /// <summary>
    /// Available tools for filtering.
    /// </summary>
    [ObservableProperty]
    private ObservableCollection<string> _availableTools = new();

    /// <summary>
    /// Available decisions for filtering.
    /// </summary>
    public AuditDecision[] AvailableDecisions { get; } = Enum.GetValues<AuditDecision>();

    /// <summary>
    /// Available risk levels for filtering.
    /// </summary>
    public RiskLevel[] AvailableRiskLevels { get; } = Enum.GetValues<RiskLevel>();

    /// <summary>
    /// Filtered entries based on current filters.
    /// </summary>
    public ObservableCollection<AuditLogEntry> FilteredEntries
    {
        get
        {
            var query = _allEntries.AsEnumerable();

            if (StartDate.HasValue)
                query = query.Where(e => e.Timestamp >= StartDate.Value.DateTime);

            if (EndDate.HasValue)
                query = query.Where(e => e.Timestamp <= EndDate.Value.DateTime.AddDays(1));

            if (!string.IsNullOrEmpty(SelectedTool))
                query = query.Where(e => e.ToolId == SelectedTool);

            if (SelectedDecision.HasValue)
                query = query.Where(e => e.Decision == SelectedDecision.Value);

            if (SelectedMinRisk.HasValue)
                query = query.Where(e => e.RiskLevel >= SelectedMinRisk.Value);

            if (!string.IsNullOrWhiteSpace(SearchText))
                query = query.Where(e =>
                    e.ToolName.Contains(SearchText, StringComparison.OrdinalIgnoreCase) ||
                    e.ExecutionSummary.Contains(SearchText, StringComparison.OrdinalIgnoreCase));

            return new ObservableCollection<AuditLogEntry>(query.OrderByDescending(e => e.Timestamp));
        }
    }

    /// <summary>
    /// Whether an entry is selected.
    /// </summary>
    public bool HasSelectedEntry => SelectedEntry is not null;

    /// <summary>
    /// Summary text showing count and date range.
    /// </summary>
    public string SummaryText
    {
        get
        {
            var count = FilteredEntries.Count;
            var total = _allEntries.Count;
            return $"Showing {count} of {total} entries";
        }
    }

    public AuditLogViewerViewModel(
        IAuditLogRepository auditLogRepository,
        INavigationService navigationService)
    {
        _auditLogRepository = auditLogRepository;
        _navigationService = navigationService;
    }

    /// <summary>
    /// Initialize the viewer with data.
    /// </summary>
    public async Task InitializeAsync()
    {
        await RefreshAsync();
    }

    /// <summary>
    /// Refresh the log entries.
    /// </summary>
    [RelayCommand]
    private async Task RefreshAsync()
    {
        var entries = await _auditLogRepository.GetAllAsync();
        _allEntries = new ObservableCollection<AuditLogEntry>(entries);

        // Extract unique tools
        AvailableTools = new ObservableCollection<string>(
            _allEntries.Select(e => e.ToolId).Distinct().OrderBy(t => t));

        OnPropertyChanged(nameof(FilteredEntries));
        OnPropertyChanged(nameof(SummaryText));
    }

    /// <summary>
    /// Navigate to the conversation.
    /// </summary>
    [RelayCommand]
    private async Task ViewConversationAsync(Guid? conversationId)
    {
        if (!conversationId.HasValue) return;

        await _navigationService.NavigateToConversationAsync(conversationId.Value);
    }

    partial void OnStartDateChanged(DateTimeOffset? value) => OnPropertyChanged(nameof(FilteredEntries));
    partial void OnEndDateChanged(DateTimeOffset? value) => OnPropertyChanged(nameof(FilteredEntries));
    partial void OnSelectedToolChanged(string? value) => OnPropertyChanged(nameof(FilteredEntries));
    partial void OnSelectedDecisionChanged(AuditDecision? value) => OnPropertyChanged(nameof(FilteredEntries));
    partial void OnSelectedMinRiskChanged(RiskLevel? value) => OnPropertyChanged(nameof(FilteredEntries));
    partial void OnSearchTextChanged(string value) => OnPropertyChanged(nameof(FilteredEntries));
}
```

### File: `src/SeniorIntern.Desktop/Converters/AuditConverters.cs`

```csharp
using System;
using System.Globalization;
using Avalonia.Data.Converters;
using Avalonia.Media;
using SeniorIntern.Core.Models;

namespace SeniorIntern.Desktop.Converters;

/// <summary>
/// Converts AuditDecision to brush for styling.
/// </summary>
public class AuditDecisionToBrushConverter : IValueConverter
{
    public object? Convert(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        if (value is not AuditDecision decision)
            return Brushes.Gray;

        return decision switch
        {
            AuditDecision.AutoApproved => new SolidColorBrush(Color.Parse("#10B981")),
            AuditDecision.UserApproved => new SolidColorBrush(Color.Parse("#3B82F6")),
            AuditDecision.UserDenied => new SolidColorBrush(Color.Parse("#EF4444")),
            AuditDecision.PolicyBlocked => new SolidColorBrush(Color.Parse("#7F1D1D")),
            AuditDecision.RateLimited => new SolidColorBrush(Color.Parse("#F59E0B")),
            AuditDecision.Error => new SolidColorBrush(Color.Parse("#EF4444")),
            _ => Brushes.Gray
        };
    }

    public object? ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        throw new NotImplementedException();
    }
}

/// <summary>
/// Converts RiskLevel to brush for styling.
/// </summary>
public class RiskLevelToBrushConverter : IValueConverter
{
    public object? Convert(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        if (value is not RiskLevel level)
            return Brushes.Gray;

        return level switch
        {
            RiskLevel.Safe => new SolidColorBrush(Color.Parse("#10B981")),
            RiskLevel.Low => new SolidColorBrush(Color.Parse("#6B7280")),
            RiskLevel.Medium => new SolidColorBrush(Color.Parse("#F59E0B")),
            RiskLevel.High => new SolidColorBrush(Color.Parse("#EF4444")),
            RiskLevel.Critical => new SolidColorBrush(Color.Parse("#7F1D1D")),
            _ => Brushes.Gray
        };
    }

    public object? ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        throw new NotImplementedException();
    }
}
```

### Acceptance Criteria (v0.6.5f)
- [ ] Audit log viewer opens as dialog
- [ ] Date range filtering works
- [ ] Tool filtering shows available tools
- [ ] Decision filtering functional
- [ ] Risk level filtering works
- [ ] Search filters by tool name and summary
- [ ] DataGrid displays all columns correctly
- [ ] Entry selection shows details panel
- [ ] Conversation navigation works
- [ ] Refresh reloads data

---

## v0.6.5g: Keyboard Shortcuts System

### Objective
Implement global keyboard shortcuts for efficient agent interaction.

### File: `src/SeniorIntern.Desktop/Services/KeyboardShortcutService.cs`

```csharp
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Avalonia.Input;
using CommunityToolkit.Mvvm.Messaging;
using SeniorIntern.Desktop.Messages;

namespace SeniorIntern.Desktop.Services;

/// <summary>
/// Service for handling global keyboard shortcuts.
/// </summary>
public sealed class KeyboardShortcutService : IKeyboardShortcutService
{
    private readonly Dictionary<KeyGesture, ShortcutAction> _shortcuts = new();
    private readonly IMessenger _messenger;
    private bool _isEnabled = true;

    public KeyboardShortcutService(IMessenger messenger)
    {
        _messenger = messenger;
        RegisterDefaultShortcuts();
    }

    /// <summary>
    /// Enable or disable keyboard shortcut handling.
    /// </summary>
    public bool IsEnabled
    {
        get => _isEnabled;
        set => _isEnabled = value;
    }

    private void RegisterDefaultShortcuts()
    {
        // Agent Mode Toggle
        Register(
            new KeyGesture(Key.A, KeyModifiers.Control | KeyModifiers.Shift),
            new ShortcutAction("Toggle Agent Mode", ShortcutCategory.Agent, () =>
            {
                _messenger.Send(new ToggleAgentModeMessage());
                return Task.CompletedTask;
            }));

        // Cancel Agent Execution
        Register(
            new KeyGesture(Key.Escape),
            new ShortcutAction("Cancel Execution", ShortcutCategory.Agent, () =>
            {
                _messenger.Send(new CancelAgentExecutionMessage());
                return Task.CompletedTask;
            }, requiresAgentActive: true));

        // Approve Pending Tool Call
        Register(
            new KeyGesture(Key.Enter),
            new ShortcutAction("Approve Tool", ShortcutCategory.Approval, () =>
            {
                _messenger.Send(new ApproveToolCallMessage(remember: false));
                return Task.CompletedTask;
            }, requiresApprovalPending: true));

        // Approve and Remember for Session
        Register(
            new KeyGesture(Key.Enter, KeyModifiers.Control),
            new ShortcutAction("Approve & Remember", ShortcutCategory.Approval, () =>
            {
                _messenger.Send(new ApproveToolCallMessage(remember: true));
                return Task.CompletedTask;
            }, requiresApprovalPending: true));

        // Deny Pending Tool Call
        Register(
            new KeyGesture(Key.Back),
            new ShortcutAction("Deny Tool", ShortcutCategory.Approval, () =>
            {
                _messenger.Send(new DenyToolCallMessage());
                return Task.CompletedTask;
            }, requiresApprovalPending: true));

        // Focus Chat Input
        Register(
            new KeyGesture(Key.L, KeyModifiers.Control),
            new ShortcutAction("Focus Input", ShortcutCategory.Navigation, () =>
            {
                _messenger.Send(new FocusChatInputMessage());
                return Task.CompletedTask;
            }));

        // Open Agent Settings
        Register(
            new KeyGesture(Key.OemComma, KeyModifiers.Control | KeyModifiers.Shift),
            new ShortcutAction("Agent Settings", ShortcutCategory.Navigation, () =>
            {
                _messenger.Send(new OpenAgentSettingsMessage());
                return Task.CompletedTask;
            }));

        // Show Shortcut Help
        Register(
            new KeyGesture(Key.OemQuestion, KeyModifiers.Control | KeyModifiers.Shift),
            new ShortcutAction("Show Shortcuts", ShortcutCategory.Help, () =>
            {
                _messenger.Send(new ShowShortcutHelpMessage());
                return Task.CompletedTask;
            }));
    }

    /// <summary>
    /// Register a keyboard shortcut.
    /// </summary>
    public void Register(KeyGesture gesture, ShortcutAction action)
    {
        _shortcuts[gesture] = action;
    }

    /// <summary>
    /// Unregister a keyboard shortcut.
    /// </summary>
    public void Unregister(KeyGesture gesture)
    {
        _shortcuts.Remove(gesture);
    }

    /// <summary>
    /// Handle a key event, returning true if handled.
    /// </summary>
    public async Task<bool> HandleKeyEventAsync(KeyEventArgs e, ShortcutContext context)
    {
        if (!IsEnabled) return false;

        var gesture = new KeyGesture(e.Key, e.KeyModifiers);

        if (!_shortcuts.TryGetValue(gesture, out var action))
            return false;

        // Check context requirements
        if (action.RequiresAgentActive && !context.IsAgentActive)
            return false;

        if (action.RequiresApprovalPending && !context.IsApprovalPending)
            return false;

        try
        {
            await action.ExecuteAsync();
            e.Handled = true;
            return true;
        }
        catch (Exception ex)
        {
            // Log error but don't crash
            System.Diagnostics.Debug.WriteLine($"Shortcut error: {ex.Message}");
            return false;
        }
    }

    /// <summary>
    /// Get all registered shortcuts.
    /// </summary>
    public IReadOnlyDictionary<KeyGesture, ShortcutAction> GetAllShortcuts() => _shortcuts;

    /// <summary>
    /// Get shortcuts by category.
    /// </summary>
    public IEnumerable<(KeyGesture Gesture, ShortcutAction Action)> GetShortcutsByCategory(ShortcutCategory category)
    {
        foreach (var (gesture, action) in _shortcuts)
        {
            if (action.Category == category)
                yield return (gesture, action);
        }
    }
}

/// <summary>
/// Action associated with a keyboard shortcut.
/// </summary>
public sealed class ShortcutAction
{
    /// <summary>
    /// Display name of the shortcut.
    /// </summary>
    public string Name { get; }

    /// <summary>
    /// Category for grouping.
    /// </summary>
    public ShortcutCategory Category { get; }

    /// <summary>
    /// Action to execute.
    /// </summary>
    private readonly Func<Task> _execute;

    /// <summary>
    /// Whether this shortcut requires the agent to be active.
    /// </summary>
    public bool RequiresAgentActive { get; }

    /// <summary>
    /// Whether this shortcut requires an approval to be pending.
    /// </summary>
    public bool RequiresApprovalPending { get; }

    public ShortcutAction(
        string name,
        ShortcutCategory category,
        Func<Task> execute,
        bool requiresAgentActive = false,
        bool requiresApprovalPending = false)
    {
        Name = name;
        Category = category;
        _execute = execute;
        RequiresAgentActive = requiresAgentActive;
        RequiresApprovalPending = requiresApprovalPending;
    }

    public Task ExecuteAsync() => _execute();
}

/// <summary>
/// Categories for organizing shortcuts.
/// </summary>
public enum ShortcutCategory
{
    Agent,
    Approval,
    Navigation,
    Help
}

/// <summary>
/// Context for evaluating shortcut conditions.
/// </summary>
public sealed class ShortcutContext
{
    public bool IsAgentActive { get; init; }
    public bool IsApprovalPending { get; init; }
    public bool IsChatInputFocused { get; init; }
}

/// <summary>
/// Interface for keyboard shortcut service.
/// </summary>
public interface IKeyboardShortcutService
{
    bool IsEnabled { get; set; }
    void Register(KeyGesture gesture, ShortcutAction action);
    void Unregister(KeyGesture gesture);
    Task<bool> HandleKeyEventAsync(KeyEventArgs e, ShortcutContext context);
    IReadOnlyDictionary<KeyGesture, ShortcutAction> GetAllShortcuts();
}
```

### File: `src/SeniorIntern.Desktop/Messages/ShortcutMessages.cs`

```csharp
namespace SeniorIntern.Desktop.Messages;

/// <summary>
/// Message to toggle agent mode.
/// </summary>
public sealed class ToggleAgentModeMessage { }

/// <summary>
/// Message to cancel agent execution.
/// </summary>
public sealed class CancelAgentExecutionMessage { }

/// <summary>
/// Message to approve a pending tool call.
/// </summary>
public sealed class ApproveToolCallMessage
{
    /// <summary>
    /// Whether to remember the decision.
    /// </summary>
    public bool Remember { get; }

    public ApproveToolCallMessage(bool remember)
    {
        Remember = remember;
    }
}

/// <summary>
/// Message to deny a pending tool call.
/// </summary>
public sealed class DenyToolCallMessage { }

/// <summary>
/// Message to focus the chat input.
/// </summary>
public sealed class FocusChatInputMessage { }

/// <summary>
/// Message to open agent settings.
/// </summary>
public sealed class OpenAgentSettingsMessage { }

/// <summary>
/// Message to show shortcut help.
/// </summary>
public sealed class ShowShortcutHelpMessage { }
```

### File: `src/SeniorIntern.Desktop/Views/ShortcutHelpDialog.axaml`

```xml
<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        x:Class="SeniorIntern.Desktop.Views.ShortcutHelpDialog"
        Title="Keyboard Shortcuts"
        Width="450"
        SizeToContent="Height"
        WindowStartupLocation="CenterOwner"
        CanResize="False">

    <StackPanel Spacing="16" Padding="24">

        <TextBlock Text="Keyboard Shortcuts"
                   FontSize="18"
                   FontWeight="SemiBold" />

        <!-- Agent Shortcuts -->
        <StackPanel Spacing="8">
            <TextBlock Text="Agent" FontWeight="SemiBold" FontSize="13" />

            <Grid ColumnDefinitions="*, Auto">
                <TextBlock Text="Toggle Agent Mode" />
                <Border Background="{DynamicResource SurfaceBackgroundAlt}"
                        CornerRadius="4" Padding="8,4">
                    <TextBlock Text="Ctrl+Shift+A"
                               FontFamily="{StaticResource MonoFont}"
                               FontSize="12" />
                </Border>
            </Grid>

            <Grid ColumnDefinitions="*, Auto">
                <TextBlock Text="Cancel Execution" />
                <Border Background="{DynamicResource SurfaceBackgroundAlt}"
                        CornerRadius="4" Padding="8,4">
                    <TextBlock Text="Escape"
                               FontFamily="{StaticResource MonoFont}"
                               FontSize="12" />
                </Border>
            </Grid>
        </StackPanel>

        <Separator />

        <!-- Approval Shortcuts -->
        <StackPanel Spacing="8">
            <TextBlock Text="Tool Approval" FontWeight="SemiBold" FontSize="13" />

            <Grid ColumnDefinitions="*, Auto">
                <TextBlock Text="Approve Tool" />
                <Border Background="{DynamicResource SurfaceBackgroundAlt}"
                        CornerRadius="4" Padding="8,4">
                    <TextBlock Text="Enter"
                               FontFamily="{StaticResource MonoFont}"
                               FontSize="12" />
                </Border>
            </Grid>

            <Grid ColumnDefinitions="*, Auto">
                <TextBlock Text="Approve &amp; Remember" />
                <Border Background="{DynamicResource SurfaceBackgroundAlt}"
                        CornerRadius="4" Padding="8,4">
                    <TextBlock Text="Ctrl+Enter"
                               FontFamily="{StaticResource MonoFont}"
                               FontSize="12" />
                </Border>
            </Grid>

            <Grid ColumnDefinitions="*, Auto">
                <TextBlock Text="Deny Tool" />
                <Border Background="{DynamicResource SurfaceBackgroundAlt}"
                        CornerRadius="4" Padding="8,4">
                    <TextBlock Text="Backspace"
                               FontFamily="{StaticResource MonoFont}"
                               FontSize="12" />
                </Border>
            </Grid>
        </StackPanel>

        <Separator />

        <!-- Navigation Shortcuts -->
        <StackPanel Spacing="8">
            <TextBlock Text="Navigation" FontWeight="SemiBold" FontSize="13" />

            <Grid ColumnDefinitions="*, Auto">
                <TextBlock Text="Focus Input" />
                <Border Background="{DynamicResource SurfaceBackgroundAlt}"
                        CornerRadius="4" Padding="8,4">
                    <TextBlock Text="Ctrl+L"
                               FontFamily="{StaticResource MonoFont}"
                               FontSize="12" />
                </Border>
            </Grid>

            <Grid ColumnDefinitions="*, Auto">
                <TextBlock Text="Agent Settings" />
                <Border Background="{DynamicResource SurfaceBackgroundAlt}"
                        CornerRadius="4" Padding="8,4">
                    <TextBlock Text="Ctrl+Shift+,"
                               FontFamily="{StaticResource MonoFont}"
                               FontSize="12" />
                </Border>
            </Grid>

            <Grid ColumnDefinitions="*, Auto">
                <TextBlock Text="Show This Help" />
                <Border Background="{DynamicResource SurfaceBackgroundAlt}"
                        CornerRadius="4" Padding="8,4">
                    <TextBlock Text="Ctrl+Shift+?"
                               FontFamily="{StaticResource MonoFont}"
                               FontSize="12" />
                </Border>
            </Grid>
        </StackPanel>

        <Button Content="Close"
                Command="{Binding CloseCommand}"
                HorizontalAlignment="Right"
                Padding="24,8" />
    </StackPanel>
</Window>
```

### Modification: `src/SeniorIntern.Desktop/Views/MainWindow.axaml.cs`

Add keyboard event handling to MainWindow:

```csharp
// Add to MainWindow constructor or initialization
private void SetupKeyboardShortcuts()
{
    KeyDown += OnMainWindowKeyDown;
}

private async void OnMainWindowKeyDown(object? sender, KeyEventArgs e)
{
    var shortcutService = App.Current.Services.GetRequiredService<IKeyboardShortcutService>();
    var viewModel = DataContext as MainWindowViewModel;

    var context = new ShortcutContext
    {
        IsAgentActive = viewModel?.IsAgentActive ?? false,
        IsApprovalPending = viewModel?.IsApprovalPending ?? false,
        IsChatInputFocused = viewModel?.IsChatInputFocused ?? false
    };

    await shortcutService.HandleKeyEventAsync(e, context);
}
```

### Acceptance Criteria (v0.6.5g)
- [ ] KeyboardShortcutService registers default shortcuts
- [ ] Ctrl+Shift+A toggles agent mode
- [ ] Escape cancels agent execution
- [ ] Enter approves pending tool call
- [ ] Ctrl+Enter approves and remembers
- [ ] Backspace denies tool call
- [ ] Context conditions evaluated correctly
- [ ] Shortcut help dialog displays all shortcuts
- [ ] Shortcuts can be enabled/disabled

---

## v0.6.5h: ChatViewModel Agent Integration

### Objective
Integrate agent mode into the ChatViewModel with full event handling.

### File: `src/SeniorIntern.Desktop/ViewModels/ChatViewModel.Agent.cs`

```csharp
using System;
using System.Collections.ObjectModel;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using CommunityToolkit.Mvvm.Messaging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Desktop.Messages;
using SeniorIntern.Desktop.Views;

namespace SeniorIntern.Desktop.ViewModels;

/// <summary>
/// Agent-related functionality for ChatViewModel.
/// </summary>
public partial class ChatViewModel : IRecipient<ToggleAgentModeMessage>,
                                     IRecipient<CancelAgentExecutionMessage>,
                                     IRecipient<ApproveToolCallMessage>,
                                     IRecipient<DenyToolCallMessage>
{
    private readonly IAgentService _agentService;
    private CancellationTokenSource? _agentCancellationTokenSource;
    private TaskCompletionSource<ApprovalDecision>? _pendingApprovalTcs;

    /// <summary>
    /// Whether agent mode is enabled.
    /// </summary>
    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(AgentModeText))]
    private bool _isAgentMode = true;

    /// <summary>
    /// Current agent state.
    /// </summary>
    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(IsAgentActive))]
    [NotifyPropertyChangedFor(nameof(IsApprovalPending))]
    private AgentState _agentState = AgentState.Idle;

    /// <summary>
    /// Agent activities for the activity panel.
    /// </summary>
    [ObservableProperty]
    private ObservableCollection<AgentActivityItem> _agentActivities = new();

    /// <summary>
    /// Activity ViewModel.
    /// </summary>
    [ObservableProperty]
    private AgentActivityViewModel? _agentActivityViewModel;

    /// <summary>
    /// Current pending approval request.
    /// </summary>
    [ObservableProperty]
    private ApprovalRequestEvent? _pendingApproval;

    /// <summary>
    /// Text for agent mode toggle.
    /// </summary>
    public string AgentModeText => IsAgentMode ? "Agent Mode: On" : "Agent Mode: Off";

    /// <summary>
    /// Whether the agent is currently active (not idle).
    /// </summary>
    public bool IsAgentActive => AgentState != AgentState.Idle;

    /// <summary>
    /// Whether an approval is pending.
    /// </summary>
    public bool IsApprovalPending => AgentState == AgentState.WaitingForApproval;

    /// <summary>
    /// Initialize agent-related functionality.
    /// </summary>
    private void InitializeAgentMode()
    {
        _agentService.StateChanged += OnAgentStateChanged;

        // Register for messages
        WeakReferenceMessenger.Default.Register<ToggleAgentModeMessage>(this);
        WeakReferenceMessenger.Default.Register<CancelAgentExecutionMessage>(this);
        WeakReferenceMessenger.Default.Register<ApproveToolCallMessage>(this);
        WeakReferenceMessenger.Default.Register<DenyToolCallMessage>(this);

        // Create activity ViewModel
        AgentActivityViewModel = new AgentActivityViewModel(_agentService);
    }

    /// <summary>
    /// Send a message using agent mode.
    /// </summary>
    private async Task SendAgentMessageAsync()
    {
        if (string.IsNullOrWhiteSpace(UserInput))
            return;

        _agentCancellationTokenSource = new CancellationTokenSource();
        var cancellationToken = _agentCancellationTokenSource.Token;

        var request = new AgentRequest
        {
            Message = UserInput,
            ConversationId = _conversation?.Id ?? Guid.NewGuid(),
            History = Messages.Select(m => m.ToChatMessage()).ToList(),
            AttachedFiles = AttachedContexts.Select(c => c.ToFileContext()).ToList(),
            SystemPrompt = CurrentSystemPrompt?.Content,
            ToolContext = new ToolAvailabilityContext
            {
                HasWorkspace = _workspaceService?.HasOpenWorkspace ?? false,
                HasTerminal = _terminalService?.Sessions.Count > 0,
                WorkspacePath = _workspaceService?.CurrentWorkspace?.RootPath
            }
        };

        var userMessage = UserInput;
        UserInput = string.Empty;
        AddUserMessage(userMessage);

        var assistantMessage = new ChatMessageViewModel
        {
            Role = MessageRole.Assistant,
            Content = string.Empty,
            ToolResults = new ObservableCollection<ToolResultDisplay>()
        };
        Messages.Add(assistantMessage);

        AgentActivities.Clear();
        var settings = await _settingsService.GetAgentSettingsAsync();
        AgentActivityViewModel?.StartTracking(request.ConversationId, settings.MaxIterations, _agentCancellationTokenSource);

        try
        {
            await foreach (var evt in _agentService.ProcessMessageAsync(request, cancellationToken))
            {
                await HandleAgentEventAsync(evt, assistantMessage);

                if (cancellationToken.IsCancellationRequested)
                    break;
            }
        }
        catch (OperationCanceledException)
        {
            AgentActivityViewModel?.StopTracking(ExecutionEndReason.UserCancelled);
            assistantMessage.Content += "\n\n*[Execution cancelled]*";
        }
        catch (Exception ex)
        {
            AgentActivityViewModel?.StopTracking(ExecutionEndReason.Error, ex.Message);
            assistantMessage.Content += $"\n\n*[Error: {ex.Message}]*";
        }
        finally
        {
            _agentCancellationTokenSource?.Dispose();
            _agentCancellationTokenSource = null;
        }

        // Save conversation
        await _conversationService.SaveCurrentConversationAsync();
    }

    private async Task HandleAgentEventAsync(AgentEvent evt, ChatMessageViewModel assistantMessage)
    {
        switch (evt)
        {
            case TextGenerationEvent text:
                assistantMessage.Content += text.Token;
                break;

            case ThinkingEvent thinking:
                AgentActivityViewModel?.AddActivity(ActivityType.Thinking, thinking.Content);
                break;

            case ToolCallRequestEvent toolRequest:
                AgentActivityViewModel?.AddActivity(
                    ActivityType.Tool,
                    $"Tool: {toolRequest.ToolName}",
                    toolRequest.ParametersSummary);
                break;

            case ApprovalRequestEvent approval:
                PendingApproval = approval;
                AgentActivityViewModel?.AddActivity(
                    ActivityType.Approval,
                    $"Requesting approval: {approval.Summary}");

                var decision = await ShowApprovalDialogAsync(approval);
                approval.SetResult(decision);

                AgentActivityViewModel?.RecordApproval(decision.Approved, wasAutoApproved: false);
                PendingApproval = null;
                break;

            case ToolExecutionEvent execution:
                AgentActivityViewModel?.AddActivity(
                    ActivityType.Tool,
                    $"Executing: {execution.ToolName}");
                break;

            case ToolResultEvent result:
                var resultType = result.Result.Success ? ActivityType.Success : ActivityType.Error;
                AgentActivityViewModel?.AddActivity(
                    resultType,
                    result.Result.Success ? "Tool completed" : "Tool failed",
                    result.Result.Message);

                AgentActivityViewModel?.RecordToolExecution(
                    result.ToolId,
                    result.Result.Success,
                    result.Duration);

                // Add tool result to message
                assistantMessage.ToolResults.Add(new ToolResultDisplay
                {
                    ToolName = result.ToolId,
                    Success = result.Result.Success,
                    Summary = result.Result.Message,
                    Duration = result.Duration
                });
                break;

            case IterationEvent iteration:
                AgentActivityViewModel?.IncrementIteration();
                break;

            case AgentErrorEvent error:
                AgentActivityViewModel?.AddActivity(ActivityType.Error, error.Error);
                break;

            case AgentCompleteEvent complete:
                AgentActivityViewModel?.StopTracking(
                    ExecutionEndReason.Completed,
                    $"Completed: {complete.ToolCallsExecuted} tools in {complete.TotalDuration.TotalSeconds:F1}s");
                break;
        }
    }

    private async Task<ApprovalDecision> ShowApprovalDialogAsync(ApprovalRequestEvent approval)
    {
        // Create completion source for keyboard shortcuts
        _pendingApprovalTcs = new TaskCompletionSource<ApprovalDecision>();

        var dialog = new ToolApprovalDialog
        {
            DataContext = new ToolApprovalViewModel(approval.Request)
        };

        // Race between dialog result and keyboard shortcut
        var dialogTask = dialog.ShowDialog<ApprovalDecision?>(GetMainWindow());
        var shortcutTask = _pendingApprovalTcs.Task;

        var completedTask = await Task.WhenAny(dialogTask, shortcutTask);

        if (completedTask == shortcutTask)
        {
            // Keyboard shortcut was used, close dialog
            dialog.Close();
            return await shortcutTask;
        }
        else
        {
            // Dialog was used
            _pendingApprovalTcs = null;
            var result = await dialogTask;
            return result ?? new ApprovalDecision { Approved = false, Reason = "Dialog closed" };
        }
    }

    /// <summary>
    /// Toggle agent mode on/off.
    /// </summary>
    [RelayCommand]
    private void ToggleAgentMode()
    {
        IsAgentMode = !IsAgentMode;
    }

    /// <summary>
    /// Cancel the current agent execution.
    /// </summary>
    [RelayCommand(CanExecute = nameof(IsAgentActive))]
    private void CancelAgentExecution()
    {
        _agentCancellationTokenSource?.Cancel();
    }

    private void OnAgentStateChanged(object? sender, AgentState newState)
    {
        AgentState = newState;
    }

    // Message handlers
    void IRecipient<ToggleAgentModeMessage>.Receive(ToggleAgentModeMessage message)
    {
        ToggleAgentMode();
    }

    void IRecipient<CancelAgentExecutionMessage>.Receive(CancelAgentExecutionMessage message)
    {
        if (IsAgentActive)
            CancelAgentExecution();
    }

    void IRecipient<ApproveToolCallMessage>.Receive(ApproveToolCallMessage message)
    {
        if (_pendingApprovalTcs is not null && IsApprovalPending)
        {
            _pendingApprovalTcs.TrySetResult(new ApprovalDecision
            {
                Approved = true,
                RememberForSession = message.Remember
            });
        }
    }

    void IRecipient<DenyToolCallMessage>.Receive(DenyToolCallMessage message)
    {
        if (_pendingApprovalTcs is not null && IsApprovalPending)
        {
            _pendingApprovalTcs.TrySetResult(new ApprovalDecision
            {
                Approved = false,
                Reason = "Denied via keyboard shortcut"
            });
        }
    }
}
```

### Modification: `src/SeniorIntern.Desktop/ViewModels/ChatViewModel.cs`

Add agent mode branch to SendMessage:

```csharp
// Modify the existing SendMessageAsync method
[RelayCommand]
private async Task SendMessageAsync()
{
    if (IsAgentMode)
    {
        await SendAgentMessageAsync();
    }
    else
    {
        await SendRegularMessageAsync();
    }
}
```

### Modification: `src/SeniorIntern.Desktop/Views/ChatView.axaml`

Add agent activity panel and mode toggle:

```xml
<!-- Add to ChatView.axaml in appropriate location -->

<!-- Agent Mode Toggle in header -->
<ToggleButton Content="{Binding AgentModeText}"
              IsChecked="{Binding IsAgentMode}"
              Classes="agent-mode-toggle"
              ToolTip.Tip="Toggle agent mode (Ctrl+Shift+A)" />

<!-- Agent Activity Panel above input -->
<views:AgentActivityPanel DataContext="{Binding AgentActivityViewModel}"
                           Grid.Row="2" />
```

### Acceptance Criteria (v0.6.5h)
- [ ] Agent mode toggle works via button
- [ ] Agent mode toggle works via keyboard shortcut
- [ ] SendMessage routes to agent or regular based on mode
- [ ] Agent events handled and displayed in activity panel
- [ ] Approval dialog appears for risky tools
- [ ] Keyboard shortcuts work for approval/denial
- [ ] Cancellation stops agent execution
- [ ] Tool results displayed in message
- [ ] Conversation saved after agent completion
- [ ] Message handlers registered correctly

---

## v0.6.5i: AppSettings Agent Configuration

### Objective
Add agent settings to the application settings system.

### File: `src/SeniorIntern.Core/Interfaces/ISettingsService.cs`

Add to existing interface:

```csharp
namespace SeniorIntern.Core.Interfaces;

public partial interface ISettingsService
{
    /// <summary>
    /// Get agent settings.
    /// </summary>
    Task<AgentSettings> GetAgentSettingsAsync();

    /// <summary>
    /// Save agent settings.
    /// </summary>
    Task SaveAgentSettingsAsync(AgentSettings settings);
}
```

### Modification: `src/SeniorIntern.Core/Models/AppSettings.cs`

Add agent settings section:

```csharp
namespace SeniorIntern.Core.Models;

public partial class AppSettings
{
    /// <summary>
    /// Agent configuration settings.
    /// </summary>
    public AgentSettings Agent { get; set; } = new();
}
```

### Modification: `src/SeniorIntern.Services/SettingsService.cs`

Implement agent settings:

```csharp
public partial class SettingsService : ISettingsService
{
    public async Task<AgentSettings> GetAgentSettingsAsync()
    {
        var settings = await LoadSettingsAsync();
        return settings.Agent;
    }

    public async Task SaveAgentSettingsAsync(AgentSettings agentSettings)
    {
        var settings = await LoadSettingsAsync();
        settings.Agent = agentSettings;
        await SaveSettingsAsync(settings);
    }
}
```

### Acceptance Criteria (v0.6.5i)
- [ ] AgentSettings included in AppSettings
- [ ] GetAgentSettingsAsync returns current settings
- [ ] SaveAgentSettingsAsync persists settings
- [ ] Default values applied for new installations
- [ ] Settings survive application restart

---

## v0.6.5j: End-to-End Testing

### Objective
Create comprehensive end-to-end tests for the agent system.

### File: `tests/SeniorIntern.Tests.E2E/AgentFlowTests.cs`

```csharp
using System;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using Xunit;

namespace SeniorIntern.Tests.E2E;

/// <summary>
/// End-to-end tests for agent execution flow.
/// </summary>
public class AgentFlowTests : E2ETestBase
{
    private readonly IAgentService _agentService;
    private readonly IToolRegistry _toolRegistry;
    private readonly IPermissionManager _permissionManager;

    public AgentFlowTests()
    {
        _agentService = Services.GetRequiredService<IAgentService>();
        _toolRegistry = Services.GetRequiredService<IToolRegistry>();
        _permissionManager = Services.GetRequiredService<IPermissionManager>();
    }

    [Fact]
    public async Task SimpleMessage_NoToolCalls_CompletesSuccessfully()
    {
        // Arrange
        var request = new AgentRequest
        {
            Message = "Hello, how are you?",
            ConversationId = Guid.NewGuid(),
            History = new(),
            AttachedFiles = new()
        };

        var receivedText = "";
        var completed = false;

        // Act
        await foreach (var evt in _agentService.ProcessMessageAsync(request))
        {
            if (evt is TextGenerationEvent text)
                receivedText += text.Token;
            else if (evt is AgentCompleteEvent)
                completed = true;
        }

        // Assert
        Assert.True(completed);
        Assert.NotEmpty(receivedText);
    }

    [Fact]
    public async Task ToolCall_AutoApproved_ExecutesSuccessfully()
    {
        // Arrange
        await SetPolicyModeAsync(PolicyMode.AutoApprove);

        var request = new AgentRequest
        {
            Message = "List the files in the current directory",
            ConversationId = Guid.NewGuid(),
            History = new(),
            AttachedFiles = new(),
            ToolContext = new ToolAvailabilityContext
            {
                HasWorkspace = true,
                WorkspacePath = TestWorkspacePath
            }
        };

        var toolExecuted = false;
        var toolSucceeded = false;

        // Act
        await foreach (var evt in _agentService.ProcessMessageAsync(request))
        {
            if (evt is ToolExecutionEvent)
                toolExecuted = true;
            else if (evt is ToolResultEvent result)
                toolSucceeded = result.Result.Success;
        }

        // Assert
        Assert.True(toolExecuted);
        Assert.True(toolSucceeded);
    }

    [Fact]
    public async Task ToolCall_RequiresApproval_WaitsForDecision()
    {
        // Arrange
        await SetPolicyModeAsync(PolicyMode.AlwaysAsk);

        var request = new AgentRequest
        {
            Message = "Read the file test.txt",
            ConversationId = Guid.NewGuid(),
            History = new(),
            AttachedFiles = new(),
            ToolContext = new ToolAvailabilityContext
            {
                HasWorkspace = true,
                WorkspacePath = TestWorkspacePath
            }
        };

        var approvalRequested = false;
        ApprovalRequestEvent? approvalEvent = null;

        // Act
        await foreach (var evt in _agentService.ProcessMessageAsync(request))
        {
            if (evt is ApprovalRequestEvent approval)
            {
                approvalRequested = true;
                approvalEvent = approval;

                // Approve the request
                approval.SetResult(new ApprovalDecision { Approved = true });
            }
        }

        // Assert
        Assert.True(approvalRequested);
        Assert.NotNull(approvalEvent);
    }

    [Fact]
    public async Task ToolCall_Denied_StopsExecution()
    {
        // Arrange
        await SetPolicyModeAsync(PolicyMode.AlwaysAsk);

        var request = new AgentRequest
        {
            Message = "Delete all files",
            ConversationId = Guid.NewGuid(),
            History = new(),
            AttachedFiles = new(),
            ToolContext = new ToolAvailabilityContext
            {
                HasWorkspace = true,
                WorkspacePath = TestWorkspacePath
            }
        };

        ExecutionEndReason? endReason = null;

        // Act
        await foreach (var evt in _agentService.ProcessMessageAsync(request))
        {
            if (evt is ApprovalRequestEvent approval)
            {
                approval.SetResult(new ApprovalDecision { Approved = false, Reason = "Too dangerous" });
            }
            else if (evt is AgentCompleteEvent complete)
            {
                endReason = ExecutionEndReason.ToolDenied;
            }
        }

        // Assert
        Assert.Equal(ExecutionEndReason.ToolDenied, endReason);
    }

    [Fact]
    public async Task Cancellation_StopsExecution()
    {
        // Arrange
        var cts = new CancellationTokenSource();
        var request = new AgentRequest
        {
            Message = "Do a long running task",
            ConversationId = Guid.NewGuid(),
            History = new(),
            AttachedFiles = new()
        };

        var cancelled = false;

        // Act
        try
        {
            await foreach (var evt in _agentService.ProcessMessageAsync(request, cts.Token))
            {
                if (evt is TextGenerationEvent)
                {
                    // Cancel after receiving some text
                    cts.Cancel();
                }
            }
        }
        catch (OperationCanceledException)
        {
            cancelled = true;
        }

        // Assert
        Assert.True(cancelled);
    }

    [Fact]
    public async Task MultiStepExecution_CompletesAllSteps()
    {
        // Arrange
        await SetPolicyModeAsync(PolicyMode.AutoApprove);

        var request = new AgentRequest
        {
            Message = "Read test.txt, then write a summary to summary.txt",
            ConversationId = Guid.NewGuid(),
            History = new(),
            AttachedFiles = new(),
            ToolContext = new ToolAvailabilityContext
            {
                HasWorkspace = true,
                WorkspacePath = TestWorkspacePath
            }
        };

        var toolCalls = 0;

        // Act
        await foreach (var evt in _agentService.ProcessMessageAsync(request))
        {
            if (evt is ToolResultEvent)
                toolCalls++;
        }

        // Assert
        Assert.True(toolCalls >= 2);
    }

    [Fact]
    public async Task MaxIterations_StopsExecution()
    {
        // Arrange
        await SetMaxIterationsAsync(2);
        await SetPolicyModeAsync(PolicyMode.AutoApprove);

        var request = new AgentRequest
        {
            Message = "Keep searching until you find something",
            ConversationId = Guid.NewGuid(),
            History = new(),
            AttachedFiles = new(),
            ToolContext = new ToolAvailabilityContext
            {
                HasWorkspace = true,
                WorkspacePath = TestWorkspacePath
            }
        };

        ExecutionEndReason? endReason = null;
        var iterations = 0;

        // Act
        await foreach (var evt in _agentService.ProcessMessageAsync(request))
        {
            if (evt is IterationEvent)
                iterations++;
            else if (evt is AgentCompleteEvent complete)
                endReason = ExecutionEndReason.MaxIterationsReached;
        }

        // Assert
        Assert.Equal(2, iterations);
        Assert.Equal(ExecutionEndReason.MaxIterationsReached, endReason);
    }

    [Fact]
    public async Task AuditLog_RecordsExecutions()
    {
        // Arrange
        await SetPolicyModeAsync(PolicyMode.AutoApprove);
        await ClearAuditLogAsync();

        var request = new AgentRequest
        {
            Message = "List files in the directory",
            ConversationId = Guid.NewGuid(),
            History = new(),
            AttachedFiles = new(),
            ToolContext = new ToolAvailabilityContext
            {
                HasWorkspace = true,
                WorkspacePath = TestWorkspacePath
            }
        };

        // Act
        await foreach (var _ in _agentService.ProcessMessageAsync(request)) { }

        // Assert
        var auditRepo = Services.GetRequiredService<IAuditLogRepository>();
        var count = await auditRepo.GetCountAsync();
        Assert.True(count > 0);
    }

    private async Task SetPolicyModeAsync(PolicyMode mode)
    {
        var settingsService = Services.GetRequiredService<ISettingsService>();
        var settings = await settingsService.GetAgentSettingsAsync();
        settings.PolicyMode = mode;
        await settingsService.SaveAgentSettingsAsync(settings);
    }

    private async Task SetMaxIterationsAsync(int max)
    {
        var settingsService = Services.GetRequiredService<ISettingsService>();
        var settings = await settingsService.GetAgentSettingsAsync();
        settings.MaxIterations = max;
        await settingsService.SaveAgentSettingsAsync(settings);
    }

    private async Task ClearAuditLogAsync()
    {
        var auditRepo = Services.GetRequiredService<IAuditLogRepository>();
        await auditRepo.ClearAsync();
    }
}
```

### File: `tests/SeniorIntern.Tests.E2E/ToolChainingTests.cs`

```csharp
using System;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using Xunit;

namespace SeniorIntern.Tests.E2E;

/// <summary>
/// Tests for tool chaining and multi-tool scenarios.
/// </summary>
public class ToolChainingTests : E2ETestBase
{
    private readonly IAgentService _agentService;

    public ToolChainingTests()
    {
        _agentService = Services.GetRequiredService<IAgentService>();
    }

    [Fact]
    public async Task ReadThenWrite_ChainsToolsCorrectly()
    {
        // Arrange
        await SetupTestFileAsync("input.txt", "Hello World");

        var request = new AgentRequest
        {
            Message = "Read input.txt, convert to uppercase, and write to output.txt",
            ConversationId = Guid.NewGuid(),
            History = new(),
            AttachedFiles = new(),
            ToolContext = CreateToolContext()
        };

        // Act
        var toolResults = new System.Collections.Generic.List<ToolResultEvent>();
        await foreach (var evt in _agentService.ProcessMessageAsync(request))
        {
            if (evt is ToolResultEvent result)
                toolResults.Add(result);
        }

        // Assert
        Assert.True(toolResults.Count >= 2);
        Assert.True(toolResults.All(r => r.Result.Success));

        var outputContent = await ReadTestFileAsync("output.txt");
        Assert.Contains("HELLO WORLD", outputContent, StringComparison.OrdinalIgnoreCase);
    }

    [Fact]
    public async Task SearchThenRead_FindsAndReadsFile()
    {
        // Arrange
        await SetupTestFileAsync("data/config.json", "{ \"key\": \"value\" }");

        var request = new AgentRequest
        {
            Message = "Find a JSON file and read its contents",
            ConversationId = Guid.NewGuid(),
            History = new(),
            AttachedFiles = new(),
            ToolContext = CreateToolContext()
        };

        // Act
        var foundJson = false;
        await foreach (var evt in _agentService.ProcessMessageAsync(request))
        {
            if (evt is TextGenerationEvent text && text.Token.Contains("key"))
                foundJson = true;
        }

        // Assert
        Assert.True(foundJson);
    }

    [Fact]
    public async Task GitStatusThenDiff_ShowsChanges()
    {
        // Arrange
        await InitializeTestGitRepoAsync();
        await SetupTestFileAsync("changed.txt", "Modified content");

        var request = new AgentRequest
        {
            Message = "Show the git status and diff for any changed files",
            ConversationId = Guid.NewGuid(),
            History = new(),
            AttachedFiles = new(),
            ToolContext = CreateToolContext()
        };

        // Act
        var executedTools = new System.Collections.Generic.List<string>();
        await foreach (var evt in _agentService.ProcessMessageAsync(request))
        {
            if (evt is ToolExecutionEvent execution)
                executedTools.Add(execution.ToolName);
        }

        // Assert
        Assert.Contains("git_status", executedTools);
    }

    [Fact]
    public async Task ErrorInChain_ContinuesGracefully()
    {
        // Arrange
        var request = new AgentRequest
        {
            Message = "Read nonexistent.txt, if that fails read backup.txt instead",
            ConversationId = Guid.NewGuid(),
            History = new(),
            AttachedFiles = new(),
            ToolContext = CreateToolContext()
        };

        await SetupTestFileAsync("backup.txt", "Backup content");

        // Act
        var failedTools = 0;
        var succeededTools = 0;

        await foreach (var evt in _agentService.ProcessMessageAsync(request))
        {
            if (evt is ToolResultEvent result)
            {
                if (result.Result.Success)
                    succeededTools++;
                else
                    failedTools++;
            }
        }

        // Assert - agent should recover from failure
        Assert.True(succeededTools > 0 || failedTools > 0);
    }

    [Fact]
    public async Task ParallelToolCalls_ExecuteCorrectly()
    {
        // Arrange
        await SetupTestFileAsync("file1.txt", "Content 1");
        await SetupTestFileAsync("file2.txt", "Content 2");
        await SetupTestFileAsync("file3.txt", "Content 3");

        var request = new AgentRequest
        {
            Message = "Read file1.txt, file2.txt, and file3.txt and summarize their contents",
            ConversationId = Guid.NewGuid(),
            History = new(),
            AttachedFiles = new(),
            ToolContext = CreateToolContext()
        };

        // Act
        var readTools = 0;
        await foreach (var evt in _agentService.ProcessMessageAsync(request))
        {
            if (evt is ToolResultEvent result && result.ToolId.Contains("read"))
                readTools++;
        }

        // Assert
        Assert.True(readTools >= 3);
    }

    private ToolAvailabilityContext CreateToolContext()
    {
        return new ToolAvailabilityContext
        {
            HasWorkspace = true,
            WorkspacePath = TestWorkspacePath,
            HasTerminal = true
        };
    }
}
```

### File: `tests/SeniorIntern.Tests.E2E/ApprovalFlowTests.cs`

```csharp
using System;
using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using Xunit;

namespace SeniorIntern.Tests.E2E;

/// <summary>
/// Tests for the approval flow system.
/// </summary>
public class ApprovalFlowTests : E2ETestBase
{
    private readonly IAgentService _agentService;

    public ApprovalFlowTests()
    {
        _agentService = Services.GetRequiredService<IAgentService>();
    }

    [Fact]
    public async Task HighRiskTool_RequiresApproval()
    {
        // Arrange
        await SetPolicyModeAsync(PolicyMode.AskForRisky);
        await SetApprovalThresholdAsync(RiskLevel.High);

        var request = CreateRequestWithMessage("Run 'rm -rf temp' in the terminal");
        var approvalRequested = false;

        // Act
        await foreach (var evt in _agentService.ProcessMessageAsync(request))
        {
            if (evt is ApprovalRequestEvent approval)
            {
                approvalRequested = true;
                Assert.True(approval.Request.RiskLevel >= RiskLevel.High);
                approval.SetResult(new ApprovalDecision { Approved = false });
                break;
            }
        }

        // Assert
        Assert.True(approvalRequested);
    }

    [Fact]
    public async Task LowRiskTool_AutoApprovedWithThreshold()
    {
        // Arrange
        await SetPolicyModeAsync(PolicyMode.AskForRisky);
        await SetApprovalThresholdAsync(RiskLevel.High);

        var request = CreateRequestWithMessage("List the files in the current directory");
        var approvalRequested = false;
        var toolExecuted = false;

        // Act
        await foreach (var evt in _agentService.ProcessMessageAsync(request))
        {
            if (evt is ApprovalRequestEvent)
                approvalRequested = true;
            else if (evt is ToolExecutionEvent)
                toolExecuted = true;
        }

        // Assert
        Assert.False(approvalRequested);
        Assert.True(toolExecuted);
    }

    [Fact]
    public async Task RememberForSession_SkipsSubsequentApprovals()
    {
        // Arrange
        await SetPolicyModeAsync(PolicyMode.AlwaysAsk);

        var request1 = CreateRequestWithMessage("Read test.txt");
        var request2 = CreateRequestWithMessage("Read test.txt again");

        var approvalCount = 0;

        // Act - First request
        await foreach (var evt in _agentService.ProcessMessageAsync(request1))
        {
            if (evt is ApprovalRequestEvent approval)
            {
                approvalCount++;
                approval.SetResult(new ApprovalDecision
                {
                    Approved = true,
                    RememberForSession = true
                });
            }
        }

        // Act - Second request
        await foreach (var evt in _agentService.ProcessMessageAsync(request2))
        {
            if (evt is ApprovalRequestEvent)
                approvalCount++;
        }

        // Assert
        Assert.Equal(1, approvalCount);
    }

    [Fact]
    public async Task BlockedPattern_AutoDenies()
    {
        // Arrange
        await AddBlockedPatternAsync("rm -rf /");

        var request = CreateRequestWithMessage("Run 'rm -rf /' to clean up");
        var toolBlocked = false;

        // Act
        await foreach (var evt in _agentService.ProcessMessageAsync(request))
        {
            if (evt is AgentErrorEvent error && error.Error.Contains("blocked"))
                toolBlocked = true;
        }

        // Assert
        Assert.True(toolBlocked);
    }

    [Fact]
    public async Task ProtectedPath_PreventAccess()
    {
        // Arrange
        await AddProtectedPathAsync("/etc");

        var request = CreateRequestWithMessage("Read /etc/passwd");
        var accessDenied = false;

        // Act
        await foreach (var evt in _agentService.ProcessMessageAsync(request))
        {
            if (evt is ToolResultEvent result && !result.Result.Success)
                accessDenied = result.Result.Message.Contains("protected");
        }

        // Assert
        Assert.True(accessDenied);
    }

    [Fact]
    public async Task RateLimit_BlocksExcessiveCalls()
    {
        // Arrange
        await SetRateLimitAsync(perMinute: 2, perHour: 10);
        await SetPolicyModeAsync(PolicyMode.AutoApprove);

        var rateLimited = false;

        // Act - Make many requests
        for (int i = 0; i < 5; i++)
        {
            var request = CreateRequestWithMessage($"List files iteration {i}");

            await foreach (var evt in _agentService.ProcessMessageAsync(request))
            {
                if (evt is AgentErrorEvent error && error.Error.Contains("rate limit"))
                {
                    rateLimited = true;
                    break;
                }
            }

            if (rateLimited) break;
        }

        // Assert
        Assert.True(rateLimited);
    }

    private AgentRequest CreateRequestWithMessage(string message)
    {
        return new AgentRequest
        {
            Message = message,
            ConversationId = Guid.NewGuid(),
            History = new(),
            AttachedFiles = new(),
            ToolContext = new ToolAvailabilityContext
            {
                HasWorkspace = true,
                WorkspacePath = TestWorkspacePath,
                HasTerminal = true
            }
        };
    }

    private async Task SetPolicyModeAsync(PolicyMode mode)
    {
        var settingsService = Services.GetRequiredService<ISettingsService>();
        var settings = await settingsService.GetAgentSettingsAsync();
        settings.PolicyMode = mode;
        await settingsService.SaveAgentSettingsAsync(settings);
    }

    private async Task SetApprovalThresholdAsync(RiskLevel level)
    {
        var settingsService = Services.GetRequiredService<ISettingsService>();
        var settings = await settingsService.GetAgentSettingsAsync();
        settings.ApprovalThreshold = level;
        await settingsService.SaveAgentSettingsAsync(settings);
    }

    private async Task SetRateLimitAsync(int perMinute, int perHour)
    {
        var settingsService = Services.GetRequiredService<ISettingsService>();
        var settings = await settingsService.GetAgentSettingsAsync();
        settings.RateLimitPerMinute = perMinute;
        settings.RateLimitPerHour = perHour;
        await settingsService.SaveAgentSettingsAsync(settings);
    }

    private async Task AddBlockedPatternAsync(string pattern)
    {
        // Implementation would add to permission manager's blocked patterns
        var permissionManager = Services.GetRequiredService<IPermissionManager>();
        // await permissionManager.AddBlockedPatternAsync(pattern);
    }

    private async Task AddProtectedPathAsync(string path)
    {
        var settingsService = Services.GetRequiredService<ISettingsService>();
        var settings = await settingsService.GetAgentSettingsAsync();
        settings.ProtectedPaths.Add(path);
        await settingsService.SaveAgentSettingsAsync(settings);
    }
}
```

### File: `tests/SeniorIntern.Tests.E2E/E2ETestBase.cs`

```csharp
using System;
using System.IO;
using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;
using SeniorIntern.Core.Models;

namespace SeniorIntern.Tests.E2E;

/// <summary>
/// Base class for end-to-end tests.
/// </summary>
public abstract class E2ETestBase : IDisposable
{
    protected IServiceProvider Services { get; }
    protected string TestWorkspacePath { get; }

    protected E2ETestBase()
    {
        // Create test workspace
        TestWorkspacePath = Path.Combine(Path.GetTempPath(), $"si-test-{Guid.NewGuid()}");
        Directory.CreateDirectory(TestWorkspacePath);

        // Build service provider
        var services = new ServiceCollection();
        ConfigureServices(services);
        Services = services.BuildServiceProvider();
    }

    protected virtual void ConfigureServices(IServiceCollection services)
    {
        // Register all services needed for E2E tests
        // This would mirror the main application's DI setup
        services.AddSeniorInternCore();
        services.AddSeniorInternServices();
        services.AddSeniorInternTools();

        // Override settings for testing
        services.Configure<AgentSettings>(options =>
        {
            options.PolicyMode = PolicyMode.AutoApprove;
            options.MaxIterations = 10;
        });
    }

    protected async Task SetupTestFileAsync(string relativePath, string content)
    {
        var fullPath = Path.Combine(TestWorkspacePath, relativePath);
        var directory = Path.GetDirectoryName(fullPath);

        if (!string.IsNullOrEmpty(directory) && !Directory.Exists(directory))
            Directory.CreateDirectory(directory);

        await File.WriteAllTextAsync(fullPath, content);
    }

    protected async Task<string> ReadTestFileAsync(string relativePath)
    {
        var fullPath = Path.Combine(TestWorkspacePath, relativePath);
        return await File.ReadAllTextAsync(fullPath);
    }

    protected async Task InitializeTestGitRepoAsync()
    {
        var startInfo = new System.Diagnostics.ProcessStartInfo
        {
            WorkingDirectory = TestWorkspacePath,
            FileName = "git",
            Arguments = "init",
            RedirectStandardOutput = true,
            UseShellExecute = false
        };

        var process = System.Diagnostics.Process.Start(startInfo);
        await process!.WaitForExitAsync();
    }

    public void Dispose()
    {
        // Clean up test workspace
        try
        {
            if (Directory.Exists(TestWorkspacePath))
                Directory.Delete(TestWorkspacePath, recursive: true);
        }
        catch
        {
            // Ignore cleanup errors
        }
    }
}
```

### File: `tests/SeniorIntern.Tests.E2E/UIIntegrationTests.cs`

```csharp
using System;
using System.Threading.Tasks;
using Avalonia.Headless.XUnit;
using SeniorIntern.Desktop.ViewModels;
using Xunit;

namespace SeniorIntern.Tests.E2E;

/// <summary>
/// UI integration tests using Avalonia Headless.
/// </summary>
public class UIIntegrationTests
{
    [AvaloniaFact]
    public async Task AgentActivityPanel_ShowsProgress()
    {
        // Arrange
        var viewModel = new AgentActivityViewModel(null!); // Mock would be injected
        viewModel.StartTracking(Guid.NewGuid(), 10, new System.Threading.CancellationTokenSource());

        // Act
        viewModel.IncrementIteration();
        viewModel.AddActivity(Core.Models.ActivityType.Tool, "Executing tool");

        // Assert
        Assert.True(viewModel.IsAgentActive);
        Assert.Equal(1, viewModel.CurrentIteration);
        Assert.Single(viewModel.Activities, a => a.Type == Core.Models.ActivityType.Tool);
    }

    [AvaloniaFact]
    public async Task AgentSettingsViewModel_LoadsAndSaves()
    {
        // This would require mocking the services
        // Placeholder for UI integration test structure
        await Task.CompletedTask;
    }

    [AvaloniaFact]
    public async Task AuditLogViewer_FiltersCorrectly()
    {
        // This would require mocking the repository
        // Placeholder for UI integration test structure
        await Task.CompletedTask;
    }
}
```

### File: `tests/SeniorIntern.Tests.E2E/KeyboardShortcutTests.cs`

```csharp
using System.Threading.Tasks;
using Avalonia.Input;
using CommunityToolkit.Mvvm.Messaging;
using SeniorIntern.Desktop.Messages;
using SeniorIntern.Desktop.Services;
using Xunit;

namespace SeniorIntern.Tests.E2E;

/// <summary>
/// Tests for keyboard shortcut handling.
/// </summary>
public class KeyboardShortcutTests
{
    [Fact]
    public async Task ToggleAgentMode_SendsMessage()
    {
        // Arrange
        var messenger = new WeakReferenceMessenger();
        var service = new KeyboardShortcutService(messenger);
        var messageReceived = false;

        messenger.Register<ToggleAgentModeMessage>(this, (r, m) => messageReceived = true);

        var keyArgs = CreateKeyEventArgs(Key.A, KeyModifiers.Control | KeyModifiers.Shift);
        var context = new ShortcutContext();

        // Act
        await service.HandleKeyEventAsync(keyArgs, context);

        // Assert
        Assert.True(messageReceived);
    }

    [Fact]
    public async Task CancelExecution_OnlyWorksWhenActive()
    {
        // Arrange
        var messenger = new WeakReferenceMessenger();
        var service = new KeyboardShortcutService(messenger);
        var messageReceived = false;

        messenger.Register<CancelAgentExecutionMessage>(this, (r, m) => messageReceived = true);

        var keyArgs = CreateKeyEventArgs(Key.Escape, KeyModifiers.None);
        var inactiveContext = new ShortcutContext { IsAgentActive = false };

        // Act
        await service.HandleKeyEventAsync(keyArgs, inactiveContext);

        // Assert
        Assert.False(messageReceived);

        // Now with active agent
        var activeContext = new ShortcutContext { IsAgentActive = true };
        await service.HandleKeyEventAsync(keyArgs, activeContext);

        Assert.True(messageReceived);
    }

    [Fact]
    public async Task ApproveToolCall_OnlyWorksWhenPending()
    {
        // Arrange
        var messenger = new WeakReferenceMessenger();
        var service = new KeyboardShortcutService(messenger);
        var messageReceived = false;

        messenger.Register<ApproveToolCallMessage>(this, (r, m) => messageReceived = true);

        var keyArgs = CreateKeyEventArgs(Key.Enter, KeyModifiers.None);
        var noPendingContext = new ShortcutContext { IsApprovalPending = false };

        // Act
        await service.HandleKeyEventAsync(keyArgs, noPendingContext);

        // Assert
        Assert.False(messageReceived);

        // Now with pending approval
        var pendingContext = new ShortcutContext { IsApprovalPending = true };
        await service.HandleKeyEventAsync(keyArgs, pendingContext);

        Assert.True(messageReceived);
    }

    [Fact]
    public void GetAllShortcuts_ReturnsRegisteredShortcuts()
    {
        // Arrange
        var messenger = new WeakReferenceMessenger();
        var service = new KeyboardShortcutService(messenger);

        // Act
        var shortcuts = service.GetAllShortcuts();

        // Assert
        Assert.NotEmpty(shortcuts);
        Assert.Contains(shortcuts, s => s.Value.Name == "Toggle Agent Mode");
    }

    private KeyEventArgs CreateKeyEventArgs(Key key, KeyModifiers modifiers)
    {
        // Create a mock KeyEventArgs
        // In real tests, this would use Avalonia's test infrastructure
        return new KeyEventArgs
        {
            Key = key,
            KeyModifiers = modifiers
        };
    }
}
```

### File: `tests/SeniorIntern.Tests.E2E/CancellationTests.cs`

```csharp
using System;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using Xunit;

namespace SeniorIntern.Tests.E2E;

/// <summary>
/// Tests for cancellation behavior.
/// </summary>
public class CancellationTests : E2ETestBase
{
    private readonly IAgentService _agentService;

    public CancellationTests()
    {
        _agentService = Services.GetRequiredService<IAgentService>();
    }

    [Fact]
    public async Task CancellationDuringThinking_StopsImmediately()
    {
        // Arrange
        var cts = new CancellationTokenSource();
        var request = CreateLongRequest();
        var eventsReceived = 0;

        // Act
        try
        {
            await foreach (var evt in _agentService.ProcessMessageAsync(request, cts.Token))
            {
                eventsReceived++;
                if (eventsReceived >= 2)
                    cts.Cancel();
            }
        }
        catch (OperationCanceledException)
        {
            // Expected
        }

        // Assert
        Assert.True(eventsReceived < 10); // Should stop early
    }

    [Fact]
    public async Task CancellationDuringToolExecution_StopsGracefully()
    {
        // Arrange
        await SetPolicyModeAsync(PolicyMode.AutoApprove);
        var cts = new CancellationTokenSource();
        var request = CreateToolRequest();
        var toolStarted = false;
        var toolCompleted = false;

        // Act
        try
        {
            await foreach (var evt in _agentService.ProcessMessageAsync(request, cts.Token))
            {
                if (evt is ToolExecutionEvent)
                {
                    toolStarted = true;
                    cts.Cancel();
                }
                else if (evt is ToolResultEvent)
                {
                    toolCompleted = true;
                }
            }
        }
        catch (OperationCanceledException)
        {
            // Expected
        }

        // Assert
        Assert.True(toolStarted);
        // Tool might or might not complete depending on timing
    }

    [Fact]
    public async Task CancellationDuringApproval_StopsWaiting()
    {
        // Arrange
        await SetPolicyModeAsync(PolicyMode.AlwaysAsk);
        var cts = new CancellationTokenSource();
        var request = CreateToolRequest();
        var approvalRequested = false;

        // Act
        var task = Task.Run(async () =>
        {
            await foreach (var evt in _agentService.ProcessMessageAsync(request, cts.Token))
            {
                if (evt is ApprovalRequestEvent)
                {
                    approvalRequested = true;
                    // Don't respond to approval, let cancellation happen
                }
            }
        });

        // Wait a bit then cancel
        await Task.Delay(100);
        cts.Cancel();

        // Assert
        await Assert.ThrowsAsync<OperationCanceledException>(() => task);
        Assert.True(approvalRequested);
    }

    private AgentRequest CreateLongRequest()
    {
        return new AgentRequest
        {
            Message = "Write a very long and detailed essay about the history of computing",
            ConversationId = Guid.NewGuid(),
            History = new(),
            AttachedFiles = new()
        };
    }

    private AgentRequest CreateToolRequest()
    {
        return new AgentRequest
        {
            Message = "List the files in the current directory",
            ConversationId = Guid.NewGuid(),
            History = new(),
            AttachedFiles = new(),
            ToolContext = new ToolAvailabilityContext
            {
                HasWorkspace = true,
                WorkspacePath = TestWorkspacePath
            }
        };
    }

    private async Task SetPolicyModeAsync(PolicyMode mode)
    {
        var settingsService = Services.GetRequiredService<ISettingsService>();
        var settings = await settingsService.GetAgentSettingsAsync();
        settings.PolicyMode = mode;
        await settingsService.SaveAgentSettingsAsync(settings);
    }
}
```

### Acceptance Criteria (v0.6.5j)
- [ ] E2ETestBase provides test infrastructure
- [ ] AgentFlowTests cover basic execution paths
- [ ] ToolChainingTests verify multi-tool scenarios
- [ ] ApprovalFlowTests test permission system
- [ ] UIIntegrationTests use Avalonia Headless
- [ ] KeyboardShortcutTests verify shortcut handling
- [ ] CancellationTests verify proper cleanup
- [ ] All tests pass in CI pipeline

---

## File Summary

### Files to Create (32 total)

| File | Sub-version |
|------|-------------|
| `src/SeniorIntern.Core/Models/AgentActivityItem.cs` | v0.6.5a |
| `src/SeniorIntern.Core/Models/ActivityType.cs` | v0.6.5a |
| `src/SeniorIntern.Core/Models/AgentExecutionSummary.cs` | v0.6.5a |
| `src/SeniorIntern.Core/Models/ToolResultDisplay.cs` | v0.6.5a |
| `src/SeniorIntern.Desktop/Views/AgentActivityPanel.axaml` | v0.6.5b |
| `src/SeniorIntern.Desktop/Views/AgentActivityPanel.axaml.cs` | v0.6.5b |
| `src/SeniorIntern.Desktop/Converters/ActivityTypeConverters.cs` | v0.6.5b |
| `src/SeniorIntern.Desktop/ViewModels/AgentActivityViewModel.cs` | v0.6.5c |
| `src/SeniorIntern.Core/Events/AgentStateChangedEventArgs.cs` | v0.6.5c |
| `src/SeniorIntern.Desktop/Views/AgentSettingsPanel.axaml` | v0.6.5d |
| `src/SeniorIntern.Desktop/Views/AgentSettingsPanel.axaml.cs` | v0.6.5d |
| `src/SeniorIntern.Desktop/Models/ToolPermissionItem.cs` | v0.6.5d |
| `src/SeniorIntern.Desktop/ViewModels/AgentSettingsViewModel.cs` | v0.6.5e |
| `src/SeniorIntern.Core/Models/AgentSettings.cs` | v0.6.5e |
| `src/SeniorIntern.Desktop/Views/AuditLogViewer.axaml` | v0.6.5f |
| `src/SeniorIntern.Desktop/Views/AuditLogViewer.axaml.cs` | v0.6.5f |
| `src/SeniorIntern.Desktop/ViewModels/AuditLogViewerViewModel.cs` | v0.6.5f |
| `src/SeniorIntern.Desktop/Converters/AuditConverters.cs` | v0.6.5f |
| `src/SeniorIntern.Desktop/Services/KeyboardShortcutService.cs` | v0.6.5g |
| `src/SeniorIntern.Desktop/Messages/ShortcutMessages.cs` | v0.6.5g |
| `src/SeniorIntern.Desktop/Views/ShortcutHelpDialog.axaml` | v0.6.5g |
| `src/SeniorIntern.Desktop/ViewModels/ChatViewModel.Agent.cs` | v0.6.5h |
| `src/SeniorIntern.Core/Interfaces/ISettingsService.Agent.cs` | v0.6.5i |
| `tests/SeniorIntern.Tests.E2E/AgentFlowTests.cs` | v0.6.5j |
| `tests/SeniorIntern.Tests.E2E/ToolChainingTests.cs` | v0.6.5j |
| `tests/SeniorIntern.Tests.E2E/ApprovalFlowTests.cs` | v0.6.5j |
| `tests/SeniorIntern.Tests.E2E/E2ETestBase.cs` | v0.6.5j |
| `tests/SeniorIntern.Tests.E2E/UIIntegrationTests.cs` | v0.6.5j |
| `tests/SeniorIntern.Tests.E2E/KeyboardShortcutTests.cs` | v0.6.5j |
| `tests/SeniorIntern.Tests.E2E/CancellationTests.cs` | v0.6.5j |
| `tests/SeniorIntern.Tests.E2E/SeniorIntern.Tests.E2E.csproj` | v0.6.5j |

### Files to Modify (5 total)

| File | Sub-version | Changes |
|------|-------------|---------|
| `src/SeniorIntern.Desktop/Views/MainWindow.axaml.cs` | v0.6.5g | Add keyboard event handling |
| `src/SeniorIntern.Desktop/ViewModels/ChatViewModel.cs` | v0.6.5h | Add agent mode branch |
| `src/SeniorIntern.Desktop/Views/ChatView.axaml` | v0.6.5h | Add activity panel and toggle |
| `src/SeniorIntern.Core/Models/AppSettings.cs` | v0.6.5i | Add Agent property |
| `src/SeniorIntern.Services/SettingsService.cs` | v0.6.5i | Implement agent settings methods |

---

## Testing Strategy

### Unit Tests
- AgentActivityViewModel state management
- AgentSettingsViewModel settings loading/saving
- KeyboardShortcutService shortcut handling
- AuditLogViewerViewModel filtering

### Integration Tests
- Agent mode in ChatViewModel
- Keyboard shortcuts to message flow
- Settings persistence

### End-to-End Tests
- Complete agent flows
- Tool chaining
- Approval flows
- Cancellation behavior
- UI interactions

---

## Dependencies

### NuGet Packages (No new packages required for v0.6.5)
All required packages should already be present from v0.6.1-v0.6.4.

### Internal Dependencies
- v0.6.4 Safety & Approval system
- v0.6.3 Built-in Tools
- v0.6.2 Semantic Kernel Integration
- v0.6.1 Tool Framework

---

## Acceptance Criteria Summary

### v0.6.5 Complete
- [ ] Agent activity panel shows execution progress
- [ ] Agent settings panel allows full configuration
- [ ] Audit log viewer provides transparency
- [ ] Keyboard shortcuts work for all actions
- [ ] Chat integrates seamlessly with agent mode
- [ ] Settings persist across sessions
- [ ] All E2E tests pass
- [ ] Documentation complete
