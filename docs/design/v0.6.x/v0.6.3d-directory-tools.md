# Design Specification: AIntern v0.6.3d "Directory Tools"

## Overview

**Version**: v0.6.3d
**Parent**: v0.6.3 Built-in Tools
**Focus**: ListDirectoryTool, CreateDirectoryTool, and DeleteDirectoryTool

### Purpose

Implement directory tools that enable the AI agent to:
1. List directory contents with filtering and sorting options
2. Support recursive listing with depth limits
3. Include or exclude hidden files
4. Calculate and display file sizes
5. Create new directories with automatic parent creation
6. Delete directories (with confirmation for non-empty)
7. Provide formatted tree-style output

### Dependencies

**From v0.6.3a (File Read Tools)**:
- `ToolPathHelper` for path validation
- `PathValidationResult` for validation responses

**From v0.6.1 (Tool Framework)**:
- `ToolBase`, `ToolResult`
- `JsonSchemaBuilder`, `RiskLevel`

**From v0.3.x (Workspace Awareness)**:
- `IWorkspaceService`, `IFileSystemService`

---

## Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    v0.6.3d Directory Tools Architecture                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  src/SeniorIntern.Services/Tools/FileSystem/                                 â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                                                                          â”‚ â”‚
â”‚  â”‚  ListDirectoryTool : ToolBase                                            â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚ â”‚
â”‚  â”‚  â”‚  Id: "directory-list"                                                â”‚â”‚ â”‚
â”‚  â”‚  â”‚  DefaultRiskLevel: Safe                                              â”‚â”‚ â”‚
â”‚  â”‚  â”‚                                                                      â”‚â”‚ â”‚
â”‚  â”‚  â”‚  Parameters                                                           â”‚â”‚ â”‚
â”‚  â”‚  â”‚  â”œâ”€â”€ path: string (default: ".") - Directory to list                 â”‚â”‚ â”‚
â”‚  â”‚  â”‚  â”œâ”€â”€ recursive: bool (default: false)                                â”‚â”‚ â”‚
â”‚  â”‚  â”‚  â”œâ”€â”€ max_depth: int (default: 3, max: 10)                            â”‚â”‚ â”‚
â”‚  â”‚  â”‚  â”œâ”€â”€ include_hidden: bool (default: false)                           â”‚â”‚ â”‚
â”‚  â”‚  â”‚  â”œâ”€â”€ include_size: bool (default: true)                              â”‚â”‚ â”‚
â”‚  â”‚  â”‚  â””â”€â”€ sort_by: string (name|size|modified)                            â”‚â”‚ â”‚
â”‚  â”‚  â”‚                                                                      â”‚â”‚ â”‚
â”‚  â”‚  â”‚  Constants                                                            â”‚â”‚ â”‚
â”‚  â”‚  â”‚  â”œâ”€â”€ MaxEntries = 1000                                               â”‚â”‚ â”‚
â”‚  â”‚  â”‚  â””â”€â”€ DefaultMaxDepth = 3                                             â”‚â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚ â”‚
â”‚  â”‚                                                                          â”‚ â”‚
â”‚  â”‚  CreateDirectoryTool : ToolBase                                          â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚ â”‚
â”‚  â”‚  â”‚  Id: "directory-create"                                              â”‚â”‚ â”‚
â”‚  â”‚  â”‚  DefaultRiskLevel: Low                                               â”‚â”‚ â”‚
â”‚  â”‚  â”‚                                                                      â”‚â”‚ â”‚
â”‚  â”‚  â”‚  Parameters                                                           â”‚â”‚ â”‚
â”‚  â”‚  â”‚  â””â”€â”€ path: string (required) - Directory to create                   â”‚â”‚ â”‚
â”‚  â”‚  â”‚                                                                      â”‚â”‚ â”‚
â”‚  â”‚  â”‚  Features                                                             â”‚â”‚ â”‚
â”‚  â”‚  â”‚  â””â”€â”€ Automatic parent directory creation                             â”‚â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚ â”‚
â”‚  â”‚                                                                          â”‚ â”‚
â”‚  â”‚  DeleteDirectoryTool : ToolBase                                          â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚ â”‚
â”‚  â”‚  â”‚  Id: "directory-delete"                                              â”‚â”‚ â”‚
â”‚  â”‚  â”‚  DefaultRiskLevel: High (Critical if recursive)                      â”‚â”‚ â”‚
â”‚  â”‚  â”‚                                                                      â”‚â”‚ â”‚
â”‚  â”‚  â”‚  Parameters                                                           â”‚â”‚ â”‚
â”‚  â”‚  â”‚  â”œâ”€â”€ path: string (required) - Directory to delete                   â”‚â”‚ â”‚
â”‚  â”‚  â”‚  â””â”€â”€ recursive: bool (default: false)                                â”‚â”‚ â”‚
â”‚  â”‚  â”‚                                                                      â”‚â”‚ â”‚
â”‚  â”‚  â”‚  Features                                                             â”‚â”‚ â”‚
â”‚  â”‚  â”‚  â”œâ”€â”€ Empty directory only (by default)                               â”‚â”‚ â”‚
â”‚  â”‚  â”‚  â””â”€â”€ Recursive deletion with explicit flag                           â”‚â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚ â”‚
â”‚  â”‚                                                                          â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â”‚  src/SeniorIntern.Core/Models/                                               â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                                                                          â”‚ â”‚
â”‚  â”‚  DirectoryEntry                       ListDirectoryResultData            â”‚ â”‚
â”‚  â”‚  â”œâ”€â”€ Name: string                     â”œâ”€â”€ Path: string                   â”‚ â”‚
â”‚  â”‚  â”œâ”€â”€ Type: string (file|directory)   â”œâ”€â”€ TotalEntries: int              â”‚ â”‚
â”‚  â”‚  â”œâ”€â”€ Size: long                       â”œâ”€â”€ FileCount: int                 â”‚ â”‚
â”‚  â”‚  â””â”€â”€ Modified: DateTime               â”œâ”€â”€ DirectoryCount: int            â”‚ â”‚
â”‚  â”‚                                        â”œâ”€â”€ TotalSize: long               â”‚ â”‚
â”‚  â”‚                                        â””â”€â”€ WasTruncated: bool            â”‚ â”‚
â”‚  â”‚                                                                          â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Output Format

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      ListDirectoryTool Output Format                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  Default (flat) listing:                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  ğŸ“ src                                                                 â”‚ â”‚
â”‚  â”‚  ğŸ“ tests                                                               â”‚ â”‚
â”‚  â”‚  ğŸ“„ README.md (2.5 KB)                                                  â”‚ â”‚
â”‚  â”‚  ğŸ“„ package.json (1.2 KB)                                               â”‚ â”‚
â”‚  â”‚  ğŸ“„ .gitignore (348 B)                                                  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â”‚  Recursive (tree) listing:                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  ğŸ“ src                                                                 â”‚ â”‚
â”‚  â”‚  ğŸ“ src/components                                                      â”‚ â”‚
â”‚  â”‚  ğŸ“„ src/components/App.tsx (4.2 KB)                                    â”‚ â”‚
â”‚  â”‚  ğŸ“„ src/components/Header.tsx (1.8 KB)                                 â”‚ â”‚
â”‚  â”‚  ğŸ“„ src/index.ts (256 B)                                               â”‚ â”‚
â”‚  â”‚  ğŸ“ tests                                                               â”‚ â”‚
â”‚  â”‚  ğŸ“„ tests/App.test.tsx (892 B)                                         â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â”‚  Sort by size:                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  ğŸ“„ node_modules/lodash/lodash.js (547 KB)                             â”‚ â”‚
â”‚  â”‚  ğŸ“„ dist/bundle.js (128 KB)                                            â”‚ â”‚
â”‚  â”‚  ğŸ“„ src/components/App.tsx (4.2 KB)                                    â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Execution Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      ListDirectoryTool Execution Flow                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  ExecuteAsync(context)                                                       â”‚
â”‚      â”‚                                                                       â”‚
â”‚      â–¼                                                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                             â”‚
â”‚  â”‚  1. Extract Parameters      â”‚                                             â”‚
â”‚  â”‚  path, recursive, max_depth â”‚                                             â”‚
â”‚  â”‚  include_hidden, sort_by    â”‚                                             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                             â”‚
â”‚                â”‚                                                             â”‚
â”‚                â–¼                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                             â”‚
â”‚  â”‚  2. Validate Path           â”‚                                             â”‚
â”‚  â”‚  ToolPathHelper.ValidatePathâ”‚                                             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                             â”‚
â”‚                â”‚                                                             â”‚
â”‚                â–¼                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                             â”‚
â”‚  â”‚  3. Check Directory Exists  â”‚                                             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                             â”‚
â”‚                â”‚                                                             â”‚
â”‚                â–¼                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                             â”‚
â”‚  â”‚  4. Collect Entries         â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                               â”‚
â”‚  â”‚  CollectEntriesAsync()      â”‚             â”‚                               â”‚
â”‚  â”‚  â”œâ”€â”€ Enumerate directories  â”‚             â”‚ Recursive                     â”‚
â”‚  â”‚  â”œâ”€â”€ Enumerate files        â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ (depth < maxDepth)            â”‚
â”‚  â”‚  â””â”€â”€ Check MaxEntries limit â”‚                                             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                             â”‚
â”‚                â”‚                                                             â”‚
â”‚                â–¼                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                             â”‚
â”‚  â”‚  5. Sort Entries            â”‚                                             â”‚
â”‚  â”‚  â”œâ”€â”€ By name (default)      â”‚                                             â”‚
â”‚  â”‚  â”œâ”€â”€ By size                â”‚                                             â”‚
â”‚  â”‚  â””â”€â”€ By modified            â”‚                                             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                             â”‚
â”‚                â”‚                                                             â”‚
â”‚                â–¼                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                             â”‚
â”‚  â”‚  6. Check Truncation        â”‚                                             â”‚
â”‚  â”‚  (entries > MaxEntries)     â”‚                                             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                             â”‚
â”‚                â”‚                                                             â”‚
â”‚                â–¼                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                             â”‚
â”‚  â”‚  7. Format Output           â”‚                                             â”‚
â”‚  â”‚  â”œâ”€â”€ Icons (ğŸ“/ğŸ“„)          â”‚                                             â”‚
â”‚  â”‚  â”œâ”€â”€ Relative paths         â”‚                                             â”‚
â”‚  â”‚  â””â”€â”€ File sizes             â”‚                                             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                             â”‚
â”‚                â”‚                                                             â”‚
â”‚                â–¼                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                             â”‚
â”‚  â”‚  8. Build Result            â”‚                                             â”‚
â”‚  â”‚  â”œâ”€â”€ Formatted output       â”‚                                             â”‚
â”‚  â”‚  â”œâ”€â”€ ListDirectoryResultDataâ”‚                                             â”‚
â”‚  â”‚  â””â”€â”€ Summary message        â”‚                                             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                             â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## File Specifications

### 1. ListDirectoryTool.cs

**Location**: `src/SeniorIntern.Services/Tools/FileSystem/ListDirectoryTool.cs`

```csharp
namespace SeniorIntern.Services.Tools.FileSystem;

using System.Text;
using System.Text.Json;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Core.Tools;
using SeniorIntern.Services.Tools;

/// <summary>
/// Tool for listing directory contents.
/// </summary>
/// <remarks>
/// <para>
/// ListDirectoryTool enables the AI agent to explore the workspace structure:
/// </para>
/// <list type="bullet">
/// <item>Flat or recursive listing</item>
/// <item>Hidden file filtering</item>
/// <item>Sort by name, size, or modification date</item>
/// <item>Truncation for large directories</item>
/// </list>
/// </remarks>
public sealed class ListDirectoryTool : ToolBase
{
    #region Tool Metadata

    public override string Id => "directory-list";

    public override string Name => "List Directory";

    public override string Description => """
        List files and directories at a given path.
        Returns names, types, sizes, and modification dates.

        Use this to explore the workspace structure and find files.
        """;

    public override ToolCategory Category => ToolCategory.FileSystem;

    public override RiskLevel DefaultRiskLevel => RiskLevel.Safe;

    public override IReadOnlyList<string> Tags => new[] { "directory", "list", "files", "explore" };

    public override JsonSchema InputSchema => JsonSchemaBuilder.Create()
        .WithDescription("Parameters for listing a directory")
        .AddString("path", "Directory path (default: workspace root)", required: false)
        .AddBoolean("recursive", "List contents recursively (default: false)", required: false)
        .AddInteger("max_depth", "Maximum recursion depth (default: 3)", required: false)
        .AddBoolean("include_hidden", "Include hidden files/directories (default: false)", required: false)
        .AddBoolean("include_size", "Calculate file sizes (default: true)", required: false)
        .AddString("sort_by", "Sort by: name, size, modified (default: name)", required: false)
        .Build();

    #endregion

    #region Dependencies

    private readonly IFileSystemService _fileSystem;
    private readonly IWorkspaceService _workspace;
    private readonly ILogger<ListDirectoryTool> _logger;

    #endregion

    #region Constants

    /// <summary>
    /// Maximum number of entries to return.
    /// </summary>
    public const int MaxEntries = 1000;

    /// <summary>
    /// Default maximum recursion depth.
    /// </summary>
    public const int DefaultMaxDepth = 3;

    /// <summary>
    /// Maximum allowed recursion depth.
    /// </summary>
    public const int MaxAllowedDepth = 10;

    /// <summary>
    /// Valid sort options.
    /// </summary>
    private static readonly string[] ValidSortOptions = { "name", "size", "modified" };

    #endregion

    public ListDirectoryTool(
        IFileSystemService fileSystem,
        IWorkspaceService workspace,
        ILogger<ListDirectoryTool> logger)
    {
        _fileSystem = fileSystem ?? throw new ArgumentNullException(nameof(fileSystem));
        _workspace = workspace ?? throw new ArgumentNullException(nameof(workspace));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    public override bool IsAvailable => _workspace.CurrentWorkspace != null;

    #region ExecuteAsync

    public override async Task<ToolResult> ExecuteAsync(
        ToolExecutionContext context,
        CancellationToken ct = default)
    {
        // Extract parameters
        var path = GetOptionalParameter(context.Parameters, "path", ".");
        var recursive = GetOptionalParameter(context.Parameters, "recursive", false);
        var maxDepth = Math.Min(
            GetOptionalParameter(context.Parameters, "max_depth", DefaultMaxDepth),
            MaxAllowedDepth);
        var includeHidden = GetOptionalParameter(context.Parameters, "include_hidden", false);
        var includeSize = GetOptionalParameter(context.Parameters, "include_size", true);
        var sortBy = GetOptionalParameter(context.Parameters, "sort_by", "name");

        _logger.LogDebug(
            "ListDirectoryTool executing: path={Path}, recursive={Recursive}, depth={Depth}",
            path, recursive, maxDepth);

        // Resolve and validate path
        var fullPath = ToolPathHelper.ResolvePath(context.WorkspacePath, path);
        var pathValidation = ToolPathHelper.ValidatePath(fullPath, context.WorkspacePath);

        if (!pathValidation.IsValid)
        {
            return ToolResult.Failed(pathValidation.ErrorMessage!);
        }

        // Check directory exists
        if (!await _fileSystem.DirectoryExistsAsync(fullPath, ct))
        {
            return ToolResult.Failed($"Directory not found: {path}");
        }

        try
        {
            var entries = new List<DirectoryEntry>();

            await CollectEntriesAsync(
                fullPath,
                context.WorkspacePath!,
                recursive,
                maxDepth,
                currentDepth: 0,
                includeHidden,
                includeSize,
                entries,
                ct);

            // Sort entries
            entries = SortEntries(entries, sortBy);

            // Check truncation
            var wasTruncated = entries.Count > MaxEntries;
            if (wasTruncated)
            {
                entries = entries.Take(MaxEntries).ToList();
            }

            // Format output
            var output = FormatOutput(entries);

            var resultData = new ListDirectoryResultData
            {
                Path = path,
                TotalEntries = entries.Count,
                FileCount = entries.Count(e => e.Type == "file"),
                DirectoryCount = entries.Count(e => e.Type == "directory"),
                TotalSize = entries.Where(e => e.Type == "file").Sum(e => e.Size),
                WasTruncated = wasTruncated
            };

            var message = wasTruncated
                ? $"Found {entries.Count}+ items in {path} (truncated)"
                : $"Found {entries.Count} items in {path}";

            _logger.LogInformation(
                "ListDirectoryTool success: {Path}, entries={Count}, truncated={Truncated}",
                path, entries.Count, wasTruncated);

            return ToolResult.Success(output, resultData, message);
        }
        catch (UnauthorizedAccessException ex)
        {
            _logger.LogWarning(ex, "Access denied to directory: {Path}", path);
            return ToolResult.Failed($"Access denied: {path}");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to list directory: {Path}", path);
            return ToolResult.Failed($"Failed to list directory: {ex.Message}");
        }
    }

    #endregion

    #region Entry Collection

    /// <summary>
    /// Recursively collect directory entries.
    /// </summary>
    private async Task CollectEntriesAsync(
        string path,
        string workspacePath,
        bool recursive,
        int maxDepth,
        int currentDepth,
        bool includeHidden,
        bool includeSize,
        List<DirectoryEntry> entries,
        CancellationToken ct)
    {
        // Stop if we've reached limits
        if (entries.Count >= MaxEntries) return;
        if (recursive && currentDepth > maxDepth) return;

        var options = new EnumerationOptions
        {
            AttributesToSkip = includeHidden ? 0 : FileAttributes.Hidden,
            IgnoreInaccessible = true
        };

        // Collect directories first
        foreach (var dir in Directory.EnumerateDirectories(path, "*", options))
        {
            ct.ThrowIfCancellationRequested();
            if (entries.Count >= MaxEntries) break;

            var relativePath = Path.GetRelativePath(workspacePath, dir);
            entries.Add(new DirectoryEntry
            {
                Name = relativePath,
                Type = "directory",
                Size = 0,
                Modified = Directory.GetLastWriteTimeUtc(dir)
            });

            // Recurse into subdirectories
            if (recursive)
            {
                await CollectEntriesAsync(
                    dir, workspacePath, recursive, maxDepth, currentDepth + 1,
                    includeHidden, includeSize, entries, ct);
            }
        }

        // Collect files
        foreach (var file in Directory.EnumerateFiles(path, "*", options))
        {
            ct.ThrowIfCancellationRequested();
            if (entries.Count >= MaxEntries) break;

            var fileInfo = new FileInfo(file);
            var relativePath = Path.GetRelativePath(workspacePath, file);

            entries.Add(new DirectoryEntry
            {
                Name = relativePath,
                Type = "file",
                Size = includeSize ? fileInfo.Length : 0,
                Modified = fileInfo.LastWriteTimeUtc
            });
        }
    }

    #endregion

    #region Sorting

    /// <summary>
    /// Sort entries by specified field.
    /// </summary>
    private static List<DirectoryEntry> SortEntries(List<DirectoryEntry> entries, string sortBy)
    {
        return sortBy.ToLowerInvariant() switch
        {
            "size" => entries
                .OrderByDescending(e => e.Size)
                .ThenBy(e => e.Name)
                .ToList(),
            "modified" => entries
                .OrderByDescending(e => e.Modified)
                .ThenBy(e => e.Name)
                .ToList(),
            _ => entries
                .OrderBy(e => e.Type) // Directories first
                .ThenBy(e => e.Name)
                .ToList()
        };
    }

    #endregion

    #region Output Formatting

    /// <summary>
    /// Format entries for display.
    /// </summary>
    private static string FormatOutput(List<DirectoryEntry> entries)
    {
        if (entries.Count == 0)
        {
            return "(empty directory)";
        }

        var sb = new StringBuilder();

        foreach (var entry in entries)
        {
            var icon = entry.Type == "directory" ? "ğŸ“" : "ğŸ“„";
            var size = entry.Type == "file" && entry.Size > 0
                ? $" ({ToolPathHelper.FormatFileSize(entry.Size)})"
                : "";

            sb.AppendLine($"{icon} {entry.Name}{size}");
        }

        return sb.ToString().TrimEnd();
    }

    #endregion

    #region Overrides

    public override string GetExecutionSummary(JsonElement parameters)
    {
        var path = parameters.TryGetProperty("path", out var p) ? p.GetString() : ".";
        var recursive = parameters.TryGetProperty("recursive", out var r) && r.GetBoolean();

        var shortPath = path?.Length > 30 ? "..." + path[^27..] : path ?? ".";
        return recursive ? $"List '{shortPath}' recursively" : $"List '{shortPath}'";
    }

    public override ToolValidationResult Validate(JsonElement parameters)
    {
        var errors = new List<ToolValidationError>();

        // Validate sort_by if provided
        if (parameters.TryGetProperty("sort_by", out var sortProp))
        {
            var sort = sortProp.GetString()?.ToLowerInvariant();
            if (!string.IsNullOrEmpty(sort) && !ValidSortOptions.Contains(sort))
            {
                errors.Add(new ToolValidationError
                {
                    ParameterName = "sort_by",
                    Message = $"Invalid sort option. Valid: {string.Join(", ", ValidSortOptions)}",
                    Code = "INVALID_VALUE"
                });
            }
        }

        // Validate max_depth if provided
        if (parameters.TryGetProperty("max_depth", out var depthProp))
        {
            var depth = depthProp.GetInt32();
            if (depth < 1 || depth > MaxAllowedDepth)
            {
                errors.Add(new ToolValidationError
                {
                    ParameterName = "max_depth",
                    Message = $"Depth must be between 1 and {MaxAllowedDepth}",
                    Code = "INVALID_RANGE"
                });
            }
        }

        return errors.Count > 0
            ? ToolValidationResult.Invalid(errors)
            : ToolValidationResult.Valid();
    }

    #endregion
}
```

### 2. CreateDirectoryTool.cs

**Location**: `src/SeniorIntern.Services/Tools/FileSystem/CreateDirectoryTool.cs`

```csharp
namespace SeniorIntern.Services.Tools.FileSystem;

using System.Text.Json;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Core.Tools;
using SeniorIntern.Services.Tools;

/// <summary>
/// Tool for creating directories.
/// </summary>
/// <remarks>
/// Parent directories are created automatically if they don't exist.
/// If the directory already exists, success is returned with a note.
/// </remarks>
public sealed class CreateDirectoryTool : ToolBase
{
    #region Tool Metadata

    public override string Id => "directory-create";

    public override string Name => "Create Directory";

    public override string Description => """
        Create a new directory in the workspace.
        Parent directories are created automatically if they don't exist.
        """;

    public override ToolCategory Category => ToolCategory.FileSystem;

    public override RiskLevel DefaultRiskLevel => RiskLevel.Low;

    public override IReadOnlyList<string> Tags => new[] { "directory", "create", "folder" };

    public override JsonSchema InputSchema => JsonSchemaBuilder.Create()
        .WithDescription("Parameters for creating a directory")
        .AddString("path", "Path for the new directory", required: true)
        .Build();

    #endregion

    #region Dependencies

    private readonly IFileSystemService _fileSystem;
    private readonly IWorkspaceService _workspace;
    private readonly ILogger<CreateDirectoryTool> _logger;

    #endregion

    public CreateDirectoryTool(
        IFileSystemService fileSystem,
        IWorkspaceService workspace,
        ILogger<CreateDirectoryTool> logger)
    {
        _fileSystem = fileSystem ?? throw new ArgumentNullException(nameof(fileSystem));
        _workspace = workspace ?? throw new ArgumentNullException(nameof(workspace));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    public override bool IsAvailable => _workspace.CurrentWorkspace != null;

    #region ExecuteAsync

    public override async Task<ToolResult> ExecuteAsync(
        ToolExecutionContext context,
        CancellationToken ct = default)
    {
        var path = GetRequiredParameter<string>(context.Parameters, "path");

        _logger.LogDebug("CreateDirectoryTool executing: path={Path}", path);

        // Resolve and validate path
        var fullPath = ToolPathHelper.ResolvePath(context.WorkspacePath, path);
        var pathValidation = ToolPathHelper.ValidatePath(fullPath, context.WorkspacePath);

        if (!pathValidation.IsValid)
        {
            return ToolResult.Failed(pathValidation.ErrorMessage!);
        }

        // Check if already exists
        if (await _fileSystem.DirectoryExistsAsync(fullPath, ct))
        {
            _logger.LogDebug("Directory already exists: {Path}", path);
            return ToolResult.Success(
                content: null,
                new CreateDirectoryResultData
                {
                    Path = path,
                    AlreadyExisted = true,
                    Created = false
                },
                $"Directory already exists: {path}");
        }

        try
        {
            await _fileSystem.CreateDirectoryAsync(fullPath, ct);

            _logger.LogInformation("Created directory: {Path}", path);

            return ToolResult.Success(
                content: null,
                new CreateDirectoryResultData
                {
                    Path = path,
                    AlreadyExisted = false,
                    Created = true,
                    CreatedAt = DateTime.UtcNow
                },
                $"Created directory: {path}");
        }
        catch (UnauthorizedAccessException ex)
        {
            _logger.LogWarning(ex, "Access denied to create directory: {Path}", path);
            return ToolResult.Failed($"Access denied: {path}");
        }
        catch (IOException ex)
        {
            _logger.LogError(ex, "Failed to create directory: {Path}", path);
            return ToolResult.Failed($"Failed to create directory: {ex.Message}");
        }
    }

    #endregion

    #region Overrides

    public override string GetExecutionSummary(JsonElement parameters)
    {
        var path = parameters.TryGetProperty("path", out var p)
            ? p.GetString() ?? "?"
            : "?";
        return $"Create directory '{path}'";
    }

    public override ToolValidationResult Validate(JsonElement parameters)
    {
        var errors = new List<ToolValidationError>();

        if (!parameters.TryGetProperty("path", out var pathProp) ||
            string.IsNullOrWhiteSpace(pathProp.GetString()))
        {
            errors.Add(ToolValidationError.Required("path"));
        }

        return errors.Count > 0
            ? ToolValidationResult.Invalid(errors)
            : ToolValidationResult.Valid();
    }

    #endregion
}
```

### 3. DeleteDirectoryTool.cs

**Location**: `src/SeniorIntern.Services/Tools/FileSystem/DeleteDirectoryTool.cs`

```csharp
namespace SeniorIntern.Services.Tools.FileSystem;

using System.Text.Json;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Core.Tools;
using SeniorIntern.Services.Tools;

/// <summary>
/// Tool for deleting directories.
/// </summary>
/// <remarks>
/// <para>
/// By default, only empty directories can be deleted. Use the recursive
/// flag to delete non-empty directories, which increases risk level.
/// </para>
/// </remarks>
public sealed class DeleteDirectoryTool : ToolBase
{
    #region Tool Metadata

    public override string Id => "directory-delete";

    public override string Name => "Delete Directory";

    public override string Description => """
        Delete a directory from the workspace.
        By default, only empty directories can be deleted.
        Set recursive=true to delete non-empty directories (use with caution).
        """;

    public override ToolCategory Category => ToolCategory.FileSystem;

    public override RiskLevel DefaultRiskLevel => RiskLevel.High;

    public override IReadOnlyList<string> Tags => new[] { "directory", "delete", "remove", "folder" };

    public override JsonSchema InputSchema => JsonSchemaBuilder.Create()
        .WithDescription("Parameters for deleting a directory")
        .AddString("path", "Path to the directory to delete", required: true)
        .AddBoolean("recursive", "Delete non-empty directories (default: false)", required: false)
        .Build();

    #endregion

    #region Dependencies

    private readonly IFileSystemService _fileSystem;
    private readonly IWorkspaceService _workspace;
    private readonly ILogger<DeleteDirectoryTool> _logger;

    #endregion

    public DeleteDirectoryTool(
        IFileSystemService fileSystem,
        IWorkspaceService workspace,
        ILogger<DeleteDirectoryTool> logger)
    {
        _fileSystem = fileSystem ?? throw new ArgumentNullException(nameof(fileSystem));
        _workspace = workspace ?? throw new ArgumentNullException(nameof(workspace));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    public override bool IsAvailable => _workspace.CurrentWorkspace != null;

    #region ExecuteAsync

    public override async Task<ToolResult> ExecuteAsync(
        ToolExecutionContext context,
        CancellationToken ct = default)
    {
        var path = GetRequiredParameter<string>(context.Parameters, "path");
        var recursive = GetOptionalParameter(context.Parameters, "recursive", false);

        _logger.LogDebug(
            "DeleteDirectoryTool executing: path={Path}, recursive={Recursive}",
            path, recursive);

        // Resolve and validate path
        var fullPath = ToolPathHelper.ResolvePath(context.WorkspacePath, path);
        var pathValidation = ToolPathHelper.ValidatePath(fullPath, context.WorkspacePath);

        if (!pathValidation.IsValid)
        {
            return ToolResult.Failed(pathValidation.ErrorMessage!);
        }

        // Prevent deleting workspace root
        if (ToolPathHelper.NormalizePath(fullPath) ==
            ToolPathHelper.NormalizePath(context.WorkspacePath!))
        {
            return ToolResult.Failed("Cannot delete workspace root directory");
        }

        // Check directory exists
        if (!await _fileSystem.DirectoryExistsAsync(fullPath, ct))
        {
            return ToolResult.Failed($"Directory not found: {path}");
        }

        try
        {
            // Check if empty (when not recursive)
            if (!recursive)
            {
                var hasContents = Directory.EnumerateFileSystemEntries(fullPath).Any();
                if (hasContents)
                {
                    return ToolResult.Failed(
                        $"Directory is not empty: {path}. Set recursive=true to delete with contents.");
                }
            }

            // Count contents for result data
            var (fileCount, dirCount) = recursive
                ? CountContents(fullPath)
                : (0, 0);

            // Delete the directory
            await _fileSystem.DeleteDirectoryAsync(fullPath, recursive, ct);

            var resultData = new DeleteDirectoryResultData
            {
                Path = path,
                WasRecursive = recursive,
                FilesDeleted = fileCount,
                DirectoriesDeleted = dirCount,
                DeletedAt = DateTime.UtcNow
            };

            var message = recursive && (fileCount > 0 || dirCount > 0)
                ? $"Deleted directory: {path} ({fileCount} files, {dirCount} subdirectories)"
                : $"Deleted directory: {path}";

            _logger.LogInformation(
                "DeleteDirectoryTool success: {Path}, recursive={Recursive}, files={Files}",
                path, recursive, fileCount);

            return ToolResult.Success(content: null, resultData, message);
        }
        catch (UnauthorizedAccessException ex)
        {
            _logger.LogWarning(ex, "Access denied to delete directory: {Path}", path);
            return ToolResult.Failed($"Access denied: {path}");
        }
        catch (IOException ex)
        {
            _logger.LogError(ex, "Failed to delete directory: {Path}", path);
            return ToolResult.Failed($"Failed to delete directory: {ex.Message}");
        }
    }

    #endregion

    #region Helper Methods

    /// <summary>
    /// Count files and directories in a directory tree.
    /// </summary>
    private static (int FileCount, int DirCount) CountContents(string path)
    {
        try
        {
            var files = Directory.GetFiles(path, "*", SearchOption.AllDirectories).Length;
            var dirs = Directory.GetDirectories(path, "*", SearchOption.AllDirectories).Length;
            return (files, dirs);
        }
        catch
        {
            return (0, 0);
        }
    }

    #endregion

    #region Overrides

    public override string GetExecutionSummary(JsonElement parameters)
    {
        var path = parameters.TryGetProperty("path", out var p)
            ? p.GetString() ?? "?"
            : "?";
        var recursive = parameters.TryGetProperty("recursive", out var r) && r.GetBoolean();

        return recursive
            ? $"Delete directory '{path}' (recursive)"
            : $"Delete directory '{path}'";
    }

    public override RiskLevel GetEffectiveRiskLevel(JsonElement parameters)
    {
        var recursive = parameters.TryGetProperty("recursive", out var r) && r.GetBoolean();

        // Recursive deletion is critical risk
        return recursive ? RiskLevel.Critical : RiskLevel.High;
    }

    public override ToolValidationResult Validate(JsonElement parameters)
    {
        var errors = new List<ToolValidationError>();

        if (!parameters.TryGetProperty("path", out var pathProp) ||
            string.IsNullOrWhiteSpace(pathProp.GetString()))
        {
            errors.Add(ToolValidationError.Required("path"));
        }

        return errors.Count > 0
            ? ToolValidationResult.Invalid(errors)
            : ToolValidationResult.Valid();
    }

    #endregion
}
```

### 4. Result Data Models

**Location**: `src/SeniorIntern.Core/Models/DirectoryToolResultData.cs`

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// An entry in a directory listing.
/// </summary>
public sealed class DirectoryEntry
{
    /// <summary>Relative path name.</summary>
    public string Name { get; init; } = string.Empty;

    /// <summary>Entry type: "file" or "directory".</summary>
    public string Type { get; init; } = string.Empty;

    /// <summary>File size in bytes (0 for directories).</summary>
    public long Size { get; init; }

    /// <summary>Last modification time.</summary>
    public DateTime Modified { get; init; }

    /// <summary>Whether this is a directory.</summary>
    public bool IsDirectory => Type == "directory";

    /// <summary>Whether this is a file.</summary>
    public bool IsFile => Type == "file";
}

/// <summary>
/// Result data for directory listing operations.
/// </summary>
public sealed class ListDirectoryResultData
{
    /// <summary>Listed directory path.</summary>
    public string Path { get; init; } = string.Empty;

    /// <summary>Total entries returned.</summary>
    public int TotalEntries { get; init; }

    /// <summary>Number of files.</summary>
    public int FileCount { get; init; }

    /// <summary>Number of subdirectories.</summary>
    public int DirectoryCount { get; init; }

    /// <summary>Total size of all files in bytes.</summary>
    public long TotalSize { get; init; }

    /// <summary>Whether results were truncated.</summary>
    public bool WasTruncated { get; init; }

    /// <summary>Human-readable total size.</summary>
    public string FormattedTotalSize => ToolPathHelper.FormatFileSize(TotalSize);
}

/// <summary>
/// Result data for directory creation.
/// </summary>
public sealed class CreateDirectoryResultData
{
    /// <summary>Created directory path.</summary>
    public string Path { get; init; } = string.Empty;

    /// <summary>Whether the directory already existed.</summary>
    public bool AlreadyExisted { get; init; }

    /// <summary>Whether the directory was created.</summary>
    public bool Created { get; init; }

    /// <summary>When the directory was created.</summary>
    public DateTime? CreatedAt { get; init; }
}

/// <summary>
/// Result data for directory deletion.
/// </summary>
public sealed class DeleteDirectoryResultData
{
    /// <summary>Deleted directory path.</summary>
    public string Path { get; init; } = string.Empty;

    /// <summary>Whether recursive deletion was used.</summary>
    public bool WasRecursive { get; init; }

    /// <summary>Number of files deleted (if recursive).</summary>
    public int FilesDeleted { get; init; }

    /// <summary>Number of subdirectories deleted (if recursive).</summary>
    public int DirectoriesDeleted { get; init; }

    /// <summary>When the directory was deleted.</summary>
    public DateTime DeletedAt { get; init; }
}
```

---

## IFileSystemService Extensions

Add these methods to the existing `IFileSystemService` interface:

```csharp
// In src/SeniorIntern.Core/Interfaces/IFileSystemService.cs

/// <summary>
/// Create a directory (and all parent directories).
/// </summary>
Task CreateDirectoryAsync(string path, CancellationToken ct = default);

/// <summary>
/// Delete a directory.
/// </summary>
/// <param name="path">Path to directory.</param>
/// <param name="recursive">Whether to delete contents.</param>
Task DeleteDirectoryAsync(string path, bool recursive, CancellationToken ct = default);
```

---

## File Summary

| File | Location | Purpose | Lines |
|------|----------|---------|-------|
| `ListDirectoryTool.cs` | `Services/Tools/FileSystem/` | List directory contents | ~280 |
| `CreateDirectoryTool.cs` | `Services/Tools/FileSystem/` | Create directories | ~120 |
| `DeleteDirectoryTool.cs` | `Services/Tools/FileSystem/` | Delete directories | ~170 |
| `DirectoryToolResultData.cs` | `Core/Models/` | Result data models | ~90 |

---

## Unit Test Plan

| Test | Description |
|------|-------------|
| `ListDirectoryTool_RootDir_ReturnsContents` | Basic listing |
| `ListDirectoryTool_Recursive_RespectsMaxDepth` | Depth limiting |
| `ListDirectoryTool_HiddenFiles_FilteredByDefault` | Hidden file filter |
| `ListDirectoryTool_SortBySize_OrdersCorrectly` | Size sorting |
| `ListDirectoryTool_SortByModified_OrdersCorrectly` | Date sorting |
| `ListDirectoryTool_LargeDir_Truncates` | MaxEntries limit |
| `CreateDirectoryTool_NewPath_CreatesDirectory` | Basic creation |
| `CreateDirectoryTool_Existing_ReturnsSuccess` | Idempotent |
| `CreateDirectoryTool_NestedPath_CreatesParents` | Parent creation |
| `DeleteDirectoryTool_EmptyDir_Deletes` | Empty deletion |
| `DeleteDirectoryTool_NonEmpty_RequiresRecursive` | Non-empty protection |
| `DeleteDirectoryTool_Recursive_DeletesContents` | Recursive deletion |
| `DeleteDirectoryTool_WorkspaceRoot_Blocked` | Root protection |

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | ListDirectoryTool returns files and directories |
| AC-2 | Recursive listing respects max depth |
| AC-3 | Hidden files are optionally included |
| AC-4 | Results are sorted by name/size/date |
| AC-5 | CreateDirectoryTool creates nested directories |
| AC-6 | Large directories are properly truncated |
| AC-7 | DeleteDirectoryTool protects non-empty dirs |

---

## Changelog Entry

```markdown
## v0.6.3d - Directory Tools

### Added
- `ListDirectoryTool` for exploring workspace structure
  - Flat and recursive listing
  - Hidden file filtering
  - Sort by name, size, or modified date
  - 1000 entry truncation limit
  - Max depth limit (default: 3, max: 10)
- `CreateDirectoryTool` for creating directories
  - Automatic parent directory creation
  - Idempotent (success if exists)
- `DeleteDirectoryTool` for removing directories
  - Empty directory only (by default)
  - Recursive deletion with explicit flag
  - Critical risk level for recursive
  - Workspace root protection
- `DirectoryEntry` model for listing entries
- Result data models for all directory operations
```

---

## Timeline Estimate

| Version | Estimated Effort |
|---------|------------------|
| v0.6.3d | 0.5 day |
