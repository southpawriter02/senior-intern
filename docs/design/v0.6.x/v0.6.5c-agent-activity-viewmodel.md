# Design Specification: AIntern v0.6.5c "Agent Activity ViewModel"

## Overview

**Version**: v0.6.5c
**Parent**: v0.6.5 Agent Loop & Polish
**Focus**: ViewModel implementation for the agent activity panel with full state management

### Purpose

Implement the ViewModel that:
1. Tracks agent execution state (active, processing, paused)
2. Manages the activity log collection
3. Tracks iteration progress and statistics
4. Provides cancellation capability
5. Responds to agent state changes
6. Maintains execution summary statistics

### Dependencies

**From v0.6.5a (Agent Activity Models)**:
- `AgentActivityItem`, `ActivityType`
- `AgentExecutionSummary`, `ExecutionEndReason`

**From v0.6.5b (Agent Activity Panel XAML)**:
- Bound to by the activity panel UI

**From v0.6.2 (Semantic Kernel Integration)**:
- `IAgentService`, `AgentState`

**From MVVM Toolkit**:
- `ObservableProperty`, `RelayCommand`, `NotifyPropertyChangedFor`

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                    v0.6.5c Agent Activity ViewModel Architecture              │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Class Diagram:                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                    AgentActivityViewModel                                │ │
│  │  (inherits ViewModelBase, implements IDisposable)                       │ │
│  ├─────────────────────────────────────────────────────────────────────────┤ │
│  │                                                                          │ │
│  │  Dependencies:                                                           │ │
│  │  ├── IAgentService _agentService                                        │ │
│  │  └── CancellationTokenSource? _cancellationTokenSource                  │ │
│  │                                                                          │ │
│  │  Observable Properties:                                                  │ │
│  │  ├── IsAgentActive: bool                                                │ │
│  │  ├── IsProcessing: bool                                                 │ │
│  │  ├── IsPaused: bool                                                     │ │
│  │  ├── IsCompleted: bool                                                  │ │
│  │  ├── HasError: bool                                                     │ │
│  │  ├── AgentStateText: string                                             │ │
│  │  ├── CurrentIteration: int                                              │ │
│  │  ├── MaxIterations: int                                                 │ │
│  │  ├── IsIndeterminate: bool                                              │ │
│  │  ├── ShowIterationCounter: bool                                         │ │
│  │  ├── Activities: ObservableCollection<AgentActivityItem>                │ │
│  │  └── ExecutionSummary: AgentExecutionSummary?                           │ │
│  │                                                                          │ │
│  │  Computed Properties:                                                    │ │
│  │  ├── ProgressPercent: double                                            │ │
│  │  └── CanCancel: bool                                                    │ │
│  │                                                                          │ │
│  │  Commands:                                                               │ │
│  │  └── CancelCommand: IRelayCommand                                       │ │
│  │                                                                          │ │
│  │  Public Methods:                                                         │ │
│  │  ├── StartTracking(conversationId, maxIterations, cts)                  │ │
│  │  ├── StopTracking(reason, errorMessage?)                                │ │
│  │  ├── AddActivity(type, message, details?, toolId?)                      │ │
│  │  ├── CompleteActivity(activityId, success, duration, details?)          │ │
│  │  ├── IncrementIteration()                                               │ │
│  │  ├── RecordToolExecution(toolName, success, duration)                   │ │
│  │  ├── RecordApproval(approved, wasAutoApproved)                          │ │
│  │  └── Dispose()                                                          │ │
│  │                                                                          │ │
│  │  Event Handlers:                                                         │ │
│  │  └── OnAgentStateChanged(sender, newState)                              │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  Event Flow:                                                                 │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  IAgentService.StateChanged                                              │ │
│  │         │                                                                │ │
│  │         ▼                                                                │ │
│  │  OnAgentStateChanged()                                                   │ │
│  │         │                                                                │ │
│  │         ├──→ Update AgentStateText                                      │ │
│  │         ├──→ Update IsProcessing                                        │ │
│  │         └──→ Update IsPaused                                            │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## State Management Flow

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                        State Management Flow                                  │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Execution Lifecycle:                                                        │
│                                                                              │
│  StartTracking() ──────────────────────────────────────────────────────────►│
│       │                                                                      │
│       ├── Set IsAgentActive = true                                          │
│       ├── Set IsProcessing = true                                           │
│       ├── Set IsPaused = false                                              │
│       ├── Set IsIndeterminate = true                                        │
│       ├── Clear Activities                                                  │
│       ├── Create new ExecutionSummary                                       │
│       └── Add "Agent execution started" activity                            │
│       │                                                                      │
│       ▼                                                                      │
│  [Agent Running]                                                             │
│       │                                                                      │
│       ├── AgentState changes trigger OnAgentStateChanged()                  │
│       │   ├── Thinking → IsProcessing=true, "Thinking..."                   │
│       │   ├── WaitingForApproval → IsPaused=true, "Waiting for approval"    │
│       │   ├── ExecutingTool → IsProcessing=true, "Executing tool..."        │
│       │   └── etc.                                                          │
│       │                                                                      │
│       ├── IncrementIteration() called per LLM call                          │
│       │   ├── CurrentIteration++                                            │
│       │   ├── IsIndeterminate = false (now determinate)                     │
│       │   └── Update ExecutionSummary.IterationCount                        │
│       │                                                                      │
│       ├── AddActivity() for each notable event                              │
│       │   └── Posts to UI thread, adds to collection                        │
│       │                                                                      │
│       ├── RecordToolExecution() after each tool                             │
│       │   └── Updates ExecutionSummary statistics                           │
│       │                                                                      │
│       └── RecordApproval() after each approval decision                     │
│           └── Updates ExecutionSummary statistics                           │
│       │                                                                      │
│       ▼                                                                      │
│  StopTracking(reason) ─────────────────────────────────────────────────────►│
│       │                                                                      │
│       ├── Set IsAgentActive = false                                         │
│       ├── Set IsProcessing = false                                          │
│       ├── Set IsPaused = false                                              │
│       ├── Update ExecutionSummary (EndTime, EndReason, ErrorMessage)        │
│       ├── Add final activity (Success/Error/Cancelled based on reason)     │
│       └── Clear _cancellationTokenSource                                    │
│                                                                              │
│  Cancel Flow:                                                                │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │  User clicks "Cancel" button                                             ││
│  │         │                                                                ││
│  │         ▼                                                                ││
│  │  CancelCommand.Execute()                                                 ││
│  │         │                                                                ││
│  │         ├── Guard: CanCancel returns false → exit                       ││
│  │         ├── Call _cancellationTokenSource.Cancel()                       ││
│  │         ├── Add "Cancellation requested" activity                        ││
│  │         └── Set AgentStateText = "Cancelling..."                         ││
│  │         │                                                                ││
│  │         ▼                                                                ││
│  │  Agent loop detects cancellation                                         ││
│  │         │                                                                ││
│  │         ▼                                                                ││
│  │  StopTracking(UserCancelled) called                                      ││
│  └─────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Specifications

### 1. AgentActivityViewModel.cs

**Location**: `src/SeniorIntern.Desktop/ViewModels/AgentActivityViewModel.cs`

```csharp
namespace SeniorIntern.Desktop.ViewModels;

using System;
using System.Collections.ObjectModel;
using System.Threading;
using Avalonia.Threading;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using SeniorIntern.Core.Events;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;

/// <summary>
/// ViewModel for the agent activity panel.
/// </summary>
/// <remarks>
/// <para>
/// This ViewModel manages the state and data for the agent activity panel,
/// which displays real-time information about agent execution, including
/// the activity log, progress, and provides cancellation capability.
/// </para>
/// <para>
/// The ViewModel subscribes to the <see cref="IAgentService.StateChanged"/>
/// event to receive updates about agent state transitions.
/// </para>
/// </remarks>
public partial class AgentActivityViewModel : ViewModelBase, IDisposable
{
    private readonly IAgentService _agentService;
    private CancellationTokenSource? _cancellationTokenSource;
    private bool _disposed;

    #region Observable Properties - State

    /// <summary>
    /// Whether the agent is currently active (executing a request).
    /// </summary>
    /// <remarks>
    /// When true, the activity panel is visible. When false, the panel is hidden.
    /// </remarks>
    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(CanCancel))]
    private bool _isAgentActive;

    /// <summary>
    /// Whether the agent is currently processing (thinking or executing).
    /// </summary>
    /// <remarks>
    /// When true, the progress ring is visible and active.
    /// </remarks>
    [ObservableProperty]
    private bool _isProcessing;

    /// <summary>
    /// Whether the agent is paused (waiting for user approval).
    /// </summary>
    /// <remarks>
    /// When true, the pause icon is shown and progress is frozen.
    /// </remarks>
    [ObservableProperty]
    private bool _isPaused;

    /// <summary>
    /// Whether the agent execution completed successfully.
    /// </summary>
    [ObservableProperty]
    private bool _isCompleted;

    /// <summary>
    /// Whether the agent execution encountered an error.
    /// </summary>
    [ObservableProperty]
    private bool _hasError;

    /// <summary>
    /// Human-readable text describing the current agent state.
    /// </summary>
    /// <example>"Thinking...", "Executing tool...", "Waiting for approval"</example>
    [ObservableProperty]
    private string _agentStateText = "Idle";

    #endregion

    #region Observable Properties - Progress

    /// <summary>
    /// Current iteration number (1-based).
    /// </summary>
    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(ProgressPercent))]
    private int _currentIteration;

    /// <summary>
    /// Maximum allowed iterations.
    /// </summary>
    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(ProgressPercent))]
    [NotifyPropertyChangedFor(nameof(ShowIterationCounter))]
    private int _maxIterations = 10;

    /// <summary>
    /// Whether the progress bar should be indeterminate.
    /// </summary>
    /// <remarks>
    /// Set to true initially, then false once iteration tracking begins.
    /// </remarks>
    [ObservableProperty]
    private bool _isIndeterminate = true;

    #endregion

    #region Observable Properties - Data

    /// <summary>
    /// Collection of activity items to display in the activity log.
    /// </summary>
    [ObservableProperty]
    private ObservableCollection<AgentActivityItem> _activities = new();

    /// <summary>
    /// Current execution summary with aggregated statistics.
    /// </summary>
    [ObservableProperty]
    private AgentExecutionSummary? _executionSummary;

    #endregion

    #region Computed Properties

    /// <summary>
    /// Progress percentage (0-100) for the progress bar.
    /// </summary>
    public double ProgressPercent => MaxIterations > 0
        ? (double)CurrentIteration / MaxIterations * 100
        : 0;

    /// <summary>
    /// Whether the iteration counter should be displayed.
    /// </summary>
    public bool ShowIterationCounter => MaxIterations > 0 && IsAgentActive;

    /// <summary>
    /// Whether cancellation is possible.
    /// </summary>
    /// <remarks>
    /// Returns true if agent is active and cancellation hasn't been requested.
    /// </remarks>
    public bool CanCancel => IsAgentActive &&
        _cancellationTokenSource is not null &&
        !_cancellationTokenSource.IsCancellationRequested;

    #endregion

    #region Constructor

    /// <summary>
    /// Initializes a new instance of the AgentActivityViewModel.
    /// </summary>
    /// <param name="agentService">The agent service to monitor.</param>
    public AgentActivityViewModel(IAgentService agentService)
    {
        _agentService = agentService ?? throw new ArgumentNullException(nameof(agentService));
        _agentService.StateChanged += OnAgentStateChanged;
    }

    #endregion

    #region Tracking Methods

    /// <summary>
    /// Start tracking a new agent execution.
    /// </summary>
    /// <param name="conversationId">The conversation ID for this execution.</param>
    /// <param name="maxIterations">Maximum number of iterations allowed.</param>
    /// <param name="cts">Cancellation token source for this execution.</param>
    public void StartTracking(Guid conversationId, int maxIterations, CancellationTokenSource cts)
    {
        ArgumentNullException.ThrowIfNull(cts);

        _cancellationTokenSource = cts;
        MaxIterations = maxIterations;
        CurrentIteration = 0;
        IsAgentActive = true;
        IsProcessing = true;
        IsPaused = false;
        IsCompleted = false;
        HasError = false;
        IsIndeterminate = true;
        AgentStateText = "Starting...";

        // Clear previous activities
        Dispatcher.UIThread.Post(() => Activities.Clear());

        // Create new execution summary
        ExecutionSummary = AgentExecutionSummary.Start(conversationId, maxIterations);

        // Add initial activity
        AddActivity(ActivityType.Info, "Agent execution started");

        // Notify CanCancel changed
        OnPropertyChanged(nameof(CanCancel));
    }

    /// <summary>
    /// Stop tracking and reset state.
    /// </summary>
    /// <param name="reason">The reason execution ended.</param>
    /// <param name="errorMessage">Error message if applicable.</param>
    public void StopTracking(ExecutionEndReason reason, string? errorMessage = null)
    {
        IsAgentActive = false;
        IsProcessing = false;
        IsPaused = false;
        IsCompleted = reason == ExecutionEndReason.Completed;
        HasError = reason.IsError();

        // Update execution summary
        if (ExecutionSummary is not null)
        {
            switch (reason)
            {
                case ExecutionEndReason.Completed:
                    ExecutionSummary.Complete();
                    break;
                case ExecutionEndReason.UserCancelled:
                    ExecutionSummary.Cancel();
                    break;
                case ExecutionEndReason.Error:
                    ExecutionSummary.Fail(errorMessage ?? "Unknown error");
                    break;
                case ExecutionEndReason.MaxIterationsReached:
                    ExecutionSummary.ReachMaxIterations();
                    break;
                case ExecutionEndReason.ToolDenied:
                    ExecutionSummary.ToolDenied();
                    break;
                case ExecutionEndReason.RateLimited:
                    ExecutionSummary.RateLimited();
                    break;
                case ExecutionEndReason.Timeout:
                    ExecutionSummary.Timeout();
                    break;
            }
        }

        // Build end message
        var endMessage = reason switch
        {
            ExecutionEndReason.Completed => "Agent completed successfully",
            ExecutionEndReason.UserCancelled => "Cancelled by user",
            ExecutionEndReason.MaxIterationsReached => "Maximum iterations reached",
            ExecutionEndReason.Error => $"Error: {errorMessage ?? "Unknown error"}",
            ExecutionEndReason.ToolDenied => "Stopped: Tool approval denied",
            ExecutionEndReason.RateLimited => "Rate limit exceeded",
            ExecutionEndReason.Timeout => "Execution timed out",
            _ => "Agent stopped"
        };

        // Determine activity type for final message
        var endType = reason switch
        {
            ExecutionEndReason.Completed => ActivityType.Success,
            ExecutionEndReason.UserCancelled => ActivityType.Cancelled,
            _ => ActivityType.Error
        };

        AddActivity(endType, endMessage);
        AgentStateText = reason.GetDisplayName();

        // Clean up
        _cancellationTokenSource = null;
        OnPropertyChanged(nameof(CanCancel));
    }

    #endregion

    #region Activity Methods

    /// <summary>
    /// Add an activity item to the log.
    /// </summary>
    /// <param name="type">Type of activity.</param>
    /// <param name="message">Activity message.</param>
    /// <param name="details">Optional detailed information.</param>
    /// <param name="toolId">Optional associated tool ID.</param>
    /// <param name="toolName">Optional associated tool name.</param>
    /// <returns>The ID of the created activity item.</returns>
    public Guid AddActivity(
        ActivityType type,
        string message,
        string? details = null,
        string? toolId = null,
        string? toolName = null)
    {
        var activity = new AgentActivityItem
        {
            Type = type,
            Message = message,
            Details = details,
            ToolId = toolId,
            ToolName = toolName
        };

        // Ensure UI thread for collection modification
        Dispatcher.UIThread.Post(() =>
        {
            Activities.Add(activity);

            // Limit collection size to prevent memory issues
            while (Activities.Count > 100)
            {
                Activities.RemoveAt(0);
            }
        });

        return activity.Id;
    }

    /// <summary>
    /// Add a thinking activity.
    /// </summary>
    public Guid AddThinking(string message = "Generating response...")
    {
        return AddActivity(ActivityType.Thinking, message);
    }

    /// <summary>
    /// Add a tool execution activity.
    /// </summary>
    public Guid AddToolExecution(string toolId, string toolName, string? details = null)
    {
        return AddActivity(
            ActivityType.Tool,
            $"Executing {toolName}",
            details,
            toolId,
            toolName);
    }

    /// <summary>
    /// Add an approval waiting activity.
    /// </summary>
    public Guid AddApprovalWaiting(string toolId, string toolName, string reason)
    {
        return AddActivity(
            ActivityType.Approval,
            $"Awaiting approval for {toolName}",
            reason,
            toolId,
            toolName);
    }

    /// <summary>
    /// Update an existing activity with completion info.
    /// </summary>
    /// <param name="activityId">ID of the activity to complete.</param>
    /// <param name="success">Whether the activity succeeded.</param>
    /// <param name="duration">Duration of the activity.</param>
    /// <param name="details">Optional completion details.</param>
    public void CompleteActivity(Guid activityId, bool success, TimeSpan duration, string? details = null)
    {
        Dispatcher.UIThread.Post(() =>
        {
            // Find the activity and update it
            for (int i = 0; i < Activities.Count; i++)
            {
                if (Activities[i].Id == activityId)
                {
                    Activities[i].Complete(success, duration, details);
                    break;
                }
            }
        });
    }

    #endregion

    #region Statistics Methods

    /// <summary>
    /// Increment the iteration counter.
    /// </summary>
    public void IncrementIteration()
    {
        CurrentIteration++;
        IsIndeterminate = false;

        ExecutionSummary?.RecordIteration();
    }

    /// <summary>
    /// Record a tool execution.
    /// </summary>
    /// <param name="toolName">Name of the tool.</param>
    /// <param name="success">Whether execution succeeded.</param>
    /// <param name="duration">Duration of execution.</param>
    public void RecordToolExecution(string toolName, bool success, TimeSpan duration)
    {
        ExecutionSummary?.RecordToolExecution(success);

        // Add completion activity
        AddActivity(
            success ? ActivityType.Success : ActivityType.Error,
            success ? $"{toolName} completed" : $"{toolName} failed",
            $"Duration: {duration.TotalSeconds:F1}s");
    }

    /// <summary>
    /// Record an approval decision.
    /// </summary>
    /// <param name="approved">Whether the tool was approved.</param>
    /// <param name="wasAutoApproved">Whether it was auto-approved.</param>
    public void RecordApproval(bool approved, bool wasAutoApproved)
    {
        ExecutionSummary?.RecordApproval(approved, wasAutoApproved);

        if (!approved)
        {
            AddActivity(ActivityType.Warning, "Tool execution denied by user");
        }
    }

    /// <summary>
    /// Record token usage.
    /// </summary>
    /// <param name="inputTokens">Number of input tokens.</param>
    /// <param name="outputTokens">Number of output tokens.</param>
    public void RecordTokens(int inputTokens, int outputTokens)
    {
        ExecutionSummary?.RecordTokens(inputTokens, outputTokens);
    }

    #endregion

    #region Commands

    /// <summary>
    /// Cancel the current agent execution.
    /// </summary>
    [RelayCommand(CanExecute = nameof(CanCancel))]
    private void Cancel()
    {
        if (_cancellationTokenSource is null || _cancellationTokenSource.IsCancellationRequested)
            return;

        _cancellationTokenSource.Cancel();
        AddActivity(ActivityType.Cancelled, "Cancellation requested");
        AgentStateText = "Cancelling...";
        OnPropertyChanged(nameof(CanCancel));
    }

    #endregion

    #region Event Handlers

    /// <summary>
    /// Handle agent state changes.
    /// </summary>
    private void OnAgentStateChanged(object? sender, AgentStateChangedEventArgs args)
    {
        // Update state text
        AgentStateText = args.NewState switch
        {
            AgentState.Idle => "Idle",
            AgentState.Thinking => "Thinking...",
            AgentState.ParsingToolCall => "Parsing tool call...",
            AgentState.WaitingForApproval => "Waiting for approval",
            AgentState.ExecutingTool => "Executing tool...",
            AgentState.ProcessingResult => "Processing result...",
            AgentState.GeneratingResponse => "Generating response...",
            AgentState.Error => "Error",
            AgentState.Completed => "Completed",
            AgentState.Cancelled => "Cancelled",
            _ => "Unknown"
        };

        // Update processing state
        IsProcessing = args.NewState is
            AgentState.Thinking or
            AgentState.ParsingToolCall or
            AgentState.ExecutingTool or
            AgentState.ProcessingResult or
            AgentState.GeneratingResponse;

        // Update paused state
        IsPaused = args.NewState == AgentState.WaitingForApproval;

        // Update completion states
        IsCompleted = args.NewState == AgentState.Completed;
        HasError = args.NewState == AgentState.Error;

        // Add context-specific activity if provided
        if (!string.IsNullOrEmpty(args.Context))
        {
            AddActivity(ActivityType.Info, args.Context);
        }
    }

    #endregion

    #region IDisposable

    /// <summary>
    /// Clean up resources.
    /// </summary>
    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    /// <summary>
    /// Dispose pattern implementation.
    /// </summary>
    protected virtual void Dispose(bool disposing)
    {
        if (_disposed) return;

        if (disposing)
        {
            _agentService.StateChanged -= OnAgentStateChanged;
            _cancellationTokenSource?.Dispose();
        }

        _disposed = true;
    }

    #endregion
}
```

### 2. AgentStateChangedEventArgs.cs

**Location**: `src/SeniorIntern.Core/Events/AgentStateChangedEventArgs.cs`

```csharp
namespace SeniorIntern.Core.Events;

using System;

/// <summary>
/// Event arguments for agent state changes.
/// </summary>
/// <remarks>
/// <para>
/// This event is raised by the <see cref="IAgentService"/> when the agent
/// transitions between states during execution.
/// </para>
/// </remarks>
public class AgentStateChangedEventArgs : EventArgs
{
    /// <summary>
    /// The previous state before the transition.
    /// </summary>
    public AgentState PreviousState { get; init; }

    /// <summary>
    /// The new state after the transition.
    /// </summary>
    public AgentState NewState { get; init; }

    /// <summary>
    /// Additional context about the state change.
    /// </summary>
    /// <remarks>
    /// May contain details like the tool being executed, error messages, etc.
    /// </remarks>
    public string? Context { get; init; }

    /// <summary>
    /// Timestamp when the state change occurred.
    /// </summary>
    public DateTime Timestamp { get; init; } = DateTime.UtcNow;

    /// <summary>
    /// Associated tool ID, if the state change is related to a tool.
    /// </summary>
    public string? ToolId { get; init; }

    /// <summary>
    /// Current iteration number when the state changed.
    /// </summary>
    public int? Iteration { get; init; }

    /// <summary>
    /// Creates event args for a simple state transition.
    /// </summary>
    public static AgentStateChangedEventArgs Create(AgentState previousState, AgentState newState)
        => new()
        {
            PreviousState = previousState,
            NewState = newState
        };

    /// <summary>
    /// Creates event args with context.
    /// </summary>
    public static AgentStateChangedEventArgs WithContext(
        AgentState previousState,
        AgentState newState,
        string context)
        => new()
        {
            PreviousState = previousState,
            NewState = newState,
            Context = context
        };

    /// <summary>
    /// Creates event args for a tool-related state change.
    /// </summary>
    public static AgentStateChangedEventArgs ForTool(
        AgentState previousState,
        AgentState newState,
        string toolId,
        string? context = null)
        => new()
        {
            PreviousState = previousState,
            NewState = newState,
            ToolId = toolId,
            Context = context
        };
}
```

### 3. AgentState.cs

**Location**: `src/SeniorIntern.Core/Models/AgentState.cs`

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// States that the agent can be in during execution.
/// </summary>
public enum AgentState
{
    /// <summary>
    /// Agent is idle, not executing any request.
    /// </summary>
    Idle,

    /// <summary>
    /// Agent is thinking (LLM is generating a response).
    /// </summary>
    Thinking,

    /// <summary>
    /// Agent is parsing a tool call from the LLM response.
    /// </summary>
    ParsingToolCall,

    /// <summary>
    /// Agent is waiting for user approval of a tool call.
    /// </summary>
    WaitingForApproval,

    /// <summary>
    /// Agent is executing a tool.
    /// </summary>
    ExecutingTool,

    /// <summary>
    /// Agent is processing the result of a tool execution.
    /// </summary>
    ProcessingResult,

    /// <summary>
    /// Agent is generating its final response.
    /// </summary>
    GeneratingResponse,

    /// <summary>
    /// Agent encountered an error.
    /// </summary>
    Error,

    /// <summary>
    /// Agent completed its task successfully.
    /// </summary>
    Completed,

    /// <summary>
    /// Agent execution was cancelled by the user.
    /// </summary>
    Cancelled
}

/// <summary>
/// Extension methods for AgentState.
/// </summary>
public static class AgentStateExtensions
{
    /// <summary>
    /// Get the display name for a state.
    /// </summary>
    public static string GetDisplayName(this AgentState state) => state switch
    {
        AgentState.Idle => "Idle",
        AgentState.Thinking => "Thinking",
        AgentState.ParsingToolCall => "Parsing",
        AgentState.WaitingForApproval => "Awaiting Approval",
        AgentState.ExecutingTool => "Executing",
        AgentState.ProcessingResult => "Processing",
        AgentState.GeneratingResponse => "Generating",
        AgentState.Error => "Error",
        AgentState.Completed => "Completed",
        AgentState.Cancelled => "Cancelled",
        _ => state.ToString()
    };

    /// <summary>
    /// Get whether this state indicates active processing.
    /// </summary>
    public static bool IsActive(this AgentState state) => state is
        AgentState.Thinking or
        AgentState.ParsingToolCall or
        AgentState.ExecutingTool or
        AgentState.ProcessingResult or
        AgentState.GeneratingResponse or
        AgentState.WaitingForApproval;

    /// <summary>
    /// Get whether this state indicates the agent is busy (not waiting).
    /// </summary>
    public static bool IsBusy(this AgentState state) => state is
        AgentState.Thinking or
        AgentState.ParsingToolCall or
        AgentState.ExecutingTool or
        AgentState.ProcessingResult or
        AgentState.GeneratingResponse;

    /// <summary>
    /// Get whether this is a terminal state.
    /// </summary>
    public static bool IsTerminal(this AgentState state) => state is
        AgentState.Idle or
        AgentState.Completed or
        AgentState.Error or
        AgentState.Cancelled;

    /// <summary>
    /// Get whether this state indicates an error.
    /// </summary>
    public static bool IsError(this AgentState state) =>
        state == AgentState.Error;

    /// <summary>
    /// Get whether this state is waiting for user input.
    /// </summary>
    public static bool IsWaiting(this AgentState state) =>
        state == AgentState.WaitingForApproval;
}
```

---

## IAgentService Interface Updates

The `IAgentService` interface needs to expose the `StateChanged` event:

```csharp
// Addition to IAgentService (from v0.6.2h)
public interface IAgentService
{
    // ... existing members ...

    /// <summary>
    /// Raised when the agent state changes.
    /// </summary>
    event EventHandler<AgentStateChangedEventArgs>? StateChanged;
}
```

---

## File Summary

| File | Location | Purpose | Lines |
|------|----------|---------|-------|
| `AgentActivityViewModel.cs` | `ViewModels/` | Main activity ViewModel | ~380 |
| `AgentStateChangedEventArgs.cs` | `Core/Events/` | State change event args | ~85 |
| `AgentState.cs` | `Core/Models/` | Agent state enum | ~95 |

---

## Unit Test Plan

| Test | Description |
|------|-------------|
| `StartTracking_SetsStateCorrectly` | Initial state setup |
| `StartTracking_CreatesExecutionSummary` | Summary creation |
| `StartTracking_AddsInitialActivity` | Initial activity added |
| `StopTracking_Completed_SetsSuccess` | Completed state |
| `StopTracking_Cancelled_SetsCancelled` | Cancelled state |
| `StopTracking_Error_SetsError` | Error state |
| `AddActivity_AddsToCollection` | Activity addition |
| `AddActivity_LimitsCollectionSize` | Max 100 activities |
| `IncrementIteration_IncreaseCount` | Iteration increment |
| `IncrementIteration_SetsIndeterminateFalse` | Determinate mode |
| `RecordToolExecution_UpdatesSummary` | Statistics update |
| `RecordApproval_UpdatesSummary` | Approval tracking |
| `Cancel_RequestsCancellation` | Cancel command |
| `Cancel_AddsActivity` | Cancel activity |
| `OnAgentStateChanged_UpdatesText` | State text |
| `OnAgentStateChanged_UpdatesProcessing` | Processing flag |
| `OnAgentStateChanged_UpdatesPaused` | Paused flag |
| `CanCancel_TrueWhenActive` | Cancel enabled |
| `CanCancel_FalseWhenInactive` | Cancel disabled |
| `ProgressPercent_CalculatesCorrectly` | Progress calculation |
| `Dispose_UnsubscribesEvents` | Cleanup |

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | ViewModel tracks agent active state |
| AC-2 | Progress tracking with iteration counter |
| AC-3 | Activity log population via AddActivity |
| AC-4 | Execution summary statistics updated correctly |
| AC-5 | Cancel command functional with proper state |
| AC-6 | Agent state changes reflected in UI text |
| AC-7 | Processing/paused states tracked separately |
| AC-8 | Proper cleanup on dispose |

---

## Changelog Entry

```markdown
## v0.6.5c - Agent Activity ViewModel

### Added
- `AgentActivityViewModel` class
  - Observable properties:
    - IsAgentActive, IsProcessing, IsPaused, IsCompleted, HasError
    - AgentStateText, CurrentIteration, MaxIterations
    - IsIndeterminate, ShowIterationCounter
    - Activities (ObservableCollection<AgentActivityItem>)
    - ExecutionSummary
  - Computed properties: ProgressPercent, CanCancel
  - Tracking methods:
    - StartTracking(conversationId, maxIterations, cts)
    - StopTracking(reason, errorMessage?)
  - Activity methods:
    - AddActivity(type, message, details?, toolId?, toolName?)
    - AddThinking(), AddToolExecution(), AddApprovalWaiting()
    - CompleteActivity(activityId, success, duration, details?)
  - Statistics methods:
    - IncrementIteration()
    - RecordToolExecution(toolName, success, duration)
    - RecordApproval(approved, wasAutoApproved)
    - RecordTokens(inputTokens, outputTokens)
  - CancelCommand with CanCancel guard
  - OnAgentStateChanged event handler
  - IDisposable implementation
- `AgentStateChangedEventArgs` class
  - Properties: PreviousState, NewState, Context, Timestamp, ToolId, Iteration
  - Factory methods: Create(), WithContext(), ForTool()
- `AgentState` enum
  - 10 states: Idle, Thinking, ParsingToolCall, WaitingForApproval, ExecutingTool, ProcessingResult, GeneratingResponse, Error, Completed, Cancelled
  - Extension methods: GetDisplayName(), IsActive(), IsBusy(), IsTerminal(), IsError(), IsWaiting()
```

---

## Timeline Estimate

| Version | Estimated Effort |
|---------|------------------|
| v0.6.5c | 0.5 day |
