# Design Specification: AIntern v0.6.4c "Permission Check System"

## Overview

**Version**: v0.6.4c
**Parent**: v0.6.4 Safety & Approval
**Focus**: Permission checking with session caching and rate limiting

### Purpose

Implement the permission check system that:
1. Combines risk classification with policy evaluation
2. Provides session-based decision caching for "remember for session" functionality
3. Enforces rate limiting to prevent runaway agent loops
4. Tracks permission decision sources for audit purposes
5. Returns actionable results (allow, require approval, block)

### Dependencies

**From v0.6.4a (Permission Policy Models)**:
- `PermissionPolicy`
- Rate limit configuration (`RateLimitPerMinute`, `RateLimitPerHour`)

**From v0.6.4b (Risk Classification Engine)**:
- `RiskClassificationResult`
- `RiskFactor`
- `IRiskClassifier`

**From v0.6.1 (Tool Framework)**:
- `RiskLevel`, `ITool`
- `ToolCallRequest`

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                  v0.6.4c Permission Check Architecture                        │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Input: ToolCallRequest + ITool                                              │
│      │                                                                       │
│      ▼                                                                       │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                     Permission Check Flow                                │ │
│  │                                                                          │ │
│  │  ┌───────────────────┐                                                   │ │
│  │  │ 1. Rate Limiter   │                                                   │ │
│  │  │    CheckLimit()   │──────( exceeded )───> PermissionCheckResult      │ │
│  │  └─────────┬─────────┘                           .RateLimited()         │ │
│  │            │ allowed                                                     │ │
│  │            ▼                                                             │ │
│  │  ┌───────────────────────┐                                               │ │
│  │  │ 2. Session Cache      │                                               │ │
│  │  │    TryGetDecision()   │──────( hit )─────> PermissionCheckResult     │ │
│  │  └─────────┬─────────────┘                       .WasCached = true      │ │
│  │            │ miss                                                        │ │
│  │            ▼                                                             │ │
│  │  ┌───────────────────────┐                                               │ │
│  │  │ 3. Risk Classifier    │                                               │ │
│  │  │    Classify()         │                                               │ │
│  │  └─────────┬─────────────┘                                               │ │
│  │            │                                                             │ │
│  │            ▼                                                             │ │
│  │  ┌───────────────────────┐                                               │ │
│  │  │ 4. Policy Evaluation  │                                               │ │
│  │  │    Mode + Threshold   │                                               │ │
│  │  └─────────┬─────────────┘                                               │ │
│  │            │                                                             │ │
│  │  ┌─────────┼─────────┬─────────────────────────┐                         │ │
│  │  ▼         ▼         ▼                         ▼                         │ │
│  │ Blocked  Trusted  Auto-Approve         Needs Approval                    │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│      │                                                                       │
│      ▼                                                                       │
│  Output: PermissionCheckResult                                               │
│  ├── IsAllowed: bool                                                        │
│  ├── RequiresApproval: bool                                                 │
│  ├── IsBlocked: bool                                                        │
│  ├── EffectiveRiskLevel: RiskLevel                                          │
│  ├── RiskFactors: RiskFactor[]                                              │
│  ├── WasCached: bool                                                        │
│  ├── IsRateLimited: bool                                                    │
│  └── Source: PermissionSource                                               │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Rate Limiting Flow

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                         Rate Limiting Architecture                            │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  RateLimiter                                                                 │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  _recentCalls: ConcurrentQueue<DateTime>                                 │ │
│  │                                                                          │ │
│  │  ┌─────────────────────────────────────────────────────────────────────┐│ │
│  │  │ Time Window: Last 60 minutes                                         ││ │
│  │  │                                                                       ││ │
│  │  │  [t-60m]────────────────────[t-1m]──────────[now]                    ││ │
│  │  │     │                          │              │                       ││ │
│  │  │     ├──── hourly window ───────┴──────────────┤                       ││ │
│  │  │     │                                         │                       ││ │
│  │  │     │              ├── minute window ─────────┤                       ││ │
│  │  │                                                                       ││ │
│  │  │  calls in minute: ≤ 30 (default)                                     ││ │
│  │  │  calls in hour:   ≤ 300 (default)                                    ││ │
│  │  │                                                                       ││ │
│  │  └─────────────────────────────────────────────────────────────────────┘│ │
│  │                                                                          │ │
│  │  Methods:                                                                │ │
│  │  ├── CheckLimit() → RateLimitResult                                     │ │
│  │  ├── RecordCall() → void                                                │ │
│  │  ├── GetStatus() → RateLimitStatus                                      │ │
│  │  └── Reset() → void                                                     │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  Cleanup Strategy:                                                           │
│  - On each CheckLimit(), remove entries older than 1 hour                   │
│  - Queue automatically maintains chronological order                        │
│  - Dequeue from front until reaching valid entries                          │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Session Cache Flow

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                    Session Permission Cache Architecture                      │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  SessionPermissionCache                                                      │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  _cache: ConcurrentDictionary<string, CachedDecision>                    │ │
│  │                                                                          │ │
│  │  Key: toolId (e.g., "file-write")                                        │ │
│  │  Value: CachedDecision                                                   │ │
│  │  ├── ToolId: string                                                      │ │
│  │  ├── Decision: ApprovalDecision                                          │ │
│  │  ├── CachedAt: DateTime                                                  │ │
│  │  └── ExpiresAt: DateTime? (optional)                                     │ │
│  │                                                                          │ │
│  │  Methods:                                                                │ │
│  │  ├── TryGetDecision(toolId) → (bool, CachedDecision?)                   │ │
│  │  ├── CacheDecision(toolId, decision) → void                             │ │
│  │  ├── Clear() → void                                                     │ │
│  │  ├── Clear(toolId) → void                                               │ │
│  │  └── GetAll() → IReadOnlyList<CachedDecision>                           │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  Decision Types:                                                             │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  ApprovalDecision                                                        │ │
│  │  ├── IsApproved: bool                                                   │ │
│  │  ├── IsDenied: bool                                                     │ │
│  │  ├── RememberChoice: RememberOption                                     │ │
│  │  │   ├── None (don't remember)                                          │ │
│  │  │   ├── ForSession (remember until app closes)                         │ │
│  │  │   └── Always (persist to storage)                                    │ │
│  │  ├── ModifiedParameters: JsonElement? (if user edited)                  │ │
│  │  ├── DecidedAt: DateTime                                                │ │
│  │  └── Reason: string? (user-provided note)                               │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  Lifetime:                                                                   │
│  - Session cache is scoped to application lifetime                          │
│  - Cleared when application restarts                                        │
│  - Can be manually cleared via API                                          │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Specifications

### 1. PermissionCheckResult.cs

**Location**: `src/SeniorIntern.Core/Models/Permissions/PermissionCheckResult.cs`

```csharp
namespace SeniorIntern.Core.Models.Permissions;

using SeniorIntern.Core.Tools;

/// <summary>
/// Result of checking permissions for a tool call.
/// </summary>
/// <remarks>
/// <para>
/// This result indicates one of three outcomes:
/// </para>
/// <list type="bullet">
/// <item><b>Allowed</b>: Tool can execute immediately</item>
/// <item><b>RequiresApproval</b>: User must approve before execution</item>
/// <item><b>Blocked</b>: Tool cannot execute (policy or rate limit)</item>
/// </list>
/// </remarks>
public sealed class PermissionCheckResult
{
    #region Core Properties

    /// <summary>
    /// Whether the tool call is allowed to proceed.
    /// </summary>
    /// <remarks>
    /// True when:
    /// <list type="bullet">
    /// <item>Tool is trusted and auto-approved</item>
    /// <item>Policy mode is AutoApprove</item>
    /// <item>Risk level is below approval threshold</item>
    /// <item>Session cache contains an approved decision</item>
    /// </list>
    /// </remarks>
    public bool IsAllowed { get; init; }

    /// <summary>
    /// Whether explicit user approval is required.
    /// </summary>
    /// <remarks>
    /// True when the tool's risk level meets or exceeds the approval threshold
    /// and no cached approval decision exists.
    /// </remarks>
    public bool RequiresApproval { get; init; }

    /// <summary>
    /// Whether the tool call is completely blocked.
    /// </summary>
    /// <remarks>
    /// True when:
    /// <list type="bullet">
    /// <item>Tool is in BlockedTools list</item>
    /// <item>Tool category is disabled</item>
    /// <item>Command matches a blocked pattern</item>
    /// <item>Rate limit is exceeded</item>
    /// <item>Policy mode is Disabled</item>
    /// </list>
    /// </remarks>
    public bool IsBlocked { get; init; }

    #endregion

    #region Detail Properties

    /// <summary>
    /// Reason for the decision.
    /// </summary>
    public string? Reason { get; init; }

    /// <summary>
    /// Reason for blocking (if blocked).
    /// </summary>
    public string? BlockReason { get; init; }

    /// <summary>
    /// Effective risk level for this call.
    /// </summary>
    public RiskLevel EffectiveRiskLevel { get; init; }

    /// <summary>
    /// Risk factors identified during classification.
    /// </summary>
    public IReadOnlyList<RiskFactor> RiskFactors { get; init; } = Array.Empty<RiskFactor>();

    #endregion

    #region Source Properties

    /// <summary>
    /// Whether this decision came from cache.
    /// </summary>
    public bool WasCached { get; init; }

    /// <summary>
    /// Whether rate limit was exceeded.
    /// </summary>
    public bool IsRateLimited { get; init; }

    /// <summary>
    /// Source of the permission decision.
    /// </summary>
    public PermissionSource Source { get; init; }

    #endregion

    #region Rate Limit Info

    /// <summary>
    /// Time to wait before retrying (if rate limited).
    /// </summary>
    public TimeSpan? RetryAfter { get; init; }

    #endregion

    #region Factory Methods

    /// <summary>
    /// Create an allowed result.
    /// </summary>
    /// <param name="riskLevel">The effective risk level.</param>
    /// <param name="source">Source of the decision.</param>
    /// <param name="reason">Optional reason for the decision.</param>
    public static PermissionCheckResult Allowed(
        RiskLevel riskLevel,
        PermissionSource source,
        string? reason = null) => new()
    {
        IsAllowed = true,
        RequiresApproval = false,
        IsBlocked = false,
        Reason = reason ?? "Allowed by policy",
        EffectiveRiskLevel = riskLevel,
        Source = source
    };

    /// <summary>
    /// Create a requires-approval result.
    /// </summary>
    /// <param name="riskLevel">The effective risk level.</param>
    /// <param name="factors">Risk factors identified.</param>
    /// <param name="reason">Optional custom reason.</param>
    public static PermissionCheckResult NeedsApproval(
        RiskLevel riskLevel,
        IReadOnlyList<RiskFactor> factors,
        string? reason = null) => new()
    {
        IsAllowed = false,
        RequiresApproval = true,
        IsBlocked = false,
        Reason = reason ?? $"Tool requires approval (risk level: {riskLevel})",
        EffectiveRiskLevel = riskLevel,
        RiskFactors = factors,
        Source = PermissionSource.Policy
    };

    /// <summary>
    /// Create a blocked result.
    /// </summary>
    /// <param name="reason">Reason for blocking.</param>
    /// <param name="riskLevel">Optional risk level (defaults to Critical).</param>
    public static PermissionCheckResult Blocked(
        string reason,
        RiskLevel riskLevel = RiskLevel.Critical) => new()
    {
        IsAllowed = false,
        RequiresApproval = false,
        IsBlocked = true,
        BlockReason = reason,
        Reason = reason,
        EffectiveRiskLevel = riskLevel,
        Source = PermissionSource.Policy
    };

    /// <summary>
    /// Create a rate-limited result.
    /// </summary>
    /// <param name="reason">Reason for rate limiting.</param>
    /// <param name="retryAfter">Time until rate limit resets.</param>
    public static PermissionCheckResult RateLimited(
        string reason,
        TimeSpan? retryAfter = null) => new()
    {
        IsAllowed = false,
        RequiresApproval = false,
        IsBlocked = true,
        IsRateLimited = true,
        BlockReason = reason,
        Reason = reason,
        EffectiveRiskLevel = RiskLevel.Medium,
        Source = PermissionSource.RateLimit,
        RetryAfter = retryAfter
    };

    /// <summary>
    /// Create a cached result.
    /// </summary>
    /// <param name="decision">The cached approval decision.</param>
    /// <param name="riskLevel">The effective risk level.</param>
    public static PermissionCheckResult FromCache(
        ApprovalDecision decision,
        RiskLevel riskLevel) => new()
    {
        IsAllowed = decision.IsApproved,
        RequiresApproval = false,
        IsBlocked = decision.IsDenied,
        BlockReason = decision.IsDenied ? "Denied by cached decision" : null,
        EffectiveRiskLevel = riskLevel,
        WasCached = true,
        Source = PermissionSource.SessionCache
    };

    #endregion
}
```

### 2. PermissionSource.cs

**Location**: `src/SeniorIntern.Core/Models/Permissions/PermissionSource.cs`

```csharp
namespace SeniorIntern.Core.Models.Permissions;

/// <summary>
/// Source of a permission decision.
/// </summary>
/// <remarks>
/// Tracks where a permission decision originated for audit purposes.
/// </remarks>
public enum PermissionSource
{
    /// <summary>
    /// Decision based on policy rules.
    /// </summary>
    /// <remarks>
    /// Includes:
    /// <list type="bullet">
    /// <item>Policy mode (Disabled, AlwaysAsk, AskForRisky, AutoApprove)</item>
    /// <item>Approval threshold evaluation</item>
    /// <item>Blocked/trusted tool lists</item>
    /// </list>
    /// </remarks>
    Policy = 0,

    /// <summary>
    /// Decision from session cache (remembered for session).
    /// </summary>
    /// <remarks>
    /// User selected "Remember for this session" on a previous approval.
    /// </remarks>
    SessionCache = 1,

    /// <summary>
    /// Decision from persistent storage (always allow/deny).
    /// </summary>
    /// <remarks>
    /// User selected "Always allow/deny" on a previous approval.
    /// Stored in settings file and persists across sessions.
    /// </remarks>
    Persistent = 2,

    /// <summary>
    /// Decision from tool trusted list.
    /// </summary>
    /// <remarks>
    /// Tool is in the policy's TrustedTools set.
    /// </remarks>
    TrustedTool = 3,

    /// <summary>
    /// Blocked by rate limiter.
    /// </summary>
    /// <remarks>
    /// Too many tool calls in the time window.
    /// </remarks>
    RateLimit = 4,

    /// <summary>
    /// Decision from tool override configuration.
    /// </summary>
    ToolOverride = 5
}
```

### 3. ApprovalDecision.cs

**Location**: `src/SeniorIntern.Core/Models/Permissions/ApprovalDecision.cs`

```csharp
namespace SeniorIntern.Core.Models.Permissions;

using System.Text.Json;

/// <summary>
/// Represents a user's decision on an approval request.
/// </summary>
public sealed class ApprovalDecision
{
    /// <summary>
    /// Whether the user approved the tool call.
    /// </summary>
    public bool IsApproved { get; init; }

    /// <summary>
    /// Whether the user denied the tool call.
    /// </summary>
    public bool IsDenied { get; init; }

    /// <summary>
    /// Whether the request timed out waiting for user response.
    /// </summary>
    public bool IsTimedOut { get; init; }

    /// <summary>
    /// Whether the request was cancelled.
    /// </summary>
    public bool IsCancelled { get; init; }

    /// <summary>
    /// How long to remember this decision.
    /// </summary>
    public RememberOption RememberChoice { get; init; } = RememberOption.None;

    /// <summary>
    /// Modified parameters if user edited them before approval.
    /// </summary>
    public JsonElement? ModifiedParameters { get; init; }

    /// <summary>
    /// Whether parameters were modified by the user.
    /// </summary>
    public bool HasModifiedParameters => ModifiedParameters.HasValue;

    /// <summary>
    /// When this decision was made.
    /// </summary>
    public DateTime DecidedAt { get; init; } = DateTime.UtcNow;

    /// <summary>
    /// Optional user-provided reason or note.
    /// </summary>
    public string? Reason { get; init; }

    /// <summary>
    /// Tool ID this decision applies to.
    /// </summary>
    public string ToolId { get; init; } = string.Empty;

    /// <summary>
    /// Request ID this decision was for.
    /// </summary>
    public Guid RequestId { get; init; }

    #region Factory Methods

    /// <summary>
    /// Create an approved decision.
    /// </summary>
    public static ApprovalDecision Approved(
        string toolId,
        Guid requestId,
        RememberOption remember = RememberOption.None,
        JsonElement? modifiedParams = null) => new()
    {
        IsApproved = true,
        ToolId = toolId,
        RequestId = requestId,
        RememberChoice = remember,
        ModifiedParameters = modifiedParams
    };

    /// <summary>
    /// Create a denied decision.
    /// </summary>
    public static ApprovalDecision Denied(
        string toolId,
        Guid requestId,
        RememberOption remember = RememberOption.None,
        string? reason = null) => new()
    {
        IsDenied = true,
        ToolId = toolId,
        RequestId = requestId,
        RememberChoice = remember,
        Reason = reason
    };

    /// <summary>
    /// Create a timed out decision.
    /// </summary>
    public static ApprovalDecision TimedOut(string toolId, Guid requestId) => new()
    {
        IsDenied = true,
        IsTimedOut = true,
        ToolId = toolId,
        RequestId = requestId,
        Reason = "Approval request timed out"
    };

    /// <summary>
    /// Create a cancelled decision.
    /// </summary>
    public static ApprovalDecision Cancelled(string toolId, Guid requestId) => new()
    {
        IsDenied = true,
        IsCancelled = true,
        ToolId = toolId,
        RequestId = requestId,
        Reason = "Approval request was cancelled"
    };

    #endregion
}

/// <summary>
/// Options for remembering approval decisions.
/// </summary>
public enum RememberOption
{
    /// <summary>
    /// Don't remember - ask again next time.
    /// </summary>
    None = 0,

    /// <summary>
    /// Remember for this session only.
    /// </summary>
    ForSession = 1,

    /// <summary>
    /// Remember permanently (stored in settings).
    /// </summary>
    Always = 2
}
```

### 4. RateLimiter.cs

**Location**: `src/SeniorIntern.Services/Permissions/RateLimiter.cs`

```csharp
namespace SeniorIntern.Services.Permissions;

using System.Collections.Concurrent;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using SeniorIntern.Core.Models.Permissions;

/// <summary>
/// Tracks and enforces rate limits for tool calls.
/// </summary>
/// <remarks>
/// <para>
/// Prevents runaway agent loops by limiting the number of tool calls
/// within sliding time windows:
/// </para>
/// <list type="bullet">
/// <item>Per-minute limit (default: 30 calls/minute)</item>
/// <item>Per-hour limit (default: 300 calls/hour)</item>
/// </list>
/// <para>
/// Uses a concurrent queue to track call timestamps and automatically
/// cleans up old entries on each check.
/// </para>
/// </remarks>
public sealed class RateLimiter : IRateLimiter
{
    #region Dependencies

    private readonly PermissionPolicy _policy;
    private readonly ILogger<RateLimiter> _logger;

    #endregion

    #region State

    /// <summary>
    /// Queue of recent call timestamps.
    /// </summary>
    private readonly ConcurrentQueue<DateTime> _recentCalls = new();

    /// <summary>
    /// Lock for thread-safe cleanup operations.
    /// </summary>
    private readonly object _cleanupLock = new();

    #endregion

    public RateLimiter(
        IOptions<PermissionPolicy> policy,
        ILogger<RateLimiter> logger)
    {
        _policy = policy?.Value ?? throw new ArgumentNullException(nameof(policy));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    #region Public API

    /// <summary>
    /// Check if a tool call is within rate limits.
    /// </summary>
    /// <returns>Result indicating whether the call is allowed.</returns>
    public RateLimitResult CheckLimit()
    {
        var now = DateTime.UtcNow;
        CleanupOldEntries(now);

        // Check per-minute limit
        var callsInLastMinute = CountCallsInWindow(now, TimeSpan.FromMinutes(1));
        if (callsInLastMinute >= _policy.RateLimitPerMinute)
        {
            _logger.LogWarning(
                "Rate limit exceeded: {Count}/{Limit} calls per minute",
                callsInLastMinute, _policy.RateLimitPerMinute);

            var retryAfter = CalculateRetryAfter(now, TimeSpan.FromMinutes(1));

            return new RateLimitResult
            {
                IsAllowed = false,
                Reason = $"Rate limit exceeded: {callsInLastMinute}/{_policy.RateLimitPerMinute} calls per minute",
                RetryAfter = retryAfter,
                CallsInLastMinute = callsInLastMinute,
                CallsInLastHour = CountCallsInWindow(now, TimeSpan.FromHours(1))
            };
        }

        // Check per-hour limit
        var callsInLastHour = CountCallsInWindow(now, TimeSpan.FromHours(1));
        if (callsInLastHour >= _policy.RateLimitPerHour)
        {
            _logger.LogWarning(
                "Hourly rate limit exceeded: {Count}/{Limit} calls per hour",
                callsInLastHour, _policy.RateLimitPerHour);

            return new RateLimitResult
            {
                IsAllowed = false,
                Reason = $"Hourly rate limit exceeded: {callsInLastHour}/{_policy.RateLimitPerHour} calls per hour",
                RetryAfter = TimeSpan.FromMinutes(60),
                CallsInLastMinute = callsInLastMinute,
                CallsInLastHour = callsInLastHour
            };
        }

        _logger.LogTrace(
            "Rate limit check passed: {MinuteCount}/{MinuteLimit} per minute, {HourCount}/{HourLimit} per hour",
            callsInLastMinute, _policy.RateLimitPerMinute,
            callsInLastHour, _policy.RateLimitPerHour);

        return new RateLimitResult
        {
            IsAllowed = true,
            CallsInLastMinute = callsInLastMinute,
            CallsInLastHour = callsInLastHour
        };
    }

    /// <summary>
    /// Record a tool call for rate limiting.
    /// </summary>
    public void RecordCall()
    {
        var now = DateTime.UtcNow;
        _recentCalls.Enqueue(now);

        _logger.LogTrace("Recorded tool call at {Time}", now);
    }

    /// <summary>
    /// Get current rate limit status.
    /// </summary>
    public RateLimitStatus GetStatus()
    {
        var now = DateTime.UtcNow;
        CleanupOldEntries(now);

        return new RateLimitStatus
        {
            CallsInLastMinute = CountCallsInWindow(now, TimeSpan.FromMinutes(1)),
            CallsInLastHour = CountCallsInWindow(now, TimeSpan.FromHours(1)),
            LimitPerMinute = _policy.RateLimitPerMinute,
            LimitPerHour = _policy.RateLimitPerHour
        };
    }

    /// <summary>
    /// Reset all rate limit counters.
    /// </summary>
    public void Reset()
    {
        lock (_cleanupLock)
        {
            while (_recentCalls.TryDequeue(out _)) { }
        }

        _logger.LogInformation("Rate limiter reset");
    }

    #endregion

    #region Private Methods

    /// <summary>
    /// Count calls within a time window.
    /// </summary>
    private int CountCallsInWindow(DateTime now, TimeSpan window)
    {
        var cutoff = now - window;
        return _recentCalls.Count(c => c > cutoff);
    }

    /// <summary>
    /// Calculate time until a rate limit resets.
    /// </summary>
    private TimeSpan CalculateRetryAfter(DateTime now, TimeSpan window)
    {
        var cutoff = now - window;
        var oldestInWindow = _recentCalls.FirstOrDefault(c => c > cutoff);

        if (oldestInWindow == default)
            return TimeSpan.Zero;

        return oldestInWindow + window - now;
    }

    /// <summary>
    /// Remove entries older than 1 hour.
    /// </summary>
    private void CleanupOldEntries(DateTime now)
    {
        var cutoff = now.AddHours(-1);

        lock (_cleanupLock)
        {
            while (_recentCalls.TryPeek(out var oldest) && oldest < cutoff)
            {
                _recentCalls.TryDequeue(out _);
            }
        }
    }

    #endregion
}
```

### 5. IRateLimiter.cs

**Location**: `src/SeniorIntern.Core/Interfaces/IRateLimiter.cs`

```csharp
namespace SeniorIntern.Core.Interfaces;

using SeniorIntern.Core.Models.Permissions;

/// <summary>
/// Service for enforcing rate limits on tool calls.
/// </summary>
public interface IRateLimiter
{
    /// <summary>
    /// Check if a tool call is within rate limits.
    /// </summary>
    RateLimitResult CheckLimit();

    /// <summary>
    /// Record a tool call for rate limiting.
    /// </summary>
    void RecordCall();

    /// <summary>
    /// Get current rate limit status.
    /// </summary>
    RateLimitStatus GetStatus();

    /// <summary>
    /// Reset all rate limit counters.
    /// </summary>
    void Reset();
}
```

### 6. RateLimitModels.cs

**Location**: `src/SeniorIntern.Core/Models/Permissions/RateLimitModels.cs`

```csharp
namespace SeniorIntern.Core.Models.Permissions;

/// <summary>
/// Result of a rate limit check.
/// </summary>
public sealed class RateLimitResult
{
    /// <summary>
    /// Whether the call is allowed within rate limits.
    /// </summary>
    public bool IsAllowed { get; init; }

    /// <summary>
    /// Reason for blocking (if not allowed).
    /// </summary>
    public string? Reason { get; init; }

    /// <summary>
    /// Time to wait before retrying (if not allowed).
    /// </summary>
    public TimeSpan? RetryAfter { get; init; }

    /// <summary>
    /// Number of calls in the last minute.
    /// </summary>
    public int CallsInLastMinute { get; init; }

    /// <summary>
    /// Number of calls in the last hour.
    /// </summary>
    public int CallsInLastHour { get; init; }
}

/// <summary>
/// Current rate limit status.
/// </summary>
public sealed class RateLimitStatus
{
    /// <summary>
    /// Number of calls in the last minute.
    /// </summary>
    public int CallsInLastMinute { get; init; }

    /// <summary>
    /// Number of calls in the last hour.
    /// </summary>
    public int CallsInLastHour { get; init; }

    /// <summary>
    /// Configured limit per minute.
    /// </summary>
    public int LimitPerMinute { get; init; }

    /// <summary>
    /// Configured limit per hour.
    /// </summary>
    public int LimitPerHour { get; init; }

    /// <summary>
    /// Percentage of minute limit used.
    /// </summary>
    public double MinuteUsagePercent => LimitPerMinute > 0
        ? (double)CallsInLastMinute / LimitPerMinute * 100
        : 0;

    /// <summary>
    /// Percentage of hour limit used.
    /// </summary>
    public double HourUsagePercent => LimitPerHour > 0
        ? (double)CallsInLastHour / LimitPerHour * 100
        : 0;

    /// <summary>
    /// Remaining calls allowed this minute.
    /// </summary>
    public int RemainingThisMinute => Math.Max(0, LimitPerMinute - CallsInLastMinute);

    /// <summary>
    /// Remaining calls allowed this hour.
    /// </summary>
    public int RemainingThisHour => Math.Max(0, LimitPerHour - CallsInLastHour);

    /// <summary>
    /// Whether the minute limit is close to being reached (>80%).
    /// </summary>
    public bool IsMinuteLimitNear => MinuteUsagePercent >= 80;

    /// <summary>
    /// Whether the hour limit is close to being reached (>80%).
    /// </summary>
    public bool IsHourLimitNear => HourUsagePercent >= 80;
}
```

### 7. SessionPermissionCache.cs

**Location**: `src/SeniorIntern.Services/Permissions/SessionPermissionCache.cs`

```csharp
namespace SeniorIntern.Services.Permissions;

using System.Collections.Concurrent;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models.Permissions;

/// <summary>
/// Caches permission decisions for the current session.
/// </summary>
/// <remarks>
/// <para>
/// Provides in-memory caching for "remember for this session" decisions.
/// Cache is cleared when the application restarts.
/// </para>
/// <para>
/// Thread-safe implementation using ConcurrentDictionary.
/// </para>
/// </remarks>
public sealed class SessionPermissionCache : ISessionPermissionCache
{
    #region Dependencies

    private readonly ILogger<SessionPermissionCache> _logger;

    #endregion

    #region State

    /// <summary>
    /// Cache of decisions keyed by tool ID.
    /// </summary>
    private readonly ConcurrentDictionary<string, CachedDecision> _cache = new();

    #endregion

    public SessionPermissionCache(ILogger<SessionPermissionCache> logger)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    #region Public API

    /// <summary>
    /// Try to get a cached decision for a tool.
    /// </summary>
    /// <param name="toolId">The tool ID to look up.</param>
    /// <param name="decision">The cached decision if found.</param>
    /// <returns>True if a cached decision exists.</returns>
    public bool TryGetDecision(string toolId, out CachedDecision? decision)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(toolId);

        if (_cache.TryGetValue(toolId, out decision))
        {
            // Check if decision has expired
            if (decision.ExpiresAt.HasValue && DateTime.UtcNow > decision.ExpiresAt.Value)
            {
                _cache.TryRemove(toolId, out _);
                decision = null;
                return false;
            }

            _logger.LogDebug(
                "Cache hit for tool {ToolId}: {Decision}",
                toolId, decision.Decision.IsApproved ? "Approved" : "Denied");

            return true;
        }

        decision = null;
        return false;
    }

    /// <summary>
    /// Cache a decision for a tool.
    /// </summary>
    /// <param name="toolId">The tool ID.</param>
    /// <param name="decision">The approval decision to cache.</param>
    /// <param name="expiresAt">Optional expiration time.</param>
    public void CacheDecision(
        string toolId,
        ApprovalDecision decision,
        DateTime? expiresAt = null)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(toolId);
        ArgumentNullException.ThrowIfNull(decision);

        var cached = new CachedDecision
        {
            ToolId = toolId,
            Decision = decision,
            CachedAt = DateTime.UtcNow,
            ExpiresAt = expiresAt
        };

        _cache[toolId] = cached;

        _logger.LogInformation(
            "Cached {Decision} decision for tool {ToolId}",
            decision.IsApproved ? "approved" : "denied",
            toolId);
    }

    /// <summary>
    /// Clear all cached decisions.
    /// </summary>
    public void Clear()
    {
        var count = _cache.Count;
        _cache.Clear();

        _logger.LogInformation("Cleared {Count} cached permission decisions", count);
    }

    /// <summary>
    /// Clear cached decision for a specific tool.
    /// </summary>
    /// <param name="toolId">The tool ID to clear.</param>
    public void Clear(string toolId)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(toolId);

        if (_cache.TryRemove(toolId, out _))
        {
            _logger.LogInformation("Cleared cached decision for tool {ToolId}", toolId);
        }
    }

    /// <summary>
    /// Get all cached decisions.
    /// </summary>
    public IReadOnlyList<CachedDecision> GetAll()
    {
        // Filter out expired entries
        var now = DateTime.UtcNow;
        return _cache.Values
            .Where(c => !c.ExpiresAt.HasValue || c.ExpiresAt.Value > now)
            .ToList();
    }

    /// <summary>
    /// Get the count of cached decisions.
    /// </summary>
    public int Count => _cache.Count;

    #endregion
}
```

### 8. ISessionPermissionCache.cs

**Location**: `src/SeniorIntern.Core/Interfaces/ISessionPermissionCache.cs`

```csharp
namespace SeniorIntern.Core.Interfaces;

using SeniorIntern.Core.Models.Permissions;

/// <summary>
/// Service for caching permission decisions for the current session.
/// </summary>
public interface ISessionPermissionCache
{
    /// <summary>
    /// Try to get a cached decision for a tool.
    /// </summary>
    bool TryGetDecision(string toolId, out CachedDecision? decision);

    /// <summary>
    /// Cache a decision for a tool.
    /// </summary>
    void CacheDecision(string toolId, ApprovalDecision decision, DateTime? expiresAt = null);

    /// <summary>
    /// Clear all cached decisions.
    /// </summary>
    void Clear();

    /// <summary>
    /// Clear cached decision for a specific tool.
    /// </summary>
    void Clear(string toolId);

    /// <summary>
    /// Get all cached decisions.
    /// </summary>
    IReadOnlyList<CachedDecision> GetAll();

    /// <summary>
    /// Get the count of cached decisions.
    /// </summary>
    int Count { get; }
}
```

### 9. CachedDecision.cs

**Location**: `src/SeniorIntern.Core/Models/Permissions/CachedDecision.cs`

```csharp
namespace SeniorIntern.Core.Models.Permissions;

/// <summary>
/// A cached permission decision.
/// </summary>
public sealed class CachedDecision
{
    /// <summary>
    /// Tool ID this decision applies to.
    /// </summary>
    public string ToolId { get; init; } = string.Empty;

    /// <summary>
    /// The cached approval decision.
    /// </summary>
    public ApprovalDecision Decision { get; init; } = null!;

    /// <summary>
    /// When this decision was cached.
    /// </summary>
    public DateTime CachedAt { get; init; }

    /// <summary>
    /// Optional expiration time.
    /// </summary>
    public DateTime? ExpiresAt { get; init; }

    /// <summary>
    /// Whether this cached decision has expired.
    /// </summary>
    public bool IsExpired => ExpiresAt.HasValue && DateTime.UtcNow > ExpiresAt.Value;

    /// <summary>
    /// How long this decision has been cached.
    /// </summary>
    public TimeSpan CachedFor => DateTime.UtcNow - CachedAt;
}
```

---

## File Summary

| File | Location | Purpose | Lines |
|------|----------|---------|-------|
| `PermissionCheckResult.cs` | `Core/Models/Permissions/` | Check result model | ~150 |
| `PermissionSource.cs` | `Core/Models/Permissions/` | Source enum | ~45 |
| `ApprovalDecision.cs` | `Core/Models/Permissions/` | Decision model | ~110 |
| `RateLimiter.cs` | `Services/Permissions/` | Rate limiting | ~150 |
| `IRateLimiter.cs` | `Core/Interfaces/` | Rate limiter interface | ~25 |
| `RateLimitModels.cs` | `Core/Models/Permissions/` | Rate limit models | ~80 |
| `SessionPermissionCache.cs` | `Services/Permissions/` | Session cache | ~120 |
| `ISessionPermissionCache.cs` | `Core/Interfaces/` | Cache interface | ~30 |
| `CachedDecision.cs` | `Core/Models/Permissions/` | Cached decision model | ~40 |

---

## Unit Test Plan

| Test | Description |
|------|-------------|
| `PermissionCheckResult_Allowed_SetsProperties` | Factory method |
| `PermissionCheckResult_NeedsApproval_IncludesFactors` | Factor inclusion |
| `PermissionCheckResult_Blocked_HasBlockReason` | Block reason |
| `PermissionCheckResult_RateLimited_HasRetryAfter` | Rate limit info |
| `RateLimiter_UnderLimit_ReturnsAllowed` | Normal operation |
| `RateLimiter_ExceedsMinuteLimit_ReturnsBlocked` | Minute limit |
| `RateLimiter_ExceedsHourLimit_ReturnsBlocked` | Hour limit |
| `RateLimiter_RecordCall_IncrementsCount` | Call recording |
| `RateLimiter_CleanupOldEntries_RemovesExpired` | Cleanup |
| `RateLimiter_Reset_ClearsAllEntries` | Reset |
| `SessionCache_TryGetDecision_ReturnsCached` | Cache hit |
| `SessionCache_TryGetDecision_MissReturnsNull` | Cache miss |
| `SessionCache_ExpiredDecision_ReturnsNull` | Expiration |
| `SessionCache_Clear_RemovesAll` | Clear all |
| `SessionCache_ClearTool_RemovesSpecific` | Clear specific |
| `ApprovalDecision_Approved_SetsFlags` | Approval factory |
| `ApprovalDecision_Denied_SetsFlags` | Denial factory |
| `ApprovalDecision_TimedOut_SetsFlags` | Timeout factory |

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | PermissionCheckResult captures all decision information |
| AC-2 | RateLimiter tracks per-minute and per-hour limits |
| AC-3 | SessionPermissionCache stores remembered decisions |
| AC-4 | Rate limit status is queryable |
| AC-5 | Cache can be cleared per-tool or entirely |

---

## Changelog Entry

```markdown
## v0.6.4c - Permission Check System

### Added
- `PermissionCheckResult` for comprehensive check results
  - IsAllowed, RequiresApproval, IsBlocked states
  - EffectiveRiskLevel and RiskFactors
  - WasCached and IsRateLimited flags
  - Source tracking (Policy, SessionCache, Persistent, etc.)
  - Factory methods for common patterns
- `PermissionSource` enum for decision origin tracking
- `ApprovalDecision` model for user decisions
  - Approved, Denied, TimedOut, Cancelled states
  - RememberOption (None, ForSession, Always)
  - Modified parameters support
  - Factory methods
- `RateLimiter` for preventing runaway loops
  - Per-minute limit (default: 30)
  - Per-hour limit (default: 300)
  - Sliding window tracking
  - Automatic cleanup of old entries
  - GetStatus() for monitoring
- `IRateLimiter` interface
- `RateLimitResult` and `RateLimitStatus` models
  - Usage percentages
  - Remaining calls
  - RetryAfter calculation
- `SessionPermissionCache` for session decisions
  - ConcurrentDictionary-based storage
  - Optional expiration support
  - Per-tool and full clear
- `ISessionPermissionCache` interface
- `CachedDecision` model with expiration
```

---

## Timeline Estimate

| Version | Estimated Effort |
|---------|------------------|
| v0.6.4c | 0.5 day |
