# Design Specification: AIntern v0.6.2e "Agent Event System"

## Overview

**Version**: v0.6.2e
**Parent**: v0.6.2 Semantic Kernel Integration
**Focus**: Event hierarchy for streaming agent updates to UI

### Purpose

This sub-version defines the event system for real-time agent feedback:
1. Create `AgentEvent` abstract base class for all events
2. Create `TextGenerationEvent` for streaming LLM tokens
3. Create `ToolCallRequestEvent` when LLM requests tools
4. Create `ApprovalRequestEvent` with async approval flow
5. Create `ToolExecutionEvent` for execution status updates
6. Create `ToolResultEvent` when tools complete
7. Create `AgentIterationEvent` for loop tracking
8. Create `AgentErrorEvent` for error handling
9. Create `AgentCompleteEvent` with statistics
10. Create `AgentEventEmitter` for centralized dispatch

### Dependencies

**From v0.6.1a (Tool Core Models)**:
- `RiskLevel` for approval events
- `ToolResult` for result events

**From v0.6.2d**:
- `AgentState` for state context in events

**Future Consumers**:
- v0.6.2i: AgentService (emits events)
- UI Layer: Subscribes to events for display

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                    v0.6.2e Agent Event System Architecture                    │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Event Hierarchy                                                             │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │                         AgentEvent (abstract)                            │ │
│  │                         ┌─────────────────────┐                          │ │
│  │                         │  EventId: Guid       │                          │ │
│  │                         │  Timestamp: DateTime │                          │ │
│  │                         │  RequestId: Guid     │                          │ │
│  │                         │  IterationNumber: int│                          │ │
│  │                         └──────────┬──────────┘                          │ │
│  │                                    │                                      │ │
│  │  ┌───────────────────┬────────────┼────────────┬──────────────────────┐  │ │
│  │  │                   │            │            │                      │  │ │
│  │  ▼                   ▼            ▼            ▼                      ▼  │ │
│  │ ┌──────────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────────┐ │ │
│  │ │TextGeneration│ │ToolCall  │ │Approval  │ │  Tool    │ │ Agent       │ │ │
│  │ │   Event      │ │ Request  │ │ Request  │ │Execution │ │ Iteration   │ │ │
│  │ │              │ │  Event   │ │  Event   │ │  Event   │ │   Event     │ │ │
│  │ ├──────────────┤ ├──────────┤ ├──────────┤ ├──────────┤ ├──────────────┤ │ │
│  │ │Token: string │ │Request   │ │Request   │ │ToolId    │ │IterationNum │ │ │
│  │ │IsComplete    │ │CallIndex │ │Summary   │ │Status    │ │MaxIterations│ │ │
│  │ │TokenCount    │ │TotalCalls│ │RiskLevel │ │Progress  │ │ToolCalls    │ │ │
│  │ │IsThinking    │ │          │ │Warnings  │ │Message   │ │             │ │ │
│  │ │              │ │          │ │Approval  │ │          │ │             │ │ │
│  │ │              │ │          │ │  Task    │ │          │ │             │ │ │
│  │ └──────────────┘ └──────────┘ └──────────┘ └──────────┘ └──────────────┘ │ │
│  │                                                                          │ │
│  │  ┌───────────────┐ ┌─────────────────┐ ┌─────────────────────────────┐   │ │
│  │  │  ToolResult   │ │   AgentError    │ │      AgentComplete          │   │ │
│  │  │    Event      │ │     Event       │ │        Event                │   │ │
│  │  ├───────────────┤ ├─────────────────┤ ├─────────────────────────────┤   │ │
│  │  │ToolId         │ │Error: string    │ │FinalResponse                │   │ │
│  │  │Result         │ │IsFatal: bool    │ │ToolCallsExecuted            │   │ │
│  │  │Duration       │ │Category         │ │TotalIterations              │   │ │
│  │  │               │ │Exception?       │ │TotalDuration                │   │ │
│  │  │               │ │RecoveryHint?    │ │ToolUsage                    │   │ │
│  │  └───────────────┘ └─────────────────┘ └─────────────────────────────┘   │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  Event Emitter                                                               │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  AgentEventEmitter                                                       │ │
│  │  ├── Subscribe<TEvent>(handler)                                          │ │
│  │  ├── Emit(event)                                                         │ │
│  │  ├── EmitAsync(event)                                                    │ │
│  │  └── AsObservable<TEvent>()                                              │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Event Flow

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                        Agent Event Flow During Execution                      │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Request Start                                                               │
│      │                                                                       │
│      ▼                                                                       │
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │  AgentIterationEvent (iteration: 1, max: 10)                          │   │
│  └──────────────────────────────────┬───────────────────────────────────┘   │
│                                     │                                        │
│                                     ▼                                        │
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │  TextGenerationEvent (token: "I'll", thinking: true)                  │   │
│  │  TextGenerationEvent (token: " read", thinking: true)                 │   │
│  │  TextGenerationEvent (token: "...", thinking: true)                   │   │
│  │  ...                                                                  │   │
│  └──────────────────────────────────┬───────────────────────────────────┘   │
│                                     │                                        │
│          ┌──────────────────────────┴─────────────────────────┐             │
│          │ Tool call detected                                  │             │
│          ▼                                                     ▼             │
│  ┌─────────────────────────┐                        ┌─────────────────────┐ │
│  │ToolCallRequestEvent     │                        │ No tool call        │ │
│  │(tool: file-read)        │                        │ (straight to        │ │
│  └───────────┬─────────────┘                        │  completion)        │ │
│              │                                      └──────────┬──────────┘ │
│              │ Needs approval?                                 │             │
│      ┌───────┴───────┐                                        │             │
│      │ Yes           │ No (auto-approved)                      │             │
│      ▼               ▼                                        │             │
│  ┌───────────────┐  │                                         │             │
│  │ApprovalRequest│  │                                         │             │
│  │Event (wait)   │  │                                         │             │
│  └───────┬───────┘  │                                         │             │
│          │ Decision │                                         │             │
│          ▼          │                                         │             │
│  ┌───────────────┐  │                                         │             │
│  │ToolExecution  │◄─┘                                         │             │
│  │Event(Starting)│                                            │             │
│  └───────┬───────┘                                            │             │
│          │                                                    │             │
│          ▼                                                    │             │
│  ┌───────────────┐                                            │             │
│  │ToolExecution  │                                            │             │
│  │Event(Progress)│                                            │             │
│  └───────┬───────┘                                            │             │
│          │                                                    │             │
│          ▼                                                    │             │
│  ┌───────────────┐                                            │             │
│  │ToolResultEvent│                                            │             │
│  └───────┬───────┘                                            │             │
│          │                                                    │             │
│          └──────────────────────┬─────────────────────────────┘             │
│                                 │                                            │
│                                 ▼                                            │
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │  TextGenerationEvent (token: "Based on...", thinking: false)          │   │
│  │  ...                                                                  │   │
│  └──────────────────────────────────┬───────────────────────────────────┘   │
│                                     │                                        │
│                                     ▼                                        │
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │  AgentCompleteEvent (toolCalls: 1, iterations: 1, duration: 3.2s)     │   │
│  └──────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Specifications

### 1. AgentEvent.cs

**Location**: `src/SeniorIntern.Core/Models/AgentEvent.cs`

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Base class for all events emitted during agent execution.
/// </summary>
/// <remarks>
/// <para>
/// Agent events provide real-time feedback during request processing:
/// </para>
/// <list type="bullet">
/// <item>Text generation streaming</item>
/// <item>Tool call detection and execution</item>
/// <item>Approval requests</item>
/// <item>Progress updates</item>
/// <item>Completion/error status</item>
/// </list>
/// <para>
/// Events are streamed to the UI via the event emitter for immediate display.
/// </para>
/// </remarks>
public abstract class AgentEvent
{
    /// <summary>
    /// Unique identifier for this event.
    /// </summary>
    public Guid EventId { get; init; } = Guid.NewGuid();

    /// <summary>
    /// When this event was created.
    /// </summary>
    public DateTime Timestamp { get; init; } = DateTime.UtcNow;

    /// <summary>
    /// Request ID this event belongs to.
    /// </summary>
    /// <remarks>
    /// All events from a single request share the same RequestId.
    /// </remarks>
    public Guid RequestId { get; init; }

    /// <summary>
    /// Current iteration number when this event occurred.
    /// </summary>
    /// <remarks>
    /// 1-based. First thinking phase is iteration 1.
    /// </remarks>
    public int IterationNumber { get; init; }

    /// <summary>
    /// Event type identifier for serialization/routing.
    /// </summary>
    public abstract string EventType { get; }

    /// <summary>
    /// Get a brief description of this event for logging.
    /// </summary>
    public abstract string GetSummary();
}

/// <summary>
/// Extension methods for AgentEvent.
/// </summary>
public static class AgentEventExtensions
{
    /// <summary>
    /// Check if this is a terminal event (complete or error).
    /// </summary>
    public static bool IsTerminal(this AgentEvent evt) =>
        evt is AgentCompleteEvent or AgentErrorEvent { IsFatal: true };

    /// <summary>
    /// Check if this event requires user interaction.
    /// </summary>
    public static bool RequiresUserInput(this AgentEvent evt) =>
        evt is ApprovalRequestEvent;

    /// <summary>
    /// Get elapsed time since event creation.
    /// </summary>
    public static TimeSpan Age(this AgentEvent evt) =>
        DateTime.UtcNow - evt.Timestamp;
}
```

### 2. TextGenerationEvent.cs

**Location**: `src/SeniorIntern.Core/Models/TextGenerationEvent.cs`

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Event for streaming text tokens from the LLM.
/// </summary>
/// <remarks>
/// <para>
/// TextGenerationEvents are emitted frequently during LLM generation,
/// typically one per token or small group of tokens.
/// </para>
/// <para>
/// The UI should append these tokens to build the complete response.
/// </para>
/// </remarks>
public sealed class TextGenerationEvent : AgentEvent
{
    /// <summary>
    /// The generated token or text fragment.
    /// </summary>
    /// <remarks>
    /// May be a single token, word, or small phrase depending on streaming granularity.
    /// </remarks>
    public string Token { get; init; } = string.Empty;

    /// <summary>
    /// Whether this is the final token in the current generation.
    /// </summary>
    /// <remarks>
    /// True when LLM signals end of generation (before tool calls or completion).
    /// </remarks>
    public bool IsComplete { get; init; }

    /// <summary>
    /// Cumulative token count so far in this generation phase.
    /// </summary>
    public int TokenCount { get; init; }

    /// <summary>
    /// Whether this text is part of thinking/reasoning vs response.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Thinking text is internal reasoning that may be displayed differently
    /// (e.g., collapsed, dimmed, or hidden based on user preferences).
    /// </para>
    /// <para>
    /// Response text is the final answer to show the user.
    /// </para>
    /// </remarks>
    public bool IsThinking { get; init; }

    /// <summary>
    /// Source of the text (LLM model name).
    /// </summary>
    public string? Source { get; init; }

    /// <summary>
    /// Index within the current streaming sequence.
    /// </summary>
    public int SequenceIndex { get; init; }

    /// <inheritdoc />
    public override string EventType => "text_generation";

    /// <inheritdoc />
    public override string GetSummary() =>
        IsComplete ? $"Generation complete ({TokenCount} tokens)"
        : $"Token: \"{Token.Truncate(20)}\" (thinking: {IsThinking})";

    #region Factory Methods

    /// <summary>
    /// Create a token event.
    /// </summary>
    public static TextGenerationEvent Token(
        Guid requestId,
        string token,
        int tokenCount,
        bool isThinking,
        int iteration) => new()
    {
        RequestId = requestId,
        Token = token,
        TokenCount = tokenCount,
        IsThinking = isThinking,
        IterationNumber = iteration
    };

    /// <summary>
    /// Create a completion event.
    /// </summary>
    public static TextGenerationEvent Complete(
        Guid requestId,
        int totalTokens,
        int iteration) => new()
    {
        RequestId = requestId,
        Token = string.Empty,
        TokenCount = totalTokens,
        IsComplete = true,
        IterationNumber = iteration
    };

    #endregion
}
```

### 3. ToolCallRequestEvent.cs

**Location**: `src/SeniorIntern.Core/Models/ToolCallRequestEvent.cs`

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Event when the LLM requests a tool call.
/// </summary>
/// <remarks>
/// Emitted when the agent parses a tool call from LLM output.
/// Multiple ToolCallRequestEvents may be emitted per iteration if
/// the LLM requests parallel tool calls.
/// </remarks>
public sealed class ToolCallRequestEvent : AgentEvent
{
    /// <summary>
    /// The parsed tool call request.
    /// </summary>
    public ToolCallRequest Request { get; init; } = null!;

    /// <summary>
    /// Index of this tool call in the current iteration (0-based).
    /// </summary>
    /// <remarks>
    /// Multiple tool calls can occur per iteration when LLM requests parallel execution.
    /// </remarks>
    public int CallIndex { get; init; }

    /// <summary>
    /// Total tool calls detected in this iteration.
    /// </summary>
    public int TotalCalls { get; init; }

    /// <summary>
    /// Whether this is the only tool call in this iteration.
    /// </summary>
    public bool IsSingleCall => TotalCalls == 1;

    /// <summary>
    /// Whether this is the last tool call in this iteration.
    /// </summary>
    public bool IsLastCall => CallIndex == TotalCalls - 1;

    /// <inheritdoc />
    public override string EventType => "tool_call_request";

    /// <inheritdoc />
    public override string GetSummary() =>
        $"Tool call: {Request.ToolName} ({CallIndex + 1}/{TotalCalls})";

    /// <summary>
    /// Create a tool call request event.
    /// </summary>
    public static ToolCallRequestEvent Create(
        Guid requestId,
        ToolCallRequest request,
        int callIndex,
        int totalCalls,
        int iteration) => new()
    {
        RequestId = requestId,
        Request = request,
        CallIndex = callIndex,
        TotalCalls = totalCalls,
        IterationNumber = iteration
    };
}
```

### 4. ApprovalRequestEvent.cs

**Location**: `src/SeniorIntern.Core/Models/ApprovalRequestEvent.cs`

```csharp
namespace SeniorIntern.Core.Models;

using SeniorIntern.Core.Tools;

/// <summary>
/// Event when user approval is needed for a tool call.
/// </summary>
/// <remarks>
/// <para>
/// This event contains a TaskCompletionSource that the UI must complete
/// with the user's approval decision. The agent loop awaits this task.
/// </para>
/// <para>
/// Approval flow:
/// </para>
/// <list type="number">
/// <item>Agent emits ApprovalRequestEvent</item>
/// <item>UI displays approval dialog</item>
/// <item>User makes decision</item>
/// <item>UI calls ApprovalTask.SetResult(decision)</item>
/// <item>Agent continues based on decision</item>
/// </list>
/// </remarks>
public sealed class ApprovalRequestEvent : AgentEvent
{
    /// <summary>
    /// The tool call requiring approval.
    /// </summary>
    public ToolCallRequest Request { get; init; } = null!;

    /// <summary>
    /// Human-readable summary of what the tool will do.
    /// </summary>
    /// <remarks>
    /// Used as the main text in approval dialogs.
    /// </remarks>
    public string Summary { get; init; } = string.Empty;

    /// <summary>
    /// Risk level for this specific invocation.
    /// </summary>
    /// <remarks>
    /// Determined by the tool and parameters. Higher risk levels
    /// should trigger more prominent warnings in the UI.
    /// </remarks>
    public RiskLevel RiskLevel { get; init; }

    /// <summary>
    /// Detailed breakdown of the operation for review.
    /// </summary>
    /// <remarks>
    /// Expandable details in the approval dialog.
    /// E.g., "File: /src/Program.cs", "Command: rm -rf ./build"
    /// </remarks>
    public IReadOnlyList<string>? Details { get; init; }

    /// <summary>
    /// Suggested actions or warnings.
    /// </summary>
    /// <remarks>
    /// Important notes for the user to consider.
    /// E.g., "This will delete files permanently"
    /// </remarks>
    public IReadOnlyList<string>? Warnings { get; init; }

    /// <summary>
    /// Task completion source for the UI to provide the decision.
    /// </summary>
    /// <remarks>
    /// <para>
    /// The UI must call SetResult() on this task with the user's decision.
    /// </para>
    /// <para>
    /// If the timeout expires before a decision, the agent treats it as denial.
    /// </para>
    /// </remarks>
    public TaskCompletionSource<ApprovalDecision> ApprovalTask { get; init; } = new();

    /// <summary>
    /// Timeout for waiting on approval.
    /// </summary>
    /// <remarks>
    /// After this duration, the request is auto-denied.
    /// </remarks>
    public TimeSpan Timeout { get; init; } = TimeSpan.FromMinutes(5);

    /// <summary>
    /// When the approval request expires.
    /// </summary>
    public DateTime ExpiresAt => Timestamp.Add(Timeout);

    /// <summary>
    /// Whether the approval request has expired.
    /// </summary>
    public bool IsExpired => DateTime.UtcNow > ExpiresAt;

    /// <summary>
    /// Time remaining before expiration.
    /// </summary>
    public TimeSpan TimeRemaining => ExpiresAt - DateTime.UtcNow;

    /// <inheritdoc />
    public override string EventType => "approval_request";

    /// <inheritdoc />
    public override string GetSummary() =>
        $"Approval needed: {Request.ToolName} ({RiskLevel})";

    /// <summary>
    /// Approve the tool call.
    /// </summary>
    /// <param name="rememberChoice">Whether to remember for this session.</param>
    /// <param name="modifiedParameters">Optional modified parameters.</param>
    public void Approve(bool rememberChoice = false, JsonElement? modifiedParameters = null)
    {
        ApprovalTask.TrySetResult(new ApprovalDecision
        {
            Approved = true,
            RememberChoice = rememberChoice,
            ModifiedParameters = modifiedParameters
        });
    }

    /// <summary>
    /// Deny the tool call.
    /// </summary>
    /// <param name="reason">Optional reason for denial.</param>
    public void Deny(string? reason = null)
    {
        ApprovalTask.TrySetResult(new ApprovalDecision
        {
            Approved = false,
            DenialReason = reason
        });
    }

    /// <summary>
    /// Cancel the approval (agent was cancelled).
    /// </summary>
    public void Cancel()
    {
        ApprovalTask.TrySetCanceled();
    }
}

/// <summary>
/// User's decision on a tool approval request.
/// </summary>
public sealed class ApprovalDecision
{
    /// <summary>
    /// Whether the tool call was approved.
    /// </summary>
    public bool Approved { get; init; }

    /// <summary>
    /// Whether to remember this decision for the session.
    /// </summary>
    public bool RememberChoice { get; init; }

    /// <summary>
    /// Reason for denial (if not approved).
    /// </summary>
    public string? DenialReason { get; init; }

    /// <summary>
    /// Modified parameters (if user adjusted them).
    /// </summary>
    public JsonElement? ModifiedParameters { get; init; }

    /// <summary>
    /// When the decision was made.
    /// </summary>
    public DateTime DecidedAt { get; init; } = DateTime.UtcNow;

    /// <summary>
    /// Create an approval decision.
    /// </summary>
    public static ApprovalDecision Approve(bool remember = false) =>
        new() { Approved = true, RememberChoice = remember };

    /// <summary>
    /// Create a denial decision.
    /// </summary>
    public static ApprovalDecision Deny(string? reason = null) =>
        new() { Approved = false, DenialReason = reason };
}
```

### 5. ToolExecutionEvent.cs

**Location**: `src/SeniorIntern.Core/Models/ToolExecutionEvent.cs`

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Event for tool execution status updates.
/// </summary>
/// <remarks>
/// Emitted throughout tool execution to provide progress feedback.
/// Multiple events may be emitted for long-running tools.
/// </remarks>
public sealed class ToolExecutionEvent : AgentEvent
{
    /// <summary>
    /// Tool ID being executed.
    /// </summary>
    public string ToolId { get; init; } = string.Empty;

    /// <summary>
    /// Human-readable tool name.
    /// </summary>
    public string ToolName { get; init; } = string.Empty;

    /// <summary>
    /// Current execution status.
    /// </summary>
    public ToolExecutionStatus Status { get; init; }

    /// <summary>
    /// Progress information if available.
    /// </summary>
    public ToolProgress? Progress { get; init; }

    /// <summary>
    /// Status message for UI display.
    /// </summary>
    public string? StatusMessage { get; init; }

    /// <summary>
    /// Elapsed time since execution started.
    /// </summary>
    public TimeSpan? Elapsed { get; init; }

    /// <inheritdoc />
    public override string EventType => "tool_execution";

    /// <inheritdoc />
    public override string GetSummary() =>
        $"Tool {ToolName}: {Status}" +
        (Progress != null ? $" ({Progress.Percentage}%)" : "");

    #region Factory Methods

    /// <summary>
    /// Create a "Starting" event.
    /// </summary>
    public static ToolExecutionEvent Starting(
        Guid requestId,
        string toolId,
        string toolName,
        int iteration) => new()
    {
        RequestId = requestId,
        ToolId = toolId,
        ToolName = toolName,
        Status = ToolExecutionStatus.Starting,
        IterationNumber = iteration
    };

    /// <summary>
    /// Create a "Progress" event.
    /// </summary>
    public static ToolExecutionEvent InProgress(
        Guid requestId,
        string toolId,
        string toolName,
        ToolProgress progress,
        TimeSpan elapsed,
        int iteration) => new()
    {
        RequestId = requestId,
        ToolId = toolId,
        ToolName = toolName,
        Status = ToolExecutionStatus.InProgress,
        Progress = progress,
        Elapsed = elapsed,
        IterationNumber = iteration
    };

    /// <summary>
    /// Create a "Completed" event.
    /// </summary>
    public static ToolExecutionEvent Completed(
        Guid requestId,
        string toolId,
        string toolName,
        TimeSpan elapsed,
        int iteration) => new()
    {
        RequestId = requestId,
        ToolId = toolId,
        ToolName = toolName,
        Status = ToolExecutionStatus.Completed,
        Elapsed = elapsed,
        IterationNumber = iteration
    };

    /// <summary>
    /// Create a "Failed" event.
    /// </summary>
    public static ToolExecutionEvent Failed(
        Guid requestId,
        string toolId,
        string toolName,
        string errorMessage,
        TimeSpan elapsed,
        int iteration) => new()
    {
        RequestId = requestId,
        ToolId = toolId,
        ToolName = toolName,
        Status = ToolExecutionStatus.Failed,
        StatusMessage = errorMessage,
        Elapsed = elapsed,
        IterationNumber = iteration
    };

    #endregion
}

/// <summary>
/// Status of tool execution.
/// </summary>
public enum ToolExecutionStatus
{
    /// <summary>Tool execution is beginning.</summary>
    Starting,
    /// <summary>Tool is actively executing.</summary>
    InProgress,
    /// <summary>Tool completed successfully.</summary>
    Completed,
    /// <summary>Tool execution failed.</summary>
    Failed,
    /// <summary>Tool execution was cancelled.</summary>
    Cancelled,
    /// <summary>Tool execution exceeded timeout.</summary>
    TimedOut
}

/// <summary>
/// Progress information for long-running tools.
/// </summary>
public sealed class ToolProgress
{
    /// <summary>
    /// Current progress value.
    /// </summary>
    public int Current { get; init; }

    /// <summary>
    /// Total expected progress.
    /// </summary>
    public int Total { get; init; }

    /// <summary>
    /// Progress percentage (0-100).
    /// </summary>
    public int Percentage => Total > 0 ? (Current * 100) / Total : 0;

    /// <summary>
    /// Description of current operation.
    /// </summary>
    public string? Message { get; init; }

    /// <summary>
    /// Whether progress is indeterminate.
    /// </summary>
    public bool IsIndeterminate => Total <= 0;

    /// <summary>
    /// Create determinate progress.
    /// </summary>
    public static ToolProgress Determinate(int current, int total, string? message = null) =>
        new() { Current = current, Total = total, Message = message };

    /// <summary>
    /// Create indeterminate progress.
    /// </summary>
    public static ToolProgress Indeterminate(string? message = null) =>
        new() { Current = 0, Total = 0, Message = message };
}
```

### 6. ToolResultEvent.cs

**Location**: `src/SeniorIntern.Core/Models/ToolResultEvent.cs`

```csharp
namespace SeniorIntern.Core.Models;

using SeniorIntern.Core.Tools;

/// <summary>
/// Event when a tool completes execution.
/// </summary>
/// <remarks>
/// Contains the full tool result for display and logging.
/// </remarks>
public sealed class ToolResultEvent : AgentEvent
{
    /// <summary>
    /// Tool ID that completed.
    /// </summary>
    public string ToolId { get; init; } = string.Empty;

    /// <summary>
    /// Human-readable tool name.
    /// </summary>
    public string ToolName { get; init; } = string.Empty;

    /// <summary>
    /// Tool execution result.
    /// </summary>
    public ToolResult Result { get; init; } = null!;

    /// <summary>
    /// Execution duration.
    /// </summary>
    public TimeSpan Duration { get; init; }

    /// <summary>
    /// Whether the tool succeeded.
    /// </summary>
    public bool Success => Result.Success;

    /// <summary>
    /// Truncated result for display.
    /// </summary>
    public string DisplayResult => Result.GetSerializedData()?.Truncate(500) ?? "(no data)";

    /// <inheritdoc />
    public override string EventType => "tool_result";

    /// <inheritdoc />
    public override string GetSummary() =>
        $"Tool {ToolName} {(Success ? "succeeded" : "failed")} ({Duration.TotalMilliseconds:F0}ms)";

    /// <summary>
    /// Create a tool result event.
    /// </summary>
    public static ToolResultEvent Create(
        Guid requestId,
        string toolId,
        string toolName,
        ToolResult result,
        TimeSpan duration,
        int iteration) => new()
    {
        RequestId = requestId,
        ToolId = toolId,
        ToolName = toolName,
        Result = result,
        Duration = duration,
        IterationNumber = iteration
    };
}
```

### 7. AgentIterationEvent.cs

**Location**: `src/SeniorIntern.Core/Models/AgentIterationEvent.cs`

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Event at the start of each agent loop iteration.
/// </summary>
/// <remarks>
/// Provides context about the agent loop progress.
/// </remarks>
public sealed class AgentIterationEvent : AgentEvent
{
    /// <summary>
    /// Current iteration number (1-based).
    /// </summary>
    public new int IterationNumber { get; init; }

    /// <summary>
    /// Maximum allowed iterations.
    /// </summary>
    public int MaxIterations { get; init; }

    /// <summary>
    /// Whether this is the final allowed iteration.
    /// </summary>
    public bool IsFinalIteration => IterationNumber >= MaxIterations;

    /// <summary>
    /// Remaining iterations.
    /// </summary>
    public int RemainingIterations => Math.Max(0, MaxIterations - IterationNumber);

    /// <summary>
    /// Tool calls executed in previous iteration.
    /// </summary>
    public int ToolCallsInPreviousIteration { get; init; }

    /// <summary>
    /// Total tool calls executed so far.
    /// </summary>
    public int TotalToolCallsExecuted { get; init; }

    /// <summary>
    /// Elapsed time since request started.
    /// </summary>
    public TimeSpan ElapsedTime { get; init; }

    /// <inheritdoc />
    public override string EventType => "agent_iteration";

    /// <inheritdoc />
    public override string GetSummary() =>
        $"Iteration {IterationNumber}/{MaxIterations}" +
        (ToolCallsInPreviousIteration > 0 ? $" (prev tools: {ToolCallsInPreviousIteration})" : "");

    /// <summary>
    /// Create an iteration event.
    /// </summary>
    public static AgentIterationEvent Create(
        Guid requestId,
        int iteration,
        int maxIterations,
        int prevToolCalls,
        int totalToolCalls,
        TimeSpan elapsed) => new()
    {
        RequestId = requestId,
        IterationNumber = iteration,
        MaxIterations = maxIterations,
        ToolCallsInPreviousIteration = prevToolCalls,
        TotalToolCallsExecuted = totalToolCalls,
        ElapsedTime = elapsed
    };
}
```

### 8. AgentErrorEvent.cs

**Location**: `src/SeniorIntern.Core/Models/AgentErrorEvent.cs`

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Event when an error occurs during agent execution.
/// </summary>
/// <remarks>
/// Errors may be fatal (stopping execution) or non-fatal (logged but continued).
/// </remarks>
public sealed class AgentErrorEvent : AgentEvent
{
    /// <summary>
    /// Error message.
    /// </summary>
    public string Error { get; init; } = string.Empty;

    /// <summary>
    /// Whether this error is fatal (stops execution).
    /// </summary>
    public bool IsFatal { get; init; }

    /// <summary>
    /// Error category for handling.
    /// </summary>
    public AgentErrorCategory Category { get; init; }

    /// <summary>
    /// Underlying exception if available.
    /// </summary>
    public Exception? Exception { get; init; }

    /// <summary>
    /// Suggested recovery action.
    /// </summary>
    public string? RecoveryHint { get; init; }

    /// <summary>
    /// Error code for programmatic handling.
    /// </summary>
    public string? ErrorCode { get; init; }

    /// <inheritdoc />
    public override string EventType => "agent_error";

    /// <inheritdoc />
    public override string GetSummary() =>
        $"Error ({Category}): {Error.Truncate(50)}" +
        (IsFatal ? " [FATAL]" : "");

    #region Factory Methods

    /// <summary>
    /// Create an LLM error event.
    /// </summary>
    public static AgentErrorEvent LlmError(
        Guid requestId,
        string error,
        Exception? ex = null,
        int iteration = 0) => new()
    {
        RequestId = requestId,
        Error = error,
        Category = AgentErrorCategory.LlmError,
        IsFatal = true,
        Exception = ex,
        RecoveryHint = "Try again or check model connectivity",
        IterationNumber = iteration
    };

    /// <summary>
    /// Create a tool error event.
    /// </summary>
    public static AgentErrorEvent ToolError(
        Guid requestId,
        string toolName,
        string error,
        bool isFatal = false,
        int iteration = 0) => new()
    {
        RequestId = requestId,
        Error = $"Tool '{toolName}' failed: {error}",
        Category = AgentErrorCategory.ToolError,
        IsFatal = isFatal,
        RecoveryHint = "The agent will inform you of the failure and may try alternatives",
        IterationNumber = iteration
    };

    /// <summary>
    /// Create a parsing error event.
    /// </summary>
    public static AgentErrorEvent ParsingError(
        Guid requestId,
        string error,
        int iteration = 0) => new()
    {
        RequestId = requestId,
        Error = error,
        Category = AgentErrorCategory.ParsingError,
        IsFatal = false,
        RecoveryHint = "LLM output could not be parsed, continuing without tool call",
        IterationNumber = iteration
    };

    /// <summary>
    /// Create a timeout error event.
    /// </summary>
    public static AgentErrorEvent TimeoutError(
        Guid requestId,
        string context,
        int iteration = 0) => new()
    {
        RequestId = requestId,
        Error = $"Timeout: {context}",
        Category = AgentErrorCategory.TimeoutError,
        IsFatal = true,
        RecoveryHint = "Request took too long, try a simpler task",
        IterationNumber = iteration
    };

    #endregion
}

/// <summary>
/// Categories of agent errors.
/// </summary>
public enum AgentErrorCategory
{
    /// <summary>Error from LLM API.</summary>
    LlmError,
    /// <summary>Error during tool execution.</summary>
    ToolError,
    /// <summary>Error parsing LLM output.</summary>
    ParsingError,
    /// <summary>Permission denied.</summary>
    PermissionError,
    /// <summary>Operation timed out.</summary>
    TimeoutError,
    /// <summary>Operation cancelled.</summary>
    CancellationError,
    /// <summary>Uncategorized error.</summary>
    Unknown
}
```

### 9. AgentCompleteEvent.cs

**Location**: `src/SeniorIntern.Core/Models/AgentCompleteEvent.cs`

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Event when agent execution completes.
/// </summary>
/// <remarks>
/// Contains comprehensive statistics about the request.
/// </remarks>
public sealed class AgentCompleteEvent : AgentEvent
{
    /// <summary>
    /// Final response text.
    /// </summary>
    public string FinalResponse { get; init; } = string.Empty;

    /// <summary>
    /// Total tool calls executed.
    /// </summary>
    public int ToolCallsExecuted { get; init; }

    /// <summary>
    /// Total iterations used.
    /// </summary>
    public int TotalIterations { get; init; }

    /// <summary>
    /// Total execution duration.
    /// </summary>
    public TimeSpan TotalDuration { get; init; }

    /// <summary>
    /// Whether execution was cancelled.
    /// </summary>
    public bool WasCancelled { get; init; }

    /// <summary>
    /// Total tokens generated.
    /// </summary>
    public int TotalTokens { get; init; }

    /// <summary>
    /// Summary of tools used.
    /// </summary>
    public IReadOnlyList<ToolUsageSummary>? ToolUsage { get; init; }

    /// <summary>
    /// Completion reason.
    /// </summary>
    public CompletionReason Reason { get; init; }

    /// <inheritdoc />
    public override string EventType => "agent_complete";

    /// <inheritdoc />
    public override string GetSummary() =>
        $"Complete: {TotalIterations} iterations, {ToolCallsExecuted} tools, " +
        $"{TotalDuration.TotalSeconds:F1}s";

    /// <summary>
    /// Create a completion event.
    /// </summary>
    public static AgentCompleteEvent Success(
        Guid requestId,
        string response,
        int toolCalls,
        int iterations,
        TimeSpan duration,
        int tokens,
        IReadOnlyList<ToolUsageSummary>? usage = null) => new()
    {
        RequestId = requestId,
        FinalResponse = response,
        ToolCallsExecuted = toolCalls,
        TotalIterations = iterations,
        TotalDuration = duration,
        TotalTokens = tokens,
        ToolUsage = usage,
        Reason = CompletionReason.Finished
    };

    /// <summary>
    /// Create a cancelled event.
    /// </summary>
    public static AgentCompleteEvent Cancelled(
        Guid requestId,
        int toolCalls,
        int iterations,
        TimeSpan duration) => new()
    {
        RequestId = requestId,
        WasCancelled = true,
        ToolCallsExecuted = toolCalls,
        TotalIterations = iterations,
        TotalDuration = duration,
        Reason = CompletionReason.Cancelled
    };
}

/// <summary>
/// Reason for agent completion.
/// </summary>
public enum CompletionReason
{
    /// <summary>Normal completion.</summary>
    Finished,
    /// <summary>Max iterations reached.</summary>
    MaxIterations,
    /// <summary>User cancelled.</summary>
    Cancelled,
    /// <summary>Error occurred.</summary>
    Error,
    /// <summary>Timeout exceeded.</summary>
    Timeout
}

/// <summary>
/// Summary of a tool's usage in the request.
/// </summary>
public sealed class ToolUsageSummary
{
    /// <summary>Tool ID.</summary>
    public string ToolId { get; init; } = string.Empty;
    /// <summary>Tool display name.</summary>
    public string ToolName { get; init; } = string.Empty;
    /// <summary>How many times invoked.</summary>
    public int InvocationCount { get; init; }
    /// <summary>Successful invocations.</summary>
    public int SuccessCount { get; init; }
    /// <summary>Failed invocations.</summary>
    public int FailureCount { get; init; }
    /// <summary>Total time spent.</summary>
    public TimeSpan TotalDuration { get; init; }
    /// <summary>Average duration.</summary>
    public TimeSpan AverageDuration => InvocationCount > 0
        ? TimeSpan.FromMilliseconds(TotalDuration.TotalMilliseconds / InvocationCount)
        : TimeSpan.Zero;
}
```

### 10. AgentEventEmitter.cs

**Location**: `src/SeniorIntern.Services/AI/AgentEventEmitter.cs`

```csharp
namespace SeniorIntern.Services.AI;

using SeniorIntern.Core.Models;
using Microsoft.Extensions.Logging;
using System.Collections.Concurrent;

/// <summary>
/// Centralized event emitter for agent events.
/// </summary>
/// <remarks>
/// Provides pub/sub pattern for agent events with type-safe subscriptions.
/// </remarks>
public sealed class AgentEventEmitter : IDisposable
{
    private readonly ILogger<AgentEventEmitter>? _logger;
    private readonly ConcurrentDictionary<Type, List<Delegate>> _handlers = new();
    private readonly object _lock = new();

    public AgentEventEmitter(ILogger<AgentEventEmitter>? logger = null)
    {
        _logger = logger;
    }

    /// <summary>
    /// Event raised for all agent events.
    /// </summary>
    public event EventHandler<AgentEvent>? EventEmitted;

    /// <summary>
    /// Subscribe to a specific event type.
    /// </summary>
    public IDisposable Subscribe<TEvent>(Action<TEvent> handler) where TEvent : AgentEvent
    {
        var handlers = _handlers.GetOrAdd(typeof(TEvent), _ => new List<Delegate>());
        lock (_lock)
        {
            handlers.Add(handler);
        }
        return new Subscription(() =>
        {
            lock (_lock) { handlers.Remove(handler); }
        });
    }

    /// <summary>
    /// Emit an event to all subscribers.
    /// </summary>
    public void Emit(AgentEvent evt)
    {
        _logger?.LogDebug("Emitting event: {EventType}", evt.EventType);

        // Notify general subscribers
        EventEmitted?.Invoke(this, evt);

        // Notify type-specific subscribers
        var eventType = evt.GetType();
        if (_handlers.TryGetValue(eventType, out var handlers))
        {
            List<Delegate> handlersCopy;
            lock (_lock) { handlersCopy = handlers.ToList(); }

            foreach (var handler in handlersCopy)
            {
                try
                {
                    handler.DynamicInvoke(evt);
                }
                catch (Exception ex)
                {
                    _logger?.LogError(ex, "Error in event handler for {EventType}", evt.EventType);
                }
            }
        }
    }

    /// <summary>
    /// Emit an event asynchronously.
    /// </summary>
    public Task EmitAsync(AgentEvent evt)
    {
        return Task.Run(() => Emit(evt));
    }

    /// <summary>
    /// Get an observable stream for a specific event type.
    /// </summary>
    public IObservable<TEvent> AsObservable<TEvent>() where TEvent : AgentEvent
    {
        return new EventObservable<TEvent>(this);
    }

    public void Dispose()
    {
        _handlers.Clear();
    }

    private sealed class Subscription : IDisposable
    {
        private readonly Action _unsubscribe;
        public Subscription(Action unsubscribe) => _unsubscribe = unsubscribe;
        public void Dispose() => _unsubscribe();
    }

    private sealed class EventObservable<TEvent> : IObservable<TEvent> where TEvent : AgentEvent
    {
        private readonly AgentEventEmitter _emitter;
        public EventObservable(AgentEventEmitter emitter) => _emitter = emitter;

        public IDisposable Subscribe(IObserver<TEvent> observer)
        {
            return _emitter.Subscribe<TEvent>(evt => observer.OnNext(evt));
        }
    }
}
```

---

## File Summary

| File | Location | Purpose | Lines |
|------|----------|---------|-------|
| `AgentEvent.cs` | `Core/Models/` | Base event class | ~70 |
| `TextGenerationEvent.cs` | `Core/Models/` | Token streaming | ~90 |
| `ToolCallRequestEvent.cs` | `Core/Models/` | Tool call detection | ~60 |
| `ApprovalRequestEvent.cs` | `Core/Models/` | Approval flow | ~130 |
| `ToolExecutionEvent.cs` | `Core/Models/` | Execution status | ~140 |
| `ToolResultEvent.cs` | `Core/Models/` | Tool results | ~60 |
| `AgentIterationEvent.cs` | `Core/Models/` | Iteration tracking | ~60 |
| `AgentErrorEvent.cs` | `Core/Models/` | Error handling | ~120 |
| `AgentCompleteEvent.cs` | `Core/Models/` | Completion stats | ~100 |
| `AgentEventEmitter.cs` | `Services/AI/` | Event dispatch | ~100 |

---

## Unit Test Plan

| Test | Description |
|------|-------------|
| `TextGenerationEvent_Token_ConstructsCorrectly` | Token event |
| `ApprovalRequestEvent_Approve_CompletesTask` | Approval flow |
| `ApprovalRequestEvent_Deny_CompletesWithFalse` | Denial flow |
| `ApprovalRequestEvent_IsExpired_AfterTimeout` | Expiry check |
| `ToolExecutionEvent_Factory_CreatesCorrectStatus` | Status events |
| `ToolProgress_Percentage_CalculatesCorrectly` | Progress calc |
| `AgentErrorEvent_LlmError_SetsFatalTrue` | Error factory |
| `AgentCompleteEvent_Success_HasCorrectStats` | Stats |
| `AgentEventEmitter_Subscribe_ReceivesEvents` | Subscription |
| `AgentEventEmitter_TypedSubscribe_OnlyReceivesType` | Type filtering |
| `AgentEvent_IsTerminal_CorrectForTypes` | Extension |

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | Complete event hierarchy for all agent activities |
| AC-2 | Events support streaming updates to UI |
| AC-3 | ApprovalRequestEvent includes TaskCompletionSource for async approval |
| AC-4 | Error events include recovery hints |
| AC-5 | Completion event includes comprehensive statistics |
| AC-6 | Event emitter supports typed subscriptions |
| AC-7 | All events have unique EventId and Timestamp |

---

## Changelog Entry

```markdown
## v0.6.2e - Agent Event System

### Added
- `AgentEvent` abstract base class for all events
- `TextGenerationEvent` for streaming LLM tokens
- `ToolCallRequestEvent` for tool call detection
- `ApprovalRequestEvent` with async approval via TaskCompletionSource
- `ToolExecutionEvent` with progress tracking (ToolProgress)
- `ToolResultEvent` with execution results
- `AgentIterationEvent` for loop progress tracking
- `AgentErrorEvent` with categories and recovery hints
- `AgentCompleteEvent` with comprehensive statistics
- `AgentEventEmitter` for centralized event dispatch
- `ApprovalDecision` model for approval responses
- `ToolUsageSummary` for tool usage statistics
```

---

## Timeline Estimate

| Version | Estimated Effort |
|---------|------------------|
| v0.6.2e | 0.75 day |
