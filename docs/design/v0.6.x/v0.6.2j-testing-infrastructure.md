# Design Specification: AIntern v0.6.2j "Testing Infrastructure"

## Overview

**Version**: v0.6.2j
**Parent**: v0.6.2 Semantic Kernel Integration
**Focus**: Comprehensive test infrastructure for all v0.6.2 components

### Purpose

Create comprehensive testing infrastructure:
1. Unit tests for `FunctionCallParser` (batch parsing)
2. Unit tests for `StreamingFunctionCallParser` (token-by-token)
3. Unit tests for `AgentStateMachine` (state transitions)
4. Unit tests for `PermissionManager` (permission caching)
5. Integration tests for `AgentService` (end-to-end agent loop)
6. Mock implementations for isolated testing
7. Test fixtures and helpers for consistent test setup

### Dependencies

**Components Under Test**:
- v0.6.2d: `AgentStateMachine`
- v0.6.2g: `FunctionCallParser`, `StreamingFunctionCallParser`
- v0.6.2h: `IPermissionManager`
- v0.6.2i: `AgentService`, `PermissionManager`

**Testing Frameworks**:
- xUnit (test framework)
- Moq (mocking)
- FluentAssertions (optional, for readable assertions)

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                    v0.6.2j Testing Infrastructure                             │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  tests/SeniorIntern.Tests/Services/AI/                                       │
│  ├─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  Unit Tests                                                              │ │
│  │  ├── FunctionCallParserTests.cs          (8 tests)                      │ │
│  │  ├── StreamingFunctionCallParserTests.cs (7 tests)                      │ │
│  │  ├── AgentStateMachineTests.cs           (8 tests)                      │ │
│  │  └── PermissionManagerTests.cs           (6 tests)                      │ │
│  │                                                                          │ │
│  │  Integration Tests                                                       │ │
│  │  └── AgentServiceIntegrationTests.cs     (6 tests)                      │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  tests/SeniorIntern.Tests/Mocks/                                             │
│  ├─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  Mock Implementations                                                    │ │
│  │  ├── MockTool.cs                         (configurable ITool)           │ │
│  │  ├── MockLlmService.cs                   (configurable ILlmService)     │ │
│  │  └── MockToolRegistry.cs                 (configurable IToolRegistry)   │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  tests/SeniorIntern.Tests/Fixtures/                                          │
│  ├─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  Test Fixtures                                                           │ │
│  │  ├── AgentServiceTestFixture.cs          (DI container setup)           │ │
│  │  └── TestContentSamples.cs               (sample LLM responses)         │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Specifications

### 1. FunctionCallParserTests.cs

**Location**: `tests/SeniorIntern.Tests/Services/AI/FunctionCallParserTests.cs`

```csharp
namespace SeniorIntern.Tests.Services.AI;

using System.Text.Json;
using Microsoft.Extensions.Logging;
using Moq;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Tools;
using SeniorIntern.Services.AI;
using Xunit;

public class FunctionCallParserTests
{
    private readonly Mock<IToolRegistry> _mockRegistry;
    private readonly Mock<ILogger<FunctionCallParser>> _mockLogger;
    private readonly FunctionCallParser _parser;

    public FunctionCallParserTests()
    {
        _mockRegistry = new Mock<IToolRegistry>();
        _mockLogger = new Mock<ILogger<FunctionCallParser>>();
        _parser = new FunctionCallParser(_mockRegistry.Object, _mockLogger.Object);
    }

    [Fact]
    public void Parse_ValidToolCallBlock_ReturnsToolCallRequest()
    {
        // Arrange
        var content = """
            Here's what I'll do:

            ```tool_call
            {
              "tool": "file-read",
              "parameters": { "path": "src/Program.cs" }
            }
            ```

            This will read the file.
            """;

        var mockTool = new Mock<ITool>();
        mockTool.Setup(t => t.Name).Returns("Read File");
        mockTool.Setup(t => t.GetEffectiveRiskLevel(It.IsAny<JsonElement>()))
            .Returns(RiskLevel.Safe);
        mockTool.Setup(t => t.GetExecutionSummary(It.IsAny<JsonElement>()))
            .Returns("Read file 'src/Program.cs'");
        _mockRegistry.Setup(r => r.GetTool("file-read")).Returns(mockTool.Object);

        // Act
        var requests = _parser.Parse(content);

        // Assert
        Assert.Single(requests);
        Assert.Equal("file-read", requests[0].ToolId);
        Assert.Equal("Read File", requests[0].ToolName);
        Assert.Equal(RiskLevel.Safe, requests[0].RiskLevel);
    }

    [Fact]
    public void Parse_MultipleToolCalls_ReturnsAllRequests()
    {
        // Arrange
        var content = """
            ```tool_call
            { "tool": "file-read", "parameters": { "path": "a.txt" } }
            ```

            ```tool_call
            { "tool": "file-read", "parameters": { "path": "b.txt" } }
            ```
            """;

        _mockRegistry.Setup(r => r.GetTool("file-read")).Returns((ITool?)null);

        // Act
        var requests = _parser.Parse(content);

        // Assert
        Assert.Equal(2, requests.Count);
    }

    [Fact]
    public void Parse_NoToolCalls_ReturnsEmptyList()
    {
        // Arrange
        var content = "Just a regular response without any tool calls.";

        // Act
        var requests = _parser.Parse(content);

        // Assert
        Assert.Empty(requests);
    }

    [Fact]
    public void Parse_MalformedJson_LogsWarningAndContinues()
    {
        // Arrange
        var content = """
            ```tool_call
            { invalid json }
            ```
            """;

        // Act
        var requests = _parser.Parse(content);

        // Assert
        Assert.Empty(requests);
        _mockLogger.Verify(
            x => x.Log(
                LogLevel.Warning,
                It.IsAny<EventId>(),
                It.IsAny<It.IsAnyType>(),
                It.IsAny<Exception>(),
                It.IsAny<Func<It.IsAnyType, Exception?, string>>()),
            Times.AtLeastOnce);
    }

    [Fact]
    public void Parse_UnknownTool_ReturnsRequestWithWarning()
    {
        // Arrange
        var content = """
            ```tool_call
            { "tool": "unknown-tool", "parameters": {} }
            ```
            """;
        _mockRegistry.Setup(r => r.GetTool("unknown-tool")).Returns((ITool?)null);

        // Act
        var requests = _parser.Parse(content);

        // Assert
        Assert.Single(requests);
        Assert.Equal("unknown-tool", requests[0].ToolId);
        Assert.NotNull(requests[0].Warnings);
        Assert.Contains(requests[0].Warnings, w => w.Contains("not registered"));
    }

    [Fact]
    public void ExtractText_RemovesToolCallBlocks()
    {
        // Arrange
        var content = """
            Start text.

            ```tool_call
            { "tool": "test", "parameters": {} }
            ```

            End text.
            """;

        // Act
        var text = _parser.ExtractText(content);

        // Assert
        Assert.Contains("Start text", text);
        Assert.Contains("End text", text);
        Assert.DoesNotContain("tool_call", text);
    }

    [Fact]
    public void HasToolCalls_WithToolCall_ReturnsTrue()
    {
        // Arrange
        var content = """
            ```tool_call
            { "tool": "test", "parameters": {} }
            ```
            """;

        // Act & Assert
        Assert.True(_parser.HasToolCalls(content));
    }

    [Fact]
    public void SplitContent_SeparatesTextAndToolCalls()
    {
        // Arrange
        var content = """
            Before text.

            ```tool_call
            { "tool": "test", "parameters": {} }
            ```

            After text.
            """;
        _mockRegistry.Setup(r => r.GetTool("test")).Returns((ITool?)null);

        // Act
        var result = _parser.SplitContent(content);

        // Assert
        Assert.Contains("Before text", result.TextBefore);
        Assert.Contains("After text", result.TextAfter);
        Assert.Single(result.ToolCalls);
    }
}
```

### 2. StreamingFunctionCallParserTests.cs

**Location**: `tests/SeniorIntern.Tests/Services/AI/StreamingFunctionCallParserTests.cs`

```csharp
namespace SeniorIntern.Tests.Services.AI;

using Moq;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Services.AI;
using Xunit;

public class StreamingFunctionCallParserTests
{
    private readonly FunctionCallParser _batchParser;
    private readonly StreamingFunctionCallParser _streamingParser;

    public StreamingFunctionCallParserTests()
    {
        var mockRegistry = new Mock<IToolRegistry>();
        mockRegistry.Setup(r => r.GetTool(It.IsAny<string>())).Returns((ITool?)null);
        var mockLogger = new Mock<ILogger<FunctionCallParser>>();
        _batchParser = new FunctionCallParser(mockRegistry.Object, mockLogger.Object);
        _streamingParser = new StreamingFunctionCallParser(_batchParser);
    }

    [Fact]
    public void ProcessToken_RegularText_ReturnsTextResult()
    {
        // Act
        var result = _streamingParser.ProcessToken("Hello world");

        // Assert
        Assert.True(result.IsText);
        Assert.Equal("Hello world", result.Text);
    }

    [Fact]
    public void ProcessToken_ToolCallStart_BuffersContent()
    {
        // Act
        var result1 = _streamingParser.ProcessToken("Some text ```");
        var result2 = _streamingParser.ProcessToken("tool_call");

        // Assert - should be buffering after detecting potential tool call
        Assert.True(result1.IsBuffering || result1.IsText);
        Assert.True(result2.IsBuffering);
        Assert.Equal(ParserState.InToolCallOpening, _streamingParser.CurrentState);
    }

    [Fact]
    public void ProcessToken_CompleteToolCall_ReturnsToolCallResult()
    {
        // Arrange - simulate streaming a complete tool call
        var tokens = new[]
        {
            "```tool_call\n",
            "{ \"tool\": \"test\",",
            " \"parameters\": {} }",
            "\n```"
        };

        // Act
        ParseResult? toolCallResult = null;
        foreach (var token in tokens)
        {
            var result = _streamingParser.ProcessToken(token);
            if (result.IsToolCall)
                toolCallResult = result;
        }

        // Assert
        Assert.NotNull(toolCallResult);
        Assert.True(toolCallResult.IsToolCall);
        Assert.NotNull(toolCallResult.ToolCall);
        Assert.Equal("test", toolCallResult.ToolCall.ToolId);
    }

    [Fact]
    public void ProcessToken_TextBeforeToolCall_EmitsTextFirst()
    {
        // Arrange
        _streamingParser.ProcessToken("Before ");
        _streamingParser.ProcessToken("text ");

        // Act
        var result = _streamingParser.ProcessToken("```tool_call\n");

        // Assert - should emit the buffered text
        Assert.True(result.IsText || result.IsBuffering);
    }

    [Fact]
    public void Reset_ClearsState()
    {
        // Arrange
        _streamingParser.ProcessToken("```tool_call\n");
        Assert.NotEqual(ParserState.Text, _streamingParser.CurrentState);

        // Act
        _streamingParser.Reset();

        // Assert
        Assert.Equal(ParserState.Text, _streamingParser.CurrentState);
        Assert.Empty(_streamingParser.BufferedContent);
    }

    [Fact]
    public void Flush_ReturnsBufferedContent()
    {
        // Arrange
        _streamingParser.ProcessToken("```tool_call\n");
        _streamingParser.ProcessToken("{ partial");

        // Act
        var flushed = _streamingParser.Flush();

        // Assert
        Assert.Contains("tool_call", flushed);
        Assert.Contains("partial", flushed);
        Assert.Empty(_streamingParser.BufferedContent);
    }

    [Fact]
    public void ProcessToken_TracksJsonBraceDepth()
    {
        // Arrange - nested JSON
        var tokens = new[]
        {
            "```tool_call\n",
            "{ \"tool\": \"test\", \"parameters\": {",
            " \"nested\": { \"deep\": true }",
            " } }\n```"
        };

        // Act
        ParseResult? toolCallResult = null;
        foreach (var token in tokens)
        {
            var result = _streamingParser.ProcessToken(token);
            if (result.IsToolCall)
                toolCallResult = result;
        }

        // Assert - should correctly handle nested braces
        Assert.NotNull(toolCallResult);
        Assert.True(toolCallResult.IsToolCall);
    }
}
```

### 3. AgentStateMachineTests.cs

**Location**: `tests/SeniorIntern.Tests/Services/AI/AgentStateMachineTests.cs`

```csharp
namespace SeniorIntern.Tests.Services.AI;

using SeniorIntern.Core.Models;
using Xunit;

public class AgentStateMachineTests
{
    private readonly AgentStateMachine _stateMachine = new();

    [Fact]
    public void InitialState_IsIdle()
    {
        Assert.Equal(AgentState.Idle, _stateMachine.CurrentState);
        Assert.Equal(0, _stateMachine.IterationNumber);
    }

    [Fact]
    public void TryTransition_Start_MovesToInitializing()
    {
        var result = _stateMachine.TryTransition(AgentStateTransition.Start);

        Assert.True(result);
        Assert.Equal(AgentState.Initializing, _stateMachine.CurrentState);
    }

    [Fact]
    public void TryTransition_InvalidTransition_ReturnsFalse()
    {
        // Can't go directly from Idle to Thinking
        var result = _stateMachine.TryTransition(AgentStateTransition.BeginThinking);

        Assert.False(result);
        Assert.Equal(AgentState.Idle, _stateMachine.CurrentState);
    }

    [Fact]
    public void TryTransition_Cancel_WorksFromNonTerminalStates()
    {
        _stateMachine.TryTransition(AgentStateTransition.Start);
        _stateMachine.TryTransition(AgentStateTransition.BeginThinking);

        var result = _stateMachine.TryTransition(AgentStateTransition.Cancel);

        Assert.True(result);
        Assert.Equal(AgentState.Cancelled, _stateMachine.CurrentState);
    }

    [Fact]
    public void IterationNumber_IncrementsOnBeginThinking()
    {
        _stateMachine.TryTransition(AgentStateTransition.Start);
        Assert.Equal(0, _stateMachine.IterationNumber);

        _stateMachine.TryTransition(AgentStateTransition.BeginThinking);
        Assert.Equal(1, _stateMachine.IterationNumber);

        // Simulate loop back to thinking
        _stateMachine.TryTransition(AgentStateTransition.DetectToolCall);
        _stateMachine.TryTransition(AgentStateTransition.ApprovalGranted);
        _stateMachine.TryTransition(AgentStateTransition.ToolComplete);
        _stateMachine.TryTransition(AgentStateTransition.BeginThinking);
        Assert.Equal(2, _stateMachine.IterationNumber);
    }

    [Fact]
    public void StateChanged_FiresOnTransition()
    {
        AgentStateChangedEventArgs? capturedArgs = null;
        _stateMachine.StateChanged += (_, e) => capturedArgs = e;

        _stateMachine.TryTransition(AgentStateTransition.Start);

        Assert.NotNull(capturedArgs);
        Assert.Equal(AgentState.Idle, capturedArgs.PreviousState);
        Assert.Equal(AgentState.Initializing, capturedArgs.CurrentState);
        Assert.Equal(AgentStateTransition.Start, capturedArgs.Transition);
    }

    [Fact]
    public void Reset_RestoresToIdleState()
    {
        _stateMachine.TryTransition(AgentStateTransition.Start);
        _stateMachine.TryTransition(AgentStateTransition.BeginThinking);

        _stateMachine.Reset();

        Assert.Equal(AgentState.Idle, _stateMachine.CurrentState);
        Assert.Equal(0, _stateMachine.IterationNumber);
    }

    [Fact]
    public void IsTerminalState_TrueForCompletedCancelledError()
    {
        _stateMachine.TryTransition(AgentStateTransition.Start);
        _stateMachine.TryTransition(AgentStateTransition.BeginThinking);
        Assert.False(_stateMachine.IsTerminalState);

        _stateMachine.TryTransition(AgentStateTransition.Complete);
        Assert.True(_stateMachine.IsTerminalState);
    }
}
```

### 4. PermissionManagerTests.cs

**Location**: `tests/SeniorIntern.Tests/Services/AI/PermissionManagerTests.cs`

```csharp
namespace SeniorIntern.Tests.Services.AI;

using Moq;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Core.Tools;
using SeniorIntern.Services.AI;
using Xunit;

public class PermissionManagerTests
{
    private readonly Mock<ISettingsService> _mockSettings;
    private readonly Mock<ILogger<PermissionManager>> _mockLogger;
    private readonly PermissionManager _permissionManager;

    public PermissionManagerTests()
    {
        _mockSettings = new Mock<ISettingsService>();
        _mockLogger = new Mock<ILogger<PermissionManager>>();
        _permissionManager = new PermissionManager(_mockSettings.Object, _mockLogger.Object);
    }

    [Fact]
    public async Task CheckPermission_SafeRisk_AllowsWithoutApproval()
    {
        // Arrange
        var request = new ToolCallRequest { ToolId = "safe-tool", RiskLevel = RiskLevel.Safe };

        // Act
        var result = await _permissionManager.CheckPermissionAsync(request);

        // Assert
        Assert.True(result.IsAllowed);
        Assert.False(result.RequiresApproval);
    }

    [Fact]
    public async Task CheckPermission_HighRisk_RequiresApproval()
    {
        // Arrange
        var request = new ToolCallRequest
        {
            ToolId = "dangerous-tool",
            ToolName = "Dangerous Tool",
            RiskLevel = RiskLevel.High
        };

        // Act
        var result = await _permissionManager.CheckPermissionAsync(request);

        // Assert
        Assert.False(result.IsAllowed);
        Assert.True(result.RequiresApproval);
        Assert.Contains("High", result.ApprovalReason);
    }

    [Fact]
    public async Task RememberDecision_SessionCache_AllowsSubsequentCalls()
    {
        // Arrange
        var toolId = "test-tool";
        var decision = ApprovalDecision.Approve(rememberForSession: true);

        // Act
        await _permissionManager.RememberDecisionAsync(toolId, decision);
        var result = await _permissionManager.CheckPermissionAsync(
            new ToolCallRequest { ToolId = toolId, RiskLevel = RiskLevel.High });

        // Assert
        Assert.True(result.IsAllowed);
        Assert.True(result.WasCached);
    }

    [Fact]
    public async Task ClearSessionPermissions_ClearsCache()
    {
        // Arrange
        var toolId = "test-tool";
        await _permissionManager.RememberDecisionAsync(toolId,
            ApprovalDecision.Approve(rememberForSession: true));

        // Act
        await _permissionManager.ClearSessionPermissionsAsync();
        var result = await _permissionManager.CheckPermissionAsync(
            new ToolCallRequest { ToolId = toolId, RiskLevel = RiskLevel.High });

        // Assert
        Assert.True(result.RequiresApproval);
        Assert.False(result.WasCached);
    }

    [Fact]
    public async Task SetToolPermissions_AlwaysDeny_Blocks()
    {
        // Arrange
        var toolId = "blocked-tool";
        await _permissionManager.SetToolPermissionsAsync(toolId,
            ToolPermissionSettings.AlwaysDenied(toolId));

        // Act
        var result = await _permissionManager.CheckPermissionAsync(
            new ToolCallRequest { ToolId = toolId, RiskLevel = RiskLevel.Safe });

        // Assert
        Assert.True(result.IsDenied);
        Assert.False(result.RequiresApproval);
    }

    [Fact]
    public async Task SetToolPermissions_AlwaysAllow_Permits()
    {
        // Arrange
        var toolId = "trusted-tool";
        await _permissionManager.SetToolPermissionsAsync(toolId,
            ToolPermissionSettings.AlwaysAllowed(toolId));

        // Act
        var result = await _permissionManager.CheckPermissionAsync(
            new ToolCallRequest { ToolId = toolId, RiskLevel = RiskLevel.Critical });

        // Assert
        Assert.True(result.IsAllowed);
        Assert.False(result.RequiresApproval);
    }
}
```

### 5. AgentServiceIntegrationTests.cs

**Location**: `tests/SeniorIntern.Tests/Services/AI/AgentServiceIntegrationTests.cs`

```csharp
namespace SeniorIntern.Tests.Services.AI;

using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Moq;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Core.Tools;
using SeniorIntern.Services.AI;
using SeniorIntern.Tests.Mocks;
using Xunit;

public class AgentServiceIntegrationTests : IAsyncLifetime
{
    private readonly ServiceProvider _serviceProvider;
    private readonly IAgentService _agentService;
    private readonly MockLlmService _mockLlm;

    public AgentServiceIntegrationTests()
    {
        _mockLlm = new MockLlmService();
        var services = new ServiceCollection();

        services.AddSingleton<ILlmService>(_mockLlm);
        services.AddSingleton(CreateMockToolRegistry());
        services.AddSingleton(CreateMockToolExecutionService());
        services.AddSingleton<IPermissionManager, PermissionManager>();
        services.AddSingleton(Mock.Of<IConversationService>());
        services.AddSingleton(Mock.Of<ISettingsService>());
        services.AddSingleton<FunctionCallParser>();
        services.Configure<SemanticKernelConfiguration>(c =>
        {
            c.MaxAgentIterations = 3;
            c.IterationDelay = TimeSpan.Zero;
            c.AgentRequestTimeout = TimeSpan.FromSeconds(30);
        });
        services.AddLogging();
        services.AddSingleton<IAgentService, AgentService>();

        _serviceProvider = services.BuildServiceProvider();
        _agentService = _serviceProvider.GetRequiredService<IAgentService>();
    }

    [Fact]
    public async Task ProcessMessageAsync_SimpleMessage_ReturnsTextEvents()
    {
        // Arrange
        _mockLlm.SetResponse("Hello, how can I help you?");
        var request = AgentRequest.Simple("Hello!");

        // Act
        var events = await CollectEventsAsync(request);

        // Assert
        Assert.Contains(events, e => e is AgentIterationEvent);
        Assert.Contains(events, e => e is TextGenerationEvent);
        Assert.Contains(events, e => e is AgentCompleteEvent);
    }

    [Fact]
    public async Task ProcessMessageAsync_WithToolDisabled_NoToolEvents()
    {
        // Arrange
        _mockLlm.SetResponse("Just text, no tools.");
        var request = new AgentRequest { Message = "Test", EnableTools = false };

        // Act
        var events = await CollectEventsAsync(request);

        // Assert
        Assert.DoesNotContain(events, e => e is ToolCallRequestEvent);
        Assert.DoesNotContain(events, e => e is ToolResultEvent);
    }

    [Fact]
    public async Task ProcessMessageAsync_CompletionEvent_HasStatistics()
    {
        // Arrange
        _mockLlm.SetResponse("Response text.");
        var request = AgentRequest.Simple("Test");

        // Act
        var events = await CollectEventsAsync(request);
        var complete = events.OfType<AgentCompleteEvent>().First();

        // Assert
        Assert.True(complete.TotalDuration > TimeSpan.Zero);
        Assert.True(complete.TotalTokens > 0);
        Assert.Equal(1, complete.TotalIterations);
    }

    [Fact]
    public async Task CancelAsync_DuringProcessing_EmitsCancelledEvent()
    {
        // Arrange
        _mockLlm.SetSlowResponse("Slow response", delayPerToken: 100);
        var request = AgentRequest.Simple("Test");

        // Act
        var cts = new CancellationTokenSource();
        var collectTask = Task.Run(async () =>
        {
            var events = new List<AgentEvent>();
            await foreach (var evt in _agentService.ProcessMessageAsync(request, cts.Token))
                events.Add(evt);
            return events;
        });

        await Task.Delay(50);
        await _agentService.CancelAsync();

        var events = await collectTask;
        var complete = events.OfType<AgentCompleteEvent>().FirstOrDefault();

        // Assert
        Assert.NotNull(complete);
        Assert.True(complete.WasCancelled);
    }

    [Fact]
    public async Task State_DuringProcessing_ReflectsCurrentState()
    {
        // Arrange
        _mockLlm.SetSlowResponse("Response", delayPerToken: 50);
        var request = AgentRequest.Simple("Test");
        var statesObserved = new List<AgentState>();

        _agentService.StateChanged += (_, e) => statesObserved.Add(e.CurrentState);

        // Act
        await CollectEventsAsync(request);

        // Assert
        Assert.Contains(AgentState.Initializing, statesObserved);
        Assert.Contains(AgentState.Thinking, statesObserved);
    }

    [Fact]
    public async Task ProcessMessageAsync_RespectsIterationLimit()
    {
        // Arrange - LLM always returns tool call
        _mockLlm.SetToolCallResponse("file-read", new { path = "test.txt" });
        var request = new AgentRequest
        {
            Message = "Read many files",
            EnableTools = true,
            MaxIterations = 2
        };

        // Act
        var events = await CollectEventsAsync(request);
        var complete = events.OfType<AgentCompleteEvent>().First();

        // Assert
        Assert.True(complete.TotalIterations <= 2);
    }

    private async Task<List<AgentEvent>> CollectEventsAsync(AgentRequest request)
    {
        var events = new List<AgentEvent>();
        await foreach (var evt in _agentService.ProcessMessageAsync(request))
            events.Add(evt);
        return events;
    }

    private static IToolRegistry CreateMockToolRegistry()
    {
        var mock = new Mock<IToolRegistry>();
        mock.Setup(r => r.GetAvailableTools(It.IsAny<ToolAvailabilityContext>()))
            .Returns(Array.Empty<ITool>());
        mock.Setup(r => r.GetTool(It.IsAny<string>())).Returns((ITool?)null);
        return mock.Object;
    }

    private static IToolExecutionService CreateMockToolExecutionService()
    {
        var mock = new Mock<IToolExecutionService>();
        mock.Setup(s => s.ExecuteAsync(
                It.IsAny<ITool>(),
                It.IsAny<ToolExecutionContext>(),
                It.IsAny<CancellationToken>()))
            .ReturnsAsync(ToolResult.Success("Mock result"));
        return mock.Object;
    }

    public Task InitializeAsync() => Task.CompletedTask;
    public async Task DisposeAsync() => await _serviceProvider.DisposeAsync();
}
```

### 6. MockTool.cs

**Location**: `tests/SeniorIntern.Tests/Mocks/MockTool.cs`

```csharp
namespace SeniorIntern.Tests.Mocks;

using System.Text.Json;
using SeniorIntern.Core.Tools;

/// <summary>
/// Configurable mock tool for testing agent behavior.
/// </summary>
public sealed class MockTool : ITool
{
    public string Id { get; set; } = "mock-tool";
    public string Name { get; set; } = "Mock Tool";
    public string Description { get; set; } = "A mock tool for testing";
    public ToolCategory Category { get; set; } = ToolCategory.Custom;
    public RiskLevel DefaultRiskLevel { get; set; } = RiskLevel.Safe;
    public JsonSchema InputSchema { get; set; } = new() { Type = "object" };
    public bool IsAvailable { get; set; } = true;
    public IReadOnlyList<string> Tags { get; set; } = Array.Empty<string>();

    public Func<ToolExecutionContext, Task<ToolResult>>? ExecuteHandler { get; set; }
    public Func<JsonElement, ToolValidationResult>? ValidateHandler { get; set; }

    public Task<ToolResult> ExecuteAsync(ToolExecutionContext context, CancellationToken ct = default)
        => ExecuteHandler?.Invoke(context) ?? Task.FromResult(ToolResult.Success("Mock success"));

    public ToolValidationResult Validate(JsonElement parameters)
        => ValidateHandler?.Invoke(parameters) ?? ToolValidationResult.Valid();

    public string GetExecutionSummary(JsonElement parameters) => $"Execute {Name}";
    public RiskLevel GetEffectiveRiskLevel(JsonElement parameters) => DefaultRiskLevel;

    // Factory methods
    public static MockTool Safe(string id = "safe-mock") => new() { Id = id, DefaultRiskLevel = RiskLevel.Safe };
    public static MockTool Risky(string id = "risky-mock") => new() { Id = id, DefaultRiskLevel = RiskLevel.High };

    public static MockTool WithResult(string id, ToolResult result) => new()
    {
        Id = id,
        ExecuteHandler = _ => Task.FromResult(result)
    };

    public static MockTool Failing(string id, string error) => new()
    {
        Id = id,
        ExecuteHandler = _ => Task.FromResult(ToolResult.Failed(error))
    };
}
```

### 7. MockLlmService.cs

**Location**: `tests/SeniorIntern.Tests/Mocks/MockLlmService.cs`

```csharp
namespace SeniorIntern.Tests.Mocks;

using System.Text.Json;
using SeniorIntern.Core.Interfaces;

/// <summary>
/// Configurable mock LLM service for testing.
/// </summary>
public sealed class MockLlmService : ILlmService
{
    private string _responseContent = "Default response";
    private int _delayPerToken = 0;
    private bool _isLoaded = true;

    public bool IsModelLoaded => _isLoaded;
    public string? LoadedModelPath => _isLoaded ? "mock-model" : null;

    public void SetResponse(string content) => _responseContent = content;

    public void SetSlowResponse(string content, int delayPerToken)
    {
        _responseContent = content;
        _delayPerToken = delayPerToken;
    }

    public void SetToolCallResponse(string toolId, object parameters)
    {
        var json = JsonSerializer.Serialize(new { tool = toolId, parameters });
        _responseContent = $"```tool_call\n{json}\n```";
    }

    public void SetLoaded(bool loaded) => _isLoaded = loaded;

    public async IAsyncEnumerable<string> GenerateStreamingAsync(
        string prompt,
        InferenceOptions options,
        [EnumeratorCancellation] CancellationToken ct = default)
    {
        var words = _responseContent.Split(' ');
        foreach (var word in words)
        {
            ct.ThrowIfCancellationRequested();
            if (_delayPerToken > 0)
                await Task.Delay(_delayPerToken, ct);
            yield return word + " ";
        }
    }

    public Task<string> GenerateAsync(string prompt, InferenceOptions options, CancellationToken ct = default)
        => Task.FromResult(_responseContent);

    public Task LoadModelAsync(string modelPath, CancellationToken ct = default)
    {
        _isLoaded = true;
        return Task.CompletedTask;
    }

    public Task UnloadModelAsync() { _isLoaded = false; return Task.CompletedTask; }
    public void Dispose() { }
}
```

---

## File Summary

| File | Location | Tests | Purpose |
|------|----------|-------|---------|
| `FunctionCallParserTests.cs` | `Tests/Services/AI/` | 8 | Batch parsing |
| `StreamingFunctionCallParserTests.cs` | `Tests/Services/AI/` | 7 | Streaming parsing |
| `AgentStateMachineTests.cs` | `Tests/Services/AI/` | 8 | State transitions |
| `PermissionManagerTests.cs` | `Tests/Services/AI/` | 6 | Permission caching |
| `AgentServiceIntegrationTests.cs` | `Tests/Services/AI/` | 6 | End-to-end agent |
| `MockTool.cs` | `Tests/Mocks/` | - | Configurable ITool |
| `MockLlmService.cs` | `Tests/Mocks/` | - | Configurable ILlmService |

**Total Tests**: ~35

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | Parser tests cover valid and malformed input |
| AC-2 | Streaming parser tests verify token-by-token parsing |
| AC-3 | State machine tests verify all valid transitions |
| AC-4 | Integration tests verify end-to-end agent loop |
| AC-5 | Mock tools enable isolated testing |
| AC-6 | All tests pass in CI |

---

## Changelog Entry

```markdown
## v0.6.2j - Testing Infrastructure

### Added
- `FunctionCallParserTests` (8 tests) for batch parsing
- `StreamingFunctionCallParserTests` (7 tests) for streaming
- `AgentStateMachineTests` (8 tests) for state transitions
- `PermissionManagerTests` (6 tests) for permissions
- `AgentServiceIntegrationTests` (6 tests) for agent loop
- `MockTool` with configurable handlers
- `MockLlmService` with response configuration
```

---

## Timeline Estimate

| Version | Estimated Effort |
|---------|------------------|
| v0.6.2j | 1 day |
