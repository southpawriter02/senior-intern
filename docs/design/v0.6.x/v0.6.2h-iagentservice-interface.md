# Design Specification: AIntern v0.6.2h "IAgentService Interface"

## Overview

**Version**: v0.6.2h
**Parent**: v0.6.2 Semantic Kernel Integration
**Focus**: Service interface for agent orchestration with streaming events and permissions

### Purpose

This sub-version defines the contracts for agent orchestration:
1. Create `IAgentService` interface for agent orchestration
2. Create `IPermissionManager` interface for tool permission handling
3. Create `PermissionCheckResult` for permission query responses
4. Create `ToolPermissionSettings` for persistent permissions
5. Define streaming event pattern with `IAsyncEnumerable<AgentEvent>`
6. Support cancellation, approval flow, and state tracking
7. Enable permission caching for session and permanent decisions

### Dependencies

**From v0.6.2c (Agent Request Models)**:
- `AgentRequest` as input to ProcessMessageAsync

**From v0.6.2d (Agent State Management)**:
- `AgentState` for state property
- `AgentStateChangedEventArgs` for StateChanged event

**From v0.6.2e (Agent Event System)**:
- `AgentEvent` hierarchy for streaming events

**From v0.6.2f (Tool Call Request Models)**:
- `ToolCallRequest` for permission checks
- `ApprovalDecision` for user responses

**Future Consumers**:
- v0.6.2i: AgentService implementation
- v0.6.2j: PermissionManager implementation
- UI Layer: Calls IAgentService, provides approvals

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                   v0.6.2h IAgentService Interface Architecture                │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  src/SeniorIntern.Core/Interfaces/                                           │
│  ├─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  IAgentService                                                           │ │
│  │  ┌─────────────────────────────────────────────────────────────────────┐│ │
│  │  │  Core Methods                                                        ││ │
│  │  │  ├── ProcessMessageAsync(request, ct)                               ││ │
│  │  │  │      → IAsyncEnumerable<AgentEvent>                              ││ │
│  │  │  ├── CancelAsync()                                                   ││ │
│  │  │  └── ProvideApprovalAsync(requestId, decision)                       ││ │
│  │  │                                                                      ││ │
│  │  │  State Properties                                                     ││ │
│  │  │  ├── State: AgentState                                               ││ │
│  │  │  ├── IsProcessing: bool                                              ││ │
│  │  │  └── CurrentIteration: int                                           ││ │
│  │  │                                                                      ││ │
│  │  │  Events                                                               ││ │
│  │  │  └── StateChanged: EventHandler<AgentStateChangedEventArgs>          ││ │
│  │  └─────────────────────────────────────────────────────────────────────┘│ │
│  │                                                                          │ │
│  │  IPermissionManager                                                      │ │
│  │  ┌─────────────────────────────────────────────────────────────────────┐│ │
│  │  │  Permission Checking                                                 ││ │
│  │  │  ├── CheckPermissionAsync(request) → PermissionCheckResult          ││ │
│  │  │  └── RequiresApprovalAsync(request) → bool                          ││ │
│  │  │                                                                      ││ │
│  │  │  Decision Management                                                  ││ │
│  │  │  ├── RememberDecisionAsync(toolId, decision)                         ││ │
│  │  │  ├── ClearSessionPermissionsAsync()                                  ││ │
│  │  │  └── ClearAllRememberedAsync()                                       ││ │
│  │  │                                                                      ││ │
│  │  │  Settings                                                             ││ │
│  │  │  ├── GetToolPermissionsAsync(toolId) → ToolPermissionSettings?      ││ │
│  │  │  └── SetToolPermissionsAsync(toolId, settings)                       ││ │
│  │  └─────────────────────────────────────────────────────────────────────┘│ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  src/SeniorIntern.Core/Models/                                               │
│  ├─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  PermissionCheckResult              ToolPermissionSettings               │ │
│  │  ┌──────────────────────────┐      ┌────────────────────────────────┐   │ │
│  │  │  IsAllowed: bool         │      │  ToolId: string                │   │ │
│  │  │  RequiresApproval: bool  │      │  AlwaysAllow: bool             │   │ │
│  │  │  ApprovalReason: string? │      │  AlwaysDeny: bool              │   │ │
│  │  │  WasCached: bool         │      │  AllowedPatterns: List<string> │   │ │
│  │  │  CacheSource: CacheSource│      │  DeniedPatterns: List<string>  │   │ │
│  │  │  RiskLevel: RiskLevel    │      │  MaxRiskAutoApproval: RiskLevel│   │ │
│  │  └──────────────────────────┘      └────────────────────────────────┘   │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Interaction Flow

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                        IAgentService Interaction Flow                         │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ViewModel/UI                          IAgentService                         │
│      │                                       │                               │
│      │  1. Subscribe to StateChanged         │                               │
│      │ ─────────────────────────────────────►│                               │
│      │                                       │                               │
│      │  2. ProcessMessageAsync(request)      │                               │
│      │ ─────────────────────────────────────►│                               │
│      │                                       │                               │
│      │            StartedEvent               │                               │
│      │ ◄─────────────────────────────────────│                               │
│      │                                       │                               │
│      │           IterationEvent              │                               │
│      │ ◄─────────────────────────────────────│                               │
│      │                                       │                               │
│      │         TextGenerationEvent           │ (multiple)                    │
│      │ ◄─────────────────────────────────────│                               │
│      │                                       │                               │
│      │         ToolCallRequestEvent          │                               │
│      │ ◄─────────────────────────────────────│                               │
│      │                                       │                               │
│      │         ApprovalRequestEvent          │                               │
│      │ ◄─────────────────────────────────────│                               │
│      │                                       │                               │
│      │  3. [User interacts with dialog]      │                               │
│      │                                       │                               │
│      │  4. ProvideApprovalAsync(id, decision)│                               │
│      │ ─────────────────────────────────────►│                               │
│      │                                       │                               │
│      │         ToolExecutionEvent            │                               │
│      │ ◄─────────────────────────────────────│                               │
│      │                                       │                               │
│      │          ToolResultEvent              │                               │
│      │ ◄─────────────────────────────────────│                               │
│      │                                       │                               │
│      │         TextGenerationEvent           │ (final response)              │
│      │ ◄─────────────────────────────────────│                               │
│      │                                       │                               │
│      │         AgentCompleteEvent            │                               │
│      │ ◄─────────────────────────────────────│                               │
│      │                                       │                               │
│      └───────────────────────────────────────┘                               │
│                                                                              │
│  Cancellation Flow:                                                          │
│                                                                              │
│  ViewModel/UI                          IAgentService                         │
│      │                                       │                               │
│      │  [Processing in progress]             │                               │
│      │                                       │                               │
│      │  CancelAsync()                        │                               │
│      │ ─────────────────────────────────────►│                               │
│      │                                       │                               │
│      │  StateChanged: State = Cancelled      │                               │
│      │ ◄─────────────────────────────────────│                               │
│      │                                       │                               │
│      │  AgentCompleteEvent(wasCancelled=true)│                               │
│      │ ◄─────────────────────────────────────│                               │
│      │                                       │                               │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Permission Flow

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                        IPermissionManager Permission Flow                     │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  AgentService                      IPermissionManager                        │
│      │                                       │                               │
│      │  1. CheckPermissionAsync(request)     │                               │
│      │ ─────────────────────────────────────►│                               │
│      │                                       │                               │
│      │     ┌─────────────────────────────────┴───────────────────────────┐  │
│      │     │ Check flow:                                                  │  │
│      │     │ 1. Check AlwaysDeny → Deny immediately                       │  │
│      │     │ 2. Check AlwaysAllow → Allow immediately                     │  │
│      │     │ 3. Check AllowedPatterns → Allow if match                    │  │
│      │     │ 4. Check DeniedPatterns → Deny if match                      │  │
│      │     │ 5. Check session cache → Return cached decision              │  │
│      │     │ 6. Check RiskLevel vs threshold → Allow/RequireApproval      │  │
│      │     └─────────────────────────────────┬───────────────────────────┘  │
│      │                                       │                               │
│      │  PermissionCheckResult                │                               │
│      │  ├── IsAllowed: false                 │                               │
│      │  ├── RequiresApproval: true           │                               │
│      │  ├── ApprovalReason: "High risk op"   │                               │
│      │  └── WasCached: false                 │                               │
│      │ ◄─────────────────────────────────────│                               │
│      │                                       │                               │
│      │  [After user approves with remember]  │                               │
│      │                                       │                               │
│      │  2. RememberDecisionAsync(toolId,     │                               │
│      │        decision{RememberForSession})  │                               │
│      │ ─────────────────────────────────────►│                               │
│      │                                       │                               │
│      │   [Decision cached for session]       │                               │
│      │                                       │                               │
│      │  [Next similar request]               │                               │
│      │                                       │                               │
│      │  3. CheckPermissionAsync(request)     │                               │
│      │ ─────────────────────────────────────►│                               │
│      │                                       │                               │
│      │  PermissionCheckResult                │                               │
│      │  ├── IsAllowed: true                  │                               │
│      │  ├── RequiresApproval: false          │                               │
│      │  └── WasCached: true                  │                               │
│      │ ◄─────────────────────────────────────│                               │
│      │                                       │                               │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Specifications

### 1. IAgentService.cs

**Location**: `src/SeniorIntern.Core/Interfaces/IAgentService.cs`

```csharp
namespace SeniorIntern.Core.Interfaces;

using SeniorIntern.Core.Models;

/// <summary>
/// Service for managing AI agent interactions with tool capabilities.
/// </summary>
/// <remarks>
/// <para>
/// IAgentService orchestrates the complete agent loop:
/// </para>
/// <list type="bullet">
/// <item>Processing user messages with LLM</item>
/// <item>Detecting and executing tool calls</item>
/// <item>Managing approval flows for risky operations</item>
/// <item>Streaming events to UI for real-time updates</item>
/// </list>
/// <para>
/// The service follows a streaming pattern using IAsyncEnumerable,
/// yielding events as processing progresses. This enables real-time
/// UI updates for token streaming, tool execution, and completion.
/// </para>
/// </remarks>
public interface IAgentService
{
    #region Processing

    /// <summary>
    /// Process a user message with potential tool execution.
    /// </summary>
    /// <param name="request">The agent request with message and context.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>Async enumerable of agent events.</returns>
    /// <remarks>
    /// <para>
    /// Events are yielded in order as processing progresses:
    /// </para>
    /// <list type="number">
    /// <item>AgentIterationEvent (start of each loop)</item>
    /// <item>TextGenerationEvent (streaming tokens)</item>
    /// <item>ToolCallRequestEvent (tool detected)</item>
    /// <item>ApprovalRequestEvent (if approval needed)</item>
    /// <item>ToolExecutionEvent (execution progress)</item>
    /// <item>ToolResultEvent (execution complete)</item>
    /// <item>AgentCompleteEvent or AgentErrorEvent (final)</item>
    /// </list>
    /// <para>
    /// The caller should iterate the enumerable to receive events:
    /// </para>
    /// <code>
    /// await foreach (var evt in agentService.ProcessMessageAsync(request, ct))
    /// {
    ///     switch (evt)
    ///     {
    ///         case TextGenerationEvent text: HandleText(text); break;
    ///         case ApprovalRequestEvent approval: ShowApprovalDialog(approval); break;
    ///         // ...
    ///     }
    /// }
    /// </code>
    /// </remarks>
    IAsyncEnumerable<AgentEvent> ProcessMessageAsync(
        AgentRequest request,
        CancellationToken ct = default);

    /// <summary>
    /// Cancel the current agent execution.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Cancellation is cooperative and may not be immediate.
    /// The agent will:
    /// </para>
    /// <list type="bullet">
    /// <item>Stop LLM generation at next opportunity</item>
    /// <item>Cancel any pending tool execution</item>
    /// <item>Emit cancellation events</item>
    /// <item>Transition to Cancelled state</item>
    /// </list>
    /// <para>
    /// If no processing is active, this is a no-op.
    /// </para>
    /// </remarks>
    Task CancelAsync();

    #endregion

    #region State

    /// <summary>
    /// Current state of the agent.
    /// </summary>
    AgentState State { get; }

    /// <summary>
    /// Whether the agent is currently processing a request.
    /// </summary>
    /// <remarks>
    /// True when State is not Idle, Completed, Cancelled, or Error.
    /// </remarks>
    bool IsProcessing { get; }

    /// <summary>
    /// Current iteration number if processing.
    /// </summary>
    /// <remarks>
    /// 1-based. Returns 0 when not processing.
    /// Increments each time the agent enters the Thinking state.
    /// </remarks>
    int CurrentIteration { get; }

    /// <summary>
    /// ID of the current request being processed.
    /// </summary>
    /// <remarks>
    /// Guid.Empty when not processing.
    /// </remarks>
    Guid CurrentRequestId { get; }

    /// <summary>
    /// Event fired when agent state changes.
    /// </summary>
    event EventHandler<AgentStateChangedEventArgs>? StateChanged;

    #endregion

    #region Approval Flow

    /// <summary>
    /// Provide an approval decision for a pending tool call.
    /// </summary>
    /// <param name="requestId">The tool call request ID.</param>
    /// <param name="decision">The user's decision.</param>
    /// <remarks>
    /// <para>
    /// Called by UI when user responds to an approval request.
    /// The decision is matched to the pending approval by request ID.
    /// </para>
    /// <para>
    /// If the request ID is not found (already processed or timed out),
    /// this call is ignored.
    /// </para>
    /// </remarks>
    Task ProvideApprovalAsync(Guid requestId, ApprovalDecision decision);

    /// <summary>
    /// Check if there are pending approvals.
    /// </summary>
    bool HasPendingApprovals { get; }

    /// <summary>
    /// Get pending approval requests.
    /// </summary>
    IReadOnlyList<ToolCallRequest> GetPendingApprovals();

    /// <summary>
    /// Cancel all pending approval requests.
    /// </summary>
    /// <remarks>
    /// All pending requests are denied with "Cancelled" reason.
    /// </remarks>
    Task CancelPendingApprovalsAsync();

    #endregion
}

/// <summary>
/// Extension methods for IAgentService.
/// </summary>
public static class AgentServiceExtensions
{
    /// <summary>
    /// Process a simple message (no files, default options).
    /// </summary>
    public static IAsyncEnumerable<AgentEvent> ProcessMessageAsync(
        this IAgentService service,
        string message,
        CancellationToken ct = default)
    {
        var request = AgentRequest.Simple(message);
        return service.ProcessMessageAsync(request, ct);
    }

    /// <summary>
    /// Process a message in an existing conversation.
    /// </summary>
    public static IAsyncEnumerable<AgentEvent> ProcessMessageAsync(
        this IAgentService service,
        string message,
        Guid conversationId,
        CancellationToken ct = default)
    {
        var request = AgentRequest.InConversation(message, conversationId);
        return service.ProcessMessageAsync(request, ct);
    }

    /// <summary>
    /// Wait for processing to complete.
    /// </summary>
    public static async Task WaitForCompletionAsync(
        this IAgentService service,
        CancellationToken ct = default)
    {
        while (service.IsProcessing && !ct.IsCancellationRequested)
        {
            await Task.Delay(50, ct);
        }
    }
}
```

### 2. IPermissionManager.cs

**Location**: `src/SeniorIntern.Core/Interfaces/IPermissionManager.cs`

```csharp
namespace SeniorIntern.Core.Interfaces;

using SeniorIntern.Core.Models;
using SeniorIntern.Core.Tools;

/// <summary>
/// Manages tool execution permissions and approval caching.
/// </summary>
/// <remarks>
/// <para>
/// IPermissionManager provides a centralized way to check and remember
/// tool approval decisions. It supports:
/// </para>
/// <list type="bullet">
/// <item>Per-tool always allow/deny settings</item>
/// <item>Pattern-based permissions (file paths, commands)</item>
/// <item>Session-scoped caching of user decisions</item>
/// <item>Risk-level-based auto-approval</item>
/// </list>
/// <para>
/// Permission check order:
/// </para>
/// <list type="number">
/// <item>AlwaysDeny settings (immediate deny)</item>
/// <item>AlwaysAllow settings (immediate allow)</item>
/// <item>Denied patterns (deny if match)</item>
/// <item>Allowed patterns (allow if match)</item>
/// <item>Session cache (return cached decision)</item>
/// <item>Risk level vs threshold (allow or require approval)</item>
/// </list>
/// </remarks>
public interface IPermissionManager
{
    #region Permission Checking

    /// <summary>
    /// Check if a tool call requires approval.
    /// </summary>
    /// <param name="request">The tool call request to check.</param>
    /// <returns>Permission check result.</returns>
    Task<PermissionCheckResult> CheckPermissionAsync(ToolCallRequest request);

    /// <summary>
    /// Quick check if approval is required.
    /// </summary>
    /// <param name="request">The tool call request to check.</param>
    /// <returns>True if approval is required.</returns>
    Task<bool> RequiresApprovalAsync(ToolCallRequest request);

    /// <summary>
    /// Check permission for a tool ID and risk level.
    /// </summary>
    /// <param name="toolId">The tool ID.</param>
    /// <param name="riskLevel">The risk level.</param>
    /// <returns>Permission check result.</returns>
    Task<PermissionCheckResult> CheckPermissionAsync(string toolId, RiskLevel riskLevel);

    #endregion

    #region Decision Management

    /// <summary>
    /// Remember a user's approval decision.
    /// </summary>
    /// <param name="toolId">The tool ID.</param>
    /// <param name="decision">The decision to remember.</param>
    /// <remarks>
    /// <para>
    /// Based on the decision's remember flags:
    /// </para>
    /// <list type="bullet">
    /// <item>RememberForSession: Cache in memory for this session</item>
    /// <item>RememberForTool: Persist to settings</item>
    /// <item>RememberPattern: Remember for matching pattern only</item>
    /// </list>
    /// </remarks>
    Task RememberDecisionAsync(string toolId, ApprovalDecision decision);

    /// <summary>
    /// Remember a decision with a specific pattern.
    /// </summary>
    /// <param name="toolId">The tool ID.</param>
    /// <param name="pattern">The pattern (e.g., file path pattern).</param>
    /// <param name="allow">Whether to allow or deny.</param>
    /// <param name="persistent">Whether to persist beyond session.</param>
    Task RememberPatternAsync(string toolId, string pattern, bool allow, bool persistent = false);

    /// <summary>
    /// Clear session-based permission cache.
    /// </summary>
    /// <remarks>
    /// Clears all session-scoped remembered decisions.
    /// Persistent settings are not affected.
    /// </remarks>
    Task ClearSessionPermissionsAsync();

    /// <summary>
    /// Clear all remembered permissions (session and persistent).
    /// </summary>
    Task ClearAllRememberedAsync();

    #endregion

    #region Tool Settings

    /// <summary>
    /// Get current permission settings for a tool.
    /// </summary>
    /// <param name="toolId">The tool ID.</param>
    /// <returns>Settings if configured, null otherwise.</returns>
    Task<ToolPermissionSettings?> GetToolPermissionsAsync(string toolId);

    /// <summary>
    /// Set permission settings for a tool.
    /// </summary>
    /// <param name="toolId">The tool ID.</param>
    /// <param name="settings">The settings to apply.</param>
    Task SetToolPermissionsAsync(string toolId, ToolPermissionSettings settings);

    /// <summary>
    /// Remove permission settings for a tool.
    /// </summary>
    /// <param name="toolId">The tool ID.</param>
    Task RemoveToolPermissionsAsync(string toolId);

    /// <summary>
    /// Get all configured tool permission settings.
    /// </summary>
    Task<IReadOnlyDictionary<string, ToolPermissionSettings>> GetAllToolPermissionsAsync();

    #endregion

    #region Global Settings

    /// <summary>
    /// Maximum risk level for automatic approval.
    /// </summary>
    RiskLevel AutoApprovalThreshold { get; set; }

    /// <summary>
    /// Whether to prompt for unsafe operations even if remembered.
    /// </summary>
    bool AlwaysPromptForUnsafe { get; set; }

    #endregion
}
```

### 3. PermissionCheckResult.cs

**Location**: `src/SeniorIntern.Core/Models/PermissionCheckResult.cs`

```csharp
namespace SeniorIntern.Core.Models;

using SeniorIntern.Core.Tools;

/// <summary>
/// Result of a permission check.
/// </summary>
/// <remarks>
/// <para>
/// Possible outcomes:
/// </para>
/// <list type="bullet">
/// <item>IsAllowed=true, RequiresApproval=false: Auto-approved, execute immediately</item>
/// <item>IsAllowed=false, RequiresApproval=true: Show approval dialog</item>
/// <item>IsAllowed=false, RequiresApproval=false: Denied by policy, don't execute</item>
/// </list>
/// </remarks>
public sealed class PermissionCheckResult
{
    /// <summary>
    /// Whether the tool call is allowed without approval.
    /// </summary>
    public bool IsAllowed { get; init; }

    /// <summary>
    /// Whether explicit user approval is required.
    /// </summary>
    public bool RequiresApproval { get; init; }

    /// <summary>
    /// Whether the tool call is denied by policy.
    /// </summary>
    public bool IsDenied => !IsAllowed && !RequiresApproval;

    /// <summary>
    /// Reason for the permission decision.
    /// </summary>
    /// <remarks>
    /// Used in approval dialogs and logging.
    /// </remarks>
    public string? Reason { get; init; }

    /// <summary>
    /// Reason for requiring approval (if RequiresApproval).
    /// </summary>
    public string? ApprovalReason { get; init; }

    /// <summary>
    /// Whether this permission was from cached decision.
    /// </summary>
    public bool WasCached { get; init; }

    /// <summary>
    /// Source of the cached decision.
    /// </summary>
    public CacheSource CacheSource { get; init; }

    /// <summary>
    /// The risk level that triggered this decision.
    /// </summary>
    public RiskLevel RiskLevel { get; init; }

    /// <summary>
    /// Pattern that matched (if pattern-based decision).
    /// </summary>
    public string? MatchedPattern { get; init; }

    #region Factory Methods

    /// <summary>
    /// Create an "allowed" result.
    /// </summary>
    public static PermissionCheckResult Allowed(
        string? reason = null,
        bool wasCached = false,
        CacheSource cacheSource = CacheSource.None) => new()
    {
        IsAllowed = true,
        RequiresApproval = false,
        Reason = reason ?? "Automatically approved",
        WasCached = wasCached,
        CacheSource = cacheSource
    };

    /// <summary>
    /// Create a "requires approval" result.
    /// </summary>
    public static PermissionCheckResult NeedsApproval(
        string reason,
        RiskLevel riskLevel = RiskLevel.Medium) => new()
    {
        IsAllowed = false,
        RequiresApproval = true,
        ApprovalReason = reason,
        RiskLevel = riskLevel
    };

    /// <summary>
    /// Create a "denied" result.
    /// </summary>
    public static PermissionCheckResult Denied(
        string reason,
        string? matchedPattern = null) => new()
    {
        IsAllowed = false,
        RequiresApproval = false,
        Reason = reason,
        MatchedPattern = matchedPattern
    };

    /// <summary>
    /// Create a cached allowed result.
    /// </summary>
    public static PermissionCheckResult CachedAllowed(CacheSource source) =>
        Allowed("Previously approved", wasCached: true, cacheSource: source);

    /// <summary>
    /// Create a pattern-matched result.
    /// </summary>
    public static PermissionCheckResult PatternMatched(
        string pattern,
        bool allowed) => new()
    {
        IsAllowed = allowed,
        RequiresApproval = false,
        Reason = allowed ? "Matches allowed pattern" : "Matches denied pattern",
        MatchedPattern = pattern
    };

    #endregion

    /// <inheritdoc />
    public override string ToString() =>
        IsAllowed ? $"Allowed: {Reason}"
        : RequiresApproval ? $"NeedsApproval: {ApprovalReason}"
        : $"Denied: {Reason}";
}

/// <summary>
/// Source of a cached permission decision.
/// </summary>
public enum CacheSource
{
    /// <summary>Not from cache.</summary>
    None,

    /// <summary>Session-scoped cache.</summary>
    Session,

    /// <summary>Persistent settings.</summary>
    Persistent,

    /// <summary>Pattern match from settings.</summary>
    Pattern,

    /// <summary>Tool-level always allow/deny.</summary>
    ToolSetting
}
```

### 4. ToolPermissionSettings.cs

**Location**: `src/SeniorIntern.Core/Models/ToolPermissionSettings.cs`

```csharp
namespace SeniorIntern.Core.Models;

using SeniorIntern.Core.Tools;
using System.Text.Json.Serialization;

/// <summary>
/// Persistent permission settings for a tool.
/// </summary>
/// <remarks>
/// <para>
/// ToolPermissionSettings allow fine-grained control over tool execution:
/// </para>
/// <list type="bullet">
/// <item>Always allow/deny the entire tool</item>
/// <item>Pattern-based rules for specific operations</item>
/// <item>Risk-level thresholds per tool</item>
/// </list>
/// <para>
/// Settings are persisted via ISettingsService and loaded at startup.
/// </para>
/// </remarks>
public sealed class ToolPermissionSettings
{
    /// <summary>
    /// Tool ID these settings apply to.
    /// </summary>
    [JsonPropertyName("toolId")]
    public string ToolId { get; init; } = string.Empty;

    /// <summary>
    /// Always allow this tool without approval.
    /// </summary>
    /// <remarks>
    /// Takes precedence over risk level checks.
    /// Use with caution for safe tools only.
    /// </remarks>
    [JsonPropertyName("alwaysAllow")]
    public bool AlwaysAllow { get; init; }

    /// <summary>
    /// Always deny this tool.
    /// </summary>
    /// <remarks>
    /// Takes precedence over all other settings.
    /// Useful for disabling dangerous tools.
    /// </remarks>
    [JsonPropertyName("alwaysDeny")]
    public bool AlwaysDeny { get; init; }

    /// <summary>
    /// Patterns that are automatically allowed.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Glob patterns that match tool parameters:
    /// </para>
    /// <list type="bullet">
    /// <item>file-read: "/src/**/*.cs" allows reading C# files in src</item>
    /// <item>terminal-execute: "npm *" allows npm commands</item>
    /// </list>
    /// </remarks>
    [JsonPropertyName("allowedPatterns")]
    public IReadOnlyList<string>? AllowedPatterns { get; init; }

    /// <summary>
    /// Patterns that are automatically denied.
    /// </summary>
    /// <remarks>
    /// Takes precedence over AllowedPatterns.
    /// </remarks>
    [JsonPropertyName("deniedPatterns")]
    public IReadOnlyList<string>? DeniedPatterns { get; init; }

    /// <summary>
    /// Maximum risk level for auto-approval on this tool.
    /// </summary>
    /// <remarks>
    /// Overrides the global auto-approval threshold for this tool.
    /// </remarks>
    [JsonPropertyName("maxRiskAutoApproval")]
    public RiskLevel? MaxRiskAutoApproval { get; init; }

    /// <summary>
    /// Whether to show detailed parameters in approval dialogs.
    /// </summary>
    [JsonPropertyName("showDetailedParameters")]
    public bool ShowDetailedParameters { get; init; } = true;

    /// <summary>
    /// Custom approval message for this tool.
    /// </summary>
    [JsonPropertyName("customApprovalMessage")]
    public string? CustomApprovalMessage { get; init; }

    /// <summary>
    /// When these settings were last modified.
    /// </summary>
    [JsonPropertyName("lastModified")]
    public DateTime LastModified { get; init; } = DateTime.UtcNow;

    #region Computed Properties

    /// <summary>
    /// Whether any patterns are configured.
    /// </summary>
    [JsonIgnore]
    public bool HasPatterns =>
        (AllowedPatterns?.Count ?? 0) > 0 || (DeniedPatterns?.Count ?? 0) > 0;

    /// <summary>
    /// Whether this is a restrictive configuration.
    /// </summary>
    [JsonIgnore]
    public bool IsRestrictive =>
        AlwaysDeny || (DeniedPatterns?.Count ?? 0) > 0;

    /// <summary>
    /// Whether this is a permissive configuration.
    /// </summary>
    [JsonIgnore]
    public bool IsPermissive =>
        AlwaysAllow || (AllowedPatterns?.Count ?? 0) > 0;

    #endregion

    #region Factory Methods

    /// <summary>
    /// Create settings that always allow.
    /// </summary>
    public static ToolPermissionSettings AlwaysAllowed(string toolId) => new()
    {
        ToolId = toolId,
        AlwaysAllow = true
    };

    /// <summary>
    /// Create settings that always deny.
    /// </summary>
    public static ToolPermissionSettings AlwaysDenied(string toolId) => new()
    {
        ToolId = toolId,
        AlwaysDeny = true
    };

    /// <summary>
    /// Create settings with allowed patterns.
    /// </summary>
    public static ToolPermissionSettings WithAllowedPatterns(
        string toolId,
        params string[] patterns) => new()
    {
        ToolId = toolId,
        AllowedPatterns = patterns
    };

    /// <summary>
    /// Create settings with denied patterns.
    /// </summary>
    public static ToolPermissionSettings WithDeniedPatterns(
        string toolId,
        params string[] patterns) => new()
    {
        ToolId = toolId,
        DeniedPatterns = patterns
    };

    /// <summary>
    /// Create default (no special handling) settings.
    /// </summary>
    public static ToolPermissionSettings Default(string toolId) => new()
    {
        ToolId = toolId
    };

    #endregion

    #region Builder Pattern

    /// <summary>
    /// Create a modified copy with AlwaysAllow set.
    /// </summary>
    public ToolPermissionSettings WithAlwaysAllow(bool alwaysAllow) => new()
    {
        ToolId = ToolId,
        AlwaysAllow = alwaysAllow,
        AlwaysDeny = alwaysAllow ? false : AlwaysDeny,
        AllowedPatterns = AllowedPatterns,
        DeniedPatterns = DeniedPatterns,
        MaxRiskAutoApproval = MaxRiskAutoApproval,
        ShowDetailedParameters = ShowDetailedParameters,
        CustomApprovalMessage = CustomApprovalMessage,
        LastModified = DateTime.UtcNow
    };

    /// <summary>
    /// Create a modified copy with an added allowed pattern.
    /// </summary>
    public ToolPermissionSettings WithAddedAllowedPattern(string pattern)
    {
        var patterns = (AllowedPatterns?.ToList() ?? new List<string>());
        if (!patterns.Contains(pattern))
        {
            patterns.Add(pattern);
        }

        return new()
        {
            ToolId = ToolId,
            AlwaysAllow = AlwaysAllow,
            AlwaysDeny = AlwaysDeny,
            AllowedPatterns = patterns,
            DeniedPatterns = DeniedPatterns,
            MaxRiskAutoApproval = MaxRiskAutoApproval,
            ShowDetailedParameters = ShowDetailedParameters,
            CustomApprovalMessage = CustomApprovalMessage,
            LastModified = DateTime.UtcNow
        };
    }

    #endregion

    /// <inheritdoc />
    public override string ToString() =>
        AlwaysDeny ? $"{ToolId}: AlwaysDeny"
        : AlwaysAllow ? $"{ToolId}: AlwaysAllow"
        : $"{ToolId}: Patterns({AllowedPatterns?.Count ?? 0} allow, {DeniedPatterns?.Count ?? 0} deny)";
}
```

---

## File Summary

| File | Location | Purpose | Lines |
|------|----------|---------|-------|
| `IAgentService.cs` | `Core/Interfaces/` | Agent orchestration interface | ~170 |
| `IPermissionManager.cs` | `Core/Interfaces/` | Permission management interface | ~120 |
| `PermissionCheckResult.cs` | `Core/Models/` | Permission check response | ~120 |
| `ToolPermissionSettings.cs` | `Core/Models/` | Persistent permission settings | ~180 |
| `CacheSource.cs` | (in PermissionCheckResult) | Cache source enum | ~15 |

---

## Unit Test Plan

| Test | Description |
|------|-------------|
| `IAgentService_ProcessMessageAsync_ReturnsEvents` | Event streaming |
| `IAgentService_CancelAsync_StopsProcessing` | Cancellation |
| `IAgentService_ProvideApprovalAsync_UnblocksExecution` | Approval flow |
| `IAgentService_State_ReflectsProcessingState` | State tracking |
| `IPermissionManager_CheckPermission_AllowsLowRisk` | Risk-based allow |
| `IPermissionManager_CheckPermission_RequiresApprovalHighRisk` | Risk-based approval |
| `IPermissionManager_CheckPermission_DeniesAlwaysDeny` | Always deny |
| `IPermissionManager_RememberDecision_CachesForSession` | Session caching |
| `IPermissionManager_PatternMatch_AllowsMatchingPattern` | Pattern matching |
| `PermissionCheckResult_Factory_CreatesCorrectTypes` | Factory methods |
| `ToolPermissionSettings_WithAlwaysAllow_UpdatesCorrectly` | Builder pattern |

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | IAgentService supports async enumerable event streaming |
| AC-2 | Cancellation is properly supported |
| AC-3 | State tracking is accessible |
| AC-4 | Approval flow integration via ProvideApprovalAsync |
| AC-5 | IPermissionManager handles permission caching |
| AC-6 | Pattern-based permissions work correctly |
| AC-7 | Settings are serializable for persistence |

---

## Changelog Entry

```markdown
## v0.6.2h - IAgentService Interface

### Added
- `IAgentService` interface for agent orchestration
  - `ProcessMessageAsync` with IAsyncEnumerable<AgentEvent> streaming
  - `CancelAsync` for stopping processing
  - `ProvideApprovalAsync` for approval flow integration
  - State tracking properties (State, IsProcessing, CurrentIteration)
  - StateChanged event for UI updates
- `IPermissionManager` interface for tool permissions
  - Permission checking with pattern support
  - Session and persistent caching
  - Tool-level settings management
- `PermissionCheckResult` with Allowed/NeedsApproval/Denied states
- `ToolPermissionSettings` for persistent per-tool configuration
- `CacheSource` enum for identifying permission sources
- Extension methods for simplified API usage
```

---

## Timeline Estimate

| Version | Estimated Effort |
|---------|------------------|
| v0.6.2h | 0.5 day |
