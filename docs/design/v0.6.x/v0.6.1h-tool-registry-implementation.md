# Design Specification: AIntern v0.6.1h "Tool Registry Implementation"

## Overview

**Version**: v0.6.1h
**Parent**: v0.6.1 Tool Framework
**Focus**: Thread-safe registry implementation with DI integration and filtering logic

### Purpose

This sub-version implements the tool registry:
1. Create `ToolRegistry` class implementing `IToolRegistry`
2. Implement thread-safe tool storage using `ConcurrentDictionary`
3. Implement filtering logic for availability context
4. Create `ToolRegistryExtensions` for DI registration
5. Implement function definition caching
6. Provide tool discovery and registration helpers

### Dependencies

**From v0.6.1a (Tool Core Models)**:
- `ITool` interface for stored tools
- `ToolCategory` for filtering
- `RiskLevel` for filtering

**From v0.6.1e (JSON Schema System)**:
- `JsonSchema` for function definitions

**From v0.6.1g (Tool Registry Interface)**:
- `IToolRegistry` interface to implement
- `ToolAvailabilityContext` for filtering
- `FunctionDefinition` for LLM format
- `ToolRegistryChangedEventArgs` for events

**Future consumers**:
- v0.6.1i: Tool Execution Service
- v0.6.2: Semantic Kernel Integration
- v0.6.3: Built-in Tools registration

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│              v0.6.1h Tool Registry Implementation Architecture                 │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  src/AIntern.Services/Tools/                                                 │
│  ├─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  ToolRegistry : IToolRegistry                                            │ │
│  │  ┌─────────────────────────────────────────────────────────────────────┐│ │
│  │  │                                                                      ││ │
│  │  │  Storage                                                             ││ │
│  │  │  └── _tools: ConcurrentDictionary<string, ITool>                    ││ │
│  │  │                                                                      ││ │
│  │  │  Dependencies                                                        ││ │
│  │  │  └── _logger: ILogger<ToolRegistry>                                 ││ │
│  │  │                                                                      ││ │
│  │  │  Caching (optional)                                                  ││ │
│  │  │  ├── _functionDefinitionCache: Dictionary<string, FunctionDef>      ││ │
│  │  │  └── _cacheVersion: int                                             ││ │
│  │  │                                                                      ││ │
│  │  │  Interface Implementation                                            ││ │
│  │  │  ├── Tools → _tools.Values.ToList()                                 ││ │
│  │  │  ├── Count → _tools.Count                                           ││ │
│  │  │  ├── RegisterTool(tool) → AddOrThrow                                ││ │
│  │  │  ├── TryRegisterTool(tool) → TryAdd                                 ││ │
│  │  │  ├── UnregisterTool(toolId) → TryRemove                             ││ │
│  │  │  ├── GetTool(toolId) → TryGetValue                                  ││ │
│  │  │  ├── HasTool(toolId) → ContainsKey                                  ││ │
│  │  │  ├── GetAvailableTools(context) → ApplyFilters                      ││ │
│  │  │  ├── GetToolsByCategory(cat) → Filter                               ││ │
│  │  │  ├── GetToolsByTag(tag) → Filter                                    ││ │
│  │  │  ├── GetToolsByRiskLevel(max) → Filter                              ││ │
│  │  │  ├── SearchTools(query) → SearchAllFields                           ││ │
│  │  │  ├── GetFunctionDefinitions(ctx) → GenerateOrCache                  ││ │
│  │  │  ├── GetFunctionDefinition(id) → FromTool                           ││ │
│  │  │  └── ToolsChanged: event                                            ││ │
│  │  │                                                                      ││ │
│  │  │  Private Methods                                                     ││ │
│  │  │  ├── ApplyContextFilters(tools, context) → IEnumerable<ITool>       ││ │
│  │  │  ├── InvalidateCache()                                              ││ │
│  │  │  └── OnToolsChanged(args)                                           ││ │
│  │  │                                                                      ││ │
│  │  └─────────────────────────────────────────────────────────────────────┘│ │
│  │                                                                          │ │
│  │  ToolRegistryExtensions                                                  │ │
│  │  ┌─────────────────────────────────────────────────────────────────────┐│ │
│  │  │                                                                      ││ │
│  │  │  IServiceCollection Extensions                                       ││ │
│  │  │  ├── AddToolRegistry() → Singleton IToolRegistry                    ││ │
│  │  │  ├── AddTool<T>() → Register ITool implementation                   ││ │
│  │  │  ├── AddTools(params Type[]) → Register multiple tools              ││ │
│  │  │  └── AddToolsFromAssembly() → Discover and register                 ││ │
│  │  │                                                                      ││ │
│  │  │  IServiceProvider Extensions                                         ││ │
│  │  │  └── ConfigureTools() → Register ITool services with registry       ││ │
│  │  │                                                                      ││ │
│  │  └─────────────────────────────────────────────────────────────────────┘│ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Filter Application Flow

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                       Filter Application Flow                                 │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  GetAvailableTools(context)                                                  │
│         │                                                                    │
│         ▼                                                                    │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │ Start: _tools.Values.AsEnumerable()                                    │  │
│  │                                                                         │  │
│  │ All registered tools                                                   │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│         │                                                                    │
│         ▼                                                                    │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │ Filter 1: IsAvailable                                                   │  │
│  │                                                                         │  │
│  │ tools = tools.Where(t => t.IsAvailable);                               │  │
│  │                                                                         │  │
│  │ Remove tools that report themselves unavailable                        │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│         │                                                                    │
│         ▼  (if context != null)                                              │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │ Filter 2: Whitelist                                                     │  │
│  │                                                                         │  │
│  │ if (context.EnabledToolIds?.Count > 0)                                 │  │
│  │     tools = tools.Where(t => context.EnabledToolIds.Contains(t.Id));   │  │
│  │                                                                         │  │
│  │ Keep only whitelisted tools                                            │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│         │                                                                    │
│         ▼                                                                    │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │ Filter 3: Blacklist                                                     │  │
│  │                                                                         │  │
│  │ if (context.DisabledToolIds?.Count > 0)                                │  │
│  │     tools = tools.Where(t => !context.DisabledToolIds.Contains(t.Id)); │  │
│  │                                                                         │  │
│  │ Remove blacklisted tools                                               │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│         │                                                                    │
│         ▼                                                                    │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │ Filter 4: Risk Level                                                    │  │
│  │                                                                         │  │
│  │ if (context.MaxRiskLevel.HasValue)                                     │  │
│  │     tools = tools.Where(t => t.DefaultRiskLevel <= context.MaxRiskLevel);│ │
│  │                                                                         │  │
│  │ Remove tools above max risk level                                      │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│         │                                                                    │
│         ▼                                                                    │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │ Filter 5: Categories                                                    │  │
│  │                                                                         │  │
│  │ if (context.IncludedCategories?.Count > 0)                             │  │
│  │     tools = tools.Where(t => context.IncludedCategories.Contains(t.Cat));│ │
│  │                                                                         │  │
│  │ if (context.ExcludedCategories?.Count > 0)                             │  │
│  │     tools = tools.Where(t => !context.ExcludedCategories.Contains(t.Cat));││
│  │                                                                         │  │
│  │ Apply category filters                                                 │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│         │                                                                    │
│         ▼                                                                    │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │ Filter 6: Tags                                                          │  │
│  │                                                                         │  │
│  │ if (context.RequiredTags?.Count > 0)                                   │  │
│  │     tools = tools.Where(t =>                                           │  │
│  │         context.RequiredTags.All(tag => t.Tags.Contains(tag)));        │  │
│  │                                                                         │  │
│  │ Keep only tools with ALL required tags                                 │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│         │                                                                    │
│         ▼                                                                    │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │ Filter 7: Context Availability                                          │  │
│  │                                                                         │  │
│  │ if (!context.HasWorkspace)                                             │  │
│  │     tools = tools.Where(t => t.Category != ToolCategory.Workspace);    │  │
│  │                                                                         │  │
│  │ if (!context.HasTerminal)                                              │  │
│  │     tools = tools.Where(t => t.Category != ToolCategory.Terminal);     │  │
│  │                                                                         │  │
│  │ if (!context.HasEditor)                                                │  │
│  │     tools = tools.Where(t => t.Category != ToolCategory.Editor);       │  │
│  │                                                                         │  │
│  │ if (!context.HasGitRepository)                                         │  │
│  │     tools = tools.Where(t => t.Category != ToolCategory.Git);          │  │
│  │                                                                         │  │
│  │ Remove tools for unavailable contexts                                  │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│         │                                                                    │
│         ▼                                                                    │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │ Result: tools.ToList()                                                  │  │
│  │                                                                         │  │
│  │ Filtered list of available tools                                       │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## DI Registration Flow

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                       DI Registration Flow                                    │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Startup/Configuration                                                       │
│  ┌───────────────────────────────────────────────────────────────────────┐   │
│  │                                                                        │   │
│  │ services.AddToolRegistry()                                            │   │
│  │     .AddTool<FileReadTool>()                                          │   │
│  │     .AddTool<FileWriteTool>()                                         │   │
│  │     .AddToolsFromAssembly(typeof(BuiltInTools).Assembly);             │   │
│  │                                                                        │   │
│  └───────────────────────────────────────────────────────────────────────┘   │
│         │                                                                    │
│         ▼                                                                    │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │ AddToolRegistry()                                                       │  │
│  │                                                                         │  │
│  │ services.AddSingleton<IToolRegistry, ToolRegistry>();                  │  │
│  │                                                                         │  │
│  │ Registers the registry as a singleton                                  │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│         │                                                                    │
│         ▼                                                                    │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │ AddTool<T>()                                                            │  │
│  │                                                                         │  │
│  │ services.AddSingleton<ITool, T>();                                     │  │
│  │                                                                         │  │
│  │ Registers each tool type as ITool service                              │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│         │                                                                    │
│         ▼                                                                    │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │ Application Startup                                                     │  │
│  │                                                                         │  │
│  │ var app = builder.Build();                                             │  │
│  │ app.Services.ConfigureTools();                                         │  │
│  │                                                                         │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│         │                                                                    │
│         ▼                                                                    │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │ ConfigureTools()                                                        │  │
│  │                                                                         │  │
│  │ var registry = services.GetRequiredService<IToolRegistry>();           │  │
│  │ var tools = services.GetServices<ITool>();                             │  │
│  │                                                                         │  │
│  │ foreach (var tool in tools)                                            │  │
│  │     registry.TryRegisterTool(tool);                                    │  │
│  │                                                                         │  │
│  │ Registers all ITool services with the registry                         │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Specifications

### 1. ToolRegistry.cs

**Location**: `src/AIntern.Services/Tools/ToolRegistry.cs`

```csharp
namespace AIntern.Services.Tools;

using System.Collections.Concurrent;
using Microsoft.Extensions.Logging;
using AIntern.Core.Interfaces;
using AIntern.Core.Tools;

/// <summary>
/// Thread-safe implementation of the tool registry.
/// </summary>
/// <remarks>
/// <para>
/// The registry stores all registered tools and provides filtering and
/// lookup capabilities. It uses a <see cref="ConcurrentDictionary{TKey,TValue}"/>
/// for thread-safe operations.
/// </para>
/// <para>
/// Tools should be registered during application startup, typically via
/// the DI container using <see cref="ToolRegistryExtensions"/>.
/// </para>
/// </remarks>
public sealed class ToolRegistry : IToolRegistry
{
    private readonly ConcurrentDictionary<string, ITool> _tools = new(StringComparer.OrdinalIgnoreCase);
    private readonly ILogger<ToolRegistry>? _logger;

    // Optional caching for function definitions
    private readonly object _cacheLock = new();
    private Dictionary<string, FunctionDefinition>? _functionDefinitionCache;
    private int _cacheVersion;

    /// <summary>
    /// Initializes a new instance of the <see cref="ToolRegistry"/> class.
    /// </summary>
    /// <param name="logger">Optional logger for diagnostics.</param>
    public ToolRegistry(ILogger<ToolRegistry>? logger = null)
    {
        _logger = logger;
    }

    #region Properties

    /// <inheritdoc />
    public IReadOnlyList<ITool> Tools => _tools.Values.ToList();

    /// <inheritdoc />
    public int Count => _tools.Count;

    #endregion

    #region Registration

    /// <inheritdoc />
    public void RegisterTool(ITool tool)
    {
        if (!TryRegisterTool(tool))
        {
            throw new InvalidOperationException($"Tool '{tool.Id}' is already registered");
        }
    }

    /// <inheritdoc />
    public bool TryRegisterTool(ITool tool)
    {
        if (_tools.TryAdd(tool.Id, tool))
        {
            _logger?.LogInformation(
                "Registered tool: {ToolId} ({ToolName}) - Category: {Category}, Risk: {Risk}",
                tool.Id, tool.Name, tool.Category, tool.DefaultRiskLevel);

            InvalidateCache();

            OnToolsChanged(ToolRegistryChangedEventArgs.Added(tool));

            return true;
        }

        _logger?.LogWarning("Tool '{ToolId}' is already registered", tool.Id);
        return false;
    }

    /// <inheritdoc />
    public bool UnregisterTool(string toolId)
    {
        if (_tools.TryRemove(toolId, out var tool))
        {
            _logger?.LogInformation("Unregistered tool: {ToolId}", toolId);

            InvalidateCache();

            OnToolsChanged(ToolRegistryChangedEventArgs.Removed(tool));

            return true;
        }

        _logger?.LogDebug("Tool '{ToolId}' not found for unregistration", toolId);
        return false;
    }

    #endregion

    #region Lookup

    /// <inheritdoc />
    public ITool? GetTool(string toolId) =>
        _tools.GetValueOrDefault(toolId);

    /// <inheritdoc />
    public bool HasTool(string toolId) =>
        _tools.ContainsKey(toolId);

    #endregion

    #region Filtering

    /// <inheritdoc />
    public IReadOnlyList<ITool> GetAvailableTools(ToolAvailabilityContext? context = null)
    {
        var tools = _tools.Values.AsEnumerable();

        // Filter by IsAvailable
        tools = tools.Where(t => t.IsAvailable);

        if (context == null)
            return tools.ToList();

        // Apply context filters
        tools = ApplyContextFilters(tools, context);

        return tools.ToList();
    }

    /// <inheritdoc />
    public IReadOnlyList<ITool> GetToolsByCategory(ToolCategory category) =>
        _tools.Values
            .Where(t => t.Category == category && t.IsAvailable)
            .ToList();

    /// <inheritdoc />
    public IReadOnlyList<ITool> GetToolsByTag(string tag) =>
        _tools.Values
            .Where(t => t.Tags.Contains(tag, StringComparer.OrdinalIgnoreCase) && t.IsAvailable)
            .ToList();

    /// <inheritdoc />
    public IReadOnlyList<ITool> GetToolsByRiskLevel(RiskLevel maxRiskLevel) =>
        _tools.Values
            .Where(t => t.DefaultRiskLevel <= maxRiskLevel && t.IsAvailable)
            .ToList();

    /// <inheritdoc />
    public IReadOnlyList<ITool> SearchTools(string query)
    {
        if (string.IsNullOrWhiteSpace(query))
            return Tools;

        var lowerQuery = query.ToLowerInvariant();

        return _tools.Values
            .Where(t => t.IsAvailable && MatchesQuery(t, lowerQuery))
            .ToList();
    }

    #endregion

    #region Function Definitions

    /// <inheritdoc />
    public IReadOnlyList<FunctionDefinition> GetFunctionDefinitions(ToolAvailabilityContext? context = null)
    {
        return GetAvailableTools(context)
            .Select(FunctionDefinition.FromTool)
            .ToList();
    }

    /// <inheritdoc />
    public FunctionDefinition? GetFunctionDefinition(string toolId)
    {
        var tool = GetTool(toolId);
        return tool != null ? FunctionDefinition.FromTool(tool) : null;
    }

    #endregion

    #region Events

    /// <inheritdoc />
    public event EventHandler<ToolRegistryChangedEventArgs>? ToolsChanged;

    private void OnToolsChanged(ToolRegistryChangedEventArgs args)
    {
        ToolsChanged?.Invoke(this, args);
    }

    #endregion

    #region Private Methods

    private IEnumerable<ITool> ApplyContextFilters(
        IEnumerable<ITool> tools,
        ToolAvailabilityContext context)
    {
        // Whitelist filter
        if (context.EnabledToolIds?.Count > 0)
        {
            tools = tools.Where(t => context.EnabledToolIds.Contains(t.Id));
        }

        // Blacklist filter
        if (context.DisabledToolIds?.Count > 0)
        {
            tools = tools.Where(t => !context.DisabledToolIds.Contains(t.Id));
        }

        // Risk level filter
        if (context.MaxRiskLevel.HasValue)
        {
            tools = tools.Where(t => t.DefaultRiskLevel <= context.MaxRiskLevel.Value);
        }

        // Category filters
        if (context.IncludedCategories?.Count > 0)
        {
            tools = tools.Where(t => context.IncludedCategories.Contains(t.Category));
        }

        if (context.ExcludedCategories?.Count > 0)
        {
            tools = tools.Where(t => !context.ExcludedCategories.Contains(t.Category));
        }

        // Tag filter
        if (context.RequiredTags?.Count > 0)
        {
            tools = tools.Where(t =>
                context.RequiredTags.All(tag =>
                    t.Tags.Contains(tag, StringComparer.OrdinalIgnoreCase)));
        }

        // Context-dependent availability
        if (!context.HasWorkspace)
        {
            tools = tools.Where(t => t.Category != ToolCategory.Workspace);
        }

        if (!context.HasTerminal)
        {
            tools = tools.Where(t => t.Category != ToolCategory.Terminal);
        }

        if (!context.HasEditor)
        {
            tools = tools.Where(t => t.Category != ToolCategory.Editor);
        }

        if (!context.HasGitRepository)
        {
            tools = tools.Where(t => t.Category != ToolCategory.Git);
        }

        return tools;
    }

    private static bool MatchesQuery(ITool tool, string lowerQuery)
    {
        // Match against ID
        if (tool.Id.Contains(lowerQuery, StringComparison.OrdinalIgnoreCase))
            return true;

        // Match against name
        if (tool.Name.Contains(lowerQuery, StringComparison.OrdinalIgnoreCase))
            return true;

        // Match against description
        if (tool.Description.Contains(lowerQuery, StringComparison.OrdinalIgnoreCase))
            return true;

        // Match against tags
        if (tool.Tags.Any(tag => tag.Contains(lowerQuery, StringComparison.OrdinalIgnoreCase)))
            return true;

        return false;
    }

    private void InvalidateCache()
    {
        lock (_cacheLock)
        {
            _functionDefinitionCache = null;
            _cacheVersion++;
        }
    }

    #endregion
}
```

### 2. ToolRegistryExtensions.cs

**Location**: `src/AIntern.Services/Tools/ToolRegistryExtensions.cs`

```csharp
namespace AIntern.Services.Tools;

using System.Reflection;
using Microsoft.Extensions.DependencyInjection;
using AIntern.Core.Interfaces;
using AIntern.Core.Tools;

/// <summary>
/// Extension methods for tool registry setup.
/// </summary>
/// <remarks>
/// <para>
/// These extensions provide convenient methods for registering tools
/// with the DI container and configuring the tool registry.
/// </para>
/// <para>
/// Usage example:
/// </para>
/// <code>
/// services.AddToolRegistry()
///     .AddTool&lt;FileReadTool&gt;()
///     .AddTool&lt;FileWriteTool&gt;()
///     .AddToolsFromAssembly(typeof(BuiltInTools).Assembly);
///
/// // Later, during startup:
/// app.Services.ConfigureTools();
/// </code>
/// </remarks>
public static class ToolRegistryExtensions
{
    #region IServiceCollection Extensions

    /// <summary>
    /// Add the tool registry to services.
    /// </summary>
    /// <remarks>
    /// Registers <see cref="IToolRegistry"/> as a singleton.
    /// </remarks>
    /// <param name="services">The service collection.</param>
    /// <returns>The service collection for chaining.</returns>
    public static IServiceCollection AddToolRegistry(this IServiceCollection services)
    {
        services.AddSingleton<IToolRegistry, ToolRegistry>();
        return services;
    }

    /// <summary>
    /// Register a tool type with the container.
    /// </summary>
    /// <remarks>
    /// The tool will be registered as <see cref="ITool"/> and resolved
    /// during <see cref="ConfigureTools"/>.
    /// </remarks>
    /// <typeparam name="TTool">The tool type to register.</typeparam>
    /// <param name="services">The service collection.</param>
    /// <returns>The service collection for chaining.</returns>
    public static IServiceCollection AddTool<TTool>(this IServiceCollection services)
        where TTool : class, ITool
    {
        services.AddSingleton<ITool, TTool>();
        return services;
    }

    /// <summary>
    /// Register a tool instance with the container.
    /// </summary>
    /// <param name="services">The service collection.</param>
    /// <param name="tool">The tool instance to register.</param>
    /// <returns>The service collection for chaining.</returns>
    public static IServiceCollection AddTool(this IServiceCollection services, ITool tool)
    {
        services.AddSingleton<ITool>(tool);
        return services;
    }

    /// <summary>
    /// Register multiple tool types.
    /// </summary>
    /// <param name="services">The service collection.</param>
    /// <param name="toolTypes">Tool types to register.</param>
    /// <returns>The service collection for chaining.</returns>
    /// <exception cref="ArgumentException">If a type doesn't implement ITool.</exception>
    public static IServiceCollection AddTools(
        this IServiceCollection services,
        params Type[] toolTypes)
    {
        foreach (var type in toolTypes)
        {
            if (!typeof(ITool).IsAssignableFrom(type))
                throw new ArgumentException($"{type.Name} does not implement ITool");

            services.AddSingleton(typeof(ITool), type);
        }

        return services;
    }

    /// <summary>
    /// Discover and register all tools from an assembly.
    /// </summary>
    /// <remarks>
    /// Scans the assembly for concrete types that implement <see cref="ITool"/>
    /// and have a parameterless constructor or can be resolved by DI.
    /// </remarks>
    /// <param name="services">The service collection.</param>
    /// <param name="assembly">The assembly to scan.</param>
    /// <returns>The service collection for chaining.</returns>
    public static IServiceCollection AddToolsFromAssembly(
        this IServiceCollection services,
        Assembly assembly)
    {
        var toolTypes = assembly.GetTypes()
            .Where(t => typeof(ITool).IsAssignableFrom(t) &&
                       !t.IsAbstract &&
                       !t.IsInterface &&
                       t.IsPublic);

        foreach (var type in toolTypes)
        {
            services.AddSingleton(typeof(ITool), type);
        }

        return services;
    }

    /// <summary>
    /// Discover and register all tools from the calling assembly.
    /// </summary>
    /// <param name="services">The service collection.</param>
    /// <returns>The service collection for chaining.</returns>
    public static IServiceCollection AddToolsFromCallingAssembly(this IServiceCollection services)
    {
        return services.AddToolsFromAssembly(Assembly.GetCallingAssembly());
    }

    /// <summary>
    /// Add built-in tool categories.
    /// </summary>
    /// <param name="services">The service collection.</param>
    /// <param name="categories">Categories of built-in tools to add.</param>
    /// <returns>The service collection for chaining.</returns>
    public static IServiceCollection AddBuiltInTools(
        this IServiceCollection services,
        params ToolCategory[] categories)
    {
        // This would be implemented to add specific built-in tools
        // For now, it's a placeholder for v0.6.3
        return services;
    }

    #endregion

    #region IServiceProvider Extensions

    /// <summary>
    /// Configure tools from registered ITool services.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Call this method after building the service provider to register
    /// all <see cref="ITool"/> services with the <see cref="IToolRegistry"/>.
    /// </para>
    /// <para>
    /// This is typically called during application startup:
    /// </para>
    /// <code>
    /// var app = builder.Build();
    /// app.Services.ConfigureTools();
    /// </code>
    /// </remarks>
    /// <param name="services">The service provider.</param>
    /// <returns>The service provider for chaining.</returns>
    public static IServiceProvider ConfigureTools(this IServiceProvider services)
    {
        var registry = services.GetRequiredService<IToolRegistry>();
        var tools = services.GetServices<ITool>();

        foreach (var tool in tools)
        {
            registry.TryRegisterTool(tool);
        }

        return services;
    }

    /// <summary>
    /// Get tools by category from the registry.
    /// </summary>
    /// <param name="services">The service provider.</param>
    /// <param name="category">Category to filter by.</param>
    /// <returns>Tools in the category.</returns>
    public static IReadOnlyList<ITool> GetToolsByCategory(
        this IServiceProvider services,
        ToolCategory category)
    {
        var registry = services.GetRequiredService<IToolRegistry>();
        return registry.GetToolsByCategory(category);
    }

    /// <summary>
    /// Get available tools with context.
    /// </summary>
    /// <param name="services">The service provider.</param>
    /// <param name="context">Availability context.</param>
    /// <returns>Available tools.</returns>
    public static IReadOnlyList<ITool> GetAvailableTools(
        this IServiceProvider services,
        ToolAvailabilityContext? context = null)
    {
        var registry = services.GetRequiredService<IToolRegistry>();
        return registry.GetAvailableTools(context);
    }

    #endregion

    #region IToolRegistry Extensions

    /// <summary>
    /// Register multiple tools at once.
    /// </summary>
    /// <param name="registry">The tool registry.</param>
    /// <param name="tools">Tools to register.</param>
    /// <returns>Count of successfully registered tools.</returns>
    public static int RegisterTools(this IToolRegistry registry, IEnumerable<ITool> tools)
    {
        int count = 0;
        foreach (var tool in tools)
        {
            if (registry.TryRegisterTool(tool))
                count++;
        }
        return count;
    }

    /// <summary>
    /// Clear all registered tools.
    /// </summary>
    /// <param name="registry">The tool registry.</param>
    /// <returns>Number of tools removed.</returns>
    public static int Clear(this IToolRegistry registry)
    {
        var toolIds = registry.Tools.Select(t => t.Id).ToList();
        int count = 0;
        foreach (var id in toolIds)
        {
            if (registry.UnregisterTool(id))
                count++;
        }
        return count;
    }

    /// <summary>
    /// Get tools that require approval.
    /// </summary>
    /// <param name="registry">The tool registry.</param>
    /// <returns>Tools with risk level Medium or higher.</returns>
    public static IReadOnlyList<ITool> GetToolsRequiringApproval(this IToolRegistry registry)
    {
        return registry.GetAvailableTools()
            .Where(t => t.DefaultRiskLevel >= RiskLevel.Medium)
            .ToList();
    }

    /// <summary>
    /// Get safe tools (auto-approved).
    /// </summary>
    /// <param name="registry">The tool registry.</param>
    /// <returns>Tools with risk level Safe or Low.</returns>
    public static IReadOnlyList<ITool> GetSafeTools(this IToolRegistry registry)
    {
        return registry.GetToolsByRiskLevel(RiskLevel.Low);
    }

    /// <summary>
    /// Get tools grouped by category.
    /// </summary>
    /// <param name="registry">The tool registry.</param>
    /// <returns>Dictionary of category to tools.</returns>
    public static IReadOnlyDictionary<ToolCategory, IReadOnlyList<ITool>> GetToolsByCategories(
        this IToolRegistry registry)
    {
        return registry.GetAvailableTools()
            .GroupBy(t => t.Category)
            .ToDictionary(
                g => g.Key,
                g => (IReadOnlyList<ITool>)g.ToList());
    }

    /// <summary>
    /// Get tool statistics.
    /// </summary>
    /// <param name="registry">The tool registry.</param>
    /// <returns>Statistics about registered tools.</returns>
    public static ToolRegistryStats GetStats(this IToolRegistry registry)
    {
        var tools = registry.GetAvailableTools();
        return new ToolRegistryStats
        {
            TotalCount = registry.Count,
            AvailableCount = tools.Count,
            ByCategory = tools.GroupBy(t => t.Category)
                .ToDictionary(g => g.Key, g => g.Count()),
            ByRiskLevel = tools.GroupBy(t => t.DefaultRiskLevel)
                .ToDictionary(g => g.Key, g => g.Count())
        };
    }

    #endregion
}

/// <summary>
/// Statistics about registered tools.
/// </summary>
public sealed class ToolRegistryStats
{
    /// <summary>
    /// Total number of registered tools.
    /// </summary>
    public int TotalCount { get; init; }

    /// <summary>
    /// Number of available tools.
    /// </summary>
    public int AvailableCount { get; init; }

    /// <summary>
    /// Count by category.
    /// </summary>
    public IReadOnlyDictionary<ToolCategory, int> ByCategory { get; init; } =
        new Dictionary<ToolCategory, int>();

    /// <summary>
    /// Count by risk level.
    /// </summary>
    public IReadOnlyDictionary<RiskLevel, int> ByRiskLevel { get; init; } =
        new Dictionary<RiskLevel, int>();
}
```

---

## Directory Structure

```
src/AIntern.Services/
└── Tools/
    ├── ToolRegistry.cs                    (NEW)
    └── ToolRegistryExtensions.cs          (NEW)
```

---

## Unit Test Plan

| Test Class | Test | Description |
|------------|------|-------------|
| **ToolRegistryTests** | | |
| | `RegisterTool_AddsTool` | Tool is added |
| | `RegisterTool_Duplicate_ThrowsException` | Duplicate throws |
| | `TryRegisterTool_AddsTool` | Tool is added |
| | `TryRegisterTool_Duplicate_ReturnsFalse` | Duplicate returns false |
| | `UnregisterTool_RemovesTool` | Tool is removed |
| | `UnregisterTool_NotFound_ReturnsFalse` | Not found returns false |
| | `GetTool_Existing_ReturnsTool` | Tool found |
| | `GetTool_NotFound_ReturnsNull` | Not found returns null |
| | `HasTool_Existing_ReturnsTrue` | Exists returns true |
| | `HasTool_NotFound_ReturnsFalse` | Not exists returns false |
| | `Tools_ReturnsAllRegistered` | All tools returned |
| | `Count_ReturnsCorrectCount` | Count is correct |
| | `ToolsChanged_FiresOnRegister` | Event fires |
| | `ToolsChanged_FiresOnUnregister` | Event fires |
| **FilteringTests** | | |
| | `GetAvailableTools_FiltersByIsAvailable` | Only available tools |
| | `GetAvailableTools_WithWhitelist_FiltersCorrectly` | Whitelist works |
| | `GetAvailableTools_WithBlacklist_FiltersCorrectly` | Blacklist works |
| | `GetAvailableTools_WithMaxRisk_FiltersCorrectly` | Risk filter works |
| | `GetAvailableTools_WithIncludedCategories_FiltersCorrectly` | Include filter |
| | `GetAvailableTools_WithExcludedCategories_FiltersCorrectly` | Exclude filter |
| | `GetAvailableTools_WithRequiredTags_FiltersCorrectly` | Tag filter |
| | `GetAvailableTools_NoWorkspace_ExcludesWorkspaceTools` | Context filter |
| | `GetAvailableTools_NoTerminal_ExcludesTerminalTools` | Context filter |
| | `GetAvailableTools_NoGit_ExcludesGitTools` | Context filter |
| | `GetToolsByCategory_ReturnsCorrectTools` | Category filter |
| | `GetToolsByTag_ReturnsCorrectTools` | Tag lookup |
| | `GetToolsByRiskLevel_ReturnsCorrectTools` | Risk filter |
| | `SearchTools_MatchesId` | Search by ID |
| | `SearchTools_MatchesName` | Search by name |
| | `SearchTools_MatchesDescription` | Search by description |
| | `SearchTools_MatchesTags` | Search by tags |
| | `SearchTools_EmptyQuery_ReturnsAll` | Empty returns all |
| **FunctionDefinitionTests** | | |
| | `GetFunctionDefinitions_ReturnsForAllAvailable` | All definitions |
| | `GetFunctionDefinitions_WithContext_FiltersCorrectly` | Context filter |
| | `GetFunctionDefinition_ExistingTool_ReturnsDefinition` | Single definition |
| | `GetFunctionDefinition_NotFound_ReturnsNull` | Not found null |
| **ExtensionsTests** | | |
| | `AddToolRegistry_RegistersSingleton` | DI registration |
| | `AddTool_RegistersToolService` | Tool registration |
| | `AddTools_RegistersMultiple` | Multiple tools |
| | `AddToolsFromAssembly_DiscoversTools` | Assembly scan |
| | `ConfigureTools_RegistersWithRegistry` | Startup config |
| | `RegisterTools_ReturnsCount` | Bulk register |
| | `Clear_RemovesAllTools` | Clear registry |
| | `GetStats_ReturnsCorrectStats` | Stats generation |

**Total Tests**: 48

---

## Usage Examples

### Basic Registration

```csharp
// In Startup/Program.cs
services.AddToolRegistry()
    .AddTool<FileReadTool>()
    .AddTool<FileWriteTool>()
    .AddTool<SearchGrepTool>();

// After building the app
app.Services.ConfigureTools();
```

### Using the Registry

```csharp
// Get all available tools
var tools = registry.GetAvailableTools();

// Get with context filtering
var context = ToolAvailabilityContext.Create()
    .WithMaxRiskLevel(RiskLevel.Medium)
    .WithWorkspace(true)
    .Build();
var safeTools = registry.GetAvailableTools(context);

// Get function definitions for LLM
var functions = registry.GetFunctionDefinitions(context);
var json = FunctionDefinition.ToOpenAIToolsJson(functions);
```

### Listening for Changes

```csharp
registry.ToolsChanged += (sender, args) =>
{
    switch (args.ChangeType)
    {
        case ToolRegistryChangeType.Added:
            Console.WriteLine($"Tool added: {args.Tool.Id}");
            break;
        case ToolRegistryChangeType.Removed:
            Console.WriteLine($"Tool removed: {args.Tool.Id}");
            break;
    }
};
```

---

## File Summary

### Files to Create

| File | Location | Lines | Purpose |
|------|----------|-------|---------|
| `ToolRegistry.cs` | `Services/Tools/` | ~280 | Registry implementation |
| `ToolRegistryExtensions.cs` | `Services/Tools/` | ~260 | DI extensions |
| **Total** | | **~540** | |

### Files to Modify

| File | Changes |
|------|---------|
| `ServiceCollectionExtensions.cs` | Add tool registry to service registration |

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | `ToolRegistry` is thread-safe using ConcurrentDictionary |
| AC-2 | Registration throws for duplicates (RegisterTool) |
| AC-3 | Registration returns false for duplicates (TryRegisterTool) |
| AC-4 | All filter types work correctly |
| AC-5 | Context availability filters exclude correct categories |
| AC-6 | Search matches ID, name, description, and tags |
| AC-7 | Function definitions are generated correctly |
| AC-8 | ToolsChanged event fires on add/remove |
| AC-9 | DI extensions register correctly |
| AC-10 | All 48 unit tests pass |

---

## Changelog Entry

```markdown
## v0.6.1h - Tool Registry Implementation

### Added
- `ToolRegistry` implementation with:
  - Thread-safe storage using ConcurrentDictionary
  - Tool registration with duplicate detection
  - Lookup by ID with HasTool/GetTool
  - Filtering by category, tag, and risk level
  - Full context-aware filtering with ToolAvailabilityContext
  - Text search across ID, name, description, and tags
  - Function definition generation
  - ToolsChanged event for registry modifications

- `ToolRegistryExtensions` with:
  - IServiceCollection extensions:
    - AddToolRegistry() for singleton registration
    - AddTool<T>() for individual tool registration
    - AddTools() for multiple tools
    - AddToolsFromAssembly() for discovery
  - IServiceProvider extensions:
    - ConfigureTools() for startup configuration
    - GetToolsByCategory() convenience method
    - GetAvailableTools() convenience method
  - IToolRegistry extensions:
    - RegisterTools() for bulk registration
    - Clear() to remove all tools
    - GetToolsRequiringApproval()
    - GetSafeTools()
    - GetToolsByCategories() for grouped lookup
    - GetStats() for registry statistics

- `ToolRegistryStats` model for statistics
```

---

## Timeline Estimate

| Task | Estimated Effort |
|------|------------------|
| ToolRegistry | 0.5 day |
| ToolRegistryExtensions | 0.35 day |
| Unit Tests | 0.4 day |
| **Total** | **1.25 days** |
