# Design Specification: AIntern v0.6.2i "AgentService Implementation"

## Overview

**Version**: v0.6.2i
**Parent**: v0.6.2 Semantic Kernel Integration
**Focus**: Core agent service implementing the agent loop with tool execution

### Purpose

Implement the core agent service that orchestrates:
1. Agent loop with iteration limits and timeout handling
2. LLM generation with streaming token output
3. Tool call parsing, validation, and execution
4. Approval flow integration with TaskCompletionSource
5. Conversation history management
6. Permission management with session caching
7. Event streaming via IAsyncEnumerable

### Dependencies

**From Previous Sub-Versions**:
- v0.6.2b: `SemanticKernelConfiguration`
- v0.6.2c: `AgentRequest`
- v0.6.2d: `AgentStateMachine`, `AgentState`, `AgentStateTransition`
- v0.6.2e: All `AgentEvent` types
- v0.6.2f: `ToolCallRequest`, `ApprovalDecision`, `ToolCallLifecycle`
- v0.6.2g: `FunctionCallParser`, `StreamingFunctionCallParser`
- v0.6.2h: `IAgentService`, `IPermissionManager`

**External Dependencies**:
- `ILlmService` for LLM generation
- `IToolRegistry` for tool lookup
- `IToolExecutionService` for tool execution
- `IConversationService` for history persistence

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                    v0.6.2i AgentService Architecture                          │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  AgentService : IAgentService, IDisposable                                   │
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │  Dependencies                                                             ││
│  │  ├── ILlmService _llmService                                              ││
│  │  ├── IToolRegistry _toolRegistry                                          ││
│  │  ├── IToolExecutionService _toolExecutionService                          ││
│  │  ├── IPermissionManager _permissionManager                                ││
│  │  ├── IConversationService _conversationService                            ││
│  │  ├── FunctionCallParser _functionCallParser                               ││
│  │  └── SemanticKernelConfiguration _config                                  ││
│  │                                                                           ││
│  │  State                                                                    ││
│  │  ├── AgentStateMachine _stateMachine                                      ││
│  │  ├── ConcurrentDictionary<Guid, TCS<ApprovalDecision>> _pendingApprovals  ││
│  │  ├── CancellationTokenSource? _cts                                        ││
│  │  └── Guid _currentRequestId                                               ││
│  │                                                                           ││
│  │  Public Methods                                                           ││
│  │  ├── ProcessMessageAsync(request, ct) → IAsyncEnumerable<AgentEvent>      ││
│  │  ├── CancelAsync()                                                        ││
│  │  └── ProvideApprovalAsync(requestId, decision)                            ││
│  │                                                                           ││
│  │  Private Methods                                                          ││
│  │  ├── ProcessToolCallAsync(request, toolCall, tracker, ct)                 ││
│  │  ├── BuildConversationHistory(request)                                    ││
│  │  ├── BuildPromptWithTools(history, tools, systemPrompt)                   ││
│  │  ├── FormatToolResultForHistory(request, result)                          ││
│  │  └── UpdateUsageTracker(tracker, request, result, duration)               ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
│  PermissionManager : IPermissionManager                                      │
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │  State                                                                    ││
│  │  ├── ISettingsService _settingsService                                    ││
│  │  └── ConcurrentDictionary<string, ApprovalDecision> _sessionCache         ││
│  │                                                                           ││
│  │  Methods                                                                  ││
│  │  ├── CheckPermissionAsync(request) → PermissionCheckResult                ││
│  │  ├── RememberDecisionAsync(toolId, decision)                              ││
│  │  ├── ClearSessionPermissionsAsync()                                       ││
│  │  ├── GetToolPermissionsAsync(toolId)                                      ││
│  │  └── SetToolPermissionsAsync(toolId, settings)                            ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Agent Loop Flow

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                           Agent Loop Flow                                     │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ProcessMessageAsync(request)                                                │
│      │                                                                       │
│      ▼                                                                       │
│  ┌─────────────────────────────┐                                             │
│  │  Initialize                 │                                             │
│  │  • Reset state machine      │                                             │
│  │  • Create cancellation      │                                             │
│  │  • Build initial history    │                                             │
│  └─────────────┬───────────────┘                                             │
│                │                                                             │
│                ▼                                                             │
│  ┌─────────────────────────────┐                                             │
│  │  WHILE iteration < max      │◄────────────────────────────────────┐       │
│  │        && !cancelled        │                                     │       │
│  └─────────────┬───────────────┘                                     │       │
│                │                                                     │       │
│                ▼                                                     │       │
│  ┌─────────────────────────────┐                                     │       │
│  │  Emit AgentIterationEvent   │                                     │       │
│  │  Transition: BeginThinking  │                                     │       │
│  └─────────────┬───────────────┘                                     │       │
│                │                                                     │       │
│                ▼                                                     │       │
│  ┌─────────────────────────────┐                                     │       │
│  │  Build prompt with tools    │                                     │       │
│  │  Get available tools        │                                     │       │
│  └─────────────┬───────────────┘                                     │       │
│                │                                                     │       │
│                ▼                                                     │       │
│  ┌─────────────────────────────┐                                     │       │
│  │  Stream LLM response        │                                     │       │
│  │  FOR each token:            │                                     │       │
│  │    • Parse with streaming   │                                     │       │
│  │    • Emit TextGenEvent      │                                     │       │
│  │    • Detect tool calls      │                                     │       │
│  └─────────────┬───────────────┘                                     │       │
│                │                                                     │       │
│       ┌────────┴────────┐                                            │       │
│       │ No tool calls   │ Tool calls detected                        │       │
│       ▼                 ▼                                            │       │
│  ┌──────────┐    ┌─────────────────────────────┐                     │       │
│  │  BREAK   │    │  FOR each tool call:        │                     │       │
│  │  loop    │    │    • ProcessToolCallAsync   │                     │       │
│  └──────────┘    │    • Emit ToolResultEvent   │                     │       │
│                  │    • Add to history         │                     │       │
│                  └─────────────┬───────────────┘                     │       │
│                                │                                     │       │
│                                └─────────────────────────────────────┘       │
│                                                                              │
│  ┌─────────────────────────────┐                                             │
│  │  Emit AgentCompleteEvent    │                                             │
│  │  with statistics            │                                             │
│  └─────────────────────────────┘                                             │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Specifications

### 1. AgentService.cs

**Location**: `src/SeniorIntern.Services/AI/AgentService.cs`

```csharp
namespace SeniorIntern.Services.AI;

using System.Collections.Concurrent;
using System.Runtime.CompilerServices;
using System.Text;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Core.Tools;

/// <summary>
/// Implementation of the agent service that orchestrates AI interactions
/// with tool capabilities.
/// </summary>
public sealed class AgentService : IAgentService, IDisposable
{
    #region Dependencies

    private readonly ILlmService _llmService;
    private readonly IToolRegistry _toolRegistry;
    private readonly IToolExecutionService _toolExecutionService;
    private readonly IPermissionManager _permissionManager;
    private readonly IConversationService _conversationService;
    private readonly FunctionCallParser _functionCallParser;
    private readonly SemanticKernelConfiguration _config;
    private readonly ILogger<AgentService> _logger;

    #endregion

    #region State

    private readonly AgentStateMachine _stateMachine = new();
    private readonly ConcurrentDictionary<Guid, TaskCompletionSource<ApprovalDecision>> 
        _pendingApprovals = new();

    private CancellationTokenSource? _cts;
    private Guid _currentRequestId;

    #endregion

    #region IAgentService Properties

    public AgentState State => _stateMachine.CurrentState;
    public bool IsProcessing => !_stateMachine.IsTerminalState && State != AgentState.Idle;
    public int CurrentIteration => _stateMachine.IterationNumber;
    public Guid CurrentRequestId => _currentRequestId;
    public bool HasPendingApprovals => !_pendingApprovals.IsEmpty;

    public event EventHandler<AgentStateChangedEventArgs>? StateChanged
    {
        add => _stateMachine.StateChanged += value;
        remove => _stateMachine.StateChanged -= value;
    }

    #endregion

    public AgentService(
        ILlmService llmService,
        IToolRegistry toolRegistry,
        IToolExecutionService toolExecutionService,
        IPermissionManager permissionManager,
        IConversationService conversationService,
        FunctionCallParser functionCallParser,
        IOptions<SemanticKernelConfiguration> config,
        ILogger<AgentService> logger)
    {
        _llmService = llmService;
        _toolRegistry = toolRegistry;
        _toolExecutionService = toolExecutionService;
        _permissionManager = permissionManager;
        _conversationService = conversationService;
        _functionCallParser = functionCallParser;
        _config = config.Value;
        _logger = logger;
    }

    #region ProcessMessageAsync

    public async IAsyncEnumerable<AgentEvent> ProcessMessageAsync(
        AgentRequest request,
        [EnumeratorCancellation] CancellationToken ct = default)
    {
        _currentRequestId = request.RequestId;
        _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);

        using var timeoutCts = new CancellationTokenSource(_config.AgentRequestTimeout);
        using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(
            _cts.Token, timeoutCts.Token);
        var linkedCt = linkedCts.Token;

        var startTime = DateTime.UtcNow;
        var toolCallsExecuted = 0;
        var totalTokens = 0;
        var responseBuilder = new StringBuilder();
        var toolUsageTracker = new Dictionary<string, ToolUsageSummary>();

        _stateMachine.Reset();
        _stateMachine.TryTransition(AgentStateTransition.Start);

        var history = BuildConversationHistory(request);

        try
        {
            var maxIterations = request.MaxIterations ?? _config.MaxAgentIterations;

            while (_stateMachine.IterationNumber < maxIterations && !linkedCt.IsCancellationRequested)
            {
                _stateMachine.TryTransition(AgentStateTransition.BeginThinking);

                yield return AgentIterationEvent.Create(
                    request.RequestId,
                    _stateMachine.IterationNumber,
                    maxIterations,
                    toolCallsExecuted);

                // Get available tools
                var availableTools = request.EnableTools
                    ? _toolRegistry.GetAvailableTools(request.ToolContext)
                    : Array.Empty<ITool>();

                var prompt = BuildPromptWithTools(history, availableTools, request.SystemPrompt);

                // Stream LLM response
                var iterationResponse = new StringBuilder();
                var toolCalls = new List<ToolCallRequest>();
                var streamingParser = _functionCallParser.CreateStreamingParser();

                await foreach (var token in _llmService.GenerateStreamingAsync(
                    prompt, request.InferenceOptions ?? GetDefaultInferenceOptions(), linkedCt))
                {
                    totalTokens++;
                    var parseResult = streamingParser.ProcessToken(token);

                    if (parseResult.IsText && !string.IsNullOrEmpty(parseResult.Text))
                    {
                        iterationResponse.Append(parseResult.Text);
                        responseBuilder.Append(parseResult.Text);

                        yield return TextGenerationEvent.Token(
                            parseResult.Text, request.RequestId, _stateMachine.IterationNumber, totalTokens);
                    }
                    else if (parseResult.IsToolCall && parseResult.ToolCall != null)
                    {
                        _stateMachine.TryTransition(AgentStateTransition.DetectToolCall);
                        var toolCall = parseResult.ToolCall with 
                        { 
                            IterationNumber = _stateMachine.IterationNumber 
                        };
                        toolCalls.Add(toolCall);

                        yield return ToolCallRequestEvent.Create(
                            toolCall, request.RequestId, _stateMachine.IterationNumber,
                            toolCalls.Count - 1, toolCalls.Count);
                    }
                }

                // Flush remaining
                var remaining = streamingParser.Flush();
                if (!string.IsNullOrEmpty(remaining))
                {
                    responseBuilder.Append(remaining);
                    yield return TextGenerationEvent.Token(
                        remaining, request.RequestId, _stateMachine.IterationNumber, totalTokens);
                }

                // No tool calls = done
                if (toolCalls.Count == 0)
                {
                    _stateMachine.TryTransition(AgentStateTransition.NoToolCalls);
                    yield return TextGenerationEvent.Complete(
                        request.RequestId, _stateMachine.IterationNumber, totalTokens);
                    break;
                }

                // Add assistant message to history
                history.Add(ChatMessage.Assistant(iterationResponse.ToString()));

                // Process tool calls
                await foreach (var evt in ProcessToolCallsAsync(
                    request, toolCalls, toolUsageTracker, history, linkedCt))
                {
                    yield return evt;
                    if (evt is ToolResultEvent tre && tre.Result.IsSuccess)
                        toolCallsExecuted++;
                }

                // Delay between iterations
                if (_config.IterationDelay > TimeSpan.Zero)
                    await Task.Delay(_config.IterationDelay, linkedCt);
            }

            _stateMachine.TryTransition(AgentStateTransition.Complete);

            yield return AgentCompleteEvent.Success(
                request.RequestId,
                responseBuilder.ToString(),
                toolCallsExecuted,
                _stateMachine.IterationNumber,
                DateTime.UtcNow - startTime,
                totalTokens,
                toolUsageTracker.Values.ToList());
        }
        catch (OperationCanceledException) when (timeoutCts.IsCancellationRequested)
        {
            _stateMachine.TryTransition(AgentStateTransition.Fail, "Request timed out");
            yield return AgentErrorEvent.Timeout(request.RequestId);
        }
        catch (OperationCanceledException)
        {
            _stateMachine.TryTransition(AgentStateTransition.Cancel);
            yield return AgentCompleteEvent.Cancelled(
                request.RequestId, responseBuilder.ToString(),
                toolCallsExecuted, _stateMachine.IterationNumber, DateTime.UtcNow - startTime);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Agent processing failed");
            _stateMachine.TryTransition(AgentStateTransition.Fail, ex.Message);
            yield return AgentErrorEvent.FromException(ex, request.RequestId, true);
        }
        finally
        {
            _cts?.Dispose();
            _cts = null;
            _pendingApprovals.Clear();
        }
    }

    #endregion

    #region Tool Processing

    private async IAsyncEnumerable<AgentEvent> ProcessToolCallsAsync(
        AgentRequest request,
        List<ToolCallRequest> toolCalls,
        Dictionary<string, ToolUsageSummary> usageTracker,
        List<ChatMessage> history,
        [EnumeratorCancellation] CancellationToken ct)
    {
        foreach (var toolCall in toolCalls)
        {
            var startTime = DateTime.UtcNow;

            // Validate
            var tool = _toolRegistry.GetTool(toolCall.ToolId);
            if (tool == null)
            {
                yield return CreateToolResultEvent(toolCall,
                    ToolResult.Failed($"Tool not found: {toolCall.ToolId}"),
                    DateTime.UtcNow - startTime, request.RequestId);
                continue;
            }

            var validation = tool.Validate(toolCall.Parameters);
            if (!validation.IsValid)
            {
                yield return CreateToolResultEvent(toolCall,
                    ToolResult.Failed($"Validation failed: {string.Join(", ", validation.Errors)}"),
                    DateTime.UtcNow - startTime, request.RequestId);
                continue;
            }

            // Check permission
            var permission = await _permissionManager.CheckPermissionAsync(toolCall);

            if (permission.RequiresApproval)
            {
                _stateMachine.TryTransition(AgentStateTransition.RequestApproval);

                var approvalTcs = new TaskCompletionSource<ApprovalDecision>();
                _pendingApprovals[toolCall.Id] = approvalTcs;

                yield return ApprovalRequestEvent.Create(
                    toolCall, permission.ApprovalReason ?? "Approval required",
                    toolCall.RiskLevel, request.RequestId, _stateMachine.IterationNumber);

                ApprovalDecision decision;
                try
                {
                    decision = await approvalTcs.Task.WaitAsync(
                        _config.ApprovalTimeout, ct);
                }
                catch (TimeoutException)
                {
                    decision = ApprovalDecision.Timeout();
                }
                finally
                {
                    _pendingApprovals.TryRemove(toolCall.Id, out _);
                }

                if (!decision.Approved)
                {
                    _stateMachine.TryTransition(AgentStateTransition.ApprovalDenied);
                    yield return CreateToolResultEvent(toolCall,
                        ToolResult.Failed($"Denied: {decision.Reason ?? "User denied"}"),
                        DateTime.UtcNow - startTime, request.RequestId);
                    continue;
                }

                if (decision.ShouldRemember)
                    await _permissionManager.RememberDecisionAsync(toolCall.ToolId, decision);

                _stateMachine.TryTransition(AgentStateTransition.ApprovalGranted);
            }
            else
            {
                _stateMachine.TryTransition(AgentStateTransition.ApprovalGranted);
            }

            // Execute
            yield return ToolExecutionEvent.Starting(
                toolCall.ToolId, toolCall.ToolName,
                request.RequestId, _stateMachine.IterationNumber);

            var context = new ToolExecutionContext
            {
                SessionId = request.ConversationId,
                WorkspacePath = request.ToolContext?.WorkspacePath,
                Parameters = toolCall.Parameters,
                CancellationToken = ct,
                IsApproved = true
            };

            ToolResult result;
            try
            {
                using var toolTimeout = new CancellationTokenSource(_config.ToolExecutionTimeout);
                using var toolLinked = CancellationTokenSource.CreateLinkedTokenSource(ct, toolTimeout.Token);

                result = await _toolExecutionService.ExecuteAsync(tool, context, toolLinked.Token);
            }
            catch (Exception ex)
            {
                result = ToolResult.Failed(ex.Message);
            }

            var duration = DateTime.UtcNow - startTime;
            UpdateUsageTracker(usageTracker, toolCall, result, duration);

            if (_config.IncludeToolResultsInHistory)
                history.Add(ChatMessage.Tool(FormatToolResultForHistory(toolCall, result)));

            _stateMachine.TryTransition(AgentStateTransition.ToolComplete);
            yield return CreateToolResultEvent(toolCall, result, duration, request.RequestId);
        }
    }

    #endregion

    #region Approval Flow

    public Task ProvideApprovalAsync(Guid requestId, ApprovalDecision decision)
    {
        if (_pendingApprovals.TryGetValue(requestId, out var tcs))
            tcs.TrySetResult(decision);
        return Task.CompletedTask;
    }

    public IReadOnlyList<ToolCallRequest> GetPendingApprovals() =>
        _pendingApprovals.Keys.Select(id => 
            new ToolCallRequest { Id = id }).ToList();

    public Task CancelPendingApprovalsAsync()
    {
        foreach (var tcs in _pendingApprovals.Values)
            tcs.TrySetCanceled();
        _pendingApprovals.Clear();
        return Task.CompletedTask;
    }

    #endregion

    #region Cancellation

    public Task CancelAsync()
    {
        _cts?.Cancel();
        foreach (var tcs in _pendingApprovals.Values)
            tcs.TrySetCanceled();
        return Task.CompletedTask;
    }

    #endregion

    #region Helper Methods

    private List<ChatMessage> BuildConversationHistory(AgentRequest request)
    {
        var history = new List<ChatMessage>();
        if (request.History != null)
            history.AddRange(request.History);
        history.Add(ChatMessage.User(request.Message));
        return history;
    }

    private string BuildPromptWithTools(
        List<ChatMessage> history, IReadOnlyList<ITool> tools, string? customSystemPrompt)
    {
        var sb = new StringBuilder();

        if (!string.IsNullOrEmpty(customSystemPrompt))
            sb.AppendLine(customSystemPrompt).AppendLine();

        if (tools.Count > 0)
        {
            sb.AppendLine(_config.ToolUseSystemPrompt).AppendLine();
            sb.AppendLine("Available tools:").AppendLine();

            foreach (var tool in tools)
            {
                sb.AppendLine(_config.ToolDefinitionFormat
                    .Replace("{name}", tool.Name)
                    .Replace("{description}", tool.Description)
                    .Replace("{parameters}", tool.InputSchema.ToJson()));
                sb.AppendLine();
            }

            sb.AppendLine(_config.ToolCallFormat).AppendLine();
        }

        foreach (var msg in history)
        {
            var role = msg.Role switch
            {
                MessageRole.User => "User",
                MessageRole.Assistant => "Assistant",
                MessageRole.System => "System",
                MessageRole.Tool => "Tool Result",
                _ => msg.Role.ToString()
            };
            sb.AppendLine($"{role}: {msg.Content}").AppendLine();
        }

        return sb.ToString();
    }

    private string FormatToolResultForHistory(ToolCallRequest request, ToolResult result)
    {
        var content = result.IsSuccess ? result.Content ?? "(no output)" : $"Error: {result.ErrorMessage}";
        if (content.Length > _config.MaxToolResultTokens * 4)
            content = content[..(_config.MaxToolResultTokens * 4)] + "\n...[truncated]";
        return $"[{request.ToolName}]\n{content}";
    }

    private static ToolResultEvent CreateToolResultEvent(
        ToolCallRequest request, ToolResult result, TimeSpan duration, Guid requestId) => new()
    {
        RequestId = requestId,
        ToolId = request.ToolId,
        ToolName = request.ToolName,
        Result = result,
        Duration = duration
    };

    private static void UpdateUsageTracker(
        Dictionary<string, ToolUsageSummary> tracker,
        ToolCallRequest request, ToolResult result, TimeSpan duration)
    {
        if (!tracker.TryGetValue(request.ToolId, out var summary))
        {
            summary = new ToolUsageSummary { ToolId = request.ToolId, ToolName = request.ToolName };
            tracker[request.ToolId] = summary;
        }

        tracker[request.ToolId] = summary with
        {
            InvocationCount = summary.InvocationCount + 1,
            SuccessCount = summary.SuccessCount + (result.IsSuccess ? 1 : 0),
            FailureCount = summary.FailureCount + (result.IsSuccess ? 0 : 1),
            TotalDuration = summary.TotalDuration + duration
        };
    }

    private InferenceOptions GetDefaultInferenceOptions() => new(4096, 0.7f, 0.9f);

    public void Dispose() => _cts?.Dispose();

    #endregion
}
```

### 2. PermissionManager.cs

**Location**: `src/SeniorIntern.Services/AI/PermissionManager.cs`

```csharp
namespace SeniorIntern.Services.AI;

using System.Collections.Concurrent;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Core.Tools;

/// <summary>
/// Manages tool execution permissions and caching.
/// </summary>
public sealed class PermissionManager : IPermissionManager
{
    private readonly ISettingsService _settingsService;
    private readonly ConcurrentDictionary<string, ApprovalDecision> _sessionCache = new();
    private readonly ConcurrentDictionary<string, ToolPermissionSettings> _toolSettings = new();
    private readonly ILogger<PermissionManager> _logger;

    public RiskLevel AutoApprovalThreshold { get; set; } = RiskLevel.Safe;
    public bool AlwaysPromptForUnsafe { get; set; } = true;

    public PermissionManager(ISettingsService settingsService, ILogger<PermissionManager> logger)
    {
        _settingsService = settingsService;
        _logger = logger;
    }

    public Task<PermissionCheckResult> CheckPermissionAsync(ToolCallRequest request)
    {
        // Check tool settings first
        if (_toolSettings.TryGetValue(request.ToolId, out var settings))
        {
            if (settings.AlwaysDeny)
                return Task.FromResult(PermissionCheckResult.Denied("Tool is blocked"));
            if (settings.AlwaysAllow)
                return Task.FromResult(PermissionCheckResult.Allowed("Tool is always allowed"));
        }

        // Check session cache
        if (_sessionCache.TryGetValue(request.ToolId, out var cached) && cached.Approved)
            return Task.FromResult(PermissionCheckResult.CachedAllowed(CacheSource.Session));

        // Check risk level
        if (request.RiskLevel <= AutoApprovalThreshold)
            return Task.FromResult(PermissionCheckResult.Allowed($"Risk level {request.RiskLevel} is auto-approved"));

        return Task.FromResult(PermissionCheckResult.NeedsApproval(
            $"Tool {request.ToolName} has risk level {request.RiskLevel}", request.RiskLevel));
    }

    public Task<bool> RequiresApprovalAsync(ToolCallRequest request) =>
        CheckPermissionAsync(request).ContinueWith(t => t.Result.RequiresApproval);

    public Task<PermissionCheckResult> CheckPermissionAsync(string toolId, RiskLevel riskLevel) =>
        CheckPermissionAsync(new ToolCallRequest { ToolId = toolId, RiskLevel = riskLevel });

    public Task RememberDecisionAsync(string toolId, ApprovalDecision decision)
    {
        if (decision.RememberForSession)
            _sessionCache[toolId] = decision;
        // TODO: Persist if RememberForTool
        return Task.CompletedTask;
    }

    public Task RememberPatternAsync(string toolId, string pattern, bool allow, bool persistent = false)
    {
        // TODO: Implement pattern-based permissions
        return Task.CompletedTask;
    }

    public Task ClearSessionPermissionsAsync()
    {
        _sessionCache.Clear();
        return Task.CompletedTask;
    }

    public Task ClearAllRememberedAsync()
    {
        _sessionCache.Clear();
        _toolSettings.Clear();
        return Task.CompletedTask;
    }

    public Task<ToolPermissionSettings?> GetToolPermissionsAsync(string toolId) =>
        Task.FromResult(_toolSettings.GetValueOrDefault(toolId));

    public Task SetToolPermissionsAsync(string toolId, ToolPermissionSettings settings)
    {
        _toolSettings[toolId] = settings;
        return Task.CompletedTask;
    }

    public Task RemoveToolPermissionsAsync(string toolId)
    {
        _toolSettings.TryRemove(toolId, out _);
        return Task.CompletedTask;
    }

    public Task<IReadOnlyDictionary<string, ToolPermissionSettings>> GetAllToolPermissionsAsync() =>
        Task.FromResult<IReadOnlyDictionary<string, ToolPermissionSettings>>(
            _toolSettings.ToDictionary(kv => kv.Key, kv => kv.Value));
}
```

---

## File Summary

| File | Location | Purpose | Lines |
|------|----------|---------|-------|
| `AgentService.cs` | `Services/AI/` | Core agent loop implementation | ~350 |
| `PermissionManager.cs` | `Services/AI/` | Permission checking and caching | ~100 |

---

## Unit Test Plan

| Test | Description |
|------|-------------|
| `AgentService_ProcessMessage_EmitsIterationEvents` | Iteration tracking |
| `AgentService_ProcessMessage_StreamsTextTokens` | Token streaming |
| `AgentService_ProcessMessage_DetectsToolCalls` | Tool detection |
| `AgentService_ProcessMessage_HandlesApproval` | Approval flow |
| `AgentService_CancelAsync_StopsProcessing` | Cancellation |
| `AgentService_Timeout_EmitsErrorEvent` | Timeout handling |
| `PermissionManager_CheckPermission_AllowsSafe` | Risk-based |
| `PermissionManager_RememberDecision_Caches` | Session cache |

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | Agent loop processes messages with tool support |
| AC-2 | Streaming events are yielded during processing |
| AC-3 | Tool calls are parsed and validated |
| AC-4 | Approval flow works with TaskCompletionSource |
| AC-5 | Cancellation stops processing cleanly |
| AC-6 | Tool results are added to conversation history |
| AC-7 | Iteration limits are enforced |
| AC-8 | Timeouts are handled properly |

---

## Changelog Entry

```markdown
## v0.6.2i - AgentService Implementation

### Added
- `AgentService` implementing `IAgentService`
  - Agent loop with configurable iteration limits
  - Streaming token output via IAsyncEnumerable
  - Tool call parsing with StreamingFunctionCallParser
  - Approval flow via TaskCompletionSource
  - Timeout and cancellation handling
  - Tool usage tracking and statistics
- `PermissionManager` implementing `IPermissionManager`
  - Session-scoped decision caching
  - Risk-level-based auto-approval
  - Tool-level always allow/deny settings
```

---

## Timeline Estimate

| Version | Estimated Effort |
|---------|------------------|
| v0.6.2i | 1.5 days |
