# Design Specification: AIntern v0.6.1b "Tool Execution Context"

## Overview

**Version**: v0.6.1b
**Parent**: v0.6.1 Tool Framework
**Focus**: Execution context, progress reporting, and cancellation support

### Purpose

This sub-version defines the execution context infrastructure for tools:
1. Create `ToolExecutionContext` with all execution metadata
2. Create `ToolProgress` for long-running operation reporting
3. Create `ToolExecutionContextBuilder` for fluent construction
4. Provide workspace path resolution utilities
5. Enable service provider access during execution
6. Support cancellation and modified parameters

### Dependencies

**From v0.6.1a (Tool Core Models)**:
- `ITool` interface (references ToolExecutionContext)
- Forward declaration to be replaced

**Future consumers**:
- v0.6.1c: Tool Result System
- v0.6.1f: Tool Base Class
- v0.6.1i: Tool Execution Service
- v0.6.3: Built-in Tools

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                 v0.6.1b Tool Execution Context Architecture                   │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  src/AIntern.Core/Tools/                                                     │
│  ├─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  ToolExecutionContext                                                    │ │
│  │  ┌─────────────────────────────────────────────────────────────────────┐│ │
│  │  │                                                                      ││ │
│  │  │  Identification                                                      ││ │
│  │  │  ├── ExecutionId: Guid          (unique per execution)              ││ │
│  │  │  ├── SessionId: Guid            (conversation/agent session)        ││ │
│  │  │  ├── ToolId: string             (tool being executed)               ││ │
│  │  │  └── StartedAt: DateTime        (execution start time)              ││ │
│  │  │                                                                      ││ │
│  │  │  Workspace                                                           ││ │
│  │  │  ├── WorkspacePath: string?     (project root path)                 ││ │
│  │  │  ├── ResolvePath(path)          (resolve relative paths)            ││ │
│  │  │  └── IsPathInWorkspace(path)    (security check)                    ││ │
│  │  │                                                                      ││ │
│  │  │  Parameters                                                          ││ │
│  │  │  ├── Parameters: JsonElement    (original from LLM)                 ││ │
│  │  │  ├── ModifiedParameters: JsonElement? (user-edited)                 ││ │
│  │  │  └── EffectiveParameters        (modified or original)              ││ │
│  │  │                                                                      ││ │
│  │  │  Services                                                            ││ │
│  │  │  ├── Services: IServiceProvider                                     ││ │
│  │  │  ├── GetRequiredService<T>()                                        ││ │
│  │  │  └── GetService<T>()                                                ││ │
│  │  │                                                                      ││ │
│  │  │  Execution Control                                                   ││ │
│  │  │  ├── CancellationToken          (for abort)                         ││ │
│  │  │  ├── Progress: IProgress<ToolProgress>?                             ││ │
│  │  │  ├── IsApproved: bool           (user approval status)              ││ │
│  │  │  ├── Metadata: IReadOnlyDictionary<string, object>?                 ││ │
│  │  │  └── ReportProgress(message, percent)                               ││ │
│  │  │                                                                      ││ │
│  │  └─────────────────────────────────────────────────────────────────────┘│ │
│  │                                                                          │ │
│  │  ToolProgress                                                            │ │
│  │  ┌─────────────────────────────────────────────────────────────────────┐│ │
│  │  │  ├── Message: string                                                 ││ │
│  │  │  ├── PercentComplete: double?                                        ││ │
│  │  │  ├── CurrentOperation: string?                                       ││ │
│  │  │  ├── ItemsProcessed: int?                                            ││ │
│  │  │  ├── TotalItems: int?                                                ││ │
│  │  │  ├── EstimatedRemaining: TimeSpan?                                   ││ │
│  │  │  └── IsIndeterminate: bool (calculated)                              ││ │
│  │  │                                                                      ││ │
│  │  │  Factory Methods:                                                    ││ │
│  │  │  ├── Message(string)                                                 ││ │
│  │  │  ├── WithPercent(string, double)                                     ││ │
│  │  │  └── Items(string, int processed, int total)                         ││ │
│  │  └─────────────────────────────────────────────────────────────────────┘│ │
│  │                                                                          │ │
│  │  ToolExecutionContextBuilder                                             │ │
│  │  ┌─────────────────────────────────────────────────────────────────────┐│ │
│  │  │  Fluent Builder Pattern                                              ││ │
│  │  │  ├── Create()                                                        ││ │
│  │  │  ├── WithExecutionId(Guid)                                           ││ │
│  │  │  ├── WithSessionId(Guid)                                             ││ │
│  │  │  ├── WithToolId(string)                                              ││ │
│  │  │  ├── WithWorkspace(string?)                                          ││ │
│  │  │  ├── WithParameters(JsonElement)                                     ││ │
│  │  │  ├── WithParametersFromObject(object)                                ││ │
│  │  │  ├── WithServices(IServiceProvider)                                  ││ │
│  │  │  ├── WithCancellation(CancellationToken)                             ││ │
│  │  │  ├── WithProgress(IProgress<ToolProgress>)                           ││ │
│  │  │  ├── WithApproval(bool)                                              ││ │
│  │  │  ├── WithModifiedParameters(JsonElement)                             ││ │
│  │  │  ├── WithMetadata(string, object)                                    ││ │
│  │  │  └── Build() → ToolExecutionContext                                  ││ │
│  │  └─────────────────────────────────────────────────────────────────────┘│ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Execution Context Data Flow

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                      Tool Execution Context Flow                              │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  LLM Response                                                                │
│       │                                                                      │
│       ▼                                                                      │
│  ┌─────────────────┐                                                         │
│  │  Parse Tool     │                                                         │
│  │  Invocation     │                                                         │
│  └────────┬────────┘                                                         │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────┐     ┌─────────────────┐                                │
│  │    Builder      │────▶│ User Approval   │ (if required)                  │
│  │  Create Context │     │    Dialog       │                                │
│  └────────┬────────┘     └────────┬────────┘                                │
│           │                       │                                          │
│           │ ◄─────────────────────┘ (ModifiedParameters)                    │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                    ToolExecutionContext                              │    │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌────────────┐  │    │
│  │  │ ExecutionId │  │ Parameters  │  │  Services   │  │ Workspace  │  │    │
│  │  └─────────────┘  └─────────────┘  └─────────────┘  └────────────┘  │    │
│  └────────┬────────────────────────────────────────────────────────────┘    │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────┐                                                         │
│  │   Tool.Execute  │                                                         │
│  │      Async      │                                                         │
│  └────────┬────────┘                                                         │
│           │                                                                  │
│           │ (during execution)                                               │
│           ▼                                                                  │
│  ┌─────────────────┐     ┌─────────────────┐                                │
│  │ context.Report  │────▶│  Progress UI    │                                │
│  │    Progress     │     │    Update       │                                │
│  └─────────────────┘     └─────────────────┘                                │
│                                                                              │
│  Path Resolution:                                                            │
│  ┌─────────────────┐     ┌─────────────────┐                                │
│  │ "src/file.cs"   │────▶│ ResolvePath()   │───▶ "/project/src/file.cs"    │
│  └─────────────────┘     └─────────────────┘                                │
│                                                                              │
│  Security Check:                                                             │
│  ┌─────────────────┐     ┌─────────────────┐                                │
│  │ "/etc/passwd"   │────▶│IsPathInWorkspace│───▶ false (blocked)           │
│  └─────────────────┘     └─────────────────┘                                │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Specifications

### 1. ToolExecutionContext.cs

**Location**: `src/AIntern.Core/Tools/ToolExecutionContext.cs`

```csharp
namespace AIntern.Core.Tools;

using System.Text.Json;
using Microsoft.Extensions.DependencyInjection;

/// <summary>
/// Context provided to tools during execution.
/// Contains all information and services needed to execute the tool.
/// </summary>
/// <remarks>
/// <para>
/// The execution context is created by the tool execution service and passed
/// to tools when they are invoked. It provides:
/// </para>
/// <list type="bullet">
/// <item>Unique execution and session identifiers for tracking</item>
/// <item>Input parameters from the LLM (with optional user modifications)</item>
/// <item>Access to application services via dependency injection</item>
/// <item>Workspace path for resolving relative file paths</item>
/// <item>Cancellation token for aborting long-running operations</item>
/// <item>Progress reporter for updating the UI during execution</item>
/// </list>
/// </remarks>
public sealed class ToolExecutionContext
{
    /// <summary>
    /// Unique identifier for this specific execution.
    /// </summary>
    /// <remarks>
    /// Used for logging, auditing, and correlation of events.
    /// Each tool invocation gets a new execution ID.
    /// </remarks>
    public Guid ExecutionId { get; init; } = Guid.NewGuid();

    /// <summary>
    /// The conversation/agent session this execution belongs to.
    /// </summary>
    /// <remarks>
    /// Used to associate tool executions with a specific conversation.
    /// Multiple tool executions may share the same session ID.
    /// </remarks>
    public Guid SessionId { get; init; }

    /// <summary>
    /// ID of the tool being executed.
    /// </summary>
    /// <remarks>
    /// Matches the <see cref="ITool.Id"/> of the tool.
    /// Used for logging and validation.
    /// </remarks>
    public string ToolId { get; init; } = string.Empty;

    /// <summary>
    /// Current workspace root path (if any).
    /// </summary>
    /// <remarks>
    /// Tools should resolve relative paths against this directory.
    /// May be null if no workspace is open.
    /// </remarks>
    public string? WorkspacePath { get; init; }

    /// <summary>
    /// Input parameters from the LLM in JSON format.
    /// </summary>
    /// <remarks>
    /// These are the original parameters as parsed from the LLM response.
    /// Use <see cref="EffectiveParameters"/> to get the final parameters
    /// (which may include user modifications).
    /// </remarks>
    public JsonElement Parameters { get; init; }

    /// <summary>
    /// Service provider for accessing application services.
    /// </summary>
    /// <remarks>
    /// Tools can use this to access any registered service.
    /// Prefer using <see cref="GetRequiredService{T}"/> or
    /// <see cref="GetService{T}"/> for cleaner syntax.
    /// </remarks>
    public IServiceProvider Services { get; init; } = null!;

    /// <summary>
    /// Cancellation token for the execution.
    /// </summary>
    /// <remarks>
    /// Tools should check this regularly during long operations.
    /// When cancelled, tools should clean up and return promptly.
    /// </remarks>
    public CancellationToken CancellationToken { get; init; }

    /// <summary>
    /// Progress reporter for long-running tools.
    /// </summary>
    /// <remarks>
    /// May be null if progress tracking is not needed.
    /// Use <see cref="ReportProgress"/> for a null-safe way to report.
    /// </remarks>
    public IProgress<ToolProgress>? Progress { get; init; }

    /// <summary>
    /// Whether user has explicitly approved this execution.
    /// </summary>
    /// <remarks>
    /// True if the user approved in the permit/deny dialog.
    /// Also true for auto-approved low-risk operations.
    /// </remarks>
    public bool IsApproved { get; init; }

    /// <summary>
    /// User-modified parameters (if changed during approval).
    /// </summary>
    /// <remarks>
    /// When the user edits parameters in the approval dialog,
    /// this contains the modified values. Takes precedence over
    /// <see cref="Parameters"/> when present.
    /// </remarks>
    public JsonElement? ModifiedParameters { get; init; }

    /// <summary>
    /// Additional metadata for this execution.
    /// </summary>
    /// <remarks>
    /// Used for custom data that doesn't fit other properties.
    /// Examples: request ID, correlation ID, feature flags.
    /// </remarks>
    public IReadOnlyDictionary<string, object>? Metadata { get; init; }

    /// <summary>
    /// Timestamp when execution started.
    /// </summary>
    public DateTime StartedAt { get; init; } = DateTime.UtcNow;

    // ========================================================================
    // Computed Properties
    // ========================================================================

    /// <summary>
    /// Get the effective parameters (modified or original).
    /// </summary>
    /// <remarks>
    /// Always use this property to get parameters in tool implementations.
    /// It returns user-modified parameters if available, otherwise the original.
    /// </remarks>
    public JsonElement EffectiveParameters =>
        ModifiedParameters ?? Parameters;

    /// <summary>
    /// Whether this execution has a workspace context.
    /// </summary>
    public bool HasWorkspace => !string.IsNullOrEmpty(WorkspacePath);

    /// <summary>
    /// Whether user modifications were made to parameters.
    /// </summary>
    public bool HasModifiedParameters => ModifiedParameters.HasValue;

    /// <summary>
    /// Time elapsed since execution started.
    /// </summary>
    public TimeSpan Elapsed => DateTime.UtcNow - StartedAt;

    // ========================================================================
    // Service Access
    // ========================================================================

    /// <summary>
    /// Get a required service from the service provider.
    /// </summary>
    /// <typeparam name="T">Service type to retrieve.</typeparam>
    /// <returns>The requested service.</returns>
    /// <exception cref="InvalidOperationException">
    /// Thrown if the service is not registered.
    /// </exception>
    public T GetRequiredService<T>() where T : notnull =>
        Services.GetRequiredService<T>();

    /// <summary>
    /// Get an optional service from the service provider.
    /// </summary>
    /// <typeparam name="T">Service type to retrieve.</typeparam>
    /// <returns>The requested service, or null if not registered.</returns>
    public T? GetService<T>() =>
        Services.GetService<T>();

    // ========================================================================
    // Progress Reporting
    // ========================================================================

    /// <summary>
    /// Report progress if a progress reporter is available.
    /// </summary>
    /// <param name="message">Progress message to display.</param>
    /// <param name="percentComplete">
    /// Optional completion percentage (0.0 to 100.0).
    /// </param>
    public void ReportProgress(string message, double? percentComplete = null)
    {
        Progress?.Report(new ToolProgress
        {
            Message = message,
            PercentComplete = percentComplete,
            CurrentOperation = null
        });
    }

    /// <summary>
    /// Report progress with item counts.
    /// </summary>
    /// <param name="message">Progress message to display.</param>
    /// <param name="itemsProcessed">Number of items processed.</param>
    /// <param name="totalItems">Total number of items.</param>
    public void ReportProgress(string message, int itemsProcessed, int totalItems)
    {
        Progress?.Report(ToolProgress.Items(message, itemsProcessed, totalItems));
    }

    /// <summary>
    /// Report progress with current operation.
    /// </summary>
    /// <param name="message">Progress message to display.</param>
    /// <param name="currentOperation">Current sub-operation name.</param>
    public void ReportOperation(string message, string currentOperation)
    {
        Progress?.Report(new ToolProgress
        {
            Message = message,
            CurrentOperation = currentOperation
        });
    }

    // ========================================================================
    // Path Resolution
    // ========================================================================

    /// <summary>
    /// Resolve a path relative to the workspace.
    /// </summary>
    /// <param name="relativePath">Path that may be relative.</param>
    /// <returns>Absolute path resolved against workspace.</returns>
    /// <exception cref="InvalidOperationException">
    /// Thrown if path is relative but no workspace is set.
    /// </exception>
    public string ResolvePath(string relativePath)
    {
        if (string.IsNullOrEmpty(relativePath))
            throw new ArgumentException("Path cannot be empty", nameof(relativePath));

        // Already absolute
        if (Path.IsPathRooted(relativePath))
            return Path.GetFullPath(relativePath);

        // Need workspace for relative paths
        if (string.IsNullOrEmpty(WorkspacePath))
            throw new InvalidOperationException(
                "Cannot resolve relative path without workspace context");

        return Path.GetFullPath(Path.Combine(WorkspacePath, relativePath));
    }

    /// <summary>
    /// Try to resolve a path relative to the workspace.
    /// </summary>
    /// <param name="relativePath">Path that may be relative.</param>
    /// <param name="resolvedPath">The resolved absolute path.</param>
    /// <returns>True if resolution succeeded.</returns>
    public bool TryResolvePath(string relativePath, out string resolvedPath)
    {
        resolvedPath = string.Empty;

        if (string.IsNullOrEmpty(relativePath))
            return false;

        if (Path.IsPathRooted(relativePath))
        {
            resolvedPath = Path.GetFullPath(relativePath);
            return true;
        }

        if (string.IsNullOrEmpty(WorkspacePath))
            return false;

        resolvedPath = Path.GetFullPath(Path.Combine(WorkspacePath, relativePath));
        return true;
    }

    /// <summary>
    /// Check if a path is within the workspace.
    /// </summary>
    /// <param name="path">Path to check (relative or absolute).</param>
    /// <returns>True if the path is within the workspace bounds.</returns>
    /// <remarks>
    /// Returns false if no workspace is set.
    /// This is a security check to prevent tools from accessing
    /// files outside the project directory.
    /// </remarks>
    public bool IsPathInWorkspace(string path)
    {
        if (string.IsNullOrEmpty(WorkspacePath))
            return false;

        if (string.IsNullOrEmpty(path))
            return false;

        try
        {
            var fullPath = Path.IsPathRooted(path)
                ? Path.GetFullPath(path)
                : Path.GetFullPath(Path.Combine(WorkspacePath, path));

            var workspaceFullPath = Path.GetFullPath(WorkspacePath);

            // Ensure workspace path ends with separator for accurate prefix check
            if (!workspaceFullPath.EndsWith(Path.DirectorySeparatorChar))
                workspaceFullPath += Path.DirectorySeparatorChar;

            return fullPath.StartsWith(workspaceFullPath, StringComparison.OrdinalIgnoreCase)
                || fullPath.Equals(WorkspacePath.TrimEnd(Path.DirectorySeparatorChar),
                    StringComparison.OrdinalIgnoreCase);
        }
        catch
        {
            // Invalid path
            return false;
        }
    }

    /// <summary>
    /// Get the relative path from workspace to a file.
    /// </summary>
    /// <param name="absolutePath">Absolute path to the file.</param>
    /// <returns>Relative path from workspace, or the original if outside.</returns>
    public string GetRelativePath(string absolutePath)
    {
        if (string.IsNullOrEmpty(WorkspacePath))
            return absolutePath;

        if (!IsPathInWorkspace(absolutePath))
            return absolutePath;

        return Path.GetRelativePath(WorkspacePath, absolutePath);
    }

    // ========================================================================
    // Parameter Helpers
    // ========================================================================

    /// <summary>
    /// Get a required string parameter.
    /// </summary>
    /// <param name="name">Parameter name.</param>
    /// <returns>Parameter value.</returns>
    /// <exception cref="ArgumentException">
    /// Thrown if parameter is missing or not a string.
    /// </exception>
    public string GetRequiredString(string name)
    {
        var parameters = EffectiveParameters;
        if (!parameters.TryGetProperty(name, out var prop))
            throw new ArgumentException($"Missing required parameter: {name}");

        if (prop.ValueKind != JsonValueKind.String)
            throw new ArgumentException($"Parameter '{name}' must be a string");

        return prop.GetString()
            ?? throw new ArgumentException($"Parameter '{name}' cannot be null");
    }

    /// <summary>
    /// Get an optional string parameter.
    /// </summary>
    /// <param name="name">Parameter name.</param>
    /// <param name="defaultValue">Default value if not present.</param>
    /// <returns>Parameter value or default.</returns>
    public string? GetOptionalString(string name, string? defaultValue = null)
    {
        var parameters = EffectiveParameters;
        if (!parameters.TryGetProperty(name, out var prop))
            return defaultValue;

        if (prop.ValueKind == JsonValueKind.Null)
            return defaultValue;

        return prop.GetString() ?? defaultValue;
    }

    /// <summary>
    /// Get a required integer parameter.
    /// </summary>
    public int GetRequiredInt(string name)
    {
        var parameters = EffectiveParameters;
        if (!parameters.TryGetProperty(name, out var prop))
            throw new ArgumentException($"Missing required parameter: {name}");

        if (prop.ValueKind != JsonValueKind.Number)
            throw new ArgumentException($"Parameter '{name}' must be an integer");

        return prop.GetInt32();
    }

    /// <summary>
    /// Get an optional integer parameter.
    /// </summary>
    public int GetOptionalInt(string name, int defaultValue = 0)
    {
        var parameters = EffectiveParameters;
        if (!parameters.TryGetProperty(name, out var prop))
            return defaultValue;

        if (prop.ValueKind != JsonValueKind.Number)
            return defaultValue;

        return prop.GetInt32();
    }

    /// <summary>
    /// Get a required boolean parameter.
    /// </summary>
    public bool GetRequiredBool(string name)
    {
        var parameters = EffectiveParameters;
        if (!parameters.TryGetProperty(name, out var prop))
            throw new ArgumentException($"Missing required parameter: {name}");

        if (prop.ValueKind != JsonValueKind.True && prop.ValueKind != JsonValueKind.False)
            throw new ArgumentException($"Parameter '{name}' must be a boolean");

        return prop.GetBoolean();
    }

    /// <summary>
    /// Get an optional boolean parameter.
    /// </summary>
    public bool GetOptionalBool(string name, bool defaultValue = false)
    {
        var parameters = EffectiveParameters;
        if (!parameters.TryGetProperty(name, out var prop))
            return defaultValue;

        if (prop.ValueKind == JsonValueKind.True)
            return true;
        if (prop.ValueKind == JsonValueKind.False)
            return false;

        return defaultValue;
    }

    /// <summary>
    /// Get a parameter deserialized to a specific type.
    /// </summary>
    public T? GetParameter<T>(string name)
    {
        var parameters = EffectiveParameters;
        if (!parameters.TryGetProperty(name, out var prop))
            return default;

        return prop.Deserialize<T>();
    }

    /// <summary>
    /// Check if a parameter exists.
    /// </summary>
    public bool HasParameter(string name) =>
        EffectiveParameters.TryGetProperty(name, out _);

    // ========================================================================
    // Metadata Helpers
    // ========================================================================

    /// <summary>
    /// Get a metadata value.
    /// </summary>
    public T? GetMetadata<T>(string key)
    {
        if (Metadata == null)
            return default;

        if (!Metadata.TryGetValue(key, out var value))
            return default;

        if (value is T typedValue)
            return typedValue;

        return default;
    }

    /// <summary>
    /// Check if metadata contains a key.
    /// </summary>
    public bool HasMetadata(string key) =>
        Metadata?.ContainsKey(key) ?? false;
}
```

### 2. ToolProgress.cs

**Location**: `src/AIntern.Core/Tools/ToolProgress.cs`

```csharp
namespace AIntern.Core.Tools;

/// <summary>
/// Progress information for long-running tool executions.
/// </summary>
/// <remarks>
/// <para>
/// Progress reports are used to update the UI during tool execution.
/// They can represent:
/// </para>
/// <list type="bullet">
/// <item>Simple status messages</item>
/// <item>Percentage-based progress</item>
/// <item>Item-based progress (e.g., "5 of 10 files")</item>
/// <item>Indeterminate progress with activity messages</item>
/// </list>
/// </remarks>
public sealed class ToolProgress
{
    /// <summary>
    /// Human-readable progress message.
    /// </summary>
    /// <remarks>
    /// Should be concise and descriptive.
    /// Examples: "Reading file...", "Installing packages..."
    /// </remarks>
    public string Message { get; init; } = string.Empty;

    /// <summary>
    /// Completion percentage (0.0 to 100.0), if known.
    /// </summary>
    /// <remarks>
    /// Null indicates indeterminate progress.
    /// Values outside 0-100 are clamped.
    /// </remarks>
    public double? PercentComplete { get; init; }

    /// <summary>
    /// Current sub-operation being performed.
    /// </summary>
    /// <remarks>
    /// Used to provide more detail about what's happening.
    /// Example: While message is "Building project...",
    /// CurrentOperation might be "Compiling src/Models/User.cs"
    /// </remarks>
    public string? CurrentOperation { get; init; }

    /// <summary>
    /// Number of items processed (for batch operations).
    /// </summary>
    public int? ItemsProcessed { get; init; }

    /// <summary>
    /// Total number of items (for batch operations).
    /// </summary>
    public int? TotalItems { get; init; }

    /// <summary>
    /// Estimated time remaining, if calculable.
    /// </summary>
    public TimeSpan? EstimatedRemaining { get; init; }

    /// <summary>
    /// Whether this progress has a warning.
    /// </summary>
    public bool HasWarning { get; init; }

    /// <summary>
    /// Warning message if applicable.
    /// </summary>
    public string? WarningMessage { get; init; }

    // ========================================================================
    // Computed Properties
    // ========================================================================

    /// <summary>
    /// Whether this is an indeterminate progress update.
    /// </summary>
    /// <remarks>
    /// True when neither percentage nor item counts are provided.
    /// UI should show a spinner or marquee progress bar.
    /// </remarks>
    public bool IsIndeterminate =>
        PercentComplete == null && TotalItems == null;

    /// <summary>
    /// Normalized percentage (0.0 to 1.0) for progress bars.
    /// </summary>
    public double NormalizedProgress
    {
        get
        {
            if (PercentComplete.HasValue)
                return Math.Clamp(PercentComplete.Value / 100.0, 0.0, 1.0);

            if (TotalItems.HasValue && TotalItems.Value > 0 && ItemsProcessed.HasValue)
                return Math.Clamp((double)ItemsProcessed.Value / TotalItems.Value, 0.0, 1.0);

            return 0.0;
        }
    }

    /// <summary>
    /// Display-friendly progress text.
    /// </summary>
    /// <remarks>
    /// Returns formatted string like "50%" or "5/10" or empty if indeterminate.
    /// </remarks>
    public string ProgressText
    {
        get
        {
            if (PercentComplete.HasValue)
                return $"{PercentComplete.Value:F0}%";

            if (TotalItems.HasValue && ItemsProcessed.HasValue)
                return $"{ItemsProcessed.Value}/{TotalItems.Value}";

            return string.Empty;
        }
    }

    /// <summary>
    /// Display-friendly remaining time text.
    /// </summary>
    public string? RemainingText
    {
        get
        {
            if (!EstimatedRemaining.HasValue)
                return null;

            var remaining = EstimatedRemaining.Value;
            if (remaining.TotalSeconds < 60)
                return $"{remaining.TotalSeconds:F0}s remaining";
            if (remaining.TotalMinutes < 60)
                return $"{remaining.TotalMinutes:F0}m remaining";

            return $"{remaining.TotalHours:F1}h remaining";
        }
    }

    // ========================================================================
    // Factory Methods
    // ========================================================================

    /// <summary>
    /// Create a simple message-only progress update.
    /// </summary>
    /// <param name="message">Progress message.</param>
    /// <returns>Progress with message only (indeterminate).</returns>
    public static ToolProgress Message(string message) =>
        new() { Message = message };

    /// <summary>
    /// Create a progress update with percentage.
    /// </summary>
    /// <param name="message">Progress message.</param>
    /// <param name="percent">Completion percentage (0-100).</param>
    /// <returns>Progress with message and percentage.</returns>
    public static ToolProgress WithPercent(string message, double percent) =>
        new()
        {
            Message = message,
            PercentComplete = Math.Clamp(percent, 0.0, 100.0)
        };

    /// <summary>
    /// Create a progress update for item-based processing.
    /// </summary>
    /// <param name="message">Progress message.</param>
    /// <param name="processed">Number of items processed.</param>
    /// <param name="total">Total number of items.</param>
    /// <returns>Progress with item counts and calculated percentage.</returns>
    public static ToolProgress Items(string message, int processed, int total) =>
        new()
        {
            Message = message,
            ItemsProcessed = processed,
            TotalItems = total,
            PercentComplete = total > 0 ? (processed * 100.0 / total) : null
        };

    /// <summary>
    /// Create a progress update with current operation.
    /// </summary>
    /// <param name="message">Progress message.</param>
    /// <param name="operation">Current sub-operation.</param>
    /// <param name="percent">Optional completion percentage.</param>
    /// <returns>Progress with operation details.</returns>
    public static ToolProgress Operation(
        string message,
        string operation,
        double? percent = null) =>
        new()
        {
            Message = message,
            CurrentOperation = operation,
            PercentComplete = percent
        };

    /// <summary>
    /// Create a progress update with warning.
    /// </summary>
    /// <param name="message">Progress message.</param>
    /// <param name="warning">Warning message.</param>
    /// <returns>Progress with warning flag.</returns>
    public static ToolProgress WithWarning(string message, string warning) =>
        new()
        {
            Message = message,
            HasWarning = true,
            WarningMessage = warning
        };

    /// <summary>
    /// Create a completed progress update.
    /// </summary>
    /// <param name="message">Completion message.</param>
    /// <returns>Progress at 100%.</returns>
    public static ToolProgress Completed(string message = "Completed") =>
        new()
        {
            Message = message,
            PercentComplete = 100.0
        };
}
```

### 3. ToolExecutionContextBuilder.cs

**Location**: `src/AIntern.Core/Tools/ToolExecutionContextBuilder.cs`

```csharp
namespace AIntern.Core.Tools;

using System.Text.Json;

/// <summary>
/// Fluent builder for creating <see cref="ToolExecutionContext"/> instances.
/// </summary>
/// <remarks>
/// <para>
/// This builder provides a clean API for constructing execution contexts,
/// especially useful in testing and the tool execution service.
/// </para>
/// <example>
/// <code>
/// var context = ToolExecutionContextBuilder.Create()
///     .WithToolId("file-read")
///     .WithWorkspace("/path/to/project")
///     .WithParametersFromObject(new { path = "src/file.cs" })
///     .WithServices(serviceProvider)
///     .Build();
/// </code>
/// </example>
/// </remarks>
public sealed class ToolExecutionContextBuilder
{
    private Guid _executionId = Guid.NewGuid();
    private Guid _sessionId;
    private string _toolId = string.Empty;
    private string? _workspacePath;
    private JsonElement _parameters;
    private IServiceProvider? _services;
    private CancellationToken _cancellationToken;
    private IProgress<ToolProgress>? _progress;
    private bool _isApproved;
    private JsonElement? _modifiedParameters;
    private Dictionary<string, object>? _metadata;
    private DateTime? _startedAt;

    /// <summary>
    /// Create a new builder instance.
    /// </summary>
    public static ToolExecutionContextBuilder Create() => new();

    /// <summary>
    /// Set the execution ID.
    /// </summary>
    /// <param name="id">Unique execution identifier.</param>
    public ToolExecutionContextBuilder WithExecutionId(Guid id)
    {
        _executionId = id;
        return this;
    }

    /// <summary>
    /// Set the session ID.
    /// </summary>
    /// <param name="id">Conversation/agent session identifier.</param>
    public ToolExecutionContextBuilder WithSessionId(Guid id)
    {
        _sessionId = id;
        return this;
    }

    /// <summary>
    /// Set the tool ID.
    /// </summary>
    /// <param name="toolId">ID of the tool being executed.</param>
    public ToolExecutionContextBuilder WithToolId(string toolId)
    {
        _toolId = toolId;
        return this;
    }

    /// <summary>
    /// Set the workspace path.
    /// </summary>
    /// <param name="path">Workspace root path, or null for no workspace.</param>
    public ToolExecutionContextBuilder WithWorkspace(string? path)
    {
        _workspacePath = path;
        return this;
    }

    /// <summary>
    /// Set the parameters from a JsonElement.
    /// </summary>
    /// <param name="parameters">Parameters as JSON.</param>
    public ToolExecutionContextBuilder WithParameters(JsonElement parameters)
    {
        _parameters = parameters;
        return this;
    }

    /// <summary>
    /// Set the parameters from an object (serialized to JSON).
    /// </summary>
    /// <param name="obj">Object to serialize as parameters.</param>
    public ToolExecutionContextBuilder WithParametersFromObject(object obj)
    {
        var json = JsonSerializer.Serialize(obj);
        using var doc = JsonDocument.Parse(json);
        _parameters = doc.RootElement.Clone();
        return this;
    }

    /// <summary>
    /// Set the parameters from a JSON string.
    /// </summary>
    /// <param name="json">JSON string containing parameters.</param>
    public ToolExecutionContextBuilder WithParametersFromJson(string json)
    {
        using var doc = JsonDocument.Parse(json);
        _parameters = doc.RootElement.Clone();
        return this;
    }

    /// <summary>
    /// Set empty parameters (empty object {}).
    /// </summary>
    public ToolExecutionContextBuilder WithEmptyParameters()
    {
        using var doc = JsonDocument.Parse("{}");
        _parameters = doc.RootElement.Clone();
        return this;
    }

    /// <summary>
    /// Set the service provider.
    /// </summary>
    /// <param name="services">Application service provider.</param>
    public ToolExecutionContextBuilder WithServices(IServiceProvider services)
    {
        _services = services;
        return this;
    }

    /// <summary>
    /// Set the cancellation token.
    /// </summary>
    /// <param name="ct">Cancellation token for the operation.</param>
    public ToolExecutionContextBuilder WithCancellation(CancellationToken ct)
    {
        _cancellationToken = ct;
        return this;
    }

    /// <summary>
    /// Set the progress reporter.
    /// </summary>
    /// <param name="progress">Progress reporter for UI updates.</param>
    public ToolExecutionContextBuilder WithProgress(IProgress<ToolProgress> progress)
    {
        _progress = progress;
        return this;
    }

    /// <summary>
    /// Set the approval status.
    /// </summary>
    /// <param name="approved">Whether execution is approved.</param>
    public ToolExecutionContextBuilder WithApproval(bool approved = true)
    {
        _isApproved = approved;
        return this;
    }

    /// <summary>
    /// Set user-modified parameters.
    /// </summary>
    /// <param name="parameters">Modified parameters from approval dialog.</param>
    public ToolExecutionContextBuilder WithModifiedParameters(JsonElement parameters)
    {
        _modifiedParameters = parameters;
        return this;
    }

    /// <summary>
    /// Set user-modified parameters from an object.
    /// </summary>
    /// <param name="obj">Object to serialize as modified parameters.</param>
    public ToolExecutionContextBuilder WithModifiedParametersFromObject(object obj)
    {
        var json = JsonSerializer.Serialize(obj);
        using var doc = JsonDocument.Parse(json);
        _modifiedParameters = doc.RootElement.Clone();
        return this;
    }

    /// <summary>
    /// Add a metadata key-value pair.
    /// </summary>
    /// <param name="key">Metadata key.</param>
    /// <param name="value">Metadata value.</param>
    public ToolExecutionContextBuilder WithMetadata(string key, object value)
    {
        _metadata ??= new Dictionary<string, object>();
        _metadata[key] = value;
        return this;
    }

    /// <summary>
    /// Set multiple metadata values.
    /// </summary>
    /// <param name="metadata">Dictionary of metadata values.</param>
    public ToolExecutionContextBuilder WithMetadata(
        IReadOnlyDictionary<string, object> metadata)
    {
        _metadata = new Dictionary<string, object>(metadata);
        return this;
    }

    /// <summary>
    /// Set the start time (for testing or reconstruction).
    /// </summary>
    /// <param name="startedAt">Execution start time.</param>
    public ToolExecutionContextBuilder WithStartedAt(DateTime startedAt)
    {
        _startedAt = startedAt;
        return this;
    }

    /// <summary>
    /// Build the execution context.
    /// </summary>
    /// <returns>A configured ToolExecutionContext.</returns>
    /// <exception cref="InvalidOperationException">
    /// Thrown if required properties (Services) are not set.
    /// </exception>
    public ToolExecutionContext Build()
    {
        if (_services == null)
            throw new InvalidOperationException(
                "Services must be provided via WithServices()");

        return new ToolExecutionContext
        {
            ExecutionId = _executionId,
            SessionId = _sessionId,
            ToolId = _toolId,
            WorkspacePath = _workspacePath,
            Parameters = _parameters,
            Services = _services,
            CancellationToken = _cancellationToken,
            Progress = _progress,
            IsApproved = _isApproved,
            ModifiedParameters = _modifiedParameters,
            Metadata = _metadata,
            StartedAt = _startedAt ?? DateTime.UtcNow
        };
    }

    /// <summary>
    /// Build with a mock service provider (for testing).
    /// </summary>
    /// <param name="services">Optional services to use.</param>
    /// <returns>A configured ToolExecutionContext.</returns>
    public ToolExecutionContext BuildForTesting(IServiceProvider? services = null)
    {
        return new ToolExecutionContext
        {
            ExecutionId = _executionId,
            SessionId = _sessionId,
            ToolId = _toolId,
            WorkspacePath = _workspacePath,
            Parameters = _parameters,
            Services = services ?? new EmptyServiceProvider(),
            CancellationToken = _cancellationToken,
            Progress = _progress,
            IsApproved = _isApproved,
            ModifiedParameters = _modifiedParameters,
            Metadata = _metadata,
            StartedAt = _startedAt ?? DateTime.UtcNow
        };
    }

    /// <summary>
    /// Empty service provider for testing.
    /// </summary>
    private sealed class EmptyServiceProvider : IServiceProvider
    {
        public object? GetService(Type serviceType) => null;
    }
}
```

---

## File Summary

### Files to Create

| File | Location | Purpose |
|------|----------|---------|
| `ToolExecutionContext.cs` | `Core/Tools/` | Execution context model |
| `ToolProgress.cs` | `Core/Tools/` | Progress reporting model |
| `ToolExecutionContextBuilder.cs` | `Core/Tools/` | Fluent context builder |

### Files to Update

| File | Changes |
|------|---------|
| `ITool.cs` | Uses ToolExecutionContext (now fully defined) |
| `ToolTypes.cs` | Remove ToolExecutionContext forward declaration |

---

## Unit Test Plan

| Test | Description |
|------|-------------|
| `ToolExecutionContext_DefaultValues_Correct` | Default property values |
| `ToolExecutionContext_EffectiveParameters_UsesOriginal` | Original when no mods |
| `ToolExecutionContext_EffectiveParameters_UsesModified` | Modified when present |
| `ToolExecutionContext_ResolvePath_Absolute_ReturnsAsIs` | Absolute path passthrough |
| `ToolExecutionContext_ResolvePath_Relative_CombinesWithWorkspace` | Relative resolution |
| `ToolExecutionContext_ResolvePath_NoWorkspace_Throws` | Error without workspace |
| `ToolExecutionContext_IsPathInWorkspace_Inside_ReturnsTrue` | Path within workspace |
| `ToolExecutionContext_IsPathInWorkspace_Outside_ReturnsFalse` | Path outside workspace |
| `ToolExecutionContext_IsPathInWorkspace_NoWorkspace_ReturnsFalse` | No workspace |
| `ToolExecutionContext_GetRequiredString_Exists_ReturnsValue` | Get existing string |
| `ToolExecutionContext_GetRequiredString_Missing_Throws` | Missing throws |
| `ToolExecutionContext_GetOptionalString_Missing_ReturnsDefault` | Default for missing |
| `ToolExecutionContext_GetRequiredInt_Exists_ReturnsValue` | Get existing int |
| `ToolExecutionContext_GetOptionalBool_Missing_ReturnsDefault` | Default for missing |
| `ToolProgress_IsIndeterminate_NoPercent_ReturnsTrue` | Indeterminate check |
| `ToolProgress_IsIndeterminate_WithPercent_ReturnsFalse` | Determinate check |
| `ToolProgress_NormalizedProgress_FromPercent_Correct` | Normalize percent |
| `ToolProgress_NormalizedProgress_FromItems_Correct` | Normalize items |
| `ToolProgress_ProgressText_Percent_FormatsCorrectly` | Percent text |
| `ToolProgress_ProgressText_Items_FormatsCorrectly` | Items text |
| `ToolProgress_Items_CalculatesPercent` | Factory calculates % |
| `ToolProgress_Completed_IsFullProgress` | 100% check |
| `ToolExecutionContextBuilder_Build_RequiresServices` | Validation |
| `ToolExecutionContextBuilder_WithParametersFromObject_Serializes` | Object to JSON |
| `ToolExecutionContextBuilder_WithMetadata_Accumulates` | Multiple metadata |
| `ToolExecutionContextBuilder_BuildForTesting_AllowsNullServices` | Test helper |

**Total Tests**: 26

---

## Verification

```bash
# Build the core project
dotnet build src/AIntern.Core

# Run unit tests
dotnet test --filter "ToolExecutionContext|ToolProgress"

# Verify no compile errors
dotnet build src/AIntern.Core --no-incremental
```

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | ToolExecutionContext has all documented properties |
| AC-2 | EffectiveParameters returns modified when present |
| AC-3 | ResolvePath correctly handles relative paths |
| AC-4 | IsPathInWorkspace correctly detects inside/outside |
| AC-5 | Parameter helper methods work for all types |
| AC-6 | ToolProgress factory methods create correct instances |
| AC-7 | NormalizedProgress is always 0.0-1.0 |
| AC-8 | Builder validates required properties |
| AC-9 | BuildForTesting works without real services |
| AC-10 | ReportProgress is null-safe |

---

## Changelog Entry

```markdown
## v0.6.1b - Tool Execution Context

### Added
- `ToolExecutionContext` with:
  - ExecutionId, SessionId, ToolId for tracking
  - WorkspacePath with ResolvePath and IsPathInWorkspace
  - Parameters and ModifiedParameters with EffectiveParameters
  - IServiceProvider with GetRequiredService/GetService
  - CancellationToken and Progress reporting
  - Typed parameter getters (GetRequiredString, GetOptionalInt, etc.)
  - Metadata dictionary with GetMetadata helper

- `ToolProgress` with:
  - Message, PercentComplete, CurrentOperation
  - ItemsProcessed, TotalItems, EstimatedRemaining
  - IsIndeterminate, NormalizedProgress computed properties
  - ProgressText, RemainingText for display
  - Factory methods: Message, WithPercent, Items, Operation, Completed

- `ToolExecutionContextBuilder` with:
  - Fluent construction API
  - WithParameters, WithParametersFromObject, WithParametersFromJson
  - WithWorkspace, WithServices, WithCancellation
  - WithProgress, WithApproval, WithMetadata
  - BuildForTesting for unit tests
```

---

## Timeline Estimate

| Version | Estimated Effort |
|---------|------------------|
| v0.6.1b | 0.75 day |
