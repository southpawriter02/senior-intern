# Design Specification: AIntern v0.6.4 "Safety & Approval"

## Executive Summary

This document provides a comprehensive design specification for v0.6.4, which implements a robust permission and safety system for tool execution. This sub-version delivers the critical security layer that stands between the AI agent and potentially dangerous operations, including risk classification, policy-based permission management, user approval workflows, rate limiting, and comprehensive audit logging. This system ensures users maintain full control over what actions the AI can perform while providing a streamlined experience for low-risk operations.

### v0.6.4 Scope (from v0.6.0 Design Document)
- Permission system architecture with policy engine
- Risk classification for tool calls based on parameters
- Approval dialog UI with risk visualization
- Remember decisions (session and persistent)
- Audit logging with database storage
- Rate limiting for tool calls
- Protected paths and blocked command patterns
- Tool-specific permission overrides

---

## Sub-Part Breakdown

| Part | Name | Focus |
|------|------|-------|
| v0.6.4a | Permission Policy Models | PermissionPolicy, PolicyMode, overrides, blocked patterns |
| v0.6.4b | Risk Classification Engine | RiskClassifier, RiskFactor, pattern matching |
| v0.6.4c | Permission Check System | PermissionCheckResult, session cache, rate limiting |
| v0.6.4d | IPermissionManager Interface | Service contract, decision memory, policy updates |
| v0.6.4e | PermissionManager Implementation | Core permission logic, policy evaluation |
| v0.6.4f | Audit Log Models | AuditLogEntry, AuditDecision, query support |
| v0.6.4g | Audit Log Storage | Database schema, repository, retention |
| v0.6.4h | Approval Dialog UI | ToolApprovalDialog, risk visualization |
| v0.6.4i | Approval Dialog ViewModel | ToolApprovalViewModel, parameter editing |
| v0.6.4j | Testing Infrastructure | Unit tests, integration tests, security tests |

---

## v0.6.4a: Permission Policy Models

### Objective
Define the policy models that govern how permissions are evaluated, including global policy modes, risk thresholds, tool overrides, and security patterns.

### PermissionPolicy Class

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Comprehensive policy configuration for tool permissions.
/// Controls how the system decides whether to allow, block, or prompt for tool calls.
/// </summary>
public sealed class PermissionPolicy
{
    /// <summary>
    /// Global policy mode determining default behavior.
    /// </summary>
    public PolicyMode Mode { get; set; } = PolicyMode.AskForRisky;

    /// <summary>
    /// Risk level threshold for requiring approval.
    /// Tools at or above this level require explicit user approval.
    /// Only applies when Mode is AskForRisky.
    /// </summary>
    public RiskLevel ApprovalThreshold { get; set; } = RiskLevel.Medium;

    /// <summary>
    /// Tool-specific permission overrides.
    /// Key is the tool ID.
    /// </summary>
    public Dictionary<string, ToolPermissionOverride> ToolOverrides { get; set; } = new();

    /// <summary>
    /// Tools that are completely blocked and cannot be executed.
    /// Takes precedence over all other settings.
    /// </summary>
    public HashSet<string> BlockedTools { get; set; } = new();

    /// <summary>
    /// Tools that are always allowed without approval.
    /// Only applies when Mode is not Disabled.
    /// </summary>
    public HashSet<string> TrustedTools { get; set; } = new();

    /// <summary>
    /// Regex patterns for commands that are always blocked.
    /// Applied to terminal/command tools.
    /// </summary>
    public List<BlockedPattern> BlockedCommandPatterns { get; set; } = new()
    {
        new("rm -rf /", @"rm\s+-rf\s+/", "Recursive delete of root directory"),
        new("rm -rf ~", @"rm\s+-rf\s+~", "Recursive delete of home directory"),
        new("sudo rm", @"sudo\s+rm\s+-rf", "Sudo recursive delete"),
        new("Format drive", @"format\s+[a-zA-Z]:", "Windows drive format"),
        new("mkfs", @"mkfs\.", "Linux filesystem format"),
        new("Fork bomb", @":\(\)\{:\|:&\};:", "Fork bomb attack"),
        new("dd to device", @"dd\s+if=.*/dev/", "Direct disk write"),
        new("Write to block device", @">\s*/dev/sd[a-z]", "Write to block device"),
        new("chmod 777 /", @"chmod\s+(-R\s+)?777\s+/", "Dangerous permission change"),
        new("chown root /", @"chown\s+(-R\s+)?root\s+/", "Dangerous ownership change"),
    };

    /// <summary>
    /// Glob patterns for paths that require elevated approval.
    /// Operations on these paths are elevated to High risk.
    /// </summary>
    public List<ProtectedPath> ProtectedPaths { get; set; } = new()
    {
        new("~/.ssh/*", "SSH keys and configuration"),
        new("~/.aws/*", "AWS credentials"),
        new("~/.azure/*", "Azure credentials"),
        new("~/.config/gcloud/*", "Google Cloud credentials"),
        new("~/.kube/*", "Kubernetes configuration"),
        new("~/.docker/*", "Docker configuration"),
        new("**/.env", "Environment files"),
        new("**/.env.*", "Environment files"),
        new("**/secrets/**", "Secrets directory"),
        new("**/credentials*", "Credentials files"),
        new("**/*.pem", "Certificate files"),
        new("**/*.key", "Private key files"),
        new("**/id_rsa*", "SSH private keys"),
    };

    /// <summary>
    /// Maximum tool calls allowed per minute.
    /// Prevents runaway agent loops.
    /// </summary>
    public int RateLimitPerMinute { get; set; } = 30;

    /// <summary>
    /// Maximum tool calls allowed per hour.
    /// Additional safety limit.
    /// </summary>
    public int RateLimitPerHour { get; set; } = 300;

    /// <summary>
    /// Whether to log all tool executions to the audit log.
    /// </summary>
    public bool AuditAllExecutions { get; set; } = true;

    /// <summary>
    /// Whether to log denied/blocked tool calls.
    /// </summary>
    public bool AuditDeniedCalls { get; set; } = true;

    /// <summary>
    /// Number of days to retain audit logs.
    /// Set to 0 for indefinite retention.
    /// </summary>
    public int AuditRetentionDays { get; set; } = 30;

    /// <summary>
    /// Whether to show detailed parameters in approval dialogs.
    /// May be disabled for privacy.
    /// </summary>
    public bool ShowParametersInApproval { get; set; } = true;

    /// <summary>
    /// Timeout for user approval in seconds.
    /// Request is denied if not responded within this time.
    /// </summary>
    public int ApprovalTimeoutSeconds { get; set; } = 300; // 5 minutes

    /// <summary>
    /// Whether to allow editing parameters before approval.
    /// </summary>
    public bool AllowParameterEditing { get; set; } = true;

    /// <summary>
    /// Categories of tools that are disabled entirely.
    /// </summary>
    public HashSet<ToolCategory> DisabledCategories { get; set; } = new();
}
```

### PolicyMode Enum

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Global policy modes for tool permission handling.
/// </summary>
public enum PolicyMode
{
    /// <summary>
    /// All tool calls are blocked. Agent cannot execute any tools.
    /// Use when you want AI assistance without any system modifications.
    /// </summary>
    Disabled = 0,

    /// <summary>
    /// All tool calls require explicit user approval.
    /// Most secure mode - nothing happens without consent.
    /// </summary>
    AlwaysAsk = 1,

    /// <summary>
    /// Safe operations auto-approve, risky ones require approval.
    /// Recommended balance of security and convenience.
    /// </summary>
    AskForRisky = 2,

    /// <summary>
    /// All tool calls are automatically approved.
    /// DANGEROUS: Only use in fully trusted, isolated environments.
    /// </summary>
    AutoApprove = 3
}
```

### ToolPermissionOverride Class

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Override settings for a specific tool.
/// </summary>
public sealed class ToolPermissionOverride
{
    /// <summary>
    /// Tool ID this override applies to.
    /// </summary>
    public string ToolId { get; init; } = string.Empty;

    /// <summary>
    /// Action to take for this tool.
    /// </summary>
    public OverrideAction Action { get; init; } = OverrideAction.UseDefault;

    /// <summary>
    /// Custom risk level override.
    /// Only used when Action is UseDefault.
    /// </summary>
    public RiskLevel? CustomRiskLevel { get; init; }

    /// <summary>
    /// Reason for this override (for audit purposes).
    /// </summary>
    public string? Reason { get; init; }

    /// <summary>
    /// When this override was created.
    /// </summary>
    public DateTime CreatedAt { get; init; } = DateTime.UtcNow;

    /// <summary>
    /// Whether this override was set by the user or system.
    /// </summary>
    public bool IsUserDefined { get; init; } = true;
}

/// <summary>
/// Actions that can be taken for tool permission overrides.
/// </summary>
public enum OverrideAction
{
    /// <summary>
    /// Use default policy behavior.
    /// </summary>
    UseDefault = 0,

    /// <summary>
    /// Always allow without asking.
    /// </summary>
    AlwaysAllow = 1,

    /// <summary>
    /// Always ask for approval regardless of risk level.
    /// </summary>
    AlwaysAsk = 2,

    /// <summary>
    /// Block this tool entirely.
    /// </summary>
    Block = 3
}
```

### BlockedPattern Class

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// A pattern for blocking dangerous commands.
/// </summary>
public sealed class BlockedPattern
{
    /// <summary>
    /// Human-readable name for this pattern.
    /// </summary>
    public string Name { get; init; }

    /// <summary>
    /// Regex pattern to match against commands.
    /// </summary>
    public string Pattern { get; init; }

    /// <summary>
    /// Explanation of why this pattern is dangerous.
    /// </summary>
    public string Reason { get; init; }

    /// <summary>
    /// Whether this pattern is enabled.
    /// </summary>
    public bool IsEnabled { get; init; } = true;

    /// <summary>
    /// Whether this is a built-in pattern (cannot be deleted).
    /// </summary>
    public bool IsBuiltIn { get; init; } = true;

    public BlockedPattern(string name, string pattern, string reason)
    {
        Name = name;
        Pattern = pattern;
        Reason = reason;
    }
}
```

### ProtectedPath Class

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// A path pattern that requires elevated approval.
/// </summary>
public sealed class ProtectedPath
{
    /// <summary>
    /// Glob pattern to match against file paths.
    /// </summary>
    public string Pattern { get; init; }

    /// <summary>
    /// Description of what this path contains.
    /// </summary>
    public string Description { get; init; }

    /// <summary>
    /// Whether this protection is enabled.
    /// </summary>
    public bool IsEnabled { get; init; } = true;

    /// <summary>
    /// Whether this is a built-in protection (cannot be deleted).
    /// </summary>
    public bool IsBuiltIn { get; init; } = true;

    /// <summary>
    /// Risk level to apply when this path is matched.
    /// </summary>
    public RiskLevel ElevatedRiskLevel { get; init; } = RiskLevel.High;

    public ProtectedPath(string pattern, string description)
    {
        Pattern = pattern;
        Description = description;
    }
}
```

### Files to Create (v0.6.4a)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Models/PermissionPolicy.cs` | Policy configuration model |
| `src/SeniorIntern.Core/Models/PolicyMode.cs` | Policy mode enum |
| `src/SeniorIntern.Core/Models/ToolPermissionOverride.cs` | Tool override model |
| `src/SeniorIntern.Core/Models/BlockedPattern.cs` | Blocked pattern model |
| `src/SeniorIntern.Core/Models/ProtectedPath.cs` | Protected path model |

### Acceptance Criteria (v0.6.4a)
- [ ] PermissionPolicy captures all configuration options
- [ ] PolicyMode enum covers all use cases
- [ ] Built-in blocked patterns cover dangerous commands
- [ ] Protected paths include common credential locations
- [ ] Models are serializable for persistence

---

## v0.6.4b: Risk Classification Engine

### Objective
Implement the RiskClassifier that analyzes tool call requests and determines their effective risk level based on tool type, parameters, patterns, and policy overrides.

### RiskClassifier Class

```csharp
namespace SeniorIntern.Services.Permissions;

/// <summary>
/// Classifies the risk level of tool call requests.
/// Analyzes parameters, patterns, and policy to determine effective risk.
/// </summary>
public sealed class RiskClassifier
{
    private readonly PermissionPolicy _policy;
    private readonly ILogger<RiskClassifier> _logger;

    // Compiled regex cache for performance
    private readonly ConcurrentDictionary<string, Regex> _regexCache = new();

    public RiskClassifier(
        IOptions<PermissionPolicy> policy,
        ILogger<RiskClassifier> logger)
    {
        _policy = policy.Value;
        _logger = logger;
    }

    /// <summary>
    /// Classify the risk of a tool call request.
    /// </summary>
    public RiskClassificationResult Classify(ToolCallRequest request, ITool tool)
    {
        var factors = new List<RiskFactor>();
        var baseRisk = tool.DefaultRiskLevel;

        // Check if tool is blocked
        if (_policy.BlockedTools.Contains(tool.Id))
        {
            return RiskClassificationResult.Blocked(
                "Tool is blocked by policy",
                new RiskFactor("Blocked tool", RiskLevel.Critical));
        }

        // Check if category is disabled
        if (_policy.DisabledCategories.Contains(tool.Category))
        {
            return RiskClassificationResult.Blocked(
                $"Tool category '{tool.Category}' is disabled",
                new RiskFactor("Disabled category", RiskLevel.Critical));
        }

        // Check tool-specific override
        if (_policy.ToolOverrides.TryGetValue(tool.Id, out var toolOverride))
        {
            switch (toolOverride.Action)
            {
                case OverrideAction.Block:
                    return RiskClassificationResult.Blocked(
                        toolOverride.Reason ?? "Blocked by tool override",
                        new RiskFactor("Tool override: Block", RiskLevel.Critical));

                case OverrideAction.AlwaysAllow:
                    return new RiskClassificationResult
                    {
                        FinalRisk = RiskLevel.Safe,
                        IsBlocked = false,
                        IsTrusted = true,
                        Factors = new[] { new RiskFactor("Tool override: AlwaysAllow", RiskLevel.Safe) }
                    };

                case OverrideAction.AlwaysAsk:
                    factors.Add(new RiskFactor("Tool override: AlwaysAsk", RiskLevel.High));
                    baseRisk = RiskLevel.High;
                    break;

                case OverrideAction.UseDefault when toolOverride.CustomRiskLevel.HasValue:
                    baseRisk = toolOverride.CustomRiskLevel.Value;
                    factors.Add(new RiskFactor($"Custom risk level", baseRisk));
                    break;
            }
        }

        // Check if tool is trusted
        if (_policy.TrustedTools.Contains(tool.Id))
        {
            return new RiskClassificationResult
            {
                FinalRisk = RiskLevel.Safe,
                IsBlocked = false,
                IsTrusted = true,
                Factors = new[] { new RiskFactor("Trusted tool", RiskLevel.Safe) }
            };
        }

        // Analyze based on tool category
        switch (tool.Category)
        {
            case ToolCategory.Terminal:
                var terminalResult = ClassifyTerminalCommand(request, factors);
                if (terminalResult.IsBlocked)
                    return terminalResult;
                baseRisk = (RiskLevel)Math.Max((int)baseRisk, (int)terminalResult.FinalRisk);
                break;

            case ToolCategory.FileSystem:
                var fileResult = ClassifyFileOperation(request, tool, factors);
                if (fileResult.IsBlocked)
                    return fileResult;
                baseRisk = (RiskLevel)Math.Max((int)baseRisk, (int)fileResult.FinalRisk);
                break;

            case ToolCategory.Git:
                var gitResult = ClassifyGitOperation(request, factors);
                baseRisk = (RiskLevel)Math.Max((int)baseRisk, (int)gitResult.FinalRisk);
                break;

            case ToolCategory.Network:
                var networkResult = ClassifyNetworkOperation(request, factors);
                baseRisk = (RiskLevel)Math.Max((int)baseRisk, (int)networkResult.FinalRisk);
                break;
        }

        // Get effective risk from tool based on specific parameters
        var toolEffectiveRisk = tool.GetEffectiveRiskLevel(request.Parameters);
        if (toolEffectiveRisk > baseRisk)
        {
            baseRisk = toolEffectiveRisk;
            factors.Add(new RiskFactor("Tool parameter analysis", toolEffectiveRisk));
        }

        return new RiskClassificationResult
        {
            FinalRisk = baseRisk,
            IsBlocked = false,
            Factors = factors
        };
    }

    private RiskClassificationResult ClassifyTerminalCommand(
        ToolCallRequest request, List<RiskFactor> factors)
    {
        if (!request.Parameters.TryGetProperty("command", out var cmdProp))
            return new RiskClassificationResult { FinalRisk = RiskLevel.High };

        var command = cmdProp.GetString() ?? "";

        // Check blocked patterns
        foreach (var blocked in _policy.BlockedCommandPatterns.Where(p => p.IsEnabled))
        {
            var regex = GetOrCreateRegex(blocked.Pattern);
            if (regex.IsMatch(command))
            {
                _logger.LogWarning(
                    "Blocked dangerous command pattern: {Pattern} in command: {Command}",
                    blocked.Name, TruncateForLog(command));

                return RiskClassificationResult.Blocked(
                    $"Command matches blocked pattern: {blocked.Name}. {blocked.Reason}",
                    new RiskFactor(blocked.Name, RiskLevel.Critical));
            }
        }

        var risk = RiskLevel.High; // Terminal commands are high risk by default

        // Analyze specific command patterns
        var commandLower = command.ToLowerInvariant();

        // Sudo/admin commands
        if (commandLower.StartsWith("sudo ") || commandLower.Contains(" sudo "))
        {
            risk = RiskLevel.Critical;
            factors.Add(new RiskFactor("Sudo/admin command", RiskLevel.Critical));
        }

        // Package installation
        if (Regex.IsMatch(command, @"\b(npm|pip|gem|cargo|apt|yum|brew)\s+(install|add)\b", RegexOptions.IgnoreCase))
        {
            factors.Add(new RiskFactor("Package installation", RiskLevel.High));
        }

        // Git push
        if (commandLower.Contains("git push"))
        {
            factors.Add(new RiskFactor("Git push to remote", RiskLevel.High));
            if (commandLower.Contains("--force") || commandLower.Contains("-f"))
            {
                risk = RiskLevel.Critical;
                factors.Add(new RiskFactor("Force push", RiskLevel.Critical));
            }
        }

        // Network commands
        if (Regex.IsMatch(command, @"\b(curl|wget|nc|netcat|ssh|scp)\b", RegexOptions.IgnoreCase))
        {
            factors.Add(new RiskFactor("Network command", RiskLevel.High));
        }

        // File deletion
        if (Regex.IsMatch(command, @"\brm\b.*-[rf]", RegexOptions.IgnoreCase))
        {
            factors.Add(new RiskFactor("File deletion with flags", RiskLevel.High));
        }

        return new RiskClassificationResult { FinalRisk = risk, Factors = factors };
    }

    private RiskClassificationResult ClassifyFileOperation(
        ToolCallRequest request, ITool tool, List<RiskFactor> factors)
    {
        var path = request.Parameters.TryGetProperty("path", out var p)
            ? p.GetString()
            : request.Parameters.TryGetProperty("source", out var s)
                ? s.GetString()
                : null;

        if (string.IsNullOrEmpty(path))
            return new RiskClassificationResult { FinalRisk = tool.DefaultRiskLevel };

        var risk = tool.DefaultRiskLevel;

        // Check protected paths
        foreach (var protectedPath in _policy.ProtectedPaths.Where(pp => pp.IsEnabled))
        {
            if (MatchesGlobPattern(path, protectedPath.Pattern))
            {
                factors.Add(new RiskFactor(
                    $"Protected path: {protectedPath.Description}",
                    protectedPath.ElevatedRiskLevel));

                risk = (RiskLevel)Math.Max((int)risk, (int)protectedPath.ElevatedRiskLevel);
            }
        }

        // Check for write operations to sensitive extensions
        if (tool.Id is "file-write" or "file-patch" or "file-delete")
        {
            var extension = Path.GetExtension(path).ToLowerInvariant();
            var sensitiveExtensions = new[] { ".pem", ".key", ".crt", ".pfx", ".p12" };

            if (sensitiveExtensions.Contains(extension))
            {
                factors.Add(new RiskFactor("Sensitive file extension", RiskLevel.High));
                risk = (RiskLevel)Math.Max((int)risk, (int)RiskLevel.High);
            }
        }

        // Check for operations outside workspace
        // (This would be validated elsewhere, but flag as critical if detected)

        return new RiskClassificationResult { FinalRisk = risk, Factors = factors };
    }

    private RiskClassificationResult ClassifyGitOperation(
        ToolCallRequest request, List<RiskFactor> factors)
    {
        var risk = RiskLevel.Safe; // Most git operations are read-only

        // Git operations that modify remote
        if (request.ToolId is "git-push" or "git-force-push")
        {
            risk = RiskLevel.High;
            factors.Add(new RiskFactor("Git push operation", RiskLevel.High));
        }

        // Git operations that modify history
        if (request.ToolId is "git-rebase" or "git-reset")
        {
            risk = RiskLevel.High;
            factors.Add(new RiskFactor("Git history modification", RiskLevel.High));
        }

        return new RiskClassificationResult { FinalRisk = risk, Factors = factors };
    }

    private RiskClassificationResult ClassifyNetworkOperation(
        ToolCallRequest request, List<RiskFactor> factors)
    {
        factors.Add(new RiskFactor("Network operation", RiskLevel.Medium));
        return new RiskClassificationResult { FinalRisk = RiskLevel.Medium, Factors = factors };
    }

    private bool MatchesGlobPattern(string path, string pattern)
    {
        // Expand ~ to home directory
        var expandedPattern = pattern.Replace("~", Environment.GetFolderPath(Environment.SpecialFolder.UserProfile));

        // Convert glob to regex
        var regexPattern = "^" + Regex.Escape(expandedPattern)
            .Replace(@"\*\*", ".*")
            .Replace(@"\*", "[^/\\\\]*")
            .Replace(@"\?", ".")
            + "$";

        var regex = GetOrCreateRegex(regexPattern);
        return regex.IsMatch(path) || regex.IsMatch(Path.GetFullPath(path));
    }

    private Regex GetOrCreateRegex(string pattern)
    {
        return _regexCache.GetOrAdd(pattern, p =>
            new Regex(p, RegexOptions.Compiled | RegexOptions.IgnoreCase));
    }

    private static string TruncateForLog(string value, int maxLength = 100)
    {
        return value.Length <= maxLength ? value : value[..(maxLength - 3)] + "...";
    }
}
```

### RiskClassificationResult Class

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Result of risk classification for a tool call.
/// </summary>
public sealed class RiskClassificationResult
{
    /// <summary>
    /// Final calculated risk level.
    /// </summary>
    public RiskLevel FinalRisk { get; init; }

    /// <summary>
    /// Whether the operation is blocked entirely.
    /// </summary>
    public bool IsBlocked { get; init; }

    /// <summary>
    /// Reason for blocking (if blocked).
    /// </summary>
    public string? BlockReason { get; init; }

    /// <summary>
    /// Whether this tool is trusted (auto-approved).
    /// </summary>
    public bool IsTrusted { get; init; }

    /// <summary>
    /// Factors that contributed to the risk assessment.
    /// </summary>
    public IReadOnlyList<RiskFactor> Factors { get; init; } = Array.Empty<RiskFactor>();

    /// <summary>
    /// Create a blocked result.
    /// </summary>
    public static RiskClassificationResult Blocked(string reason, params RiskFactor[] factors) => new()
    {
        FinalRisk = RiskLevel.Critical,
        IsBlocked = true,
        BlockReason = reason,
        Factors = factors
    };
}

/// <summary>
/// A factor contributing to risk assessment.
/// </summary>
public sealed record RiskFactor
{
    /// <summary>
    /// Description of this risk factor.
    /// </summary>
    public string Description { get; init; }

    /// <summary>
    /// Risk level contribution of this factor.
    /// </summary>
    public RiskLevel Contribution { get; init; }

    public RiskFactor(string description, RiskLevel contribution)
    {
        Description = description;
        Contribution = contribution;
    }
}
```

### Files to Create (v0.6.4b)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Services/Permissions/RiskClassifier.cs` | Risk classification logic |
| `src/SeniorIntern.Core/Models/RiskClassificationResult.cs` | Classification result model |
| `src/SeniorIntern.Core/Models/RiskFactor.cs` | Risk factor model |

### Acceptance Criteria (v0.6.4b)
- [ ] RiskClassifier evaluates all policy rules
- [ ] Blocked patterns are detected and blocked
- [ ] Protected paths elevate risk level
- [ ] Tool overrides are respected
- [ ] Terminal commands are analyzed for dangerous patterns
- [ ] Regex patterns are cached for performance

---

## v0.6.4c: Permission Check System

### Objective
Implement the permission checking system that combines risk classification with session caching and rate limiting to determine if a tool call can proceed.

### PermissionCheckResult Class

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Result of checking permissions for a tool call.
/// </summary>
public sealed class PermissionCheckResult
{
    /// <summary>
    /// Whether the tool call is allowed to proceed.
    /// </summary>
    public bool IsAllowed { get; init; }

    /// <summary>
    /// Whether explicit user approval is required.
    /// </summary>
    public bool RequiresApproval { get; init; }

    /// <summary>
    /// Whether the tool call is completely blocked.
    /// </summary>
    public bool IsBlocked { get; init; }

    /// <summary>
    /// Reason for the decision.
    /// </summary>
    public string? Reason { get; init; }

    /// <summary>
    /// Reason for blocking (if blocked).
    /// </summary>
    public string? BlockReason { get; init; }

    /// <summary>
    /// Effective risk level for this call.
    /// </summary>
    public RiskLevel EffectiveRiskLevel { get; init; }

    /// <summary>
    /// Risk factors identified.
    /// </summary>
    public IReadOnlyList<RiskFactor> RiskFactors { get; init; } = Array.Empty<RiskFactor>();

    /// <summary>
    /// Whether this decision came from cache.
    /// </summary>
    public bool WasCached { get; init; }

    /// <summary>
    /// Whether rate limit was exceeded.
    /// </summary>
    public bool IsRateLimited { get; init; }

    /// <summary>
    /// Source of the permission decision.
    /// </summary>
    public PermissionSource Source { get; init; }

    /// <summary>
    /// Create an allowed result.
    /// </summary>
    public static PermissionCheckResult Allowed(
        RiskLevel riskLevel,
        PermissionSource source,
        string? reason = null) => new()
    {
        IsAllowed = true,
        RequiresApproval = false,
        IsBlocked = false,
        Reason = reason,
        EffectiveRiskLevel = riskLevel,
        Source = source
    };

    /// <summary>
    /// Create a requires-approval result.
    /// </summary>
    public static PermissionCheckResult NeedsApproval(
        RiskLevel riskLevel,
        IReadOnlyList<RiskFactor> factors,
        string? reason = null) => new()
    {
        IsAllowed = false,
        RequiresApproval = true,
        IsBlocked = false,
        Reason = reason ?? $"Tool requires approval (risk level: {riskLevel})",
        EffectiveRiskLevel = riskLevel,
        RiskFactors = factors,
        Source = PermissionSource.Policy
    };

    /// <summary>
    /// Create a blocked result.
    /// </summary>
    public static PermissionCheckResult Blocked(string reason, RiskLevel riskLevel = RiskLevel.Critical) => new()
    {
        IsAllowed = false,
        RequiresApproval = false,
        IsBlocked = true,
        BlockReason = reason,
        EffectiveRiskLevel = riskLevel,
        Source = PermissionSource.Policy
    };

    /// <summary>
    /// Create a rate-limited result.
    /// </summary>
    public static PermissionCheckResult RateLimited(string reason) => new()
    {
        IsAllowed = false,
        RequiresApproval = false,
        IsBlocked = true,
        IsRateLimited = true,
        BlockReason = reason,
        EffectiveRiskLevel = RiskLevel.Medium,
        Source = PermissionSource.RateLimit
    };
}

/// <summary>
/// Source of a permission decision.
/// </summary>
public enum PermissionSource
{
    /// <summary>
    /// Decision based on policy rules.
    /// </summary>
    Policy,

    /// <summary>
    /// Decision from session cache (remembered for session).
    /// </summary>
    SessionCache,

    /// <summary>
    /// Decision from persistent storage (always allow/deny).
    /// </summary>
    Persistent,

    /// <summary>
    /// Decision from tool trusted list.
    /// </summary>
    TrustedTool,

    /// <summary>
    /// Blocked by rate limiter.
    /// </summary>
    RateLimit
}
```

### RateLimiter Class

```csharp
namespace SeniorIntern.Services.Permissions;

/// <summary>
/// Tracks and enforces rate limits for tool calls.
/// </summary>
public sealed class RateLimiter
{
    private readonly PermissionPolicy _policy;
    private readonly ConcurrentQueue<DateTime> _recentCalls = new();
    private readonly ILogger<RateLimiter> _logger;

    public RateLimiter(
        IOptions<PermissionPolicy> policy,
        ILogger<RateLimiter> logger)
    {
        _policy = policy.Value;
        _logger = logger;
    }

    /// <summary>
    /// Check if a tool call is within rate limits.
    /// </summary>
    public RateLimitResult CheckLimit()
    {
        var now = DateTime.UtcNow;
        CleanupOldEntries(now);

        // Check per-minute limit
        var callsInLastMinute = _recentCalls.Count(c => c > now.AddMinutes(-1));
        if (callsInLastMinute >= _policy.RateLimitPerMinute)
        {
            _logger.LogWarning("Rate limit exceeded: {Count}/{Limit} calls per minute",
                callsInLastMinute, _policy.RateLimitPerMinute);

            return new RateLimitResult
            {
                IsAllowed = false,
                Reason = $"Rate limit exceeded: {callsInLastMinute}/{_policy.RateLimitPerMinute} calls per minute",
                RetryAfter = TimeSpan.FromSeconds(60 - (now - _recentCalls.First(c => c > now.AddMinutes(-1))).TotalSeconds)
            };
        }

        // Check per-hour limit
        var callsInLastHour = _recentCalls.Count(c => c > now.AddHours(-1));
        if (callsInLastHour >= _policy.RateLimitPerHour)
        {
            _logger.LogWarning("Hourly rate limit exceeded: {Count}/{Limit} calls per hour",
                callsInLastHour, _policy.RateLimitPerHour);

            return new RateLimitResult
            {
                IsAllowed = false,
                Reason = $"Hourly rate limit exceeded: {callsInLastHour}/{_policy.RateLimitPerHour} calls per hour",
                RetryAfter = TimeSpan.FromMinutes(60)
            };
        }

        return new RateLimitResult
        {
            IsAllowed = true,
            CallsInLastMinute = callsInLastMinute,
            CallsInLastHour = callsInLastHour
        };
    }

    /// <summary>
    /// Record a tool call for rate limiting.
    /// </summary>
    public void RecordCall()
    {
        _recentCalls.Enqueue(DateTime.UtcNow);
    }

    private void CleanupOldEntries(DateTime now)
    {
        var cutoff = now.AddHours(-1);
        while (_recentCalls.TryPeek(out var oldest) && oldest < cutoff)
        {
            _recentCalls.TryDequeue(out _);
        }
    }

    /// <summary>
    /// Get current rate limit status.
    /// </summary>
    public RateLimitStatus GetStatus()
    {
        var now = DateTime.UtcNow;
        CleanupOldEntries(now);

        return new RateLimitStatus
        {
            CallsInLastMinute = _recentCalls.Count(c => c > now.AddMinutes(-1)),
            CallsInLastHour = _recentCalls.Count(c => c > now.AddHours(-1)),
            LimitPerMinute = _policy.RateLimitPerMinute,
            LimitPerHour = _policy.RateLimitPerHour
        };
    }
}

/// <summary>
/// Result of a rate limit check.
/// </summary>
public sealed class RateLimitResult
{
    public bool IsAllowed { get; init; }
    public string? Reason { get; init; }
    public TimeSpan? RetryAfter { get; init; }
    public int CallsInLastMinute { get; init; }
    public int CallsInLastHour { get; init; }
}

/// <summary>
/// Current rate limit status.
/// </summary>
public sealed class RateLimitStatus
{
    public int CallsInLastMinute { get; init; }
    public int CallsInLastHour { get; init; }
    public int LimitPerMinute { get; init; }
    public int LimitPerHour { get; init; }

    public double MinuteUsagePercent => LimitPerMinute > 0
        ? (double)CallsInLastMinute / LimitPerMinute * 100 : 0;

    public double HourUsagePercent => LimitPerHour > 0
        ? (double)CallsInLastHour / LimitPerHour * 100 : 0;
}
```

### SessionPermissionCache Class

```csharp
namespace SeniorIntern.Services.Permissions;

/// <summary>
/// Caches permission decisions for the current session.
/// </summary>
public sealed class SessionPermissionCache
{
    private readonly ConcurrentDictionary<string, CachedDecision> _cache = new();

    /// <summary>
    /// Try to get a cached decision for a tool.
    /// </summary>
    public bool TryGetDecision(string toolId, out CachedDecision? decision)
    {
        return _cache.TryGetValue(toolId, out decision);
    }

    /// <summary>
    /// Cache a decision for a tool.
    /// </summary>
    public void CacheDecision(string toolId, ApprovalDecision decision)
    {
        _cache[toolId] = new CachedDecision
        {
            ToolId = toolId,
            Decision = decision,
            CachedAt = DateTime.UtcNow
        };
    }

    /// <summary>
    /// Clear all cached decisions.
    /// </summary>
    public void Clear()
    {
        _cache.Clear();
    }

    /// <summary>
    /// Clear cached decision for a specific tool.
    /// </summary>
    public void Clear(string toolId)
    {
        _cache.TryRemove(toolId, out _);
    }

    /// <summary>
    /// Get all cached decisions.
    /// </summary>
    public IReadOnlyList<CachedDecision> GetAll()
    {
        return _cache.Values.ToList();
    }
}

/// <summary>
/// A cached permission decision.
/// </summary>
public sealed class CachedDecision
{
    public string ToolId { get; init; } = string.Empty;
    public ApprovalDecision Decision { get; init; } = null!;
    public DateTime CachedAt { get; init; }
}
```

### Files to Create (v0.6.4c)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Models/PermissionCheckResult.cs` | Check result model |
| `src/SeniorIntern.Core/Models/PermissionSource.cs` | Permission source enum |
| `src/SeniorIntern.Services/Permissions/RateLimiter.cs` | Rate limiting logic |
| `src/SeniorIntern.Services/Permissions/SessionPermissionCache.cs` | Session cache |

### Acceptance Criteria (v0.6.4c)
- [ ] PermissionCheckResult captures all decision information
- [ ] RateLimiter tracks per-minute and per-hour limits
- [ ] SessionPermissionCache stores remembered decisions
- [ ] Rate limit status is queryable
- [ ] Cache can be cleared per-tool or entirely

---

## v0.6.4d: IPermissionManager Interface

### Objective
Define the comprehensive interface for the permission management system, including permission checking, approval handling, policy management, and audit log access.

### IPermissionManager Interface

```csharp
namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Manages permissions for tool execution.
/// Handles risk classification, approval workflows, and decision caching.
/// </summary>
public interface IPermissionManager
{
    /// <summary>
    /// Check if a tool call is allowed, requires approval, or is blocked.
    /// </summary>
    /// <param name="request">The tool call request to check</param>
    /// <param name="tool">The tool being invoked</param>
    /// <returns>Permission check result</returns>
    Task<PermissionCheckResult> CheckPermissionAsync(
        ToolCallRequest request,
        ITool tool);

    /// <summary>
    /// Request approval from the user for a tool call.
    /// Returns when user approves, denies, or timeout occurs.
    /// </summary>
    /// <param name="request">The tool call request</param>
    /// <param name="classificationResult">Risk classification result</param>
    /// <param name="ct">Cancellation token</param>
    /// <returns>User's approval decision</returns>
    Task<ApprovalDecision> RequestApprovalAsync(
        ToolCallRequest request,
        RiskClassificationResult classificationResult,
        CancellationToken ct = default);

    /// <summary>
    /// Remember a user's approval decision for future calls.
    /// </summary>
    /// <param name="toolId">Tool ID</param>
    /// <param name="decision">The decision to remember</param>
    Task RememberDecisionAsync(string toolId, ApprovalDecision decision);

    /// <summary>
    /// Clear remembered decisions.
    /// </summary>
    /// <param name="toolId">Optional tool ID to clear; null clears all</param>
    Task ClearRememberedDecisionsAsync(string? toolId = null);

    /// <summary>
    /// Get the current permission policy.
    /// </summary>
    PermissionPolicy GetPolicy();

    /// <summary>
    /// Update the permission policy.
    /// </summary>
    /// <param name="policy">New policy settings</param>
    Task UpdatePolicyAsync(PermissionPolicy policy);

    /// <summary>
    /// Record a tool execution in the audit log.
    /// </summary>
    /// <param name="entry">Audit log entry</param>
    Task RecordAuditAsync(AuditLogEntry entry);

    /// <summary>
    /// Query the audit log.
    /// </summary>
    /// <param name="query">Query parameters</param>
    /// <param name="ct">Cancellation token</param>
    /// <returns>Matching audit log entries</returns>
    Task<IReadOnlyList<AuditLogEntry>> GetAuditLogAsync(
        AuditLogQuery? query = null,
        CancellationToken ct = default);

    /// <summary>
    /// Get current rate limit status.
    /// </summary>
    RateLimitStatus GetRateLimitStatus();

    /// <summary>
    /// Event fired when approval is needed.
    /// UI should subscribe to show approval dialog.
    /// </summary>
    event EventHandler<ApprovalRequestedEventArgs>? ApprovalRequested;

    /// <summary>
    /// Event fired when policy changes.
    /// </summary>
    event EventHandler<PolicyChangedEventArgs>? PolicyChanged;
}
```

### ApprovalRequestedEventArgs Class

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Event arguments when approval is requested.
/// </summary>
public sealed class ApprovalRequestedEventArgs : EventArgs
{
    /// <summary>
    /// Unique ID for this approval request.
    /// </summary>
    public Guid RequestId { get; init; }

    /// <summary>
    /// The tool call request.
    /// </summary>
    public ToolCallRequest ToolRequest { get; init; } = null!;

    /// <summary>
    /// The tool being invoked.
    /// </summary>
    public ITool Tool { get; init; } = null!;

    /// <summary>
    /// Risk classification result.
    /// </summary>
    public RiskClassificationResult Classification { get; init; } = null!;

    /// <summary>
    /// Task completion source for the approval decision.
    /// UI should call SetResult with the decision.
    /// </summary>
    public TaskCompletionSource<ApprovalDecision> DecisionTask { get; init; } = new();

    /// <summary>
    /// Timeout for the approval.
    /// </summary>
    public TimeSpan Timeout { get; init; }

    /// <summary>
    /// When the request was created.
    /// </summary>
    public DateTime RequestedAt { get; init; } = DateTime.UtcNow;
}
```

### PolicyChangedEventArgs Class

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Event arguments when policy changes.
/// </summary>
public sealed class PolicyChangedEventArgs : EventArgs
{
    /// <summary>
    /// The previous policy.
    /// </summary>
    public PermissionPolicy OldPolicy { get; init; } = null!;

    /// <summary>
    /// The new policy.
    /// </summary>
    public PermissionPolicy NewPolicy { get; init; } = null!;

    /// <summary>
    /// What aspects of the policy changed.
    /// </summary>
    public PolicyChangeType ChangeType { get; init; }
}

/// <summary>
/// Types of policy changes.
/// </summary>
[Flags]
public enum PolicyChangeType
{
    None = 0,
    Mode = 1,
    Threshold = 2,
    ToolOverrides = 4,
    BlockedPatterns = 8,
    ProtectedPaths = 16,
    RateLimits = 32,
    Other = 64
}
```

### Files to Create (v0.6.4d)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/IPermissionManager.cs` | Permission manager interface |
| `src/SeniorIntern.Core/Models/ApprovalRequestedEventArgs.cs` | Approval event args |
| `src/SeniorIntern.Core/Models/PolicyChangedEventArgs.cs` | Policy change event args |

### Acceptance Criteria (v0.6.4d)
- [ ] IPermissionManager defines complete contract
- [ ] Approval workflow is event-based for UI integration
- [ ] Policy updates notify subscribers
- [ ] Audit log access is async and queryable

---

## v0.6.4e: PermissionManager Implementation

### Objective
Implement the core permission management service that integrates risk classification, session caching, rate limiting, and policy evaluation.

### PermissionManager Class

```csharp
namespace SeniorIntern.Services.Permissions;

/// <summary>
/// Implementation of the permission management system.
/// </summary>
public sealed class PermissionManager : IPermissionManager, IDisposable
{
    private readonly RiskClassifier _riskClassifier;
    private readonly RateLimiter _rateLimiter;
    private readonly SessionPermissionCache _sessionCache;
    private readonly IAuditLogRepository _auditRepository;
    private readonly ISettingsService _settingsService;
    private readonly ILogger<PermissionManager> _logger;

    private PermissionPolicy _policy;
    private readonly SemaphoreSlim _policyLock = new(1, 1);

    public event EventHandler<ApprovalRequestedEventArgs>? ApprovalRequested;
    public event EventHandler<PolicyChangedEventArgs>? PolicyChanged;

    public PermissionManager(
        RiskClassifier riskClassifier,
        RateLimiter rateLimiter,
        SessionPermissionCache sessionCache,
        IAuditLogRepository auditRepository,
        ISettingsService settingsService,
        ILogger<PermissionManager> logger)
    {
        _riskClassifier = riskClassifier;
        _rateLimiter = rateLimiter;
        _sessionCache = sessionCache;
        _auditRepository = auditRepository;
        _settingsService = settingsService;
        _logger = logger;

        _policy = _settingsService.GetPermissionPolicy();
    }

    public async Task<PermissionCheckResult> CheckPermissionAsync(
        ToolCallRequest request, ITool tool)
    {
        _logger.LogDebug("Checking permission for tool: {ToolId}", tool.Id);

        // Check rate limit first
        var rateLimitResult = _rateLimiter.CheckLimit();
        if (!rateLimitResult.IsAllowed)
        {
            _logger.LogWarning("Rate limit exceeded for tool call: {ToolId}", tool.Id);
            return PermissionCheckResult.RateLimited(rateLimitResult.Reason!);
        }

        // Check policy mode
        if (_policy.Mode == PolicyMode.Disabled)
        {
            return PermissionCheckResult.Blocked("Tool execution is disabled");
        }

        // Classify risk
        var classification = _riskClassifier.Classify(request, tool);

        // Handle blocked tools
        if (classification.IsBlocked)
        {
            _logger.LogWarning("Tool call blocked: {ToolId} - {Reason}",
                tool.Id, classification.BlockReason);

            return PermissionCheckResult.Blocked(
                classification.BlockReason!,
                classification.FinalRisk);
        }

        // Handle trusted tools
        if (classification.IsTrusted)
        {
            _logger.LogDebug("Tool is trusted, auto-approving: {ToolId}", tool.Id);
            return PermissionCheckResult.Allowed(
                RiskLevel.Safe, PermissionSource.TrustedTool, "Trusted tool");
        }

        // Check session cache
        if (_sessionCache.TryGetDecision(tool.Id, out var cached) && cached!.Decision.Approved)
        {
            _logger.LogDebug("Using cached approval for tool: {ToolId}", tool.Id);
            return new PermissionCheckResult
            {
                IsAllowed = true,
                RequiresApproval = false,
                EffectiveRiskLevel = classification.FinalRisk,
                WasCached = true,
                Source = PermissionSource.SessionCache,
                Reason = "Approved earlier in session"
            };
        }

        // Check persistent overrides
        if (_policy.ToolOverrides.TryGetValue(tool.Id, out var toolOverride))
        {
            if (toolOverride.Action == OverrideAction.AlwaysAllow)
            {
                return PermissionCheckResult.Allowed(
                    classification.FinalRisk,
                    PermissionSource.Persistent,
                    "Always allowed by policy");
            }
        }

        // Apply policy mode
        switch (_policy.Mode)
        {
            case PolicyMode.AutoApprove:
                return PermissionCheckResult.Allowed(
                    classification.FinalRisk,
                    PermissionSource.Policy,
                    "Auto-approve mode enabled");

            case PolicyMode.AlwaysAsk:
                return PermissionCheckResult.NeedsApproval(
                    classification.FinalRisk,
                    classification.Factors,
                    "Always-ask mode enabled");

            case PolicyMode.AskForRisky:
                if (classification.FinalRisk >= _policy.ApprovalThreshold)
                {
                    return PermissionCheckResult.NeedsApproval(
                        classification.FinalRisk,
                        classification.Factors,
                        $"Risk level {classification.FinalRisk} >= threshold {_policy.ApprovalThreshold}");
                }
                else
                {
                    return PermissionCheckResult.Allowed(
                        classification.FinalRisk,
                        PermissionSource.Policy,
                        $"Risk level {classification.FinalRisk} < threshold {_policy.ApprovalThreshold}");
                }

            default:
                return PermissionCheckResult.Blocked("Unknown policy mode");
        }
    }

    public async Task<ApprovalDecision> RequestApprovalAsync(
        ToolCallRequest request,
        RiskClassificationResult classificationResult,
        CancellationToken ct = default)
    {
        var requestId = Guid.NewGuid();
        var tool = request; // Would need tool reference

        var eventArgs = new ApprovalRequestedEventArgs
        {
            RequestId = requestId,
            ToolRequest = request,
            Classification = classificationResult,
            Timeout = TimeSpan.FromSeconds(_policy.ApprovalTimeoutSeconds)
        };

        _logger.LogInformation(
            "Requesting approval for tool: {ToolId} (Risk: {Risk})",
            request.ToolId, classificationResult.FinalRisk);

        // Raise event for UI to handle
        ApprovalRequested?.Invoke(this, eventArgs);

        try
        {
            // Wait for decision with timeout
            using var timeoutCts = new CancellationTokenSource(eventArgs.Timeout);
            using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(ct, timeoutCts.Token);

            var decision = await eventArgs.DecisionTask.Task.WaitAsync(linkedCts.Token);

            _logger.LogInformation(
                "Approval decision for {ToolId}: {Approved} (Remember: Session={Session}, Tool={Tool})",
                request.ToolId, decision.Approved, decision.RememberForSession, decision.RememberForTool);

            return decision;
        }
        catch (OperationCanceledException) when (!ct.IsCancellationRequested)
        {
            _logger.LogWarning("Approval request timed out for tool: {ToolId}", request.ToolId);
            return new ApprovalDecision
            {
                Approved = false,
                Reason = "Approval timed out"
            };
        }
    }

    public async Task RememberDecisionAsync(string toolId, ApprovalDecision decision)
    {
        if (decision.RememberForSession)
        {
            _sessionCache.CacheDecision(toolId, decision);
            _logger.LogDebug("Cached decision for session: {ToolId}", toolId);
        }

        if (decision.RememberForTool)
        {
            await _policyLock.WaitAsync();
            try
            {
                var action = decision.Approved ? OverrideAction.AlwaysAllow : OverrideAction.Block;
                _policy.ToolOverrides[toolId] = new ToolPermissionOverride
                {
                    ToolId = toolId,
                    Action = action,
                    Reason = decision.Reason ?? (decision.Approved ? "User always allowed" : "User blocked"),
                    IsUserDefined = true
                };

                await _settingsService.SavePermissionPolicyAsync(_policy);
                _logger.LogInformation("Saved persistent permission for tool: {ToolId} -> {Action}", toolId, action);
            }
            finally
            {
                _policyLock.Release();
            }
        }
    }

    public async Task ClearRememberedDecisionsAsync(string? toolId = null)
    {
        if (toolId != null)
        {
            _sessionCache.Clear(toolId);

            await _policyLock.WaitAsync();
            try
            {
                if (_policy.ToolOverrides.Remove(toolId))
                {
                    await _settingsService.SavePermissionPolicyAsync(_policy);
                }
            }
            finally
            {
                _policyLock.Release();
            }
        }
        else
        {
            _sessionCache.Clear();

            await _policyLock.WaitAsync();
            try
            {
                _policy.ToolOverrides.Clear();
                await _settingsService.SavePermissionPolicyAsync(_policy);
            }
            finally
            {
                _policyLock.Release();
            }
        }
    }

    public PermissionPolicy GetPolicy() => _policy;

    public async Task UpdatePolicyAsync(PermissionPolicy policy)
    {
        await _policyLock.WaitAsync();
        try
        {
            var oldPolicy = _policy;
            _policy = policy;

            await _settingsService.SavePermissionPolicyAsync(policy);

            var changeType = DetermineChangeType(oldPolicy, policy);
            PolicyChanged?.Invoke(this, new PolicyChangedEventArgs
            {
                OldPolicy = oldPolicy,
                NewPolicy = policy,
                ChangeType = changeType
            });

            _logger.LogInformation("Permission policy updated: {ChangeType}", changeType);
        }
        finally
        {
            _policyLock.Release();
        }
    }

    public async Task RecordAuditAsync(AuditLogEntry entry)
    {
        if (!_policy.AuditAllExecutions && entry.Decision == AuditDecision.AutoApproved)
            return;

        if (!_policy.AuditDeniedCalls && entry.Decision is AuditDecision.UserDenied or AuditDecision.PolicyBlocked)
            return;

        await _auditRepository.AddAsync(entry);
        _rateLimiter.RecordCall();
    }

    public async Task<IReadOnlyList<AuditLogEntry>> GetAuditLogAsync(
        AuditLogQuery? query = null,
        CancellationToken ct = default)
    {
        return await _auditRepository.QueryAsync(query ?? new AuditLogQuery(), ct);
    }

    public RateLimitStatus GetRateLimitStatus() => _rateLimiter.GetStatus();

    private PolicyChangeType DetermineChangeType(PermissionPolicy oldPolicy, PermissionPolicy newPolicy)
    {
        var changes = PolicyChangeType.None;

        if (oldPolicy.Mode != newPolicy.Mode)
            changes |= PolicyChangeType.Mode;

        if (oldPolicy.ApprovalThreshold != newPolicy.ApprovalThreshold)
            changes |= PolicyChangeType.Threshold;

        if (!oldPolicy.ToolOverrides.SequenceEqual(newPolicy.ToolOverrides))
            changes |= PolicyChangeType.ToolOverrides;

        if (oldPolicy.RateLimitPerMinute != newPolicy.RateLimitPerMinute ||
            oldPolicy.RateLimitPerHour != newPolicy.RateLimitPerHour)
            changes |= PolicyChangeType.RateLimits;

        return changes == PolicyChangeType.None ? PolicyChangeType.Other : changes;
    }

    public void Dispose()
    {
        _policyLock.Dispose();
    }
}
```

### Files to Create (v0.6.4e)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Services/Permissions/PermissionManager.cs` | Permission manager implementation |

### Files to Modify (v0.6.4e)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Services/ServiceCollectionExtensions.cs` | Register permission services |
| `src/SeniorIntern.Core/Interfaces/ISettingsService.cs` | Add policy persistence methods |

### Acceptance Criteria (v0.6.4e)
- [ ] Permission checking integrates all components
- [ ] Session cache is checked before policy
- [ ] Rate limiting prevents excessive calls
- [ ] Approval events are raised for UI
- [ ] Decisions are persisted correctly
- [ ] Policy updates are saved and notify subscribers

---

## v0.6.4f: Audit Log Models

### Objective
Define the audit log entry model and query support for tracking all tool execution decisions and outcomes.

### AuditLogEntry Class

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// A single entry in the audit log.
/// Records tool execution decisions and outcomes.
/// </summary>
public sealed class AuditLogEntry
{
    /// <summary>
    /// Unique identifier for this entry.
    /// </summary>
    public Guid Id { get; init; } = Guid.NewGuid();

    /// <summary>
    /// When this event occurred.
    /// </summary>
    public DateTime Timestamp { get; init; } = DateTime.UtcNow;

    /// <summary>
    /// ID of the tool involved.
    /// </summary>
    public string ToolId { get; init; } = string.Empty;

    /// <summary>
    /// Display name of the tool.
    /// </summary>
    public string ToolName { get; init; } = string.Empty;

    /// <summary>
    /// Category of the tool.
    /// </summary>
    public ToolCategory ToolCategory { get; init; }

    /// <summary>
    /// Risk level at the time of the call.
    /// </summary>
    public RiskLevel RiskLevel { get; init; }

    /// <summary>
    /// Decision that was made.
    /// </summary>
    public AuditDecision Decision { get; init; }

    /// <summary>
    /// Reason for denial (if denied).
    /// </summary>
    public string? DenialReason { get; init; }

    /// <summary>
    /// Tool parameters (may be redacted for sensitive data).
    /// </summary>
    public JsonElement Parameters { get; init; }

    /// <summary>
    /// Human-readable summary of the operation.
    /// </summary>
    public string ExecutionSummary { get; init; } = string.Empty;

    /// <summary>
    /// Risk factors identified.
    /// </summary>
    public IReadOnlyList<RiskFactor>? RiskFactors { get; init; }

    /// <summary>
    /// Associated conversation ID.
    /// </summary>
    public Guid? ConversationId { get; init; }

    /// <summary>
    /// Request ID within the agent loop.
    /// </summary>
    public Guid? RequestId { get; init; }

    /// <summary>
    /// Source of the permission decision.
    /// </summary>
    public PermissionSource PermissionSource { get; init; }

    // Execution results (populated after execution)

    /// <summary>
    /// Whether execution succeeded (null if not executed).
    /// </summary>
    public bool? ExecutionSuccess { get; init; }

    /// <summary>
    /// Error message if execution failed.
    /// </summary>
    public string? ExecutionError { get; init; }

    /// <summary>
    /// How long execution took.
    /// </summary>
    public TimeSpan? ExecutionDuration { get; init; }

    /// <summary>
    /// Brief description of the result.
    /// </summary>
    public string? ResultSummary { get; init; }

    /// <summary>
    /// Create an entry for a permitted and executed tool call.
    /// </summary>
    public static AuditLogEntry ForExecution(
        ToolCallRequest request,
        ITool tool,
        RiskClassificationResult classification,
        PermissionSource source,
        ToolResult result,
        TimeSpan duration,
        Guid? conversationId = null) => new()
    {
        ToolId = tool.Id,
        ToolName = tool.Name,
        ToolCategory = tool.Category,
        RiskLevel = classification.FinalRisk,
        Decision = source switch
        {
            PermissionSource.TrustedTool => AuditDecision.AutoApproved,
            PermissionSource.SessionCache => AuditDecision.UserApproved,
            PermissionSource.Persistent => AuditDecision.UserApproved,
            PermissionSource.Policy when result.IsSuccess => AuditDecision.AutoApproved,
            _ => AuditDecision.UserApproved
        },
        Parameters = request.Parameters,
        ExecutionSummary = request.ExecutionSummary,
        RiskFactors = classification.Factors.ToList(),
        ConversationId = conversationId,
        RequestId = request.Id,
        PermissionSource = source,
        ExecutionSuccess = result.IsSuccess,
        ExecutionError = result.ErrorMessage,
        ExecutionDuration = duration,
        ResultSummary = result.Message
    };

    /// <summary>
    /// Create an entry for a denied tool call.
    /// </summary>
    public static AuditLogEntry ForDenial(
        ToolCallRequest request,
        ITool tool,
        RiskClassificationResult classification,
        string reason,
        bool wasBlocked,
        Guid? conversationId = null) => new()
    {
        ToolId = tool.Id,
        ToolName = tool.Name,
        ToolCategory = tool.Category,
        RiskLevel = classification.FinalRisk,
        Decision = wasBlocked ? AuditDecision.PolicyBlocked : AuditDecision.UserDenied,
        DenialReason = reason,
        Parameters = request.Parameters,
        ExecutionSummary = request.ExecutionSummary,
        RiskFactors = classification.Factors.ToList(),
        ConversationId = conversationId,
        RequestId = request.Id,
        PermissionSource = PermissionSource.Policy
    };
}
```

### AuditDecision Enum

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// The decision made for an audited tool call.
/// </summary>
public enum AuditDecision
{
    /// <summary>
    /// Automatically approved by policy (safe/trusted).
    /// </summary>
    AutoApproved = 0,

    /// <summary>
    /// Approved by user in approval dialog.
    /// </summary>
    UserApproved = 1,

    /// <summary>
    /// Denied by user in approval dialog.
    /// </summary>
    UserDenied = 2,

    /// <summary>
    /// Blocked by policy (blocked tool, pattern, or category).
    /// </summary>
    PolicyBlocked = 3,

    /// <summary>
    /// Blocked by rate limiter.
    /// </summary>
    RateLimited = 4,

    /// <summary>
    /// Error occurred during permission check.
    /// </summary>
    Error = 5
}
```

### AuditLogQuery Class

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Query parameters for searching the audit log.
/// </summary>
public sealed class AuditLogQuery
{
    /// <summary>
    /// Start of date range (inclusive).
    /// </summary>
    public DateTime? StartDate { get; init; }

    /// <summary>
    /// End of date range (exclusive).
    /// </summary>
    public DateTime? EndDate { get; init; }

    /// <summary>
    /// Filter by tool ID.
    /// </summary>
    public string? ToolId { get; init; }

    /// <summary>
    /// Filter by tool category.
    /// </summary>
    public ToolCategory? Category { get; init; }

    /// <summary>
    /// Filter by decision type.
    /// </summary>
    public AuditDecision? Decision { get; init; }

    /// <summary>
    /// Filter by minimum risk level.
    /// </summary>
    public RiskLevel? MinRiskLevel { get; init; }

    /// <summary>
    /// Filter by conversation ID.
    /// </summary>
    public Guid? ConversationId { get; init; }

    /// <summary>
    /// Only include failed executions.
    /// </summary>
    public bool? OnlyFailures { get; init; }

    /// <summary>
    /// Search in execution summary.
    /// </summary>
    public string? SearchText { get; init; }

    /// <summary>
    /// Number of entries to skip.
    /// </summary>
    public int Skip { get; init; }

    /// <summary>
    /// Maximum entries to return.
    /// </summary>
    public int Take { get; init; } = 100;

    /// <summary>
    /// Sort order.
    /// </summary>
    public AuditLogSortOrder SortOrder { get; init; } = AuditLogSortOrder.NewestFirst;
}

/// <summary>
/// Sort order for audit log queries.
/// </summary>
public enum AuditLogSortOrder
{
    NewestFirst,
    OldestFirst,
    RiskLevelDesc,
    DurationDesc
}
```

### Files to Create (v0.6.4f)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Models/AuditLogEntry.cs` | Audit entry model |
| `src/SeniorIntern.Core/Models/AuditDecision.cs` | Decision enum |
| `src/SeniorIntern.Core/Models/AuditLogQuery.cs` | Query model |

### Acceptance Criteria (v0.6.4f)
- [ ] AuditLogEntry captures all relevant information
- [ ] Factory methods simplify entry creation
- [ ] Query model supports comprehensive filtering
- [ ] Parameters can be stored as JSON

---

## v0.6.4g: Audit Log Storage

### Objective
Implement database schema and repository for persistent audit log storage with efficient querying and automatic retention management.

### Database Schema

```sql
-- Audit log table
CREATE TABLE AuditLog (
    Id TEXT PRIMARY KEY,
    Timestamp TEXT NOT NULL,
    ToolId TEXT NOT NULL,
    ToolName TEXT NOT NULL,
    ToolCategory INTEGER NOT NULL,
    RiskLevel INTEGER NOT NULL,
    Decision INTEGER NOT NULL,
    DenialReason TEXT,
    Parameters TEXT NOT NULL,
    ExecutionSummary TEXT NOT NULL,
    RiskFactorsJson TEXT,
    ConversationId TEXT,
    RequestId TEXT,
    PermissionSource INTEGER NOT NULL,
    ExecutionSuccess INTEGER,
    ExecutionError TEXT,
    ExecutionDurationMs INTEGER,
    ResultSummary TEXT
);

-- Indexes for common queries
CREATE INDEX IX_AuditLog_Timestamp ON AuditLog(Timestamp DESC);
CREATE INDEX IX_AuditLog_ToolId ON AuditLog(ToolId);
CREATE INDEX IX_AuditLog_Decision ON AuditLog(Decision);
CREATE INDEX IX_AuditLog_RiskLevel ON AuditLog(RiskLevel);
CREATE INDEX IX_AuditLog_ConversationId ON AuditLog(ConversationId);
CREATE INDEX IX_AuditLog_Timestamp_ToolId ON AuditLog(Timestamp DESC, ToolId);

-- Remembered decisions table
CREATE TABLE RememberedDecisions (
    ToolId TEXT PRIMARY KEY,
    Decision INTEGER NOT NULL,
    Reason TEXT,
    RememberedAt TEXT NOT NULL,
    ExpiresAt TEXT,
    IsUserDefined INTEGER NOT NULL DEFAULT 1
);
```

### AuditLogEntity Class

```csharp
namespace SeniorIntern.Data.Entities;

/// <summary>
/// Entity for storing audit log entries.
/// </summary>
public sealed class AuditLogEntity
{
    public string Id { get; set; } = string.Empty;
    public DateTime Timestamp { get; set; }
    public string ToolId { get; set; } = string.Empty;
    public string ToolName { get; set; } = string.Empty;
    public int ToolCategory { get; set; }
    public int RiskLevel { get; set; }
    public int Decision { get; set; }
    public string? DenialReason { get; set; }
    public string Parameters { get; set; } = "{}";
    public string ExecutionSummary { get; set; } = string.Empty;
    public string? RiskFactorsJson { get; set; }
    public string? ConversationId { get; set; }
    public string? RequestId { get; set; }
    public int PermissionSource { get; set; }
    public bool? ExecutionSuccess { get; set; }
    public string? ExecutionError { get; set; }
    public long? ExecutionDurationMs { get; set; }
    public string? ResultSummary { get; set; }

    public AuditLogEntry ToModel() => new()
    {
        Id = Guid.Parse(Id),
        Timestamp = Timestamp,
        ToolId = ToolId,
        ToolName = ToolName,
        ToolCategory = (ToolCategory)ToolCategory,
        RiskLevel = (RiskLevel)RiskLevel,
        Decision = (AuditDecision)Decision,
        DenialReason = DenialReason,
        Parameters = JsonDocument.Parse(Parameters).RootElement,
        ExecutionSummary = ExecutionSummary,
        RiskFactors = RiskFactorsJson != null
            ? JsonSerializer.Deserialize<List<RiskFactor>>(RiskFactorsJson)
            : null,
        ConversationId = ConversationId != null ? Guid.Parse(ConversationId) : null,
        RequestId = RequestId != null ? Guid.Parse(RequestId) : null,
        PermissionSource = (PermissionSource)PermissionSource,
        ExecutionSuccess = ExecutionSuccess,
        ExecutionError = ExecutionError,
        ExecutionDuration = ExecutionDurationMs.HasValue
            ? TimeSpan.FromMilliseconds(ExecutionDurationMs.Value)
            : null,
        ResultSummary = ResultSummary
    };

    public static AuditLogEntity FromModel(AuditLogEntry entry) => new()
    {
        Id = entry.Id.ToString(),
        Timestamp = entry.Timestamp,
        ToolId = entry.ToolId,
        ToolName = entry.ToolName,
        ToolCategory = (int)entry.ToolCategory,
        RiskLevel = (int)entry.RiskLevel,
        Decision = (int)entry.Decision,
        DenialReason = entry.DenialReason,
        Parameters = entry.Parameters.GetRawText(),
        ExecutionSummary = entry.ExecutionSummary,
        RiskFactorsJson = entry.RiskFactors != null
            ? JsonSerializer.Serialize(entry.RiskFactors)
            : null,
        ConversationId = entry.ConversationId?.ToString(),
        RequestId = entry.RequestId?.ToString(),
        PermissionSource = (int)entry.PermissionSource,
        ExecutionSuccess = entry.ExecutionSuccess,
        ExecutionError = entry.ExecutionError,
        ExecutionDurationMs = entry.ExecutionDuration.HasValue
            ? (long)entry.ExecutionDuration.Value.TotalMilliseconds
            : null,
        ResultSummary = entry.ResultSummary
    };
}
```

### IAuditLogRepository Interface

```csharp
namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Repository for audit log entries.
/// </summary>
public interface IAuditLogRepository
{
    /// <summary>
    /// Add a new audit log entry.
    /// </summary>
    Task AddAsync(AuditLogEntry entry);

    /// <summary>
    /// Query audit log entries.
    /// </summary>
    Task<IReadOnlyList<AuditLogEntry>> QueryAsync(
        AuditLogQuery query,
        CancellationToken ct = default);

    /// <summary>
    /// Get total count matching query.
    /// </summary>
    Task<int> CountAsync(AuditLogQuery query, CancellationToken ct = default);

    /// <summary>
    /// Delete entries older than specified date.
    /// </summary>
    Task<int> DeleteOlderThanAsync(DateTime date, CancellationToken ct = default);

    /// <summary>
    /// Get summary statistics.
    /// </summary>
    Task<AuditLogStatistics> GetStatisticsAsync(
        DateTime? since = null,
        CancellationToken ct = default);

    /// <summary>
    /// Export entries to file.
    /// </summary>
    Task ExportAsync(string filePath, AuditLogQuery? query = null, CancellationToken ct = default);
}

/// <summary>
/// Summary statistics for the audit log.
/// </summary>
public sealed class AuditLogStatistics
{
    public int TotalEntries { get; init; }
    public int AutoApprovedCount { get; init; }
    public int UserApprovedCount { get; init; }
    public int DeniedCount { get; init; }
    public int BlockedCount { get; init; }
    public int FailedExecutionsCount { get; init; }
    public Dictionary<string, int> ToolUsageCounts { get; init; } = new();
    public Dictionary<RiskLevel, int> RiskLevelCounts { get; init; } = new();
}
```

### AuditLogRepository Implementation

```csharp
namespace SeniorIntern.Data.Repositories;

/// <summary>
/// SQLite implementation of audit log repository.
/// </summary>
public sealed class AuditLogRepository : IAuditLogRepository
{
    private readonly AppDbContext _context;
    private readonly ILogger<AuditLogRepository> _logger;

    public AuditLogRepository(
        AppDbContext context,
        ILogger<AuditLogRepository> logger)
    {
        _context = context;
        _logger = logger;
    }

    public async Task AddAsync(AuditLogEntry entry)
    {
        var entity = AuditLogEntity.FromModel(entry);
        _context.AuditLog.Add(entity);
        await _context.SaveChangesAsync();
    }

    public async Task<IReadOnlyList<AuditLogEntry>> QueryAsync(
        AuditLogQuery query, CancellationToken ct = default)
    {
        var queryable = _context.AuditLog.AsQueryable();

        // Apply filters
        if (query.StartDate.HasValue)
            queryable = queryable.Where(e => e.Timestamp >= query.StartDate.Value);

        if (query.EndDate.HasValue)
            queryable = queryable.Where(e => e.Timestamp < query.EndDate.Value);

        if (query.ToolId != null)
            queryable = queryable.Where(e => e.ToolId == query.ToolId);

        if (query.Category.HasValue)
            queryable = queryable.Where(e => e.ToolCategory == (int)query.Category.Value);

        if (query.Decision.HasValue)
            queryable = queryable.Where(e => e.Decision == (int)query.Decision.Value);

        if (query.MinRiskLevel.HasValue)
            queryable = queryable.Where(e => e.RiskLevel >= (int)query.MinRiskLevel.Value);

        if (query.ConversationId.HasValue)
            queryable = queryable.Where(e => e.ConversationId == query.ConversationId.Value.ToString());

        if (query.OnlyFailures == true)
            queryable = queryable.Where(e => e.ExecutionSuccess == false);

        if (!string.IsNullOrEmpty(query.SearchText))
            queryable = queryable.Where(e => e.ExecutionSummary.Contains(query.SearchText));

        // Apply sorting
        queryable = query.SortOrder switch
        {
            AuditLogSortOrder.OldestFirst => queryable.OrderBy(e => e.Timestamp),
            AuditLogSortOrder.RiskLevelDesc => queryable.OrderByDescending(e => e.RiskLevel)
                .ThenByDescending(e => e.Timestamp),
            AuditLogSortOrder.DurationDesc => queryable.OrderByDescending(e => e.ExecutionDurationMs)
                .ThenByDescending(e => e.Timestamp),
            _ => queryable.OrderByDescending(e => e.Timestamp)
        };

        // Apply pagination
        var entities = await queryable
            .Skip(query.Skip)
            .Take(query.Take)
            .ToListAsync(ct);

        return entities.Select(e => e.ToModel()).ToList();
    }

    public async Task<int> CountAsync(AuditLogQuery query, CancellationToken ct = default)
    {
        var queryable = _context.AuditLog.AsQueryable();

        // Apply same filters as QueryAsync
        if (query.StartDate.HasValue)
            queryable = queryable.Where(e => e.Timestamp >= query.StartDate.Value);

        if (query.EndDate.HasValue)
            queryable = queryable.Where(e => e.Timestamp < query.EndDate.Value);

        // ... other filters ...

        return await queryable.CountAsync(ct);
    }

    public async Task<int> DeleteOlderThanAsync(DateTime date, CancellationToken ct = default)
    {
        var count = await _context.AuditLog
            .Where(e => e.Timestamp < date)
            .ExecuteDeleteAsync(ct);

        _logger.LogInformation("Deleted {Count} audit log entries older than {Date}", count, date);
        return count;
    }

    public async Task<AuditLogStatistics> GetStatisticsAsync(
        DateTime? since = null, CancellationToken ct = default)
    {
        var query = _context.AuditLog.AsQueryable();

        if (since.HasValue)
            query = query.Where(e => e.Timestamp >= since.Value);

        var entries = await query.ToListAsync(ct);

        return new AuditLogStatistics
        {
            TotalEntries = entries.Count,
            AutoApprovedCount = entries.Count(e => e.Decision == (int)AuditDecision.AutoApproved),
            UserApprovedCount = entries.Count(e => e.Decision == (int)AuditDecision.UserApproved),
            DeniedCount = entries.Count(e => e.Decision == (int)AuditDecision.UserDenied),
            BlockedCount = entries.Count(e => e.Decision == (int)AuditDecision.PolicyBlocked),
            FailedExecutionsCount = entries.Count(e => e.ExecutionSuccess == false),
            ToolUsageCounts = entries.GroupBy(e => e.ToolId)
                .ToDictionary(g => g.Key, g => g.Count()),
            RiskLevelCounts = entries.GroupBy(e => (RiskLevel)e.RiskLevel)
                .ToDictionary(g => g.Key, g => g.Count())
        };
    }

    public async Task ExportAsync(
        string filePath, AuditLogQuery? query = null, CancellationToken ct = default)
    {
        var entries = await QueryAsync(query ?? new AuditLogQuery { Take = int.MaxValue }, ct);
        var json = JsonSerializer.Serialize(entries, new JsonSerializerOptions { WriteIndented = true });
        await File.WriteAllTextAsync(filePath, json, ct);
    }
}
```

### Files to Create (v0.6.4g)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Data/Entities/AuditLogEntity.cs` | Entity class |
| `src/SeniorIntern.Core/Interfaces/IAuditLogRepository.cs` | Repository interface |
| `src/SeniorIntern.Data/Repositories/AuditLogRepository.cs` | Repository implementation |
| `src/SeniorIntern.Data/Migrations/AddAuditLog.cs` | Database migration |

### Files to Modify (v0.6.4g)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Data/AppDbContext.cs` | Add AuditLog DbSet |

### Acceptance Criteria (v0.6.4g)
- [ ] Database schema supports all audit fields
- [ ] Indexes enable efficient queries
- [ ] Repository implements all query filters
- [ ] Statistics aggregation works correctly
- [ ] Export produces valid JSON

---

## v0.6.4h: Approval Dialog UI

### Objective
Design and implement the approval dialog that presents tool call requests to users with clear risk visualization and action options.

### ToolApprovalDialog XAML

```xml
<!-- Views/Dialogs/ToolApprovalDialog.axaml -->
<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:vm="using:SeniorIntern.Desktop.ViewModels"
        x:Class="SeniorIntern.Desktop.Views.Dialogs.ToolApprovalDialog"
        Title="Tool Execution Request"
        Width="520"
        SizeToContent="Height"
        WindowStartupLocation="CenterOwner"
        CanResize="False"
        ShowInTaskbar="False"
        SystemDecorations="BorderOnly">

    <Window.Styles>
        <StyleInclude Source="/Styles/ApprovalDialogStyles.axaml" />
    </Window.Styles>

    <Border Classes="dialog-container" Padding="24">
        <Grid RowDefinitions="Auto, Auto, Auto, Auto, Auto, Auto">

            <!-- Header with Risk Indicator -->
            <Grid ColumnDefinitions="Auto, *, Auto" Margin="0,0,0,16">

                <!-- Risk Level Badge -->
                <Border Classes="risk-badge"
                        Classes.safe="{Binding IsSafe}"
                        Classes.low="{Binding IsLow}"
                        Classes.medium="{Binding IsMedium}"
                        Classes.high="{Binding IsHigh}"
                        Classes.critical="{Binding IsCritical}"
                        Width="56" Height="56" CornerRadius="28">
                    <StackPanel HorizontalAlignment="Center" VerticalAlignment="Center">
                        <PathIcon Data="{Binding RiskIcon}"
                                  Width="24" Height="24"
                                  Foreground="White" />
                    </StackPanel>
                </Border>

                <!-- Tool Info -->
                <StackPanel Grid.Column="1" Margin="16,0" VerticalAlignment="Center">
                    <TextBlock Text="{Binding ToolName}"
                               FontSize="20"
                               FontWeight="SemiBold" />
                    <StackPanel Orientation="Horizontal" Spacing="8">
                        <TextBlock Text="{Binding CategoryText}"
                                   FontSize="12"
                                   Foreground="{DynamicResource TextMuted}" />
                        <TextBlock Text=""
                                   FontSize="12"
                                   Foreground="{DynamicResource TextMuted}" />
                        <TextBlock Text="{Binding RiskLevelText}"
                                   FontSize="12"
                                   Foreground="{Binding RiskLevelBrush}"
                                   FontWeight="SemiBold" />
                    </StackPanel>
                </StackPanel>

                <!-- Timeout Indicator -->
                <StackPanel Grid.Column="2" VerticalAlignment="Center" HorizontalAlignment="Right">
                    <TextBlock Text="{Binding TimeoutText}"
                               FontSize="12"
                               Foreground="{DynamicResource TextMuted}"
                               HorizontalAlignment="Right" />
                    <ProgressBar Value="{Binding TimeoutProgress}"
                                 Maximum="100"
                                 Height="3"
                                 Width="60"
                                 Foreground="{Binding TimeoutBrush}" />
                </StackPanel>
            </Grid>

            <!-- Execution Summary -->
            <Border Grid.Row="1"
                    Classes="summary-box"
                    Padding="16"
                    Margin="0,0,0,16">
                <Grid RowDefinitions="Auto, Auto">
                    <TextBlock Text="This action will:"
                               FontSize="12"
                               Foreground="{DynamicResource TextMuted}"
                               Margin="0,0,0,8" />
                    <TextBlock Grid.Row="1"
                               Text="{Binding ExecutionSummary}"
                               TextWrapping="Wrap"
                               FontFamily="{DynamicResource MonoFont}"
                               FontSize="14" />
                </Grid>
            </Border>

            <!-- Risk Factors (if any) -->
            <Border Grid.Row="2"
                    Classes="risk-factors-box"
                    IsVisible="{Binding HasRiskFactors}"
                    Padding="16"
                    Margin="0,0,0,16">
                <StackPanel>
                    <TextBlock Text="Risk factors:"
                               FontSize="12"
                               FontWeight="SemiBold"
                               Margin="0,0,0,8" />
                    <ItemsControl ItemsSource="{Binding RiskFactors}">
                        <ItemsControl.ItemTemplate>
                            <DataTemplate>
                                <Grid ColumnDefinitions="Auto, *" Margin="0,4">
                                    <Ellipse Width="8" Height="8"
                                             Fill="{Binding Contribution, Converter={StaticResource RiskLevelBrushConverter}}"
                                             Margin="0,5,12,0"
                                             VerticalAlignment="Top" />
                                    <TextBlock Grid.Column="1"
                                               Text="{Binding Description}"
                                               TextWrapping="Wrap" />
                                </Grid>
                            </DataTemplate>
                        </ItemsControl.ItemTemplate>
                    </ItemsControl>
                </StackPanel>
            </Border>

            <!-- Details Expander -->
            <Expander Grid.Row="3"
                      Header="View parameters"
                      IsExpanded="{Binding IsDetailsExpanded}"
                      Margin="0,0,0,16">
                <Border Classes="details-box" Padding="12">
                    <Grid RowDefinitions="Auto, Auto">
                        <TextBox Text="{Binding ParametersJson}"
                                 IsReadOnly="{Binding !IsEditingParameters}"
                                 AcceptsReturn="True"
                                 FontFamily="{DynamicResource MonoFont}"
                                 FontSize="12"
                                 MaxHeight="200"
                                 TextWrapping="Wrap" />

                        <StackPanel Grid.Row="1"
                                    Orientation="Horizontal"
                                    HorizontalAlignment="Right"
                                    Margin="0,8,0,0"
                                    IsVisible="{Binding CanEditParameters}">
                            <Button Content="{Binding EditButtonText}"
                                    Command="{Binding ToggleEditCommand}"
                                    Classes="link-button" />
                        </StackPanel>
                    </Grid>
                </Border>
            </Expander>

            <!-- Remember Options -->
            <StackPanel Grid.Row="4" Spacing="12" Margin="0,0,0,20">
                <CheckBox IsChecked="{Binding RememberForSession}">
                    <TextBlock>
                        <Run Text="Remember for this session" />
                        <Run Text=" - don't ask again until restart"
                             Foreground="{DynamicResource TextMuted}"
                             FontSize="12" />
                    </TextBlock>
                </CheckBox>

                <CheckBox IsChecked="{Binding RememberForTool}"
                          IsVisible="{Binding CanRememberPermanently}">
                    <TextBlock>
                        <Run Text="Always allow this tool" />
                        <Run Text=" - can be changed in Settings"
                             Foreground="{DynamicResource TextMuted}"
                             FontSize="12" />
                    </TextBlock>
                </CheckBox>
            </StackPanel>

            <!-- Action Buttons -->
            <Grid Grid.Row="5" ColumnDefinitions="Auto, *, Auto, Auto">

                <!-- Keyboard hints -->
                <TextBlock VerticalAlignment="Center"
                           FontSize="11"
                           Foreground="{DynamicResource TextMuted}">
                    <Run Text="Enter" FontWeight="SemiBold" /> to allow,
                    <Run Text="Esc" FontWeight="SemiBold" /> to deny
                </TextBlock>

                <!-- Deny Button -->
                <Button Grid.Column="2"
                        Content="Deny"
                        Command="{Binding DenyCommand}"
                        HotKey="Escape"
                        Width="100"
                        Margin="0,0,12,0" />

                <!-- Allow Button -->
                <Button Grid.Column="3"
                        Content="Allow"
                        Command="{Binding AllowCommand}"
                        HotKey="Enter"
                        Classes="accent"
                        Width="100" />
            </Grid>
        </Grid>
    </Border>
</Window>
```

### ApprovalDialogStyles XAML

```xml
<!-- Styles/ApprovalDialogStyles.axaml -->
<Styles xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">

    <!-- Risk Badge Colors -->
    <Style Selector="Border.risk-badge.safe">
        <Setter Property="Background" Value="#22C55E" />
    </Style>
    <Style Selector="Border.risk-badge.low">
        <Setter Property="Background" Value="#84CC16" />
    </Style>
    <Style Selector="Border.risk-badge.medium">
        <Setter Property="Background" Value="#F59E0B" />
    </Style>
    <Style Selector="Border.risk-badge.high">
        <Setter Property="Background" Value="#EF4444" />
    </Style>
    <Style Selector="Border.risk-badge.critical">
        <Setter Property="Background" Value="#7C2D12" />
    </Style>

    <!-- Summary Box -->
    <Style Selector="Border.summary-box">
        <Setter Property="Background" Value="{DynamicResource SurfaceVariant}" />
        <Setter Property="CornerRadius" Value="8" />
        <Setter Property="BorderBrush" Value="{DynamicResource BorderMuted}" />
        <Setter Property="BorderThickness" Value="1" />
    </Style>

    <!-- Risk Factors Box -->
    <Style Selector="Border.risk-factors-box">
        <Setter Property="Background" Value="{DynamicResource WarningBackground}" />
        <Setter Property="CornerRadius" Value="8" />
        <Setter Property="BorderBrush" Value="{DynamicResource WarningBorder}" />
        <Setter Property="BorderThickness" Value="1" />
    </Style>

    <!-- Details Box -->
    <Style Selector="Border.details-box">
        <Setter Property="Background" Value="{DynamicResource Surface}" />
        <Setter Property="CornerRadius" Value="4" />
    </Style>

    <!-- Dialog Container -->
    <Style Selector="Border.dialog-container">
        <Setter Property="Background" Value="{DynamicResource Background}" />
    </Style>
</Styles>
```

### Files to Create (v0.6.4h)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/Views/Dialogs/ToolApprovalDialog.axaml` | Dialog view |
| `src/SeniorIntern.Desktop/Views/Dialogs/ToolApprovalDialog.axaml.cs` | Code-behind |
| `src/SeniorIntern.Desktop/Styles/ApprovalDialogStyles.axaml` | Dialog styles |
| `src/SeniorIntern.Desktop/Converters/RiskLevelBrushConverter.cs` | Color converter |

### Acceptance Criteria (v0.6.4h)
- [ ] Dialog displays tool name and risk level
- [ ] Risk factors are clearly listed
- [ ] Parameters are viewable and optionally editable
- [ ] Remember options work correctly
- [ ] Keyboard shortcuts work (Enter/Escape)
- [ ] Timeout countdown is visible

---

## v0.6.4i: Approval Dialog ViewModel

### Objective
Implement the ViewModel for the approval dialog, handling user interactions, parameter editing, and decision submission.

### ToolApprovalViewModel Class

```csharp
namespace SeniorIntern.Desktop.ViewModels;

/// <summary>
/// ViewModel for the tool approval dialog.
/// </summary>
public partial class ToolApprovalViewModel : ViewModelBase
{
    private readonly ToolCallRequest _request;
    private readonly ITool _tool;
    private readonly RiskClassificationResult _classification;
    private readonly TimeSpan _timeout;
    private readonly DateTime _requestedAt;
    private readonly DispatcherTimer _timeoutTimer;

    [ObservableProperty]
    private string _toolName;

    [ObservableProperty]
    private string _categoryText;

    [ObservableProperty]
    private string _riskLevelText;

    [ObservableProperty]
    private IBrush _riskLevelBrush;

    [ObservableProperty]
    private StreamGeometry _riskIcon;

    [ObservableProperty]
    private string _executionSummary;

    [ObservableProperty]
    private string _parametersJson;

    [ObservableProperty]
    private ObservableCollection<RiskFactor> _riskFactors;

    [ObservableProperty]
    private bool _hasRiskFactors;

    [ObservableProperty]
    private bool _rememberForSession;

    [ObservableProperty]
    private bool _rememberForTool;

    [ObservableProperty]
    private bool _isDetailsExpanded;

    [ObservableProperty]
    private bool _isEditingParameters;

    [ObservableProperty]
    private string _editButtonText = "Edit";

    [ObservableProperty]
    private bool _canEditParameters;

    [ObservableProperty]
    private bool _canRememberPermanently;

    [ObservableProperty]
    private string _timeoutText;

    [ObservableProperty]
    private double _timeoutProgress;

    [ObservableProperty]
    private IBrush _timeoutBrush;

    // Risk level flags for styling
    public bool IsSafe => _classification.FinalRisk == RiskLevel.Safe;
    public bool IsLow => _classification.FinalRisk == RiskLevel.Low;
    public bool IsMedium => _classification.FinalRisk == RiskLevel.Medium;
    public bool IsHigh => _classification.FinalRisk == RiskLevel.High;
    public bool IsCritical => _classification.FinalRisk == RiskLevel.Critical;

    public ApprovalDecision? Result { get; private set; }

    public ToolApprovalViewModel(
        ToolCallRequest request,
        ITool tool,
        RiskClassificationResult classification,
        TimeSpan timeout,
        bool allowEditing = true)
    {
        _request = request;
        _tool = tool;
        _classification = classification;
        _timeout = timeout;
        _requestedAt = DateTime.UtcNow;

        // Initialize display values
        ToolName = tool.Name;
        CategoryText = tool.Category.ToString();
        RiskLevelText = classification.FinalRisk.ToString();
        RiskLevelBrush = GetRiskBrush(classification.FinalRisk);
        RiskIcon = GetRiskIcon(classification.FinalRisk);
        ExecutionSummary = request.ExecutionSummary;
        ParametersJson = FormatParameters(request.Parameters);
        RiskFactors = new ObservableCollection<RiskFactor>(classification.Factors);
        HasRiskFactors = RiskFactors.Count > 0;
        CanEditParameters = allowEditing;
        CanRememberPermanently = classification.FinalRisk <= RiskLevel.Medium;

        TimeoutProgress = 100;
        TimeoutBrush = Brushes.Green;
        UpdateTimeoutDisplay();

        // Start timeout timer
        _timeoutTimer = new DispatcherTimer
        {
            Interval = TimeSpan.FromMilliseconds(100)
        };
        _timeoutTimer.Tick += OnTimeoutTick;
        _timeoutTimer.Start();
    }

    private void OnTimeoutTick(object? sender, EventArgs e)
    {
        var elapsed = DateTime.UtcNow - _requestedAt;
        var remaining = _timeout - elapsed;

        if (remaining <= TimeSpan.Zero)
        {
            _timeoutTimer.Stop();
            // Timeout - deny automatically
            Result = new ApprovalDecision
            {
                Approved = false,
                Reason = "Approval timed out"
            };
            CloseDialog();
            return;
        }

        TimeoutProgress = remaining.TotalMilliseconds / _timeout.TotalMilliseconds * 100;
        UpdateTimeoutDisplay();

        // Change color as time runs out
        TimeoutBrush = TimeoutProgress switch
        {
            > 50 => Brushes.Green,
            > 25 => Brushes.Orange,
            _ => Brushes.Red
        };
    }

    private void UpdateTimeoutDisplay()
    {
        var remaining = _timeout - (DateTime.UtcNow - _requestedAt);
        if (remaining.TotalSeconds > 60)
        {
            TimeoutText = $"{remaining.Minutes}:{remaining.Seconds:D2}";
        }
        else
        {
            TimeoutText = $"{remaining.Seconds}s";
        }
    }

    [RelayCommand]
    private void Allow()
    {
        _timeoutTimer.Stop();

        JsonElement? modifiedParams = null;
        if (IsEditingParameters)
        {
            try
            {
                modifiedParams = JsonDocument.Parse(ParametersJson).RootElement;
            }
            catch (JsonException)
            {
                // Invalid JSON - show error
                return;
            }
        }

        Result = new ApprovalDecision
        {
            Approved = true,
            RememberForSession = RememberForSession,
            RememberForTool = RememberForTool,
            ModifiedParameters = modifiedParams
        };

        CloseDialog();
    }

    [RelayCommand]
    private void Deny()
    {
        _timeoutTimer.Stop();

        Result = new ApprovalDecision
        {
            Approved = false,
            Reason = "User denied"
        };

        CloseDialog();
    }

    [RelayCommand]
    private void ToggleEdit()
    {
        if (IsEditingParameters)
        {
            // Validate JSON before exiting edit mode
            try
            {
                JsonDocument.Parse(ParametersJson);
                IsEditingParameters = false;
                EditButtonText = "Edit";
            }
            catch (JsonException)
            {
                // Show validation error
            }
        }
        else
        {
            IsEditingParameters = true;
            EditButtonText = "Done";
        }
    }

    private void CloseDialog()
    {
        // Request dialog close through view
        DialogCloseRequested?.Invoke(this, Result);
    }

    public event EventHandler<ApprovalDecision?>? DialogCloseRequested;

    private static IBrush GetRiskBrush(RiskLevel level) => level switch
    {
        RiskLevel.Safe => new SolidColorBrush(Color.Parse("#22C55E")),
        RiskLevel.Low => new SolidColorBrush(Color.Parse("#84CC16")),
        RiskLevel.Medium => new SolidColorBrush(Color.Parse("#F59E0B")),
        RiskLevel.High => new SolidColorBrush(Color.Parse("#EF4444")),
        RiskLevel.Critical => new SolidColorBrush(Color.Parse("#7C2D12")),
        _ => Brushes.Gray
    };

    private static StreamGeometry GetRiskIcon(RiskLevel level)
    {
        // Return appropriate icon geometry based on risk level
        return level switch
        {
            RiskLevel.Safe => Icons.CheckCircle,
            RiskLevel.Low => Icons.InfoCircle,
            RiskLevel.Medium => Icons.AlertTriangle,
            RiskLevel.High => Icons.AlertCircle,
            RiskLevel.Critical => Icons.ShieldAlert,
            _ => Icons.HelpCircle
        };
    }

    private static string FormatParameters(JsonElement parameters)
    {
        return JsonSerializer.Serialize(
            parameters,
            new JsonSerializerOptions { WriteIndented = true });
    }
}
```

### Files to Create (v0.6.4i)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/ViewModels/ToolApprovalViewModel.cs` | Dialog ViewModel |
| `src/SeniorIntern.Desktop/Resources/Icons.cs` | Icon geometries |

### Acceptance Criteria (v0.6.4i)
- [ ] ViewModel initializes with request data
- [ ] Timeout countdown works correctly
- [ ] Allow/Deny commands close dialog with result
- [ ] Parameter editing validates JSON
- [ ] Remember options are captured in result
- [ ] Automatic denial on timeout

---

## v0.6.4j: Testing Infrastructure

### Objective
Create comprehensive test suites for the permission system, including unit tests for risk classification, policy evaluation, and integration tests for the approval flow.

### RiskClassifierTests

```csharp
namespace SeniorIntern.Tests.Permissions;

public class RiskClassifierTests
{
    private readonly RiskClassifier _classifier;
    private readonly PermissionPolicy _policy;

    public RiskClassifierTests()
    {
        _policy = new PermissionPolicy();
        _classifier = new RiskClassifier(
            Options.Create(_policy),
            NullLogger<RiskClassifier>.Instance);
    }

    [Fact]
    public void Classify_BlockedTool_ReturnsBlocked()
    {
        _policy.BlockedTools.Add("dangerous-tool");

        var tool = CreateMockTool("dangerous-tool", ToolCategory.Terminal, RiskLevel.High);
        var request = CreateMockRequest("dangerous-tool");

        var result = _classifier.Classify(request, tool);

        Assert.True(result.IsBlocked);
        Assert.Equal(RiskLevel.Critical, result.FinalRisk);
    }

    [Fact]
    public void Classify_TrustedTool_ReturnsTrusted()
    {
        _policy.TrustedTools.Add("safe-tool");

        var tool = CreateMockTool("safe-tool", ToolCategory.FileSystem, RiskLevel.Safe);
        var request = CreateMockRequest("safe-tool");

        var result = _classifier.Classify(request, tool);

        Assert.True(result.IsTrusted);
        Assert.False(result.IsBlocked);
    }

    [Theory]
    [InlineData("rm -rf /", true)]
    [InlineData("rm -rf ~", true)]
    [InlineData("sudo rm -rf /tmp", true)]
    [InlineData("rm file.txt", false)]
    [InlineData("ls -la", false)]
    public void Classify_TerminalCommand_DetectsBlockedPatterns(string command, bool shouldBlock)
    {
        var tool = CreateMockTool("terminal-run", ToolCategory.Terminal, RiskLevel.High);
        var request = CreateMockRequest("terminal-run", ("command", command));

        var result = _classifier.Classify(request, tool);

        Assert.Equal(shouldBlock, result.IsBlocked);
    }

    [Theory]
    [InlineData("~/.ssh/id_rsa", true)]
    [InlineData("~/.aws/credentials", true)]
    [InlineData(".env", true)]
    [InlineData("src/main.cs", false)]
    public void Classify_FileOperation_DetectsProtectedPaths(string path, bool shouldElevate)
    {
        var tool = CreateMockTool("file-read", ToolCategory.FileSystem, RiskLevel.Safe);
        var request = CreateMockRequest("file-read", ("path", path));

        var result = _classifier.Classify(request, tool);

        if (shouldElevate)
        {
            Assert.True(result.FinalRisk >= RiskLevel.High);
            Assert.Contains(result.Factors, f => f.Description.Contains("Protected path"));
        }
    }

    [Fact]
    public void Classify_ToolOverride_AppliesCustomRisk()
    {
        _policy.ToolOverrides["my-tool"] = new ToolPermissionOverride
        {
            ToolId = "my-tool",
            Action = OverrideAction.UseDefault,
            CustomRiskLevel = RiskLevel.Critical
        };

        var tool = CreateMockTool("my-tool", ToolCategory.Custom, RiskLevel.Safe);
        var request = CreateMockRequest("my-tool");

        var result = _classifier.Classify(request, tool);

        Assert.Equal(RiskLevel.Critical, result.FinalRisk);
    }

    // Helper methods
    private static ITool CreateMockTool(string id, ToolCategory category, RiskLevel risk)
    {
        var mock = new Mock<ITool>();
        mock.Setup(t => t.Id).Returns(id);
        mock.Setup(t => t.Category).Returns(category);
        mock.Setup(t => t.DefaultRiskLevel).Returns(risk);
        mock.Setup(t => t.GetEffectiveRiskLevel(It.IsAny<JsonElement>())).Returns(risk);
        return mock.Object;
    }

    private static ToolCallRequest CreateMockRequest(string toolId, params (string key, string value)[] parameters)
    {
        var paramsDict = parameters.ToDictionary(p => p.key, p => (object)p.value);
        var json = JsonSerializer.Serialize(paramsDict);
        var element = JsonDocument.Parse(json).RootElement;

        return new ToolCallRequest
        {
            ToolId = toolId,
            Parameters = element,
            ExecutionSummary = $"Execute {toolId}"
        };
    }
}
```

### PermissionManagerTests

```csharp
namespace SeniorIntern.Tests.Permissions;

public class PermissionManagerTests
{
    [Fact]
    public async Task CheckPermission_DisabledMode_ReturnsBlocked()
    {
        var manager = CreateManager(PolicyMode.Disabled);
        var tool = CreateMockTool("test", ToolCategory.FileSystem, RiskLevel.Safe);
        var request = CreateMockRequest("test");

        var result = await manager.CheckPermissionAsync(request, tool);

        Assert.True(result.IsBlocked);
    }

    [Fact]
    public async Task CheckPermission_AutoApproveMode_AllowsAll()
    {
        var manager = CreateManager(PolicyMode.AutoApprove);
        var tool = CreateMockTool("test", ToolCategory.Terminal, RiskLevel.High);
        var request = CreateMockRequest("test");

        var result = await manager.CheckPermissionAsync(request, tool);

        Assert.True(result.IsAllowed);
        Assert.False(result.RequiresApproval);
    }

    [Fact]
    public async Task CheckPermission_AskForRisky_LowRisk_Allows()
    {
        var manager = CreateManager(PolicyMode.AskForRisky, RiskLevel.Medium);
        var tool = CreateMockTool("test", ToolCategory.FileSystem, RiskLevel.Low);
        var request = CreateMockRequest("test");

        var result = await manager.CheckPermissionAsync(request, tool);

        Assert.True(result.IsAllowed);
    }

    [Fact]
    public async Task CheckPermission_AskForRisky_HighRisk_RequiresApproval()
    {
        var manager = CreateManager(PolicyMode.AskForRisky, RiskLevel.Medium);
        var tool = CreateMockTool("test", ToolCategory.Terminal, RiskLevel.High);
        var request = CreateMockRequest("test");

        var result = await manager.CheckPermissionAsync(request, tool);

        Assert.False(result.IsAllowed);
        Assert.True(result.RequiresApproval);
    }

    [Fact]
    public async Task CheckPermission_SessionCache_ReturnsAllowed()
    {
        var manager = CreateManager(PolicyMode.AlwaysAsk);
        var tool = CreateMockTool("test", ToolCategory.FileSystem, RiskLevel.Medium);

        // Cache a positive decision
        await manager.RememberDecisionAsync("test", new ApprovalDecision
        {
            Approved = true,
            RememberForSession = true
        });

        var request = CreateMockRequest("test");
        var result = await manager.CheckPermissionAsync(request, tool);

        Assert.True(result.IsAllowed);
        Assert.True(result.WasCached);
    }

    // Helper methods omitted for brevity
}
```

### RateLimiterTests

```csharp
namespace SeniorIntern.Tests.Permissions;

public class RateLimiterTests
{
    [Fact]
    public void CheckLimit_UnderLimit_Allows()
    {
        var policy = new PermissionPolicy { RateLimitPerMinute = 10 };
        var limiter = new RateLimiter(Options.Create(policy), NullLogger<RateLimiter>.Instance);

        for (int i = 0; i < 5; i++)
        {
            limiter.RecordCall();
        }

        var result = limiter.CheckLimit();

        Assert.True(result.IsAllowed);
    }

    [Fact]
    public void CheckLimit_AtLimit_Blocks()
    {
        var policy = new PermissionPolicy { RateLimitPerMinute = 5 };
        var limiter = new RateLimiter(Options.Create(policy), NullLogger<RateLimiter>.Instance);

        for (int i = 0; i < 5; i++)
        {
            limiter.RecordCall();
        }

        var result = limiter.CheckLimit();

        Assert.False(result.IsAllowed);
        Assert.NotNull(result.Reason);
        Assert.NotNull(result.RetryAfter);
    }

    [Fact]
    public void GetStatus_ReturnsAccurateCounts()
    {
        var policy = new PermissionPolicy { RateLimitPerMinute = 30, RateLimitPerHour = 300 };
        var limiter = new RateLimiter(Options.Create(policy), NullLogger<RateLimiter>.Instance);

        limiter.RecordCall();
        limiter.RecordCall();
        limiter.RecordCall();

        var status = limiter.GetStatus();

        Assert.Equal(3, status.CallsInLastMinute);
        Assert.Equal(3, status.CallsInLastHour);
    }
}
```

### Files to Create (v0.6.4j)

| File | Purpose |
|------|---------|
| `tests/SeniorIntern.Tests/Permissions/RiskClassifierTests.cs` | Risk classification tests |
| `tests/SeniorIntern.Tests/Permissions/PermissionManagerTests.cs` | Permission manager tests |
| `tests/SeniorIntern.Tests/Permissions/RateLimiterTests.cs` | Rate limiter tests |
| `tests/SeniorIntern.Tests/Permissions/SessionCacheTests.cs` | Session cache tests |
| `tests/SeniorIntern.Tests/Permissions/AuditLogRepositoryTests.cs` | Audit log tests |
| `tests/SeniorIntern.Tests/Permissions/PolicyEvaluationTests.cs` | Policy evaluation tests |
| `tests/SeniorIntern.Tests/Permissions/ApprovalFlowTests.cs` | Approval flow integration tests |

### Acceptance Criteria (v0.6.4j)
- [ ] Risk classifier tests cover all patterns
- [ ] Permission manager tests verify policy modes
- [ ] Rate limiter tests verify limits
- [ ] Session cache tests verify caching behavior
- [ ] All tests pass in CI

---

## Complete File Summary

### Files to Create (Total: 35)

| Part | Count | Focus |
|------|-------|-------|
| v0.6.4a | 5 | Policy models |
| v0.6.4b | 3 | Risk classification |
| v0.6.4c | 4 | Permission checking |
| v0.6.4d | 3 | Interface definitions |
| v0.6.4e | 1 | Permission manager |
| v0.6.4f | 3 | Audit log models |
| v0.6.4g | 4 | Audit storage |
| v0.6.4h | 4 | Approval dialog UI |
| v0.6.4i | 2 | Approval ViewModel |
| v0.6.4j | 7 | Tests |

### Files to Modify (Total: 4)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Services/ServiceCollectionExtensions.cs` | Register permission services |
| `src/SeniorIntern.Core/Interfaces/ISettingsService.cs` | Add policy persistence |
| `src/SeniorIntern.Data/AppDbContext.cs` | Add AuditLog DbSet |
| `src/SeniorIntern.Desktop/App.axaml` | Add dialog styles |

---

## Dependencies

### Prerequisite Sub-Versions
- v0.6.1 (Tool Framework) - Required for ITool, RiskLevel, ToolCategory
- v0.6.2 (Semantic Kernel Integration) - Required for IAgentService integration
- v0.6.3 (Built-in Tools) - Required for tool implementations

### External Dependencies
- Microsoft.Extensions.Options (for configuration)
- System.Text.RegularExpressions (for pattern matching)
- Entity Framework Core (for audit log storage)

---

## Security Considerations

| Concern | Mitigation |
|---------|------------|
| Pattern bypass | Multiple overlapping patterns, continuous updates |
| Rate limit bypass | Per-session tracking, cannot be reset by user |
| Audit log tampering | Append-only storage, no delete API in UI |
| Parameter injection | JSON validation, display sanitization |
| Credential exposure | Redact sensitive parameters in logs |

---

## Implementation Notes

1. **Default Secure**: The default policy mode (AskForRisky with Medium threshold) provides security while avoiding approval fatigue.

2. **Pattern Updates**: Blocked patterns should be updatable without code changes for rapid response to new threats.

3. **Audit Performance**: Audit logging is async and non-blocking to avoid impacting tool execution latency.

4. **UI Responsiveness**: The approval dialog must remain responsive during timeout countdown.

5. **Session Isolation**: Session cache is cleared on application restart to prevent stale permissions.

6. **Policy Persistence**: Policy changes are saved immediately to prevent data loss.
