# Design Specification: AIntern v0.6.0 "Tool Call Execution"

## Executive Summary

This document provides a comprehensive design specification for v0.6.0, which transforms The Senior Intern from a passive coding assistant into an autonomous agent capable of executing actions on behalf of the user. This phase introduces function calling via Microsoft Semantic Kernel (or Microsoft.Extensions.AI), a robust tool system, and critical safety mechanisms including a "Permit/Deny" approval workflow for all potentially dangerous operations.

### v0.6.0 Scope (from ROADMAP.md)
- Introduce **Semantic Kernel** or **Microsoft.Extensions.AI** to handle "Function Calling"
- The Intern can now *request* to run a command (e.g., `dotnet build` or `npm install`)
- **Safety Gate:** A "Permit/Deny" popup for every terminal command the AI wants to run

---

## Sub-Version Breakdown

| Version | Name | Focus |
|---------|------|-------|
| v0.6.1 | Tool Framework | Core tool abstraction, tool registry, tool result handling |
| v0.6.2 | Semantic Kernel Integration | SK setup, function calling with LLamaSharp, prompt engineering |
| v0.6.3 | Built-in Tools | File, terminal, search, and workspace tools |
| v0.6.4 | Safety & Approval | Permission system, approval dialogs, risk classification |
| v0.6.5 | Agent Loop & Polish | Multi-step execution, tool chaining, settings, testing |

---

## Architecture Overview

### Agentic Architecture

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              User Interface                                  │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │    Chat     │  │   Editor    │  │  Terminal   │  │   Files     │        │
│  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘        │
└─────────┼────────────────┼────────────────┼────────────────┼────────────────┘
          │                │                │                │
          ▼                ▼                ▼                ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                           Agent Orchestrator                                 │
│  ┌──────────────────────────────────────────────────────────────────────┐  │
│  │                        Semantic Kernel                                │  │
│  │  ┌────────────────┐  ┌────────────────┐  ┌────────────────┐         │  │
│  │  │  LLM Connector │  │ Function Call  │  │    Planner     │         │  │
│  │  │  (LLamaSharp)  │  │    Parser      │  │   (optional)   │         │  │
│  │  └────────────────┘  └────────────────┘  └────────────────┘         │  │
│  └──────────────────────────────────────────────────────────────────────┘  │
│                                    │                                        │
│                                    ▼                                        │
│  ┌──────────────────────────────────────────────────────────────────────┐  │
│  │                         Tool Registry                                 │  │
│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐        │  │
│  │  │  File   │ │Terminal │ │ Search  │ │Workspace│ │ Custom  │        │  │
│  │  │  Tools  │ │  Tools  │ │  Tools  │ │  Tools  │ │  Tools  │        │  │
│  │  └─────────┘ └─────────┘ └─────────┘ └─────────┘ └─────────┘        │  │
│  └──────────────────────────────────────────────────────────────────────┘  │
│                                    │                                        │
│                                    ▼                                        │
│  ┌──────────────────────────────────────────────────────────────────────┐  │
│  │                       Permission Manager                              │  │
│  │  ┌────────────────┐  ┌────────────────┐  ┌────────────────┐         │  │
│  │  │ Risk Classifier│  │ Approval Flow  │  │  Audit Logger  │         │  │
│  │  └────────────────┘  └────────────────┘  └────────────────┘         │  │
│  └──────────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Agent Execution Flow

```
User Message
     │
     ▼
┌─────────────────┐
│  Build Context  │ ← Attached files, terminal output, workspace state
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│   LLM Inference │ ← Semantic Kernel + LLamaSharp
└────────┬────────┘
         │
         ▼
┌─────────────────┐     No tool calls
│ Parse Response  │ ──────────────────► Display to User
└────────┬────────┘
         │ Has tool calls
         ▼
┌─────────────────┐
│ For each tool:  │
│  ┌────────────┐ │
│  │  Classify  │ │
│  │    Risk    │ │
│  └─────┬──────┘ │
│        │        │
│        ▼        │
│  ┌────────────┐ │     Auto-approve (low risk)
│  │  Request   │ │ ──────────────────────────┐
│  │  Approval  │ │                           │
│  └─────┬──────┘ │                           │
│        │        │                           │
│        ▼        │                           │
│  ┌────────────┐ │     Denied                │
│  │   User     │ │ ─────► Skip tool ─────────┤
│  │  Decision  │ │                           │
│  └─────┬──────┘ │                           │
│        │        │                           │
│        │Approved│                           │
│        ▼        │                           │
│  ┌────────────┐ │                           │
│  │  Execute   │◄├───────────────────────────┘
│  │   Tool     │ │
│  └─────┬──────┘ │
│        │        │
│        ▼        │
│  ┌────────────┐ │
│  │  Capture   │ │
│  │   Result   │ │
│  └────────────┘ │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Continue Agent  │ ← Loop until no more tool calls or max iterations
│     Loop        │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Final Response  │
│   to User       │
└─────────────────┘
```

---

## v0.6.1: Tool Framework

### Objective
Establish the core tool abstraction layer with a registry system, standardized tool definitions, input/output schemas, and result handling.

### Tool Abstraction

#### ITool Interface

```csharp
namespace SeniorIntern.Core.Tools;

/// <summary>
/// Base interface for all tools that can be invoked by the AI agent
/// </summary>
public interface ITool
{
    /// <summary>
    /// Unique identifier for this tool
    /// </summary>
    string Id { get; }

    /// <summary>
    /// Human-readable name
    /// </summary>
    string Name { get; }

    /// <summary>
    /// Description for the LLM to understand when to use this tool
    /// </summary>
    string Description { get; }

    /// <summary>
    /// Category for UI grouping
    /// </summary>
    ToolCategory Category { get; }

    /// <summary>
    /// Risk level for permission management
    /// </summary>
    RiskLevel DefaultRiskLevel { get; }

    /// <summary>
    /// JSON Schema for input parameters
    /// </summary>
    JsonSchema InputSchema { get; }

    /// <summary>
    /// Whether this tool is currently available
    /// </summary>
    bool IsAvailable { get; }

    /// <summary>
    /// Execute the tool with given parameters
    /// </summary>
    Task<ToolResult> ExecuteAsync(
        ToolExecutionContext context,
        CancellationToken ct = default);

    /// <summary>
    /// Validate parameters before execution
    /// </summary>
    ToolValidationResult Validate(JsonElement parameters);

    /// <summary>
    /// Get a human-readable description of what this invocation will do
    /// </summary>
    string GetExecutionSummary(JsonElement parameters);
}

public enum ToolCategory
{
    FileSystem,
    Terminal,
    Search,
    Workspace,
    Editor,
    Git,
    Network,
    System,
    Custom
}

public enum RiskLevel
{
    /// <summary>
    /// Read-only operations, no side effects
    /// </summary>
    Safe,

    /// <summary>
    /// May modify files but reversible
    /// </summary>
    Low,

    /// <summary>
    /// Significant changes, requires attention
    /// </summary>
    Medium,

    /// <summary>
    /// Potentially destructive or irreversible
    /// </summary>
    High,

    /// <summary>
    /// System-level operations, always requires explicit approval
    /// </summary>
    Critical
}
```

#### ToolExecutionContext

```csharp
namespace SeniorIntern.Core.Tools;

/// <summary>
/// Context provided to tools during execution
/// </summary>
public sealed class ToolExecutionContext
{
    /// <summary>
    /// Unique ID for this execution
    /// </summary>
    public Guid ExecutionId { get; init; } = Guid.NewGuid();

    /// <summary>
    /// The conversation/agent session this belongs to
    /// </summary>
    public Guid SessionId { get; init; }

    /// <summary>
    /// Current workspace path (if any)
    /// </summary>
    public string? WorkspacePath { get; init; }

    /// <summary>
    /// Input parameters from the LLM
    /// </summary>
    public JsonElement Parameters { get; init; }

    /// <summary>
    /// Access to services
    /// </summary>
    public IServiceProvider Services { get; init; } = null!;

    /// <summary>
    /// Cancellation token
    /// </summary>
    public CancellationToken CancellationToken { get; init; }

    /// <summary>
    /// Progress reporter for long-running tools
    /// </summary>
    public IProgress<ToolProgress>? Progress { get; init; }

    /// <summary>
    /// Whether user has approved this execution
    /// </summary>
    public bool IsApproved { get; init; }

    /// <summary>
    /// User-modified parameters (if any changes during approval)
    /// </summary>
    public JsonElement? ModifiedParameters { get; init; }
}

public sealed class ToolProgress
{
    public string Message { get; init; } = string.Empty;
    public double? PercentComplete { get; init; }
    public string? CurrentOperation { get; init; }
}
```

#### ToolResult

```csharp
namespace SeniorIntern.Core.Tools;

/// <summary>
/// Result of a tool execution
/// </summary>
public sealed class ToolResult
{
    /// <summary>
    /// Whether the tool executed successfully
    /// </summary>
    public bool Success { get; init; }

    /// <summary>
    /// Result data to return to the LLM
    /// </summary>
    public object? Data { get; init; }

    /// <summary>
    /// Human-readable message about the result
    /// </summary>
    public string Message { get; init; } = string.Empty;

    /// <summary>
    /// Error details if failed
    /// </summary>
    public string? Error { get; init; }

    /// <summary>
    /// Any artifacts produced (files created, etc.)
    /// </summary>
    public IReadOnlyList<ToolArtifact> Artifacts { get; init; } = Array.Empty<ToolArtifact>();

    /// <summary>
    /// Execution duration
    /// </summary>
    public TimeSpan Duration { get; init; }

    /// <summary>
    /// Suggested follow-up actions
    /// </summary>
    public IReadOnlyList<string>? SuggestedFollowUps { get; init; }

    public static ToolResult Succeeded(object? data = null, string? message = null) =>
        new() { Success = true, Data = data, Message = message ?? "Operation completed successfully" };

    public static ToolResult Failed(string error, object? partialData = null) =>
        new() { Success = false, Error = error, Data = partialData, Message = error };

    public static ToolResult Cancelled() =>
        new() { Success = false, Error = "Operation was cancelled", Message = "Operation was cancelled by user" };
}

public sealed class ToolArtifact
{
    public string Type { get; init; } = string.Empty; // "file", "directory", "output", etc.
    public string Path { get; init; } = string.Empty;
    public string? Description { get; init; }
    public long? Size { get; init; }
}

public sealed class ToolValidationResult
{
    public bool IsValid { get; init; }
    public IReadOnlyList<ToolValidationError> Errors { get; init; } = Array.Empty<ToolValidationError>();

    public static ToolValidationResult Valid() => new() { IsValid = true };
    public static ToolValidationResult Invalid(params ToolValidationError[] errors) =>
        new() { IsValid = false, Errors = errors };
}

public sealed class ToolValidationError
{
    public string ParameterName { get; init; } = string.Empty;
    public string Message { get; init; } = string.Empty;
}
```

### Tool Registry

```csharp
namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Registry for managing available tools
/// </summary>
public interface IToolRegistry
{
    /// <summary>
    /// All registered tools
    /// </summary>
    IReadOnlyList<ITool> Tools { get; }

    /// <summary>
    /// Get available tools (filtered by current context)
    /// </summary>
    IReadOnlyList<ITool> GetAvailableTools(ToolAvailabilityContext? context = null);

    /// <summary>
    /// Get a tool by ID
    /// </summary>
    ITool? GetTool(string toolId);

    /// <summary>
    /// Register a new tool
    /// </summary>
    void RegisterTool(ITool tool);

    /// <summary>
    /// Unregister a tool
    /// </summary>
    void UnregisterTool(string toolId);

    /// <summary>
    /// Get tools by category
    /// </summary>
    IReadOnlyList<ITool> GetToolsByCategory(ToolCategory category);

    /// <summary>
    /// Generate OpenAI-compatible function definitions for all available tools
    /// </summary>
    IReadOnlyList<FunctionDefinition> GetFunctionDefinitions(ToolAvailabilityContext? context = null);

    /// <summary>
    /// Event when tools change
    /// </summary>
    event EventHandler<ToolRegistryChangedEventArgs>? ToolsChanged;
}

public sealed class ToolAvailabilityContext
{
    public bool HasWorkspace { get; init; }
    public bool HasTerminal { get; init; }
    public bool HasEditor { get; init; }
    public string? WorkspacePath { get; init; }
    public IReadOnlySet<string>? EnabledToolIds { get; init; }
    public IReadOnlySet<string>? DisabledToolIds { get; init; }
}

public sealed class FunctionDefinition
{
    public string Name { get; init; } = string.Empty;
    public string Description { get; init; } = string.Empty;
    public JsonSchema Parameters { get; init; } = null!;
}
```

### Tool Registry Implementation

```csharp
namespace SeniorIntern.Services;

public sealed class ToolRegistry : IToolRegistry
{
    private readonly ConcurrentDictionary<string, ITool> _tools = new();
    private readonly ILogger<ToolRegistry> _logger;

    public IReadOnlyList<ITool> Tools => _tools.Values.ToList();

    public void RegisterTool(ITool tool)
    {
        if (_tools.TryAdd(tool.Id, tool))
        {
            _logger.LogInformation("Registered tool: {ToolId} ({ToolName})", tool.Id, tool.Name);
            ToolsChanged?.Invoke(this, new ToolRegistryChangedEventArgs
            {
                ChangeType = ToolRegistryChangeType.Added,
                Tool = tool
            });
        }
        else
        {
            _logger.LogWarning("Tool {ToolId} is already registered", tool.Id);
        }
    }

    public IReadOnlyList<ITool> GetAvailableTools(ToolAvailabilityContext? context = null)
    {
        var tools = _tools.Values.Where(t => t.IsAvailable);

        if (context != null)
        {
            // Filter based on context
            if (context.DisabledToolIds?.Count > 0)
            {
                tools = tools.Where(t => !context.DisabledToolIds.Contains(t.Id));
            }

            if (context.EnabledToolIds?.Count > 0)
            {
                tools = tools.Where(t => context.EnabledToolIds.Contains(t.Id));
            }

            // Filter workspace-dependent tools
            if (!context.HasWorkspace)
            {
                tools = tools.Where(t => t.Category != ToolCategory.Workspace);
            }

            // Filter terminal-dependent tools
            if (!context.HasTerminal)
            {
                tools = tools.Where(t => t.Category != ToolCategory.Terminal);
            }
        }

        return tools.ToList();
    }

    public IReadOnlyList<FunctionDefinition> GetFunctionDefinitions(ToolAvailabilityContext? context = null)
    {
        return GetAvailableTools(context)
            .Select(t => new FunctionDefinition
            {
                Name = t.Id,
                Description = t.Description,
                Parameters = t.InputSchema
            })
            .ToList();
    }

    public event EventHandler<ToolRegistryChangedEventArgs>? ToolsChanged;
}
```

### Tool Base Class

```csharp
namespace SeniorIntern.Core.Tools;

/// <summary>
/// Base class for implementing tools with common functionality
/// </summary>
public abstract class ToolBase : ITool
{
    public abstract string Id { get; }
    public abstract string Name { get; }
    public abstract string Description { get; }
    public abstract ToolCategory Category { get; }
    public virtual RiskLevel DefaultRiskLevel => RiskLevel.Low;
    public abstract JsonSchema InputSchema { get; }
    public virtual bool IsAvailable => true;

    public abstract Task<ToolResult> ExecuteAsync(
        ToolExecutionContext context,
        CancellationToken ct = default);

    public virtual ToolValidationResult Validate(JsonElement parameters)
    {
        // Default validation using JSON schema
        // Subclasses can override for custom validation
        return ToolValidationResult.Valid();
    }

    public virtual string GetExecutionSummary(JsonElement parameters)
    {
        return $"Execute {Name}";
    }

    /// <summary>
    /// Helper to get a required parameter
    /// </summary>
    protected T GetParameter<T>(JsonElement parameters, string name)
    {
        if (!parameters.TryGetProperty(name, out var prop))
        {
            throw new ArgumentException($"Missing required parameter: {name}");
        }

        return prop.Deserialize<T>()
            ?? throw new ArgumentException($"Invalid value for parameter: {name}");
    }

    /// <summary>
    /// Helper to get an optional parameter
    /// </summary>
    protected T? GetOptionalParameter<T>(JsonElement parameters, string name, T? defaultValue = default)
    {
        if (!parameters.TryGetProperty(name, out var prop))
        {
            return defaultValue;
        }

        return prop.Deserialize<T>();
    }
}
```

### JSON Schema Builder

```csharp
namespace SeniorIntern.Core.Tools;

/// <summary>
/// Fluent builder for JSON Schema definitions
/// </summary>
public sealed class JsonSchemaBuilder
{
    private readonly Dictionary<string, JsonSchemaProperty> _properties = new();
    private readonly List<string> _required = new();
    private string? _description;

    public static JsonSchemaBuilder Create() => new();

    public JsonSchemaBuilder WithDescription(string description)
    {
        _description = description;
        return this;
    }

    public JsonSchemaBuilder AddString(string name, string description, bool required = false,
        string[]? enumValues = null, string? pattern = null)
    {
        _properties[name] = new JsonSchemaProperty
        {
            Type = "string",
            Description = description,
            Enum = enumValues,
            Pattern = pattern
        };

        if (required) _required.Add(name);
        return this;
    }

    public JsonSchemaBuilder AddInteger(string name, string description, bool required = false,
        int? minimum = null, int? maximum = null)
    {
        _properties[name] = new JsonSchemaProperty
        {
            Type = "integer",
            Description = description,
            Minimum = minimum,
            Maximum = maximum
        };

        if (required) _required.Add(name);
        return this;
    }

    public JsonSchemaBuilder AddBoolean(string name, string description, bool required = false)
    {
        _properties[name] = new JsonSchemaProperty
        {
            Type = "boolean",
            Description = description
        };

        if (required) _required.Add(name);
        return this;
    }

    public JsonSchemaBuilder AddArray(string name, string description, string itemType,
        bool required = false)
    {
        _properties[name] = new JsonSchemaProperty
        {
            Type = "array",
            Description = description,
            Items = new JsonSchemaProperty { Type = itemType }
        };

        if (required) _required.Add(name);
        return this;
    }

    public JsonSchema Build()
    {
        return new JsonSchema
        {
            Type = "object",
            Description = _description,
            Properties = _properties,
            Required = _required
        };
    }
}

public sealed class JsonSchema
{
    public string Type { get; init; } = "object";
    public string? Description { get; init; }
    public Dictionary<string, JsonSchemaProperty> Properties { get; init; } = new();
    public List<string> Required { get; init; } = new();
}

public sealed class JsonSchemaProperty
{
    public string Type { get; init; } = string.Empty;
    public string? Description { get; init; }
    public string[]? Enum { get; init; }
    public string? Pattern { get; init; }
    public int? Minimum { get; init; }
    public int? Maximum { get; init; }
    public JsonSchemaProperty? Items { get; init; }
}
```

### Files to Create (v0.6.1)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Tools/ITool.cs` | Tool interface |
| `src/SeniorIntern.Core/Tools/ToolBase.cs` | Base implementation |
| `src/SeniorIntern.Core/Tools/ToolResult.cs` | Result types |
| `src/SeniorIntern.Core/Tools/ToolExecutionContext.cs` | Execution context |
| `src/SeniorIntern.Core/Tools/JsonSchema.cs` | Schema types |
| `src/SeniorIntern.Core/Tools/JsonSchemaBuilder.cs` | Schema builder |
| `src/SeniorIntern.Core/Interfaces/IToolRegistry.cs` | Registry interface |
| `src/SeniorIntern.Services/ToolRegistry.cs` | Registry implementation |

### Testing Strategy (v0.6.1)
- Unit tests for JSON schema generation
- Unit tests for tool validation
- Unit tests for tool registry operations
- Integration tests for tool execution

---

## v0.6.2: Semantic Kernel Integration

### Objective
Integrate Microsoft Semantic Kernel with LLamaSharp to enable function calling capabilities, prompt engineering for tool use, and response parsing.

### New NuGet Packages

| Package | Version | Purpose |
|---------|---------|---------|
| Microsoft.SemanticKernel | 1.x | AI orchestration framework |
| Microsoft.SemanticKernel.Connectors.OpenAI | 1.x | Function calling support |
| LLamaSharp.SemanticKernel | 0.x | LLamaSharp SK connector |

### Semantic Kernel Configuration

```csharp
namespace SeniorIntern.Services.AI;

public sealed class SemanticKernelConfiguration
{
    /// <summary>
    /// Whether to use Semantic Kernel for orchestration
    /// </summary>
    public bool Enabled { get; set; } = true;

    /// <summary>
    /// Maximum iterations for agent loop
    /// </summary>
    public int MaxAgentIterations { get; set; } = 10;

    /// <summary>
    /// Maximum parallel tool calls per iteration
    /// </summary>
    public int MaxParallelToolCalls { get; set; } = 3;

    /// <summary>
    /// Timeout for single tool execution
    /// </summary>
    public TimeSpan ToolExecutionTimeout { get; set; } = TimeSpan.FromMinutes(2);

    /// <summary>
    /// Whether to include tool results in conversation history
    /// </summary>
    public bool IncludeToolResultsInHistory { get; set; } = true;

    /// <summary>
    /// System prompt additions for tool use
    /// </summary>
    public string ToolUseSystemPrompt { get; set; } = """
        You are an AI assistant with access to tools that can help you complete tasks.
        When you need to perform an action, use the appropriate tool.
        Always explain what you're doing and why before using a tool.
        After using a tool, interpret the results for the user.
        If a tool fails, explain the error and suggest alternatives.
        """;
}
```

### IAgentService Interface

```csharp
namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Service for managing AI agent interactions with tool capabilities
/// </summary>
public interface IAgentService
{
    /// <summary>
    /// Process a user message with potential tool execution
    /// </summary>
    IAsyncEnumerable<AgentEvent> ProcessMessageAsync(
        AgentRequest request,
        CancellationToken ct = default);

    /// <summary>
    /// Cancel current agent execution
    /// </summary>
    Task CancelAsync();

    /// <summary>
    /// Current agent state
    /// </summary>
    AgentState State { get; }

    /// <summary>
    /// Events for UI updates
    /// </summary>
    event EventHandler<AgentStateChangedEventArgs>? StateChanged;
}

public sealed class AgentRequest
{
    public string Message { get; init; } = string.Empty;
    public Guid ConversationId { get; init; }
    public IReadOnlyList<ChatMessage>? History { get; init; }
    public IReadOnlyList<FileContext>? AttachedFiles { get; init; }
    public string? SystemPrompt { get; init; }
    public ToolAvailabilityContext? ToolContext { get; init; }
}

public enum AgentState
{
    Idle,
    Thinking,
    CallingTool,
    WaitingForApproval,
    ExecutingTool,
    Responding,
    Cancelled,
    Error
}
```

### Agent Events (Streaming Updates)

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Base class for events during agent execution
/// </summary>
public abstract class AgentEvent
{
    public Guid EventId { get; init; } = Guid.NewGuid();
    public DateTime Timestamp { get; init; } = DateTime.UtcNow;
}

/// <summary>
/// LLM is generating a text response
/// </summary>
public sealed class TextGenerationEvent : AgentEvent
{
    public string Token { get; init; } = string.Empty;
    public bool IsComplete { get; init; }
}

/// <summary>
/// LLM wants to call a tool
/// </summary>
public sealed class ToolCallRequestEvent : AgentEvent
{
    public ToolCallRequest Request { get; init; } = null!;
}

/// <summary>
/// Waiting for user approval
/// </summary>
public sealed class ApprovalRequestEvent : AgentEvent
{
    public ToolCallRequest Request { get; init; } = null!;
    public string Summary { get; init; } = string.Empty;
    public RiskLevel RiskLevel { get; init; }

    /// <summary>
    /// TaskCompletionSource to wait for user decision
    /// </summary>
    public TaskCompletionSource<ApprovalDecision> ApprovalTask { get; init; } = new();
}

/// <summary>
/// Tool is executing
/// </summary>
public sealed class ToolExecutionEvent : AgentEvent
{
    public string ToolId { get; init; } = string.Empty;
    public string ToolName { get; init; } = string.Empty;
    public ToolExecutionStatus Status { get; init; }
    public ToolProgress? Progress { get; init; }
}

/// <summary>
/// Tool completed
/// </summary>
public sealed class ToolResultEvent : AgentEvent
{
    public string ToolId { get; init; } = string.Empty;
    public ToolResult Result { get; init; } = null!;
}

/// <summary>
/// Agent loop iteration
/// </summary>
public sealed class AgentIterationEvent : AgentEvent
{
    public int IterationNumber { get; init; }
    public int MaxIterations { get; init; }
}

/// <summary>
/// Error occurred
/// </summary>
public sealed class AgentErrorEvent : AgentEvent
{
    public string Error { get; init; } = string.Empty;
    public bool IsFatal { get; init; }
}

/// <summary>
/// Agent execution complete
/// </summary>
public sealed class AgentCompleteEvent : AgentEvent
{
    public string FinalResponse { get; init; } = string.Empty;
    public int ToolCallsExecuted { get; init; }
    public TimeSpan TotalDuration { get; init; }
}

public enum ToolExecutionStatus
{
    Starting,
    InProgress,
    Completed,
    Failed,
    Cancelled
}
```

### Tool Call Request Model

```csharp
namespace SeniorIntern.Core.Models;

public sealed class ToolCallRequest
{
    public Guid Id { get; init; } = Guid.NewGuid();
    public string ToolId { get; init; } = string.Empty;
    public string ToolName { get; init; } = string.Empty;
    public JsonElement Parameters { get; init; }
    public RiskLevel RiskLevel { get; init; }
    public string ExecutionSummary { get; init; } = string.Empty;
    public DateTime RequestedAt { get; init; } = DateTime.UtcNow;
}

public sealed class ApprovalDecision
{
    public bool Approved { get; init; }
    public string? Reason { get; init; }
    public JsonElement? ModifiedParameters { get; init; }
    public bool RememberForSession { get; init; }
    public bool RememberForTool { get; init; }
}
```

### AgentService Implementation

```csharp
namespace SeniorIntern.Services.AI;

using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.ChatCompletion;

public sealed class AgentService : IAgentService
{
    private readonly ILlmService _llmService;
    private readonly IToolRegistry _toolRegistry;
    private readonly IPermissionManager _permissionManager;
    private readonly SemanticKernelConfiguration _config;
    private readonly ILogger<AgentService> _logger;

    private CancellationTokenSource? _cts;
    private AgentState _state = AgentState.Idle;

    public AgentState State
    {
        get => _state;
        private set
        {
            if (_state != value)
            {
                _state = value;
                StateChanged?.Invoke(this, new AgentStateChangedEventArgs { State = value });
            }
        }
    }

    public async IAsyncEnumerable<AgentEvent> ProcessMessageAsync(
        AgentRequest request,
        [EnumeratorCancellation] CancellationToken ct = default)
    {
        _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);
        var linkedCt = _cts.Token;

        var iteration = 0;
        var toolCallsExecuted = 0;
        var startTime = DateTime.UtcNow;
        var conversationHistory = BuildHistory(request);
        var responseBuilder = new StringBuilder();

        try
        {
            while (iteration < _config.MaxAgentIterations && !linkedCt.IsCancellationRequested)
            {
                iteration++;
                yield return new AgentIterationEvent
                {
                    IterationNumber = iteration,
                    MaxIterations = _config.MaxAgentIterations
                };

                State = AgentState.Thinking;

                // Get available tools
                var tools = _toolRegistry.GetAvailableTools(request.ToolContext);
                var functionDefs = _toolRegistry.GetFunctionDefinitions(request.ToolContext);

                // Build prompt with tool definitions
                var prompt = BuildPromptWithTools(conversationHistory, functionDefs);

                // Stream LLM response
                var response = new StringBuilder();
                var toolCalls = new List<ToolCallRequest>();

                await foreach (var token in _llmService.GenerateStreamingAsync(
                    prompt, GetInferenceOptions(), linkedCt))
                {
                    // Parse for tool calls vs text
                    var parseResult = ParseToken(token, response);

                    if (parseResult.IsToolCall)
                    {
                        toolCalls.Add(parseResult.ToolCall!);
                        yield return new ToolCallRequestEvent { Request = parseResult.ToolCall };
                    }
                    else if (parseResult.IsText)
                    {
                        yield return new TextGenerationEvent { Token = token };
                        responseBuilder.Append(token);
                    }
                }

                // If no tool calls, we're done
                if (toolCalls.Count == 0)
                {
                    yield return new TextGenerationEvent { IsComplete = true };
                    break;
                }

                // Process tool calls
                foreach (var toolCall in toolCalls)
                {
                    // Check permission
                    var permission = await _permissionManager.CheckPermissionAsync(toolCall);

                    if (permission.RequiresApproval)
                    {
                        State = AgentState.WaitingForApproval;

                        var approvalEvent = new ApprovalRequestEvent
                        {
                            Request = toolCall,
                            Summary = toolCall.ExecutionSummary,
                            RiskLevel = toolCall.RiskLevel
                        };

                        yield return approvalEvent;

                        // Wait for user decision
                        var decision = await approvalEvent.ApprovalTask.Task;

                        if (!decision.Approved)
                        {
                            yield return new ToolResultEvent
                            {
                                ToolId = toolCall.ToolId,
                                Result = ToolResult.Failed($"Denied by user: {decision.Reason}")
                            };
                            continue;
                        }

                        // Update permission memory
                        if (decision.RememberForSession || decision.RememberForTool)
                        {
                            await _permissionManager.RememberDecisionAsync(
                                toolCall.ToolId, decision);
                        }
                    }

                    // Execute tool
                    State = AgentState.ExecutingTool;

                    yield return new ToolExecutionEvent
                    {
                        ToolId = toolCall.ToolId,
                        ToolName = toolCall.ToolName,
                        Status = ToolExecutionStatus.Starting
                    };

                    var tool = _toolRegistry.GetTool(toolCall.ToolId);
                    if (tool == null)
                    {
                        yield return new ToolResultEvent
                        {
                            ToolId = toolCall.ToolId,
                            Result = ToolResult.Failed($"Tool not found: {toolCall.ToolId}")
                        };
                        continue;
                    }

                    var context = new ToolExecutionContext
                    {
                        SessionId = request.ConversationId,
                        WorkspacePath = request.ToolContext?.WorkspacePath,
                        Parameters = toolCall.Parameters,
                        CancellationToken = linkedCt,
                        IsApproved = true
                    };

                    try
                    {
                        var result = await tool.ExecuteAsync(context, linkedCt);
                        toolCallsExecuted++;

                        yield return new ToolResultEvent
                        {
                            ToolId = toolCall.ToolId,
                            Result = result
                        };

                        // Add tool result to conversation for next iteration
                        conversationHistory.Add(new ChatMessage
                        {
                            Role = MessageRole.Tool,
                            Content = FormatToolResult(toolCall, result)
                        });
                    }
                    catch (Exception ex)
                    {
                        _logger.LogError(ex, "Tool execution failed: {ToolId}", toolCall.ToolId);

                        yield return new ToolResultEvent
                        {
                            ToolId = toolCall.ToolId,
                            Result = ToolResult.Failed(ex.Message)
                        };

                        yield return new AgentErrorEvent
                        {
                            Error = ex.Message,
                            IsFatal = false
                        };
                    }
                }

                // Continue loop to process tool results
            }

            State = AgentState.Idle;

            yield return new AgentCompleteEvent
            {
                FinalResponse = responseBuilder.ToString(),
                ToolCallsExecuted = toolCallsExecuted,
                TotalDuration = DateTime.UtcNow - startTime
            };
        }
        finally
        {
            _cts?.Dispose();
            _cts = null;
        }
    }

    public Task CancelAsync()
    {
        _cts?.Cancel();
        State = AgentState.Cancelled;
        return Task.CompletedTask;
    }

    private string BuildPromptWithTools(
        List<ChatMessage> history,
        IReadOnlyList<FunctionDefinition> functions)
    {
        var sb = new StringBuilder();

        // System prompt with tool instructions
        sb.AppendLine(_config.ToolUseSystemPrompt);
        sb.AppendLine();
        sb.AppendLine("Available tools:");
        sb.AppendLine();

        foreach (var func in functions)
        {
            sb.AppendLine($"## {func.Name}");
            sb.AppendLine(func.Description);
            sb.AppendLine($"Parameters: {JsonSerializer.Serialize(func.Parameters)}");
            sb.AppendLine();
        }

        sb.AppendLine("""
            To use a tool, respond with a JSON block in this format:
            ```tool_call
            {
              "tool": "tool_name",
              "parameters": { ... }
            }
            ```

            You may include text before or after the tool call.
            """);
        sb.AppendLine();

        // Add conversation history
        foreach (var msg in history)
        {
            sb.AppendLine($"{msg.Role}: {msg.Content}");
        }

        return sb.ToString();
    }

    public event EventHandler<AgentStateChangedEventArgs>? StateChanged;
}
```

### Function Call Parser

```csharp
namespace SeniorIntern.Services.AI;

/// <summary>
/// Parses tool calls from LLM output
/// </summary>
public sealed class FunctionCallParser
{
    // Pattern for tool call blocks
    private static readonly Regex ToolCallPattern = new(
        @"```tool_call\s*\n(?<json>\{[\s\S]*?\})\s*\n```",
        RegexOptions.Compiled | RegexOptions.Multiline);

    // Alternative patterns for different formats
    private static readonly Regex JsonToolCallPattern = new(
        @"\{[^{}]*""tool""\s*:\s*""(?<tool>[^""]+)""[^{}]*""parameters""\s*:\s*(?<params>\{[^{}]*\})[^{}]*\}",
        RegexOptions.Compiled);

    private readonly IToolRegistry _toolRegistry;
    private readonly StringBuilder _buffer = new();
    private bool _inToolBlock;

    public IReadOnlyList<ToolCallRequest> Parse(string content)
    {
        var requests = new List<ToolCallRequest>();

        var matches = ToolCallPattern.Matches(content);
        foreach (Match match in matches)
        {
            try
            {
                var json = match.Groups["json"].Value;
                var parsed = JsonDocument.Parse(json);

                var toolId = parsed.RootElement.GetProperty("tool").GetString()
                    ?? throw new InvalidOperationException("Missing tool name");

                var parameters = parsed.RootElement.TryGetProperty("parameters", out var p)
                    ? p
                    : JsonDocument.Parse("{}").RootElement;

                var tool = _toolRegistry.GetTool(toolId);

                requests.Add(new ToolCallRequest
                {
                    ToolId = toolId,
                    ToolName = tool?.Name ?? toolId,
                    Parameters = parameters,
                    RiskLevel = tool?.DefaultRiskLevel ?? RiskLevel.Medium,
                    ExecutionSummary = tool?.GetExecutionSummary(parameters) ?? $"Execute {toolId}"
                });
            }
            catch (Exception ex)
            {
                // Log parsing error but continue
            }
        }

        return requests;
    }

    public (bool IsToolCall, bool IsText, ToolCallRequest? ToolCall) ParseStreaming(string token)
    {
        _buffer.Append(token);
        var content = _buffer.ToString();

        // Check if we're entering a tool block
        if (content.Contains("```tool_call"))
        {
            _inToolBlock = true;
        }

        if (_inToolBlock)
        {
            // Check for complete tool block
            var match = ToolCallPattern.Match(content);
            if (match.Success)
            {
                _buffer.Clear();
                _inToolBlock = false;

                var requests = Parse(content);
                if (requests.Count > 0)
                {
                    return (true, false, requests[0]);
                }
            }

            // Still in tool block, don't emit text
            return (false, false, null);
        }

        // Regular text
        return (false, true, null);
    }
}
```

### Files to Create (v0.6.2)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/IAgentService.cs` | Agent service interface |
| `src/SeniorIntern.Core/Models/AgentEvent.cs` | Agent event types |
| `src/SeniorIntern.Core/Models/ToolCallRequest.cs` | Tool call models |
| `src/SeniorIntern.Services/AI/SemanticKernelConfiguration.cs` | SK configuration |
| `src/SeniorIntern.Services/AI/AgentService.cs` | Agent implementation |
| `src/SeniorIntern.Services/AI/FunctionCallParser.cs` | Function call parser |

### Files to Modify (v0.6.2)

| File | Changes |
|------|---------|
| `Directory.Packages.props` | Add Semantic Kernel packages |
| `src/SeniorIntern.Services/SeniorIntern.Services.csproj` | Reference SK packages |
| `src/SeniorIntern.Core/Models/ChatMessage.cs` | Add Tool role |

### Testing Strategy (v0.6.2)
- Unit tests for function call parsing
- Unit tests for prompt construction
- Integration tests with mock LLM
- Agent loop iteration tests

---

## v0.6.3: Built-in Tools

### Objective
Implement a comprehensive set of built-in tools for file operations, terminal commands, workspace management, and search functionality.

### File System Tools

#### ReadFileTool

```csharp
namespace SeniorIntern.Services.Tools;

public sealed class ReadFileTool : ToolBase
{
    public override string Id => "read_file";
    public override string Name => "Read File";
    public override string Description => """
        Read the contents of a file from the workspace.
        Returns the full file content as text.
        Use this when you need to examine file contents.
        """;
    public override ToolCategory Category => ToolCategory.FileSystem;
    public override RiskLevel DefaultRiskLevel => RiskLevel.Safe;

    public override JsonSchema InputSchema => JsonSchemaBuilder.Create()
        .AddString("path", "Relative path to the file within the workspace", required: true)
        .AddInteger("max_lines", "Maximum lines to read (default: all)", required: false)
        .AddInteger("start_line", "Starting line number (1-based)", required: false)
        .Build();

    private readonly IFileSystemService _fileSystem;
    private readonly IWorkspaceService _workspace;

    public override async Task<ToolResult> ExecuteAsync(
        ToolExecutionContext context, CancellationToken ct = default)
    {
        var path = GetParameter<string>(context.Parameters, "path");
        var maxLines = GetOptionalParameter<int?>(context.Parameters, "max_lines");
        var startLine = GetOptionalParameter<int?>(context.Parameters, "start_line");

        var fullPath = Path.Combine(context.WorkspacePath ?? "", path);

        if (!await _fileSystem.FileExistsAsync(fullPath))
        {
            return ToolResult.Failed($"File not found: {path}");
        }

        var content = await _fileSystem.ReadFileAsync(fullPath, ct);

        // Apply line filtering
        if (startLine.HasValue || maxLines.HasValue)
        {
            var lines = content.Split('\n');
            var start = (startLine ?? 1) - 1;
            var count = maxLines ?? lines.Length;

            content = string.Join('\n', lines.Skip(start).Take(count));
        }

        return ToolResult.Succeeded(
            data: new { path, content, line_count = content.Split('\n').Length },
            message: $"Read {content.Split('\n').Length} lines from {path}"
        );
    }

    public override string GetExecutionSummary(JsonElement parameters)
    {
        var path = parameters.GetProperty("path").GetString();
        return $"Read file: {path}";
    }
}
```

#### WriteFileTool

```csharp
public sealed class WriteFileTool : ToolBase
{
    public override string Id => "write_file";
    public override string Name => "Write File";
    public override string Description => """
        Write content to a file in the workspace.
        Creates the file if it doesn't exist, overwrites if it does.
        Creates parent directories automatically.
        """;
    public override ToolCategory Category => ToolCategory.FileSystem;
    public override RiskLevel DefaultRiskLevel => RiskLevel.Medium;

    public override JsonSchema InputSchema => JsonSchemaBuilder.Create()
        .AddString("path", "Relative path for the file", required: true)
        .AddString("content", "Content to write to the file", required: true)
        .AddBoolean("create_directories", "Create parent directories if needed", required: false)
        .Build();

    public override async Task<ToolResult> ExecuteAsync(
        ToolExecutionContext context, CancellationToken ct = default)
    {
        var path = GetParameter<string>(context.Parameters, "path");
        var content = GetParameter<string>(context.Parameters, "content");
        var createDirs = GetOptionalParameter<bool>(context.Parameters, "create_directories", true);

        var fullPath = Path.Combine(context.WorkspacePath ?? "", path);

        if (createDirs)
        {
            var dir = Path.GetDirectoryName(fullPath);
            if (!string.IsNullOrEmpty(dir) && !Directory.Exists(dir))
            {
                Directory.CreateDirectory(dir);
            }
        }

        var isNew = !File.Exists(fullPath);
        await File.WriteAllTextAsync(fullPath, content, ct);

        return ToolResult.Succeeded(
            data: new { path, bytes_written = content.Length, created = isNew },
            message: isNew ? $"Created file: {path}" : $"Updated file: {path}"
        ) with
        {
            Artifacts = new[] { new ToolArtifact { Type = "file", Path = fullPath } }
        };
    }

    public override string GetExecutionSummary(JsonElement parameters)
    {
        var path = parameters.GetProperty("path").GetString();
        var content = parameters.GetProperty("content").GetString() ?? "";
        return $"Write {content.Length} chars to: {path}";
    }
}
```

#### ListDirectoryTool

```csharp
public sealed class ListDirectoryTool : ToolBase
{
    public override string Id => "list_directory";
    public override string Name => "List Directory";
    public override string Description => """
        List files and directories in a workspace path.
        Returns names, types, and sizes.
        """;
    public override ToolCategory Category => ToolCategory.FileSystem;
    public override RiskLevel DefaultRiskLevel => RiskLevel.Safe;

    public override JsonSchema InputSchema => JsonSchemaBuilder.Create()
        .AddString("path", "Relative path to list (default: workspace root)", required: false)
        .AddBoolean("recursive", "List recursively", required: false)
        .AddBoolean("include_hidden", "Include hidden files", required: false)
        .Build();

    public override async Task<ToolResult> ExecuteAsync(
        ToolExecutionContext context, CancellationToken ct = default)
    {
        var path = GetOptionalParameter<string>(context.Parameters, "path", ".");
        var recursive = GetOptionalParameter<bool>(context.Parameters, "recursive", false);
        var includeHidden = GetOptionalParameter<bool>(context.Parameters, "include_hidden", false);

        var fullPath = Path.Combine(context.WorkspacePath ?? "", path);

        if (!Directory.Exists(fullPath))
        {
            return ToolResult.Failed($"Directory not found: {path}");
        }

        var options = new EnumerationOptions
        {
            RecurseSubdirectories = recursive,
            AttributesToSkip = includeHidden ? 0 : FileAttributes.Hidden
        };

        var entries = new List<object>();

        foreach (var file in Directory.EnumerateFiles(fullPath, "*", options))
        {
            var info = new FileInfo(file);
            entries.Add(new
            {
                name = Path.GetRelativePath(fullPath, file),
                type = "file",
                size = info.Length,
                modified = info.LastWriteTimeUtc
            });
        }

        foreach (var dir in Directory.EnumerateDirectories(fullPath, "*", options))
        {
            entries.Add(new
            {
                name = Path.GetRelativePath(fullPath, dir),
                type = "directory",
                modified = Directory.GetLastWriteTimeUtc(dir)
            });
        }

        return ToolResult.Succeeded(
            data: new { path, entries },
            message: $"Found {entries.Count} items in {path}"
        );
    }
}
```

### Terminal Tools

#### RunCommandTool

```csharp
public sealed class RunCommandTool : ToolBase
{
    public override string Id => "run_command";
    public override string Name => "Run Terminal Command";
    public override string Description => """
        Execute a shell command in the integrated terminal.
        Returns the command output (stdout and stderr).
        Commands run in the workspace directory by default.
        """;
    public override ToolCategory Category => ToolCategory.Terminal;
    public override RiskLevel DefaultRiskLevel => RiskLevel.High;

    public override JsonSchema InputSchema => JsonSchemaBuilder.Create()
        .AddString("command", "The command to execute", required: true)
        .AddString("working_directory", "Working directory (default: workspace root)", required: false)
        .AddInteger("timeout_seconds", "Timeout in seconds (default: 60)", required: false)
        .AddBoolean("capture_output", "Capture output instead of showing in terminal", required: false)
        .Build();

    private readonly ITerminalService _terminalService;

    public override async Task<ToolResult> ExecuteAsync(
        ToolExecutionContext context, CancellationToken ct = default)
    {
        var command = GetParameter<string>(context.Parameters, "command");
        var workDir = GetOptionalParameter<string>(context.Parameters, "working_directory");
        var timeout = GetOptionalParameter<int>(context.Parameters, "timeout_seconds", 60);
        var capture = GetOptionalParameter<bool>(context.Parameters, "capture_output", true);

        var effectiveDir = workDir ?? context.WorkspacePath ?? Environment.CurrentDirectory;

        using var cts = CancellationTokenSource.CreateLinkedTokenSource(ct);
        cts.CancelAfter(TimeSpan.FromSeconds(timeout));

        try
        {
            var result = await _terminalService.ExecuteCommandAsync(
                _terminalService.ActiveSession!.Id,
                command,
                waitForCompletion: capture,
                cts.Token);

            if (result == null)
            {
                return ToolResult.Succeeded(
                    message: $"Command sent to terminal: {command}"
                );
            }

            return ToolResult.Succeeded(
                data: new
                {
                    command,
                    exit_code = result.ExitCode,
                    output = result.Output,
                    error = result.Error,
                    duration_ms = result.Duration.TotalMilliseconds
                },
                message: result.ExitCode == 0
                    ? $"Command succeeded: {command}"
                    : $"Command failed with exit code {result.ExitCode}"
            );
        }
        catch (OperationCanceledException)
        {
            return ToolResult.Failed($"Command timed out after {timeout} seconds");
        }
    }

    public override string GetExecutionSummary(JsonElement parameters)
    {
        var command = parameters.GetProperty("command").GetString();
        // Truncate long commands
        if (command?.Length > 50)
            command = command[..47] + "...";
        return $"Run: {command}";
    }

    public override ToolValidationResult Validate(JsonElement parameters)
    {
        var command = parameters.GetProperty("command").GetString() ?? "";

        // Check for dangerous commands
        var dangerous = new[] { "rm -rf /", "format", "mkfs", "dd if=", ":(){:|:&};:" };
        foreach (var d in dangerous)
        {
            if (command.Contains(d, StringComparison.OrdinalIgnoreCase))
            {
                return ToolValidationResult.Invalid(
                    new ToolValidationError
                    {
                        ParameterName = "command",
                        Message = $"Potentially destructive command detected: {d}"
                    });
            }
        }

        return ToolValidationResult.Valid();
    }
}
```

### Search Tools

#### SearchFilesTool

```csharp
public sealed class SearchFilesTool : ToolBase
{
    public override string Id => "search_files";
    public override string Name => "Search Files";
    public override string Description => """
        Search for files by name pattern in the workspace.
        Supports glob patterns like *.cs, **/*.json
        """;
    public override ToolCategory Category => ToolCategory.Search;
    public override RiskLevel DefaultRiskLevel => RiskLevel.Safe;

    public override JsonSchema InputSchema => JsonSchemaBuilder.Create()
        .AddString("pattern", "Glob pattern to match (e.g., '*.cs', '**/*.json')", required: true)
        .AddString("path", "Starting directory (default: workspace root)", required: false)
        .AddInteger("max_results", "Maximum results to return (default: 100)", required: false)
        .Build();

    public override async Task<ToolResult> ExecuteAsync(
        ToolExecutionContext context, CancellationToken ct = default)
    {
        var pattern = GetParameter<string>(context.Parameters, "pattern");
        var path = GetOptionalParameter<string>(context.Parameters, "path", ".");
        var maxResults = GetOptionalParameter<int>(context.Parameters, "max_results", 100);

        var fullPath = Path.Combine(context.WorkspacePath ?? "", path);

        var matcher = new Microsoft.Extensions.FileSystemGlobbing.Matcher();
        matcher.AddInclude(pattern);

        var result = matcher.Execute(
            new Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoWrapper(
                new DirectoryInfo(fullPath)));

        var files = result.Files
            .Take(maxResults)
            .Select(f => f.Path)
            .ToList();

        return ToolResult.Succeeded(
            data: new { pattern, matches = files, total = result.Files.Count() },
            message: $"Found {files.Count} files matching '{pattern}'"
        );
    }
}
```

#### SearchContentTool

```csharp
public sealed class SearchContentTool : ToolBase
{
    public override string Id => "search_content";
    public override string Name => "Search Content";
    public override string Description => """
        Search for text content within files in the workspace.
        Supports regular expressions.
        Returns matching lines with file paths and line numbers.
        """;
    public override ToolCategory Category => ToolCategory.Search;
    public override RiskLevel DefaultRiskLevel => RiskLevel.Safe;

    public override JsonSchema InputSchema => JsonSchemaBuilder.Create()
        .AddString("query", "Search query (text or regex)", required: true)
        .AddString("file_pattern", "Glob pattern to filter files (e.g., '*.cs')", required: false)
        .AddBoolean("regex", "Treat query as regular expression", required: false)
        .AddBoolean("case_sensitive", "Case-sensitive search", required: false)
        .AddInteger("max_results", "Maximum results (default: 50)", required: false)
        .Build();

    public override async Task<ToolResult> ExecuteAsync(
        ToolExecutionContext context, CancellationToken ct = default)
    {
        var query = GetParameter<string>(context.Parameters, "query");
        var filePattern = GetOptionalParameter<string>(context.Parameters, "file_pattern", "**/*");
        var useRegex = GetOptionalParameter<bool>(context.Parameters, "regex", false);
        var caseSensitive = GetOptionalParameter<bool>(context.Parameters, "case_sensitive", false);
        var maxResults = GetOptionalParameter<int>(context.Parameters, "max_results", 50);

        var results = new List<object>();
        var regexOptions = caseSensitive ? RegexOptions.None : RegexOptions.IgnoreCase;
        var regex = useRegex ? new Regex(query, regexOptions) : null;

        // Find files to search
        var matcher = new Microsoft.Extensions.FileSystemGlobbing.Matcher();
        matcher.AddInclude(filePattern);

        var searchResult = matcher.Execute(
            new Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoWrapper(
                new DirectoryInfo(context.WorkspacePath ?? ".")));

        foreach (var file in searchResult.Files)
        {
            if (results.Count >= maxResults) break;

            var fullPath = Path.Combine(context.WorkspacePath ?? "", file.Path);
            var lines = await File.ReadAllLinesAsync(fullPath, ct);

            for (int i = 0; i < lines.Length && results.Count < maxResults; i++)
            {
                var line = lines[i];
                bool matches = regex != null
                    ? regex.IsMatch(line)
                    : line.Contains(query,
                        caseSensitive ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase);

                if (matches)
                {
                    results.Add(new
                    {
                        file = file.Path,
                        line = i + 1,
                        content = line.Trim()
                    });
                }
            }
        }

        return ToolResult.Succeeded(
            data: new { query, results },
            message: $"Found {results.Count} matches for '{query}'"
        );
    }
}
```

### Workspace Tools

#### GetWorkspaceInfoTool

```csharp
public sealed class GetWorkspaceInfoTool : ToolBase
{
    public override string Id => "get_workspace_info";
    public override string Name => "Get Workspace Info";
    public override string Description => """
        Get information about the current workspace.
        Returns project type, structure, and key files.
        """;
    public override ToolCategory Category => ToolCategory.Workspace;
    public override RiskLevel DefaultRiskLevel => RiskLevel.Safe;

    public override JsonSchema InputSchema => JsonSchemaBuilder.Create()
        .WithDescription("No parameters required")
        .Build();

    private readonly IWorkspaceService _workspace;

    public override async Task<ToolResult> ExecuteAsync(
        ToolExecutionContext context, CancellationToken ct = default)
    {
        var workspace = _workspace.CurrentWorkspace;
        if (workspace == null)
        {
            return ToolResult.Failed("No workspace is currently open");
        }

        // Detect project type
        var projectType = await DetectProjectTypeAsync(workspace.RootPath);

        // Find key files
        var keyFiles = await FindKeyFilesAsync(workspace.RootPath, projectType);

        return ToolResult.Succeeded(
            data: new
            {
                name = workspace.DisplayName,
                path = workspace.RootPath,
                project_type = projectType,
                key_files = keyFiles
            }
        );
    }

    private async Task<string> DetectProjectTypeAsync(string path)
    {
        if (File.Exists(Path.Combine(path, "*.csproj")) ||
            File.Exists(Path.Combine(path, "*.sln")))
            return "dotnet";

        if (File.Exists(Path.Combine(path, "package.json")))
            return "node";

        if (File.Exists(Path.Combine(path, "Cargo.toml")))
            return "rust";

        if (File.Exists(Path.Combine(path, "pyproject.toml")) ||
            File.Exists(Path.Combine(path, "setup.py")))
            return "python";

        if (File.Exists(Path.Combine(path, "go.mod")))
            return "go";

        return "unknown";
    }
}
```

### Tool Registration

```csharp
namespace SeniorIntern.Services;

public static class BuiltInToolsExtensions
{
    public static IServiceCollection AddBuiltInTools(this IServiceCollection services)
    {
        // File tools
        services.AddSingleton<ITool, ReadFileTool>();
        services.AddSingleton<ITool, WriteFileTool>();
        services.AddSingleton<ITool, ListDirectoryTool>();
        services.AddSingleton<ITool, DeleteFileTool>();
        services.AddSingleton<ITool, MoveFileTool>();
        services.AddSingleton<ITool, CopyFileTool>();

        // Terminal tools
        services.AddSingleton<ITool, RunCommandTool>();

        // Search tools
        services.AddSingleton<ITool, SearchFilesTool>();
        services.AddSingleton<ITool, SearchContentTool>();

        // Workspace tools
        services.AddSingleton<ITool, GetWorkspaceInfoTool>();
        services.AddSingleton<ITool, GetOpenFilesTool>();

        // Git tools
        services.AddSingleton<ITool, GitStatusTool>();
        services.AddSingleton<ITool, GitDiffTool>();
        services.AddSingleton<ITool, GitLogTool>();

        return services;
    }
}
```

### Files to Create (v0.6.3)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Services/Tools/ReadFileTool.cs` | Read file tool |
| `src/SeniorIntern.Services/Tools/WriteFileTool.cs` | Write file tool |
| `src/SeniorIntern.Services/Tools/ListDirectoryTool.cs` | List directory tool |
| `src/SeniorIntern.Services/Tools/DeleteFileTool.cs` | Delete file tool |
| `src/SeniorIntern.Services/Tools/MoveFileTool.cs` | Move/rename tool |
| `src/SeniorIntern.Services/Tools/CopyFileTool.cs` | Copy file tool |
| `src/SeniorIntern.Services/Tools/RunCommandTool.cs` | Terminal command tool |
| `src/SeniorIntern.Services/Tools/SearchFilesTool.cs` | File search tool |
| `src/SeniorIntern.Services/Tools/SearchContentTool.cs` | Content search tool |
| `src/SeniorIntern.Services/Tools/GetWorkspaceInfoTool.cs` | Workspace info tool |
| `src/SeniorIntern.Services/Tools/GitStatusTool.cs` | Git status tool |
| `src/SeniorIntern.Services/Tools/GitDiffTool.cs` | Git diff tool |
| `src/SeniorIntern.Services/Tools/GitLogTool.cs` | Git log tool |
| `src/SeniorIntern.Services/BuiltInToolsExtensions.cs` | DI registration |

### Testing Strategy (v0.6.3)
- Unit tests for each tool
- Integration tests with real file system (temp directories)
- Terminal command tests with mock shell
- Search performance tests

---

## v0.6.4: Safety & Approval

### Objective
Implement a comprehensive permission system with risk classification, approval workflows, audit logging, and user-configurable safety policies.

### Permission System Architecture

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           Permission Manager                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐         │
│  │ Risk Classifier │───►│ Policy Engine   │───►│ Approval Flow   │         │
│  └─────────────────┘    └─────────────────┘    └─────────────────┘         │
│          │                      │                      │                    │
│          │                      │                      ▼                    │
│          │                      │              ┌─────────────────┐          │
│          │                      │              │   UI Dialogs    │          │
│          │                      │              └─────────────────┘          │
│          │                      │                      │                    │
│          ▼                      ▼                      ▼                    │
│  ┌─────────────────────────────────────────────────────────────────┐       │
│  │                        Audit Logger                               │       │
│  │  [Timestamp] [Tool] [Risk] [Decision] [User] [Parameters]        │       │
│  └─────────────────────────────────────────────────────────────────┘       │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### IPermissionManager Interface

```csharp
namespace SeniorIntern.Core.Interfaces;

public interface IPermissionManager
{
    /// <summary>
    /// Check if a tool call requires approval
    /// </summary>
    Task<PermissionCheckResult> CheckPermissionAsync(ToolCallRequest request);

    /// <summary>
    /// Request approval from user
    /// </summary>
    Task<ApprovalDecision> RequestApprovalAsync(
        ToolCallRequest request,
        CancellationToken ct = default);

    /// <summary>
    /// Remember a user's decision for future calls
    /// </summary>
    Task RememberDecisionAsync(string toolId, ApprovalDecision decision);

    /// <summary>
    /// Clear remembered decisions
    /// </summary>
    Task ClearRememberedDecisionsAsync(string? toolId = null);

    /// <summary>
    /// Get current permission policy
    /// </summary>
    PermissionPolicy GetPolicy();

    /// <summary>
    /// Update permission policy
    /// </summary>
    Task UpdatePolicyAsync(PermissionPolicy policy);

    /// <summary>
    /// Get audit log
    /// </summary>
    Task<IReadOnlyList<AuditLogEntry>> GetAuditLogAsync(
        AuditLogQuery? query = null,
        CancellationToken ct = default);
}

public sealed class PermissionCheckResult
{
    public bool RequiresApproval { get; init; }
    public RiskLevel EffectiveRiskLevel { get; init; }
    public string? Reason { get; init; }
    public bool IsBlocked { get; init; }
    public string? BlockReason { get; init; }
}
```

### Permission Policy

```csharp
namespace SeniorIntern.Core.Models;

public sealed class PermissionPolicy
{
    /// <summary>
    /// Global policy mode
    /// </summary>
    public PolicyMode Mode { get; set; } = PolicyMode.AskForRisky;

    /// <summary>
    /// Risk level at which to require approval
    /// </summary>
    public RiskLevel ApprovalThreshold { get; set; } = RiskLevel.Medium;

    /// <summary>
    /// Tool-specific overrides
    /// </summary>
    public Dictionary<string, ToolPermissionOverride> ToolOverrides { get; set; } = new();

    /// <summary>
    /// Blocked tools (never allowed)
    /// </summary>
    public HashSet<string> BlockedTools { get; set; } = new();

    /// <summary>
    /// Trusted tools (always allowed)
    /// </summary>
    public HashSet<string> TrustedTools { get; set; } = new();

    /// <summary>
    /// Command patterns that are always blocked
    /// </summary>
    public List<string> BlockedCommandPatterns { get; set; } = new()
    {
        @"rm\s+-rf\s+/",
        @"sudo\s+rm",
        @"format\s+[a-zA-Z]:",
        @"mkfs",
        @":(){:|:&};:",
        @">\s*/dev/sd[a-z]"
    };

    /// <summary>
    /// Path patterns that are protected (require extra approval)
    /// </summary>
    public List<string> ProtectedPaths { get; set; } = new()
    {
        "~/.ssh/*",
        "~/.aws/*",
        "~/.config/*",
        "**/secrets/*",
        "**/.env*",
        "**/credentials*"
    };

    /// <summary>
    /// Maximum number of tool calls per minute
    /// </summary>
    public int RateLimitPerMinute { get; set; } = 30;

    /// <summary>
    /// Whether to log all tool executions
    /// </summary>
    public bool AuditAllExecutions { get; set; } = true;
}

public enum PolicyMode
{
    /// <summary>
    /// Always ask for approval
    /// </summary>
    AlwaysAsk,

    /// <summary>
    /// Ask for risky operations only
    /// </summary>
    AskForRisky,

    /// <summary>
    /// Auto-approve everything (dangerous!)
    /// </summary>
    AutoApprove,

    /// <summary>
    /// Block all tool calls
    /// </summary>
    Disabled
}

public sealed class ToolPermissionOverride
{
    public string ToolId { get; init; } = string.Empty;
    public OverrideAction Action { get; init; }
    public RiskLevel? CustomRiskLevel { get; init; }
    public string? Reason { get; init; }
}

public enum OverrideAction
{
    UseDefault,
    AlwaysAllow,
    AlwaysAsk,
    Block
}
```

### Risk Classifier

```csharp
namespace SeniorIntern.Services;

public sealed class RiskClassifier
{
    private readonly PermissionPolicy _policy;

    public RiskClassificationResult Classify(ToolCallRequest request, ITool tool)
    {
        var baseRisk = tool.DefaultRiskLevel;
        var factors = new List<RiskFactor>();

        // Check for blocked patterns
        if (tool.Category == ToolCategory.Terminal)
        {
            var command = request.Parameters.GetProperty("command").GetString() ?? "";

            foreach (var pattern in _policy.BlockedCommandPatterns)
            {
                if (Regex.IsMatch(command, pattern, RegexOptions.IgnoreCase))
                {
                    return new RiskClassificationResult
                    {
                        FinalRisk = RiskLevel.Critical,
                        IsBlocked = true,
                        BlockReason = $"Command matches blocked pattern: {pattern}",
                        Factors = new[] { new RiskFactor("Blocked pattern", RiskLevel.Critical) }
                    };
                }
            }

            // Elevate risk for certain commands
            var elevatedCommands = new[] { "sudo", "rm", "chmod", "chown", "kill", "pkill" };
            if (elevatedCommands.Any(c => command.StartsWith(c + " ")))
            {
                factors.Add(new RiskFactor("Elevated command", RiskLevel.High));
                baseRisk = (RiskLevel)Math.Max((int)baseRisk, (int)RiskLevel.High);
            }
        }

        // Check for protected paths
        if (tool.Category == ToolCategory.FileSystem)
        {
            var path = request.Parameters.TryGetProperty("path", out var p)
                ? p.GetString() : null;

            if (path != null)
            {
                foreach (var protectedPattern in _policy.ProtectedPaths)
                {
                    var regex = GlobToRegex(protectedPattern);
                    if (Regex.IsMatch(path, regex))
                    {
                        factors.Add(new RiskFactor($"Protected path: {protectedPattern}", RiskLevel.High));
                        baseRisk = (RiskLevel)Math.Max((int)baseRisk, (int)RiskLevel.High);
                    }
                }
            }
        }

        // Apply tool-specific override
        if (_policy.ToolOverrides.TryGetValue(tool.Id, out var @override))
        {
            if (@override.CustomRiskLevel.HasValue)
            {
                factors.Add(new RiskFactor("Custom risk override", @override.CustomRiskLevel.Value));
                baseRisk = @override.CustomRiskLevel.Value;
            }
        }

        return new RiskClassificationResult
        {
            FinalRisk = baseRisk,
            IsBlocked = false,
            Factors = factors
        };
    }

    private string GlobToRegex(string glob)
    {
        var regex = Regex.Escape(glob)
            .Replace(@"\*\*", ".*")
            .Replace(@"\*", "[^/]*")
            .Replace(@"\?", ".");
        return $"^{regex}$";
    }
}

public sealed class RiskClassificationResult
{
    public RiskLevel FinalRisk { get; init; }
    public bool IsBlocked { get; init; }
    public string? BlockReason { get; init; }
    public IReadOnlyList<RiskFactor> Factors { get; init; } = Array.Empty<RiskFactor>();
}

public record RiskFactor(string Description, RiskLevel Contribution);
```

### Approval Dialog

```xml
<!-- ToolApprovalDialog.axaml -->
<Window xmlns="https://github.com/avaloniaui"
        Title="Tool Execution Request"
        Width="500"
        SizeToContent="Height"
        WindowStartupLocation="CenterOwner"
        CanResize="False">

    <Grid RowDefinitions="Auto, Auto, *, Auto, Auto" Margin="20">

        <!-- Header with Risk Indicator -->
        <Grid ColumnDefinitions="Auto, *, Auto">
            <Border Classes="risk-indicator"
                    Classes.safe="{Binding RiskLevel, Converter={StaticResource RiskLevelConverter}, ConverterParameter=Safe}"
                    Classes.low="{Binding RiskLevel, Converter={StaticResource RiskLevelConverter}, ConverterParameter=Low}"
                    Classes.medium="{Binding RiskLevel, Converter={StaticResource RiskLevelConverter}, ConverterParameter=Medium}"
                    Classes.high="{Binding RiskLevel, Converter={StaticResource RiskLevelConverter}, ConverterParameter=High}"
                    Classes.critical="{Binding RiskLevel, Converter={StaticResource RiskLevelConverter}, ConverterParameter=Critical}"
                    Width="48" Height="48" CornerRadius="24">
                <PathIcon Data="{Binding RiskIcon}" Width="24" Height="24" />
            </Border>

            <StackPanel Grid.Column="1" Margin="16,0">
                <TextBlock Text="{Binding ToolName}" FontSize="18" FontWeight="SemiBold" />
                <TextBlock Text="{Binding RiskLevelText}"
                           Foreground="{Binding RiskLevelBrush}" />
            </StackPanel>

            <TextBlock Grid.Column="2" Text="?" FontSize="24"
                       VerticalAlignment="Center"
                       Foreground="{DynamicResource TextMuted}" />
        </Grid>

        <!-- Summary -->
        <Border Grid.Row="1" Classes="summary-box" Margin="0,16" Padding="12">
            <TextBlock Text="{Binding ExecutionSummary}"
                       TextWrapping="Wrap"
                       FontFamily="Cascadia Mono" />
        </Border>

        <!-- Details (Expandable) -->
        <Expander Grid.Row="2" Header="Details" IsExpanded="False" Margin="0,8">
            <Border Classes="details-box" Padding="12">
                <StackPanel Spacing="8">
                    <TextBlock Text="Parameters:" FontWeight="SemiBold" />
                    <TextBox Text="{Binding ParametersJson}"
                             IsReadOnly="True"
                             AcceptsReturn="True"
                             FontFamily="Cascadia Mono"
                             MaxHeight="150" />

                    <TextBlock Text="Risk Factors:" FontWeight="SemiBold"
                               IsVisible="{Binding HasRiskFactors}"
                               Margin="0,8,0,0" />
                    <ItemsControl ItemsSource="{Binding RiskFactors}"
                                  IsVisible="{Binding HasRiskFactors}">
                        <ItemsControl.ItemTemplate>
                            <DataTemplate>
                                <Grid ColumnDefinitions="Auto, *">
                                    <Ellipse Width="8" Height="8"
                                             Fill="{Binding Contribution, Converter={StaticResource RiskLevelBrushConverter}}"
                                             Margin="0,0,8,0" />
                                    <TextBlock Grid.Column="1" Text="{Binding Description}" />
                                </Grid>
                            </DataTemplate>
                        </ItemsControl.ItemTemplate>
                    </ItemsControl>
                </StackPanel>
            </Border>
        </Expander>

        <!-- Remember Options -->
        <StackPanel Grid.Row="3" Margin="0,16,0,8" Spacing="8">
            <CheckBox Content="Remember for this session"
                      IsChecked="{Binding RememberForSession}" />
            <CheckBox Content="Always allow this tool"
                      IsChecked="{Binding RememberForTool}"
                      ToolTip.Tip="You can change this in Settings > Tools" />
        </StackPanel>

        <!-- Actions -->
        <Grid Grid.Row="4" ColumnDefinitions="*, Auto, Auto">
            <Button Content="Edit Parameters"
                    Command="{Binding EditParametersCommand}"
                    IsVisible="{Binding CanEditParameters}"
                    HorizontalAlignment="Left" />

            <Button Grid.Column="1" Content="Deny"
                    Command="{Binding DenyCommand}"
                    Margin="0,0,8,0" />

            <Button Grid.Column="2" Content="Allow"
                    Command="{Binding AllowCommand}"
                    Classes="accent" />
        </Grid>
    </Grid>
</Window>
```

### Audit Logger

```csharp
namespace SeniorIntern.Core.Models;

public sealed class AuditLogEntry
{
    public Guid Id { get; init; } = Guid.NewGuid();
    public DateTime Timestamp { get; init; } = DateTime.UtcNow;
    public string ToolId { get; init; } = string.Empty;
    public string ToolName { get; init; } = string.Empty;
    public RiskLevel RiskLevel { get; init; }
    public AuditDecision Decision { get; init; }
    public string? DenialReason { get; init; }
    public JsonElement Parameters { get; init; }
    public string ExecutionSummary { get; init; } = string.Empty;
    public Guid? ConversationId { get; init; }

    // Result (if executed)
    public bool? ExecutionSuccess { get; init; }
    public string? ExecutionError { get; init; }
    public TimeSpan? ExecutionDuration { get; init; }
}

public enum AuditDecision
{
    AutoApproved,
    UserApproved,
    UserDenied,
    PolicyBlocked,
    RateLimited,
    Error
}

public sealed class AuditLogQuery
{
    public DateTime? StartDate { get; init; }
    public DateTime? EndDate { get; init; }
    public string? ToolId { get; init; }
    public AuditDecision? Decision { get; init; }
    public RiskLevel? MinRiskLevel { get; init; }
    public int Skip { get; init; }
    public int Take { get; init; } = 100;
}
```

### Database Schema Additions

```sql
-- Audit log table
CREATE TABLE AuditLog (
    Id TEXT PRIMARY KEY,
    Timestamp TEXT NOT NULL,
    ToolId TEXT NOT NULL,
    ToolName TEXT NOT NULL,
    RiskLevel INTEGER NOT NULL,
    Decision INTEGER NOT NULL,
    DenialReason TEXT,
    Parameters TEXT NOT NULL,
    ExecutionSummary TEXT NOT NULL,
    ConversationId TEXT,
    ExecutionSuccess INTEGER,
    ExecutionError TEXT,
    ExecutionDurationMs INTEGER,
    FOREIGN KEY (ConversationId) REFERENCES Conversations(Id)
);

CREATE INDEX IX_AuditLog_Timestamp ON AuditLog(Timestamp DESC);
CREATE INDEX IX_AuditLog_ToolId ON AuditLog(ToolId);
CREATE INDEX IX_AuditLog_Decision ON AuditLog(Decision);

-- Remembered decisions table
CREATE TABLE RememberedDecisions (
    ToolId TEXT PRIMARY KEY,
    Decision INTEGER NOT NULL,
    Reason TEXT,
    RememberedAt TEXT NOT NULL,
    ExpiresAt TEXT
);
```

### Files to Create (v0.6.4)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/IPermissionManager.cs` | Permission interface |
| `src/SeniorIntern.Core/Models/PermissionPolicy.cs` | Policy model |
| `src/SeniorIntern.Core/Models/AuditLogEntry.cs` | Audit log model |
| `src/SeniorIntern.Services/PermissionManager.cs` | Permission implementation |
| `src/SeniorIntern.Services/RiskClassifier.cs` | Risk classification |
| `src/SeniorIntern.Services/AuditLogger.cs` | Audit logging |
| `src/SeniorIntern.Desktop/Views/ToolApprovalDialog.axaml` | Approval dialog |
| `src/SeniorIntern.Desktop/ViewModels/ToolApprovalViewModel.cs` | Dialog ViewModel |
| `src/SeniorIntern.Desktop/Views/AuditLogPanel.axaml` | Audit log viewer |
| `src/SeniorIntern.Data/Entities/AuditLogEntity.cs` | EF entity |
| `src/SeniorIntern.Data/Repositories/AuditLogRepository.cs` | Repository |

### Testing Strategy (v0.6.4)
- Unit tests for risk classification
- Unit tests for policy evaluation
- Integration tests for approval flow
- Audit logging tests

---

## v0.6.5: Agent Loop & Polish

### Objective
Finalize the agent system with multi-step execution, tool chaining, comprehensive settings UI, and thorough testing.

### Agent Loop Visualization

```xml
<!-- AgentActivityPanel.axaml -->
<UserControl xmlns="https://github.com/avaloniaui"
             x:Class="SeniorIntern.Desktop.Views.AgentActivityPanel">

    <Border Classes="agent-activity" IsVisible="{Binding IsAgentActive}">
        <Grid RowDefinitions="Auto, Auto, *">

            <!-- Header -->
            <Grid ColumnDefinitions="Auto, *, Auto" Margin="12,8">
                <StackPanel Orientation="Horizontal" Spacing="8">
                    <ProgressRing Width="16" Height="16"
                                  IsActive="{Binding IsProcessing}" />
                    <TextBlock Text="{Binding AgentStateText}" FontWeight="SemiBold" />
                </StackPanel>

                <TextBlock Grid.Column="1"
                           Text="{Binding IterationText}"
                           HorizontalAlignment="Center"
                           Foreground="{DynamicResource TextMuted}" />

                <Button Grid.Column="2"
                        Content="Cancel"
                        Command="{Binding CancelCommand}"
                        Classes="secondary" />
            </Grid>

            <!-- Progress Bar -->
            <ProgressBar Grid.Row="1"
                         Value="{Binding ProgressPercent}"
                         IsIndeterminate="{Binding IsIndeterminate}"
                         Height="3" />

            <!-- Activity Log -->
            <ScrollViewer Grid.Row="2" MaxHeight="200">
                <ItemsControl ItemsSource="{Binding Activities}">
                    <ItemsControl.ItemTemplate>
                        <DataTemplate>
                            <Grid ColumnDefinitions="Auto, Auto, *" Margin="12,4">
                                <TextBlock Text="{Binding Timestamp, StringFormat='{}{0:HH:mm:ss}'}"
                                           Foreground="{DynamicResource TextMuted}"
                                           FontSize="11" Width="60" />

                                <Border Grid.Column="1"
                                        Classes="activity-icon"
                                        Classes.thinking="{Binding Type, Converter={StaticResource EnumConverter}, ConverterParameter=Thinking}"
                                        Classes.tool="{Binding Type, Converter={StaticResource EnumConverter}, ConverterParameter=Tool}"
                                        Classes.approval="{Binding Type, Converter={StaticResource EnumConverter}, ConverterParameter=Approval}"
                                        Classes.success="{Binding Type, Converter={StaticResource EnumConverter}, ConverterParameter=Success}"
                                        Classes.error="{Binding Type, Converter={StaticResource EnumConverter}, ConverterParameter=Error}"
                                        Margin="8,0">
                                    <PathIcon Data="{Binding Icon}" Width="12" Height="12" />
                                </Border>

                                <TextBlock Grid.Column="2"
                                           Text="{Binding Message}"
                                           TextTrimming="CharacterEllipsis" />
                            </Grid>
                        </DataTemplate>
                    </ItemsControl.ItemTemplate>
                </ItemsControl>
            </ScrollViewer>
        </Grid>
    </Border>
</UserControl>
```

### Agent Settings Panel

```xml
<!-- AgentSettingsPanel.axaml -->
<UserControl xmlns="https://github.com/avaloniaui"
             x:Class="SeniorIntern.Desktop.Views.AgentSettingsPanel">

    <StackPanel Spacing="24" Padding="16">
        <TextBlock Text="Agent Settings" FontSize="18" FontWeight="SemiBold" />

        <!-- Agent Mode -->
        <StackPanel Spacing="12">
            <TextBlock Text="Agent Mode" FontWeight="SemiBold" />

            <RadioButton Content="Disabled - No tool execution"
                         GroupName="AgentMode"
                         IsChecked="{Binding Policy.Mode, Converter={StaticResource EnumConverter}, ConverterParameter=Disabled}" />

            <RadioButton Content="Always Ask - Require approval for all tools"
                         GroupName="AgentMode"
                         IsChecked="{Binding Policy.Mode, Converter={StaticResource EnumConverter}, ConverterParameter=AlwaysAsk}" />

            <RadioButton Content="Ask for Risky - Auto-approve safe operations (Recommended)"
                         GroupName="AgentMode"
                         IsChecked="{Binding Policy.Mode, Converter={StaticResource EnumConverter}, ConverterParameter=AskForRisky}" />

            <RadioButton Content="Auto-Approve - No confirmations (Dangerous!)"
                         GroupName="AgentMode"
                         IsChecked="{Binding Policy.Mode, Converter={StaticResource EnumConverter}, ConverterParameter=AutoApprove}" />
        </StackPanel>

        <!-- Risk Threshold -->
        <StackPanel Spacing="12"
                    IsVisible="{Binding Policy.Mode, Converter={StaticResource EnumConverter}, ConverterParameter=AskForRisky}">
            <TextBlock Text="Approval Threshold" FontWeight="SemiBold" />

            <Grid ColumnDefinitions="*, Auto">
                <Slider Minimum="0" Maximum="4"
                        Value="{Binding RiskThresholdValue}"
                        TickFrequency="1"
                        IsSnapToTickEnabled="True" />
                <TextBlock Grid.Column="1"
                           Text="{Binding Policy.ApprovalThreshold}"
                           Width="80" Margin="8,0" />
            </Grid>

            <TextBlock Text="Tools with this risk level or higher will require approval"
                       Foreground="{DynamicResource TextMuted}"
                       FontSize="12" />
        </StackPanel>

        <!-- Tool List -->
        <StackPanel Spacing="12">
            <Grid ColumnDefinitions="*, Auto">
                <TextBlock Text="Tool Permissions" FontWeight="SemiBold" />
                <Button Grid.Column="1" Content="Reset All"
                        Command="{Binding ResetToolPermissionsCommand}"
                        Classes="link-button" />
            </Grid>

            <ListBox ItemsSource="{Binding Tools}" MaxHeight="300">
                <ListBox.ItemTemplate>
                    <DataTemplate>
                        <Grid ColumnDefinitions="Auto, *, Auto">
                            <CheckBox IsChecked="{Binding IsEnabled}"
                                      ToolTip.Tip="Enable/disable this tool" />

                            <StackPanel Grid.Column="1" Margin="8,0">
                                <TextBlock Text="{Binding Name}" />
                                <TextBlock Text="{Binding Description}"
                                           FontSize="11"
                                           Foreground="{DynamicResource TextMuted}"
                                           TextTrimming="CharacterEllipsis" />
                            </StackPanel>

                            <ComboBox Grid.Column="2"
                                      ItemsSource="{Binding OverrideOptions}"
                                      SelectedItem="{Binding OverrideAction}"
                                      Width="120" />
                        </Grid>
                    </DataTemplate>
                </ListBox.ItemTemplate>
            </ListBox>
        </StackPanel>

        <!-- Limits -->
        <StackPanel Spacing="12">
            <TextBlock Text="Limits" FontWeight="SemiBold" />

            <Grid ColumnDefinitions="200, *, Auto">
                <TextBlock Text="Max iterations per request" VerticalAlignment="Center" />
                <Slider Grid.Column="1" Minimum="1" Maximum="20"
                        Value="{Binding Config.MaxAgentIterations}" />
                <TextBlock Grid.Column="2"
                           Text="{Binding Config.MaxAgentIterations}"
                           Width="30" TextAlignment="Right" />
            </Grid>

            <Grid ColumnDefinitions="200, *, Auto">
                <TextBlock Text="Tool execution timeout (sec)" VerticalAlignment="Center" />
                <Slider Grid.Column="1" Minimum="10" Maximum="300"
                        Value="{Binding ToolTimeoutSeconds}" />
                <TextBlock Grid.Column="2"
                           Text="{Binding ToolTimeoutSeconds}"
                           Width="30" TextAlignment="Right" />
            </Grid>

            <Grid ColumnDefinitions="200, *, Auto">
                <TextBlock Text="Rate limit (calls/min)" VerticalAlignment="Center" />
                <Slider Grid.Column="1" Minimum="5" Maximum="60"
                        Value="{Binding Policy.RateLimitPerMinute}" />
                <TextBlock Grid.Column="2"
                           Text="{Binding Policy.RateLimitPerMinute}"
                           Width="30" TextAlignment="Right" />
            </Grid>
        </StackPanel>

        <!-- Audit -->
        <StackPanel Spacing="12">
            <TextBlock Text="Audit" FontWeight="SemiBold" />

            <CheckBox Content="Log all tool executions"
                      IsChecked="{Binding Policy.AuditAllExecutions}" />

            <Button Content="View Audit Log"
                    Command="{Binding ViewAuditLogCommand}" />
        </StackPanel>
    </StackPanel>
</UserControl>
```

### Keyboard Shortcuts

| Shortcut | Action |
|----------|--------|
| Ctrl+Shift+A | Toggle agent mode |
| Escape | Cancel current agent execution |
| Enter | Approve pending tool call |
| Ctrl+Enter | Approve and remember for session |
| Backspace | Deny pending tool call |

### Chat Integration

```csharp
namespace SeniorIntern.Desktop.ViewModels;

public partial class ChatViewModel : ViewModelBase
{
    private readonly IAgentService _agentService;

    [ObservableProperty]
    private bool _isAgentMode = true;

    [ObservableProperty]
    private AgentState _agentState = AgentState.Idle;

    [ObservableProperty]
    private ObservableCollection<AgentActivityItem> _agentActivities = new();

    [RelayCommand]
    private async Task SendMessageAsync()
    {
        if (!IsAgentMode)
        {
            // Regular chat (existing behavior)
            await SendRegularMessageAsync();
            return;
        }

        // Agent mode
        var request = new AgentRequest
        {
            Message = UserInput,
            ConversationId = _conversation.Id,
            History = Messages.Select(m => m.ToChatMessage()).ToList(),
            AttachedFiles = AttachedContexts.Select(c => c.ToFileContext()).ToList(),
            SystemPrompt = CurrentSystemPrompt?.Content,
            ToolContext = new ToolAvailabilityContext
            {
                HasWorkspace = _workspaceService.HasOpenWorkspace,
                HasTerminal = _terminalService.Sessions.Count > 0,
                WorkspacePath = _workspaceService.CurrentWorkspace?.RootPath
            }
        };

        UserInput = string.Empty;
        AddUserMessage(request.Message);

        var assistantMessage = new ChatMessageViewModel
        {
            Role = MessageRole.Assistant,
            Content = string.Empty
        };
        Messages.Add(assistantMessage);

        AgentActivities.Clear();

        await foreach (var evt in _agentService.ProcessMessageAsync(request))
        {
            switch (evt)
            {
                case TextGenerationEvent text:
                    assistantMessage.Content += text.Token;
                    break;

                case ApprovalRequestEvent approval:
                    AgentActivities.Add(new AgentActivityItem
                    {
                        Type = ActivityType.Approval,
                        Message = $"Requesting approval: {approval.Summary}"
                    });

                    var decision = await ShowApprovalDialogAsync(approval);
                    approval.ApprovalTask.SetResult(decision);
                    break;

                case ToolExecutionEvent execution:
                    AgentActivities.Add(new AgentActivityItem
                    {
                        Type = ActivityType.Tool,
                        Message = $"Executing: {execution.ToolName}"
                    });
                    break;

                case ToolResultEvent result:
                    var resultActivity = new AgentActivityItem
                    {
                        Type = result.Result.Success ? ActivityType.Success : ActivityType.Error,
                        Message = result.Result.Message
                    };
                    AgentActivities.Add(resultActivity);

                    // Add tool result to message for visibility
                    assistantMessage.ToolResults.Add(new ToolResultDisplay
                    {
                        ToolName = result.ToolId,
                        Success = result.Result.Success,
                        Summary = result.Result.Message
                    });
                    break;

                case AgentErrorEvent error:
                    AgentActivities.Add(new AgentActivityItem
                    {
                        Type = ActivityType.Error,
                        Message = error.Error
                    });
                    break;

                case AgentCompleteEvent complete:
                    AgentActivities.Add(new AgentActivityItem
                    {
                        Type = ActivityType.Success,
                        Message = $"Completed ({complete.ToolCallsExecuted} tools, {complete.TotalDuration.TotalSeconds:F1}s)"
                    });
                    break;
            }

            AgentState = _agentService.State;
        }

        // Save conversation
        await _conversationService.SaveCurrentConversationAsync();
    }

    private async Task<ApprovalDecision> ShowApprovalDialogAsync(ApprovalRequestEvent approval)
    {
        var dialog = new ToolApprovalDialog
        {
            DataContext = new ToolApprovalViewModel(approval.Request)
        };

        var result = await dialog.ShowDialog<ApprovalDecision?>(GetMainWindow());

        return result ?? new ApprovalDecision { Approved = false, Reason = "Dialog closed" };
    }
}
```

### Files to Create (v0.6.5)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/Views/AgentActivityPanel.axaml` | Activity visualization |
| `src/SeniorIntern.Desktop/Views/AgentSettingsPanel.axaml` | Settings UI |
| `src/SeniorIntern.Desktop/ViewModels/AgentSettingsViewModel.cs` | Settings ViewModel |
| `src/SeniorIntern.Desktop/ViewModels/AgentActivityViewModel.cs` | Activity ViewModel |
| `src/SeniorIntern.Desktop/Views/AuditLogViewer.axaml` | Audit log viewer |

### Files to Modify (v0.6.5)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/ViewModels/ChatViewModel.cs` | Add agent mode |
| `src/SeniorIntern.Desktop/Views/ChatView.axaml` | Add agent activity panel |
| `src/SeniorIntern.Desktop/Views/MainWindow.axaml` | Add keyboard shortcuts |
| `src/SeniorIntern.Core/Models/AppSettings.cs` | Add agent settings |

### Testing Strategy (v0.6.5)
- End-to-end agent flow tests
- Multi-step execution tests
- Tool chaining tests
- Cancellation tests
- UI integration tests

---

## Architecture Summary

### Project Structure After v0.6.0

```
SeniorIntern/
├── src/
│   ├── SeniorIntern.Core/
│   │   ├── Tools/
│   │   │   ├── ITool.cs                         [NEW]
│   │   │   ├── ToolBase.cs                      [NEW]
│   │   │   ├── ToolResult.cs                    [NEW]
│   │   │   ├── ToolExecutionContext.cs          [NEW]
│   │   │   ├── JsonSchema.cs                    [NEW]
│   │   │   └── JsonSchemaBuilder.cs             [NEW]
│   │   ├── Models/
│   │   │   ├── AgentEvent.cs                    [NEW]
│   │   │   ├── ToolCallRequest.cs               [NEW]
│   │   │   ├── PermissionPolicy.cs              [NEW]
│   │   │   ├── AuditLogEntry.cs                 [NEW]
│   │   │   └── AppSettings.cs (updated)
│   │   └── Interfaces/
│   │       ├── IToolRegistry.cs                 [NEW]
│   │       ├── IAgentService.cs                 [NEW]
│   │       └── IPermissionManager.cs            [NEW]
│   │
│   ├── SeniorIntern.Services/
│   │   ├── AI/
│   │   │   ├── SemanticKernelConfiguration.cs   [NEW]
│   │   │   ├── AgentService.cs                  [NEW]
│   │   │   └── FunctionCallParser.cs            [NEW]
│   │   ├── Tools/
│   │   │   ├── ReadFileTool.cs                  [NEW]
│   │   │   ├── WriteFileTool.cs                 [NEW]
│   │   │   ├── ListDirectoryTool.cs             [NEW]
│   │   │   ├── RunCommandTool.cs                [NEW]
│   │   │   ├── SearchFilesTool.cs               [NEW]
│   │   │   ├── SearchContentTool.cs             [NEW]
│   │   │   ├── GetWorkspaceInfoTool.cs          [NEW]
│   │   │   └── Git*.cs                          [NEW]
│   │   ├── ToolRegistry.cs                      [NEW]
│   │   ├── PermissionManager.cs                 [NEW]
│   │   ├── RiskClassifier.cs                    [NEW]
│   │   ├── AuditLogger.cs                       [NEW]
│   │   └── BuiltInToolsExtensions.cs            [NEW]
│   │
│   └── SeniorIntern.Desktop/
│       ├── ViewModels/
│       │   ├── ToolApprovalViewModel.cs         [NEW]
│       │   ├── AgentActivityViewModel.cs        [NEW]
│       │   ├── AgentSettingsViewModel.cs        [NEW]
│       │   └── ChatViewModel.cs (updated)
│       └── Views/
│           ├── ToolApprovalDialog.axaml         [NEW]
│           ├── AgentActivityPanel.axaml         [NEW]
│           ├── AgentSettingsPanel.axaml         [NEW]
│           ├── AuditLogViewer.axaml             [NEW]
│           └── ChatView.axaml (updated)
```

### New NuGet Packages (v0.6.0)

| Package | Version | Project | Purpose |
|---------|---------|---------|---------|
| Microsoft.SemanticKernel | 1.x | Services | AI orchestration |
| Microsoft.SemanticKernel.Connectors.OpenAI | 1.x | Services | Function calling |
| LLamaSharp.SemanticKernel | 0.x | Services | SK connector |
| Microsoft.Extensions.FileSystemGlobbing | 8.0.0 | Services | File search |

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| LLM generates harmful commands | Medium | Critical | Multi-layer safety, approval flow |
| Infinite agent loops | Medium | Medium | Max iterations, cancellation |
| Tool execution failures | High | Low | Error handling, graceful degradation |
| Function call parsing errors | Medium | Medium | Multiple parsing strategies, fallbacks |
| User fatigue from approval dialogs | Medium | Low | Remember decisions, smart defaults |
| Performance with many tools | Low | Medium | Lazy loading, tool filtering |

---

## Acceptance Criteria

### v0.6.1
- [ ] Tool framework implemented
- [ ] Tool registry manages tools
- [ ] JSON schema generation works
- [ ] Tool execution produces results

### v0.6.2
- [ ] Semantic Kernel integrated
- [ ] Function calls parsed from LLM output
- [ ] Agent loop iterates correctly
- [ ] Events stream to UI

### v0.6.3
- [ ] All built-in tools implemented
- [ ] File tools work correctly
- [ ] Terminal tool executes commands
- [ ] Search tools find content

### v0.6.4
- [ ] Risk classification accurate
- [ ] Approval dialog appears for risky tools
- [ ] Policy settings saved
- [ ] Audit log captures executions

### v0.6.5
- [ ] Agent mode toggle works
- [ ] Activity panel shows progress
- [ ] Settings panel complete
- [ ] Keyboard shortcuts functional

---

## References

- [Microsoft Semantic Kernel](https://github.com/microsoft/semantic-kernel)
- [Microsoft.Extensions.AI](https://devblogs.microsoft.com/dotnet/introducing-microsoft-extensions-ai-preview/)
- [OpenAI Function Calling](https://platform.openai.com/docs/guides/function-calling)
- [LLamaSharp Semantic Kernel Integration](https://github.com/SciSharp/LLamaSharp)
- [JSON Schema Specification](https://json-schema.org/)
- [ReAct: Reasoning and Acting in LLMs](https://arxiv.org/abs/2210.03629)
