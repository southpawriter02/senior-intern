# Design Specification: AIntern v0.6.3c "File Management Tools"

## Overview

**Version**: v0.6.3c
**Parent**: v0.6.3 Built-in Tools
**Focus**: DeleteFileTool, MoveFileTool, and CopyFileTool for file management

### Purpose

Implement file management tools that enable the AI agent to:
1. Delete files from the workspace (with high-risk confirmation)
2. Move or rename files with automatic directory creation
3. Copy files to new locations
4. Validate paths are within workspace bounds
5. Handle overwrite protection for move/copy operations
6. Generate file artifacts for tracking changes

### Dependencies

**From v0.6.3a (File Read Tools)**:
- `ToolPathHelper` for path validation and resolution
- `PathValidationResult` for validation responses
- `FileInfoResult` for file metadata

**From v0.6.1 (Tool Framework)**:
- `ToolBase`, `ToolResult`, `ToolArtifact`
- `JsonSchemaBuilder`, `RiskLevel`

**From v0.3.x (Workspace Awareness)**:
- `IWorkspaceService`, `IFileSystemService`

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                   v0.6.3c File Management Tools Architecture                  │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  src/SeniorIntern.Services/Tools/FileSystem/                                 │
│  ├─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  DeleteFileTool : ToolBase                                               │ │
│  │  ┌─────────────────────────────────────────────────────────────────────┐│ │
│  │  │  Id: "file-delete"                                                   ││ │
│  │  │  DefaultRiskLevel: High (always)                                     ││ │
│  │  │                                                                      ││ │
│  │  │  Parameters                                                           ││ │
│  │  │  └── path: string (required) - File to delete                        ││ │
│  │  │                                                                      ││ │
│  │  │  Features                                                             ││ │
│  │  │  ├── Path validation (workspace bounds)                              ││ │
│  │  │  ├── File existence check                                            ││ │
│  │  │  └── File size capture before deletion                               ││ │
│  │  └─────────────────────────────────────────────────────────────────────┘│ │
│  │                                                                          │ │
│  │  MoveFileTool : ToolBase                                                 │ │
│  │  ┌─────────────────────────────────────────────────────────────────────┐│ │
│  │  │  Id: "file-move"                                                     ││ │
│  │  │  DefaultRiskLevel: Medium                                            ││ │
│  │  │                                                                      ││ │
│  │  │  Parameters                                                           ││ │
│  │  │  ├── source: string (required) - Current path                        ││ │
│  │  │  ├── destination: string (required) - New path                       ││ │
│  │  │  └── overwrite: bool (default: false)                                ││ │
│  │  │                                                                      ││ │
│  │  │  Features                                                             ││ │
│  │  │  ├── Automatic destination directory creation                        ││ │
│  │  │  ├── Rename detection (same directory)                               ││ │
│  │  │  └── Overwrite protection                                            ││ │
│  │  └─────────────────────────────────────────────────────────────────────┘│ │
│  │                                                                          │ │
│  │  CopyFileTool : ToolBase                                                 │ │
│  │  ┌─────────────────────────────────────────────────────────────────────┐│ │
│  │  │  Id: "file-copy"                                                     ││ │
│  │  │  DefaultRiskLevel: Low                                               ││ │
│  │  │                                                                      ││ │
│  │  │  Parameters                                                           ││ │
│  │  │  ├── source: string (required) - File to copy                        ││ │
│  │  │  ├── destination: string (required) - Destination path               ││ │
│  │  │  └── overwrite: bool (default: false)                                ││ │
│  │  │                                                                      ││ │
│  │  │  Features                                                             ││ │
│  │  │  ├── Automatic destination directory creation                        ││ │
│  │  │  ├── Preserves original file                                         ││ │
│  │  │  └── Returns copied file size                                        ││ │
│  │  └─────────────────────────────────────────────────────────────────────┘│ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  src/SeniorIntern.Core/Models/                                               │
│  ├─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  DeleteFileResultData    MoveFileResultData    CopyFileResultData        │ │
│  │  ├── Path: string        ├── Source: string    ├── Source: string        │ │
│  │  ├── Size: long          ├── Destination       ├── Destination           │ │
│  │  └── DeletedAt: DateTime ├── WasRenamed: bool  ├── Size: long            │ │
│  │                          └── OverwroteExisting └── CopiedAt: DateTime    │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Risk Level Comparison

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                         Risk Level by Tool                                    │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Operation              Risk      Reason                                     │
│  ──────────────────────────────────────────────────────────────────────────  │
│  file-copy              Low       Non-destructive, preserves original        │
│  file-move              Medium    Removes from original location             │
│  file-move (rename)     Medium    Changes file identity                      │
│  file-delete            High      Irreversible data loss (unless git)        │
│                                                                              │
│  Risk Assessment:                                                            │
│  ┌────────────────────────────────────────────────────────────────────────┐ │
│  │  Safe     │ Low      │ Medium   │ High      │ Critical                 │ │
│  │           │ file-copy│ file-move│ file-delete                         │ │
│  │  ◄───────────────────────────────────────────────────────────────────►│ │
│  │  Auto-approve         Prompt recommended      Always prompt            │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Execution Flows

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                       DeleteFileTool Execution Flow                           │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ExecuteAsync(context)                                                       │
│      │                                                                       │
│      ▼                                                                       │
│  ┌─────────────────────────────┐                                             │
│  │  1. Extract path parameter  │                                             │
│  └─────────────┬───────────────┘                                             │
│                │                                                             │
│                ▼                                                             │
│  ┌─────────────────────────────┐                                             │
│  │  2. Resolve & Validate Path │                                             │
│  │  ToolPathHelper.ValidatePath│                                             │
│  └─────────────┬───────────────┘                                             │
│                │                                                             │
│       ┌────────┴────────┐                                                    │
│       │ Invalid         │ Valid                                              │
│       ▼                 ▼                                                    │
│  ┌──────────┐    ┌─────────────────────────────┐                             │
│  │  RETURN  │    │  3. Check File Exists       │                             │
│  │  Failed  │    └─────────────┬───────────────┘                             │
│  └──────────┘                  │                                             │
│                       ┌────────┴────────┐                                    │
│                       │ Not found       │ Found                              │
│                       ▼                 ▼                                    │
│                  ┌──────────┐    ┌─────────────────────────────┐             │
│                  │  RETURN  │    │  4. Get File Info           │             │
│                  │  Failed  │    │  (size for result)          │             │
│                  └──────────┘    └─────────────┬───────────────┘             │
│                                                │                             │
│                                                ▼                             │
│                                  ┌─────────────────────────────┐             │
│                                  │  5. Delete File             │             │
│                                  │  DeleteFileAsync(fullPath)  │             │
│                                  └─────────────┬───────────────┘             │
│                                                │                             │
│                                                ▼                             │
│                                  ┌─────────────────────────────┐             │
│                                  │  6. Return Success          │             │
│                                  │  ├── DeleteFileResultData   │             │
│                                  │  └── "Deleted file: {path}" │             │
│                                  └─────────────────────────────┘             │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────────────────────┐
│                       MoveFileTool Execution Flow                             │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ExecuteAsync(context)                                                       │
│      │                                                                       │
│      ▼                                                                       │
│  ┌─────────────────────────────┐                                             │
│  │  1. Extract Parameters      │                                             │
│  │  source, destination,       │                                             │
│  │  overwrite                  │                                             │
│  └─────────────┬───────────────┘                                             │
│                │                                                             │
│                ▼                                                             │
│  ┌─────────────────────────────┐                                             │
│  │  2. Validate BOTH Paths     │                                             │
│  │  ├── Source in workspace    │                                             │
│  │  └── Dest in workspace      │                                             │
│  └─────────────┬───────────────┘                                             │
│                │                                                             │
│                ▼                                                             │
│  ┌─────────────────────────────┐                                             │
│  │  3. Check Source Exists     │                                             │
│  └─────────────┬───────────────┘                                             │
│                │                                                             │
│                ▼                                                             │
│  ┌─────────────────────────────┐                                             │
│  │  4. Check Destination       │                                             │
│  │  ├── If exists && !overwrite│ → RETURN Failed                             │
│  │  └── If exists && overwrite │ → Continue                                  │
│  └─────────────┬───────────────┘                                             │
│                │                                                             │
│                ▼                                                             │
│  ┌─────────────────────────────┐                                             │
│  │  5. Create Dest Directory   │                                             │
│  │  (if doesn't exist)         │                                             │
│  └─────────────┬───────────────┘                                             │
│                │                                                             │
│                ▼                                                             │
│  ┌─────────────────────────────┐                                             │
│  │  6. Move File               │                                             │
│  │  MoveFileAsync(src, dest)   │                                             │
│  └─────────────┬───────────────┘                                             │
│                │                                                             │
│                ▼                                                             │
│  ┌─────────────────────────────┐                                             │
│  │  7. Return Success          │                                             │
│  │  ├── MoveFileResultData     │                                             │
│  │  ├── File artifact          │                                             │
│  │  └── "Moved: {src} → {dest}"│                                             │
│  └─────────────────────────────┘                                             │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Specifications

### 1. DeleteFileTool.cs

**Location**: `src/SeniorIntern.Services/Tools/FileSystem/DeleteFileTool.cs`

```csharp
namespace SeniorIntern.Services.Tools.FileSystem;

using System.Text.Json;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Core.Tools;
using SeniorIntern.Services.Tools;

/// <summary>
/// Tool for deleting files from the workspace.
/// </summary>
/// <remarks>
/// <para>
/// DeleteFileTool is a high-risk operation that permanently removes files.
/// The operation cannot be undone unless the file is under version control.
/// </para>
/// <para>
/// Always requires user approval due to its destructive nature.
/// </para>
/// </remarks>
public sealed class DeleteFileTool : ToolBase
{
    #region Tool Metadata

    public override string Id => "file-delete";

    public override string Name => "Delete File";

    public override string Description => """
        Delete a file from the workspace.
        This operation cannot be undone (unless the file is under version control).

        Use with caution. Consider whether the file should be removed or renamed instead.
        """;

    public override ToolCategory Category => ToolCategory.FileSystem;

    public override RiskLevel DefaultRiskLevel => RiskLevel.High;

    public override IReadOnlyList<string> Tags => new[] { "file", "delete", "remove" };

    public override JsonSchema InputSchema => JsonSchemaBuilder.Create()
        .WithDescription("Parameters for deleting a file")
        .AddString("path", "Relative path to the file to delete", required: true)
        .Build();

    #endregion

    #region Dependencies

    private readonly IFileSystemService _fileSystem;
    private readonly IWorkspaceService _workspace;
    private readonly ILogger<DeleteFileTool> _logger;

    #endregion

    public DeleteFileTool(
        IFileSystemService fileSystem,
        IWorkspaceService workspace,
        ILogger<DeleteFileTool> logger)
    {
        _fileSystem = fileSystem ?? throw new ArgumentNullException(nameof(fileSystem));
        _workspace = workspace ?? throw new ArgumentNullException(nameof(workspace));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    public override bool IsAvailable => _workspace.CurrentWorkspace != null;

    #region ExecuteAsync

    public override async Task<ToolResult> ExecuteAsync(
        ToolExecutionContext context,
        CancellationToken ct = default)
    {
        var path = GetRequiredParameter<string>(context.Parameters, "path");

        _logger.LogDebug("DeleteFileTool executing: path={Path}", path);

        // Resolve and validate path
        var fullPath = ToolPathHelper.ResolvePath(context.WorkspacePath, path);
        var pathValidation = ToolPathHelper.ValidatePath(fullPath, context.WorkspacePath);

        if (!pathValidation.IsValid)
        {
            _logger.LogWarning("Path validation failed: {Error}", pathValidation.ErrorMessage);
            return ToolResult.Failed(pathValidation.ErrorMessage!);
        }

        // Check file exists
        if (!await _fileSystem.FileExistsAsync(fullPath, ct))
        {
            _logger.LogWarning("File not found for deletion: {Path}", path);
            return ToolResult.Failed($"File not found: {path}");
        }

        try
        {
            // Get file info before deletion (for result data)
            var fileInfo = await _fileSystem.GetFileInfoAsync(fullPath, ct);

            // Delete the file
            await _fileSystem.DeleteFileAsync(fullPath, ct);

            var resultData = new DeleteFileResultData
            {
                Path = path,
                Size = fileInfo.Size,
                DeletedAt = DateTime.UtcNow
            };

            _logger.LogInformation(
                "DeleteFileTool success: {Path}, size={Size}",
                path, fileInfo.Size);

            return ToolResult.Success(
                content: null,
                resultData,
                $"Deleted file: {path} ({ToolPathHelper.FormatFileSize(fileInfo.Size)})");
        }
        catch (UnauthorizedAccessException ex)
        {
            _logger.LogWarning(ex, "Access denied to delete file: {Path}", path);
            return ToolResult.Failed($"Access denied: {path}");
        }
        catch (IOException ex)
        {
            _logger.LogError(ex, "Failed to delete file: {Path}", path);
            return ToolResult.Failed($"Failed to delete file: {ex.Message}");
        }
    }

    #endregion

    #region Overrides

    public override string GetExecutionSummary(JsonElement parameters)
    {
        var path = parameters.TryGetProperty("path", out var p)
            ? p.GetString() ?? "unknown"
            : "unknown";
        var shortPath = path.Length > 40 ? "..." + path[^37..] : path;
        return $"Delete file '{shortPath}'";
    }

    public override RiskLevel GetEffectiveRiskLevel(JsonElement parameters)
    {
        // Deletion is always high risk
        return RiskLevel.High;
    }

    public override ToolValidationResult Validate(JsonElement parameters)
    {
        var errors = new List<ToolValidationError>();

        if (!parameters.TryGetProperty("path", out var pathProp) ||
            string.IsNullOrWhiteSpace(pathProp.GetString()))
        {
            errors.Add(ToolValidationError.Required("path"));
        }

        return errors.Count > 0
            ? ToolValidationResult.Invalid(errors)
            : ToolValidationResult.Valid();
    }

    #endregion
}
```

### 2. MoveFileTool.cs

**Location**: `src/SeniorIntern.Services/Tools/FileSystem/MoveFileTool.cs`

```csharp
namespace SeniorIntern.Services.Tools.FileSystem;

using System.Text.Json;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Core.Tools;
using SeniorIntern.Services.Tools;

/// <summary>
/// Tool for moving or renaming files in the workspace.
/// </summary>
/// <remarks>
/// <para>
/// MoveFileTool supports both moving files to new directories and renaming
/// files within the same directory. Parent directories are created automatically.
/// </para>
/// </remarks>
public sealed class MoveFileTool : ToolBase
{
    #region Tool Metadata

    public override string Id => "file-move";

    public override string Name => "Move/Rename File";

    public override string Description => """
        Move a file to a new location or rename it.
        Creates parent directories for the destination automatically.

        Use this to:
        - Rename files
        - Move files to different directories
        - Reorganize project structure
        """;

    public override ToolCategory Category => ToolCategory.FileSystem;

    public override RiskLevel DefaultRiskLevel => RiskLevel.Medium;

    public override IReadOnlyList<string> Tags => new[] { "file", "move", "rename", "relocate" };

    public override JsonSchema InputSchema => JsonSchemaBuilder.Create()
        .WithDescription("Parameters for moving a file")
        .AddString("source", "Current path of the file", required: true)
        .AddString("destination", "New path for the file", required: true)
        .AddBoolean("overwrite", "Overwrite if destination exists (default: false)", required: false)
        .Build();

    #endregion

    #region Dependencies

    private readonly IFileSystemService _fileSystem;
    private readonly IWorkspaceService _workspace;
    private readonly ILogger<MoveFileTool> _logger;

    #endregion

    public MoveFileTool(
        IFileSystemService fileSystem,
        IWorkspaceService workspace,
        ILogger<MoveFileTool> logger)
    {
        _fileSystem = fileSystem ?? throw new ArgumentNullException(nameof(fileSystem));
        _workspace = workspace ?? throw new ArgumentNullException(nameof(workspace));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    public override bool IsAvailable => _workspace.CurrentWorkspace != null;

    #region ExecuteAsync

    public override async Task<ToolResult> ExecuteAsync(
        ToolExecutionContext context,
        CancellationToken ct = default)
    {
        var source = GetRequiredParameter<string>(context.Parameters, "source");
        var destination = GetRequiredParameter<string>(context.Parameters, "destination");
        var overwrite = GetOptionalParameter(context.Parameters, "overwrite", false);

        _logger.LogDebug(
            "MoveFileTool executing: source={Source}, dest={Dest}, overwrite={Overwrite}",
            source, destination, overwrite);

        // Resolve and validate both paths
        var sourcePath = ToolPathHelper.ResolvePath(context.WorkspacePath, source);
        var destPath = ToolPathHelper.ResolvePath(context.WorkspacePath, destination);

        var sourceValidation = ToolPathHelper.ValidatePath(sourcePath, context.WorkspacePath);
        if (!sourceValidation.IsValid)
        {
            return ToolResult.Failed($"Invalid source: {sourceValidation.ErrorMessage}");
        }

        var destValidation = ToolPathHelper.ValidatePath(destPath, context.WorkspacePath);
        if (!destValidation.IsValid)
        {
            return ToolResult.Failed($"Invalid destination: {destValidation.ErrorMessage}");
        }

        // Check source exists
        if (!await _fileSystem.FileExistsAsync(sourcePath, ct))
        {
            return ToolResult.Failed($"Source file not found: {source}");
        }

        // Check destination
        var destExists = await _fileSystem.FileExistsAsync(destPath, ct);
        if (destExists && !overwrite)
        {
            return ToolResult.Failed(
                $"Destination already exists: {destination}. Set overwrite=true to replace.");
        }

        try
        {
            // Create destination directory if needed
            var destDir = Path.GetDirectoryName(destPath);
            if (!string.IsNullOrEmpty(destDir) && !await _fileSystem.DirectoryExistsAsync(destDir, ct))
            {
                await _fileSystem.CreateDirectoryAsync(destDir, ct);
                _logger.LogDebug("Created destination directory: {Dir}", destDir);
            }

            // Determine if this is a rename (same directory)
            var isRename = Path.GetDirectoryName(sourcePath) == Path.GetDirectoryName(destPath);

            // Move the file
            await _fileSystem.MoveFileAsync(sourcePath, destPath, overwrite, ct);

            var resultData = new MoveFileResultData
            {
                Source = source,
                Destination = destination,
                WasRenamed = isRename,
                OverwroteExisting = destExists && overwrite,
                MovedAt = DateTime.UtcNow
            };

            var message = isRename
                ? $"Renamed: {Path.GetFileName(source)} → {Path.GetFileName(destination)}"
                : $"Moved: {source} → {destination}";

            _logger.LogInformation(
                "MoveFileTool success: {Source} → {Dest}, rename={IsRename}",
                source, destination, isRename);

            return ToolResult.Success(content: null, resultData, message)
                .WithArtifact(new ToolArtifact
                {
                    Type = ToolArtifactType.File,
                    Path = destPath,
                    Description = isRename ? "Renamed file" : "Moved file"
                });
        }
        catch (UnauthorizedAccessException ex)
        {
            _logger.LogWarning(ex, "Access denied for move: {Source} → {Dest}", source, destination);
            return ToolResult.Failed($"Access denied: {ex.Message}");
        }
        catch (IOException ex)
        {
            _logger.LogError(ex, "Failed to move file: {Source} → {Dest}", source, destination);
            return ToolResult.Failed($"Failed to move file: {ex.Message}");
        }
    }

    #endregion

    #region Overrides

    public override string GetExecutionSummary(JsonElement parameters)
    {
        var source = parameters.TryGetProperty("source", out var s)
            ? s.GetString() ?? "?"
            : "?";
        var dest = parameters.TryGetProperty("destination", out var d)
            ? d.GetString() ?? "?"
            : "?";

        var shortSource = Path.GetFileName(source);
        var shortDest = Path.GetFileName(dest);

        // Check if same directory (rename)
        var sourceDir = Path.GetDirectoryName(source);
        var destDir = Path.GetDirectoryName(dest);

        if (sourceDir == destDir)
        {
            return $"Rename '{shortSource}' to '{shortDest}'";
        }

        return $"Move '{shortSource}' to '{dest}'";
    }

    public override ToolValidationResult Validate(JsonElement parameters)
    {
        var errors = new List<ToolValidationError>();

        if (!parameters.TryGetProperty("source", out var sourceProp) ||
            string.IsNullOrWhiteSpace(sourceProp.GetString()))
        {
            errors.Add(ToolValidationError.Required("source"));
        }

        if (!parameters.TryGetProperty("destination", out var destProp) ||
            string.IsNullOrWhiteSpace(destProp.GetString()))
        {
            errors.Add(ToolValidationError.Required("destination"));
        }

        // Check source != destination
        if (sourceProp.GetString() == destProp.GetString())
        {
            errors.Add(new ToolValidationError
            {
                ParameterName = "destination",
                Message = "Destination must be different from source",
                Code = "SAME_PATH"
            });
        }

        return errors.Count > 0
            ? ToolValidationResult.Invalid(errors)
            : ToolValidationResult.Valid();
    }

    #endregion
}
```

### 3. CopyFileTool.cs

**Location**: `src/SeniorIntern.Services/Tools/FileSystem/CopyFileTool.cs`

```csharp
namespace SeniorIntern.Services.Tools.FileSystem;

using System.Text.Json;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Core.Tools;
using SeniorIntern.Services.Tools;

/// <summary>
/// Tool for copying files within the workspace.
/// </summary>
/// <remarks>
/// <para>
/// CopyFileTool duplicates files to new locations. The original file
/// remains unchanged. This is a low-risk operation since no data is lost.
/// </para>
/// </remarks>
public sealed class CopyFileTool : ToolBase
{
    #region Tool Metadata

    public override string Id => "file-copy";

    public override string Name => "Copy File";

    public override string Description => """
        Copy a file to a new location.
        Creates parent directories for the destination automatically.

        The original file remains unchanged.
        """;

    public override ToolCategory Category => ToolCategory.FileSystem;

    public override RiskLevel DefaultRiskLevel => RiskLevel.Low;

    public override IReadOnlyList<string> Tags => new[] { "file", "copy", "duplicate" };

    public override JsonSchema InputSchema => JsonSchemaBuilder.Create()
        .WithDescription("Parameters for copying a file")
        .AddString("source", "Path of the file to copy", required: true)
        .AddString("destination", "Destination path for the copy", required: true)
        .AddBoolean("overwrite", "Overwrite if destination exists (default: false)", required: false)
        .Build();

    #endregion

    #region Dependencies

    private readonly IFileSystemService _fileSystem;
    private readonly IWorkspaceService _workspace;
    private readonly ILogger<CopyFileTool> _logger;

    #endregion

    public CopyFileTool(
        IFileSystemService fileSystem,
        IWorkspaceService workspace,
        ILogger<CopyFileTool> logger)
    {
        _fileSystem = fileSystem ?? throw new ArgumentNullException(nameof(fileSystem));
        _workspace = workspace ?? throw new ArgumentNullException(nameof(workspace));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    public override bool IsAvailable => _workspace.CurrentWorkspace != null;

    #region ExecuteAsync

    public override async Task<ToolResult> ExecuteAsync(
        ToolExecutionContext context,
        CancellationToken ct = default)
    {
        var source = GetRequiredParameter<string>(context.Parameters, "source");
        var destination = GetRequiredParameter<string>(context.Parameters, "destination");
        var overwrite = GetOptionalParameter(context.Parameters, "overwrite", false);

        _logger.LogDebug(
            "CopyFileTool executing: source={Source}, dest={Dest}, overwrite={Overwrite}",
            source, destination, overwrite);

        // Resolve and validate paths
        var sourcePath = ToolPathHelper.ResolvePath(context.WorkspacePath, source);
        var destPath = ToolPathHelper.ResolvePath(context.WorkspacePath, destination);

        var sourceValidation = ToolPathHelper.ValidatePath(sourcePath, context.WorkspacePath);
        if (!sourceValidation.IsValid)
        {
            return ToolResult.Failed($"Invalid source: {sourceValidation.ErrorMessage}");
        }

        var destValidation = ToolPathHelper.ValidatePath(destPath, context.WorkspacePath);
        if (!destValidation.IsValid)
        {
            return ToolResult.Failed($"Invalid destination: {destValidation.ErrorMessage}");
        }

        // Check source exists
        if (!await _fileSystem.FileExistsAsync(sourcePath, ct))
        {
            return ToolResult.Failed($"Source file not found: {source}");
        }

        // Check destination
        var destExists = await _fileSystem.FileExistsAsync(destPath, ct);
        if (destExists && !overwrite)
        {
            return ToolResult.Failed(
                $"Destination already exists: {destination}. Set overwrite=true to replace.");
        }

        try
        {
            // Create destination directory if needed
            var destDir = Path.GetDirectoryName(destPath);
            if (!string.IsNullOrEmpty(destDir) && !await _fileSystem.DirectoryExistsAsync(destDir, ct))
            {
                await _fileSystem.CreateDirectoryAsync(destDir, ct);
                _logger.LogDebug("Created destination directory: {Dir}", destDir);
            }

            // Copy the file
            await _fileSystem.CopyFileAsync(sourcePath, destPath, overwrite, ct);

            // Get copied file info
            var fileInfo = await _fileSystem.GetFileInfoAsync(destPath, ct);

            var resultData = new CopyFileResultData
            {
                Source = source,
                Destination = destination,
                Size = fileInfo.Size,
                OverwroteExisting = destExists && overwrite,
                CopiedAt = DateTime.UtcNow
            };

            _logger.LogInformation(
                "CopyFileTool success: {Source} → {Dest}, size={Size}",
                source, destination, fileInfo.Size);

            return ToolResult.Success(
                content: null,
                resultData,
                $"Copied: {source} → {destination} ({ToolPathHelper.FormatFileSize(fileInfo.Size)})")
                .WithArtifact(new ToolArtifact
                {
                    Type = ToolArtifactType.File,
                    Path = destPath,
                    Description = "Copied file"
                });
        }
        catch (UnauthorizedAccessException ex)
        {
            _logger.LogWarning(ex, "Access denied for copy: {Source} → {Dest}", source, destination);
            return ToolResult.Failed($"Access denied: {ex.Message}");
        }
        catch (IOException ex)
        {
            _logger.LogError(ex, "Failed to copy file: {Source} → {Dest}", source, destination);
            return ToolResult.Failed($"Failed to copy file: {ex.Message}");
        }
    }

    #endregion

    #region Overrides

    public override string GetExecutionSummary(JsonElement parameters)
    {
        var source = parameters.TryGetProperty("source", out var s)
            ? Path.GetFileName(s.GetString() ?? "?")
            : "?";
        var dest = parameters.TryGetProperty("destination", out var d)
            ? d.GetString() ?? "?"
            : "?";

        return $"Copy '{source}' to '{dest}'";
    }

    public override ToolValidationResult Validate(JsonElement parameters)
    {
        var errors = new List<ToolValidationError>();

        if (!parameters.TryGetProperty("source", out var sourceProp) ||
            string.IsNullOrWhiteSpace(sourceProp.GetString()))
        {
            errors.Add(ToolValidationError.Required("source"));
        }

        if (!parameters.TryGetProperty("destination", out var destProp) ||
            string.IsNullOrWhiteSpace(destProp.GetString()))
        {
            errors.Add(ToolValidationError.Required("destination"));
        }

        // Check source != destination
        if (sourceProp.GetString() == destProp.GetString())
        {
            errors.Add(new ToolValidationError
            {
                ParameterName = "destination",
                Message = "Destination must be different from source",
                Code = "SAME_PATH"
            });
        }

        return errors.Count > 0
            ? ToolValidationResult.Invalid(errors)
            : ToolValidationResult.Valid();
    }

    #endregion
}
```

### 4. Result Data Models

**Location**: `src/SeniorIntern.Core/Models/FileManagementResultData.cs`

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Result data for file delete operations.
/// </summary>
public sealed class DeleteFileResultData
{
    /// <summary>Relative path of deleted file.</summary>
    public string Path { get; init; } = string.Empty;

    /// <summary>Size of deleted file in bytes.</summary>
    public long Size { get; init; }

    /// <summary>When the file was deleted.</summary>
    public DateTime DeletedAt { get; init; }

    /// <summary>Human-readable size.</summary>
    public string FormattedSize => ToolPathHelper.FormatFileSize(Size);
}

/// <summary>
/// Result data for file move operations.
/// </summary>
public sealed class MoveFileResultData
{
    /// <summary>Original path.</summary>
    public string Source { get; init; } = string.Empty;

    /// <summary>New path.</summary>
    public string Destination { get; init; } = string.Empty;

    /// <summary>Whether this was a rename (same directory).</summary>
    public bool WasRenamed { get; init; }

    /// <summary>Whether an existing file was overwritten.</summary>
    public bool OverwroteExisting { get; init; }

    /// <summary>When the file was moved.</summary>
    public DateTime MovedAt { get; init; }
}

/// <summary>
/// Result data for file copy operations.
/// </summary>
public sealed class CopyFileResultData
{
    /// <summary>Source file path.</summary>
    public string Source { get; init; } = string.Empty;

    /// <summary>Destination path.</summary>
    public string Destination { get; init; } = string.Empty;

    /// <summary>Size of copied file in bytes.</summary>
    public long Size { get; init; }

    /// <summary>Whether an existing file was overwritten.</summary>
    public bool OverwroteExisting { get; init; }

    /// <summary>When the file was copied.</summary>
    public DateTime CopiedAt { get; init; }

    /// <summary>Human-readable size.</summary>
    public string FormattedSize => ToolPathHelper.FormatFileSize(Size);
}
```

---

## IFileSystemService Extensions

Add these methods to the existing `IFileSystemService` interface:

```csharp
// In src/SeniorIntern.Core/Interfaces/IFileSystemService.cs

/// <summary>
/// Delete a file.
/// </summary>
Task DeleteFileAsync(string path, CancellationToken ct = default);

/// <summary>
/// Move a file to a new location.
/// </summary>
Task MoveFileAsync(string sourcePath, string destPath, bool overwrite, CancellationToken ct = default);

/// <summary>
/// Copy a file to a new location.
/// </summary>
Task CopyFileAsync(string sourcePath, string destPath, bool overwrite, CancellationToken ct = default);
```

---

## File Summary

| File | Location | Purpose | Lines |
|------|----------|---------|-------|
| `DeleteFileTool.cs` | `Services/Tools/FileSystem/` | Delete files | ~140 |
| `MoveFileTool.cs` | `Services/Tools/FileSystem/` | Move/rename files | ~180 |
| `CopyFileTool.cs` | `Services/Tools/FileSystem/` | Copy files | ~170 |
| `FileManagementResultData.cs` | `Core/Models/` | Result data models | ~60 |

---

## Unit Test Plan

| Test | Description |
|------|-------------|
| `DeleteFileTool_ExistingFile_DeletesSuccessfully` | Basic deletion |
| `DeleteFileTool_NonExistent_ReturnsError` | Missing file |
| `DeleteFileTool_OutsideWorkspace_Blocked` | Security check |
| `DeleteFileTool_RiskLevel_AlwaysHigh` | Risk assessment |
| `MoveFileTool_ValidPaths_MovesFile` | Basic move |
| `MoveFileTool_SameDirectory_DetectsRename` | Rename detection |
| `MoveFileTool_DestExists_RequiresOverwrite` | Overwrite protection |
| `MoveFileTool_CreatesDirs_WhenNeeded` | Directory creation |
| `CopyFileTool_ValidPaths_CopiesFile` | Basic copy |
| `CopyFileTool_PreservesOriginal_AfterCopy` | Original unchanged |
| `CopyFileTool_DestExists_RequiresOverwrite` | Overwrite protection |
| `CopyFileTool_SamePath_RejectsWithError` | Same path validation |

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | DeleteFileTool removes files with confirmation |
| AC-2 | MoveFileTool relocates files to new paths |
| AC-3 | MoveFileTool renames files in same directory |
| AC-4 | CopyFileTool duplicates files |
| AC-5 | All tools validate paths are within workspace |
| AC-6 | Overwrite protection works correctly |

---

## Changelog Entry

```markdown
## v0.6.3c - File Management Tools

### Added
- `DeleteFileTool` for removing files from workspace
  - High risk level (always requires approval)
  - Returns deleted file size
  - Validates path within workspace
- `MoveFileTool` for moving and renaming files
  - Automatic destination directory creation
  - Rename detection (same directory move)
  - Overwrite protection
- `CopyFileTool` for duplicating files
  - Low risk level (non-destructive)
  - Automatic destination directory creation
  - Returns copied file size
- Result data models for each operation
- IFileSystemService extensions for file operations
```

---

## Timeline Estimate

| Version | Estimated Effort |
|---------|------------------|
| v0.6.3c | 0.5 day |
