# Design Specification: AIntern v0.6.4g "Audit Log Storage"

## Overview

**Version**: v0.6.4g
**Parent**: v0.6.4 Safety & Approval
**Focus**: Database schema and repository for persistent audit log storage

### Purpose

Implement the audit log persistence layer that:
1. Stores audit entries in SQLite database
2. Provides efficient indexing for common queries
3. Implements comprehensive filtering and searching
4. Supports automatic retention management
5. Enables statistics aggregation
6. Allows export to JSON files

### Dependencies

**From v0.6.4f (Audit Log Models)**:
- `AuditLogEntry`
- `AuditDecision`
- `AuditLogQuery`, `AuditLogSortOrder`
- `AuditLogStatistics`
- `RiskFactor`

**From v0.6.4a (Permission Policy Models)**:
- `PermissionPolicy` (AuditRetentionDays)

**From Existing Data Layer**:
- `AppDbContext`
- EF Core migrations infrastructure

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                     v0.6.4g Audit Log Storage Architecture                    │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Data Flow:                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │   PermissionManager                       IAuditLogRepository            │ │
│  │         │                                        ▲                       │ │
│  │         │ RecordAuditAsync(entry)                │                       │ │
│  │         ▼                                        │                       │ │
│  │   AuditLogEntry ───────────────────────► AuditLogRepository              │ │
│  │   (Domain Model)                         ├── AddAsync()                  │ │
│  │                                          ├── QueryAsync()                │ │
│  │                                          ├── CountAsync()                │ │
│  │                                          ├── DeleteOlderThanAsync()      │ │
│  │                                          ├── GetStatisticsAsync()        │ │
│  │                                          └── ExportAsync()               │ │
│  │                                                  │                       │ │
│  │                                                  ▼                       │ │
│  │                                          AuditLogEntity                  │ │
│  │                                          (Database Entity)               │ │
│  │                                                  │                       │ │
│  │                                                  ▼                       │ │
│  │                                          AppDbContext                    │ │
│  │                                          └── DbSet<AuditLogEntity>      │ │
│  │                                                  │                       │ │
│  │                                                  ▼                       │ │
│  │                                          SQLite Database                 │ │
│  │                                          └── AuditLog table             │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Database Schema

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                         AuditLog Table Schema                                 │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Table: AuditLog                                                             │
│  ┌─────────────────────────┬───────────────┬────────────────────────────────┐│
│  │ Column                  │ Type          │ Notes                          ││
│  ├─────────────────────────┼───────────────┼────────────────────────────────┤│
│  │ Id                      │ TEXT          │ PRIMARY KEY (GUID as string)   ││
│  │ Timestamp               │ TEXT          │ NOT NULL (ISO 8601 format)     ││
│  │ ToolId                  │ TEXT          │ NOT NULL                       ││
│  │ ToolName                │ TEXT          │ NOT NULL                       ││
│  │ ToolCategory            │ INTEGER       │ NOT NULL (enum)                ││
│  │ RiskLevel               │ INTEGER       │ NOT NULL (enum)                ││
│  │ Decision                │ INTEGER       │ NOT NULL (enum)                ││
│  │ DenialReason            │ TEXT          │ NULL                           ││
│  │ Parameters              │ TEXT          │ NOT NULL (JSON)                ││
│  │ ExecutionSummary        │ TEXT          │ NOT NULL                       ││
│  │ RiskFactorsJson         │ TEXT          │ NULL (JSON array)              ││
│  │ ConversationId          │ TEXT          │ NULL (GUID as string)          ││
│  │ RequestId               │ TEXT          │ NULL (GUID as string)          ││
│  │ PermissionSource        │ INTEGER       │ NOT NULL (enum)                ││
│  │ ExecutionSuccess        │ INTEGER       │ NULL (bool: 0/1/NULL)          ││
│  │ ExecutionError          │ TEXT          │ NULL                           ││
│  │ ExecutionDurationMs     │ INTEGER       │ NULL                           ││
│  │ ResultSummary           │ TEXT          │ NULL                           ││
│  └─────────────────────────┴───────────────┴────────────────────────────────┘│
│                                                                              │
│  Indexes:                                                                    │
│  ├── IX_AuditLog_Timestamp ON (Timestamp DESC)        [main query index]   │
│  ├── IX_AuditLog_ToolId ON (ToolId)                   [tool filter]        │
│  ├── IX_AuditLog_Decision ON (Decision)               [decision filter]    │
│  ├── IX_AuditLog_RiskLevel ON (RiskLevel)             [risk filter]        │
│  ├── IX_AuditLog_ConversationId ON (ConversationId)   [context filter]     │
│  └── IX_AuditLog_Composite ON (Timestamp DESC, ToolId) [combined query]    │
│                                                                              │
│  Estimated Row Size: ~500 bytes average                                      │
│  Index Overhead: ~100 bytes per row                                          │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Query Filter Flow

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                      QueryAsync Filter Application                            │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  AuditLogQuery                                                               │
│      │                                                                       │
│      ▼                                                                       │
│  ┌─────────────────────────────────────┐                                     │
│  │ 1. Date Range Filter                │                                     │
│  │    WHERE Timestamp >= StartDate    │                                     │
│  │    AND Timestamp < EndDate         │                                     │
│  └─────────────────┬───────────────────┘                                     │
│                    ▼                                                          │
│  ┌─────────────────────────────────────┐                                     │
│  │ 2. Tool Filter                      │                                     │
│  │    AND ToolId = @ToolId            │                                     │
│  │    AND ToolCategory = @Category    │                                     │
│  └─────────────────┬───────────────────┘                                     │
│                    ▼                                                          │
│  ┌─────────────────────────────────────┐                                     │
│  │ 3. Decision Filter                  │                                     │
│  │    AND Decision = @Decision        │                                     │
│  │    AND RiskLevel >= @MinRiskLevel  │                                     │
│  └─────────────────┬───────────────────┘                                     │
│                    ▼                                                          │
│  ┌─────────────────────────────────────┐                                     │
│  │ 4. Context Filter                   │                                     │
│  │    AND ConversationId = @ConvId    │                                     │
│  │    AND ExecutionSuccess = false    │  (OnlyFailures)                     │
│  │    AND ExecutionSuccess IS NOT NULL│  (OnlyExecuted)                     │
│  └─────────────────┬───────────────────┘                                     │
│                    ▼                                                          │
│  ┌─────────────────────────────────────┐                                     │
│  │ 5. Text Search                      │                                     │
│  │    AND ExecutionSummary LIKE '%x%' │                                     │
│  └─────────────────┬───────────────────┘                                     │
│                    ▼                                                          │
│  ┌─────────────────────────────────────┐                                     │
│  │ 6. Sorting                          │                                     │
│  │    ORDER BY Timestamp DESC         │  (NewestFirst)                      │
│  │    ORDER BY Timestamp ASC          │  (OldestFirst)                      │
│  │    ORDER BY RiskLevel DESC, ...    │  (RiskLevelDesc)                    │
│  │    ORDER BY ExecutionDurationMs... │  (DurationDesc)                     │
│  └─────────────────┬───────────────────┘                                     │
│                    ▼                                                          │
│  ┌─────────────────────────────────────┐                                     │
│  │ 7. Pagination                       │                                     │
│  │    OFFSET @Skip                    │                                     │
│  │    LIMIT @Take                     │                                     │
│  └─────────────────────────────────────┘                                     │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Specifications

### 1. AuditLogEntity.cs

**Location**: `src/SeniorIntern.Data/Entities/AuditLogEntity.cs`

```csharp
namespace SeniorIntern.Data.Entities;

using System.Text.Json;
using SeniorIntern.Core.Models.Permissions;
using SeniorIntern.Core.Tools;

/// <summary>
/// Entity for storing audit log entries in the database.
/// </summary>
/// <remarks>
/// Maps to the AuditLog table. Uses string/integer representations
/// for GUIDs and enums to ensure SQLite compatibility.
/// </remarks>
public sealed class AuditLogEntity
{
    #region Identification

    /// <summary>
    /// Unique identifier (stored as string).
    /// </summary>
    public string Id { get; set; } = string.Empty;

    /// <summary>
    /// When this event occurred (stored as ISO 8601 string).
    /// </summary>
    public DateTime Timestamp { get; set; }

    /// <summary>
    /// Associated conversation ID (stored as string).
    /// </summary>
    public string? ConversationId { get; set; }

    /// <summary>
    /// Request ID within the agent loop (stored as string).
    /// </summary>
    public string? RequestId { get; set; }

    #endregion

    #region Tool Information

    /// <summary>
    /// ID of the tool involved.
    /// </summary>
    public string ToolId { get; set; } = string.Empty;

    /// <summary>
    /// Display name of the tool.
    /// </summary>
    public string ToolName { get; set; } = string.Empty;

    /// <summary>
    /// Category of the tool (stored as integer).
    /// </summary>
    public int ToolCategory { get; set; }

    #endregion

    #region Risk & Decision

    /// <summary>
    /// Risk level at the time of the call (stored as integer).
    /// </summary>
    public int RiskLevel { get; set; }

    /// <summary>
    /// Decision that was made (stored as integer).
    /// </summary>
    public int Decision { get; set; }

    /// <summary>
    /// Source of the permission decision (stored as integer).
    /// </summary>
    public int PermissionSource { get; set; }

    /// <summary>
    /// Reason for denial (if denied).
    /// </summary>
    public string? DenialReason { get; set; }

    /// <summary>
    /// Risk factors as JSON array.
    /// </summary>
    public string? RiskFactorsJson { get; set; }

    #endregion

    #region Parameters & Summary

    /// <summary>
    /// Tool parameters as JSON string.
    /// </summary>
    public string Parameters { get; set; } = "{}";

    /// <summary>
    /// Human-readable summary of the operation.
    /// </summary>
    public string ExecutionSummary { get; set; } = string.Empty;

    #endregion

    #region Execution Results

    /// <summary>
    /// Whether execution succeeded (null if not executed).
    /// </summary>
    public bool? ExecutionSuccess { get; set; }

    /// <summary>
    /// Error message if execution failed.
    /// </summary>
    public string? ExecutionError { get; set; }

    /// <summary>
    /// Execution duration in milliseconds.
    /// </summary>
    public long? ExecutionDurationMs { get; set; }

    /// <summary>
    /// Brief description of the result.
    /// </summary>
    public string? ResultSummary { get; set; }

    #endregion

    #region Mapping Methods

    /// <summary>
    /// Convert entity to domain model.
    /// </summary>
    public AuditLogEntry ToModel()
    {
        return new AuditLogEntry
        {
            Id = Guid.Parse(Id),
            Timestamp = Timestamp,
            ToolId = ToolId,
            ToolName = ToolName,
            ToolCategory = (ToolCategory)ToolCategory,
            RiskLevel = (RiskLevel)RiskLevel,
            Decision = (AuditDecision)Decision,
            PermissionSource = (PermissionSource)PermissionSource,
            DenialReason = DenialReason,
            Parameters = ParseParameters(),
            ExecutionSummary = ExecutionSummary,
            RiskFactors = ParseRiskFactors(),
            ConversationId = ParseGuid(ConversationId),
            RequestId = ParseGuid(RequestId),
            ExecutionSuccess = ExecutionSuccess,
            ExecutionError = ExecutionError,
            ExecutionDuration = ExecutionDurationMs.HasValue
                ? TimeSpan.FromMilliseconds(ExecutionDurationMs.Value)
                : null,
            ResultSummary = ResultSummary
        };
    }

    /// <summary>
    /// Create entity from domain model.
    /// </summary>
    public static AuditLogEntity FromModel(AuditLogEntry entry)
    {
        return new AuditLogEntity
        {
            Id = entry.Id.ToString(),
            Timestamp = entry.Timestamp,
            ToolId = entry.ToolId,
            ToolName = entry.ToolName,
            ToolCategory = (int)entry.ToolCategory,
            RiskLevel = (int)entry.RiskLevel,
            Decision = (int)entry.Decision,
            PermissionSource = (int)entry.PermissionSource,
            DenialReason = entry.DenialReason,
            Parameters = SerializeParameters(entry.Parameters),
            ExecutionSummary = entry.ExecutionSummary,
            RiskFactorsJson = SerializeRiskFactors(entry.RiskFactors),
            ConversationId = entry.ConversationId?.ToString(),
            RequestId = entry.RequestId?.ToString(),
            ExecutionSuccess = entry.ExecutionSuccess,
            ExecutionError = entry.ExecutionError,
            ExecutionDurationMs = entry.ExecutionDuration.HasValue
                ? (long)entry.ExecutionDuration.Value.TotalMilliseconds
                : null,
            ResultSummary = entry.ResultSummary
        };
    }

    #endregion

    #region Helper Methods

    private JsonElement ParseParameters()
    {
        try
        {
            using var doc = JsonDocument.Parse(Parameters);
            return doc.RootElement.Clone();
        }
        catch
        {
            return JsonDocument.Parse("{}").RootElement;
        }
    }

    private IReadOnlyList<RiskFactor>? ParseRiskFactors()
    {
        if (string.IsNullOrEmpty(RiskFactorsJson))
            return null;

        try
        {
            return JsonSerializer.Deserialize<List<RiskFactor>>(RiskFactorsJson);
        }
        catch
        {
            return null;
        }
    }

    private static Guid? ParseGuid(string? value)
    {
        if (string.IsNullOrEmpty(value))
            return null;

        return Guid.TryParse(value, out var guid) ? guid : null;
    }

    private static string SerializeParameters(JsonElement parameters)
    {
        try
        {
            return parameters.GetRawText();
        }
        catch
        {
            return "{}";
        }
    }

    private static string? SerializeRiskFactors(IReadOnlyList<RiskFactor>? factors)
    {
        if (factors == null || factors.Count == 0)
            return null;

        try
        {
            return JsonSerializer.Serialize(factors);
        }
        catch
        {
            return null;
        }
    }

    #endregion
}
```

### 2. IAuditLogRepository.cs

**Location**: `src/SeniorIntern.Core/Interfaces/IAuditLogRepository.cs`

```csharp
namespace SeniorIntern.Core.Interfaces;

using SeniorIntern.Core.Models.Permissions;

/// <summary>
/// Repository for audit log entries.
/// </summary>
/// <remarks>
/// Provides CRUD operations and querying for audit log persistence.
/// </remarks>
public interface IAuditLogRepository
{
    #region Write Operations

    /// <summary>
    /// Add a new audit log entry.
    /// </summary>
    /// <param name="entry">The entry to add.</param>
    Task AddAsync(AuditLogEntry entry);

    /// <summary>
    /// Add multiple audit log entries.
    /// </summary>
    /// <param name="entries">The entries to add.</param>
    Task AddRangeAsync(IEnumerable<AuditLogEntry> entries);

    #endregion

    #region Query Operations

    /// <summary>
    /// Query audit log entries.
    /// </summary>
    /// <param name="query">Query parameters.</param>
    /// <param name="ct">Cancellation token.</param>
    Task<IReadOnlyList<AuditLogEntry>> QueryAsync(
        AuditLogQuery query,
        CancellationToken ct = default);

    /// <summary>
    /// Get total count matching query.
    /// </summary>
    /// <param name="query">Query parameters.</param>
    /// <param name="ct">Cancellation token.</param>
    Task<int> CountAsync(AuditLogQuery query, CancellationToken ct = default);

    /// <summary>
    /// Get a single entry by ID.
    /// </summary>
    /// <param name="id">Entry ID.</param>
    /// <param name="ct">Cancellation token.</param>
    Task<AuditLogEntry?> GetByIdAsync(Guid id, CancellationToken ct = default);

    /// <summary>
    /// Get the most recent entries.
    /// </summary>
    /// <param name="count">Maximum number of entries.</param>
    /// <param name="ct">Cancellation token.</param>
    Task<IReadOnlyList<AuditLogEntry>> GetRecentAsync(
        int count,
        CancellationToken ct = default);

    #endregion

    #region Maintenance Operations

    /// <summary>
    /// Delete entries older than specified date.
    /// </summary>
    /// <param name="date">Cutoff date.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>Number of deleted entries.</returns>
    Task<int> DeleteOlderThanAsync(DateTime date, CancellationToken ct = default);

    /// <summary>
    /// Get the total size of the audit log in bytes (approximate).
    /// </summary>
    Task<long> GetStorageSizeAsync(CancellationToken ct = default);

    #endregion

    #region Statistics

    /// <summary>
    /// Get summary statistics.
    /// </summary>
    /// <param name="since">Optional start date for statistics.</param>
    /// <param name="ct">Cancellation token.</param>
    Task<AuditLogStatistics> GetStatisticsAsync(
        DateTime? since = null,
        CancellationToken ct = default);

    #endregion

    #region Export

    /// <summary>
    /// Export entries to JSON file.
    /// </summary>
    /// <param name="filePath">Output file path.</param>
    /// <param name="query">Optional query filter.</param>
    /// <param name="ct">Cancellation token.</param>
    Task ExportAsync(
        string filePath,
        AuditLogQuery? query = null,
        CancellationToken ct = default);

    /// <summary>
    /// Export entries to CSV file.
    /// </summary>
    /// <param name="filePath">Output file path.</param>
    /// <param name="query">Optional query filter.</param>
    /// <param name="ct">Cancellation token.</param>
    Task ExportCsvAsync(
        string filePath,
        AuditLogQuery? query = null,
        CancellationToken ct = default);

    #endregion
}
```

### 3. AuditLogRepository.cs

**Location**: `src/SeniorIntern.Data/Repositories/AuditLogRepository.cs`

```csharp
namespace SeniorIntern.Data.Repositories;

using System.Text;
using System.Text.Json;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models.Permissions;
using SeniorIntern.Core.Tools;
using SeniorIntern.Data.Entities;

/// <summary>
/// SQLite implementation of audit log repository.
/// </summary>
public sealed class AuditLogRepository : IAuditLogRepository
{
    #region Dependencies

    private readonly AppDbContext _context;
    private readonly ILogger<AuditLogRepository> _logger;

    #endregion

    #region Constructor

    public AuditLogRepository(
        AppDbContext context,
        ILogger<AuditLogRepository> logger)
    {
        _context = context ?? throw new ArgumentNullException(nameof(context));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    #endregion

    #region Write Operations

    /// <inheritdoc />
    public async Task AddAsync(AuditLogEntry entry)
    {
        ArgumentNullException.ThrowIfNull(entry);

        var entity = AuditLogEntity.FromModel(entry);
        _context.AuditLog.Add(entity);
        await _context.SaveChangesAsync();

        _logger.LogTrace(
            "Added audit entry: {Id} - {ToolId} - {Decision}",
            entry.Id, entry.ToolId, entry.Decision);
    }

    /// <inheritdoc />
    public async Task AddRangeAsync(IEnumerable<AuditLogEntry> entries)
    {
        ArgumentNullException.ThrowIfNull(entries);

        var entities = entries.Select(AuditLogEntity.FromModel).ToList();

        if (entities.Count == 0)
            return;

        _context.AuditLog.AddRange(entities);
        await _context.SaveChangesAsync();

        _logger.LogDebug("Added {Count} audit entries", entities.Count);
    }

    #endregion

    #region Query Operations

    /// <inheritdoc />
    public async Task<IReadOnlyList<AuditLogEntry>> QueryAsync(
        AuditLogQuery query,
        CancellationToken ct = default)
    {
        ArgumentNullException.ThrowIfNull(query);

        var queryable = ApplyFilters(_context.AuditLog.AsNoTracking(), query);
        queryable = ApplySorting(queryable, query.SortOrder);
        queryable = ApplyPagination(queryable, query.Skip, query.Take);

        var entities = await queryable.ToListAsync(ct);
        return entities.Select(e => e.ToModel()).ToList();
    }

    /// <inheritdoc />
    public async Task<int> CountAsync(AuditLogQuery query, CancellationToken ct = default)
    {
        ArgumentNullException.ThrowIfNull(query);

        var queryable = ApplyFilters(_context.AuditLog.AsNoTracking(), query);
        return await queryable.CountAsync(ct);
    }

    /// <inheritdoc />
    public async Task<AuditLogEntry?> GetByIdAsync(Guid id, CancellationToken ct = default)
    {
        var idString = id.ToString();
        var entity = await _context.AuditLog
            .AsNoTracking()
            .FirstOrDefaultAsync(e => e.Id == idString, ct);

        return entity?.ToModel();
    }

    /// <inheritdoc />
    public async Task<IReadOnlyList<AuditLogEntry>> GetRecentAsync(
        int count,
        CancellationToken ct = default)
    {
        var entities = await _context.AuditLog
            .AsNoTracking()
            .OrderByDescending(e => e.Timestamp)
            .Take(count)
            .ToListAsync(ct);

        return entities.Select(e => e.ToModel()).ToList();
    }

    #endregion

    #region Maintenance Operations

    /// <inheritdoc />
    public async Task<int> DeleteOlderThanAsync(DateTime date, CancellationToken ct = default)
    {
        var count = await _context.AuditLog
            .Where(e => e.Timestamp < date)
            .ExecuteDeleteAsync(ct);

        if (count > 0)
        {
            _logger.LogInformation(
                "Deleted {Count} audit log entries older than {Date}",
                count, date);
        }

        return count;
    }

    /// <inheritdoc />
    public async Task<long> GetStorageSizeAsync(CancellationToken ct = default)
    {
        // Approximate size based on row count and average row size
        var count = await _context.AuditLog.CountAsync(ct);
        const int AverageRowSizeBytes = 500;
        return count * AverageRowSizeBytes;
    }

    #endregion

    #region Statistics

    /// <inheritdoc />
    public async Task<AuditLogStatistics> GetStatisticsAsync(
        DateTime? since = null,
        CancellationToken ct = default)
    {
        var query = _context.AuditLog.AsNoTracking();

        if (since.HasValue)
            query = query.Where(e => e.Timestamp >= since.Value);

        var entries = await query.ToListAsync(ct);

        return new AuditLogStatistics
        {
            TotalEntries = entries.Count,
            AutoApprovedCount = entries.Count(e => e.Decision == (int)AuditDecision.AutoApproved),
            UserApprovedCount = entries.Count(e => e.Decision == (int)AuditDecision.UserApproved),
            UserDeniedCount = entries.Count(e => e.Decision == (int)AuditDecision.UserDenied),
            PolicyBlockedCount = entries.Count(e => e.Decision == (int)AuditDecision.PolicyBlocked),
            RateLimitedCount = entries.Count(e => e.Decision == (int)AuditDecision.RateLimited),
            TimedOutCount = entries.Count(e => e.Decision == (int)AuditDecision.TimedOut),
            ErrorCount = entries.Count(e => e.Decision == (int)AuditDecision.Error),
            FailedExecutionsCount = entries.Count(e => e.ExecutionSuccess == false),
            ToolUsageCounts = entries
                .GroupBy(e => e.ToolId)
                .ToDictionary(g => g.Key, g => g.Count()),
            RiskLevelCounts = entries
                .GroupBy(e => (RiskLevel)e.RiskLevel)
                .ToDictionary(g => g.Key, g => g.Count()),
            CategoryCounts = entries
                .GroupBy(e => (ToolCategory)e.ToolCategory)
                .ToDictionary(g => g.Key, g => g.Count()),
            AverageExecutionDuration = CalculateAverageDuration(entries),
            FromDate = since,
            ToDate = DateTime.UtcNow
        };
    }

    private static TimeSpan? CalculateAverageDuration(List<AuditLogEntity> entries)
    {
        var durations = entries
            .Where(e => e.ExecutionDurationMs.HasValue)
            .Select(e => e.ExecutionDurationMs!.Value)
            .ToList();

        if (durations.Count == 0)
            return null;

        return TimeSpan.FromMilliseconds(durations.Average());
    }

    #endregion

    #region Export

    /// <inheritdoc />
    public async Task ExportAsync(
        string filePath,
        AuditLogQuery? query = null,
        CancellationToken ct = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(filePath);

        var effectiveQuery = query ?? new AuditLogQuery { Take = int.MaxValue };
        if (effectiveQuery.Take == 100) // Default value
            effectiveQuery = effectiveQuery with { Take = int.MaxValue };

        var entries = await QueryAsync(effectiveQuery, ct);

        var options = new JsonSerializerOptions
        {
            WriteIndented = true,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        };

        var json = JsonSerializer.Serialize(entries, options);
        await File.WriteAllTextAsync(filePath, json, ct);

        _logger.LogInformation(
            "Exported {Count} audit entries to {Path}",
            entries.Count, filePath);
    }

    /// <inheritdoc />
    public async Task ExportCsvAsync(
        string filePath,
        AuditLogQuery? query = null,
        CancellationToken ct = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(filePath);

        var effectiveQuery = query ?? new AuditLogQuery { Take = int.MaxValue };
        if (effectiveQuery.Take == 100)
            effectiveQuery = effectiveQuery with { Take = int.MaxValue };

        var entries = await QueryAsync(effectiveQuery, ct);

        var sb = new StringBuilder();

        // Header
        sb.AppendLine("Id,Timestamp,ToolId,ToolName,Category,RiskLevel,Decision,DenialReason,ExecutionSuccess,ExecutionDurationMs,ExecutionSummary");

        // Rows
        foreach (var entry in entries)
        {
            sb.AppendLine(string.Join(",",
                EscapeCsv(entry.Id.ToString()),
                EscapeCsv(entry.Timestamp.ToString("O")),
                EscapeCsv(entry.ToolId),
                EscapeCsv(entry.ToolName),
                EscapeCsv(entry.ToolCategory.ToString()),
                EscapeCsv(entry.RiskLevel.ToString()),
                EscapeCsv(entry.Decision.ToString()),
                EscapeCsv(entry.DenialReason ?? ""),
                entry.ExecutionSuccess?.ToString() ?? "",
                entry.ExecutionDuration?.TotalMilliseconds.ToString("F0") ?? "",
                EscapeCsv(entry.ExecutionSummary)));
        }

        await File.WriteAllTextAsync(filePath, sb.ToString(), ct);

        _logger.LogInformation(
            "Exported {Count} audit entries to CSV {Path}",
            entries.Count, filePath);
    }

    private static string EscapeCsv(string value)
    {
        if (value.Contains(',') || value.Contains('"') || value.Contains('\n'))
        {
            return $"\"{value.Replace("\"", "\"\"")}\"";
        }
        return value;
    }

    #endregion

    #region Private Helper Methods

    private IQueryable<AuditLogEntity> ApplyFilters(
        IQueryable<AuditLogEntity> query,
        AuditLogQuery filter)
    {
        // Date range
        if (filter.StartDate.HasValue)
            query = query.Where(e => e.Timestamp >= filter.StartDate.Value);

        if (filter.EndDate.HasValue)
            query = query.Where(e => e.Timestamp < filter.EndDate.Value);

        // Tool filtering
        if (!string.IsNullOrEmpty(filter.ToolId))
            query = query.Where(e => e.ToolId == filter.ToolId);

        if (filter.ToolIds != null && filter.ToolIds.Count > 0)
            query = query.Where(e => filter.ToolIds.Contains(e.ToolId));

        if (filter.Category.HasValue)
            query = query.Where(e => e.ToolCategory == (int)filter.Category.Value);

        // Decision filtering
        if (filter.Decision.HasValue)
            query = query.Where(e => e.Decision == (int)filter.Decision.Value);

        if (filter.Decisions != null && filter.Decisions.Count > 0)
        {
            var decisionInts = filter.Decisions.Select(d => (int)d).ToList();
            query = query.Where(e => decisionInts.Contains(e.Decision));
        }

        if (filter.MinRiskLevel.HasValue)
            query = query.Where(e => e.RiskLevel >= (int)filter.MinRiskLevel.Value);

        if (filter.PermissionSource.HasValue)
            query = query.Where(e => e.PermissionSource == (int)filter.PermissionSource.Value);

        // Context filtering
        if (filter.ConversationId.HasValue)
            query = query.Where(e => e.ConversationId == filter.ConversationId.Value.ToString());

        if (filter.OnlyFailures == true)
            query = query.Where(e => e.ExecutionSuccess == false);

        if (filter.OnlyExecuted == true)
            query = query.Where(e => e.ExecutionSuccess != null);

        if (filter.OnlyDenied == true)
        {
            var deniedDecisions = new[]
            {
                (int)AuditDecision.UserDenied,
                (int)AuditDecision.PolicyBlocked,
                (int)AuditDecision.RateLimited,
                (int)AuditDecision.TimedOut
            };
            query = query.Where(e => deniedDecisions.Contains(e.Decision));
        }

        // Text search
        if (!string.IsNullOrEmpty(filter.SearchText))
        {
            var searchLower = filter.SearchText.ToLowerInvariant();
            query = query.Where(e =>
                e.ExecutionSummary.ToLower().Contains(searchLower) ||
                e.ToolName.ToLower().Contains(searchLower) ||
                e.ToolId.ToLower().Contains(searchLower));
        }

        return query;
    }

    private static IQueryable<AuditLogEntity> ApplySorting(
        IQueryable<AuditLogEntity> query,
        AuditLogSortOrder sortOrder)
    {
        return sortOrder switch
        {
            AuditLogSortOrder.OldestFirst =>
                query.OrderBy(e => e.Timestamp),

            AuditLogSortOrder.RiskLevelDesc =>
                query.OrderByDescending(e => e.RiskLevel)
                     .ThenByDescending(e => e.Timestamp),

            AuditLogSortOrder.DurationDesc =>
                query.OrderByDescending(e => e.ExecutionDurationMs)
                     .ThenByDescending(e => e.Timestamp),

            AuditLogSortOrder.ToolIdAsc =>
                query.OrderBy(e => e.ToolId)
                     .ThenByDescending(e => e.Timestamp),

            _ => // NewestFirst (default)
                query.OrderByDescending(e => e.Timestamp)
        };
    }

    private static IQueryable<AuditLogEntity> ApplyPagination(
        IQueryable<AuditLogEntity> query,
        int skip,
        int take)
    {
        if (skip > 0)
            query = query.Skip(skip);

        if (take > 0 && take < int.MaxValue)
            query = query.Take(take);

        return query;
    }

    #endregion
}
```

### 4. Migration File

**Location**: `src/SeniorIntern.Data/Migrations/AddAuditLog.cs`

```csharp
namespace SeniorIntern.Data.Migrations;

using Microsoft.EntityFrameworkCore.Migrations;

/// <summary>
/// Migration to add audit log table.
/// </summary>
public partial class AddAuditLog : Migration
{
    protected override void Up(MigrationBuilder migrationBuilder)
    {
        migrationBuilder.CreateTable(
            name: "AuditLog",
            columns: table => new
            {
                Id = table.Column<string>(type: "TEXT", nullable: false),
                Timestamp = table.Column<DateTime>(type: "TEXT", nullable: false),
                ToolId = table.Column<string>(type: "TEXT", nullable: false),
                ToolName = table.Column<string>(type: "TEXT", nullable: false),
                ToolCategory = table.Column<int>(type: "INTEGER", nullable: false),
                RiskLevel = table.Column<int>(type: "INTEGER", nullable: false),
                Decision = table.Column<int>(type: "INTEGER", nullable: false),
                DenialReason = table.Column<string>(type: "TEXT", nullable: true),
                Parameters = table.Column<string>(type: "TEXT", nullable: false),
                ExecutionSummary = table.Column<string>(type: "TEXT", nullable: false),
                RiskFactorsJson = table.Column<string>(type: "TEXT", nullable: true),
                ConversationId = table.Column<string>(type: "TEXT", nullable: true),
                RequestId = table.Column<string>(type: "TEXT", nullable: true),
                PermissionSource = table.Column<int>(type: "INTEGER", nullable: false),
                ExecutionSuccess = table.Column<bool>(type: "INTEGER", nullable: true),
                ExecutionError = table.Column<string>(type: "TEXT", nullable: true),
                ExecutionDurationMs = table.Column<long>(type: "INTEGER", nullable: true),
                ResultSummary = table.Column<string>(type: "TEXT", nullable: true)
            },
            constraints: table =>
            {
                table.PrimaryKey("PK_AuditLog", x => x.Id);
            });

        // Create indexes for efficient querying
        migrationBuilder.CreateIndex(
            name: "IX_AuditLog_Timestamp",
            table: "AuditLog",
            column: "Timestamp",
            descending: new[] { true });

        migrationBuilder.CreateIndex(
            name: "IX_AuditLog_ToolId",
            table: "AuditLog",
            column: "ToolId");

        migrationBuilder.CreateIndex(
            name: "IX_AuditLog_Decision",
            table: "AuditLog",
            column: "Decision");

        migrationBuilder.CreateIndex(
            name: "IX_AuditLog_RiskLevel",
            table: "AuditLog",
            column: "RiskLevel");

        migrationBuilder.CreateIndex(
            name: "IX_AuditLog_ConversationId",
            table: "AuditLog",
            column: "ConversationId");

        migrationBuilder.CreateIndex(
            name: "IX_AuditLog_Timestamp_ToolId",
            table: "AuditLog",
            columns: new[] { "Timestamp", "ToolId" },
            descending: new[] { true, false });
    }

    protected override void Down(MigrationBuilder migrationBuilder)
    {
        migrationBuilder.DropTable(name: "AuditLog");
    }
}
```

### 5. AppDbContext Modification

**Location**: `src/SeniorIntern.Data/AppDbContext.cs` (modification)

```csharp
// Add to AppDbContext class:

/// <summary>
/// Audit log entries.
/// </summary>
public DbSet<AuditLogEntity> AuditLog { get; set; } = null!;

// Add to OnModelCreating:
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    base.OnModelCreating(modelBuilder);

    // AuditLog configuration
    modelBuilder.Entity<AuditLogEntity>(entity =>
    {
        entity.ToTable("AuditLog");
        entity.HasKey(e => e.Id);

        entity.Property(e => e.Timestamp).IsRequired();
        entity.Property(e => e.ToolId).IsRequired();
        entity.Property(e => e.ToolName).IsRequired();
        entity.Property(e => e.Parameters).IsRequired().HasDefaultValue("{}");
        entity.Property(e => e.ExecutionSummary).IsRequired();

        // Indexes
        entity.HasIndex(e => e.Timestamp).IsDescending();
        entity.HasIndex(e => e.ToolId);
        entity.HasIndex(e => e.Decision);
        entity.HasIndex(e => e.RiskLevel);
        entity.HasIndex(e => e.ConversationId);
        entity.HasIndex(e => new { e.Timestamp, e.ToolId });
    });
}
```

---

## File Summary

| File | Location | Purpose | Lines |
|------|----------|---------|-------|
| `AuditLogEntity.cs` | `Data/Entities/` | Database entity | ~200 |
| `IAuditLogRepository.cs` | `Core/Interfaces/` | Repository interface | ~85 |
| `AuditLogRepository.cs` | `Data/Repositories/` | Repository implementation | ~350 |
| `AddAuditLog.cs` | `Data/Migrations/` | Database migration | ~80 |
| (Modified) `AppDbContext.cs` | `Data/` | Add DbSet and configuration | +30 |

---

## Unit Test Plan

| Test | Description |
|------|-------------|
| `AddAsync_InsertsEntry` | Insert single entry |
| `AddRangeAsync_InsertsBatch` | Batch insert |
| `QueryAsync_FiltersbyDateRange` | Date filtering |
| `QueryAsync_FiltersByToolId` | Tool filtering |
| `QueryAsync_FiltersByDecision` | Decision filtering |
| `QueryAsync_FiltersByRiskLevel` | Risk filtering |
| `QueryAsync_FiltersByConversationId` | Context filtering |
| `QueryAsync_SearchesText` | Text search |
| `QueryAsync_SortsNewestFirst` | Default sort |
| `QueryAsync_SortsOldestFirst` | Alternate sort |
| `QueryAsync_AppliesPagination` | Skip/Take |
| `CountAsync_ReturnsCorrectCount` | Counting |
| `GetByIdAsync_ReturnsEntry` | Single lookup |
| `DeleteOlderThanAsync_RemovesOldEntries` | Retention |
| `GetStatisticsAsync_CalculatesCorrectly` | Statistics |
| `ExportAsync_CreatesValidJson` | JSON export |
| `ExportCsvAsync_CreatesValidCsv` | CSV export |

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | Database schema supports all audit fields |
| AC-2 | Indexes enable efficient queries |
| AC-3 | Repository implements all query filters |
| AC-4 | Statistics aggregation works correctly |
| AC-5 | Export produces valid JSON |

---

## Changelog Entry

```markdown
## v0.6.4g - Audit Log Storage

### Added
- `AuditLogEntity` database entity
  - Maps AuditLogEntry to SQLite-compatible schema
  - ToModel() and FromModel() conversion methods
  - JSON serialization for Parameters and RiskFactors
- `IAuditLogRepository` interface
  - CRUD: AddAsync, AddRangeAsync, GetByIdAsync
  - Query: QueryAsync, CountAsync, GetRecentAsync
  - Maintenance: DeleteOlderThanAsync, GetStorageSizeAsync
  - Statistics: GetStatisticsAsync
  - Export: ExportAsync (JSON), ExportCsvAsync
- `AuditLogRepository` SQLite implementation
  - Full filter support: date, tool, decision, risk, context, text
  - Sorting: NewestFirst, OldestFirst, RiskLevelDesc, DurationDesc
  - Pagination support
  - Statistics aggregation with averages
  - CSV and JSON export
- Database migration `AddAuditLog`
  - AuditLog table with 17 columns
  - 6 indexes for query optimization
  - Composite index for common queries
- AppDbContext extension
  - DbSet<AuditLogEntity> AuditLog
  - Entity configuration with indexes
```

---

## Timeline Estimate

| Version | Estimated Effort |
|---------|------------------|
| v0.6.4g | 0.75 day |
