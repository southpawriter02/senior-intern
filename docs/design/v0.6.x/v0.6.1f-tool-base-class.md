# Design Specification: AIntern v0.6.1f "Tool Base Class"

## Overview

**Version**: v0.6.1f
**Parent**: v0.6.1 Tool Framework
**Focus**: Abstract base class providing common tool functionality, parameter extraction, validation helpers, and workspace path resolution

### Purpose

This sub-version implements the abstract base class for tool implementations:
1. Create `ToolBase` abstract class implementing `ITool`
2. Provide common parameter extraction helpers
3. Implement default validation using JSON Schema
4. Provide workspace-aware path resolution
5. Implement execution summary generation
6. Provide risk level calculation utilities
7. Enable progress reporting infrastructure

### Dependencies

**From v0.6.1a (Tool Core Models)**:
- `ITool` interface to implement
- `ToolCategory` enum
- `RiskLevel` enum

**From v0.6.1b (Tool Execution Context)**:
- `ToolExecutionContext` for execution
- `ToolProgress` for progress reporting

**From v0.6.1c (Tool Result System)**:
- `ToolResult` for execution results
- `ToolArtifact` for output artifacts

**From v0.6.1d (Tool Validation)**:
- `ToolValidationResult` for validation
- `ToolValidationError` for error details

**From v0.6.1e (JSON Schema System)**:
- `JsonSchema` for parameter definitions
- `JsonSchemaBuilder` for schema construction

**Future consumers**:
- v0.6.3: Built-in Tools inherit from ToolBase
- Custom tool implementations

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                    v0.6.1f Tool Base Class Architecture                        │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  src/AIntern.Core/Tools/                                                     │
│  ├─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  ToolBase : ITool                                                        │ │
│  │  ┌─────────────────────────────────────────────────────────────────────┐│ │
│  │  │                                                                      ││ │
│  │  │  Abstract Properties (must implement)                                ││ │
│  │  │  ├── Id: string                                                      ││ │
│  │  │  ├── Name: string                                                    ││ │
│  │  │  ├── Description: string                                             ││ │
│  │  │  ├── Category: ToolCategory                                          ││ │
│  │  │  ├── DefaultRiskLevel: RiskLevel                                     ││ │
│  │  │  └── InputSchema: JsonSchema                                         ││ │
│  │  │                                                                      ││ │
│  │  │  Virtual Properties (can override)                                   ││ │
│  │  │  ├── IsAvailable: bool (default: true)                              ││ │
│  │  │  └── Tags: IReadOnlyList<string> (default: empty)                   ││ │
│  │  │                                                                      ││ │
│  │  │  Abstract Method                                                     ││ │
│  │  │  └── ExecuteCoreAsync(context, ct) → ToolResult                     ││ │
│  │  │                                                                      ││ │
│  │  │  Virtual Methods (can override)                                      ││ │
│  │  │  ├── Validate(parameters) → ToolValidationResult                    ││ │
│  │  │  ├── GetExecutionSummary(parameters) → string                       ││ │
│  │  │  └── GetEffectiveRiskLevel(parameters) → RiskLevel                  ││ │
│  │  │                                                                      ││ │
│  │  │  Parameter Extraction Helpers                                        ││ │
│  │  │  ├── GetRequiredString(ctx, name) → string                          ││ │
│  │  │  ├── GetOptionalString(ctx, name, default) → string                 ││ │
│  │  │  ├── GetRequiredInt(ctx, name) → int                                ││ │
│  │  │  ├── GetOptionalInt(ctx, name, default) → int                       ││ │
│  │  │  ├── GetRequiredBool(ctx, name) → bool                              ││ │
│  │  │  ├── GetOptionalBool(ctx, name, default) → bool                     ││ │
│  │  │  ├── GetStringArray(ctx, name) → string[]                           ││ │
│  │  │  └── GetEnumValue<T>(ctx, name) → T                                 ││ │
│  │  │                                                                      ││ │
│  │  │  Path Resolution                                                     ││ │
│  │  │  ├── ResolvePath(ctx, path) → string                                ││ │
│  │  │  ├── ResolvePathOrThrow(ctx, path, mustExist) → string              ││ │
│  │  │  ├── IsPathInWorkspace(ctx, path) → bool                            ││ │
│  │  │  └── EnsurePathInWorkspace(ctx, path) → void (throws)               ││ │
│  │  │                                                                      ││ │
│  │  │  Progress Reporting                                                  ││ │
│  │  │  ├── ReportProgress(ctx, message) → void                            ││ │
│  │  │  ├── ReportProgress(ctx, message, percent) → void                   ││ │
│  │  │  └── ReportProgressItems(ctx, message, current, total) → void       ││ │
│  │  │                                                                      ││ │
│  │  │  Result Helpers                                                      ││ │
│  │  │  ├── Success(data, message) → ToolResult                            ││ │
│  │  │  ├── Failure(error) → ToolResult                                    ││ │
│  │  │  ├── FileArtifact(path, isNew) → ToolArtifact                       ││ │
│  │  │  └── DirectoryArtifact(path, isNew) → ToolArtifact                  ││ │
│  │  │                                                                      ││ │
│  │  │  Validation Helpers                                                  ││ │
│  │  │  ├── ValidateRequiredParameter(parameters, name) → bool             ││ │
│  │  │  ├── ValidatePath(ctx, paramName, path, mustExist) → Error?         ││ │
│  │  │  └── ValidateEnum(value, allowedValues) → Error?                    ││ │
│  │  │                                                                      ││ │
│  │  └─────────────────────────────────────────────────────────────────────┘│ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Tool Implementation Pattern

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                       Tool Implementation Example                             │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  FileReadTool : ToolBase                                                     │
│  ┌───────────────────────────────────────────────────────────────────────┐   │
│  │                                                                        │   │
│  │  // Required abstract implementations                                  │   │
│  │  public override string Id => "file-read";                            │   │
│  │  public override string Name => "Read File";                          │   │
│  │  public override string Description => "Read file contents";          │   │
│  │  public override ToolCategory Category => ToolCategory.FileSystem;    │   │
│  │  public override RiskLevel DefaultRiskLevel => RiskLevel.Safe;        │   │
│  │                                                                        │   │
│  │  public override JsonSchema InputSchema => JsonSchemaBuilder.Create() │   │
│  │      .AddPath("path", "File path", required: true)                    │   │
│  │      .AddInteger("maxLines", "Max lines", maximum: 10000)             │   │
│  │      .Build();                                                         │   │
│  │                                                                        │   │
│  │  // Core execution logic                                               │   │
│  │  protected override async Task<ToolResult> ExecuteCoreAsync(          │   │
│  │      ToolExecutionContext ctx, CancellationToken ct)                  │   │
│  │  {                                                                     │   │
│  │      // Extract parameters using helpers                              │   │
│  │      var path = GetRequiredString(ctx, "path");                       │   │
│  │      var maxLines = GetOptionalInt(ctx, "maxLines", 1000);            │   │
│  │                                                                        │   │
│  │      // Resolve path (throws if outside workspace)                    │   │
│  │      var fullPath = ResolvePathOrThrow(ctx, path, mustExist: true);   │   │
│  │                                                                        │   │
│  │      // Report progress                                                │   │
│  │      ReportProgress(ctx, "Reading file...");                          │   │
│  │                                                                        │   │
│  │      // Do work                                                        │   │
│  │      var content = await File.ReadAllTextAsync(fullPath, ct);         │   │
│  │                                                                        │   │
│  │      // Return success                                                 │   │
│  │      return Success(new { content, path }, "File read successfully"); │   │
│  │  }                                                                     │   │
│  │                                                                        │   │
│  │  // Optional: Custom execution summary                                 │   │
│  │  public override string GetExecutionSummary(JsonElement parameters)   │   │
│  │  {                                                                     │   │
│  │      var path = parameters.GetProperty("path").GetString();           │   │
│  │      return $"Read file: {path}";                                     │   │
│  │  }                                                                     │   │
│  │                                                                        │   │
│  └───────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Execution Flow

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                       ToolBase Execution Flow                                 │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ITool.ExecuteAsync() called                                                 │
│         │                                                                    │
│         ▼                                                                    │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │ ToolBase.ExecuteAsync() [sealed]                                       │  │
│  │                                                                         │  │
│  │ 1. Validate parameters                                                  │  │
│  │    var validation = Validate(context.EffectiveParameters);             │  │
│  │    if (!validation.IsValid)                                            │  │
│  │        return ToolResult.ValidationFailed(validation);                 │  │
│  │                                                                         │  │
│  │ 2. Check cancellation                                                   │  │
│  │    if (ct.IsCancellationRequested)                                     │  │
│  │        return ToolResult.Cancelled();                                  │  │
│  │                                                                         │  │
│  │ 3. Log execution start                                                  │  │
│  │    _logger?.LogDebug("Executing {ToolId}...", Id);                     │  │
│  │                                                                         │  │
│  │ 4. Call derived class implementation                                    │  │
│  │    try {                                                                │  │
│  │        return await ExecuteCoreAsync(context, ct);  ◄── Override this  │  │
│  │    }                                                                    │  │
│  │    catch (OperationCanceledException) {                                │  │
│  │        return ToolResult.Cancelled();                                  │  │
│  │    }                                                                    │  │
│  │    catch (ToolExecutionException ex) {                                 │  │
│  │        return ToolResult.Failed(ex.Message, ex.ErrorCode);             │  │
│  │    }                                                                    │  │
│  │    catch (Exception ex) {                                              │  │
│  │        return ToolResult.FromException(ex);                            │  │
│  │    }                                                                    │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│         │                                                                    │
│         ▼                                                                    │
│  ToolResult returned to caller                                               │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Specifications

### 1. ToolBase.cs

**Location**: `src/AIntern.Core/Tools/ToolBase.cs`

```csharp
namespace AIntern.Core.Tools;

using System.Text.Json;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;

/// <summary>
/// Abstract base class for tool implementations.
/// </summary>
/// <remarks>
/// <para>
/// <see cref="ToolBase"/> provides common functionality for tools:
/// </para>
/// <list type="bullet">
/// <item>Parameter extraction with type safety</item>
/// <item>JSON Schema validation</item>
/// <item>Workspace-aware path resolution</item>
/// <item>Progress reporting infrastructure</item>
/// <item>Result creation helpers</item>
/// <item>Exception handling</item>
/// </list>
/// <para>
/// To create a tool, inherit from this class and implement:
/// </para>
/// <list type="bullet">
/// <item><see cref="Id"/> - Unique tool identifier (kebab-case)</item>
/// <item><see cref="Name"/> - Human-readable display name</item>
/// <item><see cref="Description"/> - LLM-facing description</item>
/// <item><see cref="Category"/> - Tool category for grouping</item>
/// <item><see cref="DefaultRiskLevel"/> - Base risk level</item>
/// <item><see cref="InputSchema"/> - Parameter JSON schema</item>
/// <item><see cref="ExecuteCoreAsync"/> - Execution logic</item>
/// </list>
/// </remarks>
public abstract class ToolBase : ITool
{
    #region Abstract Properties (Must Implement)

    /// <inheritdoc />
    public abstract string Id { get; }

    /// <inheritdoc />
    public abstract string Name { get; }

    /// <inheritdoc />
    public abstract string Description { get; }

    /// <inheritdoc />
    public abstract ToolCategory Category { get; }

    /// <inheritdoc />
    public abstract RiskLevel DefaultRiskLevel { get; }

    /// <inheritdoc />
    public abstract JsonSchema InputSchema { get; }

    #endregion

    #region Virtual Properties (Can Override)

    /// <inheritdoc />
    /// <remarks>
    /// Override to return false when the tool's prerequisites are not met.
    /// For example, return false if no workspace is open for workspace tools.
    /// </remarks>
    public virtual bool IsAvailable => true;

    /// <inheritdoc />
    /// <remarks>
    /// Override to provide tags for additional categorization.
    /// </remarks>
    public virtual IReadOnlyList<string> Tags => Array.Empty<string>();

    #endregion

    #region Execution

    /// <inheritdoc />
    /// <remarks>
    /// This method is sealed to enforce the execution pattern. Override
    /// <see cref="ExecuteCoreAsync"/> to implement tool-specific logic.
    /// </remarks>
    public async Task<ToolResult> ExecuteAsync(
        ToolExecutionContext context,
        CancellationToken ct = default)
    {
        var logger = GetLogger(context);

        // Pre-validation
        var validation = Validate(context.EffectiveParameters);
        if (!validation.IsValid)
        {
            logger?.LogWarning(
                "Tool {ToolId} validation failed: {Errors}",
                Id, validation.GetErrorMessage());
            return ToolResult.ValidationFailed(validation);
        }

        // Check for early cancellation
        if (ct.IsCancellationRequested)
        {
            logger?.LogDebug("Tool {ToolId} cancelled before execution", Id);
            return ToolResult.Cancelled();
        }

        logger?.LogDebug("Executing tool: {ToolId}", Id);

        try
        {
            var result = await ExecuteCoreAsync(context, ct);

            logger?.LogDebug(
                "Tool {ToolId} completed: Success={Success}",
                Id, result.Success);

            return result;
        }
        catch (OperationCanceledException)
        {
            logger?.LogDebug("Tool {ToolId} was cancelled", Id);
            return ToolResult.Cancelled();
        }
        catch (ToolExecutionException ex)
        {
            logger?.LogWarning(ex,
                "Tool {ToolId} failed with ToolExecutionException: {Error}",
                Id, ex.Message);
            return ToolResult.Failed(ex.Message, ex.ErrorCode);
        }
        catch (Exception ex)
        {
            logger?.LogError(ex, "Tool {ToolId} failed with exception", Id);
            return ToolResult.FromException(ex);
        }
    }

    /// <summary>
    /// Core execution logic to be implemented by derived classes.
    /// </summary>
    /// <remarks>
    /// <para>
    /// This method contains the tool-specific logic. The base class handles:
    /// </para>
    /// <list type="bullet">
    /// <item>Parameter validation (before this method is called)</item>
    /// <item>Cancellation checking</item>
    /// <item>Exception handling and result wrapping</item>
    /// <item>Logging</item>
    /// </list>
    /// <para>
    /// Use the helper methods to extract parameters and resolve paths:
    /// </para>
    /// <code>
    /// var path = GetRequiredString(context, "path");
    /// var fullPath = ResolvePathOrThrow(context, path, mustExist: true);
    /// </code>
    /// </remarks>
    /// <param name="context">Execution context with parameters and services.</param>
    /// <param name="ct">Cancellation token to check during long operations.</param>
    /// <returns>Result of the tool execution.</returns>
    protected abstract Task<ToolResult> ExecuteCoreAsync(
        ToolExecutionContext context,
        CancellationToken ct);

    #endregion

    #region Validation

    /// <inheritdoc />
    /// <remarks>
    /// Default implementation validates required parameters from the schema.
    /// Override to add custom validation logic.
    /// </remarks>
    public virtual ToolValidationResult Validate(JsonElement parameters)
    {
        var errors = new List<ToolValidationError>();

        // Validate required parameters
        foreach (var required in InputSchema.Required)
        {
            if (!parameters.TryGetProperty(required, out var value) ||
                value.ValueKind == JsonValueKind.Null)
            {
                errors.Add(ToolValidationError.Required(required));
            }
        }

        // Validate parameter types
        foreach (var property in parameters.EnumerateObject())
        {
            var propertyName = property.Name;

            if (!InputSchema.Properties.TryGetValue(propertyName, out var schemaProperty))
            {
                // Unknown property - could be error or ignored based on additionalProperties
                if (!InputSchema.AdditionalProperties)
                {
                    errors.Add(ToolValidationError.InvalidValue(
                        propertyName, $"Unknown parameter: {propertyName}"));
                }
                continue;
            }

            // Type validation
            var typeError = ValidateParameterType(propertyName, property.Value, schemaProperty);
            if (typeError != null)
            {
                errors.Add(typeError);
            }
        }

        return errors.Count > 0
            ? ToolValidationResult.Invalid(errors)
            : ToolValidationResult.Valid();
    }

    /// <summary>
    /// Validate that a parameter has the correct type.
    /// </summary>
    protected virtual ToolValidationError? ValidateParameterType(
        string name,
        JsonElement value,
        JsonSchemaProperty schemaProperty)
    {
        if (value.ValueKind == JsonValueKind.Null)
            return null; // Null handling is done by required check

        var expectedType = schemaProperty.Type.ToLowerInvariant();
        var actualKind = value.ValueKind;

        var isValid = expectedType switch
        {
            "string" => actualKind == JsonValueKind.String,
            "integer" => actualKind == JsonValueKind.Number && IsInteger(value),
            "number" => actualKind == JsonValueKind.Number,
            "boolean" => actualKind == JsonValueKind.True || actualKind == JsonValueKind.False,
            "array" => actualKind == JsonValueKind.Array,
            "object" => actualKind == JsonValueKind.Object,
            _ => true
        };

        if (!isValid)
        {
            return ToolValidationError.TypeMismatch(
                name, expectedType, GetJsonTypeName(actualKind));
        }

        return null;
    }

    #endregion

    #region Execution Summary

    /// <inheritdoc />
    /// <remarks>
    /// Default implementation returns "[Tool Name]" or extracts a path parameter.
    /// Override for more specific summaries.
    /// </remarks>
    public virtual string GetExecutionSummary(JsonElement parameters)
    {
        // Try to find a path parameter
        if (parameters.TryGetProperty("path", out var path) &&
            path.ValueKind == JsonValueKind.String)
        {
            var pathValue = path.GetString();
            return $"{Name}: {pathValue}";
        }

        // Try to find any string parameter to display
        foreach (var required in InputSchema.Required)
        {
            if (parameters.TryGetProperty(required, out var value) &&
                value.ValueKind == JsonValueKind.String)
            {
                var stringValue = value.GetString();
                if (!string.IsNullOrEmpty(stringValue))
                {
                    var displayValue = stringValue.Length > 50
                        ? stringValue[..47] + "..."
                        : stringValue;
                    return $"{Name}: {displayValue}";
                }
            }
        }

        return Name;
    }

    #endregion

    #region Risk Level

    /// <inheritdoc />
    /// <remarks>
    /// Default implementation returns <see cref="DefaultRiskLevel"/>.
    /// Override to elevate risk based on parameter values.
    /// </remarks>
    public virtual RiskLevel GetEffectiveRiskLevel(JsonElement parameters) =>
        DefaultRiskLevel;

    /// <summary>
    /// Elevate risk level if condition is true.
    /// </summary>
    /// <param name="condition">Condition that elevates risk.</param>
    /// <param name="currentLevel">Current risk level.</param>
    /// <param name="elevatedLevel">Risk level if condition is true.</param>
    /// <returns>The higher of current or elevated level.</returns>
    protected static RiskLevel ElevateRiskIf(
        bool condition,
        RiskLevel currentLevel,
        RiskLevel elevatedLevel)
    {
        if (!condition) return currentLevel;
        return (RiskLevel)Math.Max((int)currentLevel, (int)elevatedLevel);
    }

    #endregion

    #region Parameter Extraction Helpers

    /// <summary>
    /// Get a required string parameter.
    /// </summary>
    /// <param name="context">Execution context.</param>
    /// <param name="name">Parameter name.</param>
    /// <returns>Parameter value.</returns>
    /// <exception cref="ToolExecutionException">If parameter is missing or invalid.</exception>
    protected string GetRequiredString(ToolExecutionContext context, string name)
    {
        var parameters = context.EffectiveParameters;

        if (!parameters.TryGetProperty(name, out var value))
            throw new ToolExecutionException($"Missing required parameter: {name}", "missing_parameter");

        if (value.ValueKind != JsonValueKind.String)
            throw new ToolExecutionException($"Parameter '{name}' must be a string", "invalid_type");

        var stringValue = value.GetString();
        if (string.IsNullOrEmpty(stringValue))
            throw new ToolExecutionException($"Parameter '{name}' cannot be empty", "empty_value");

        return stringValue;
    }

    /// <summary>
    /// Get an optional string parameter.
    /// </summary>
    /// <param name="context">Execution context.</param>
    /// <param name="name">Parameter name.</param>
    /// <param name="defaultValue">Default value if not provided.</param>
    /// <returns>Parameter value or default.</returns>
    protected string GetOptionalString(
        ToolExecutionContext context,
        string name,
        string defaultValue = "")
    {
        var parameters = context.EffectiveParameters;

        if (!parameters.TryGetProperty(name, out var value))
            return defaultValue;

        if (value.ValueKind == JsonValueKind.Null)
            return defaultValue;

        if (value.ValueKind != JsonValueKind.String)
            return defaultValue;

        return value.GetString() ?? defaultValue;
    }

    /// <summary>
    /// Get a required integer parameter.
    /// </summary>
    /// <param name="context">Execution context.</param>
    /// <param name="name">Parameter name.</param>
    /// <returns>Parameter value.</returns>
    /// <exception cref="ToolExecutionException">If parameter is missing or invalid.</exception>
    protected int GetRequiredInt(ToolExecutionContext context, string name)
    {
        var parameters = context.EffectiveParameters;

        if (!parameters.TryGetProperty(name, out var value))
            throw new ToolExecutionException($"Missing required parameter: {name}", "missing_parameter");

        if (value.ValueKind != JsonValueKind.Number || !value.TryGetInt32(out var intValue))
            throw new ToolExecutionException($"Parameter '{name}' must be an integer", "invalid_type");

        return intValue;
    }

    /// <summary>
    /// Get an optional integer parameter.
    /// </summary>
    /// <param name="context">Execution context.</param>
    /// <param name="name">Parameter name.</param>
    /// <param name="defaultValue">Default value if not provided.</param>
    /// <returns>Parameter value or default.</returns>
    protected int GetOptionalInt(ToolExecutionContext context, string name, int defaultValue = 0)
    {
        var parameters = context.EffectiveParameters;

        if (!parameters.TryGetProperty(name, out var value))
            return defaultValue;

        if (value.ValueKind != JsonValueKind.Number)
            return defaultValue;

        return value.TryGetInt32(out var intValue) ? intValue : defaultValue;
    }

    /// <summary>
    /// Get a required boolean parameter.
    /// </summary>
    protected bool GetRequiredBool(ToolExecutionContext context, string name)
    {
        var parameters = context.EffectiveParameters;

        if (!parameters.TryGetProperty(name, out var value))
            throw new ToolExecutionException($"Missing required parameter: {name}", "missing_parameter");

        if (value.ValueKind != JsonValueKind.True && value.ValueKind != JsonValueKind.False)
            throw new ToolExecutionException($"Parameter '{name}' must be a boolean", "invalid_type");

        return value.GetBoolean();
    }

    /// <summary>
    /// Get an optional boolean parameter.
    /// </summary>
    protected bool GetOptionalBool(ToolExecutionContext context, string name, bool defaultValue = false)
    {
        var parameters = context.EffectiveParameters;

        if (!parameters.TryGetProperty(name, out var value))
            return defaultValue;

        if (value.ValueKind == JsonValueKind.True)
            return true;

        if (value.ValueKind == JsonValueKind.False)
            return false;

        return defaultValue;
    }

    /// <summary>
    /// Get a string array parameter.
    /// </summary>
    protected string[] GetStringArray(ToolExecutionContext context, string name)
    {
        var parameters = context.EffectiveParameters;

        if (!parameters.TryGetProperty(name, out var value))
            return Array.Empty<string>();

        if (value.ValueKind != JsonValueKind.Array)
            return Array.Empty<string>();

        return value.EnumerateArray()
            .Where(e => e.ValueKind == JsonValueKind.String)
            .Select(e => e.GetString()!)
            .ToArray();
    }

    /// <summary>
    /// Get an enum value parameter.
    /// </summary>
    /// <typeparam name="T">Enum type.</typeparam>
    /// <param name="context">Execution context.</param>
    /// <param name="name">Parameter name.</param>
    /// <param name="defaultValue">Default value if not provided.</param>
    /// <returns>Enum value.</returns>
    protected T GetEnumValue<T>(ToolExecutionContext context, string name, T defaultValue)
        where T : struct, Enum
    {
        var stringValue = GetOptionalString(context, name, string.Empty);

        if (string.IsNullOrEmpty(stringValue))
            return defaultValue;

        if (Enum.TryParse<T>(stringValue, ignoreCase: true, out var result))
            return result;

        return defaultValue;
    }

    /// <summary>
    /// Get a required double parameter.
    /// </summary>
    protected double GetRequiredDouble(ToolExecutionContext context, string name)
    {
        var parameters = context.EffectiveParameters;

        if (!parameters.TryGetProperty(name, out var value))
            throw new ToolExecutionException($"Missing required parameter: {name}", "missing_parameter");

        if (value.ValueKind != JsonValueKind.Number || !value.TryGetDouble(out var doubleValue))
            throw new ToolExecutionException($"Parameter '{name}' must be a number", "invalid_type");

        return doubleValue;
    }

    /// <summary>
    /// Get an optional double parameter.
    /// </summary>
    protected double GetOptionalDouble(ToolExecutionContext context, string name, double defaultValue = 0.0)
    {
        var parameters = context.EffectiveParameters;

        if (!parameters.TryGetProperty(name, out var value))
            return defaultValue;

        if (value.ValueKind != JsonValueKind.Number)
            return defaultValue;

        return value.TryGetDouble(out var doubleValue) ? doubleValue : defaultValue;
    }

    #endregion

    #region Path Resolution

    /// <summary>
    /// Resolve a path relative to the workspace.
    /// </summary>
    /// <param name="context">Execution context.</param>
    /// <param name="path">Path to resolve (absolute or relative).</param>
    /// <returns>Resolved absolute path.</returns>
    protected string ResolvePath(ToolExecutionContext context, string path)
    {
        if (Path.IsPathRooted(path))
            return Path.GetFullPath(path);

        if (string.IsNullOrEmpty(context.WorkspacePath))
            return Path.GetFullPath(path);

        return Path.GetFullPath(Path.Combine(context.WorkspacePath, path));
    }

    /// <summary>
    /// Resolve a path and validate it's within the workspace.
    /// </summary>
    /// <param name="context">Execution context.</param>
    /// <param name="path">Path to resolve.</param>
    /// <param name="mustExist">Whether the path must exist.</param>
    /// <returns>Resolved absolute path.</returns>
    /// <exception cref="ToolExecutionException">If path is outside workspace or doesn't exist.</exception>
    protected string ResolvePathOrThrow(
        ToolExecutionContext context,
        string path,
        bool mustExist = false)
    {
        var fullPath = ResolvePath(context, path);

        // Check workspace boundary
        if (!string.IsNullOrEmpty(context.WorkspacePath))
        {
            var normalizedWorkspace = Path.GetFullPath(context.WorkspacePath);
            if (!fullPath.StartsWith(normalizedWorkspace, StringComparison.OrdinalIgnoreCase))
            {
                throw new ToolExecutionException(
                    $"Path is outside workspace: {path}",
                    "path_outside_workspace");
            }
        }

        // Check existence
        if (mustExist && !File.Exists(fullPath) && !Directory.Exists(fullPath))
        {
            throw new ToolExecutionException(
                $"Path does not exist: {path}",
                "path_not_found");
        }

        return fullPath;
    }

    /// <summary>
    /// Check if a path is within the workspace.
    /// </summary>
    /// <param name="context">Execution context.</param>
    /// <param name="path">Path to check.</param>
    /// <returns>True if path is within workspace.</returns>
    protected bool IsPathInWorkspace(ToolExecutionContext context, string path)
    {
        if (string.IsNullOrEmpty(context.WorkspacePath))
            return true; // No workspace = all paths allowed

        try
        {
            var fullPath = ResolvePath(context, path);
            var normalizedWorkspace = Path.GetFullPath(context.WorkspacePath);
            return fullPath.StartsWith(normalizedWorkspace, StringComparison.OrdinalIgnoreCase);
        }
        catch
        {
            return false;
        }
    }

    /// <summary>
    /// Ensure a path is within the workspace, throwing if not.
    /// </summary>
    /// <param name="context">Execution context.</param>
    /// <param name="path">Path to check.</param>
    /// <exception cref="ToolExecutionException">If path is outside workspace.</exception>
    protected void EnsurePathInWorkspace(ToolExecutionContext context, string path)
    {
        if (!IsPathInWorkspace(context, path))
        {
            throw new ToolExecutionException(
                $"Path is outside workspace: {path}",
                "path_outside_workspace");
        }
    }

    #endregion

    #region Progress Reporting

    /// <summary>
    /// Report progress with a message.
    /// </summary>
    /// <param name="context">Execution context.</param>
    /// <param name="message">Progress message.</param>
    protected void ReportProgress(ToolExecutionContext context, string message)
    {
        context.Progress?.Report(ToolProgress.Message(message));
    }

    /// <summary>
    /// Report progress with a message and percentage.
    /// </summary>
    /// <param name="context">Execution context.</param>
    /// <param name="message">Progress message.</param>
    /// <param name="percentComplete">Completion percentage (0-100).</param>
    protected void ReportProgress(ToolExecutionContext context, string message, double percentComplete)
    {
        context.Progress?.Report(ToolProgress.WithPercent(message, percentComplete));
    }

    /// <summary>
    /// Report progress with item count.
    /// </summary>
    /// <param name="context">Execution context.</param>
    /// <param name="message">Progress message.</param>
    /// <param name="current">Current item index.</param>
    /// <param name="total">Total item count.</param>
    protected void ReportProgressItems(
        ToolExecutionContext context,
        string message,
        int current,
        int total)
    {
        context.Progress?.Report(ToolProgress.Items(message, current, total));
    }

    #endregion

    #region Result Helpers

    /// <summary>
    /// Create a success result.
    /// </summary>
    /// <param name="data">Result data.</param>
    /// <param name="message">Optional success message.</param>
    /// <returns>Success result.</returns>
    protected static ToolResult Success(object? data = null, string? message = null) =>
        ToolResult.Succeeded(data, message);

    /// <summary>
    /// Create a success result with artifacts.
    /// </summary>
    /// <param name="artifacts">Artifacts produced.</param>
    /// <param name="data">Optional result data.</param>
    /// <param name="message">Optional success message.</param>
    /// <returns>Success result with artifacts.</returns>
    protected static ToolResult SuccessWithArtifacts(
        IEnumerable<ToolArtifact> artifacts,
        object? data = null,
        string? message = null) =>
        ToolResult.SucceededWithArtifacts(artifacts.ToList(), data, message);

    /// <summary>
    /// Create a failure result.
    /// </summary>
    /// <param name="error">Error message.</param>
    /// <param name="errorCode">Optional error code.</param>
    /// <returns>Failure result.</returns>
    protected static ToolResult Failure(string error, string? errorCode = null) =>
        ToolResult.Failed(error, errorCode);

    /// <summary>
    /// Create a file artifact.
    /// </summary>
    /// <param name="path">File path.</param>
    /// <param name="isNew">Whether the file was created (vs modified).</param>
    /// <param name="description">Optional description.</param>
    /// <returns>File artifact.</returns>
    protected static ToolArtifact FileArtifact(string path, bool isNew = false, string? description = null) =>
        ToolArtifact.File(path, isNew, description);

    /// <summary>
    /// Create a directory artifact.
    /// </summary>
    /// <param name="path">Directory path.</param>
    /// <param name="isNew">Whether the directory was created.</param>
    /// <param name="description">Optional description.</param>
    /// <returns>Directory artifact.</returns>
    protected static ToolArtifact DirectoryArtifact(string path, bool isNew = false, string? description = null) =>
        ToolArtifact.Directory(path, isNew, description);

    #endregion

    #region Validation Helpers

    /// <summary>
    /// Validate that a required parameter is present.
    /// </summary>
    protected bool ValidateRequiredParameter(JsonElement parameters, string name, out JsonElement value)
    {
        return parameters.TryGetProperty(name, out value) && value.ValueKind != JsonValueKind.Null;
    }

    /// <summary>
    /// Validate a path parameter.
    /// </summary>
    /// <param name="context">Execution context for workspace info.</param>
    /// <param name="parameterName">Parameter name for error messages.</param>
    /// <param name="path">Path to validate.</param>
    /// <param name="mustExist">Whether path must exist.</param>
    /// <returns>Validation error or null if valid.</returns>
    protected ToolValidationError? ValidatePath(
        ToolExecutionContext context,
        string parameterName,
        string path,
        bool mustExist = false)
    {
        if (string.IsNullOrWhiteSpace(path))
        {
            return ToolValidationError.InvalidValue(parameterName, "Path cannot be empty");
        }

        if (!IsPathInWorkspace(context, path))
        {
            return ToolValidationError.PathOutsideWorkspace(parameterName, path);
        }

        if (mustExist)
        {
            var fullPath = ResolvePath(context, path);
            if (!File.Exists(fullPath) && !Directory.Exists(fullPath))
            {
                return ToolValidationError.PathNotFound(parameterName, path);
            }
        }

        return null;
    }

    /// <summary>
    /// Validate an enum value.
    /// </summary>
    protected ToolValidationError? ValidateEnum(
        string parameterName,
        string value,
        IEnumerable<string> allowedValues)
    {
        var allowed = allowedValues.ToList();
        if (!allowed.Contains(value, StringComparer.OrdinalIgnoreCase))
        {
            return ToolValidationError.InvalidEnum(parameterName, value, allowed);
        }
        return null;
    }

    #endregion

    #region Private Helpers

    private ILogger? GetLogger(ToolExecutionContext context)
    {
        try
        {
            return context.Services.GetService<ILoggerFactory>()?.CreateLogger(GetType());
        }
        catch
        {
            return null;
        }
    }

    private static bool IsInteger(JsonElement value)
    {
        if (value.TryGetInt64(out _))
            return true;

        if (value.TryGetDouble(out var d))
            return Math.Abs(d % 1) < double.Epsilon;

        return false;
    }

    private static string GetJsonTypeName(JsonValueKind kind) => kind switch
    {
        JsonValueKind.String => "string",
        JsonValueKind.Number => "number",
        JsonValueKind.True or JsonValueKind.False => "boolean",
        JsonValueKind.Array => "array",
        JsonValueKind.Object => "object",
        JsonValueKind.Null => "null",
        _ => "undefined"
    };

    #endregion
}
```

### 2. ToolExecutionException.cs

**Location**: `src/AIntern.Core/Tools/ToolExecutionException.cs`

```csharp
namespace AIntern.Core.Tools;

/// <summary>
/// Exception thrown during tool execution.
/// </summary>
/// <remarks>
/// <para>
/// Use this exception for expected error conditions that should be
/// reported to the LLM. The error code allows for programmatic handling.
/// </para>
/// <para>
/// The <see cref="ToolBase"/> catches this exception and converts it to
/// a <see cref="ToolResult"/> with the appropriate error information.
/// </para>
/// </remarks>
public sealed class ToolExecutionException : Exception
{
    /// <summary>
    /// Error code for programmatic handling.
    /// </summary>
    /// <remarks>
    /// Uses snake_case convention. Common codes:
    /// <list type="bullet">
    /// <item>missing_parameter - Required parameter not provided</item>
    /// <item>invalid_type - Parameter has wrong type</item>
    /// <item>empty_value - Parameter value is empty</item>
    /// <item>path_not_found - Path doesn't exist</item>
    /// <item>path_outside_workspace - Security violation</item>
    /// <item>permission_denied - Operation not allowed</item>
    /// <item>resource_busy - Resource is locked</item>
    /// </list>
    /// </remarks>
    public string ErrorCode { get; }

    /// <summary>
    /// Creates a new tool execution exception.
    /// </summary>
    /// <param name="message">Error message.</param>
    /// <param name="errorCode">Error code for programmatic handling.</param>
    public ToolExecutionException(string message, string errorCode = "execution_error")
        : base(message)
    {
        ErrorCode = errorCode;
    }

    /// <summary>
    /// Creates a new tool execution exception with inner exception.
    /// </summary>
    /// <param name="message">Error message.</param>
    /// <param name="errorCode">Error code.</param>
    /// <param name="innerException">Inner exception.</param>
    public ToolExecutionException(string message, string errorCode, Exception innerException)
        : base(message, innerException)
    {
        ErrorCode = errorCode;
    }

    #region Factory Methods

    /// <summary>
    /// Create exception for missing parameter.
    /// </summary>
    public static ToolExecutionException MissingParameter(string parameterName) =>
        new($"Missing required parameter: {parameterName}", "missing_parameter");

    /// <summary>
    /// Create exception for invalid parameter type.
    /// </summary>
    public static ToolExecutionException InvalidType(string parameterName, string expectedType) =>
        new($"Parameter '{parameterName}' must be {expectedType}", "invalid_type");

    /// <summary>
    /// Create exception for empty value.
    /// </summary>
    public static ToolExecutionException EmptyValue(string parameterName) =>
        new($"Parameter '{parameterName}' cannot be empty", "empty_value");

    /// <summary>
    /// Create exception for path not found.
    /// </summary>
    public static ToolExecutionException PathNotFound(string path) =>
        new($"Path does not exist: {path}", "path_not_found");

    /// <summary>
    /// Create exception for path outside workspace.
    /// </summary>
    public static ToolExecutionException PathOutsideWorkspace(string path) =>
        new($"Path is outside workspace: {path}", "path_outside_workspace");

    /// <summary>
    /// Create exception for permission denied.
    /// </summary>
    public static ToolExecutionException PermissionDenied(string operation) =>
        new($"Permission denied: {operation}", "permission_denied");

    /// <summary>
    /// Create exception for resource busy.
    /// </summary>
    public static ToolExecutionException ResourceBusy(string resource) =>
        new($"Resource is busy: {resource}", "resource_busy");

    /// <summary>
    /// Create exception for out of range value.
    /// </summary>
    public static ToolExecutionException OutOfRange(string parameterName, object value, object? min, object? max) =>
        new($"Parameter '{parameterName}' value {value} is out of range [{min}, {max}]", "out_of_range");

    /// <summary>
    /// Create exception for operation timeout.
    /// </summary>
    public static ToolExecutionException Timeout(string operation) =>
        new($"Operation timed out: {operation}", "timeout");

    #endregion
}
```

---

## Directory Structure

```
src/AIntern.Core/
└── Tools/
    ├── ToolBase.cs                        (NEW)
    └── ToolExecutionException.cs          (NEW)
```

---

## Unit Test Plan

| Test Class | Test | Description |
|------------|------|-------------|
| **ToolBaseTests** | | |
| | `ExecuteAsync_ValidParameters_CallsExecuteCore` | Execution flow works |
| | `ExecuteAsync_InvalidParameters_ReturnsValidationFailed` | Validation blocks execution |
| | `ExecuteAsync_CancellationRequested_ReturnsCancelled` | Cancellation handled |
| | `ExecuteAsync_ExecutionException_ReturnsFailedWithCode` | Exception handling |
| | `ExecuteAsync_UnexpectedException_ReturnsFromException` | Unexpected exception handling |
| | `Validate_MissingRequired_ReturnsError` | Required validation |
| | `Validate_WrongType_ReturnsError` | Type validation |
| | `Validate_UnknownProperty_ReturnsError` | Additional properties blocked |
| | `Validate_AllValid_ReturnsValid` | Valid parameters pass |
| | `GetExecutionSummary_WithPath_IncludesPath` | Path in summary |
| | `GetExecutionSummary_WithoutPath_ReturnsName` | Falls back to name |
| | `GetEffectiveRiskLevel_ReturnsDefault` | Default risk level |
| **ParameterExtractionTests** | | |
| | `GetRequiredString_Present_ReturnsValue` | String extraction |
| | `GetRequiredString_Missing_Throws` | Missing required throws |
| | `GetRequiredString_WrongType_Throws` | Wrong type throws |
| | `GetRequiredString_Empty_Throws` | Empty string throws |
| | `GetOptionalString_Present_ReturnsValue` | Optional present |
| | `GetOptionalString_Missing_ReturnsDefault` | Optional missing |
| | `GetRequiredInt_Present_ReturnsValue` | Integer extraction |
| | `GetRequiredInt_Missing_Throws` | Missing throws |
| | `GetOptionalInt_Present_ReturnsValue` | Optional present |
| | `GetOptionalInt_Missing_ReturnsDefault` | Optional missing |
| | `GetRequiredBool_Present_ReturnsValue` | Boolean extraction |
| | `GetOptionalBool_Missing_ReturnsDefault` | Optional missing |
| | `GetStringArray_Present_ReturnsArray` | Array extraction |
| | `GetStringArray_Missing_ReturnsEmpty` | Empty on missing |
| | `GetEnumValue_Valid_ReturnsValue` | Enum extraction |
| | `GetEnumValue_Invalid_ReturnsDefault` | Invalid returns default |
| **PathResolutionTests** | | |
| | `ResolvePath_Relative_ResolvesFromWorkspace` | Relative resolution |
| | `ResolvePath_Absolute_ReturnsAsIs` | Absolute unchanged |
| | `ResolvePathOrThrow_InWorkspace_Succeeds` | Valid path |
| | `ResolvePathOrThrow_OutsideWorkspace_Throws` | Security check |
| | `ResolvePathOrThrow_MustExist_ChecksExistence` | Existence check |
| | `IsPathInWorkspace_Inside_ReturnsTrue` | Inside check |
| | `IsPathInWorkspace_Outside_ReturnsFalse` | Outside check |
| | `EnsurePathInWorkspace_Outside_Throws` | Guard throws |
| **ProgressReportingTests** | | |
| | `ReportProgress_Message_ReportsToProgress` | Message reporting |
| | `ReportProgress_WithPercent_ReportsProgress` | Percent reporting |
| | `ReportProgressItems_ReportsWithCounts` | Item reporting |
| | `ReportProgress_NoProgress_NoOp` | Null progress safe |
| **ResultHelperTests** | | |
| | `Success_CreatesSuccessResult` | Success factory |
| | `Success_WithData_IncludesData` | Data included |
| | `SuccessWithArtifacts_IncludesArtifacts` | Artifacts included |
| | `Failure_CreatesFailedResult` | Failure factory |
| | `FileArtifact_CreatesCorrectType` | File artifact |
| | `DirectoryArtifact_CreatesCorrectType` | Directory artifact |
| **ValidationHelperTests** | | |
| | `ValidateRequiredParameter_Present_ReturnsTrue` | Present check |
| | `ValidateRequiredParameter_Missing_ReturnsFalse` | Missing check |
| | `ValidatePath_Valid_ReturnsNull` | Valid path |
| | `ValidatePath_Empty_ReturnsError` | Empty error |
| | `ValidatePath_OutsideWorkspace_ReturnsError` | Security error |
| | `ValidatePath_NotExists_ReturnsError` | Existence error |
| | `ValidateEnum_Valid_ReturnsNull` | Valid enum |
| | `ValidateEnum_Invalid_ReturnsError` | Invalid enum |
| **ToolExecutionExceptionTests** | | |
| | `Constructor_SetsMessageAndCode` | Properties set |
| | `MissingParameter_CreatesCorrectException` | Factory method |
| | `InvalidType_CreatesCorrectException` | Factory method |
| | `PathNotFound_CreatesCorrectException` | Factory method |
| | `PathOutsideWorkspace_CreatesCorrectException` | Factory method |

**Total Tests**: 58

---

## Implementation Example

```csharp
/// <summary>
/// Example tool implementation using ToolBase.
/// </summary>
public sealed class FileReadTool : ToolBase
{
    public override string Id => "file-read";
    public override string Name => "Read File";
    public override string Description => "Read the contents of a file from the workspace.";
    public override ToolCategory Category => ToolCategory.FileSystem;
    public override RiskLevel DefaultRiskLevel => RiskLevel.Safe;

    public override JsonSchema InputSchema => JsonSchemaBuilder.Create()
        .WithDescription("File reading parameters")
        .AddPath("path", "Path to the file to read", required: true, mustExist: true)
        .AddInteger("maxLines", "Maximum lines to read (0 for all)",
            minimum: 0, maximum: 10000, defaultValue: 0)
        .AddString("encoding", "Text encoding",
            defaultValue: "utf-8")
        .Build();

    public override IReadOnlyList<string> Tags => new[] { "read-only", "workspace" };

    protected override async Task<ToolResult> ExecuteCoreAsync(
        ToolExecutionContext context,
        CancellationToken ct)
    {
        // Extract parameters
        var path = GetRequiredString(context, "path");
        var maxLines = GetOptionalInt(context, "maxLines", 0);
        var encoding = GetOptionalString(context, "encoding", "utf-8");

        // Resolve and validate path
        var fullPath = ResolvePathOrThrow(context, path, mustExist: true);

        ReportProgress(context, $"Reading: {path}");

        // Read file
        var textEncoding = GetEncoding(encoding);
        var lines = await File.ReadAllLinesAsync(fullPath, textEncoding, ct);

        // Apply max lines limit
        if (maxLines > 0 && lines.Length > maxLines)
        {
            lines = lines.Take(maxLines).ToArray();
        }

        var content = string.Join(Environment.NewLine, lines);

        return Success(new
        {
            path,
            content,
            lineCount = lines.Length,
            truncated = maxLines > 0 && lines.Length >= maxLines
        }, $"Read {lines.Length} lines from {path}");
    }

    public override string GetExecutionSummary(JsonElement parameters)
    {
        var path = parameters.GetProperty("path").GetString();
        return $"Read file: {path}";
    }

    private static System.Text.Encoding GetEncoding(string name) => name.ToLowerInvariant() switch
    {
        "utf-8" or "utf8" => System.Text.Encoding.UTF8,
        "ascii" => System.Text.Encoding.ASCII,
        "utf-16" or "utf16" or "unicode" => System.Text.Encoding.Unicode,
        _ => System.Text.Encoding.UTF8
    };
}
```

---

## File Summary

### Files to Create

| File | Location | Lines | Purpose |
|------|----------|-------|---------|
| `ToolBase.cs` | `Core/Tools/` | ~550 | Abstract base class |
| `ToolExecutionException.cs` | `Core/Tools/` | ~120 | Execution exception |
| **Total** | | **~670** | |

### Files to Modify

None.

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | `ToolBase` implements all `ITool` members |
| AC-2 | `ExecuteAsync` validates before calling `ExecuteCoreAsync` |
| AC-3 | Cancellation is handled correctly at all stages |
| AC-4 | Parameter extraction helpers throw for invalid data |
| AC-5 | Path resolution prevents workspace escapes |
| AC-6 | Progress reporting works with null progress |
| AC-7 | Result helpers create correct result types |
| AC-8 | Validation helpers cover common cases |
| AC-9 | `ToolExecutionException` provides useful factory methods |
| AC-10 | All 58 unit tests pass |

---

## Changelog Entry

```markdown
## v0.6.1f - Tool Base Class

### Added
- `ToolBase` abstract class with:
  - ITool interface implementation
  - Sealed ExecuteAsync with validation and exception handling
  - Abstract ExecuteCoreAsync for derived class logic
  - Parameter extraction helpers:
    - GetRequiredString, GetOptionalString
    - GetRequiredInt, GetOptionalInt
    - GetRequiredBool, GetOptionalBool
    - GetRequiredDouble, GetOptionalDouble
    - GetStringArray, GetEnumValue
  - Path resolution:
    - ResolvePath, ResolvePathOrThrow
    - IsPathInWorkspace, EnsurePathInWorkspace
  - Progress reporting:
    - ReportProgress (message, percent, items)
  - Result helpers:
    - Success, SuccessWithArtifacts, Failure
    - FileArtifact, DirectoryArtifact
  - Validation helpers:
    - ValidateRequiredParameter
    - ValidatePath, ValidateEnum

- `ToolExecutionException` with:
  - ErrorCode property for programmatic handling
  - Factory methods for common error cases:
    - MissingParameter, InvalidType, EmptyValue
    - PathNotFound, PathOutsideWorkspace
    - PermissionDenied, ResourceBusy, OutOfRange, Timeout
```

---

## Implementation Notes

### Tool Implementation Guidelines

1. **Always use parameter helpers**: Use `GetRequiredString`, etc. instead of accessing `parameters` directly.

2. **Always validate paths**: Use `ResolvePathOrThrow` for any path parameter to ensure security.

3. **Report progress for long operations**: Users appreciate feedback during execution.

4. **Use appropriate risk levels**: Start with the lowest appropriate level and override `GetEffectiveRiskLevel` to elevate for dangerous parameter combinations.

5. **Provide good execution summaries**: Help users understand what the tool will do before they approve.

### Error Handling

```csharp
// Good: Use ToolExecutionException for expected errors
if (!File.Exists(path))
    throw ToolExecutionException.PathNotFound(path);

// Good: Let unexpected exceptions propagate (ToolBase handles them)
// The base class will convert them to ToolResult.FromException()

// Avoid: Don't catch and wrap all exceptions
// Let the base class handle unexpected exceptions appropriately
```

### Progress Reporting

```csharp
// For simple operations
ReportProgress(context, "Processing file...");

// For operations with known progress
for (int i = 0; i < files.Length; i++)
{
    ReportProgressItems(context, "Processing files", i + 1, files.Length);
    // process file...
}
```

---

## Timeline Estimate

| Task | Estimated Effort |
|------|------------------|
| ToolBase | 0.75 day |
| ToolExecutionException | 0.15 day |
| Unit Tests | 0.6 day |
| **Total** | **1.5 days** |
