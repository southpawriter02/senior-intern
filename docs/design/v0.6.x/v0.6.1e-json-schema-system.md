# Design Specification: AIntern v0.6.1e "JSON Schema System"

## Overview

**Version**: v0.6.1e
**Parent**: v0.6.1 Tool Framework
**Focus**: JSON Schema representation, fluent builder, and type-based generation for tool parameter definitions

### Purpose

This sub-version implements the JSON Schema infrastructure for tool parameters:
1. Create `JsonSchema` model compatible with OpenAI function calling format
2. Create `JsonSchemaProperty` for individual property definitions
3. Create `JsonSchemaBuilder` for fluent, type-safe schema construction
4. Create `JsonSchemaExtensions` for common operations
5. Create `JsonSchemaGenerator` for automatic schema generation from .NET types
6. Support all common JSON Schema Draft 7 features

### Dependencies

**From v0.6.1a (Tool Core Models)**:
- `ITool.InputSchema` returns `JsonSchema`
- `JsonSchema` forward declaration to be replaced
- `JsonSchemaProperty` forward declaration to be replaced

**From v0.6.1d (Tool Validation)**:
- `IToolValidator.ValidateAgainstSchema()` uses `JsonSchema`
- `IToolValidator.ValidateParameter()` uses `JsonSchemaProperty`

**Future consumers**:
- v0.6.1f: Tool Base Class schema definition
- v0.6.1g: Tool Registry function definitions
- v0.6.2: Semantic Kernel Integration
- v0.6.3: Built-in Tools parameter schemas

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                    v0.6.1e JSON Schema System Architecture                     │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  src/AIntern.Core/Tools/                                                     │
│  ├─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  JsonSchema                                                              │ │
│  │  ┌─────────────────────────────────────────────────────────────────────┐│ │
│  │  │                                                                      ││ │
│  │  │  Properties                                                          ││ │
│  │  │  ├── Type: string                  (always "object")                 ││ │
│  │  │  ├── Description: string?          (schema description)              ││ │
│  │  │  ├── Properties: Dictionary<string, JsonSchemaProperty>             ││ │
│  │  │  ├── Required: List<string>        (required property names)        ││ │
│  │  │  └── AdditionalProperties: bool    (allow extra properties)         ││ │
│  │  │                                                                      ││ │
│  │  │  Methods                                                             ││ │
│  │  │  ├── ToJson() → string             (serialize for LLM)              ││ │
│  │  │  └── Empty: JsonSchema             (no parameters)                  ││ │
│  │  │                                                                      ││ │
│  │  └─────────────────────────────────────────────────────────────────────┘│ │
│  │                                                                          │ │
│  │  JsonSchemaProperty                                                      │ │
│  │  ┌─────────────────────────────────────────────────────────────────────┐│ │
│  │  │                                                                      ││ │
│  │  │  Core Properties                                                     ││ │
│  │  │  ├── Type: string                  (string, integer, number, etc.)  ││ │
│  │  │  ├── Description: string?          (property description)           ││ │
│  │  │  └── Default: object?              (default value)                  ││ │
│  │  │                                                                      ││ │
│  │  │  String Constraints                                                  ││ │
│  │  │  ├── Enum: string[]?               (allowed values)                 ││ │
│  │  │  ├── Pattern: string?              (regex pattern)                  ││ │
│  │  │  ├── MinLength: int?               (minimum length)                 ││ │
│  │  │  └── MaxLength: int?               (maximum length)                 ││ │
│  │  │                                                                      ││ │
│  │  │  Numeric Constraints                                                 ││ │
│  │  │  ├── Minimum: double?              (minimum value)                  ││ │
│  │  │  └── Maximum: double?              (maximum value)                  ││ │
│  │  │                                                                      ││ │
│  │  │  Array Properties                                                    ││ │
│  │  │  ├── Items: JsonSchemaProperty?    (item schema)                    ││ │
│  │  │  ├── MinItems: int?                (minimum count)                  ││ │
│  │  │  ├── MaxItems: int?                (maximum count)                  ││ │
│  │  │  └── UniqueItems: bool             (no duplicates)                  ││ │
│  │  │                                                                      ││ │
│  │  │  Object Properties                                                   ││ │
│  │  │  ├── ObjectProperties: Dictionary<string, JsonSchemaProperty>?     ││ │
│  │  │  └── ObjectRequired: List<string>? (required nested properties)    ││ │
│  │  │                                                                      ││ │
│  │  │  Documentation                                                       ││ │
│  │  │  └── Examples: object[]?           (example values)                 ││ │
│  │  │                                                                      ││ │
│  │  └─────────────────────────────────────────────────────────────────────┘│ │
│  │                                                                          │ │
│  │  JsonSchemaBuilder                                                       │ │
│  │  ┌─────────────────────────────────────────────────────────────────────┐│ │
│  │  │                                                                      ││ │
│  │  │  Fluent Builder Pattern                                              ││ │
│  │  │  ├── Create() → JsonSchemaBuilder                                   ││ │
│  │  │  ├── WithDescription(string) → JsonSchemaBuilder                    ││ │
│  │  │  ├── AllowAdditionalProperties(bool) → JsonSchemaBuilder            ││ │
│  │  │  │                                                                   ││ │
│  │  │  │  String Properties                                                ││ │
│  │  │  ├── AddString(name, desc, required, ...) → JsonSchemaBuilder       ││ │
│  │  │  ├── AddEnum(name, desc, values, required, ...) → JsonSchemaBuilder ││ │
│  │  │  ├── AddPath(name, desc, required, mustExist) → JsonSchemaBuilder   ││ │
│  │  │  │                                                                   ││ │
│  │  │  │  Numeric Properties                                               ││ │
│  │  │  ├── AddInteger(name, desc, required, ...) → JsonSchemaBuilder      ││ │
│  │  │  ├── AddNumber(name, desc, required, ...) → JsonSchemaBuilder       ││ │
│  │  │  │                                                                   ││ │
│  │  │  │  Boolean Property                                                 ││ │
│  │  │  ├── AddBoolean(name, desc, required, ...) → JsonSchemaBuilder      ││ │
│  │  │  │                                                                   ││ │
│  │  │  │  Array Properties                                                 ││ │
│  │  │  ├── AddStringArray(name, desc, required, ...) → JsonSchemaBuilder  ││ │
│  │  │  ├── AddArray(name, desc, itemSchema, ...) → JsonSchemaBuilder      ││ │
│  │  │  │                                                                   ││ │
│  │  │  │  Object Properties                                                ││ │
│  │  │  ├── AddObject(name, desc, configure, required) → JsonSchemaBuilder ││ │
│  │  │  │                                                                   ││ │
│  │  │  └── Build() → JsonSchema                                           ││ │
│  │  │                                                                      ││ │
│  │  └─────────────────────────────────────────────────────────────────────┘│ │
│  │                                                                          │ │
│  │  JsonSchemaGenerator                                                     │ │
│  │  ┌─────────────────────────────────────────────────────────────────────┐│ │
│  │  │  Reflection-based schema generation from .NET types                  ││ │
│  │  │  ├── Generate<T>() → JsonSchema                                      ││ │
│  │  │  ├── Generate(Type) → JsonSchema                                     ││ │
│  │  │  │                                                                   ││ │
│  │  │  Attribute Support:                                                  ││ │
│  │  │  ├── [Description] → property description                           ││ │
│  │  │  ├── [Required] → required property                                 ││ │
│  │  │  ├── [Range] → min/max constraints                                  ││ │
│  │  │  ├── [MinLength], [MaxLength] → string length                       ││ │
│  │  │  └── [RegularExpression] → pattern                                  ││ │
│  │  │                                                                      ││ │
│  │  └─────────────────────────────────────────────────────────────────────┘│ │
│  │                                                                          │ │
│  │  JsonSchemaExtensions                                                    │ │
│  │  ┌─────────────────────────────────────────────────────────────────────┐│ │
│  │  │  Extension methods for JsonSchema                                    ││ │
│  │  │  ├── GetProperty(schema, name) → JsonSchemaProperty?                ││ │
│  │  │  ├── IsRequired(schema, name) → bool                                ││ │
│  │  │  ├── GetRequiredProperties(schema) → IEnumerable<string>            ││ │
│  │  │  ├── GetOptionalProperties(schema) → IEnumerable<string>            ││ │
│  │  │  └── FromType<T>() → JsonSchema                                     ││ │
│  │  │                                                                      ││ │
│  │  └─────────────────────────────────────────────────────────────────────┘│ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## OpenAI Function Calling Compatibility

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                    OpenAI Function Calling Format                             │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  OpenAI tools array format:                                                  │
│  ┌───────────────────────────────────────────────────────────────────────┐   │
│  │ {                                                                      │   │
│  │   "type": "function",                                                 │   │
│  │   "function": {                                                       │   │
│  │     "name": "file-read",                                              │   │
│  │     "description": "Read the contents of a file",                     │   │
│  │     "parameters": {                                                   │   │
│  │       "type": "object",                            ◄── JsonSchema     │   │
│  │       "properties": {                                                 │   │
│  │         "path": {                                  ◄── JsonSchemaProperty│ │
│  │           "type": "string",                                           │   │
│  │           "description": "Path to the file to read"                   │   │
│  │         },                                                            │   │
│  │         "encoding": {                                                 │   │
│  │           "type": "string",                                           │   │
│  │           "description": "Text encoding",                             │   │
│  │           "enum": ["utf-8", "ascii", "utf-16"],                      │   │
│  │           "default": "utf-8"                                          │   │
│  │         },                                                            │   │
│  │         "maxLines": {                                                 │   │
│  │           "type": "integer",                                          │   │
│  │           "description": "Maximum lines to read",                     │   │
│  │           "minimum": 1,                                               │   │
│  │           "maximum": 10000                                            │   │
│  │         }                                                             │   │
│  │       },                                                              │   │
│  │       "required": ["path"]                                            │   │
│  │     }                                                                 │   │
│  │   }                                                                   │   │
│  │ }                                                                      │   │
│  └───────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
│  Builder equivalent:                                                         │
│  ┌───────────────────────────────────────────────────────────────────────┐   │
│  │ var schema = JsonSchemaBuilder.Create()                               │   │
│  │     .AddPath("path", "Path to the file to read", required: true)     │   │
│  │     .AddEnum("encoding", "Text encoding",                            │   │
│  │         new[] { "utf-8", "ascii", "utf-16" },                        │   │
│  │         defaultValue: "utf-8")                                        │   │
│  │     .AddInteger("maxLines", "Maximum lines to read",                 │   │
│  │         minimum: 1, maximum: 10000)                                   │   │
│  │     .Build();                                                         │   │
│  └───────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Type Mapping

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                          .NET to JSON Schema Type Mapping                     │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  .NET Type           │ JSON Schema Type │ Notes                              │
│  ────────────────────┼──────────────────┼──────────────────────────────────  │
│  string              │ "string"         │ Basic string                       │
│  int, long           │ "integer"        │ Whole numbers                      │
│  float, double       │ "number"         │ Floating point                     │
│  decimal             │ "number"         │ High precision numbers             │
│  bool                │ "boolean"        │ True/false                         │
│  Enum                │ "string" + enum  │ Enum values as string array        │
│  List<T>, T[]        │ "array"          │ With items schema                  │
│  Dictionary<K,V>     │ "object"         │ additionalProperties               │
│  Nullable<T>         │ Same as T        │ Not required                       │
│  Custom class        │ "object"         │ With nested properties             │
│                                                                              │
│  Attribute Mapping:                                                          │
│  ────────────────────┼──────────────────┼──────────────────────────────────  │
│  [Description]       │ "description"    │ Property description               │
│  [Required]          │ required[]       │ Added to required array            │
│  [Range(1, 100)]     │ min/max          │ Numeric constraints                │
│  [MinLength(1)]      │ "minLength"      │ String minimum                     │
│  [MaxLength(100)]    │ "maxLength"      │ String maximum                     │
│  [RegularExpression] │ "pattern"        │ Regex pattern                      │
│  [JsonPropertyName]  │ Property key     │ Custom JSON name                   │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Specifications

### 1. JsonSchema.cs

**Location**: `src/AIntern.Core/Tools/JsonSchema.cs`

```csharp
namespace AIntern.Core.Tools;

using System.Text.Json;
using System.Text.Json.Serialization;

/// <summary>
/// JSON Schema definition for tool parameters.
/// </summary>
/// <remarks>
/// <para>
/// This class represents a JSON Schema that defines the expected parameters
/// for a tool. It is compatible with the OpenAI function calling format and
/// can be serialized directly for LLM integration.
/// </para>
/// <para>
/// JSON Schema features supported:
/// </para>
/// <list type="bullet">
/// <item>Object type with properties</item>
/// <item>Required property list</item>
/// <item>String, integer, number, boolean, array, object types</item>
/// <item>Enum constraints</item>
/// <item>Numeric range constraints (minimum, maximum)</item>
/// <item>String constraints (minLength, maxLength, pattern)</item>
/// <item>Array constraints (minItems, maxItems, uniqueItems)</item>
/// <item>Nested object schemas</item>
/// <item>Default values</item>
/// </list>
/// </remarks>
public sealed class JsonSchema
{
    /// <summary>
    /// Schema type (always "object" for tool parameters).
    /// </summary>
    /// <remarks>
    /// Tool parameters are always represented as a JSON object with named properties.
    /// </remarks>
    [JsonPropertyName("type")]
    public string Type { get; init; } = "object";

    /// <summary>
    /// Description of the parameters object.
    /// </summary>
    /// <remarks>
    /// Provides context to the LLM about the overall purpose of the parameters.
    /// </remarks>
    [JsonPropertyName("description")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? Description { get; init; }

    /// <summary>
    /// Property definitions.
    /// </summary>
    /// <remarks>
    /// Maps property names to their schema definitions.
    /// Property names should be camelCase for consistency.
    /// </remarks>
    [JsonPropertyName("properties")]
    public Dictionary<string, JsonSchemaProperty> Properties { get; init; } = new();

    /// <summary>
    /// List of required property names.
    /// </summary>
    /// <remarks>
    /// Properties in this list must be provided by the LLM.
    /// The validator will reject tool calls missing required properties.
    /// </remarks>
    [JsonPropertyName("required")]
    public List<string> Required { get; init; } = new();

    /// <summary>
    /// Whether additional properties are allowed.
    /// </summary>
    /// <remarks>
    /// When false (default), the validator will reject unknown properties.
    /// This helps catch LLM errors where incorrect property names are used.
    /// </remarks>
    [JsonPropertyName("additionalProperties")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public bool AdditionalProperties { get; init; } = false;

    #region Serialization

    private static readonly JsonSerializerOptions _serializerOptions = new()
    {
        WriteIndented = false,
        DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull,
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase
    };

    private static readonly JsonSerializerOptions _prettySerializerOptions = new()
    {
        WriteIndented = true,
        DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull,
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase
    };

    /// <summary>
    /// Serialize to JSON for LLM function calling.
    /// </summary>
    /// <returns>Compact JSON string.</returns>
    public string ToJson() => JsonSerializer.Serialize(this, _serializerOptions);

    /// <summary>
    /// Serialize to indented JSON for display.
    /// </summary>
    /// <returns>Pretty-printed JSON string.</returns>
    public string ToPrettyJson() => JsonSerializer.Serialize(this, _prettySerializerOptions);

    /// <summary>
    /// Deserialize from JSON.
    /// </summary>
    /// <param name="json">JSON string.</param>
    /// <returns>Parsed schema.</returns>
    public static JsonSchema? FromJson(string json) =>
        JsonSerializer.Deserialize<JsonSchema>(json, _serializerOptions);

    #endregion

    #region Factory Methods

    /// <summary>
    /// Create an empty schema (no parameters).
    /// </summary>
    /// <remarks>
    /// Use for tools that take no parameters.
    /// </remarks>
    public static JsonSchema Empty => new()
    {
        Type = "object",
        Properties = new Dictionary<string, JsonSchemaProperty>(),
        Required = new List<string>()
    };

    /// <summary>
    /// Create a schema with a single required string parameter.
    /// </summary>
    /// <param name="name">Parameter name.</param>
    /// <param name="description">Parameter description.</param>
    /// <returns>Schema with one required string property.</returns>
    public static JsonSchema SingleString(string name, string description) =>
        new()
        {
            Properties = new Dictionary<string, JsonSchemaProperty>
            {
                [name] = new JsonSchemaProperty
                {
                    Type = "string",
                    Description = description
                }
            },
            Required = new List<string> { name }
        };

    /// <summary>
    /// Create a schema with a single required path parameter.
    /// </summary>
    /// <param name="name">Parameter name (default: "path").</param>
    /// <param name="description">Parameter description.</param>
    /// <returns>Schema with one required path property.</returns>
    public static JsonSchema SinglePath(
        string name = "path",
        string description = "File or directory path") =>
        SingleString(name, description);

    #endregion

    #region Helper Methods

    /// <summary>
    /// Check if a property exists.
    /// </summary>
    /// <param name="name">Property name.</param>
    /// <returns>True if property exists.</returns>
    public bool HasProperty(string name) => Properties.ContainsKey(name);

    /// <summary>
    /// Check if a property is required.
    /// </summary>
    /// <param name="name">Property name.</param>
    /// <returns>True if property is required.</returns>
    public bool IsPropertyRequired(string name) => Required.Contains(name);

    /// <summary>
    /// Get the total number of properties.
    /// </summary>
    public int PropertyCount => Properties.Count;

    /// <summary>
    /// Get the number of required properties.
    /// </summary>
    public int RequiredPropertyCount => Required.Count;

    /// <summary>
    /// Get the number of optional properties.
    /// </summary>
    public int OptionalPropertyCount => Properties.Count - Required.Count;

    #endregion

    /// <inheritdoc />
    public override string ToString() =>
        $"JsonSchema({PropertyCount} properties, {RequiredPropertyCount} required)";
}
```

### 2. JsonSchemaProperty.cs

**Location**: `src/AIntern.Core/Tools/JsonSchemaProperty.cs`

```csharp
namespace AIntern.Core.Tools;

using System.Text.Json.Serialization;

/// <summary>
/// Property definition within a JSON Schema.
/// </summary>
/// <remarks>
/// <para>
/// Represents a single property in a tool's parameter schema. Each property
/// has a type and optional constraints that define valid values.
/// </para>
/// <para>
/// Supported property types:
/// </para>
/// <list type="bullet">
/// <item><b>string</b>: Text values with optional length/pattern constraints</item>
/// <item><b>integer</b>: Whole numbers with optional range constraints</item>
/// <item><b>number</b>: Floating point with optional range constraints</item>
/// <item><b>boolean</b>: True/false values</item>
/// <item><b>array</b>: Lists with typed items and count constraints</item>
/// <item><b>object</b>: Nested objects with their own schema</item>
/// </list>
/// </remarks>
public sealed class JsonSchemaProperty
{
    #region Core Properties

    /// <summary>
    /// Property type: "string", "integer", "number", "boolean", "array", "object".
    /// </summary>
    /// <remarks>
    /// This is the primary type constraint. The LLM will format values
    /// according to this type.
    /// </remarks>
    [JsonPropertyName("type")]
    public string Type { get; init; } = string.Empty;

    /// <summary>
    /// Description of the property.
    /// </summary>
    /// <remarks>
    /// <para>
    /// The description is critical for LLM understanding. It should explain:
    /// </para>
    /// <list type="bullet">
    /// <item>What the parameter represents</item>
    /// <item>Expected format or values</item>
    /// <item>Any important constraints</item>
    /// <item>Default behavior if omitted</item>
    /// </list>
    /// </remarks>
    [JsonPropertyName("description")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? Description { get; init; }

    /// <summary>
    /// Default value for the property.
    /// </summary>
    /// <remarks>
    /// Used when the property is not provided. Should match the property type.
    /// </remarks>
    [JsonPropertyName("default")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public object? Default { get; init; }

    #endregion

    #region String Constraints

    /// <summary>
    /// Allowed values for enum properties.
    /// </summary>
    /// <remarks>
    /// When set, the value must be one of these strings (case-sensitive).
    /// </remarks>
    [JsonPropertyName("enum")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string[]? Enum { get; init; }

    /// <summary>
    /// Regex pattern for string validation.
    /// </summary>
    /// <remarks>
    /// Uses ECMA-262 regex syntax. The entire string must match.
    /// </remarks>
    [JsonPropertyName("pattern")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? Pattern { get; init; }

    /// <summary>
    /// Minimum length for string properties.
    /// </summary>
    [JsonPropertyName("minLength")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public int? MinLength { get; init; }

    /// <summary>
    /// Maximum length for string properties.
    /// </summary>
    [JsonPropertyName("maxLength")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public int? MaxLength { get; init; }

    /// <summary>
    /// Format hint for string validation.
    /// </summary>
    /// <remarks>
    /// Common formats: "date-time", "date", "time", "email", "uri", "uuid".
    /// Note: Not all LLMs/validators support format validation.
    /// </remarks>
    [JsonPropertyName("format")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? Format { get; init; }

    #endregion

    #region Numeric Constraints

    /// <summary>
    /// Minimum value for numeric properties.
    /// </summary>
    [JsonPropertyName("minimum")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public double? Minimum { get; init; }

    /// <summary>
    /// Maximum value for numeric properties.
    /// </summary>
    [JsonPropertyName("maximum")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public double? Maximum { get; init; }

    /// <summary>
    /// Exclusive minimum (value must be greater than this).
    /// </summary>
    [JsonPropertyName("exclusiveMinimum")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public double? ExclusiveMinimum { get; init; }

    /// <summary>
    /// Exclusive maximum (value must be less than this).
    /// </summary>
    [JsonPropertyName("exclusiveMaximum")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public double? ExclusiveMaximum { get; init; }

    /// <summary>
    /// Value must be a multiple of this number.
    /// </summary>
    [JsonPropertyName("multipleOf")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public double? MultipleOf { get; init; }

    #endregion

    #region Array Properties

    /// <summary>
    /// Schema for array items.
    /// </summary>
    /// <remarks>
    /// Defines the type and constraints for each item in the array.
    /// </remarks>
    [JsonPropertyName("items")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public JsonSchemaProperty? Items { get; init; }

    /// <summary>
    /// Minimum number of items for array properties.
    /// </summary>
    [JsonPropertyName("minItems")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public int? MinItems { get; init; }

    /// <summary>
    /// Maximum number of items for array properties.
    /// </summary>
    [JsonPropertyName("maxItems")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public int? MaxItems { get; init; }

    /// <summary>
    /// Whether array items must be unique.
    /// </summary>
    [JsonPropertyName("uniqueItems")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public bool UniqueItems { get; init; }

    #endregion

    #region Object Properties

    /// <summary>
    /// Nested object properties.
    /// </summary>
    /// <remarks>
    /// When Type is "object", this defines the nested property schema.
    /// </remarks>
    [JsonPropertyName("properties")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public Dictionary<string, JsonSchemaProperty>? ObjectProperties { get; init; }

    /// <summary>
    /// Required properties for nested objects.
    /// </summary>
    [JsonPropertyName("required")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public List<string>? ObjectRequired { get; init; }

    /// <summary>
    /// Whether nested objects allow additional properties.
    /// </summary>
    [JsonPropertyName("additionalProperties")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public bool? ObjectAdditionalProperties { get; init; }

    #endregion

    #region Documentation

    /// <summary>
    /// Examples of valid values.
    /// </summary>
    /// <remarks>
    /// Helps the LLM understand expected formats.
    /// </remarks>
    [JsonPropertyName("examples")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public object[]? Examples { get; init; }

    /// <summary>
    /// Constant value (property must equal this value).
    /// </summary>
    [JsonPropertyName("const")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public object? Const { get; init; }

    #endregion

    #region Factory Methods

    /// <summary>
    /// Create a string property.
    /// </summary>
    public static JsonSchemaProperty String(
        string description,
        string? defaultValue = null,
        int? minLength = null,
        int? maxLength = null,
        string? pattern = null,
        string[]? examples = null) =>
        new()
        {
            Type = "string",
            Description = description,
            Default = defaultValue,
            MinLength = minLength,
            MaxLength = maxLength,
            Pattern = pattern,
            Examples = examples
        };

    /// <summary>
    /// Create an enum property.
    /// </summary>
    public static JsonSchemaProperty Enum(
        string description,
        string[] values,
        string? defaultValue = null) =>
        new()
        {
            Type = "string",
            Description = description,
            Enum = values,
            Default = defaultValue
        };

    /// <summary>
    /// Create an integer property.
    /// </summary>
    public static JsonSchemaProperty Integer(
        string description,
        int? defaultValue = null,
        int? minimum = null,
        int? maximum = null) =>
        new()
        {
            Type = "integer",
            Description = description,
            Default = defaultValue,
            Minimum = minimum,
            Maximum = maximum
        };

    /// <summary>
    /// Create a number property.
    /// </summary>
    public static JsonSchemaProperty Number(
        string description,
        double? defaultValue = null,
        double? minimum = null,
        double? maximum = null) =>
        new()
        {
            Type = "number",
            Description = description,
            Default = defaultValue,
            Minimum = minimum,
            Maximum = maximum
        };

    /// <summary>
    /// Create a boolean property.
    /// </summary>
    public static JsonSchemaProperty Boolean(
        string description,
        bool? defaultValue = null) =>
        new()
        {
            Type = "boolean",
            Description = description,
            Default = defaultValue
        };

    /// <summary>
    /// Create a string array property.
    /// </summary>
    public static JsonSchemaProperty StringArray(
        string description,
        int? minItems = null,
        int? maxItems = null,
        bool uniqueItems = false) =>
        new()
        {
            Type = "array",
            Description = description,
            Items = new JsonSchemaProperty { Type = "string" },
            MinItems = minItems,
            MaxItems = maxItems,
            UniqueItems = uniqueItems
        };

    #endregion

    /// <inheritdoc />
    public override string ToString() => $"JsonSchemaProperty(type: {Type})";
}
```

### 3. JsonSchemaBuilder.cs

**Location**: `src/AIntern.Core/Tools/JsonSchemaBuilder.cs`

```csharp
namespace AIntern.Core.Tools;

/// <summary>
/// Fluent builder for JSON Schema definitions.
/// </summary>
/// <remarks>
/// <para>
/// The builder provides a type-safe, fluent API for constructing JSON schemas
/// that define tool parameters. It is the recommended way to create schemas.
/// </para>
/// <para>
/// Example usage:
/// </para>
/// <code>
/// var schema = JsonSchemaBuilder.Create()
///     .WithDescription("File reading parameters")
///     .AddPath("path", "Path to the file to read", required: true)
///     .AddInteger("maxLines", "Maximum lines to read", maximum: 10000)
///     .AddBoolean("includeLineNumbers", "Include line numbers", defaultValue: false)
///     .Build();
/// </code>
/// </remarks>
public sealed class JsonSchemaBuilder
{
    private readonly Dictionary<string, JsonSchemaProperty> _properties = new();
    private readonly List<string> _required = new();
    private string? _description;
    private bool _additionalProperties;

    private JsonSchemaBuilder() { }

    /// <summary>
    /// Create a new schema builder.
    /// </summary>
    /// <returns>A new builder instance.</returns>
    public static JsonSchemaBuilder Create() => new();

    /// <summary>
    /// Set the schema description.
    /// </summary>
    /// <param name="description">Description of the parameters object.</param>
    /// <returns>This builder for chaining.</returns>
    public JsonSchemaBuilder WithDescription(string description)
    {
        _description = description;
        return this;
    }

    /// <summary>
    /// Allow additional properties not defined in schema.
    /// </summary>
    /// <param name="allow">Whether to allow extra properties (default: true).</param>
    /// <returns>This builder for chaining.</returns>
    public JsonSchemaBuilder AllowAdditionalProperties(bool allow = true)
    {
        _additionalProperties = allow;
        return this;
    }

    #region String Properties

    /// <summary>
    /// Add a string property.
    /// </summary>
    /// <param name="name">Property name.</param>
    /// <param name="description">Property description.</param>
    /// <param name="required">Whether the property is required.</param>
    /// <param name="defaultValue">Default value if not provided.</param>
    /// <param name="pattern">Regex pattern for validation.</param>
    /// <param name="minLength">Minimum string length.</param>
    /// <param name="maxLength">Maximum string length.</param>
    /// <param name="examples">Example values.</param>
    /// <returns>This builder for chaining.</returns>
    public JsonSchemaBuilder AddString(
        string name,
        string description,
        bool required = false,
        string? defaultValue = null,
        string? pattern = null,
        int? minLength = null,
        int? maxLength = null,
        string[]? examples = null)
    {
        _properties[name] = new JsonSchemaProperty
        {
            Type = "string",
            Description = description,
            Default = defaultValue,
            Pattern = pattern,
            MinLength = minLength,
            MaxLength = maxLength,
            Examples = examples
        };

        if (required) _required.Add(name);
        return this;
    }

    /// <summary>
    /// Add a string property with enum constraint.
    /// </summary>
    /// <param name="name">Property name.</param>
    /// <param name="description">Property description.</param>
    /// <param name="values">Allowed enum values.</param>
    /// <param name="required">Whether the property is required.</param>
    /// <param name="defaultValue">Default value if not provided.</param>
    /// <returns>This builder for chaining.</returns>
    public JsonSchemaBuilder AddEnum(
        string name,
        string description,
        string[] values,
        bool required = false,
        string? defaultValue = null)
    {
        _properties[name] = new JsonSchemaProperty
        {
            Type = "string",
            Description = description,
            Enum = values,
            Default = defaultValue
        };

        if (required) _required.Add(name);
        return this;
    }

    /// <summary>
    /// Add a file path property with appropriate description.
    /// </summary>
    /// <param name="name">Property name (typically "path").</param>
    /// <param name="description">Property description.</param>
    /// <param name="required">Whether the property is required.</param>
    /// <param name="mustExist">Whether the path must exist (added to description).</param>
    /// <returns>This builder for chaining.</returns>
    public JsonSchemaBuilder AddPath(
        string name,
        string description,
        bool required = false,
        bool mustExist = false)
    {
        var desc = description;
        if (mustExist)
            desc += " (must exist)";

        _properties[name] = new JsonSchemaProperty
        {
            Type = "string",
            Description = desc
        };

        if (required) _required.Add(name);
        return this;
    }

    /// <summary>
    /// Add a formatted string property (date, email, uri, etc.).
    /// </summary>
    /// <param name="name">Property name.</param>
    /// <param name="description">Property description.</param>
    /// <param name="format">Format hint: "date-time", "date", "email", "uri", "uuid".</param>
    /// <param name="required">Whether the property is required.</param>
    /// <returns>This builder for chaining.</returns>
    public JsonSchemaBuilder AddFormattedString(
        string name,
        string description,
        string format,
        bool required = false)
    {
        _properties[name] = new JsonSchemaProperty
        {
            Type = "string",
            Description = description,
            Format = format
        };

        if (required) _required.Add(name);
        return this;
    }

    #endregion

    #region Numeric Properties

    /// <summary>
    /// Add an integer property.
    /// </summary>
    /// <param name="name">Property name.</param>
    /// <param name="description">Property description.</param>
    /// <param name="required">Whether the property is required.</param>
    /// <param name="defaultValue">Default value if not provided.</param>
    /// <param name="minimum">Minimum value (inclusive).</param>
    /// <param name="maximum">Maximum value (inclusive).</param>
    /// <returns>This builder for chaining.</returns>
    public JsonSchemaBuilder AddInteger(
        string name,
        string description,
        bool required = false,
        int? defaultValue = null,
        int? minimum = null,
        int? maximum = null)
    {
        _properties[name] = new JsonSchemaProperty
        {
            Type = "integer",
            Description = description,
            Default = defaultValue,
            Minimum = minimum,
            Maximum = maximum
        };

        if (required) _required.Add(name);
        return this;
    }

    /// <summary>
    /// Add a number (floating point) property.
    /// </summary>
    /// <param name="name">Property name.</param>
    /// <param name="description">Property description.</param>
    /// <param name="required">Whether the property is required.</param>
    /// <param name="defaultValue">Default value if not provided.</param>
    /// <param name="minimum">Minimum value (inclusive).</param>
    /// <param name="maximum">Maximum value (inclusive).</param>
    /// <returns>This builder for chaining.</returns>
    public JsonSchemaBuilder AddNumber(
        string name,
        string description,
        bool required = false,
        double? defaultValue = null,
        double? minimum = null,
        double? maximum = null)
    {
        _properties[name] = new JsonSchemaProperty
        {
            Type = "number",
            Description = description,
            Default = defaultValue,
            Minimum = minimum,
            Maximum = maximum
        };

        if (required) _required.Add(name);
        return this;
    }

    #endregion

    #region Boolean Properties

    /// <summary>
    /// Add a boolean property.
    /// </summary>
    /// <param name="name">Property name.</param>
    /// <param name="description">Property description.</param>
    /// <param name="required">Whether the property is required.</param>
    /// <param name="defaultValue">Default value if not provided.</param>
    /// <returns>This builder for chaining.</returns>
    public JsonSchemaBuilder AddBoolean(
        string name,
        string description,
        bool required = false,
        bool? defaultValue = null)
    {
        _properties[name] = new JsonSchemaProperty
        {
            Type = "boolean",
            Description = description,
            Default = defaultValue
        };

        if (required) _required.Add(name);
        return this;
    }

    #endregion

    #region Array Properties

    /// <summary>
    /// Add an array property with string items.
    /// </summary>
    /// <param name="name">Property name.</param>
    /// <param name="description">Property description.</param>
    /// <param name="required">Whether the property is required.</param>
    /// <param name="minItems">Minimum number of items.</param>
    /// <param name="maxItems">Maximum number of items.</param>
    /// <param name="uniqueItems">Whether items must be unique.</param>
    /// <returns>This builder for chaining.</returns>
    public JsonSchemaBuilder AddStringArray(
        string name,
        string description,
        bool required = false,
        int? minItems = null,
        int? maxItems = null,
        bool uniqueItems = false)
    {
        _properties[name] = new JsonSchemaProperty
        {
            Type = "array",
            Description = description,
            Items = new JsonSchemaProperty { Type = "string" },
            MinItems = minItems,
            MaxItems = maxItems,
            UniqueItems = uniqueItems
        };

        if (required) _required.Add(name);
        return this;
    }

    /// <summary>
    /// Add an array property with integer items.
    /// </summary>
    public JsonSchemaBuilder AddIntegerArray(
        string name,
        string description,
        bool required = false,
        int? minItems = null,
        int? maxItems = null)
    {
        _properties[name] = new JsonSchemaProperty
        {
            Type = "array",
            Description = description,
            Items = new JsonSchemaProperty { Type = "integer" },
            MinItems = minItems,
            MaxItems = maxItems
        };

        if (required) _required.Add(name);
        return this;
    }

    /// <summary>
    /// Add an array property with custom item type.
    /// </summary>
    /// <param name="name">Property name.</param>
    /// <param name="description">Property description.</param>
    /// <param name="itemSchema">Schema for array items.</param>
    /// <param name="required">Whether the property is required.</param>
    /// <param name="minItems">Minimum number of items.</param>
    /// <param name="maxItems">Maximum number of items.</param>
    /// <returns>This builder for chaining.</returns>
    public JsonSchemaBuilder AddArray(
        string name,
        string description,
        JsonSchemaProperty itemSchema,
        bool required = false,
        int? minItems = null,
        int? maxItems = null)
    {
        _properties[name] = new JsonSchemaProperty
        {
            Type = "array",
            Description = description,
            Items = itemSchema,
            MinItems = minItems,
            MaxItems = maxItems
        };

        if (required) _required.Add(name);
        return this;
    }

    /// <summary>
    /// Add an array of enum values.
    /// </summary>
    public JsonSchemaBuilder AddEnumArray(
        string name,
        string description,
        string[] enumValues,
        bool required = false,
        bool uniqueItems = true)
    {
        _properties[name] = new JsonSchemaProperty
        {
            Type = "array",
            Description = description,
            Items = new JsonSchemaProperty
            {
                Type = "string",
                Enum = enumValues
            },
            UniqueItems = uniqueItems
        };

        if (required) _required.Add(name);
        return this;
    }

    #endregion

    #region Object Properties

    /// <summary>
    /// Add a nested object property.
    /// </summary>
    /// <param name="name">Property name.</param>
    /// <param name="description">Property description.</param>
    /// <param name="configure">Action to configure the nested schema.</param>
    /// <param name="required">Whether the property is required.</param>
    /// <returns>This builder for chaining.</returns>
    public JsonSchemaBuilder AddObject(
        string name,
        string description,
        Action<JsonSchemaBuilder> configure,
        bool required = false)
    {
        var nestedBuilder = new JsonSchemaBuilder();
        configure(nestedBuilder);
        var nestedSchema = nestedBuilder.Build();

        _properties[name] = new JsonSchemaProperty
        {
            Type = "object",
            Description = description,
            ObjectProperties = nestedSchema.Properties,
            ObjectRequired = nestedSchema.Required.Count > 0 ? nestedSchema.Required : null
        };

        if (required) _required.Add(name);
        return this;
    }

    /// <summary>
    /// Add a nested object property with explicit schema.
    /// </summary>
    /// <param name="name">Property name.</param>
    /// <param name="description">Property description.</param>
    /// <param name="properties">Nested property definitions.</param>
    /// <param name="requiredProperties">Required nested property names.</param>
    /// <param name="required">Whether this object property is required.</param>
    /// <returns>This builder for chaining.</returns>
    public JsonSchemaBuilder AddObject(
        string name,
        string description,
        Dictionary<string, JsonSchemaProperty> properties,
        List<string>? requiredProperties = null,
        bool required = false)
    {
        _properties[name] = new JsonSchemaProperty
        {
            Type = "object",
            Description = description,
            ObjectProperties = properties,
            ObjectRequired = requiredProperties
        };

        if (required) _required.Add(name);
        return this;
    }

    #endregion

    #region Generic Property

    /// <summary>
    /// Add a property with explicit schema.
    /// </summary>
    /// <param name="name">Property name.</param>
    /// <param name="property">Property schema.</param>
    /// <param name="required">Whether the property is required.</param>
    /// <returns>This builder for chaining.</returns>
    public JsonSchemaBuilder AddProperty(
        string name,
        JsonSchemaProperty property,
        bool required = false)
    {
        _properties[name] = property;
        if (required) _required.Add(name);
        return this;
    }

    #endregion

    /// <summary>
    /// Build the JSON Schema.
    /// </summary>
    /// <returns>The constructed JSON schema.</returns>
    public JsonSchema Build() => new()
    {
        Type = "object",
        Description = _description,
        Properties = new Dictionary<string, JsonSchemaProperty>(_properties),
        Required = new List<string>(_required),
        AdditionalProperties = _additionalProperties
    };

    /// <summary>
    /// Implicit conversion to JsonSchema.
    /// </summary>
    public static implicit operator JsonSchema(JsonSchemaBuilder builder) => builder.Build();
}
```

### 4. JsonSchemaExtensions.cs

**Location**: `src/AIntern.Core/Tools/JsonSchemaExtensions.cs`

```csharp
namespace AIntern.Core.Tools;

/// <summary>
/// Extension methods for JSON Schema types.
/// </summary>
public static class JsonSchemaExtensions
{
    /// <summary>
    /// Get a property by name.
    /// </summary>
    /// <param name="schema">The schema.</param>
    /// <param name="name">Property name.</param>
    /// <returns>The property, or null if not found.</returns>
    public static JsonSchemaProperty? GetProperty(this JsonSchema schema, string name) =>
        schema.Properties.GetValueOrDefault(name);

    /// <summary>
    /// Check if a property is required.
    /// </summary>
    /// <param name="schema">The schema.</param>
    /// <param name="propertyName">Property name to check.</param>
    /// <returns>True if the property is required.</returns>
    public static bool IsRequired(this JsonSchema schema, string propertyName) =>
        schema.Required.Contains(propertyName);

    /// <summary>
    /// Get all required property names.
    /// </summary>
    /// <param name="schema">The schema.</param>
    /// <returns>Enumerable of required property names.</returns>
    public static IEnumerable<string> GetRequiredProperties(this JsonSchema schema) =>
        schema.Required;

    /// <summary>
    /// Get all optional property names.
    /// </summary>
    /// <param name="schema">The schema.</param>
    /// <returns>Enumerable of optional property names.</returns>
    public static IEnumerable<string> GetOptionalProperties(this JsonSchema schema) =>
        schema.Properties.Keys.Except(schema.Required);

    /// <summary>
    /// Get properties filtered by type.
    /// </summary>
    /// <param name="schema">The schema.</param>
    /// <param name="type">Property type to filter by.</param>
    /// <returns>Matching properties.</returns>
    public static IEnumerable<(string Name, JsonSchemaProperty Property)> GetPropertiesByType(
        this JsonSchema schema,
        string type) =>
        schema.Properties
            .Where(p => p.Value.Type == type)
            .Select(p => (p.Key, p.Value));

    /// <summary>
    /// Get all string properties.
    /// </summary>
    public static IEnumerable<(string Name, JsonSchemaProperty Property)> GetStringProperties(
        this JsonSchema schema) =>
        schema.GetPropertiesByType("string");

    /// <summary>
    /// Get all enum properties.
    /// </summary>
    public static IEnumerable<(string Name, JsonSchemaProperty Property)> GetEnumProperties(
        this JsonSchema schema) =>
        schema.Properties
            .Where(p => p.Value.Enum != null)
            .Select(p => (p.Key, p.Value));

    /// <summary>
    /// Get all path properties (strings with "path" in name or description).
    /// </summary>
    public static IEnumerable<(string Name, JsonSchemaProperty Property)> GetPathProperties(
        this JsonSchema schema) =>
        schema.Properties
            .Where(p => p.Value.Type == "string" &&
                (p.Key.Contains("path", StringComparison.OrdinalIgnoreCase) ||
                 (p.Value.Description?.Contains("path", StringComparison.OrdinalIgnoreCase) ?? false)))
            .Select(p => (p.Key, p.Value));

    /// <summary>
    /// Create a schema from a .NET type using reflection.
    /// </summary>
    /// <typeparam name="T">The type to generate schema from.</typeparam>
    /// <returns>Generated JSON schema.</returns>
    public static JsonSchema FromType<T>() where T : class =>
        JsonSchemaGenerator.Generate<T>();

    /// <summary>
    /// Merge another schema's properties into this one.
    /// </summary>
    /// <param name="schema">The base schema.</param>
    /// <param name="other">Schema to merge from.</param>
    /// <returns>New merged schema.</returns>
    public static JsonSchema Merge(this JsonSchema schema, JsonSchema other)
    {
        var mergedProperties = new Dictionary<string, JsonSchemaProperty>(schema.Properties);
        foreach (var prop in other.Properties)
        {
            mergedProperties[prop.Key] = prop.Value;
        }

        var mergedRequired = schema.Required.Union(other.Required).ToList();

        return new JsonSchema
        {
            Type = "object",
            Description = schema.Description ?? other.Description,
            Properties = mergedProperties,
            Required = mergedRequired,
            AdditionalProperties = schema.AdditionalProperties || other.AdditionalProperties
        };
    }

    /// <summary>
    /// Create a new schema with only specified properties.
    /// </summary>
    /// <param name="schema">The source schema.</param>
    /// <param name="propertyNames">Properties to keep.</param>
    /// <returns>New schema with only specified properties.</returns>
    public static JsonSchema Pick(this JsonSchema schema, params string[] propertyNames)
    {
        var names = propertyNames.ToHashSet();

        return new JsonSchema
        {
            Type = "object",
            Description = schema.Description,
            Properties = schema.Properties
                .Where(p => names.Contains(p.Key))
                .ToDictionary(p => p.Key, p => p.Value),
            Required = schema.Required.Where(r => names.Contains(r)).ToList(),
            AdditionalProperties = schema.AdditionalProperties
        };
    }

    /// <summary>
    /// Create a new schema without specified properties.
    /// </summary>
    /// <param name="schema">The source schema.</param>
    /// <param name="propertyNames">Properties to exclude.</param>
    /// <returns>New schema without specified properties.</returns>
    public static JsonSchema Omit(this JsonSchema schema, params string[] propertyNames)
    {
        var names = propertyNames.ToHashSet();

        return new JsonSchema
        {
            Type = "object",
            Description = schema.Description,
            Properties = schema.Properties
                .Where(p => !names.Contains(p.Key))
                .ToDictionary(p => p.Key, p => p.Value),
            Required = schema.Required.Where(r => !names.Contains(r)).ToList(),
            AdditionalProperties = schema.AdditionalProperties
        };
    }

    /// <summary>
    /// Make all properties optional.
    /// </summary>
    /// <param name="schema">The source schema.</param>
    /// <returns>New schema with no required properties.</returns>
    public static JsonSchema MakeAllOptional(this JsonSchema schema) =>
        new()
        {
            Type = "object",
            Description = schema.Description,
            Properties = schema.Properties,
            Required = new List<string>(),
            AdditionalProperties = schema.AdditionalProperties
        };

    /// <summary>
    /// Make specified properties required.
    /// </summary>
    /// <param name="schema">The source schema.</param>
    /// <param name="propertyNames">Properties to make required.</param>
    /// <returns>New schema with updated required list.</returns>
    public static JsonSchema MakeRequired(this JsonSchema schema, params string[] propertyNames)
    {
        var existing = schema.Properties.Keys.ToHashSet();
        var valid = propertyNames.Where(n => existing.Contains(n)).ToList();

        return new JsonSchema
        {
            Type = "object",
            Description = schema.Description,
            Properties = schema.Properties,
            Required = schema.Required.Union(valid).ToList(),
            AdditionalProperties = schema.AdditionalProperties
        };
    }
}
```

### 5. JsonSchemaGenerator.cs

**Location**: `src/AIntern.Core/Tools/JsonSchemaGenerator.cs`

```csharp
namespace AIntern.Core.Tools;

using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Reflection;
using System.Text.Json.Serialization;

/// <summary>
/// Generates JSON Schema from .NET types using reflection.
/// </summary>
/// <remarks>
/// <para>
/// The generator creates JSON schemas by inspecting .NET types and their
/// data annotation attributes. This enables automatic schema generation
/// for parameter DTOs.
/// </para>
/// <para>
/// Supported attributes:
/// </para>
/// <list type="bullet">
/// <item><see cref="DescriptionAttribute"/> - Property description</item>
/// <item><see cref="RequiredAttribute"/> - Required property</item>
/// <item><see cref="RangeAttribute"/> - Numeric range</item>
/// <item><see cref="MinLengthAttribute"/>, <see cref="MaxLengthAttribute"/> - String length</item>
/// <item><see cref="RegularExpressionAttribute"/> - String pattern</item>
/// <item><see cref="JsonPropertyNameAttribute"/> - Custom JSON name</item>
/// </list>
/// </remarks>
public static class JsonSchemaGenerator
{
    /// <summary>
    /// Generate a JSON Schema from a type.
    /// </summary>
    /// <typeparam name="T">The type to generate schema from.</typeparam>
    /// <returns>Generated JSON schema.</returns>
    public static JsonSchema Generate<T>() where T : class =>
        Generate(typeof(T));

    /// <summary>
    /// Generate a JSON Schema from a type.
    /// </summary>
    /// <param name="type">The type to generate schema from.</param>
    /// <returns>Generated JSON schema.</returns>
    public static JsonSchema Generate(Type type)
    {
        var builder = JsonSchemaBuilder.Create();

        // Get description from DescriptionAttribute on class
        var typeDesc = type.GetCustomAttribute<DescriptionAttribute>();
        if (typeDesc != null)
        {
            builder.WithDescription(typeDesc.Description);
        }

        // Process all public properties
        foreach (var prop in type.GetProperties(BindingFlags.Public | BindingFlags.Instance))
        {
            // Skip properties with JsonIgnore
            if (prop.GetCustomAttribute<JsonIgnoreAttribute>() != null)
                continue;

            var schemaProperty = GeneratePropertySchema(prop);
            if (schemaProperty == null)
                continue;

            // Get JSON property name
            var jsonName = prop.GetCustomAttribute<JsonPropertyNameAttribute>()?.Name
                ?? ToCamelCase(prop.Name);

            var isRequired = prop.GetCustomAttribute<RequiredAttribute>() != null;

            builder.AddProperty(jsonName, schemaProperty, isRequired);
        }

        return builder.Build();
    }

    /// <summary>
    /// Generate a property schema from a PropertyInfo.
    /// </summary>
    private static JsonSchemaProperty? GeneratePropertySchema(PropertyInfo prop)
    {
        var propType = Nullable.GetUnderlyingType(prop.PropertyType) ?? prop.PropertyType;
        var description = prop.GetCustomAttribute<DescriptionAttribute>()?.Description
            ?? FormatPropertyName(prop.Name);

        // String
        if (propType == typeof(string))
        {
            return GenerateStringProperty(prop, description);
        }

        // Integer types
        if (propType == typeof(int) || propType == typeof(long) ||
            propType == typeof(short) || propType == typeof(byte))
        {
            return GenerateIntegerProperty(prop, description);
        }

        // Floating point types
        if (propType == typeof(double) || propType == typeof(float) || propType == typeof(decimal))
        {
            return GenerateNumberProperty(prop, description);
        }

        // Boolean
        if (propType == typeof(bool))
        {
            return new JsonSchemaProperty
            {
                Type = "boolean",
                Description = description
            };
        }

        // Enum
        if (propType.IsEnum)
        {
            var values = Enum.GetNames(propType);
            return new JsonSchemaProperty
            {
                Type = "string",
                Description = description,
                Enum = values
            };
        }

        // Arrays and Lists
        if (propType.IsArray || (propType.IsGenericType &&
            propType.GetGenericTypeDefinition() == typeof(List<>)))
        {
            return GenerateArrayProperty(prop, propType, description);
        }

        // Nested objects
        if (propType.IsClass && propType != typeof(string))
        {
            var nestedSchema = Generate(propType);
            return new JsonSchemaProperty
            {
                Type = "object",
                Description = description,
                ObjectProperties = nestedSchema.Properties,
                ObjectRequired = nestedSchema.Required.Count > 0 ? nestedSchema.Required : null
            };
        }

        // Unsupported type - skip
        return null;
    }

    private static JsonSchemaProperty GenerateStringProperty(PropertyInfo prop, string description)
    {
        var minLength = prop.GetCustomAttribute<MinLengthAttribute>()?.Length;
        var maxLength = prop.GetCustomAttribute<MaxLengthAttribute>()?.Length;
        var stringLength = prop.GetCustomAttribute<StringLengthAttribute>();
        var pattern = prop.GetCustomAttribute<RegularExpressionAttribute>()?.Pattern;

        return new JsonSchemaProperty
        {
            Type = "string",
            Description = description,
            MinLength = minLength ?? stringLength?.MinimumLength,
            MaxLength = maxLength ?? stringLength?.MaximumLength,
            Pattern = pattern
        };
    }

    private static JsonSchemaProperty GenerateIntegerProperty(PropertyInfo prop, string description)
    {
        var range = prop.GetCustomAttribute<RangeAttribute>();

        return new JsonSchemaProperty
        {
            Type = "integer",
            Description = description,
            Minimum = range != null ? Convert.ToDouble(range.Minimum) : null,
            Maximum = range != null ? Convert.ToDouble(range.Maximum) : null
        };
    }

    private static JsonSchemaProperty GenerateNumberProperty(PropertyInfo prop, string description)
    {
        var range = prop.GetCustomAttribute<RangeAttribute>();

        return new JsonSchemaProperty
        {
            Type = "number",
            Description = description,
            Minimum = range != null ? Convert.ToDouble(range.Minimum) : null,
            Maximum = range != null ? Convert.ToDouble(range.Maximum) : null
        };
    }

    private static JsonSchemaProperty GenerateArrayProperty(PropertyInfo prop, Type propType, string description)
    {
        var elementType = propType.IsArray
            ? propType.GetElementType()!
            : propType.GetGenericArguments()[0];

        var itemSchema = GetItemSchemaForType(elementType);

        var minLength = prop.GetCustomAttribute<MinLengthAttribute>()?.Length;
        var maxLength = prop.GetCustomAttribute<MaxLengthAttribute>()?.Length;

        return new JsonSchemaProperty
        {
            Type = "array",
            Description = description,
            Items = itemSchema,
            MinItems = minLength,
            MaxItems = maxLength
        };
    }

    private static JsonSchemaProperty GetItemSchemaForType(Type type)
    {
        if (type == typeof(string))
            return new JsonSchemaProperty { Type = "string" };

        if (type == typeof(int) || type == typeof(long))
            return new JsonSchemaProperty { Type = "integer" };

        if (type == typeof(double) || type == typeof(float))
            return new JsonSchemaProperty { Type = "number" };

        if (type == typeof(bool))
            return new JsonSchemaProperty { Type = "boolean" };

        if (type.IsEnum)
        {
            return new JsonSchemaProperty
            {
                Type = "string",
                Enum = Enum.GetNames(type)
            };
        }

        // Nested object
        if (type.IsClass)
        {
            var nestedSchema = Generate(type);
            return new JsonSchemaProperty
            {
                Type = "object",
                ObjectProperties = nestedSchema.Properties,
                ObjectRequired = nestedSchema.Required.Count > 0 ? nestedSchema.Required : null
            };
        }

        return new JsonSchemaProperty { Type = "string" };
    }

    private static string ToCamelCase(string name)
    {
        if (string.IsNullOrEmpty(name))
            return name;

        return char.ToLowerInvariant(name[0]) + name[1..];
    }

    private static string FormatPropertyName(string name)
    {
        // Convert PascalCase to "Pascal Case"
        var result = new System.Text.StringBuilder();
        foreach (var c in name)
        {
            if (char.IsUpper(c) && result.Length > 0)
                result.Append(' ');
            result.Append(c);
        }
        return result.ToString();
    }
}
```

---

## Directory Structure

```
src/AIntern.Core/
└── Tools/
    ├── JsonSchema.cs                  (NEW - replaces forward declaration)
    ├── JsonSchemaProperty.cs          (NEW - replaces forward declaration)
    ├── JsonSchemaBuilder.cs           (NEW)
    ├── JsonSchemaExtensions.cs        (NEW)
    └── JsonSchemaGenerator.cs         (NEW)
```

---

## Unit Test Plan

| Test Class | Test | Description |
|------------|------|-------------|
| **JsonSchemaTests** | | |
| | `Empty_HasNoProperties` | Empty schema has 0 properties |
| | `Empty_HasNoRequired` | Empty schema has 0 required |
| | `ToJson_ProducesValidJson` | Serialization works |
| | `FromJson_ParsesCorrectly` | Deserialization works |
| | `SingleString_HasOneProperty` | Factory creates correct schema |
| | `SinglePath_UsesDefaultName` | Path factory uses "path" |
| | `HasProperty_ReturnsTrue` | Property exists check |
| | `HasProperty_ReturnsFalse` | Property not exists check |
| | `IsPropertyRequired_ReturnsTrue` | Required property check |
| | `IsPropertyRequired_ReturnsFalse` | Optional property check |
| **JsonSchemaPropertyTests** | | |
| | `String_HasCorrectType` | Type is "string" |
| | `Enum_HasValues` | Enum values set |
| | `Integer_HasCorrectType` | Type is "integer" |
| | `Integer_HasRange` | Min/max set |
| | `Number_HasCorrectType` | Type is "number" |
| | `Boolean_HasCorrectType` | Type is "boolean" |
| | `StringArray_HasItemsSchema` | Items defined |
| | `Factory_String_CreatesCorrectProperty` | Factory method |
| | `Factory_Enum_CreatesCorrectProperty` | Factory method |
| | `Factory_Integer_CreatesCorrectProperty` | Factory method |
| **JsonSchemaBuilderTests** | | |
| | `Create_ReturnsEmptyBuilder` | Fresh builder |
| | `WithDescription_SetsDescription` | Description set |
| | `AddString_AddsProperty` | String property added |
| | `AddString_Required_AddsToRequired` | Required tracked |
| | `AddEnum_AddsPropertyWithValues` | Enum values set |
| | `AddPath_AddsStringProperty` | Path as string |
| | `AddPath_MustExist_AddsToDescription` | Description updated |
| | `AddInteger_AddsProperty` | Integer property added |
| | `AddInteger_WithRange_SetsMinMax` | Range applied |
| | `AddNumber_AddsProperty` | Number property added |
| | `AddBoolean_AddsProperty` | Boolean property added |
| | `AddBoolean_WithDefault_SetsDefault` | Default value set |
| | `AddStringArray_AddsArrayProperty` | Array property added |
| | `AddStringArray_HasStringItems` | Items schema correct |
| | `AddObject_AddsNestedProperties` | Nested object works |
| | `AddObject_WithRequired_TracksNested` | Nested required works |
| | `Build_CreatesImmutableSchema` | Schema is immutable |
| | `Build_CanBuildMultipleTimes` | Builder reusable |
| | `ImplicitConversion_Works` | Implicit to JsonSchema |
| **JsonSchemaExtensionsTests** | | |
| | `GetProperty_ExistingProperty_Returns` | Property lookup |
| | `GetProperty_MissingProperty_ReturnsNull` | Missing returns null |
| | `IsRequired_RequiredProperty_ReturnsTrue` | Required check |
| | `IsRequired_OptionalProperty_ReturnsFalse` | Optional check |
| | `GetRequiredProperties_ReturnsAll` | All required listed |
| | `GetOptionalProperties_ReturnsAll` | All optional listed |
| | `GetStringProperties_FiltersCorrectly` | Type filter |
| | `GetEnumProperties_FiltersCorrectly` | Enum filter |
| | `Merge_CombinesProperties` | Merge works |
| | `Merge_CombinesRequired` | Required merged |
| | `Pick_KeepsOnlySpecified` | Pick subset |
| | `Omit_RemovesSpecified` | Omit works |
| | `MakeAllOptional_ClearsRequired` | All optional |
| | `MakeRequired_AddsToRequired` | Make required |
| **JsonSchemaGeneratorTests** | | |
| | `Generate_StringProperty_CreatesString` | String detected |
| | `Generate_IntProperty_CreatesInteger` | Int detected |
| | `Generate_DoubleProperty_CreatesNumber` | Double detected |
| | `Generate_BoolProperty_CreatesBoolean` | Bool detected |
| | `Generate_EnumProperty_CreatesEnum` | Enum detected |
| | `Generate_ListProperty_CreatesArray` | List detected |
| | `Generate_ArrayProperty_CreatesArray` | Array detected |
| | `Generate_NestedClass_CreatesObject` | Nested object |
| | `Generate_DescriptionAttribute_Used` | Description read |
| | `Generate_RequiredAttribute_MarksRequired` | Required read |
| | `Generate_RangeAttribute_SetsMinMax` | Range read |
| | `Generate_MinMaxLengthAttributes_Set` | Length read |
| | `Generate_RegexAttribute_SetsPattern` | Pattern read |
| | `Generate_JsonPropertyName_Used` | Custom name read |
| | `Generate_JsonIgnore_Skipped` | Ignored properties |
| | `Generate_NullableType_Optional` | Nullable handling |

**Total Tests**: 62

---

## Integration Points

### With v0.6.1a (Tool Core Models)

Remove forward declarations from `ToolTypes.cs`:
- `JsonSchema` class
- `JsonSchemaProperty` class

### With v0.6.1d (Tool Validation)

The `IToolValidator` uses these types:
```csharp
ToolValidationResult ValidateAgainstSchema(JsonElement parameters, JsonSchema schema);
IEnumerable<ToolValidationError> ValidateParameter(string name, JsonElement value, JsonSchemaProperty property);
```

### With v0.6.1f (Tool Base Class)

Tools define their parameter schema:
```csharp
public override JsonSchema InputSchema => JsonSchemaBuilder.Create()
    .AddPath("path", "File path to read", required: true)
    .AddInteger("maxLines", "Maximum lines", maximum: 10000)
    .Build();
```

### With v0.6.1g (Tool Registry)

Function definitions use the schema:
```csharp
public static FunctionDefinition FromTool(ITool tool) => new()
{
    Name = tool.Id,
    Description = tool.Description,
    Parameters = tool.InputSchema
};
```

---

## File Summary

### Files to Create

| File | Location | Lines | Purpose |
|------|----------|-------|---------|
| `JsonSchema.cs` | `Core/Tools/` | ~180 | Schema model with serialization |
| `JsonSchemaProperty.cs` | `Core/Tools/` | ~280 | Property model with factories |
| `JsonSchemaBuilder.cs` | `Core/Tools/` | ~380 | Fluent builder |
| `JsonSchemaExtensions.cs` | `Core/Tools/` | ~180 | Extension methods |
| `JsonSchemaGenerator.cs` | `Core/Tools/` | ~220 | Reflection-based generation |
| **Total** | | **~1240** | |

### Files to Modify

| File | Changes |
|------|---------|
| `Core/Tools/ToolTypes.cs` | Remove `JsonSchema` and `JsonSchemaProperty` forward declarations |

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | `JsonSchema.ToJson()` produces OpenAI-compatible output |
| AC-2 | `JsonSchemaBuilder` creates schemas with all property types |
| AC-3 | `JsonSchemaBuilder` tracks required properties correctly |
| AC-4 | `JsonSchemaProperty` supports all JSON Schema constraints |
| AC-5 | `JsonSchemaGenerator` creates schemas from DTO classes |
| AC-6 | `JsonSchemaGenerator` respects data annotation attributes |
| AC-7 | Extension methods provide useful query operations |
| AC-8 | Nested object schemas work correctly |
| AC-9 | Array item schemas are properly defined |
| AC-10 | All 62 unit tests pass |

---

## Changelog Entry

```markdown
## v0.6.1e - JSON Schema System

### Added
- `JsonSchema` with:
  - OpenAI function calling compatible structure
  - Properties, Required, AdditionalProperties
  - ToJson(), ToPrettyJson(), FromJson() serialization
  - Factory methods: Empty, SingleString, SinglePath
  - Helper methods for property inspection

- `JsonSchemaProperty` with:
  - All JSON Schema Draft 7 property types
  - String constraints: enum, pattern, minLength, maxLength
  - Numeric constraints: minimum, maximum
  - Array constraints: items, minItems, maxItems, uniqueItems
  - Object constraints: properties, required
  - Factory methods for each type

- `JsonSchemaBuilder` with:
  - Fluent builder pattern
  - Type-safe property addition methods
  - Support for nested objects
  - Implicit conversion to JsonSchema

- `JsonSchemaExtensions` with:
  - Property query methods
  - Schema manipulation (Merge, Pick, Omit)
  - Type-based generation shortcut

- `JsonSchemaGenerator` with:
  - Reflection-based schema generation
  - Data annotation attribute support
  - Nested type handling
  - Array and collection support

### Changed
- Removed forward declarations from `ToolTypes.cs`
```

---

## Implementation Notes

### OpenAI Compatibility

The schema format matches OpenAI's function calling specification:
- Top-level type is always "object"
- Properties define parameter schemas
- Required lists mandatory parameters
- additionalProperties defaults to false

### Builder Best Practices

```csharp
// Good: Clear, fluent style
var schema = JsonSchemaBuilder.Create()
    .WithDescription("File reading parameters")
    .AddPath("path", "Path to read", required: true)
    .AddInteger("maxLines", "Max lines to read")
    .Build();

// Good: Nested objects
var schema = JsonSchemaBuilder.Create()
    .AddObject("options", "Search options", opts =>
    {
        opts.AddBoolean("caseSensitive", "Case sensitive search");
        opts.AddInteger("maxResults", "Maximum results");
    })
    .Build();
```

### Generator Best Practices

Use data annotations for rich schemas:
```csharp
public class FileReadParameters
{
    [Required]
    [Description("Path to the file to read")]
    public string Path { get; set; } = string.Empty;

    [Range(1, 10000)]
    [Description("Maximum lines to read")]
    public int? MaxLines { get; set; }
}

var schema = JsonSchemaGenerator.Generate<FileReadParameters>();
```

---

## Timeline Estimate

| Task | Estimated Effort |
|------|------------------|
| JsonSchema | 0.25 day |
| JsonSchemaProperty | 0.3 day |
| JsonSchemaBuilder | 0.4 day |
| JsonSchemaExtensions | 0.2 day |
| JsonSchemaGenerator | 0.35 day |
| Unit Tests | 0.5 day |
| **Total** | **2.0 days** |
