# Design Specification: AIntern v0.6.3g "Content Search Tools"

## Overview

**Version**: v0.6.3g
**Parent**: v0.6.3 Built-in Tools
**Focus**: SearchContentTool for finding text within files (grep-like functionality)

### Purpose

Implement content search tools that enable the AI agent to:
1. Search for text content within files
2. Support plain text and regular expression patterns
3. Configure case sensitivity
4. Match whole words only
5. Include context lines before/after matches
6. Skip binary and large files automatically
7. Limit results to prevent overflow
8. Return matches with file paths and line numbers

### Dependencies

**From v0.6.3f (File Search Tools)**:
- Glob pattern matching for file filtering
- Default exclusion patterns

**From v0.6.3a (File Read Tools)**:
- `ToolPathHelper` for path validation
- File reading capabilities

**From v0.6.1 (Tool Framework)**:
- `ToolBase`, `ToolResult`
- `JsonSchemaBuilder`, `RiskLevel`

**External**:
- `Microsoft.Extensions.FileSystemGlobbing` for file pattern matching
- `System.Text.RegularExpressions` for regex support

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                   v0.6.3g Content Search Tools Architecture                   │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  src/SeniorIntern.Services/Tools/Search/                                     │
│  ├─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  SearchContentTool : ToolBase                                            │ │
│  │  ┌─────────────────────────────────────────────────────────────────────┐│ │
│  │  │  Id: "search-content"                                                ││ │
│  │  │  DefaultRiskLevel: Safe                                              ││ │
│  │  │                                                                      ││ │
│  │  │  Parameters                                                           ││ │
│  │  │  ├── query: string (required) - Search text or regex                 ││ │
│  │  │  ├── file_pattern: string (default: "**/*")                          ││ │
│  │  │  ├── regex: bool (default: false) - Treat as regex                   ││ │
│  │  │  ├── case_sensitive: bool (default: false)                           ││ │
│  │  │  ├── whole_word: bool (default: false)                               ││ │
│  │  │  ├── context_lines: int (default: 0, max: 5)                         ││ │
│  │  │  └── max_results: int (default: 50)                                  ││ │
│  │  │                                                                      ││ │
│  │  │  Constants                                                            ││ │
│  │  │  ├── DefaultMaxResults = 50                                          ││ │
│  │  │  ├── MaxContextLines = 5                                             ││ │
│  │  │  └── MaxFileSize = 1 MB                                              ││ │
│  │  │                                                                      ││ │
│  │  │  Binary Extensions (skipped)                                          ││ │
│  │  │  ├── .exe, .dll, .so, .dylib                                         ││ │
│  │  │  ├── .png, .jpg, .gif, .pdf                                          ││ │
│  │  │  └── .zip, .tar, .gz                                                 ││ │
│  │  └─────────────────────────────────────────────────────────────────────┘│ │
│  │                                                                          │ │
│  │  ContentSearchResult         ContentSearchResultData                     │ │
│  │  ├── File: string            ├── Query: string                          │ │
│  │  ├── Line: int               ├── FilePattern: string                    │ │
│  │  ├── Content: string         ├── MatchCount: int                        │ │
│  │  ├── ContextBefore: string[] ├── FilesSearched: int                     │ │
│  │  └── ContextAfter: string[]  └── WasTruncated: bool                     │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Search Pattern Building

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                      Search Pattern Transformation                            │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Input Query: "getUserById"                                                  │
│                                                                              │
│  Transformations based on options:                                           │
│                                                                              │
│  ┌────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                         │ │
│  │  regex=false, whole_word=false                                          │ │
│  │  └── Pattern: "getUserById" (escaped literal)                           │ │
│  │                                                                         │ │
│  │  regex=false, whole_word=true                                           │ │
│  │  └── Pattern: "\bgetUserById\b"                                         │ │
│  │                                                                         │ │
│  │  regex=true, whole_word=false                                           │ │
│  │  └── Pattern: "getUserById" (as regex, e.g., getUser.Id)                │ │
│  │                                                                         │ │
│  │  regex=true, whole_word=true                                            │ │
│  │  └── Pattern: "\bgetUserById\b" (word-bounded regex)                    │ │
│  │                                                                         │ │
│  │  Case Sensitivity:                                                       │ │
│  │  ├── case_sensitive=true  → RegexOptions.None                           │ │
│  │  └── case_sensitive=false → RegexOptions.IgnoreCase                     │ │
│  │                                                                         │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  Common Query Examples:                                                      │
│  ──────────────────────────────────────────────────────────────────────────  │
│  "TODO"                    Find all TODO comments                            │
│  "function.*async"         Find async functions (regex)                      │
│  "class\s+\w+Service"      Find service classes (regex)                      │
│  "import.*from"            Find import statements (regex)                    │
│  "Error:"                  Find error messages                               │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Execution Flow

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                      SearchContentTool Execution Flow                         │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ExecuteAsync(context)                                                       │
│      │                                                                       │
│      ▼                                                                       │
│  ┌─────────────────────────────┐                                             │
│  │  1. Extract Parameters      │                                             │
│  │  ├── query (required)       │                                             │
│  │  ├── file_pattern           │                                             │
│  │  ├── regex, case_sensitive  │                                             │
│  │  ├── whole_word             │                                             │
│  │  ├── context_lines          │                                             │
│  │  └── max_results            │                                             │
│  └─────────────┬───────────────┘                                             │
│                │                                                             │
│                ▼                                                             │
│  ┌─────────────────────────────┐                                             │
│  │  2. Clamp context_lines     │                                             │
│  │  Min(input, MaxContextLines)│                                             │
│  └─────────────┬───────────────┘                                             │
│                │                                                             │
│                ▼                                                             │
│  ┌─────────────────────────────┐                                             │
│  │  3. Build Search Pattern    │                                             │
│  │  BuildSearchPattern()       │                                             │
│  │  ├── Escape if not regex    │                                             │
│  │  └── Add word boundaries    │                                             │
│  └─────────────┬───────────────┘                                             │
│                │                                                             │
│                ▼                                                             │
│  ┌─────────────────────────────┐                                             │
│  │  4. Create Compiled Regex   │                                             │
│  │  with case sensitivity      │                                             │
│  └─────────────┬───────────────┘                                             │
│                │                                                             │
│                ▼                                                             │
│  ┌─────────────────────────────┐                                             │
│  │  5. Find Files to Search    │                                             │
│  │  ├── Apply file_pattern     │                                             │
│  │  └── Apply exclusions       │                                             │
│  └─────────────┬───────────────┘                                             │
│                │                                                             │
│                ▼                                                             │
│  ┌─────────────────────────────┐                                             │
│  │  6. For Each File:          │◄────────────────────┐                       │
│  │  ├── Check if text file     │                     │                       │
│  │  ├── Check size < 1MB       │                     │                       │
│  │  ├── Read content           │                     │                       │
│  │  ├── Split into lines       │                     │ Loop until            │
│  │  └── Search each line       │─────────────────────┘ max_results           │
│  └─────────────┬───────────────┘                                             │
│                │                                                             │
│                ▼                                                             │
│  ┌─────────────────────────────┐                                             │
│  │  7. Collect Matches         │                                             │
│  │  ├── File path              │                                             │
│  │  ├── Line number            │                                             │
│  │  ├── Matched content        │                                             │
│  │  └── Context lines          │                                             │
│  └─────────────┬───────────────┘                                             │
│                │                                                             │
│                ▼                                                             │
│  ┌─────────────────────────────┐                                             │
│  │  8. Format Output           │                                             │
│  │  file:line: content         │                                             │
│  │    [context if requested]   │                                             │
│  └─────────────┬───────────────┘                                             │
│                │                                                             │
│                ▼                                                             │
│  ┌─────────────────────────────┐                                             │
│  │  9. Build Result            │                                             │
│  │  ├── Formatted output       │                                             │
│  │  ├── ContentSearchResultData│                                             │
│  │  └── Summary message        │                                             │
│  └─────────────────────────────┘                                             │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Specifications

### 1. SearchContentTool.cs

**Location**: `src/SeniorIntern.Services/Tools/Search/SearchContentTool.cs`

```csharp
namespace SeniorIntern.Services.Tools.Search;

using System.Text;
using System.Text.Json;
using System.Text.RegularExpressions;
using Microsoft.Extensions.FileSystemGlobbing;
using Microsoft.Extensions.FileSystemGlobbing.Abstractions;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Core.Tools;
using SeniorIntern.Services.Tools;

/// <summary>
/// Tool for searching content within files.
/// </summary>
/// <remarks>
/// <para>
/// SearchContentTool provides grep-like functionality for the AI agent:
/// </para>
/// <list type="bullet">
/// <item>Plain text and regex pattern support</item>
/// <item>Case-sensitive and whole-word options</item>
/// <item>Context lines for surrounding code</item>
/// <item>Binary file detection and skipping</item>
/// </list>
/// </remarks>
public sealed class SearchContentTool : ToolBase
{
    #region Tool Metadata

    public override string Id => "search-content";

    public override string Name => "Search Content";

    public override string Description => """
        Search for text content within files in the workspace.
        Supports plain text and regular expression patterns.
        Returns matching lines with file paths and line numbers.

        Use this to:
        - Find where a function is defined or called
        - Locate specific error messages
        - Find TODO comments
        - Search for configuration values
        """;

    public override ToolCategory Category => ToolCategory.Search;

    public override RiskLevel DefaultRiskLevel => RiskLevel.Safe;

    public override IReadOnlyList<string> Tags => new[] { "search", "content", "grep", "text" };

    public override JsonSchema InputSchema => JsonSchemaBuilder.Create()
        .WithDescription("Parameters for content search")
        .AddString("query", "Search query (text or regex pattern)", required: true)
        .AddString("file_pattern", "Glob pattern to filter files (default: '**/*')", required: false)
        .AddBoolean("regex", "Treat query as regular expression (default: false)", required: false)
        .AddBoolean("case_sensitive", "Case-sensitive search (default: false)", required: false)
        .AddBoolean("whole_word", "Match whole words only (default: false)", required: false)
        .AddInteger("context_lines", "Lines of context before/after match (default: 0)", required: false)
        .AddInteger("max_results", "Maximum results (default: 50)", required: false)
        .Build();

    #endregion

    #region Dependencies

    private readonly IFileSystemService _fileSystem;
    private readonly IWorkspaceService _workspace;
    private readonly ILogger<SearchContentTool> _logger;

    #endregion

    #region Constants

    /// <summary>
    /// Default maximum results.
    /// </summary>
    public const int DefaultMaxResults = 50;

    /// <summary>
    /// Maximum context lines.
    /// </summary>
    public const int MaxContextLines = 5;

    /// <summary>
    /// Maximum file size to search (1 MB).
    /// </summary>
    public const int MaxFileSize = 1024 * 1024;

    /// <summary>
    /// Binary file extensions to skip.
    /// </summary>
    private static readonly HashSet<string> BinaryExtensions = new(StringComparer.OrdinalIgnoreCase)
    {
        ".exe", ".dll", ".so", ".dylib", ".obj", ".o",
        ".png", ".jpg", ".jpeg", ".gif", ".bmp", ".ico", ".webp",
        ".pdf", ".doc", ".docx", ".xls", ".xlsx",
        ".zip", ".tar", ".gz", ".7z", ".rar",
        ".mp3", ".mp4", ".avi", ".mov", ".wav",
        ".bin", ".dat", ".db", ".sqlite"
    };

    /// <summary>
    /// Default file exclusions.
    /// </summary>
    private static readonly string[] DefaultExclusions =
    {
        "**/node_modules/**", "**/bin/**", "**/obj/**",
        "**/.git/**", "**/dist/**", "**/*.min.js",
        "**/*.min.css", "**/package-lock.json", "**/yarn.lock"
    };

    #endregion

    public SearchContentTool(
        IFileSystemService fileSystem,
        IWorkspaceService workspace,
        ILogger<SearchContentTool> logger)
    {
        _fileSystem = fileSystem ?? throw new ArgumentNullException(nameof(fileSystem));
        _workspace = workspace ?? throw new ArgumentNullException(nameof(workspace));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    public override bool IsAvailable => _workspace.CurrentWorkspace != null;

    #region ExecuteAsync

    public override async Task<ToolResult> ExecuteAsync(
        ToolExecutionContext context,
        CancellationToken ct = default)
    {
        // Extract parameters
        var query = GetRequiredParameter<string>(context.Parameters, "query");
        var filePattern = GetOptionalParameter(context.Parameters, "file_pattern", "**/*");
        var useRegex = GetOptionalParameter(context.Parameters, "regex", false);
        var caseSensitive = GetOptionalParameter(context.Parameters, "case_sensitive", false);
        var wholeWord = GetOptionalParameter(context.Parameters, "whole_word", false);
        var contextLines = Math.Min(
            GetOptionalParameter(context.Parameters, "context_lines", 0),
            MaxContextLines);
        var maxResults = GetOptionalParameter(context.Parameters, "max_results", DefaultMaxResults);

        _logger.LogDebug(
            "SearchContentTool executing: query={Query}, pattern={Pattern}, regex={Regex}",
            query.Length > 30 ? query[..27] + "..." : query, filePattern, useRegex);

        try
        {
            // Build the search regex
            var searchPattern = BuildSearchPattern(query, useRegex, wholeWord);
            var regexOptions = caseSensitive
                ? RegexOptions.Compiled
                : RegexOptions.Compiled | RegexOptions.IgnoreCase;

            Regex regex;
            try
            {
                regex = new Regex(searchPattern, regexOptions);
            }
            catch (RegexParseException ex)
            {
                _logger.LogWarning("Invalid regex pattern: {Pattern}", searchPattern);
                return ToolResult.Failed($"Invalid regex pattern: {ex.Message}");
            }

            // Find files to search
            var matcher = new Matcher();
            matcher.AddInclude(filePattern);
            AddDefaultExclusions(matcher);

            var directoryInfo = new DirectoryInfo(context.WorkspacePath!);
            var matchResult = matcher.Execute(new DirectoryInfoWrapper(directoryInfo));

            var results = new List<ContentSearchResult>();
            var filesSearched = 0;

            foreach (var file in matchResult.Files)
            {
                if (results.Count >= maxResults) break;
                ct.ThrowIfCancellationRequested();

                var fullPath = Path.Combine(context.WorkspacePath!, file.Path);

                // Skip binary files
                if (!await IsTextFileAsync(fullPath, ct)) continue;

                // Skip large files
                var fileInfo = await _fileSystem.GetFileInfoAsync(fullPath, ct);
                if (fileInfo.Size > MaxFileSize) continue;

                filesSearched++;

                // Read and search content
                var content = await _fileSystem.ReadFileAsync(fullPath, ct);
                var lines = content.Split('\n');

                for (int i = 0; i < lines.Length && results.Count < maxResults; i++)
                {
                    if (regex.IsMatch(lines[i]))
                    {
                        results.Add(new ContentSearchResult
                        {
                            File = file.Path,
                            Line = i + 1,
                            Content = lines[i].Trim(),
                            ContextBefore = GetContextLines(lines, i, -contextLines),
                            ContextAfter = GetContextLines(lines, i, contextLines)
                        });
                    }
                }
            }

            // Format output
            var output = FormatResults(results, contextLines > 0);

            var resultData = new ContentSearchResultData
            {
                Query = query,
                FilePattern = filePattern,
                MatchCount = results.Count,
                FilesSearched = filesSearched,
                WasTruncated = results.Count >= maxResults
            };

            var message = results.Count >= maxResults
                ? $"Found {results.Count}+ matches for '{TruncateQuery(query)}' (showing first {maxResults})"
                : $"Found {results.Count} matches for '{TruncateQuery(query)}' in {filesSearched} files";

            _logger.LogInformation(
                "SearchContentTool success: query={Query}, matches={Count}, files={Files}",
                TruncateQuery(query), results.Count, filesSearched);

            return ToolResult.Success(output, resultData, message);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Content search failed for query: {Query}", TruncateQuery(query));
            return ToolResult.Failed($"Search failed: {ex.Message}");
        }
    }

    #endregion

    #region Pattern Building

    /// <summary>
    /// Build the search pattern from query and options.
    /// </summary>
    private static string BuildSearchPattern(string query, bool isRegex, bool wholeWord)
    {
        // Escape if not a regex
        var pattern = isRegex ? query : Regex.Escape(query);

        // Add word boundaries if requested
        if (wholeWord)
        {
            pattern = $@"\b{pattern}\b";
        }

        return pattern;
    }

    /// <summary>
    /// Add default file exclusions to matcher.
    /// </summary>
    private static void AddDefaultExclusions(Matcher matcher)
    {
        foreach (var exclusion in DefaultExclusions)
        {
            matcher.AddExclude(exclusion);
        }
    }

    #endregion

    #region File Detection

    /// <summary>
    /// Check if a file is a text file (not binary).
    /// </summary>
    private async Task<bool> IsTextFileAsync(string path, CancellationToken ct)
    {
        // Check extension first
        var ext = Path.GetExtension(path);
        if (BinaryExtensions.Contains(ext))
        {
            return false;
        }

        // Quick binary check by reading first bytes
        try
        {
            var bytes = await _fileSystem.ReadFileBytesAsync(path, 1000, ct);
            if (bytes.Length < 4) return true;

            // Check for null bytes (common in binary files)
            return !bytes.Contains((byte)0);
        }
        catch
        {
            return false;
        }
    }

    #endregion

    #region Context Lines

    /// <summary>
    /// Get context lines before or after a match.
    /// </summary>
    private static string[] GetContextLines(string[] lines, int matchIndex, int count)
    {
        if (count == 0) return Array.Empty<string>();

        if (count < 0)
        {
            // Before context
            var start = Math.Max(0, matchIndex + count);
            var end = matchIndex;
            return lines[start..end].Select(l => l.Trim()).ToArray();
        }
        else
        {
            // After context
            var start = matchIndex + 1;
            var end = Math.Min(lines.Length, matchIndex + count + 1);
            return lines[start..end].Select(l => l.Trim()).ToArray();
        }
    }

    #endregion

    #region Output Formatting

    /// <summary>
    /// Format search results for output.
    /// </summary>
    private static string FormatResults(List<ContentSearchResult> results, bool includeContext)
    {
        if (results.Count == 0)
        {
            return "(no matches found)";
        }

        var sb = new StringBuilder();

        foreach (var result in results)
        {
            // Main match line: file:line: content
            sb.AppendLine($"{result.File}:{result.Line}: {result.Content}");

            // Add context lines if requested
            if (includeContext)
            {
                foreach (var ctx in result.ContextAfter)
                {
                    sb.AppendLine($"  {ctx}");
                }

                if (result.ContextAfter.Length > 0)
                {
                    sb.AppendLine(); // Blank line between matches
                }
            }
        }

        return sb.ToString().TrimEnd();
    }

    /// <summary>
    /// Truncate query for display.
    /// </summary>
    private static string TruncateQuery(string query)
    {
        return query.Length > 30 ? query[..27] + "..." : query;
    }

    #endregion

    #region Overrides

    public override string GetExecutionSummary(JsonElement parameters)
    {
        var query = parameters.TryGetProperty("query", out var q)
            ? q.GetString() ?? "?"
            : "?";
        return $"Search for '{TruncateQuery(query)}'";
    }

    public override ToolValidationResult Validate(JsonElement parameters)
    {
        var errors = new List<ToolValidationError>();

        // Required query
        if (!parameters.TryGetProperty("query", out var queryProp) ||
            string.IsNullOrWhiteSpace(queryProp.GetString()))
        {
            errors.Add(ToolValidationError.Required("query"));
        }

        // Validate context_lines range
        if (parameters.TryGetProperty("context_lines", out var ctxProp))
        {
            var ctx = ctxProp.GetInt32();
            if (ctx < 0 || ctx > MaxContextLines)
            {
                errors.Add(new ToolValidationError
                {
                    ParameterName = "context_lines",
                    Message = $"Must be between 0 and {MaxContextLines}",
                    Code = "INVALID_RANGE"
                });
            }
        }

        // Validate max_results
        if (parameters.TryGetProperty("max_results", out var maxProp))
        {
            var max = maxProp.GetInt32();
            if (max < 1)
            {
                errors.Add(new ToolValidationError
                {
                    ParameterName = "max_results",
                    Message = "Must be at least 1",
                    Code = "INVALID_RANGE"
                });
            }
        }

        return errors.Count > 0
            ? ToolValidationResult.Invalid(errors)
            : ToolValidationResult.Valid();
    }

    #endregion
}
```

### 2. ContentSearchResult.cs

**Location**: `src/SeniorIntern.Services/Tools/Search/ContentSearchResult.cs`

```csharp
namespace SeniorIntern.Services.Tools.Search;

/// <summary>
/// A single content search match.
/// </summary>
public sealed class ContentSearchResult
{
    /// <summary>
    /// Relative path to the file containing the match.
    /// </summary>
    public string File { get; init; } = string.Empty;

    /// <summary>
    /// Line number of the match (1-based).
    /// </summary>
    public int Line { get; init; }

    /// <summary>
    /// The matched line content (trimmed).
    /// </summary>
    public string Content { get; init; } = string.Empty;

    /// <summary>
    /// Lines before the match (for context).
    /// </summary>
    public string[] ContextBefore { get; init; } = Array.Empty<string>();

    /// <summary>
    /// Lines after the match (for context).
    /// </summary>
    public string[] ContextAfter { get; init; } = Array.Empty<string>();

    /// <summary>
    /// Full location string (file:line).
    /// </summary>
    public string Location => $"{File}:{Line}";

    /// <summary>
    /// Total context lines.
    /// </summary>
    public int TotalContext => ContextBefore.Length + ContextAfter.Length;
}
```

### 3. ContentSearchResultData.cs

**Location**: `src/SeniorIntern.Services/Tools/Search/ContentSearchResultData.cs`

```csharp
namespace SeniorIntern.Services.Tools.Search;

/// <summary>
/// Result data for content search operations.
/// </summary>
public sealed class ContentSearchResultData
{
    /// <summary>
    /// The search query.
    /// </summary>
    public string Query { get; init; } = string.Empty;

    /// <summary>
    /// File pattern used for filtering.
    /// </summary>
    public string FilePattern { get; init; } = string.Empty;

    /// <summary>
    /// Number of matches returned.
    /// </summary>
    public int MatchCount { get; init; }

    /// <summary>
    /// Number of files searched.
    /// </summary>
    public int FilesSearched { get; init; }

    /// <summary>
    /// Whether results were truncated.
    /// </summary>
    public bool WasTruncated { get; init; }

    /// <summary>
    /// Average matches per file.
    /// </summary>
    public double AverageMatchesPerFile => FilesSearched > 0
        ? Math.Round((double)MatchCount / FilesSearched, 2)
        : 0;
}
```

---

## Output Format Examples

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                     SearchContentTool Output Examples                         │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Query: "TODO" (no context)                                                  │
│  Output:                                                                     │
│  ┌────────────────────────────────────────────────────────────────────────┐ │
│  │  src/Services/UserService.cs:45: // TODO: Add validation                │ │
│  │  src/Services/OrderService.cs:23: // TODO: Implement caching            │ │
│  │  src/Controllers/ApiController.cs:89: // TODO: Handle timeout           │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│  Message: Found 3 matches for 'TODO' in 15 files                             │
│                                                                              │
│  Query: "async.*Task" (regex, context_lines=2)                               │
│  Output:                                                                     │
│  ┌────────────────────────────────────────────────────────────────────────┐ │
│  │  src/Services/UserService.cs:12: public async Task<User> GetById(...)   │ │
│  │    {                                                                     │ │
│  │      return await _repository.FindAsync(id);                             │ │
│  │                                                                          │ │
│  │  src/Services/OrderService.cs:28: private async Task ProcessOrder(...)  │ │
│  │    {                                                                     │ │
│  │      var user = await _userService.GetById(order.UserId);                │ │
│  │                                                                          │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│  Message: Found 2 matches for 'async.*Task' in 8 files                       │
│                                                                              │
│  Query: "NonExistentThing"                                                   │
│  Output:                                                                     │
│  ┌────────────────────────────────────────────────────────────────────────┐ │
│  │  (no matches found)                                                     │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│  Message: Found 0 matches for 'NonExistentThing' in 42 files                 │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## IFileSystemService Extension

Add this method to support partial file reading for binary detection:

```csharp
// In src/SeniorIntern.Core/Interfaces/IFileSystemService.cs

/// <summary>
/// Read the first N bytes of a file.
/// </summary>
Task<byte[]> ReadFileBytesAsync(string path, int maxBytes, CancellationToken ct = default);
```

---

## File Summary

| File | Location | Purpose | Lines |
|------|----------|---------|-------|
| `SearchContentTool.cs` | `Services/Tools/Search/` | Content search | ~320 |
| `ContentSearchResult.cs` | `Services/Tools/Search/` | Match result model | ~40 |
| `ContentSearchResultData.cs` | `Services/Tools/Search/` | Search metadata | ~40 |

---

## Unit Test Plan

| Test | Description |
|------|-------------|
| `SearchContentTool_PlainText_FindsMatches` | Basic text search |
| `SearchContentTool_Regex_FindsPatterns` | Regex pattern search |
| `SearchContentTool_CaseSensitive_RespectsFlag` | Case sensitivity |
| `SearchContentTool_WholeWord_MatchesBoundaries` | Word boundary matching |
| `SearchContentTool_ContextLines_IncludesSurrounding` | Context line extraction |
| `SearchContentTool_BinaryFiles_Skipped` | Binary detection |
| `SearchContentTool_LargeFiles_Skipped` | Size limit |
| `SearchContentTool_FilePattern_FiltersCorrectly` | File filtering |
| `SearchContentTool_InvalidRegex_ReturnsError` | Regex validation |
| `SearchContentTool_NoMatches_ReturnsEmpty` | Empty results |

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | SearchContentTool finds text in files |
| AC-2 | Regular expressions are supported |
| AC-3 | Case sensitivity is configurable |
| AC-4 | Whole word matching works |
| AC-5 | Context lines are included when requested |
| AC-6 | Binary files are skipped |

---

## Changelog Entry

```markdown
## v0.6.3g - Content Search Tools

### Added
- `SearchContentTool` for grep-like content search
  - Plain text and regex pattern support
  - Case-sensitive search option
  - Whole word matching option
  - Context lines (0-5 lines before/after)
  - File pattern filtering
  - Binary file detection and skipping
  - Large file (>1MB) skipping
- `ContentSearchResult` for individual match data
- `ContentSearchResultData` for search metadata
- `IFileSystemService.ReadFileBytesAsync` for binary detection

### Default Exclusions
- node_modules, bin, obj, .git, dist
- Minified files (*.min.js, *.min.css)
- Lock files (package-lock.json, yarn.lock)
```

---

## Timeline Estimate

| Version | Estimated Effort |
|---------|------------------|
| v0.6.3g | 0.75 day |
