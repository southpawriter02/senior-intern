# Design Specification: AIntern v0.6.1c "Tool Result System"

## Overview

**Version**: v0.6.1c
**Parent**: v0.6.1 Tool Framework
**Focus**: Result types, artifacts, success/failure handling, LLM context formatting

### Purpose

This sub-version defines the result system for tool executions:
1. Create `ToolResult` with success/failure states and factory methods
2. Create `ToolArtifact` for files, directories, and other outputs
3. Create `ToolResultBuilder` for fluent result construction
4. Create `MimeTypes` utility for content type detection
5. Support data truncation for LLM context
6. Enable suggested follow-up actions
7. Provide LLM-friendly serialization

### Dependencies

**From v0.6.1a (Tool Core Models)**:
- `ITool` interface returns `ToolResult`
- `ToolValidationResult` (for `ValidationFailed` factory)

**From v0.6.1b (Tool Execution Context)**:
- Execution duration tracking

**Future consumers**:
- v0.6.1i: Tool Execution Service
- v0.6.2: Semantic Kernel Integration
- v0.6.3: Built-in Tools

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                    v0.6.1c Tool Result System Architecture                    │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  src/AIntern.Core/Tools/                                                     │
│  ├─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  ToolResult                                                              │ │
│  │  ┌─────────────────────────────────────────────────────────────────────┐│ │
│  │  │                                                                      ││ │
│  │  │  Core Properties                                                     ││ │
│  │  │  ├── Success: bool                                                   ││ │
│  │  │  ├── Data: object?              (output for LLM)                     ││ │
│  │  │  ├── Message: string            (human-readable)                     ││ │
│  │  │  ├── Error: string?             (error description)                  ││ │
│  │  │  ├── ErrorCode: string?         (programmatic code)                  ││ │
│  │  │  └── Exception: Exception?      (not serialized)                     ││ │
│  │  │                                                                      ││ │
│  │  │  Artifacts                                                           ││ │
│  │  │  └── Artifacts: IReadOnlyList<ToolArtifact>                          ││ │
│  │  │                                                                      ││ │
│  │  │  Metadata                                                            ││ │
│  │  │  ├── Duration: TimeSpan                                              ││ │
│  │  │  ├── SuggestedFollowUps: IReadOnlyList<string>?                      ││ │
│  │  │  ├── ShouldTruncate: bool                                            ││ │
│  │  │  ├── MaxDataLength: int?                                             ││ │
│  │  │  └── Metadata: IReadOnlyDictionary<string, object>?                  ││ │
│  │  │                                                                      ││ │
│  │  │  Factory Methods                                                     ││ │
│  │  │  ├── Succeeded(data, message)                                        ││ │
│  │  │  ├── SucceededWithArtifacts(artifacts, data, message)                ││ │
│  │  │  ├── Failed(error, errorCode, partialData)                           ││ │
│  │  │  ├── FromException(ex, contextMessage)                               ││ │
│  │  │  ├── Cancelled(message)                                              ││ │
│  │  │  ├── Denied(reason)                                                  ││ │
│  │  │  ├── ValidationFailed(validationResult)                              ││ │
│  │  │  └── Timeout(duration)                                               ││ │
│  │  │                                                                      ││ │
│  │  │  Serialization                                                       ││ │
│  │  │  ├── GetSerializedData(maxLength)                                    ││ │
│  │  │  └── ToLlmContext()                                                  ││ │
│  │  │                                                                      ││ │
│  │  └─────────────────────────────────────────────────────────────────────┘│ │
│  │                                                                          │ │
│  │  ToolArtifact                                                            │ │
│  │  ┌─────────────────────────────────────────────────────────────────────┐│ │
│  │  │  ├── Type: string               ("file", "directory", "url", etc.)  ││ │
│  │  │  ├── Path: string               (path or location)                  ││ │
│  │  │  ├── Description: string?       (human description)                 ││ │
│  │  │  ├── Size: long?                (bytes for files)                   ││ │
│  │  │  ├── MimeType: string?          (content type)                      ││ │
│  │  │  ├── ContentHash: string?       (for verification)                  ││ │
│  │  │  ├── IsNew: bool                (created vs modified)               ││ │
│  │  │  └── Timestamp: DateTime                                             ││ │
│  │  │                                                                      ││ │
│  │  │  Factory Methods:                                                    ││ │
│  │  │  ├── File(path, isNew, description)                                  ││ │
│  │  │  ├── Directory(path, isNew, description)                             ││ │
│  │  │  ├── Url(url, description)                                           ││ │
│  │  │  └── TerminalOutput(output, description)                             ││ │
│  │  └─────────────────────────────────────────────────────────────────────┘│ │
│  │                                                                          │ │
│  │  ToolResultBuilder                                                       │ │
│  │  ┌─────────────────────────────────────────────────────────────────────┐│ │
│  │  │  Fluent Builder Pattern                                              ││ │
│  │  │  ├── Create()                                                        ││ │
│  │  │  ├── AsSuccess() / AsFailure(error, code)                            ││ │
│  │  │  ├── WithData(data) / WithMessage(message)                           ││ │
│  │  │  ├── WithArtifact(artifact) / WithFileArtifact(path, ...)            ││ │
│  │  │  ├── WithDuration(duration)                                          ││ │
│  │  │  ├── WithSuggestion(suggestion)                                      ││ │
│  │  │  ├── WithTruncation(maxLength)                                       ││ │
│  │  │  ├── WithMetadata(key, value)                                        ││ │
│  │  │  └── Build() → ToolResult                                            ││ │
│  │  └─────────────────────────────────────────────────────────────────────┘│ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  src/AIntern.Core/Utilities/                                                 │
│  ├─────────────────────────────────────────────────────────────────────────┐ │
│  │  MimeTypes                                                               │ │
│  │  ├── GetMimeType(path) → string                                         │ │
│  │  ├── IsTextFile(path) → bool                                            │ │
│  │  └── IsBinaryFile(path) → bool                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Result Flow Diagram

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                          Tool Result Flow                                     │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Tool Execution                                                              │
│       │                                                                      │
│       ├──────── Success ────────▶ ToolResult.Succeeded(data)                 │
│       │                                │                                     │
│       │                                ▼                                     │
│       │                          ┌──────────┐                                │
│       │                          │  With    │                                │
│       │                          │ Artifacts│──▶ Files created/modified      │
│       │                          └──────────┘                                │
│       │                                                                      │
│       ├──────── Failure ────────▶ ToolResult.Failed(error)                   │
│       │                                │                                     │
│       │                                ▼                                     │
│       │                          ┌──────────┐                                │
│       │                          │ Partial  │──▶ Data still available        │
│       │                          │   Data   │                                │
│       │                          └──────────┘                                │
│       │                                                                      │
│       ├──────── Exception ──────▶ ToolResult.FromException(ex)               │
│       │                                                                      │
│       ├──────── Cancelled ──────▶ ToolResult.Cancelled()                     │
│       │                                                                      │
│       ├──────── Denied ─────────▶ ToolResult.Denied(reason)                  │
│       │                                                                      │
│       └──────── Timeout ────────▶ ToolResult.Timeout(duration)               │
│                                                                              │
│  Result Processing                                                           │
│       │                                                                      │
│       ▼                                                                      │
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │                       Result Formatting                               │   │
│  │                                                                       │   │
│  │  ├── ToLlmContext()      ──▶ Formatted text for conversation          │   │
│  │  │                                                                    │   │
│  │  ├── GetSerializedData() ──▶ JSON with optional truncation            │   │
│  │  │       │                                                            │   │
│  │  │       └── if > maxLength ──▶ "... [truncated, total X chars]"      │   │
│  │  │                                                                    │   │
│  │  └── Artifacts           ──▶ List of side effects for tracking        │   │
│  │                                                                       │   │
│  └──────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Specifications

### 1. ToolResult.cs

**Location**: `src/AIntern.Core/Tools/ToolResult.cs`

```csharp
namespace AIntern.Core.Tools;

using System.Text;
using System.Text.Json;

/// <summary>
/// Result of a tool execution.
/// Contains success/failure status, output data, artifacts, and metadata.
/// </summary>
/// <remarks>
/// <para>
/// Tool results are the primary communication mechanism between tools
/// and the agent loop. They contain:
/// </para>
/// <list type="bullet">
/// <item>Success/failure status with error details</item>
/// <item>Output data for the LLM to interpret</item>
/// <item>Artifacts produced (files, directories, etc.)</item>
/// <item>Suggested follow-up actions</item>
/// </list>
/// <para>
/// Results are immutable once created. Use factory methods or
/// <see cref="ToolResultBuilder"/> for construction.
/// </para>
/// </remarks>
public sealed class ToolResult
{
    /// <summary>
    /// Whether the tool executed successfully.
    /// </summary>
    public bool Success { get; init; }

    /// <summary>
    /// Result data to return to the LLM.
    /// </summary>
    /// <remarks>
    /// Serialized to JSON for inclusion in conversation context.
    /// May be truncated if very large.
    /// </remarks>
    public object? Data { get; init; }

    /// <summary>
    /// Human-readable message about the result.
    /// </summary>
    /// <remarks>
    /// Displayed in the UI and included in LLM context.
    /// Should be concise but informative.
    /// </remarks>
    public string Message { get; init; } = string.Empty;

    /// <summary>
    /// Error details if the execution failed.
    /// </summary>
    /// <remarks>
    /// Only populated when <see cref="Success"/> is false.
    /// Provides detailed information about what went wrong.
    /// </remarks>
    public string? Error { get; init; }

    /// <summary>
    /// Error code for programmatic error handling.
    /// </summary>
    /// <remarks>
    /// Standard codes: "Cancelled", "Denied", "Timeout", "ValidationFailed".
    /// May also contain exception type names.
    /// </remarks>
    public string? ErrorCode { get; init; }

    /// <summary>
    /// Exception that caused the failure, if any.
    /// </summary>
    /// <remarks>
    /// Not serialized to LLM context. Used for logging and debugging.
    /// </remarks>
    public Exception? Exception { get; init; }

    /// <summary>
    /// Any artifacts produced (files created, modified, etc.).
    /// </summary>
    /// <remarks>
    /// Used to track side effects for potential undo/rollback.
    /// </remarks>
    public IReadOnlyList<ToolArtifact> Artifacts { get; init; } = Array.Empty<ToolArtifact>();

    /// <summary>
    /// Execution duration.
    /// </summary>
    public TimeSpan Duration { get; init; }

    /// <summary>
    /// Suggested follow-up actions or commands.
    /// </summary>
    /// <remarks>
    /// Hints for the LLM about what to do next.
    /// Example: "Run 'npm install' to install dependencies"
    /// </remarks>
    public IReadOnlyList<string>? SuggestedFollowUps { get; init; }

    /// <summary>
    /// Whether the result data should be truncated before sending to LLM.
    /// </summary>
    /// <remarks>
    /// Set when Data is very large. The <see cref="GetSerializedData"/>
    /// method will automatically truncate.
    /// </remarks>
    public bool ShouldTruncate { get; init; }

    /// <summary>
    /// Maximum length of Data when serialized (for truncation).
    /// </summary>
    /// <remarks>
    /// Default is 50000 characters if not specified.
    /// </remarks>
    public int? MaxDataLength { get; init; }

    /// <summary>
    /// Additional metadata about the execution.
    /// </summary>
    /// <remarks>
    /// Used for custom data that doesn't fit other properties.
    /// Examples: "exitCode", "itemCount", "bytesProcessed".
    /// </remarks>
    public IReadOnlyDictionary<string, object>? Metadata { get; init; }

    // ========================================================================
    // Computed Properties
    // ========================================================================

    /// <summary>
    /// Whether this result represents a failure.
    /// </summary>
    public bool IsFailure => !Success;

    /// <summary>
    /// Whether execution was cancelled.
    /// </summary>
    public bool IsCancelled => ErrorCode == "Cancelled";

    /// <summary>
    /// Whether execution was denied by user.
    /// </summary>
    public bool IsDenied => ErrorCode == "Denied";

    /// <summary>
    /// Whether execution timed out.
    /// </summary>
    public bool IsTimeout => ErrorCode == "Timeout";

    /// <summary>
    /// Whether validation failed.
    /// </summary>
    public bool IsValidationFailure => ErrorCode == "ValidationFailed";

    /// <summary>
    /// Whether there are any artifacts.
    /// </summary>
    public bool HasArtifacts => Artifacts.Count > 0;

    /// <summary>
    /// Whether there are any suggested follow-ups.
    /// </summary>
    public bool HasSuggestions => SuggestedFollowUps?.Count > 0;

    // ========================================================================
    // Factory Methods
    // ========================================================================

    /// <summary>
    /// Create a successful result.
    /// </summary>
    /// <param name="data">Optional output data for the LLM.</param>
    /// <param name="message">Optional success message.</param>
    /// <returns>A successful ToolResult.</returns>
    public static ToolResult Succeeded(object? data = null, string? message = null) =>
        new()
        {
            Success = true,
            Data = data,
            Message = message ?? "Operation completed successfully"
        };

    /// <summary>
    /// Create a successful result with artifacts.
    /// </summary>
    /// <param name="artifacts">Artifacts produced by the operation.</param>
    /// <param name="data">Optional output data for the LLM.</param>
    /// <param name="message">Optional success message.</param>
    /// <returns>A successful ToolResult with artifacts.</returns>
    public static ToolResult SucceededWithArtifacts(
        IEnumerable<ToolArtifact> artifacts,
        object? data = null,
        string? message = null) =>
        new()
        {
            Success = true,
            Data = data,
            Message = message ?? "Operation completed successfully",
            Artifacts = artifacts.ToList()
        };

    /// <summary>
    /// Create a failed result.
    /// </summary>
    /// <param name="error">Error description.</param>
    /// <param name="errorCode">Optional error code.</param>
    /// <param name="partialData">Optional partial data that was collected.</param>
    /// <returns>A failed ToolResult.</returns>
    public static ToolResult Failed(
        string error,
        string? errorCode = null,
        object? partialData = null) =>
        new()
        {
            Success = false,
            Error = error,
            ErrorCode = errorCode,
            Data = partialData,
            Message = error
        };

    /// <summary>
    /// Create a failed result from an exception.
    /// </summary>
    /// <param name="ex">The exception that caused the failure.</param>
    /// <param name="contextMessage">Optional context about what was happening.</param>
    /// <returns>A failed ToolResult with exception details.</returns>
    public static ToolResult FromException(Exception ex, string? contextMessage = null) =>
        new()
        {
            Success = false,
            Error = contextMessage != null
                ? $"{contextMessage}: {ex.Message}"
                : ex.Message,
            ErrorCode = ex.GetType().Name,
            Exception = ex,
            Message = contextMessage ?? ex.Message
        };

    /// <summary>
    /// Create a cancelled result.
    /// </summary>
    /// <param name="message">Optional cancellation message.</param>
    /// <returns>A cancelled ToolResult.</returns>
    public static ToolResult Cancelled(string? message = null) =>
        new()
        {
            Success = false,
            Error = "Operation was cancelled",
            ErrorCode = "Cancelled",
            Message = message ?? "Operation was cancelled by user"
        };

    /// <summary>
    /// Create a denied result (user denied approval).
    /// </summary>
    /// <param name="reason">Optional denial reason.</param>
    /// <returns>A denied ToolResult.</returns>
    public static ToolResult Denied(string? reason = null) =>
        new()
        {
            Success = false,
            Error = "Operation was denied by user",
            ErrorCode = "Denied",
            Message = reason ?? "Operation was denied by user"
        };

    /// <summary>
    /// Create a validation failure result.
    /// </summary>
    /// <param name="validation">The validation result with errors.</param>
    /// <returns>A validation failure ToolResult.</returns>
    public static ToolResult ValidationFailed(ToolValidationResult validation) =>
        new()
        {
            Success = false,
            Error = string.Join("; ", validation.Errors.Select(e => e.Message)),
            ErrorCode = "ValidationFailed",
            Message = "Parameter validation failed",
            Data = new { Errors = validation.Errors.Select(e => new { e.ParameterName, e.Message }) }
        };

    /// <summary>
    /// Create a timeout result.
    /// </summary>
    /// <param name="duration">How long the operation ran before timing out.</param>
    /// <returns>A timeout ToolResult.</returns>
    public static ToolResult Timeout(TimeSpan duration) =>
        new()
        {
            Success = false,
            Error = $"Operation timed out after {duration.TotalSeconds:F1}s",
            ErrorCode = "Timeout",
            Duration = duration,
            Message = "Operation timed out"
        };

    /// <summary>
    /// Create a not-available result (tool not available).
    /// </summary>
    /// <param name="reason">Reason the tool is not available.</param>
    /// <returns>A not-available ToolResult.</returns>
    public static ToolResult NotAvailable(string reason) =>
        new()
        {
            Success = false,
            Error = reason,
            ErrorCode = "NotAvailable",
            Message = reason
        };

    // ========================================================================
    // Serialization Methods
    // ========================================================================

    private static readonly JsonSerializerOptions CompactJsonOptions = new()
    {
        WriteIndented = false,
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase
    };

    /// <summary>
    /// Get the serialized data for LLM context, with optional truncation.
    /// </summary>
    /// <param name="maxLength">Maximum length before truncation.</param>
    /// <returns>Serialized JSON string, possibly truncated.</returns>
    public string GetSerializedData(int? maxLength = null)
    {
        if (Data == null)
            return string.Empty;

        var effectiveMaxLength = maxLength ?? MaxDataLength ?? 50000;

        string json;
        try
        {
            json = JsonSerializer.Serialize(Data, CompactJsonOptions);
        }
        catch (Exception)
        {
            // Fallback to ToString if serialization fails
            json = Data.ToString() ?? string.Empty;
        }

        if (!ShouldTruncate && json.Length <= effectiveMaxLength)
            return json;

        if (json.Length <= effectiveMaxLength)
            return json;

        // Truncate with indication
        var truncateAt = effectiveMaxLength - 50;
        return json[..truncateAt] + $"... [truncated, total {json.Length} chars]";
    }

    /// <summary>
    /// Convert to LLM-friendly format for conversation context.
    /// </summary>
    /// <returns>Formatted string for LLM context.</returns>
    public string ToLlmContext()
    {
        var sb = new StringBuilder();

        if (Success)
        {
            sb.AppendLine("Result: Success");
            sb.AppendLine($"Message: {Message}");
            if (Data != null)
            {
                var serialized = GetSerializedData();
                if (!string.IsNullOrEmpty(serialized))
                {
                    sb.AppendLine($"Data: {serialized}");
                }
            }
        }
        else
        {
            sb.AppendLine("Result: Failed");
            sb.AppendLine($"Error: {Error}");
            if (ErrorCode != null)
            {
                sb.AppendLine($"Error Code: {ErrorCode}");
            }
        }

        if (Artifacts.Count > 0)
        {
            sb.AppendLine("Artifacts:");
            foreach (var artifact in Artifacts)
            {
                sb.AppendLine($"  - {artifact.Type}: {artifact.Path}");
                if (artifact.Description != null)
                {
                    sb.AppendLine($"    Description: {artifact.Description}");
                }
            }
        }

        if (SuggestedFollowUps?.Count > 0)
        {
            sb.AppendLine("Suggested next steps:");
            foreach (var suggestion in SuggestedFollowUps)
            {
                sb.AppendLine($"  - {suggestion}");
            }
        }

        if (Duration > TimeSpan.Zero)
        {
            sb.AppendLine($"Duration: {Duration.TotalMilliseconds:F0}ms");
        }

        return sb.ToString().TrimEnd();
    }

    /// <summary>
    /// Create a summary for logging.
    /// </summary>
    public string ToLogSummary()
    {
        if (Success)
            return $"Success: {Message}";
        return $"Failed ({ErrorCode}): {Error}";
    }
}
```

### 2. ToolArtifact.cs

**Location**: `src/AIntern.Core/Tools/ToolArtifact.cs`

```csharp
namespace AIntern.Core.Tools;

using AIntern.Core.Utilities;

/// <summary>
/// An artifact produced by a tool execution.
/// Represents files created, modified, or other tangible outputs.
/// </summary>
/// <remarks>
/// <para>
/// Artifacts track the side effects of tool executions:
/// </para>
/// <list type="bullet">
/// <item>Files created or modified</item>
/// <item>Directories created</item>
/// <item>URLs generated or accessed</item>
/// <item>Terminal output produced</item>
/// </list>
/// <para>
/// This information can be used for undo/rollback functionality,
/// audit logging, and informing the user about changes made.
/// </para>
/// </remarks>
public sealed class ToolArtifact
{
    /// <summary>
    /// Type of artifact.
    /// </summary>
    /// <remarks>
    /// Standard types: "file", "directory", "url", "output".
    /// Custom types are allowed for extension.
    /// </remarks>
    public string Type { get; init; } = string.Empty;

    /// <summary>
    /// Path or location of the artifact.
    /// </summary>
    /// <remarks>
    /// For files/directories: filesystem path.
    /// For URLs: the URL string.
    /// For output: identifier like "terminal" or "stdout".
    /// </remarks>
    public string Path { get; init; } = string.Empty;

    /// <summary>
    /// Human-readable description.
    /// </summary>
    public string? Description { get; init; }

    /// <summary>
    /// Size in bytes (for files and output).
    /// </summary>
    public long? Size { get; init; }

    /// <summary>
    /// MIME type (for files).
    /// </summary>
    /// <remarks>
    /// Determined automatically by extension or content sniffing.
    /// </remarks>
    public string? MimeType { get; init; }

    /// <summary>
    /// Hash of content (for verification).
    /// </summary>
    /// <remarks>
    /// May be used to detect changes or verify integrity.
    /// Format is typically "sha256:hexstring".
    /// </remarks>
    public string? ContentHash { get; init; }

    /// <summary>
    /// Whether this artifact was created (vs modified).
    /// </summary>
    /// <remarks>
    /// True for new files/directories, false for modifications.
    /// </remarks>
    public bool IsNew { get; init; }

    /// <summary>
    /// Timestamp when artifact was created/modified.
    /// </summary>
    public DateTime Timestamp { get; init; } = DateTime.UtcNow;

    /// <summary>
    /// The action performed on this artifact.
    /// </summary>
    public ArtifactAction Action { get; init; } = ArtifactAction.Created;

    // ========================================================================
    // Computed Properties
    // ========================================================================

    /// <summary>
    /// Whether this is a file artifact.
    /// </summary>
    public bool IsFile => Type == "file";

    /// <summary>
    /// Whether this is a directory artifact.
    /// </summary>
    public bool IsDirectory => Type == "directory";

    /// <summary>
    /// Whether this is a URL artifact.
    /// </summary>
    public bool IsUrl => Type == "url";

    /// <summary>
    /// Human-readable size string.
    /// </summary>
    public string? SizeDisplay
    {
        get
        {
            if (!Size.HasValue) return null;
            var size = Size.Value;

            if (size < 1024) return $"{size} B";
            if (size < 1024 * 1024) return $"{size / 1024.0:F1} KB";
            if (size < 1024 * 1024 * 1024) return $"{size / (1024.0 * 1024):F1} MB";
            return $"{size / (1024.0 * 1024 * 1024):F2} GB";
        }
    }

    /// <summary>
    /// Get the file name from the path.
    /// </summary>
    public string FileName => System.IO.Path.GetFileName(Path);

    // ========================================================================
    // Factory Methods
    // ========================================================================

    /// <summary>
    /// Create a file artifact.
    /// </summary>
    /// <param name="path">Path to the file.</param>
    /// <param name="isNew">Whether the file was created (vs modified).</param>
    /// <param name="description">Optional description.</param>
    /// <returns>A file ToolArtifact.</returns>
    public static ToolArtifact File(
        string path,
        bool isNew = false,
        string? description = null)
    {
        long? size = null;
        try
        {
            var fileInfo = new FileInfo(path);
            if (fileInfo.Exists)
            {
                size = fileInfo.Length;
            }
        }
        catch
        {
            // Ignore if we can't read file info
        }

        return new ToolArtifact
        {
            Type = "file",
            Path = path,
            Description = description,
            Size = size,
            IsNew = isNew,
            MimeType = MimeTypes.GetMimeType(path),
            Action = isNew ? ArtifactAction.Created : ArtifactAction.Modified
        };
    }

    /// <summary>
    /// Create a file artifact with explicit size (for content that will be written).
    /// </summary>
    public static ToolArtifact FileWithContent(
        string path,
        long size,
        bool isNew = true,
        string? description = null) =>
        new()
        {
            Type = "file",
            Path = path,
            Description = description,
            Size = size,
            IsNew = isNew,
            MimeType = MimeTypes.GetMimeType(path),
            Action = isNew ? ArtifactAction.Created : ArtifactAction.Modified
        };

    /// <summary>
    /// Create a deleted file artifact.
    /// </summary>
    public static ToolArtifact DeletedFile(string path, string? description = null) =>
        new()
        {
            Type = "file",
            Path = path,
            Description = description ?? "Deleted",
            IsNew = false,
            Action = ArtifactAction.Deleted
        };

    /// <summary>
    /// Create a directory artifact.
    /// </summary>
    /// <param name="path">Path to the directory.</param>
    /// <param name="isNew">Whether the directory was created.</param>
    /// <param name="description">Optional description.</param>
    /// <returns>A directory ToolArtifact.</returns>
    public static ToolArtifact Directory(
        string path,
        bool isNew = false,
        string? description = null) =>
        new()
        {
            Type = "directory",
            Path = path,
            Description = description,
            IsNew = isNew,
            Action = isNew ? ArtifactAction.Created : ArtifactAction.Modified
        };

    /// <summary>
    /// Create a URL artifact.
    /// </summary>
    /// <param name="url">The URL.</param>
    /// <param name="description">Optional description.</param>
    /// <returns>A URL ToolArtifact.</returns>
    public static ToolArtifact Url(string url, string? description = null) =>
        new()
        {
            Type = "url",
            Path = url,
            Description = description,
            Action = ArtifactAction.Accessed
        };

    /// <summary>
    /// Create a terminal output artifact.
    /// </summary>
    /// <param name="output">The output content.</param>
    /// <param name="description">Optional description.</param>
    /// <returns>A terminal output ToolArtifact.</returns>
    public static ToolArtifact TerminalOutput(string output, string? description = null) =>
        new()
        {
            Type = "output",
            Path = "terminal",
            Description = description ?? "Terminal output",
            Size = output.Length,
            Action = ArtifactAction.Created
        };

    /// <summary>
    /// Create a custom artifact.
    /// </summary>
    public static ToolArtifact Custom(
        string type,
        string path,
        string? description = null) =>
        new()
        {
            Type = type,
            Path = path,
            Description = description
        };
}

/// <summary>
/// Action performed on an artifact.
/// </summary>
public enum ArtifactAction
{
    /// <summary>
    /// Artifact was created.
    /// </summary>
    Created,

    /// <summary>
    /// Artifact was modified.
    /// </summary>
    Modified,

    /// <summary>
    /// Artifact was deleted.
    /// </summary>
    Deleted,

    /// <summary>
    /// Artifact was read/accessed.
    /// </summary>
    Accessed,

    /// <summary>
    /// Artifact was moved/renamed.
    /// </summary>
    Moved
}
```

### 3. ToolResultBuilder.cs

**Location**: `src/AIntern.Core/Tools/ToolResultBuilder.cs`

```csharp
namespace AIntern.Core.Tools;

/// <summary>
/// Fluent builder for creating <see cref="ToolResult"/> instances.
/// </summary>
/// <remarks>
/// <para>
/// Use this builder when you need to construct complex results
/// with multiple artifacts, suggestions, and metadata.
/// </para>
/// <example>
/// <code>
/// var result = ToolResultBuilder.Create()
///     .AsSuccess()
///     .WithMessage("Files updated successfully")
///     .WithData(new { updatedCount = 5 })
///     .WithFileArtifact("src/file1.cs", true, "Created")
///     .WithFileArtifact("src/file2.cs", false, "Modified")
///     .WithSuggestion("Run 'dotnet build' to verify changes")
///     .WithDuration(TimeSpan.FromSeconds(2.5))
///     .Build();
/// </code>
/// </example>
/// </remarks>
public sealed class ToolResultBuilder
{
    private bool _success = true;
    private object? _data;
    private string _message = string.Empty;
    private string? _error;
    private string? _errorCode;
    private Exception? _exception;
    private readonly List<ToolArtifact> _artifacts = new();
    private TimeSpan _duration;
    private readonly List<string> _suggestions = new();
    private bool _shouldTruncate;
    private int? _maxDataLength;
    private Dictionary<string, object>? _metadata;

    /// <summary>
    /// Create a new builder instance.
    /// </summary>
    public static ToolResultBuilder Create() => new();

    /// <summary>
    /// Create a builder starting with a success state.
    /// </summary>
    public static ToolResultBuilder Success() => new() { _success = true };

    /// <summary>
    /// Create a builder starting with a failure state.
    /// </summary>
    public static ToolResultBuilder Failure(string error) =>
        new() { _success = false, _error = error, _message = error };

    // ========================================================================
    // Status Methods
    // ========================================================================

    /// <summary>
    /// Mark result as successful.
    /// </summary>
    public ToolResultBuilder AsSuccess()
    {
        _success = true;
        return this;
    }

    /// <summary>
    /// Mark result as failed.
    /// </summary>
    /// <param name="error">Error description.</param>
    /// <param name="errorCode">Optional error code.</param>
    public ToolResultBuilder AsFailure(string error, string? errorCode = null)
    {
        _success = false;
        _error = error;
        _errorCode = errorCode;
        if (string.IsNullOrEmpty(_message))
            _message = error;
        return this;
    }

    /// <summary>
    /// Mark result as cancelled.
    /// </summary>
    public ToolResultBuilder AsCancelled(string? message = null)
    {
        _success = false;
        _error = "Operation was cancelled";
        _errorCode = "Cancelled";
        _message = message ?? "Operation was cancelled by user";
        return this;
    }

    // ========================================================================
    // Data Methods
    // ========================================================================

    /// <summary>
    /// Set the result data.
    /// </summary>
    /// <param name="data">Output data for the LLM.</param>
    public ToolResultBuilder WithData(object? data)
    {
        _data = data;
        return this;
    }

    /// <summary>
    /// Set the result message.
    /// </summary>
    /// <param name="message">Human-readable message.</param>
    public ToolResultBuilder WithMessage(string message)
    {
        _message = message;
        return this;
    }

    /// <summary>
    /// Set exception details.
    /// </summary>
    /// <param name="ex">The exception that occurred.</param>
    public ToolResultBuilder WithException(Exception ex)
    {
        _exception = ex;
        _success = false;
        _error ??= ex.Message;
        _errorCode ??= ex.GetType().Name;
        if (string.IsNullOrEmpty(_message))
            _message = ex.Message;
        return this;
    }

    // ========================================================================
    // Artifact Methods
    // ========================================================================

    /// <summary>
    /// Add an artifact to the result.
    /// </summary>
    /// <param name="artifact">The artifact to add.</param>
    public ToolResultBuilder WithArtifact(ToolArtifact artifact)
    {
        _artifacts.Add(artifact);
        return this;
    }

    /// <summary>
    /// Add multiple artifacts.
    /// </summary>
    public ToolResultBuilder WithArtifacts(IEnumerable<ToolArtifact> artifacts)
    {
        _artifacts.AddRange(artifacts);
        return this;
    }

    /// <summary>
    /// Add a file artifact.
    /// </summary>
    /// <param name="path">Path to the file.</param>
    /// <param name="isNew">Whether the file was created.</param>
    /// <param name="description">Optional description.</param>
    public ToolResultBuilder WithFileArtifact(
        string path,
        bool isNew = false,
        string? description = null)
    {
        _artifacts.Add(ToolArtifact.File(path, isNew, description));
        return this;
    }

    /// <summary>
    /// Add a directory artifact.
    /// </summary>
    public ToolResultBuilder WithDirectoryArtifact(
        string path,
        bool isNew = false,
        string? description = null)
    {
        _artifacts.Add(ToolArtifact.Directory(path, isNew, description));
        return this;
    }

    /// <summary>
    /// Add a deleted file artifact.
    /// </summary>
    public ToolResultBuilder WithDeletedFile(string path, string? description = null)
    {
        _artifacts.Add(ToolArtifact.DeletedFile(path, description));
        return this;
    }

    // ========================================================================
    // Metadata Methods
    // ========================================================================

    /// <summary>
    /// Set the execution duration.
    /// </summary>
    /// <param name="duration">How long the operation took.</param>
    public ToolResultBuilder WithDuration(TimeSpan duration)
    {
        _duration = duration;
        return this;
    }

    /// <summary>
    /// Add a suggested follow-up action.
    /// </summary>
    /// <param name="suggestion">Suggested action for the LLM.</param>
    public ToolResultBuilder WithSuggestion(string suggestion)
    {
        _suggestions.Add(suggestion);
        return this;
    }

    /// <summary>
    /// Add multiple suggestions.
    /// </summary>
    public ToolResultBuilder WithSuggestions(IEnumerable<string> suggestions)
    {
        _suggestions.AddRange(suggestions);
        return this;
    }

    /// <summary>
    /// Enable data truncation.
    /// </summary>
    /// <param name="maxLength">Maximum length before truncation.</param>
    public ToolResultBuilder WithTruncation(int maxLength = 50000)
    {
        _shouldTruncate = true;
        _maxDataLength = maxLength;
        return this;
    }

    /// <summary>
    /// Add a metadata value.
    /// </summary>
    /// <param name="key">Metadata key.</param>
    /// <param name="value">Metadata value.</param>
    public ToolResultBuilder WithMetadata(string key, object value)
    {
        _metadata ??= new Dictionary<string, object>();
        _metadata[key] = value;
        return this;
    }

    // ========================================================================
    // Build
    // ========================================================================

    /// <summary>
    /// Build the final ToolResult.
    /// </summary>
    /// <returns>The configured ToolResult.</returns>
    public ToolResult Build() => new()
    {
        Success = _success,
        Data = _data,
        Message = _message,
        Error = _error,
        ErrorCode = _errorCode,
        Exception = _exception,
        Artifacts = _artifacts,
        Duration = _duration,
        SuggestedFollowUps = _suggestions.Count > 0 ? _suggestions : null,
        ShouldTruncate = _shouldTruncate,
        MaxDataLength = _maxDataLength,
        Metadata = _metadata
    };
}
```

### 4. MimeTypes.cs

**Location**: `src/AIntern.Core/Utilities/MimeTypes.cs`

```csharp
namespace AIntern.Core.Utilities;

/// <summary>
/// Utility class for determining MIME types from file extensions.
/// </summary>
public static class MimeTypes
{
    private static readonly Dictionary<string, string> ExtensionToMimeType = new(
        StringComparer.OrdinalIgnoreCase)
    {
        // Text
        [".txt"] = "text/plain",
        [".md"] = "text/markdown",
        [".markdown"] = "text/markdown",
        [".csv"] = "text/csv",
        [".log"] = "text/plain",

        // Code
        [".cs"] = "text/x-csharp",
        [".js"] = "text/javascript",
        [".ts"] = "text/typescript",
        [".jsx"] = "text/jsx",
        [".tsx"] = "text/typescript-jsx",
        [".py"] = "text/x-python",
        [".java"] = "text/x-java",
        [".cpp"] = "text/x-c++src",
        [".c"] = "text/x-csrc",
        [".h"] = "text/x-chdr",
        [".hpp"] = "text/x-c++hdr",
        [".go"] = "text/x-go",
        [".rs"] = "text/x-rust",
        [".rb"] = "text/x-ruby",
        [".php"] = "text/x-php",
        [".swift"] = "text/x-swift",
        [".kt"] = "text/x-kotlin",

        // Web
        [".html"] = "text/html",
        [".htm"] = "text/html",
        [".css"] = "text/css",
        [".scss"] = "text/x-scss",
        [".sass"] = "text/x-sass",
        [".less"] = "text/x-less",
        [".vue"] = "text/x-vue",
        [".svelte"] = "text/x-svelte",

        // Data
        [".json"] = "application/json",
        [".xml"] = "application/xml",
        [".yaml"] = "application/x-yaml",
        [".yml"] = "application/x-yaml",
        [".toml"] = "application/toml",

        // Config
        [".gitignore"] = "text/plain",
        [".editorconfig"] = "text/plain",
        [".env"] = "text/plain",
        [".ini"] = "text/plain",
        [".cfg"] = "text/plain",
        [".conf"] = "text/plain",

        // Shell
        [".sh"] = "text/x-shellscript",
        [".bash"] = "text/x-shellscript",
        [".zsh"] = "text/x-shellscript",
        [".ps1"] = "text/x-powershell",
        [".bat"] = "text/x-batch",
        [".cmd"] = "text/x-batch",

        // Documents
        [".pdf"] = "application/pdf",
        [".doc"] = "application/msword",
        [".docx"] = "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        [".xls"] = "application/vnd.ms-excel",
        [".xlsx"] = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",

        // Images
        [".png"] = "image/png",
        [".jpg"] = "image/jpeg",
        [".jpeg"] = "image/jpeg",
        [".gif"] = "image/gif",
        [".svg"] = "image/svg+xml",
        [".ico"] = "image/x-icon",
        [".webp"] = "image/webp",

        // Binary
        [".exe"] = "application/x-msdownload",
        [".dll"] = "application/x-msdownload",
        [".so"] = "application/x-sharedlib",
        [".dylib"] = "application/x-mach-binary",
        [".zip"] = "application/zip",
        [".tar"] = "application/x-tar",
        [".gz"] = "application/gzip",
        [".7z"] = "application/x-7z-compressed",
        [".rar"] = "application/x-rar-compressed"
    };

    private static readonly HashSet<string> TextExtensions = new(StringComparer.OrdinalIgnoreCase)
    {
        ".txt", ".md", ".markdown", ".csv", ".log",
        ".cs", ".js", ".ts", ".jsx", ".tsx", ".py", ".java", ".cpp", ".c", ".h", ".hpp",
        ".go", ".rs", ".rb", ".php", ".swift", ".kt",
        ".html", ".htm", ".css", ".scss", ".sass", ".less", ".vue", ".svelte",
        ".json", ".xml", ".yaml", ".yml", ".toml",
        ".gitignore", ".editorconfig", ".env", ".ini", ".cfg", ".conf",
        ".sh", ".bash", ".zsh", ".ps1", ".bat", ".cmd"
    };

    /// <summary>
    /// Get the MIME type for a file path based on its extension.
    /// </summary>
    /// <param name="path">File path or name.</param>
    /// <returns>MIME type, or "application/octet-stream" if unknown.</returns>
    public static string GetMimeType(string path)
    {
        if (string.IsNullOrEmpty(path))
            return "application/octet-stream";

        var extension = Path.GetExtension(path);
        if (string.IsNullOrEmpty(extension))
            return "application/octet-stream";

        return ExtensionToMimeType.GetValueOrDefault(
            extension,
            "application/octet-stream");
    }

    /// <summary>
    /// Check if a file is likely a text file based on extension.
    /// </summary>
    /// <param name="path">File path or name.</param>
    /// <returns>True if the file is likely text.</returns>
    public static bool IsTextFile(string path)
    {
        if (string.IsNullOrEmpty(path))
            return false;

        var extension = Path.GetExtension(path);
        if (string.IsNullOrEmpty(extension))
            return false;

        return TextExtensions.Contains(extension);
    }

    /// <summary>
    /// Check if a file is likely a binary file based on extension.
    /// </summary>
    /// <param name="path">File path or name.</param>
    /// <returns>True if the file is likely binary.</returns>
    public static bool IsBinaryFile(string path) =>
        !IsTextFile(path);

    /// <summary>
    /// Get a file's likely content category.
    /// </summary>
    /// <param name="path">File path or name.</param>
    /// <returns>Category name.</returns>
    public static string GetCategory(string path)
    {
        var ext = Path.GetExtension(path)?.ToLowerInvariant() ?? "";

        return ext switch
        {
            ".cs" or ".js" or ".ts" or ".py" or ".java" or ".cpp" or ".go" or ".rs"
                => "code",
            ".html" or ".htm" or ".css" or ".vue" or ".svelte"
                => "web",
            ".json" or ".xml" or ".yaml" or ".yml" or ".toml"
                => "data",
            ".md" or ".txt" or ".log"
                => "text",
            ".png" or ".jpg" or ".jpeg" or ".gif" or ".svg"
                => "image",
            ".exe" or ".dll" or ".so" or ".zip" or ".tar" or ".gz"
                => "binary",
            _
                => "other"
        };
    }
}
```

---

## File Summary

### Files to Create

| File | Location | Purpose |
|------|----------|---------|
| `ToolResult.cs` | `Core/Tools/` | Result model with factories |
| `ToolArtifact.cs` | `Core/Tools/` | Artifact model |
| `ToolResultBuilder.cs` | `Core/Tools/` | Fluent builder |
| `MimeTypes.cs` | `Core/Utilities/` | MIME type helper |

### Files to Update

| File | Changes |
|------|---------|
| `ToolTypes.cs` | Remove ToolResult forward declaration |

---

## Unit Test Plan

| Test | Description |
|------|-------------|
| `ToolResult_Succeeded_HasCorrectState` | Success factory |
| `ToolResult_SucceededWithArtifacts_IncludesArtifacts` | Artifacts included |
| `ToolResult_Failed_HasErrorDetails` | Failure factory |
| `ToolResult_FromException_ExtractsDetails` | Exception handling |
| `ToolResult_Cancelled_HasCorrectCode` | Cancelled factory |
| `ToolResult_Denied_HasCorrectCode` | Denied factory |
| `ToolResult_Timeout_IncludesDuration` | Timeout factory |
| `ToolResult_ValidationFailed_IncludesErrors` | Validation factory |
| `ToolResult_GetSerializedData_Truncates` | Truncation works |
| `ToolResult_GetSerializedData_NullData_ReturnsEmpty` | Null handling |
| `ToolResult_ToLlmContext_Success_FormatsCorrectly` | Success format |
| `ToolResult_ToLlmContext_Failure_FormatsCorrectly` | Failure format |
| `ToolResult_ToLlmContext_WithArtifacts_IncludesThem` | Artifacts format |
| `ToolArtifact_File_GetsSize` | File size detection |
| `ToolArtifact_File_GetsMimeType` | MIME detection |
| `ToolArtifact_Directory_SetsCorrectType` | Directory type |
| `ToolArtifact_Url_SetsCorrectType` | URL type |
| `ToolArtifact_SizeDisplay_FormatsCorrectly` | Size formatting |
| `ToolResultBuilder_Build_CreatesCorrectResult` | Builder works |
| `ToolResultBuilder_WithArtifacts_Accumulates` | Multiple artifacts |
| `ToolResultBuilder_WithSuggestions_Accumulates` | Multiple suggestions |
| `ToolResultBuilder_AsFailure_SetsAllFields` | Failure builder |
| `MimeTypes_GetMimeType_KnownExtension_ReturnsCorrect` | Known types |
| `MimeTypes_GetMimeType_UnknownExtension_ReturnsDefault` | Unknown types |
| `MimeTypes_IsTextFile_CodeFiles_ReturnsTrue` | Text detection |
| `MimeTypes_IsBinaryFile_Images_ReturnsTrue` | Binary detection |

**Total Tests**: 26

---

## Verification

```bash
# Build the core project
dotnet build src/AIntern.Core

# Run unit tests
dotnet test --filter "ToolResult|ToolArtifact|MimeTypes"

# Verify no compile errors
dotnet build src/AIntern.Core --no-incremental
```

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | ToolResult.Succeeded creates successful result |
| AC-2 | ToolResult.Failed includes error details |
| AC-3 | ToolResult.FromException extracts message and type |
| AC-4 | Cancelled, Denied, Timeout have correct error codes |
| AC-5 | GetSerializedData truncates large data |
| AC-6 | ToLlmContext formats correctly for LLM |
| AC-7 | ToolArtifact.File detects size and MIME type |
| AC-8 | ToolResultBuilder accumulates artifacts |
| AC-9 | MimeTypes handles all common extensions |
| AC-10 | ArtifactAction enum covers all operations |

---

## Changelog Entry

```markdown
## v0.6.1c - Tool Result System

### Added
- `ToolResult` with:
  - Success/failure status and error details
  - Data, Message, Error, ErrorCode, Exception
  - Artifacts list for tracking side effects
  - Duration, SuggestedFollowUps, Metadata
  - Factory methods: Succeeded, Failed, FromException, Cancelled, Denied, Timeout, ValidationFailed
  - GetSerializedData with truncation support
  - ToLlmContext for LLM-friendly formatting

- `ToolArtifact` with:
  - Type (file, directory, url, output)
  - Path, Description, Size, MimeType
  - ContentHash, IsNew, Timestamp
  - ArtifactAction enum
  - Factory methods: File, Directory, Url, TerminalOutput
  - SizeDisplay computed property

- `ToolResultBuilder` with:
  - Fluent API for complex result construction
  - AsSuccess, AsFailure, AsCancelled
  - WithData, WithMessage, WithException
  - WithArtifact, WithFileArtifact
  - WithSuggestion, WithTruncation, WithMetadata

- `MimeTypes` utility with:
  - GetMimeType for extension → type
  - IsTextFile, IsBinaryFile for categorization
  - GetCategory for content classification
```

---

## Timeline Estimate

| Version | Estimated Effort |
|---------|------------------|
| v0.6.1c | 0.75 day |
