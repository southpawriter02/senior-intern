# Design Specification: AIntern v0.6.1i "Tool Execution Service"

## Overview

**Version**: v0.6.1i
**Parent**: v0.6.1 Tool Framework
**Focus**: Tool execution service with lifecycle management, timeout handling, and event notifications

### Purpose

This sub-version implements the tool execution service:
1. Create `IToolExecutionService` interface for tool invocation abstraction
2. Create `ToolExecutionResult` model for comprehensive execution outcomes
3. Create `ToolExecutionStatus` enumeration for execution state tracking
4. Implement `ToolExecutionService` with timeout and cancellation support
5. Create `ToolExecutionOptions` for runtime configuration
6. Define execution event args for progress and completion notifications

### Dependencies

**From v0.6.1a (Tool Core Models)**:
- `ITool` interface for tool execution
- `ToolCategory` for categorization
- `RiskLevel` for risk assessment

**From v0.6.1b (Tool Execution Context)**:
- `ToolExecutionContext` for execution parameters
- `ToolProgress` for progress reporting

**From v0.6.1c (Tool Result System)**:
- `ToolResult` for execution outcomes

**From v0.6.1d (Tool Validation)**:
- `ToolValidationResult` for parameter validation
- `ToolValidationError` for error reporting

**From v0.6.1g (Tool Registry Interface)**:
- `IToolRegistry` for tool lookup

**From v0.6.1h (Tool Registry Implementation)**:
- `ToolRegistry` for runtime tool management

**Future consumers**:
- v0.6.2: Semantic Kernel Integration
- v0.6.4: Permission System
- v0.7.x: Chat Session management

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│              v0.6.1i Tool Execution Service Architecture                      │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  src/AIntern.Core/Interfaces/                                                │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │                                                                         │  │
│  │  IToolExecutionService                                                  │  │
│  │  ┌───────────────────────────────────────────────────────────────────┐ │  │
│  │  │                                                                    │ │  │
│  │  │  Methods                                                           │ │  │
│  │  │  ├── ExecuteAsync(toolId, context, ct) → ToolExecutionResult      │ │  │
│  │  │  ├── Validate(toolId, parameters) → ToolValidationResult          │ │  │
│  │  │  ├── GetExecutionSummary(toolId, parameters) → string             │ │  │
│  │  │  └── GetEffectiveRiskLevel(toolId, parameters) → RiskLevel        │ │  │
│  │  │                                                                    │ │  │
│  │  │  Events                                                            │ │  │
│  │  │  ├── ExecutionStarted                                             │ │  │
│  │  │  ├── ExecutionCompleted                                           │ │  │
│  │  │  └── ExecutionProgress                                            │ │  │
│  │  │                                                                    │ │  │
│  │  └───────────────────────────────────────────────────────────────────┘ │  │
│  │                                                                         │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│                                                                              │
│  src/AIntern.Core/Tools/                                                     │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │                                                                         │  │
│  │  ToolExecutionResult                                                    │  │
│  │  ┌───────────────────────────────────────────────────────────────────┐ │  │
│  │  │ Properties                                                         │ │  │
│  │  │ ├── ToolId: string                                                │ │  │
│  │  │ ├── ExecutionId: Guid                                             │ │  │
│  │  │ ├── Result: ToolResult                                            │ │  │
│  │  │ ├── Status: ToolExecutionStatus                                   │ │  │
│  │  │ ├── StartedAt: DateTime                                           │ │  │
│  │  │ ├── CompletedAt: DateTime                                         │ │  │
│  │  │ ├── Duration: TimeSpan                                            │ │  │
│  │  │ ├── WasApproved: bool                                             │ │  │
│  │  │ ├── TimedOut: bool                                                │ │  │
│  │  │ └── WasCancelled: bool                                            │ │  │
│  │  │                                                                    │ │  │
│  │  │ Factory Methods                                                    │ │  │
│  │  │ ├── Success(toolId, executionId, result, startedAt)               │ │  │
│  │  │ ├── Failed(toolId, executionId, result, startedAt)                │ │  │
│  │  │ ├── Cancelled(toolId, executionId, startedAt)                     │ │  │
│  │  │ ├── Timeout(toolId, executionId, startedAt, timeout)              │ │  │
│  │  │ └── ToolNotFound(toolId)                                          │ │  │
│  │  └───────────────────────────────────────────────────────────────────┘ │  │
│  │                                                                         │  │
│  │  ToolExecutionStatus (enum)                                             │  │
│  │  ├── Pending                                                           │  │
│  │  ├── InProgress                                                        │  │
│  │  ├── Completed                                                         │  │
│  │  ├── Failed                                                            │  │
│  │  └── Cancelled                                                         │  │
│  │                                                                         │  │
│  │  Event Args                                                             │  │
│  │  ├── ToolExecutionStartedEventArgs                                     │  │
│  │  ├── ToolExecutionCompletedEventArgs                                   │  │
│  │  └── ToolExecutionProgressEventArgs                                    │  │
│  │                                                                         │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│                                                                              │
│  src/AIntern.Services/Tools/                                                 │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │                                                                         │  │
│  │  ToolExecutionService : IToolExecutionService                           │  │
│  │  ┌───────────────────────────────────────────────────────────────────┐ │  │
│  │  │                                                                    │ │  │
│  │  │  Dependencies                                                      │ │  │
│  │  │  ├── _registry: IToolRegistry                                     │ │  │
│  │  │  ├── _logger: ILogger<ToolExecutionService>                       │ │  │
│  │  │  └── _options: ToolExecutionOptions                               │ │  │
│  │  │                                                                    │ │  │
│  │  │  Execution Flow                                                    │ │  │
│  │  │  1. Lookup tool from registry                                     │ │  │
│  │  │  2. Fire ExecutionStarted event                                   │ │  │
│  │  │  3. Create linked timeout CancellationToken                       │ │  │
│  │  │  4. Create progress reporter                                      │ │  │
│  │  │  5. Execute tool with timeout                                     │ │  │
│  │  │  6. Handle exceptions (cancel, timeout, error)                    │ │  │
│  │  │  7. Fire ExecutionCompleted event                                 │ │  │
│  │  │  8. Return ToolExecutionResult                                    │ │  │
│  │  │                                                                    │ │  │
│  │  └───────────────────────────────────────────────────────────────────┘ │  │
│  │                                                                         │  │
│  │  ToolExecutionOptions                                                   │  │
│  │  ├── ExecutionTimeout: TimeSpan (default: 2 minutes)                   │  │
│  │  ├── MaxConcurrentExecutions: int (default: 3)                         │  │
│  │  ├── LogParameters: bool (default: false)                              │  │
│  │  └── LogResults: bool (default: true)                                  │  │
│  │                                                                         │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Execution Flow

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                       Tool Execution Flow                                     │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ExecuteAsync(toolId, context, ct)                                           │
│         │                                                                    │
│         ▼                                                                    │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │ 1. Lookup Tool                                                          │  │
│  │                                                                         │  │
│  │ var tool = _registry.GetTool(toolId);                                  │  │
│  │ if (tool == null)                                                      │  │
│  │     return ToolExecutionResult.ToolNotFound(toolId);                   │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│         │                                                                    │
│         ▼                                                                    │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │ 2. Fire ExecutionStarted Event                                          │  │
│  │                                                                         │  │
│  │ OnExecutionStarted(new ToolExecutionStartedEventArgs {                 │  │
│  │     ToolId = toolId,                                                   │  │
│  │     ToolName = tool.Name,                                              │  │
│  │     ExecutionId = context.ExecutionId,                                 │  │
│  │     StartedAt = startedAt                                              │  │
│  │ });                                                                    │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│         │                                                                    │
│         ▼                                                                    │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │ 3. Create Timeout Token                                                 │  │
│  │                                                                         │  │
│  │ using var timeoutCts = CancellationTokenSource                         │  │
│  │     .CreateLinkedTokenSource(ct);                                      │  │
│  │ timeoutCts.CancelAfter(_options.ExecutionTimeout);                     │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│         │                                                                    │
│         ▼                                                                    │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │ 4. Create Progress Reporter                                             │  │
│  │                                                                         │  │
│  │ var progress = new Progress<ToolProgress>(p =>                         │  │
│  │ {                                                                      │  │
│  │     OnExecutionProgress(new ToolExecutionProgressEventArgs {           │  │
│  │         ToolId = toolId,                                               │  │
│  │         ExecutionId = context.ExecutionId,                             │  │
│  │         Progress = p                                                   │  │
│  │     });                                                                │  │
│  │ });                                                                    │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│         │                                                                    │
│         ▼                                                                    │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │ 5. Execute Tool                                                         │  │
│  │                                                                         │  │
│  │ try {                                                                  │  │
│  │     var contextWithProgress = context with { Progress = progress };    │  │
│  │     var result = await tool.ExecuteAsync(                              │  │
│  │         contextWithProgress, timeoutCts.Token);                        │  │
│  │     return result.Success                                              │  │
│  │         ? ToolExecutionResult.Success(...)                             │  │
│  │         : ToolExecutionResult.Failed(...);                             │  │
│  │ }                                                                      │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│         │                                                                    │
│         ▼  (on exception)                                                    │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │ 6. Handle Exceptions                                                    │  │
│  │                                                                         │  │
│  │ catch (OperationCanceledException) when (ct.IsCancellationRequested)  │  │
│  │     → ToolExecutionResult.Cancelled(...)                               │  │
│  │                                                                         │  │
│  │ catch (OperationCanceledException)  // timeout                         │  │
│  │     → ToolExecutionResult.Timeout(...)                                 │  │
│  │                                                                         │  │
│  │ catch (Exception ex)                                                   │  │
│  │     → ToolExecutionResult.Failed(..., ToolResult.FromException(ex))    │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│         │                                                                    │
│         ▼                                                                    │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │ 7. Fire ExecutionCompleted Event                                        │  │
│  │                                                                         │  │
│  │ OnExecutionCompleted(new ToolExecutionCompletedEventArgs {             │  │
│  │     ToolId = toolId,                                                   │  │
│  │     ExecutionId = context.ExecutionId,                                 │  │
│  │     Result = executionResult,                                          │  │
│  │     CompletedAt = DateTime.UtcNow                                      │  │
│  │ });                                                                    │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│         │                                                                    │
│         ▼                                                                    │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │ 8. Return Result                                                        │  │
│  │                                                                         │  │
│  │ return executionResult;                                                │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Specifications

### 1. IToolExecutionService.cs

**Location**: `src/AIntern.Core/Interfaces/IToolExecutionService.cs`

```csharp
namespace AIntern.Core.Interfaces;

using System.Text.Json;
using AIntern.Core.Tools;

/// <summary>
/// Service for executing tools with proper lifecycle management.
/// </summary>
/// <remarks>
/// <para>
/// The tool execution service provides a centralized entry point for tool invocation.
/// It handles validation, timeout management, progress reporting, and event notifications.
/// </para>
/// <para>
/// All tool executions should go through this service rather than calling tools directly
/// to ensure consistent behavior and proper lifecycle management.
/// </para>
/// </remarks>
public interface IToolExecutionService
{
    /// <summary>
    /// Execute a tool with the given context.
    /// </summary>
    /// <remarks>
    /// <para>
    /// This method handles the complete execution lifecycle:
    /// </para>
    /// <list type="bullet">
    /// <item><description>Tool lookup from registry</description></item>
    /// <item><description>Timeout management</description></item>
    /// <item><description>Progress reporting</description></item>
    /// <item><description>Exception handling</description></item>
    /// <item><description>Event notifications</description></item>
    /// </list>
    /// </remarks>
    /// <param name="toolId">ID of the tool to execute.</param>
    /// <param name="context">Execution context with parameters and services.</param>
    /// <param name="ct">Cancellation token for the operation.</param>
    /// <returns>Complete execution result with metadata.</returns>
    Task<ToolExecutionResult> ExecuteAsync(
        string toolId,
        ToolExecutionContext context,
        CancellationToken ct = default);

    /// <summary>
    /// Validate tool parameters without executing.
    /// </summary>
    /// <remarks>
    /// Use this method to validate parameters before requesting user approval.
    /// This catches obvious errors early without executing the tool.
    /// </remarks>
    /// <param name="toolId">ID of the tool.</param>
    /// <param name="parameters">Parameters to validate.</param>
    /// <returns>Validation result with any errors or warnings.</returns>
    ToolValidationResult Validate(string toolId, JsonElement parameters);

    /// <summary>
    /// Get the execution summary for a tool invocation.
    /// </summary>
    /// <remarks>
    /// The summary is a human-readable description of what the tool invocation
    /// will do. This is used in approval dialogs to explain the action to the user.
    /// </remarks>
    /// <param name="toolId">ID of the tool.</param>
    /// <param name="parameters">Parameters for the invocation.</param>
    /// <returns>Human-readable summary like "Read file 'src/Program.cs'".</returns>
    string GetExecutionSummary(string toolId, JsonElement parameters);

    /// <summary>
    /// Get the effective risk level for a tool invocation.
    /// </summary>
    /// <remarks>
    /// <para>
    /// The effective risk level may be higher than the tool's default risk level
    /// based on the specific parameters provided.
    /// </para>
    /// <para>
    /// For example, a file write tool might have Low default risk, but writing
    /// to a system path would elevate it to High.
    /// </para>
    /// </remarks>
    /// <param name="toolId">ID of the tool.</param>
    /// <param name="parameters">Parameters for the invocation.</param>
    /// <returns>Effective risk level for this specific invocation.</returns>
    RiskLevel GetEffectiveRiskLevel(string toolId, JsonElement parameters);

    /// <summary>
    /// Event raised when tool execution starts.
    /// </summary>
    /// <remarks>
    /// Subscribe to this event to track when tools begin execution.
    /// Useful for UI updates and logging.
    /// </remarks>
    event EventHandler<ToolExecutionStartedEventArgs>? ExecutionStarted;

    /// <summary>
    /// Event raised when tool execution completes.
    /// </summary>
    /// <remarks>
    /// Subscribe to this event to track when tools finish execution.
    /// The event args contain the complete execution result.
    /// </remarks>
    event EventHandler<ToolExecutionCompletedEventArgs>? ExecutionCompleted;

    /// <summary>
    /// Event raised during tool execution progress.
    /// </summary>
    /// <remarks>
    /// Subscribe to this event to receive progress updates for long-running tools.
    /// Not all tools report progress; this event may not fire for quick operations.
    /// </remarks>
    event EventHandler<ToolExecutionProgressEventArgs>? ExecutionProgress;
}
```

### 2. ToolExecutionResult.cs

**Location**: `src/AIntern.Core/Tools/ToolExecutionResult.cs`

```csharp
namespace AIntern.Core.Tools;

/// <summary>
/// Complete result of a tool execution including metadata.
/// </summary>
/// <remarks>
/// <para>
/// This class wraps a <see cref="ToolResult"/> with additional metadata about
/// the execution itself, such as timing, status, and cancellation information.
/// </para>
/// <para>
/// Use the factory methods to create instances:
/// </para>
/// <list type="bullet">
/// <item><description><see cref="Success"/> - Tool executed and succeeded</description></item>
/// <item><description><see cref="Failed"/> - Tool executed but failed</description></item>
/// <item><description><see cref="Cancelled"/> - Execution was cancelled</description></item>
/// <item><description><see cref="Timeout"/> - Execution timed out</description></item>
/// <item><description><see cref="ToolNotFound"/> - Tool not in registry</description></item>
/// </list>
/// </remarks>
public sealed class ToolExecutionResult
{
    /// <summary>
    /// The ID of the tool that was executed.
    /// </summary>
    public string ToolId { get; init; } = string.Empty;

    /// <summary>
    /// The unique execution ID for this invocation.
    /// </summary>
    public Guid ExecutionId { get; init; }

    /// <summary>
    /// The tool result containing output or error information.
    /// </summary>
    public ToolResult Result { get; init; } = null!;

    /// <summary>
    /// The execution status.
    /// </summary>
    public ToolExecutionStatus Status { get; init; }

    /// <summary>
    /// When execution started.
    /// </summary>
    public DateTime StartedAt { get; init; }

    /// <summary>
    /// When execution completed (including failure/cancellation).
    /// </summary>
    public DateTime CompletedAt { get; init; }

    /// <summary>
    /// Total execution duration.
    /// </summary>
    public TimeSpan Duration => CompletedAt - StartedAt;

    /// <summary>
    /// Whether the user approved this execution.
    /// </summary>
    public bool WasApproved { get; init; }

    /// <summary>
    /// Whether execution exceeded the timeout limit.
    /// </summary>
    public bool TimedOut { get; init; }

    /// <summary>
    /// Whether execution was cancelled by user or system.
    /// </summary>
    public bool WasCancelled { get; init; }

    /// <summary>
    /// Whether the execution completed successfully.
    /// </summary>
    public bool IsSuccess => Status == ToolExecutionStatus.Completed && Result.Success;

    /// <summary>
    /// Whether the execution failed for any reason.
    /// </summary>
    public bool IsFailure => Status == ToolExecutionStatus.Failed;

    #region Factory Methods

    /// <summary>
    /// Create a successful execution result.
    /// </summary>
    /// <param name="toolId">ID of the executed tool.</param>
    /// <param name="executionId">Execution ID.</param>
    /// <param name="result">The successful tool result.</param>
    /// <param name="startedAt">When execution started.</param>
    /// <returns>A successful execution result.</returns>
    public static ToolExecutionResult Success(
        string toolId,
        Guid executionId,
        ToolResult result,
        DateTime startedAt) =>
        new()
        {
            ToolId = toolId,
            ExecutionId = executionId,
            Result = result,
            Status = ToolExecutionStatus.Completed,
            StartedAt = startedAt,
            CompletedAt = DateTime.UtcNow,
            WasApproved = true
        };

    /// <summary>
    /// Create a failed execution result.
    /// </summary>
    /// <param name="toolId">ID of the executed tool.</param>
    /// <param name="executionId">Execution ID.</param>
    /// <param name="result">The failed tool result.</param>
    /// <param name="startedAt">When execution started.</param>
    /// <returns>A failed execution result.</returns>
    public static ToolExecutionResult Failed(
        string toolId,
        Guid executionId,
        ToolResult result,
        DateTime startedAt) =>
        new()
        {
            ToolId = toolId,
            ExecutionId = executionId,
            Result = result,
            Status = ToolExecutionStatus.Failed,
            StartedAt = startedAt,
            CompletedAt = DateTime.UtcNow
        };

    /// <summary>
    /// Create a cancelled execution result.
    /// </summary>
    /// <param name="toolId">ID of the tool.</param>
    /// <param name="executionId">Execution ID.</param>
    /// <param name="startedAt">When execution started.</param>
    /// <returns>A cancelled execution result.</returns>
    public static ToolExecutionResult Cancelled(
        string toolId,
        Guid executionId,
        DateTime startedAt) =>
        new()
        {
            ToolId = toolId,
            ExecutionId = executionId,
            Result = ToolResult.Cancelled(),
            Status = ToolExecutionStatus.Cancelled,
            StartedAt = startedAt,
            CompletedAt = DateTime.UtcNow,
            WasCancelled = true
        };

    /// <summary>
    /// Create a timeout execution result.
    /// </summary>
    /// <param name="toolId">ID of the tool.</param>
    /// <param name="executionId">Execution ID.</param>
    /// <param name="startedAt">When execution started.</param>
    /// <param name="timeout">The timeout duration that was exceeded.</param>
    /// <returns>A timeout execution result.</returns>
    public static ToolExecutionResult Timeout(
        string toolId,
        Guid executionId,
        DateTime startedAt,
        TimeSpan timeout) =>
        new()
        {
            ToolId = toolId,
            ExecutionId = executionId,
            Result = ToolResult.Timeout(timeout),
            Status = ToolExecutionStatus.Failed,
            StartedAt = startedAt,
            CompletedAt = DateTime.UtcNow,
            TimedOut = true
        };

    /// <summary>
    /// Create a tool not found result.
    /// </summary>
    /// <param name="toolId">ID of the tool that was not found.</param>
    /// <returns>A tool not found execution result.</returns>
    public static ToolExecutionResult ToolNotFound(string toolId) =>
        new()
        {
            ToolId = toolId,
            ExecutionId = Guid.NewGuid(),
            Result = ToolResult.Failed($"Tool '{toolId}' not found", "ToolNotFound"),
            Status = ToolExecutionStatus.Failed,
            StartedAt = DateTime.UtcNow,
            CompletedAt = DateTime.UtcNow
        };

    /// <summary>
    /// Create a validation failed result.
    /// </summary>
    /// <param name="toolId">ID of the tool.</param>
    /// <param name="validationResult">The validation result with errors.</param>
    /// <returns>A validation failed execution result.</returns>
    public static ToolExecutionResult ValidationFailed(
        string toolId,
        ToolValidationResult validationResult) =>
        new()
        {
            ToolId = toolId,
            ExecutionId = Guid.NewGuid(),
            Result = ToolResult.Failed(
                validationResult.Errors.FirstOrDefault()?.Message ?? "Validation failed",
                "ValidationFailed"),
            Status = ToolExecutionStatus.Failed,
            StartedAt = DateTime.UtcNow,
            CompletedAt = DateTime.UtcNow
        };

    /// <summary>
    /// Create an approval denied result.
    /// </summary>
    /// <param name="toolId">ID of the tool.</param>
    /// <param name="executionId">Execution ID.</param>
    /// <returns>An approval denied execution result.</returns>
    public static ToolExecutionResult ApprovalDenied(
        string toolId,
        Guid executionId) =>
        new()
        {
            ToolId = toolId,
            ExecutionId = executionId,
            Result = ToolResult.Failed("User denied approval", "ApprovalDenied"),
            Status = ToolExecutionStatus.Cancelled,
            StartedAt = DateTime.UtcNow,
            CompletedAt = DateTime.UtcNow,
            WasApproved = false
        };

    #endregion
}
```

### 3. ToolExecutionStatus.cs

**Location**: `src/AIntern.Core/Tools/ToolExecutionStatus.cs`

```csharp
namespace AIntern.Core.Tools;

/// <summary>
/// Status of a tool execution.
/// </summary>
/// <remarks>
/// <para>
/// The execution status tracks the lifecycle state of a tool invocation:
/// </para>
/// <list type="bullet">
/// <item><description><see cref="Pending"/> - Waiting to start</description></item>
/// <item><description><see cref="InProgress"/> - Currently executing</description></item>
/// <item><description><see cref="Completed"/> - Finished successfully</description></item>
/// <item><description><see cref="Failed"/> - Finished with error</description></item>
/// <item><description><see cref="Cancelled"/> - Stopped by user/system</description></item>
/// </list>
/// </remarks>
public enum ToolExecutionStatus
{
    /// <summary>
    /// Execution is pending (waiting to start).
    /// </summary>
    /// <remarks>
    /// This status is used when an execution request has been received
    /// but the tool has not yet begun processing.
    /// </remarks>
    Pending = 0,

    /// <summary>
    /// Execution is currently in progress.
    /// </summary>
    /// <remarks>
    /// The tool is actively processing. Progress events may be fired
    /// during this state for long-running operations.
    /// </remarks>
    InProgress = 1,

    /// <summary>
    /// Execution completed successfully.
    /// </summary>
    /// <remarks>
    /// The tool finished execution without errors. The result
    /// contains the successful output data.
    /// </remarks>
    Completed = 2,

    /// <summary>
    /// Execution failed.
    /// </summary>
    /// <remarks>
    /// The tool execution failed due to an error, timeout, or
    /// validation failure. The result contains error details.
    /// </remarks>
    Failed = 3,

    /// <summary>
    /// Execution was cancelled.
    /// </summary>
    /// <remarks>
    /// The execution was stopped before completion, either by
    /// user request or system cancellation.
    /// </remarks>
    Cancelled = 4
}

/// <summary>
/// Extension methods for <see cref="ToolExecutionStatus"/>.
/// </summary>
public static class ToolExecutionStatusExtensions
{
    /// <summary>
    /// Whether the status represents a terminal state.
    /// </summary>
    /// <param name="status">The status to check.</param>
    /// <returns>True if the execution is complete (success, failure, or cancelled).</returns>
    public static bool IsTerminal(this ToolExecutionStatus status) =>
        status switch
        {
            ToolExecutionStatus.Completed => true,
            ToolExecutionStatus.Failed => true,
            ToolExecutionStatus.Cancelled => true,
            _ => false
        };

    /// <summary>
    /// Whether the status represents a successful outcome.
    /// </summary>
    /// <param name="status">The status to check.</param>
    /// <returns>True if the execution completed successfully.</returns>
    public static bool IsSuccessful(this ToolExecutionStatus status) =>
        status == ToolExecutionStatus.Completed;

    /// <summary>
    /// Whether the status represents an active state.
    /// </summary>
    /// <param name="status">The status to check.</param>
    /// <returns>True if the execution is pending or in progress.</returns>
    public static bool IsActive(this ToolExecutionStatus status) =>
        status switch
        {
            ToolExecutionStatus.Pending => true,
            ToolExecutionStatus.InProgress => true,
            _ => false
        };

    /// <summary>
    /// Get a human-readable display name for the status.
    /// </summary>
    /// <param name="status">The status to get the name for.</param>
    /// <returns>Display name suitable for UI.</returns>
    public static string GetDisplayName(this ToolExecutionStatus status) =>
        status switch
        {
            ToolExecutionStatus.Pending => "Pending",
            ToolExecutionStatus.InProgress => "In Progress",
            ToolExecutionStatus.Completed => "Completed",
            ToolExecutionStatus.Failed => "Failed",
            ToolExecutionStatus.Cancelled => "Cancelled",
            _ => "Unknown"
        };
}
```

### 4. ToolExecutionEventArgs.cs

**Location**: `src/AIntern.Core/Tools/ToolExecutionEventArgs.cs`

```csharp
namespace AIntern.Core.Tools;

/// <summary>
/// Event args for tool execution started.
/// </summary>
/// <remarks>
/// This event is raised when a tool begins execution, before any
/// work is performed. Use this to update UI or start timers.
/// </remarks>
public sealed class ToolExecutionStartedEventArgs : EventArgs
{
    /// <summary>
    /// ID of the tool being executed.
    /// </summary>
    public string ToolId { get; init; } = string.Empty;

    /// <summary>
    /// Display name of the tool.
    /// </summary>
    public string ToolName { get; init; } = string.Empty;

    /// <summary>
    /// Unique execution ID for correlation.
    /// </summary>
    public Guid ExecutionId { get; init; }

    /// <summary>
    /// When execution started.
    /// </summary>
    public DateTime StartedAt { get; init; }

    /// <summary>
    /// The session this execution belongs to.
    /// </summary>
    public Guid SessionId { get; init; }

    /// <summary>
    /// Human-readable summary of what will be executed.
    /// </summary>
    public string? ExecutionSummary { get; init; }

    /// <summary>
    /// Risk level for this execution.
    /// </summary>
    public RiskLevel RiskLevel { get; init; }
}

/// <summary>
/// Event args for tool execution completed.
/// </summary>
/// <remarks>
/// This event is raised when a tool finishes execution, regardless
/// of whether it succeeded, failed, or was cancelled.
/// </remarks>
public sealed class ToolExecutionCompletedEventArgs : EventArgs
{
    /// <summary>
    /// ID of the tool that was executed.
    /// </summary>
    public string ToolId { get; init; } = string.Empty;

    /// <summary>
    /// Unique execution ID for correlation.
    /// </summary>
    public Guid ExecutionId { get; init; }

    /// <summary>
    /// The complete execution result.
    /// </summary>
    public ToolExecutionResult Result { get; init; } = null!;

    /// <summary>
    /// When execution completed.
    /// </summary>
    public DateTime CompletedAt { get; init; }

    /// <summary>
    /// Whether the execution was successful.
    /// </summary>
    public bool IsSuccess => Result.IsSuccess;

    /// <summary>
    /// Total execution duration.
    /// </summary>
    public TimeSpan Duration => Result.Duration;
}

/// <summary>
/// Event args for tool execution progress.
/// </summary>
/// <remarks>
/// This event is raised periodically during long-running tool executions
/// when the tool reports progress. Not all tools report progress.
/// </remarks>
public sealed class ToolExecutionProgressEventArgs : EventArgs
{
    /// <summary>
    /// ID of the tool being executed.
    /// </summary>
    public string ToolId { get; init; } = string.Empty;

    /// <summary>
    /// Unique execution ID for correlation.
    /// </summary>
    public Guid ExecutionId { get; init; }

    /// <summary>
    /// The progress information.
    /// </summary>
    public ToolProgress Progress { get; init; } = null!;

    /// <summary>
    /// Progress percentage if available.
    /// </summary>
    public double? PercentComplete => Progress.PercentComplete;

    /// <summary>
    /// Progress message.
    /// </summary>
    public string Message => Progress.Message ?? string.Empty;
}
```

### 5. ToolExecutionService.cs

**Location**: `src/AIntern.Services/Tools/ToolExecutionService.cs`

```csharp
namespace AIntern.Services.Tools;

using System.Text.Json;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using AIntern.Core.Interfaces;
using AIntern.Core.Tools;

/// <summary>
/// Service for executing tools with proper lifecycle management.
/// </summary>
/// <remarks>
/// <para>
/// The <see cref="ToolExecutionService"/> provides a centralized entry point
/// for tool invocation with built-in support for:
/// </para>
/// <list type="bullet">
/// <item><description>Timeout management</description></item>
/// <item><description>Cancellation handling</description></item>
/// <item><description>Progress reporting</description></item>
/// <item><description>Event notifications</description></item>
/// <item><description>Error handling</description></item>
/// </list>
/// <para>
/// All tool executions should go through this service to ensure consistent
/// behavior and proper lifecycle management.
/// </para>
/// </remarks>
public sealed class ToolExecutionService : IToolExecutionService
{
    private readonly IToolRegistry _registry;
    private readonly ILogger<ToolExecutionService> _logger;
    private readonly ToolExecutionOptions _options;

    /// <summary>
    /// Initializes a new instance of the <see cref="ToolExecutionService"/> class.
    /// </summary>
    /// <param name="registry">The tool registry for tool lookup.</param>
    /// <param name="logger">Logger for diagnostics.</param>
    /// <param name="options">Execution options.</param>
    public ToolExecutionService(
        IToolRegistry registry,
        ILogger<ToolExecutionService> logger,
        IOptions<ToolExecutionOptions> options)
    {
        _registry = registry ?? throw new ArgumentNullException(nameof(registry));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _options = options?.Value ?? new ToolExecutionOptions();
    }

    /// <inheritdoc />
    public async Task<ToolExecutionResult> ExecuteAsync(
        string toolId,
        ToolExecutionContext context,
        CancellationToken ct = default)
    {
        var startedAt = DateTime.UtcNow;

        // Validate inputs
        if (string.IsNullOrEmpty(toolId))
        {
            throw new ArgumentException("Tool ID cannot be null or empty", nameof(toolId));
        }

        if (context == null)
        {
            throw new ArgumentNullException(nameof(context));
        }

        // Get the tool from registry
        var tool = _registry.GetTool(toolId);
        if (tool == null)
        {
            _logger.LogWarning("Tool not found: {ToolId}", toolId);
            return ToolExecutionResult.ToolNotFound(toolId);
        }

        // Check availability
        if (!tool.IsAvailable)
        {
            _logger.LogWarning("Tool not available: {ToolId}", toolId);
            return ToolExecutionResult.Failed(
                toolId,
                context.ExecutionId,
                ToolResult.Failed($"Tool '{toolId}' is not available", "ToolNotAvailable"),
                startedAt);
        }

        // Log execution start
        LogExecutionStart(toolId, tool.Name, context);

        // Fire started event
        OnExecutionStarted(new ToolExecutionStartedEventArgs
        {
            ToolId = toolId,
            ToolName = tool.Name,
            ExecutionId = context.ExecutionId,
            SessionId = context.SessionId,
            StartedAt = startedAt,
            ExecutionSummary = tool.GetExecutionSummary(context.EffectiveParameters),
            RiskLevel = tool.GetEffectiveRiskLevel(context.EffectiveParameters)
        });

        try
        {
            // Create linked timeout token
            using var timeoutCts = CancellationTokenSource.CreateLinkedTokenSource(ct);
            timeoutCts.CancelAfter(_options.ExecutionTimeout);

            // Create progress reporter
            var progress = new Progress<ToolProgress>(p =>
            {
                OnExecutionProgress(new ToolExecutionProgressEventArgs
                {
                    ToolId = toolId,
                    ExecutionId = context.ExecutionId,
                    Progress = p
                });
            });

            // Execute with timeout
            var contextWithProgress = context with { Progress = progress };
            var result = await tool.ExecuteAsync(contextWithProgress, timeoutCts.Token);

            // Create execution result
            var executionResult = result.Success
                ? ToolExecutionResult.Success(toolId, context.ExecutionId, result, startedAt)
                : ToolExecutionResult.Failed(toolId, context.ExecutionId, result, startedAt);

            // Log completion
            LogExecutionComplete(toolId, context, executionResult);

            // Fire completed event
            OnExecutionCompleted(new ToolExecutionCompletedEventArgs
            {
                ToolId = toolId,
                ExecutionId = context.ExecutionId,
                Result = executionResult,
                CompletedAt = DateTime.UtcNow
            });

            return executionResult;
        }
        catch (OperationCanceledException) when (ct.IsCancellationRequested)
        {
            // User/system cancellation
            _logger.LogInformation(
                "Tool execution cancelled: {ToolId} (ExecutionId: {ExecutionId})",
                toolId, context.ExecutionId);

            var result = ToolExecutionResult.Cancelled(toolId, context.ExecutionId, startedAt);

            OnExecutionCompleted(new ToolExecutionCompletedEventArgs
            {
                ToolId = toolId,
                ExecutionId = context.ExecutionId,
                Result = result,
                CompletedAt = DateTime.UtcNow
            });

            return result;
        }
        catch (OperationCanceledException)
        {
            // Timeout (not user cancellation)
            _logger.LogWarning(
                "Tool execution timed out: {ToolId} (ExecutionId: {ExecutionId}, Timeout: {Timeout})",
                toolId, context.ExecutionId, _options.ExecutionTimeout);

            var result = ToolExecutionResult.Timeout(
                toolId, context.ExecutionId, startedAt, _options.ExecutionTimeout);

            OnExecutionCompleted(new ToolExecutionCompletedEventArgs
            {
                ToolId = toolId,
                ExecutionId = context.ExecutionId,
                Result = result,
                CompletedAt = DateTime.UtcNow
            });

            return result;
        }
        catch (ToolExecutionException tex)
        {
            // Tool-specific exception
            _logger.LogError(tex,
                "Tool execution failed: {ToolId} (ExecutionId: {ExecutionId})",
                toolId, context.ExecutionId);

            var result = ToolExecutionResult.Failed(
                toolId,
                context.ExecutionId,
                ToolResult.Failed(tex.Message, tex.ErrorCode ?? "ToolExecutionError"),
                startedAt);

            OnExecutionCompleted(new ToolExecutionCompletedEventArgs
            {
                ToolId = toolId,
                ExecutionId = context.ExecutionId,
                Result = result,
                CompletedAt = DateTime.UtcNow
            });

            return result;
        }
        catch (Exception ex)
        {
            // Unexpected exception
            _logger.LogError(ex,
                "Tool execution failed with unexpected exception: {ToolId} (ExecutionId: {ExecutionId})",
                toolId, context.ExecutionId);

            var result = ToolExecutionResult.Failed(
                toolId,
                context.ExecutionId,
                ToolResult.FromException(ex),
                startedAt);

            OnExecutionCompleted(new ToolExecutionCompletedEventArgs
            {
                ToolId = toolId,
                ExecutionId = context.ExecutionId,
                Result = result,
                CompletedAt = DateTime.UtcNow
            });

            return result;
        }
    }

    /// <inheritdoc />
    public ToolValidationResult Validate(string toolId, JsonElement parameters)
    {
        if (string.IsNullOrEmpty(toolId))
        {
            return ToolValidationResult.Invalid(
                ToolValidationError.Required("toolId", "Tool ID is required"));
        }

        var tool = _registry.GetTool(toolId);
        if (tool == null)
        {
            return ToolValidationResult.Invalid(
                new ToolValidationError
                {
                    ParameterName = "toolId",
                    Message = $"Tool '{toolId}' not found",
                    ErrorCode = "tool_not_found"
                });
        }

        return tool.Validate(parameters);
    }

    /// <inheritdoc />
    public string GetExecutionSummary(string toolId, JsonElement parameters)
    {
        var tool = _registry.GetTool(toolId);
        return tool?.GetExecutionSummary(parameters) ?? $"Execute {toolId}";
    }

    /// <inheritdoc />
    public RiskLevel GetEffectiveRiskLevel(string toolId, JsonElement parameters)
    {
        var tool = _registry.GetTool(toolId);
        return tool?.GetEffectiveRiskLevel(parameters) ?? RiskLevel.Medium;
    }

    #region Events

    /// <inheritdoc />
    public event EventHandler<ToolExecutionStartedEventArgs>? ExecutionStarted;

    /// <inheritdoc />
    public event EventHandler<ToolExecutionCompletedEventArgs>? ExecutionCompleted;

    /// <inheritdoc />
    public event EventHandler<ToolExecutionProgressEventArgs>? ExecutionProgress;

    private void OnExecutionStarted(ToolExecutionStartedEventArgs args) =>
        ExecutionStarted?.Invoke(this, args);

    private void OnExecutionCompleted(ToolExecutionCompletedEventArgs args) =>
        ExecutionCompleted?.Invoke(this, args);

    private void OnExecutionProgress(ToolExecutionProgressEventArgs args) =>
        ExecutionProgress?.Invoke(this, args);

    #endregion

    #region Logging Helpers

    private void LogExecutionStart(string toolId, string toolName, ToolExecutionContext context)
    {
        _logger.LogInformation(
            "Starting tool execution: {ToolId} ({ToolName}) - ExecutionId: {ExecutionId}",
            toolId, toolName, context.ExecutionId);

        if (_options.LogParameters)
        {
            _logger.LogDebug(
                "Tool parameters: {Parameters}",
                context.EffectiveParameters.GetRawText());
        }
    }

    private void LogExecutionComplete(
        string toolId,
        ToolExecutionContext context,
        ToolExecutionResult result)
    {
        _logger.LogInformation(
            "Tool execution completed: {ToolId} - ExecutionId: {ExecutionId}, " +
            "Success: {Success}, Duration: {Duration}ms",
            toolId, context.ExecutionId, result.IsSuccess, result.Duration.TotalMilliseconds);

        if (_options.LogResults && !result.IsSuccess)
        {
            _logger.LogWarning(
                "Tool execution failed: {ToolId} - Error: {Error}",
                toolId, result.Result.ErrorMessage);
        }
    }

    #endregion
}
```

### 6. ToolExecutionOptions.cs

**Location**: `src/AIntern.Services/Tools/ToolExecutionOptions.cs`

```csharp
namespace AIntern.Services.Tools;

/// <summary>
/// Options for tool execution behavior.
/// </summary>
/// <remarks>
/// <para>
/// These options control how the <see cref="ToolExecutionService"/> behaves:
/// </para>
/// <list type="bullet">
/// <item><description>Timeout limits for execution</description></item>
/// <item><description>Concurrency controls</description></item>
/// <item><description>Logging behavior</description></item>
/// </list>
/// <para>
/// Configure these options in your application startup:
/// </para>
/// <code>
/// services.Configure&lt;ToolExecutionOptions&gt;(options =>
/// {
///     options.ExecutionTimeout = TimeSpan.FromMinutes(5);
///     options.MaxConcurrentExecutions = 5;
/// });
/// </code>
/// </remarks>
public sealed class ToolExecutionOptions
{
    /// <summary>
    /// Configuration section name for binding.
    /// </summary>
    public const string SectionName = "ToolExecution";

    /// <summary>
    /// Default execution timeout for tools.
    /// </summary>
    /// <remarks>
    /// Individual tools may have their own timeout behavior, but this
    /// provides a global safety limit. Default is 2 minutes.
    /// </remarks>
    public TimeSpan ExecutionTimeout { get; set; } = TimeSpan.FromMinutes(2);

    /// <summary>
    /// Maximum number of concurrent tool executions.
    /// </summary>
    /// <remarks>
    /// <para>
    /// This limits how many tools can execute simultaneously to prevent
    /// resource exhaustion. Default is 3.
    /// </para>
    /// <para>
    /// Note: This limit is per-session, not global across the application.
    /// </para>
    /// </remarks>
    public int MaxConcurrentExecutions { get; set; } = 3;

    /// <summary>
    /// Whether to log tool parameters.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Set to true to log the parameters passed to tools. This is useful
    /// for debugging but may expose sensitive data in logs.
    /// </para>
    /// <para>
    /// Default is false to protect sensitive information.
    /// </para>
    /// </remarks>
    public bool LogParameters { get; set; } = false;

    /// <summary>
    /// Whether to log tool results.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Set to true to log tool execution results. Results may be large
    /// (e.g., file contents) so consider log storage implications.
    /// </para>
    /// <para>
    /// Default is true for failure diagnostics.
    /// </para>
    /// </remarks>
    public bool LogResults { get; set; } = true;

    /// <summary>
    /// Whether to validate parameters before execution.
    /// </summary>
    /// <remarks>
    /// When true, the execution service will call the tool's Validate
    /// method before execution. Default is true.
    /// </remarks>
    public bool ValidateBeforeExecution { get; set; } = true;

    /// <summary>
    /// Default retry count for transient failures.
    /// </summary>
    /// <remarks>
    /// Number of times to retry a tool execution if it fails with a
    /// transient error. Default is 0 (no retries).
    /// </remarks>
    public int RetryCount { get; set; } = 0;

    /// <summary>
    /// Delay between retry attempts.
    /// </summary>
    public TimeSpan RetryDelay { get; set; } = TimeSpan.FromSeconds(1);

    /// <summary>
    /// Whether to track execution metrics.
    /// </summary>
    /// <remarks>
    /// When true, execution timing and success/failure counts are tracked
    /// for monitoring purposes. Default is true.
    /// </remarks>
    public bool EnableMetrics { get; set; } = true;
}
```

### 7. ToolExecutionServiceExtensions.cs

**Location**: `src/AIntern.Services/Tools/ToolExecutionServiceExtensions.cs`

```csharp
namespace AIntern.Services.Tools;

using Microsoft.Extensions.DependencyInjection;
using AIntern.Core.Interfaces;

/// <summary>
/// Extension methods for tool execution service setup.
/// </summary>
/// <remarks>
/// <para>
/// These extensions provide convenient methods for registering the
/// tool execution service with the DI container.
/// </para>
/// <para>
/// Usage example:
/// </para>
/// <code>
/// services.AddToolRegistry()
///     .AddToolExecutionService()
///     .AddTool&lt;FileReadTool&gt;();
/// </code>
/// </remarks>
public static class ToolExecutionServiceExtensions
{
    /// <summary>
    /// Add the tool execution service to the container.
    /// </summary>
    /// <param name="services">The service collection.</param>
    /// <returns>The service collection for chaining.</returns>
    public static IServiceCollection AddToolExecutionService(this IServiceCollection services)
    {
        services.AddSingleton<IToolExecutionService, ToolExecutionService>();
        return services;
    }

    /// <summary>
    /// Add the tool execution service with options.
    /// </summary>
    /// <param name="services">The service collection.</param>
    /// <param name="configure">Options configuration action.</param>
    /// <returns>The service collection for chaining.</returns>
    public static IServiceCollection AddToolExecutionService(
        this IServiceCollection services,
        Action<ToolExecutionOptions> configure)
    {
        services.Configure(configure);
        services.AddSingleton<IToolExecutionService, ToolExecutionService>();
        return services;
    }

    /// <summary>
    /// Add the complete tool framework (registry + execution service).
    /// </summary>
    /// <param name="services">The service collection.</param>
    /// <returns>The service collection for chaining.</returns>
    public static IServiceCollection AddToolFramework(this IServiceCollection services)
    {
        services.AddToolRegistry();
        services.AddToolExecutionService();
        return services;
    }

    /// <summary>
    /// Add the complete tool framework with options.
    /// </summary>
    /// <param name="services">The service collection.</param>
    /// <param name="configure">Options configuration action.</param>
    /// <returns>The service collection for chaining.</returns>
    public static IServiceCollection AddToolFramework(
        this IServiceCollection services,
        Action<ToolExecutionOptions> configure)
    {
        services.AddToolRegistry();
        services.AddToolExecutionService(configure);
        return services;
    }
}
```

---

## Directory Structure

```
src/AIntern.Core/
├── Interfaces/
│   └── IToolExecutionService.cs                   (NEW)
└── Tools/
    ├── ToolExecutionResult.cs                     (NEW)
    ├── ToolExecutionStatus.cs                     (NEW)
    └── ToolExecutionEventArgs.cs                  (NEW)

src/AIntern.Services/
└── Tools/
    ├── ToolExecutionService.cs                    (NEW)
    ├── ToolExecutionOptions.cs                    (NEW)
    └── ToolExecutionServiceExtensions.cs          (NEW)
```

---

## Unit Test Plan

| Test Class | Test | Description |
|------------|------|-------------|
| **ToolExecutionResultTests** | | |
| | `Success_CreatesCorrectResult` | Factory method creates success result |
| | `Failed_CreatesCorrectResult` | Factory method creates failed result |
| | `Cancelled_CreatesCorrectResult` | Factory method creates cancelled result |
| | `Timeout_CreatesCorrectResult` | Factory method creates timeout result |
| | `ToolNotFound_CreatesCorrectResult` | Factory method creates not found result |
| | `ValidationFailed_CreatesCorrectResult` | Factory method creates validation failed |
| | `ApprovalDenied_CreatesCorrectResult` | Factory method creates approval denied |
| | `Duration_CalculatedCorrectly` | Duration is CompletedAt - StartedAt |
| | `IsSuccess_TrueWhenCompleted` | IsSuccess checks status and result |
| | `IsFailure_TrueWhenFailed` | IsFailure checks status |
| **ToolExecutionStatusTests** | | |
| | `IsTerminal_ReturnsCorrectly` | Terminal states identified |
| | `IsSuccessful_ReturnsCorrectly` | Success state identified |
| | `IsActive_ReturnsCorrectly` | Active states identified |
| | `GetDisplayName_ReturnsCorrectNames` | All display names correct |
| **ToolExecutionServiceTests** | | |
| | `ExecuteAsync_ToolNotFound_ReturnsNotFoundResult` | Missing tool handled |
| | `ExecuteAsync_ToolNotAvailable_ReturnsUnavailableResult` | Unavailable tool handled |
| | `ExecuteAsync_Success_ReturnsSuccessResult` | Successful execution |
| | `ExecuteAsync_ToolFails_ReturnsFailedResult` | Tool failure handled |
| | `ExecuteAsync_ToolThrows_ReturnsFailedResult` | Exception handled |
| | `ExecuteAsync_Timeout_ReturnsTimeoutResult` | Timeout handled |
| | `ExecuteAsync_Cancelled_ReturnsCancelledResult` | Cancellation handled |
| | `ExecuteAsync_FiresStartedEvent` | Started event fires |
| | `ExecuteAsync_FiresCompletedEvent` | Completed event fires |
| | `ExecuteAsync_ReportsProgress` | Progress events fire |
| | `ExecuteAsync_NullToolId_ThrowsArgumentException` | Null toolId throws |
| | `ExecuteAsync_NullContext_ThrowsArgumentNullException` | Null context throws |
| | `Validate_ToolNotFound_ReturnsError` | Missing tool returns error |
| | `Validate_ValidParameters_ReturnsValid` | Valid params pass |
| | `Validate_InvalidParameters_ReturnsErrors` | Invalid params return errors |
| | `GetExecutionSummary_ToolFound_ReturnsSummary` | Summary from tool |
| | `GetExecutionSummary_ToolNotFound_ReturnsDefault` | Default for missing |
| | `GetEffectiveRiskLevel_ToolFound_ReturnsLevel` | Risk from tool |
| | `GetEffectiveRiskLevel_ToolNotFound_ReturnsMedium` | Default risk |
| **TimeoutTests** | | |
| | `ExecuteAsync_ExecutionExceedsTimeout_ReturnsTimeout` | Timeout triggered |
| | `ExecuteAsync_ExecutionWithinTimeout_Succeeds` | No timeout |
| | `ExecuteAsync_TimeoutConfigurable` | Options timeout used |
| **CancellationTests** | | |
| | `ExecuteAsync_CancellationRequested_ReturnsCancelled` | User cancellation |
| | `ExecuteAsync_CancellationDuringExecution_ReturnsCancelled` | Mid-execution cancel |
| | `ExecuteAsync_CancellationBeforeStart_ReturnsCancelled` | Pre-execution cancel |
| **EventTests** | | |
| | `ExecutionStarted_ContainsCorrectData` | Event args populated |
| | `ExecutionCompleted_ContainsCorrectData` | Event args populated |
| | `ExecutionProgress_ContainsCorrectData` | Event args populated |
| | `Events_FireInCorrectOrder` | Started before completed |
| **OptionsTests** | | |
| | `DefaultOptions_HaveCorrectValues` | Defaults correct |
| | `ExecutionTimeout_Applied` | Timeout option used |
| | `LogParameters_Applied` | Log params option used |
| | `LogResults_Applied` | Log results option used |
| **ExtensionsTests** | | |
| | `AddToolExecutionService_RegistersService` | DI registration |
| | `AddToolExecutionService_WithOptions_ConfiguresOptions` | Options configured |
| | `AddToolFramework_RegistersBoth` | Registry and service |

**Total Tests**: 56

---

## Usage Examples

### Basic Execution

```csharp
// Inject the service
public class MyService
{
    private readonly IToolExecutionService _execution;

    public MyService(IToolExecutionService execution)
    {
        _execution = execution;
    }

    public async Task ReadFileAsync(string path)
    {
        var context = new ToolExecutionContext
        {
            ExecutionId = Guid.NewGuid(),
            SessionId = _currentSessionId,
            WorkspacePath = _workspacePath,
            Parameters = JsonSerializer.SerializeToElement(new { path }),
            Services = _services
        };

        var result = await _execution.ExecuteAsync("file-read", context);

        if (result.IsSuccess)
        {
            var content = result.Result.Data?.GetProperty("content").GetString();
            Console.WriteLine($"File content: {content}");
        }
        else
        {
            Console.WriteLine($"Failed: {result.Result.ErrorMessage}");
        }
    }
}
```

### With Progress Tracking

```csharp
// Subscribe to progress events
_execution.ExecutionProgress += (sender, args) =>
{
    Console.WriteLine($"Progress: {args.Message} ({args.PercentComplete:P0})");
};

var result = await _execution.ExecuteAsync("file-search", context);
```

### With Validation

```csharp
// Validate before approval
var validation = _execution.Validate("file-write", parameters);

if (!validation.IsValid)
{
    foreach (var error in validation.Errors)
    {
        Console.WriteLine($"Error: {error.ParameterName} - {error.Message}");
    }
    return;
}

// Get summary for approval dialog
var summary = _execution.GetExecutionSummary("file-write", parameters);
var riskLevel = _execution.GetEffectiveRiskLevel("file-write", parameters);

if (await RequestApproval(summary, riskLevel))
{
    var result = await _execution.ExecuteAsync("file-write", context);
}
```

### Configuring Options

```csharp
// In Program.cs or Startup.cs
services.AddToolFramework(options =>
{
    options.ExecutionTimeout = TimeSpan.FromMinutes(5);
    options.MaxConcurrentExecutions = 5;
    options.LogParameters = false; // Protect sensitive data
    options.LogResults = true;
});
```

### Listening for Events

```csharp
_execution.ExecutionStarted += (sender, args) =>
{
    _logger.LogInformation(
        "Tool started: {ToolName} - {Summary}",
        args.ToolName, args.ExecutionSummary);
};

_execution.ExecutionCompleted += (sender, args) =>
{
    _logger.LogInformation(
        "Tool completed: {ToolId} - Success: {Success}, Duration: {Duration}ms",
        args.ToolId, args.IsSuccess, args.Duration.TotalMilliseconds);

    if (!args.IsSuccess)
    {
        _logger.LogWarning("Tool failed: {Error}", args.Result.Result.ErrorMessage);
    }
};
```

---

## File Summary

### Files to Create

| File | Location | Lines | Purpose |
|------|----------|-------|---------|
| `IToolExecutionService.cs` | `Core/Interfaces/` | ~110 | Execution service interface |
| `ToolExecutionResult.cs` | `Core/Tools/` | ~200 | Execution result model |
| `ToolExecutionStatus.cs` | `Core/Tools/` | ~110 | Status enumeration |
| `ToolExecutionEventArgs.cs` | `Core/Tools/` | ~120 | Event argument models |
| `ToolExecutionService.cs` | `Services/Tools/` | ~280 | Service implementation |
| `ToolExecutionOptions.cs` | `Services/Tools/` | ~100 | Configuration options |
| `ToolExecutionServiceExtensions.cs` | `Services/Tools/` | ~70 | DI extensions |
| **Total** | | **~990** | |

### Files to Modify

| File | Changes |
|------|---------|
| `ServiceCollectionExtensions.cs` | Add tool execution service registration |

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | `ExecuteAsync` handles tool not found |
| AC-2 | `ExecuteAsync` handles tool not available |
| AC-3 | `ExecuteAsync` handles successful execution |
| AC-4 | `ExecuteAsync` handles tool failure |
| AC-5 | `ExecuteAsync` handles exceptions |
| AC-6 | `ExecuteAsync` handles timeout |
| AC-7 | `ExecuteAsync` handles cancellation |
| AC-8 | `ExecutionStarted` event fires before execution |
| AC-9 | `ExecutionCompleted` event fires after execution |
| AC-10 | `ExecutionProgress` event fires during long operations |
| AC-11 | `Validate` returns correct validation results |
| AC-12 | `GetExecutionSummary` returns tool summary |
| AC-13 | `GetEffectiveRiskLevel` returns correct risk |
| AC-14 | `ToolExecutionOptions` configures behavior |
| AC-15 | All 56 unit tests pass |

---

## Changelog Entry

```markdown
## v0.6.1i - Tool Execution Service

### Added
- `IToolExecutionService` interface with:
  - ExecuteAsync for tool invocation
  - Validate for parameter validation
  - GetExecutionSummary for approval dialogs
  - GetEffectiveRiskLevel for risk assessment
  - ExecutionStarted, ExecutionCompleted, ExecutionProgress events

- `ToolExecutionResult` model with:
  - Complete execution metadata (timing, status, approval)
  - Factory methods: Success, Failed, Cancelled, Timeout, ToolNotFound
  - Additional factories: ValidationFailed, ApprovalDenied
  - Duration calculation property

- `ToolExecutionStatus` enumeration:
  - Pending, InProgress, Completed, Failed, Cancelled
  - Extension methods: IsTerminal, IsSuccessful, IsActive, GetDisplayName

- `ToolExecutionEventArgs` models:
  - ToolExecutionStartedEventArgs with tool info and summary
  - ToolExecutionCompletedEventArgs with result and duration
  - ToolExecutionProgressEventArgs with progress info

- `ToolExecutionService` implementation:
  - Timeout management with configurable duration
  - Cancellation token support
  - Progress reporting integration
  - Exception handling for all failure modes
  - Comprehensive logging

- `ToolExecutionOptions` configuration:
  - ExecutionTimeout (default: 2 minutes)
  - MaxConcurrentExecutions (default: 3)
  - LogParameters (default: false)
  - LogResults (default: true)
  - ValidateBeforeExecution, RetryCount, EnableMetrics

- `ToolExecutionServiceExtensions`:
  - AddToolExecutionService() for DI registration
  - AddToolFramework() for complete framework setup
```

---

## Implementation Notes

### Timeout Handling
The service uses `CancellationTokenSource.CreateLinkedTokenSource` to combine user cancellation with timeout cancellation. The inner token source is cancelled when the timeout expires, while the outer token allows user cancellation. The exception handler distinguishes between these cases to return the appropriate result type.

### Progress Reporting
Progress is reported through the standard `IProgress<T>` pattern. The service creates a `Progress<ToolProgress>` that fires the `ExecutionProgress` event. Tools should check for progress availability and report periodically for long-running operations.

### Event Ordering
Events are guaranteed to fire in order: `ExecutionStarted` before any progress events, and all progress events before `ExecutionCompleted`. The completed event always fires, even in error cases.

### Error Classification
The service classifies errors into categories:
- **OperationCanceledException with user token**: User cancellation
- **OperationCanceledException without user token**: Timeout
- **ToolExecutionException**: Tool-specific errors (e.g., file not found)
- **Other exceptions**: Unexpected errors

### Logging Strategy
Logging is structured to enable correlation across events:
- `ToolId` and `ExecutionId` are included in all log entries
- Parameters are only logged if `LogParameters` is enabled (off by default for security)
- Results are logged on failure when `LogResults` is enabled
- Duration is always logged for performance monitoring

---

## Timeline Estimate

| Task | Estimated Effort |
|------|------------------|
| IToolExecutionService interface | 0.15 day |
| ToolExecutionResult model | 0.2 day |
| ToolExecutionStatus enum | 0.1 day |
| Event args models | 0.15 day |
| ToolExecutionService implementation | 0.4 day |
| ToolExecutionOptions | 0.1 day |
| DI Extensions | 0.1 day |
| Unit Tests | 0.5 day |
| **Total** | **1.7 days** |
