# Design Specification: AIntern v0.6.2f "Tool Call Request Models"

## Overview

**Version**: v0.6.2f
**Parent**: v0.6.2 Semantic Kernel Integration
**Focus**: Tool call request representation, approval decisions, and lifecycle tracking

### Purpose

This sub-version defines the models for tool call processing:
1. Create `ToolCallRequest` to represent parsed tool calls from LLM output
2. Create `ApprovalDecision` for user responses with remember options
3. Create `ToolCallLifecycle` for full lifecycle tracking
4. Create `ToolCallStatus` enum for all lifecycle states
5. Create `ToolCallRequestBuilder` for fluent construction
6. Create `ToolCallBatch` for parallel tool call handling
7. Integrate with validation from v0.6.1 tool framework

### Dependencies

**From v0.6.1a (Tool Core Models)**:
- `RiskLevel` for request risk assessment
- `ToolResult` for execution results
- `ToolValidationResult` for parameter validation

**From v0.6.2e (Agent Event System)**:
- Events reference `ToolCallRequest`

**Future Consumers**:
- v0.6.2g: FunctionCallParser (creates ToolCallRequests)
- v0.6.2i: AgentService (processes ToolCallRequests)

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                v0.6.2f Tool Call Request Models Architecture                  │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  src/SeniorIntern.Core/Models/                                               │
│  ├─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  ToolCallRequest                                                         │ │
│  │  ┌─────────────────────────────────────────────────────────────────────┐│ │
│  │  │  Identity                                                            ││ │
│  │  │  ├── Id: Guid                        (unique per call)              ││ │
│  │  │  ├── ToolId: string                  (tool identifier)              ││ │
│  │  │  ├── ToolName: string                (display name)                 ││ │
│  │  │  └── IterationNumber: int            (agent loop context)           ││ │
│  │  │                                                                      ││ │
│  │  │  Parameters                                                           ││ │
│  │  │  ├── Parameters: JsonElement         (parsed from LLM)              ││ │
│  │  │  ├── RawJson: string?                (original JSON)                ││ │
│  │  │  └── ValidationResult: ToolValidationResult?                         ││ │
│  │  │                                                                      ││ │
│  │  │  Risk Assessment                                                      ││ │
│  │  │  ├── RiskLevel: RiskLevel            (computed from params)         ││ │
│  │  │  ├── ExecutionSummary: string        (human-readable)               ││ │
│  │  │  └── Warnings: IReadOnlyList<string>?                                ││ │
│  │  │                                                                      ││ │
│  │  │  Timestamps                                                           ││ │
│  │  │  └── RequestedAt: DateTime                                           ││ │
│  │  └─────────────────────────────────────────────────────────────────────┘│ │
│  │                                                                          │ │
│  │  ApprovalDecision                                                        │ │
│  │  ┌─────────────────────────────────────────────────────────────────────┐│ │
│  │  │  ├── Approved: bool                  (user's choice)                ││ │
│  │  │  ├── Reason: string?                 (denial reason)                ││ │
│  │  │  ├── ModifiedParameters: JsonElement?                                ││ │
│  │  │  ├── RememberForSession: bool        (session-level remember)       ││ │
│  │  │  ├── RememberForTool: bool           (permanent remember)           ││ │
│  │  │  ├── RememberPattern: string?        (path/command pattern)         ││ │
│  │  │  ├── DecidedAt: DateTime                                             ││ │
│  │  │  └── DecisionDuration: TimeSpan                                      ││ │
│  │  └─────────────────────────────────────────────────────────────────────┘│ │
│  │                                                                          │ │
│  │  ToolCallLifecycle                                                       │ │
│  │  ┌─────────────────────────────────────────────────────────────────────┐│ │
│  │  │  ├── Request: ToolCallRequest                                        ││ │
│  │  │  ├── Status: ToolCallStatus                                          ││ │
│  │  │  ├── ApprovalDecision: ApprovalDecision?                             ││ │
│  │  │  ├── Result: ToolResult?                                             ││ │
│  │  │  ├── ExecutionStarted: DateTime?                                     ││ │
│  │  │  ├── ExecutionCompleted: DateTime?                                   ││ │
│  │  │  ├── Duration: TimeSpan?             (computed)                     ││ │
│  │  │  └── ErrorMessage: string?                                           ││ │
│  │  └─────────────────────────────────────────────────────────────────────┘│ │
│  │                                                                          │ │
│  │  ToolCallStatus                         ToolCallBatch                    │ │
│  │  ┌──────────────────────────┐          ┌────────────────────────────┐   │ │
│  │  │  Parsed                  │          │ Calls: List<ToolCallRequest>│   │ │
│  │  │  Validating              │          │ IterationNumber: int        │   │ │
│  │  │  ValidationFailed        │          │ IsParallel: bool            │   │ │
│  │  │  AwaitingApproval        │          │ Lifecycles: Dictionary      │   │ │
│  │  │  Approved                │          └────────────────────────────┘   │ │
│  │  │  Denied                  │                                            │ │
│  │  │  Executing               │                                            │ │
│  │  │  Completed               │                                            │ │
│  │  │  Failed                  │                                            │ │
│  │  │  Cancelled               │                                            │ │
│  │  │  TimedOut                │                                            │ │
│  │  └──────────────────────────┘                                            │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Lifecycle Flow

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                        Tool Call Lifecycle Flow                               │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  LLM Output with tool_call block                                             │
│      │                                                                       │
│      ▼                                                                       │
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │  Status: Parsed                                                       │   │
│  │  FunctionCallParser creates ToolCallRequest                           │   │
│  └──────────────────────────────────┬───────────────────────────────────┘   │
│                                     │                                        │
│                                     ▼                                        │
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │  Status: Validating                                                   │   │
│  │  ITool.Validate(parameters) called                                    │   │
│  └──────────────────────────────────┬───────────────────────────────────┘   │
│                                     │                                        │
│           ┌─────────────────────────┴─────────────────────────┐             │
│           │ Valid                                    Invalid   │             │
│           ▼                                              ▼                   │
│  ┌─────────────────────────┐              ┌───────────────────────────────┐ │
│  │  Check approval needed  │              │  Status: ValidationFailed     │ │
│  │  (RiskLevel, permissions)│              │  Error returned to LLM        │ │
│  └───────────┬─────────────┘              └───────────────────────────────┘ │
│              │                                                               │
│      ┌───────┴───────────────────────────────────┐                          │
│      │ Needs approval              Auto-approved │                          │
│      ▼                                   ▼                                   │
│  ┌─────────────────────────┐    ┌───────────────────────────────────────┐   │
│  │Status: AwaitingApproval │    │  Status: Approved                     │   │
│  │Wait for user decision   │    │  Skip to execution                    │   │
│  └───────────┬─────────────┘    └────────────────────┬──────────────────┘   │
│              │                                       │                       │
│      ┌───────┴───────────┐                          │                       │
│      │ Approved    Denied│                          │                       │
│      ▼              ▼    │                          │                       │
│  ┌──────────┐ ┌─────────┐│                          │                       │
│  │Approved  │ │Denied   ││                          │                       │
│  └────┬─────┘ └─────────┘│                          │                       │
│       │                  │                          │                       │
│       └──────────────────┼──────────────────────────┘                       │
│                          │                                                   │
│                          ▼                                                   │
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │  Status: Executing                                                    │   │
│  │  ITool.ExecuteAsync() called                                          │   │
│  └──────────────────────────────────┬───────────────────────────────────┘   │
│                                     │                                        │
│           ┌─────────────────────────┼─────────────────────────┐             │
│           │ Success                 │ Failed          Timeout │             │
│           ▼                         ▼                     ▼                  │
│  ┌─────────────────┐    ┌─────────────────┐    ┌─────────────────────────┐  │
│  │Status: Completed│    │Status: Failed   │    │Status: TimedOut         │  │
│  │Result available │    │ErrorMessage set │    │Execution cancelled      │  │
│  └─────────────────┘    └─────────────────┘    └─────────────────────────┘  │
│                                                                              │
│  ════════════════════════════════════════════════════════════════════════   │
│  Special case:                                                               │
│  [Any non-terminal status] ──Cancellation──► [Cancelled]                     │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Specifications

### 1. ToolCallRequest.cs

**Location**: `src/SeniorIntern.Core/Models/ToolCallRequest.cs`

```csharp
namespace SeniorIntern.Core.Models;

using System.Text.Json;
using SeniorIntern.Core.Tools;

/// <summary>
/// Represents a tool call request parsed from LLM output.
/// </summary>
/// <remarks>
/// <para>
/// ToolCallRequest captures all information about a tool invocation:
/// </para>
/// <list type="bullet">
/// <item>Tool identification and parameters</item>
/// <item>Risk assessment and execution summary</item>
/// <item>Validation results</item>
/// <item>Context (iteration number, timestamps)</item>
/// </list>
/// <para>
/// Requests are created by the FunctionCallParser and processed by the AgentService.
/// </para>
/// </remarks>
public sealed class ToolCallRequest
{
    #region Identity

    /// <summary>
    /// Unique identifier for this tool call.
    /// </summary>
    /// <remarks>
    /// Used to track this specific invocation through its lifecycle.
    /// </remarks>
    public Guid Id { get; init; } = Guid.NewGuid();

    /// <summary>
    /// Tool ID to invoke (e.g., "file-read", "terminal-execute").
    /// </summary>
    /// <remarks>
    /// Must match a registered tool in the IToolRegistry.
    /// </remarks>
    public string ToolId { get; init; } = string.Empty;

    /// <summary>
    /// Human-readable tool name.
    /// </summary>
    /// <remarks>
    /// Used in approval dialogs and logging.
    /// </remarks>
    public string ToolName { get; init; } = string.Empty;

    /// <summary>
    /// Iteration number when this was requested.
    /// </summary>
    /// <remarks>
    /// Links this request to the agent loop context.
    /// </remarks>
    public int IterationNumber { get; init; }

    #endregion

    #region Parameters

    /// <summary>
    /// Parameters parsed from the LLM output.
    /// </summary>
    /// <remarks>
    /// JsonElement allows flexible parameter handling without strong typing.
    /// Validation ensures parameters match the tool's schema.
    /// </remarks>
    public JsonElement Parameters { get; init; }

    /// <summary>
    /// Raw JSON from the LLM output.
    /// </summary>
    /// <remarks>
    /// Preserved for debugging and logging. May include extra whitespace
    /// or formatting from the LLM.
    /// </remarks>
    public string? RawJson { get; init; }

    /// <summary>
    /// Validation result from pre-execution check.
    /// </summary>
    /// <remarks>
    /// Set by AgentService after calling ITool.Validate().
    /// </remarks>
    public ToolValidationResult? ValidationResult { get; init; }

    /// <summary>
    /// Whether this request passed validation.
    /// </summary>
    /// <remarks>
    /// True if no validation has been performed yet, or if validation passed.
    /// </remarks>
    public bool IsValid => ValidationResult?.IsValid ?? true;

    /// <summary>
    /// Validation error messages if validation failed.
    /// </summary>
    public IEnumerable<string> ValidationErrors =>
        ValidationResult?.Errors ?? Enumerable.Empty<string>();

    #endregion

    #region Risk Assessment

    /// <summary>
    /// Risk level for this specific invocation.
    /// </summary>
    /// <remarks>
    /// <para>
    /// May differ from the tool's default risk level based on parameters.
    /// For example:
    /// </para>
    /// <list type="bullet">
    /// <item>file-write to /tmp is lower risk than to /src</item>
    /// <item>terminal-execute for "ls" is lower risk than "rm -rf"</item>
    /// </list>
    /// </remarks>
    public RiskLevel RiskLevel { get; init; }

    /// <summary>
    /// Human-readable summary of what this call will do.
    /// </summary>
    /// <remarks>
    /// Used as the primary text in approval dialogs.
    /// Should be clear and specific.
    /// </remarks>
    public string ExecutionSummary { get; init; } = string.Empty;

    /// <summary>
    /// Warning messages for user consideration.
    /// </summary>
    /// <remarks>
    /// Displayed in approval dialogs for high-risk operations.
    /// </remarks>
    public IReadOnlyList<string>? Warnings { get; init; }

    /// <summary>
    /// Whether this call requires user approval.
    /// </summary>
    /// <remarks>
    /// Determined by risk level and user preferences.
    /// </remarks>
    public bool RequiresApproval { get; init; }

    #endregion

    #region Timestamps

    /// <summary>
    /// When this request was parsed.
    /// </summary>
    public DateTime RequestedAt { get; init; } = DateTime.UtcNow;

    #endregion

    #region Computed Properties

    /// <summary>
    /// Time since this request was created.
    /// </summary>
    public TimeSpan Age => DateTime.UtcNow - RequestedAt;

    /// <summary>
    /// Get a specific parameter value.
    /// </summary>
    public T? GetParameter<T>(string name)
    {
        if (Parameters.TryGetProperty(name, out var prop))
        {
            return JsonSerializer.Deserialize<T>(prop.GetRawText());
        }
        return default;
    }

    /// <summary>
    /// Check if a parameter exists.
    /// </summary>
    public bool HasParameter(string name) =>
        Parameters.ValueKind == JsonValueKind.Object &&
        Parameters.TryGetProperty(name, out _);

    /// <summary>
    /// Get parameter names.
    /// </summary>
    public IEnumerable<string> ParameterNames =>
        Parameters.ValueKind == JsonValueKind.Object
            ? Parameters.EnumerateObject().Select(p => p.Name)
            : Enumerable.Empty<string>();

    #endregion

    #region Factory Methods

    /// <summary>
    /// Create a request with basic information.
    /// </summary>
    public static ToolCallRequest Create(
        string toolId,
        string toolName,
        JsonElement parameters,
        int iteration,
        RiskLevel riskLevel = RiskLevel.Safe) => new()
    {
        ToolId = toolId,
        ToolName = toolName,
        Parameters = parameters,
        IterationNumber = iteration,
        RiskLevel = riskLevel,
        ExecutionSummary = $"Execute {toolName}"
    };

    #endregion

    /// <summary>
    /// Create a copy with validation result.
    /// </summary>
    public ToolCallRequest WithValidation(ToolValidationResult result) => new()
    {
        Id = Id,
        ToolId = ToolId,
        ToolName = ToolName,
        IterationNumber = IterationNumber,
        Parameters = Parameters,
        RawJson = RawJson,
        ValidationResult = result,
        RiskLevel = RiskLevel,
        ExecutionSummary = ExecutionSummary,
        Warnings = Warnings,
        RequiresApproval = RequiresApproval,
        RequestedAt = RequestedAt
    };

    /// <summary>
    /// Create a copy with modified parameters.
    /// </summary>
    public ToolCallRequest WithParameters(JsonElement parameters) => new()
    {
        Id = Id,
        ToolId = ToolId,
        ToolName = ToolName,
        IterationNumber = IterationNumber,
        Parameters = parameters,
        RawJson = RawJson,
        ValidationResult = null, // Re-validation needed
        RiskLevel = RiskLevel,
        ExecutionSummary = ExecutionSummary,
        Warnings = Warnings,
        RequiresApproval = RequiresApproval,
        RequestedAt = RequestedAt
    };

    /// <inheritdoc />
    public override string ToString() =>
        $"ToolCallRequest({ToolName}, Id={Id:N8}, Risk={RiskLevel})";
}
```

### 2. ApprovalDecision.cs

**Location**: `src/SeniorIntern.Core/Models/ApprovalDecision.cs`

```csharp
namespace SeniorIntern.Core.Models;

using System.Text.Json;

/// <summary>
/// User's decision on a tool approval request.
/// </summary>
/// <remarks>
/// <para>
/// ApprovalDecision captures the user's response to a tool approval prompt:
/// </para>
/// <list type="bullet">
/// <item>Approval or denial</item>
/// <item>Optional parameter modifications</item>
/// <item>Remember options for future calls</item>
/// </list>
/// <para>
/// The "remember" options create ToolPermission entries for the session or permanently.
/// </para>
/// </remarks>
public sealed class ApprovalDecision
{
    #region Core Decision

    /// <summary>
    /// Whether the tool call was approved.
    /// </summary>
    public bool Approved { get; init; }

    /// <summary>
    /// Whether the tool call was denied.
    /// </summary>
    public bool Denied => !Approved;

    /// <summary>
    /// Reason for denial (if not approved).
    /// </summary>
    /// <remarks>
    /// Provided to the LLM so it can adapt its approach.
    /// </remarks>
    public string? Reason { get; init; }

    #endregion

    #region Parameter Modifications

    /// <summary>
    /// Modified parameters if user edited them.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Some approval UIs allow the user to modify parameters before execution.
    /// For example, changing a file path or adjusting command arguments.
    /// </para>
    /// <para>
    /// If set, these parameters replace the original request parameters.
    /// </para>
    /// </remarks>
    public JsonElement? ModifiedParameters { get; init; }

    /// <summary>
    /// Whether the user modified the parameters.
    /// </summary>
    public bool ParametersModified => ModifiedParameters.HasValue;

    #endregion

    #region Remember Options

    /// <summary>
    /// Whether to remember this decision for the session.
    /// </summary>
    /// <remarks>
    /// Creates a session-scoped ToolPermission that auto-approves
    /// future calls to this tool with similar parameters.
    /// </remarks>
    public bool RememberForSession { get; init; }

    /// <summary>
    /// Whether to remember this decision for this tool globally.
    /// </summary>
    /// <remarks>
    /// Creates a persistent ToolPermission saved to settings.
    /// </remarks>
    public bool RememberForTool { get; init; }

    /// <summary>
    /// Pattern for remembering (e.g., specific path patterns).
    /// </summary>
    /// <remarks>
    /// <para>
    /// Allows granular approval patterns:
    /// </para>
    /// <list type="bullet">
    /// <item>"src/**/*.cs" - approve file writes to C# files in src</item>
    /// <item>"npm *" - approve npm commands</item>
    /// </list>
    /// <para>
    /// When null, remembers the exact tool, not a pattern.
    /// </para>
    /// </remarks>
    public string? RememberPattern { get; init; }

    /// <summary>
    /// Whether any remember option is set.
    /// </summary>
    public bool ShouldRemember => RememberForSession || RememberForTool;

    #endregion

    #region Timing

    /// <summary>
    /// When the decision was made.
    /// </summary>
    public DateTime DecidedAt { get; init; } = DateTime.UtcNow;

    /// <summary>
    /// How long the user took to decide.
    /// </summary>
    /// <remarks>
    /// Useful for UX analytics and timeout handling.
    /// </remarks>
    public TimeSpan DecisionDuration { get; init; }

    #endregion

    #region Factory Methods

    /// <summary>
    /// Creates an approval decision.
    /// </summary>
    /// <param name="rememberForSession">Remember for this session.</param>
    /// <param name="rememberForTool">Remember permanently for this tool.</param>
    /// <param name="rememberPattern">Pattern for remembered approval.</param>
    public static ApprovalDecision Approve(
        bool rememberForSession = false,
        bool rememberForTool = false,
        string? rememberPattern = null) => new()
    {
        Approved = true,
        RememberForSession = rememberForSession,
        RememberForTool = rememberForTool,
        RememberPattern = rememberPattern
    };

    /// <summary>
    /// Creates an approval with modified parameters.
    /// </summary>
    public static ApprovalDecision ApproveWithModifications(
        JsonElement modifiedParameters,
        bool rememberForSession = false) => new()
    {
        Approved = true,
        ModifiedParameters = modifiedParameters,
        RememberForSession = rememberForSession
    };

    /// <summary>
    /// Creates a denial decision.
    /// </summary>
    /// <param name="reason">Reason for denial.</param>
    public static ApprovalDecision Deny(string? reason = null) => new()
    {
        Approved = false,
        Reason = reason
    };

    /// <summary>
    /// Creates a timeout denial (user didn't respond in time).
    /// </summary>
    public static ApprovalDecision Timeout() => new()
    {
        Approved = false,
        Reason = "Approval request timed out"
    };

    /// <summary>
    /// Creates a cancellation denial (request was cancelled).
    /// </summary>
    public static ApprovalDecision Cancelled() => new()
    {
        Approved = false,
        Reason = "Request was cancelled"
    };

    #endregion

    /// <inheritdoc />
    public override string ToString() =>
        Approved
            ? $"Approved{(ShouldRemember ? " (remembered)" : "")}"
            : $"Denied: {Reason ?? "no reason"}";
}
```

### 3. ToolCallLifecycle.cs

**Location**: `src/SeniorIntern.Core/Models/ToolCallLifecycle.cs`

```csharp
namespace SeniorIntern.Core.Models;

using SeniorIntern.Core.Tools;

/// <summary>
/// Tracks the full lifecycle of a tool call from request to completion.
/// </summary>
/// <remarks>
/// <para>
/// ToolCallLifecycle is a mutable tracking object that follows a tool call
/// through all stages of processing:
/// </para>
/// <list type="bullet">
/// <item>Parsing and validation</item>
/// <item>Approval (if required)</item>
/// <item>Execution</item>
/// <item>Result handling</item>
/// </list>
/// <para>
/// Used by AgentService to track concurrent tool calls and generate events.
/// </para>
/// </remarks>
public sealed class ToolCallLifecycle
{
    #region Core Properties

    /// <summary>
    /// The original request.
    /// </summary>
    public ToolCallRequest Request { get; init; } = null!;

    /// <summary>
    /// Current status in the lifecycle.
    /// </summary>
    public ToolCallStatus Status { get; set; } = ToolCallStatus.Parsed;

    /// <summary>
    /// Lifecycle ID (delegates to Request.Id).
    /// </summary>
    public Guid Id => Request.Id;

    /// <summary>
    /// Tool ID (delegates to Request.ToolId).
    /// </summary>
    public string ToolId => Request.ToolId;

    #endregion

    #region Approval

    /// <summary>
    /// Approval decision if required.
    /// </summary>
    /// <remarks>
    /// Null if approval not required or not yet decided.
    /// </remarks>
    public ApprovalDecision? ApprovalDecision { get; set; }

    /// <summary>
    /// Whether approval was required for this call.
    /// </summary>
    public bool ApprovalRequired { get; set; }

    /// <summary>
    /// Whether the call was auto-approved.
    /// </summary>
    public bool WasAutoApproved => !ApprovalRequired && IsApproved;

    /// <summary>
    /// Whether the call is approved (auto or explicit).
    /// </summary>
    public bool IsApproved => ApprovalDecision?.Approved ?? !ApprovalRequired;

    /// <summary>
    /// Whether the call was denied.
    /// </summary>
    public bool WasDenied => ApprovalDecision?.Denied ?? false;

    #endregion

    #region Execution

    /// <summary>
    /// Execution result.
    /// </summary>
    public ToolResult? Result { get; set; }

    /// <summary>
    /// When validation started.
    /// </summary>
    public DateTime? ValidationStarted { get; set; }

    /// <summary>
    /// When approval was requested.
    /// </summary>
    public DateTime? ApprovalRequested { get; set; }

    /// <summary>
    /// When execution started.
    /// </summary>
    public DateTime? ExecutionStarted { get; set; }

    /// <summary>
    /// When execution completed.
    /// </summary>
    public DateTime? ExecutionCompleted { get; set; }

    /// <summary>
    /// Time spent waiting for approval.
    /// </summary>
    public TimeSpan? ApprovalWaitTime =>
        ApprovalRequested.HasValue && ApprovalDecision != null
            ? ApprovalDecision.DecidedAt - ApprovalRequested
            : null;

    /// <summary>
    /// Execution duration.
    /// </summary>
    public TimeSpan? Duration =>
        ExecutionStarted.HasValue && ExecutionCompleted.HasValue
            ? ExecutionCompleted - ExecutionStarted
            : null;

    /// <summary>
    /// Total lifecycle duration from request to completion.
    /// </summary>
    public TimeSpan TotalDuration => DateTime.UtcNow - Request.RequestedAt;

    #endregion

    #region Error Handling

    /// <summary>
    /// Error message if failed.
    /// </summary>
    public string? ErrorMessage { get; set; }

    /// <summary>
    /// Exception that caused failure.
    /// </summary>
    public Exception? Exception { get; set; }

    /// <summary>
    /// Whether this lifecycle ended in failure.
    /// </summary>
    public bool Failed => Status is ToolCallStatus.Failed or
        ToolCallStatus.ValidationFailed or ToolCallStatus.TimedOut;

    /// <summary>
    /// Whether this lifecycle completed successfully.
    /// </summary>
    public bool Succeeded => Status == ToolCallStatus.Completed && Result?.Success == true;

    #endregion

    #region State Queries

    /// <summary>
    /// Whether this lifecycle is in a terminal state.
    /// </summary>
    public bool IsTerminal => Status is ToolCallStatus.Completed or
        ToolCallStatus.Failed or ToolCallStatus.Cancelled or
        ToolCallStatus.ValidationFailed or ToolCallStatus.Denied or
        ToolCallStatus.TimedOut;

    /// <summary>
    /// Whether this lifecycle is waiting for something.
    /// </summary>
    public bool IsWaiting => Status == ToolCallStatus.AwaitingApproval;

    /// <summary>
    /// Whether this lifecycle is actively processing.
    /// </summary>
    public bool IsActive => Status is ToolCallStatus.Validating or
        ToolCallStatus.Executing;

    #endregion

    #region Lifecycle Methods

    /// <summary>
    /// Mark as validating.
    /// </summary>
    public void StartValidation()
    {
        Status = ToolCallStatus.Validating;
        ValidationStarted = DateTime.UtcNow;
    }

    /// <summary>
    /// Mark validation as failed.
    /// </summary>
    public void FailValidation(string error)
    {
        Status = ToolCallStatus.ValidationFailed;
        ErrorMessage = error;
    }

    /// <summary>
    /// Mark as awaiting approval.
    /// </summary>
    public void RequestApproval()
    {
        Status = ToolCallStatus.AwaitingApproval;
        ApprovalRequired = true;
        ApprovalRequested = DateTime.UtcNow;
    }

    /// <summary>
    /// Mark as approved.
    /// </summary>
    public void Approve(ApprovalDecision decision)
    {
        Status = ToolCallStatus.Approved;
        ApprovalDecision = decision;
    }

    /// <summary>
    /// Mark as denied.
    /// </summary>
    public void Deny(ApprovalDecision decision)
    {
        Status = ToolCallStatus.Denied;
        ApprovalDecision = decision;
    }

    /// <summary>
    /// Mark as executing.
    /// </summary>
    public void StartExecution()
    {
        Status = ToolCallStatus.Executing;
        ExecutionStarted = DateTime.UtcNow;
    }

    /// <summary>
    /// Mark as completed.
    /// </summary>
    public void Complete(ToolResult result)
    {
        Status = ToolCallStatus.Completed;
        ExecutionCompleted = DateTime.UtcNow;
        Result = result;
    }

    /// <summary>
    /// Mark as failed.
    /// </summary>
    public void Fail(string error, Exception? exception = null)
    {
        Status = ToolCallStatus.Failed;
        ExecutionCompleted = DateTime.UtcNow;
        ErrorMessage = error;
        Exception = exception;
    }

    /// <summary>
    /// Mark as timed out.
    /// </summary>
    public void Timeout()
    {
        Status = ToolCallStatus.TimedOut;
        ExecutionCompleted = DateTime.UtcNow;
        ErrorMessage = "Tool execution timed out";
    }

    /// <summary>
    /// Mark as cancelled.
    /// </summary>
    public void Cancel()
    {
        Status = ToolCallStatus.Cancelled;
        ExecutionCompleted = DateTime.UtcNow;
        ErrorMessage = "Tool execution was cancelled";
    }

    #endregion

    /// <summary>
    /// Create a lifecycle for a request.
    /// </summary>
    public static ToolCallLifecycle ForRequest(ToolCallRequest request) => new()
    {
        Request = request
    };

    /// <inheritdoc />
    public override string ToString() =>
        $"ToolCallLifecycle({Request.ToolName}, Status={Status}, Duration={Duration?.TotalMilliseconds:F0}ms)";
}

/// <summary>
/// Status of a tool call in its lifecycle.
/// </summary>
public enum ToolCallStatus
{
    /// <summary>Tool call was parsed from LLM output.</summary>
    Parsed,

    /// <summary>Parameters are being validated.</summary>
    Validating,

    /// <summary>Parameter validation failed.</summary>
    ValidationFailed,

    /// <summary>Waiting for user approval.</summary>
    AwaitingApproval,

    /// <summary>User approved the call.</summary>
    Approved,

    /// <summary>User denied the call.</summary>
    Denied,

    /// <summary>Tool is executing.</summary>
    Executing,

    /// <summary>Tool completed successfully.</summary>
    Completed,

    /// <summary>Tool execution failed.</summary>
    Failed,

    /// <summary>Request was cancelled.</summary>
    Cancelled,

    /// <summary>Tool execution timed out.</summary>
    TimedOut
}
```

### 4. ToolCallBatch.cs

**Location**: `src/SeniorIntern.Core/Models/ToolCallBatch.cs`

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Represents a batch of tool calls from a single LLM response.
/// </summary>
/// <remarks>
/// <para>
/// When an LLM requests multiple tools in one response, they are grouped
/// in a ToolCallBatch for coordinated processing.
/// </para>
/// <para>
/// Parallel execution is controlled by configuration (MaxParallelToolCalls).
/// </para>
/// </remarks>
public sealed class ToolCallBatch
{
    /// <summary>
    /// Unique identifier for this batch.
    /// </summary>
    public Guid BatchId { get; init; } = Guid.NewGuid();

    /// <summary>
    /// Tool calls in this batch.
    /// </summary>
    public IReadOnlyList<ToolCallRequest> Calls { get; init; } = Array.Empty<ToolCallRequest>();

    /// <summary>
    /// Iteration number when this batch was created.
    /// </summary>
    public int IterationNumber { get; init; }

    /// <summary>
    /// Whether to execute calls in parallel.
    /// </summary>
    public bool IsParallel { get; init; }

    /// <summary>
    /// Lifecycles for each call, keyed by request ID.
    /// </summary>
    public Dictionary<Guid, ToolCallLifecycle> Lifecycles { get; } = new();

    /// <summary>
    /// When this batch was created.
    /// </summary>
    public DateTime CreatedAt { get; init; } = DateTime.UtcNow;

    /// <summary>
    /// When this batch completed processing.
    /// </summary>
    public DateTime? CompletedAt { get; set; }

    #region Computed Properties

    /// <summary>
    /// Number of calls in the batch.
    /// </summary>
    public int Count => Calls.Count;

    /// <summary>
    /// Whether this is a single-call batch.
    /// </summary>
    public bool IsSingleCall => Count == 1;

    /// <summary>
    /// Whether all calls have completed (success or failure).
    /// </summary>
    public bool AllCompleted => Lifecycles.Values.All(l => l.IsTerminal);

    /// <summary>
    /// Whether any calls are still pending.
    /// </summary>
    public bool HasPending => Lifecycles.Values.Any(l => !l.IsTerminal);

    /// <summary>
    /// Number of successful calls.
    /// </summary>
    public int SuccessCount => Lifecycles.Values.Count(l => l.Succeeded);

    /// <summary>
    /// Number of failed calls.
    /// </summary>
    public int FailureCount => Lifecycles.Values.Count(l => l.Failed);

    /// <summary>
    /// All results from completed calls.
    /// </summary>
    public IEnumerable<ToolResult> Results =>
        Lifecycles.Values
            .Where(l => l.Result != null)
            .Select(l => l.Result!);

    /// <summary>
    /// Total execution time for the batch.
    /// </summary>
    public TimeSpan? TotalDuration =>
        CompletedAt.HasValue
            ? CompletedAt - CreatedAt
            : null;

    #endregion

    #region Methods

    /// <summary>
    /// Initialize lifecycles for all calls.
    /// </summary>
    public void InitializeLifecycles()
    {
        foreach (var call in Calls)
        {
            Lifecycles[call.Id] = ToolCallLifecycle.ForRequest(call);
        }
    }

    /// <summary>
    /// Get lifecycle for a specific call.
    /// </summary>
    public ToolCallLifecycle? GetLifecycle(Guid requestId) =>
        Lifecycles.GetValueOrDefault(requestId);

    /// <summary>
    /// Get lifecycle for a specific call.
    /// </summary>
    public ToolCallLifecycle? GetLifecycle(ToolCallRequest request) =>
        GetLifecycle(request.Id);

    /// <summary>
    /// Mark batch as complete.
    /// </summary>
    public void Complete()
    {
        CompletedAt = DateTime.UtcNow;
    }

    #endregion

    #region Factory Methods

    /// <summary>
    /// Create a batch from a single call.
    /// </summary>
    public static ToolCallBatch Single(ToolCallRequest request, int iteration) =>
        new()
        {
            Calls = new[] { request },
            IterationNumber = iteration,
            IsParallel = false
        };

    /// <summary>
    /// Create a batch from multiple calls.
    /// </summary>
    public static ToolCallBatch Multiple(
        IEnumerable<ToolCallRequest> requests,
        int iteration,
        bool parallel = true) =>
        new()
        {
            Calls = requests.ToList(),
            IterationNumber = iteration,
            IsParallel = parallel
        };

    #endregion

    /// <inheritdoc />
    public override string ToString() =>
        $"ToolCallBatch({Count} calls, Parallel={IsParallel}, Completed={AllCompleted})";
}
```

### 5. ToolCallRequestBuilder.cs

**Location**: `src/SeniorIntern.Core/Models/ToolCallRequestBuilder.cs`

```csharp
namespace SeniorIntern.Core.Models;

using System.Text.Json;
using SeniorIntern.Core.Tools;

/// <summary>
/// Fluent builder for constructing ToolCallRequest instances.
/// </summary>
public sealed class ToolCallRequestBuilder
{
    private Guid _id = Guid.NewGuid();
    private string _toolId = string.Empty;
    private string _toolName = string.Empty;
    private JsonElement _parameters = default;
    private string? _rawJson;
    private int _iterationNumber;
    private RiskLevel _riskLevel = RiskLevel.Safe;
    private string _executionSummary = string.Empty;
    private List<string>? _warnings;
    private bool _requiresApproval;
    private ToolValidationResult? _validationResult;

    private ToolCallRequestBuilder() { }

    /// <summary>
    /// Create a new builder.
    /// </summary>
    public static ToolCallRequestBuilder Create() => new();

    /// <summary>
    /// Set the tool ID.
    /// </summary>
    public ToolCallRequestBuilder WithToolId(string toolId)
    {
        _toolId = toolId;
        return this;
    }

    /// <summary>
    /// Set the tool name.
    /// </summary>
    public ToolCallRequestBuilder WithToolName(string toolName)
    {
        _toolName = toolName;
        return this;
    }

    /// <summary>
    /// Set the tool (ID and name from ITool).
    /// </summary>
    public ToolCallRequestBuilder WithTool(ITool tool)
    {
        _toolId = tool.Id;
        _toolName = tool.Name;
        _riskLevel = tool.DefaultRiskLevel;
        return this;
    }

    /// <summary>
    /// Set the parameters.
    /// </summary>
    public ToolCallRequestBuilder WithParameters(JsonElement parameters)
    {
        _parameters = parameters;
        return this;
    }

    /// <summary>
    /// Set the parameters from an object.
    /// </summary>
    public ToolCallRequestBuilder WithParameters<T>(T parameters) where T : class
    {
        var json = JsonSerializer.Serialize(parameters);
        _parameters = JsonDocument.Parse(json).RootElement.Clone();
        return this;
    }

    /// <summary>
    /// Set the raw JSON.
    /// </summary>
    public ToolCallRequestBuilder WithRawJson(string rawJson)
    {
        _rawJson = rawJson;
        return this;
    }

    /// <summary>
    /// Set the iteration number.
    /// </summary>
    public ToolCallRequestBuilder WithIteration(int iteration)
    {
        _iterationNumber = iteration;
        return this;
    }

    /// <summary>
    /// Set the risk level.
    /// </summary>
    public ToolCallRequestBuilder WithRiskLevel(RiskLevel riskLevel)
    {
        _riskLevel = riskLevel;
        return this;
    }

    /// <summary>
    /// Set the execution summary.
    /// </summary>
    public ToolCallRequestBuilder WithSummary(string summary)
    {
        _executionSummary = summary;
        return this;
    }

    /// <summary>
    /// Add a warning.
    /// </summary>
    public ToolCallRequestBuilder WithWarning(string warning)
    {
        _warnings ??= new List<string>();
        _warnings.Add(warning);
        return this;
    }

    /// <summary>
    /// Set whether approval is required.
    /// </summary>
    public ToolCallRequestBuilder RequiresApproval(bool required = true)
    {
        _requiresApproval = required;
        return this;
    }

    /// <summary>
    /// Set the validation result.
    /// </summary>
    public ToolCallRequestBuilder WithValidation(ToolValidationResult result)
    {
        _validationResult = result;
        return this;
    }

    /// <summary>
    /// Build the ToolCallRequest.
    /// </summary>
    public ToolCallRequest Build() => new()
    {
        Id = _id,
        ToolId = _toolId,
        ToolName = _toolName,
        Parameters = _parameters,
        RawJson = _rawJson,
        IterationNumber = _iterationNumber,
        RiskLevel = _riskLevel,
        ExecutionSummary = _executionSummary.Length > 0 ? _executionSummary : $"Execute {_toolName}",
        Warnings = _warnings,
        RequiresApproval = _requiresApproval,
        ValidationResult = _validationResult
    };

    /// <summary>
    /// Implicit conversion to ToolCallRequest.
    /// </summary>
    public static implicit operator ToolCallRequest(ToolCallRequestBuilder builder) =>
        builder.Build();
}
```

---

## File Summary

| File | Location | Purpose | Lines |
|------|----------|---------|-------|
| `ToolCallRequest.cs` | `Core/Models/` | Parsed tool call representation | ~200 |
| `ApprovalDecision.cs` | `Core/Models/` | User approval response | ~140 |
| `ToolCallLifecycle.cs` | `Core/Models/` | Lifecycle tracking with status | ~220 |
| `ToolCallBatch.cs` | `Core/Models/` | Batch of parallel calls | ~130 |
| `ToolCallRequestBuilder.cs` | `Core/Models/` | Fluent construction | ~120 |
| `ToolCallStatus.cs` | (in Lifecycle) | Status enumeration | ~25 |

---

## Unit Test Plan

| Test | Description |
|------|-------------|
| `ToolCallRequest_Create_HasUniqueId` | ID generation |
| `ToolCallRequest_GetParameter_ReturnsValue` | Parameter access |
| `ToolCallRequest_WithValidation_PreservesOther` | Immutable update |
| `ApprovalDecision_Approve_SetsApprovedTrue` | Approval factory |
| `ApprovalDecision_Deny_SetsReasonCorrectly` | Denial factory |
| `ApprovalDecision_Timeout_HasCorrectReason` | Timeout handling |
| `ToolCallLifecycle_StartExecution_SetsTimestamp` | Timing |
| `ToolCallLifecycle_Complete_SetsResult` | Completion |
| `ToolCallLifecycle_Duration_CalculatesCorrectly` | Duration calc |
| `ToolCallLifecycle_IsTerminal_CorrectForStatuses` | Terminal check |
| `ToolCallBatch_AllCompleted_TrueWhenAllTerminal` | Batch completion |
| `ToolCallBatch_SuccessCount_CountsCorrectly` | Success counting |
| `ToolCallRequestBuilder_Build_CreatesValidRequest` | Builder test |

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | ToolCallRequest captures all parsed data |
| AC-2 | ApprovalDecision supports remember options |
| AC-3 | ToolCallLifecycle tracks full request lifecycle |
| AC-4 | ToolCallStatus enum covers all possible states |
| AC-5 | ToolCallBatch supports parallel execution tracking |
| AC-6 | Builder creates valid requests |
| AC-7 | Duration calculations are correct |

---

## Changelog Entry

```markdown
## v0.6.2f - Tool Call Request Models

### Added
- `ToolCallRequest` for parsed tool calls with parameters and risk assessment
- `ApprovalDecision` with approval/denial and remember options
- `ToolCallLifecycle` for tracking calls from request to completion
- `ToolCallStatus` enum with 11 lifecycle states
- `ToolCallBatch` for parallel tool call tracking
- `ToolCallRequestBuilder` for fluent request construction
- Parameter access helpers (`GetParameter<T>`, `HasParameter`)
- Lifecycle state transition methods (`StartExecution`, `Complete`, etc.)
```

---

## Timeline Estimate

| Version | Estimated Effort |
|---------|------------------|
| v0.6.2f | 0.5 day |
