# Design Specification: AIntern v0.6.1 "Tool Framework"

## Executive Summary

This document provides a comprehensive design specification for v0.6.1, which establishes the foundational tool framework for The Senior Intern's agentic capabilities. This sub-version delivers the core abstractions that enable AI-driven tool execution: a flexible tool interface, robust registry system, standardized JSON schema definitions for parameter validation, comprehensive result handling, and the execution context infrastructure. This framework forms the backbone upon which all subsequent tool integrations (file operations, terminal commands, search, etc.) will be built.

### v0.6.1 Scope (from v0.6.0 Design Document)
- Core tool abstraction with ITool interface
- Tool registry for managing available tools
- JSON schema definitions for tool parameters
- Tool result handling with success/failure states
- Tool execution context with service access
- Tool validation before execution
- Tool categories and risk levels for classification

---

## Sub-Part Breakdown

| Part | Name | Focus |
|------|------|-------|
| v0.6.1a | Tool Core Models | ITool interface, ToolCategory, RiskLevel enums |
| v0.6.1b | Tool Execution Context | Execution context, progress reporting, cancellation |
| v0.6.1c | Tool Result System | ToolResult, ToolArtifact, success/failure handling |
| v0.6.1d | Tool Validation | ToolValidationResult, parameter validation, error reporting |
| v0.6.1e | JSON Schema System | JsonSchema, JsonSchemaBuilder, schema types |
| v0.6.1f | Tool Base Class | ToolBase abstract class, helper methods |
| v0.6.1g | Tool Registry Interface | IToolRegistry, availability context, function definitions |
| v0.6.1h | Tool Registry Implementation | ToolRegistry service, registration, event handling |
| v0.6.1i | Tool Execution Service | IToolExecutionService, execution pipeline, timeout handling |
| v0.6.1j | Testing Infrastructure | Unit tests, integration tests, mock tools |

---

## v0.6.1a: Tool Core Models

### Objective
Define the core interfaces and enumerations that establish the contract for all tools in the system. This includes the primary ITool interface, tool categorization, and risk classification.

### ITool Interface

```csharp
namespace SeniorIntern.Core.Tools;

/// <summary>
/// Base interface for all tools that can be invoked by the AI agent.
/// Tools represent discrete actions the AI can request to perform.
/// </summary>
public interface ITool
{
    /// <summary>
    /// Unique identifier for this tool. Used for registration and lookup.
    /// Should be lowercase with hyphens (e.g., "file-read", "terminal-execute").
    /// </summary>
    string Id { get; }

    /// <summary>
    /// Human-readable display name for the tool.
    /// Shown in UI and logs (e.g., "Read File", "Execute Command").
    /// </summary>
    string Name { get; }

    /// <summary>
    /// Detailed description for the LLM to understand when to use this tool.
    /// Should clearly explain the tool's purpose, capabilities, and limitations.
    /// </summary>
    string Description { get; }

    /// <summary>
    /// Category for UI grouping and filtering.
    /// </summary>
    ToolCategory Category { get; }

    /// <summary>
    /// Default risk level for permission management.
    /// May be elevated based on specific parameter values.
    /// </summary>
    RiskLevel DefaultRiskLevel { get; }

    /// <summary>
    /// JSON Schema defining the expected input parameters.
    /// Used for validation and LLM function calling format.
    /// </summary>
    JsonSchema InputSchema { get; }

    /// <summary>
    /// Whether this tool is currently available for use.
    /// May be false if dependencies are not met (e.g., no workspace open).
    /// </summary>
    bool IsAvailable { get; }

    /// <summary>
    /// Optional list of tags for additional categorization and search.
    /// </summary>
    IReadOnlyList<string> Tags { get; }

    /// <summary>
    /// Execute the tool with the given context.
    /// </summary>
    /// <param name="context">Execution context with parameters and services</param>
    /// <param name="ct">Cancellation token</param>
    /// <returns>Result of the tool execution</returns>
    Task<ToolResult> ExecuteAsync(
        ToolExecutionContext context,
        CancellationToken ct = default);

    /// <summary>
    /// Validate parameters before execution.
    /// Called before requesting approval to catch obvious errors early.
    /// </summary>
    /// <param name="parameters">Parameters to validate</param>
    /// <returns>Validation result with any errors</returns>
    ToolValidationResult Validate(JsonElement parameters);

    /// <summary>
    /// Get a human-readable description of what this specific invocation will do.
    /// Used in approval dialogs to explain the action to the user.
    /// </summary>
    /// <param name="parameters">The parameters for this invocation</param>
    /// <returns>Summary like "Read file 'src/Program.cs'"</returns>
    string GetExecutionSummary(JsonElement parameters);

    /// <summary>
    /// Calculate the effective risk level for a specific invocation.
    /// May be higher than DefaultRiskLevel based on parameters.
    /// </summary>
    /// <param name="parameters">The parameters for this invocation</param>
    /// <returns>Effective risk level</returns>
    RiskLevel GetEffectiveRiskLevel(JsonElement parameters);
}
```

### ToolCategory Enum

```csharp
namespace SeniorIntern.Core.Tools;

/// <summary>
/// Categories for grouping tools in the UI and filtering.
/// </summary>
public enum ToolCategory
{
    /// <summary>
    /// File system operations: read, write, delete, move, copy
    /// </summary>
    FileSystem,

    /// <summary>
    /// Terminal/shell operations: execute commands, scripts
    /// </summary>
    Terminal,

    /// <summary>
    /// Code and content search: grep, find, regex search
    /// </summary>
    Search,

    /// <summary>
    /// Workspace operations: project structure, dependencies
    /// </summary>
    Workspace,

    /// <summary>
    /// Editor operations: navigate, refactor, format
    /// </summary>
    Editor,

    /// <summary>
    /// Git operations: status, commit, push, branch
    /// </summary>
    Git,

    /// <summary>
    /// Network operations: HTTP requests, API calls
    /// </summary>
    Network,

    /// <summary>
    /// System operations: environment, processes
    /// </summary>
    System,

    /// <summary>
    /// User-defined or plugin tools
    /// </summary>
    Custom
}
```

### RiskLevel Enum

```csharp
namespace SeniorIntern.Core.Tools;

/// <summary>
/// Risk classification for tool operations.
/// Determines approval requirements and UI treatment.
/// </summary>
public enum RiskLevel
{
    /// <summary>
    /// Read-only operations with no side effects.
    /// Auto-approved by default.
    /// Examples: reading files, searching content, listing directories.
    /// </summary>
    Safe = 0,

    /// <summary>
    /// May modify files but changes are easily reversible.
    /// Auto-approved by default, but logged.
    /// Examples: creating files, minor edits, git add.
    /// </summary>
    Low = 1,

    /// <summary>
    /// Significant changes that require attention.
    /// Requires user approval by default.
    /// Examples: bulk file modifications, package installs, git commits.
    /// </summary>
    Medium = 2,

    /// <summary>
    /// Potentially destructive or difficult to reverse.
    /// Always requires explicit approval.
    /// Examples: deleting files, force push, dropping databases.
    /// </summary>
    High = 3,

    /// <summary>
    /// System-level operations with broad impact.
    /// Always requires explicit approval with warning.
    /// Examples: system commands, credential access, network configs.
    /// </summary>
    Critical = 4
}
```

### ToolCategoryMetadata

```csharp
namespace SeniorIntern.Core.Tools;

/// <summary>
/// Metadata for tool categories used in UI display.
/// </summary>
public static class ToolCategoryMetadata
{
    private static readonly Dictionary<ToolCategory, CategoryInfo> _metadata = new()
    {
        [ToolCategory.FileSystem] = new("File System", "file", "Operations on files and directories"),
        [ToolCategory.Terminal] = new("Terminal", "terminal", "Shell commands and scripts"),
        [ToolCategory.Search] = new("Search", "search", "Find files and content"),
        [ToolCategory.Workspace] = new("Workspace", "folder", "Project and workspace operations"),
        [ToolCategory.Editor] = new("Editor", "edit", "Code editing and navigation"),
        [ToolCategory.Git] = new("Git", "git-branch", "Version control operations"),
        [ToolCategory.Network] = new("Network", "globe", "HTTP and network operations"),
        [ToolCategory.System] = new("System", "settings", "System-level operations"),
        [ToolCategory.Custom] = new("Custom", "puzzle", "User-defined tools")
    };

    public static CategoryInfo GetInfo(ToolCategory category) =>
        _metadata.GetValueOrDefault(category, new("Unknown", "question", "Unknown category"));

    public sealed record CategoryInfo(string DisplayName, string IconName, string Description);
}
```

### RiskLevelMetadata

```csharp
namespace SeniorIntern.Core.Tools;

/// <summary>
/// Metadata for risk levels used in UI display and policy decisions.
/// </summary>
public static class RiskLevelMetadata
{
    private static readonly Dictionary<RiskLevel, RiskInfo> _metadata = new()
    {
        [RiskLevel.Safe] = new(
            "Safe",
            "#22C55E", // Green
            "Read-only operation with no side effects",
            requiresApproval: false,
            showInLog: false),

        [RiskLevel.Low] = new(
            "Low Risk",
            "#3B82F6", // Blue
            "Reversible changes to files",
            requiresApproval: false,
            showInLog: true),

        [RiskLevel.Medium] = new(
            "Medium Risk",
            "#F59E0B", // Amber
            "Significant changes requiring attention",
            requiresApproval: true,
            showInLog: true),

        [RiskLevel.High] = new(
            "High Risk",
            "#EF4444", // Red
            "Potentially destructive operation",
            requiresApproval: true,
            showInLog: true),

        [RiskLevel.Critical] = new(
            "Critical",
            "#DC2626", // Dark Red
            "System-level operation with broad impact",
            requiresApproval: true,
            showInLog: true)
    };

    public static RiskInfo GetInfo(RiskLevel level) =>
        _metadata.GetValueOrDefault(level, _metadata[RiskLevel.Medium]);

    public sealed record RiskInfo(
        string DisplayName,
        string Color,
        string Description,
        bool RequiresApproval,
        bool ShowInLog);
}
```

### Files to Create (v0.6.1a)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Tools/ITool.cs` | Core tool interface |
| `src/SeniorIntern.Core/Tools/ToolCategory.cs` | Category enumeration |
| `src/SeniorIntern.Core/Tools/RiskLevel.cs` | Risk level enumeration |
| `src/SeniorIntern.Core/Tools/ToolCategoryMetadata.cs` | Category display metadata |
| `src/SeniorIntern.Core/Tools/RiskLevelMetadata.cs` | Risk level display metadata |

### Implementation Notes
- Tool IDs should follow kebab-case convention for consistency
- Descriptions should be written with LLM consumption in mind
- Categories can be extended via Custom + Tags for plugin scenarios
- Risk levels map directly to permission policies in v0.6.4

---

## v0.6.1b: Tool Execution Context

### Objective
Define the execution context that provides tools with all necessary information and services during execution, including parameters, workspace context, progress reporting, and cancellation support.

### ToolExecutionContext Model

```csharp
namespace SeniorIntern.Core.Tools;

using System.Text.Json;

/// <summary>
/// Context provided to tools during execution.
/// Contains all information needed to execute the tool.
/// </summary>
public sealed class ToolExecutionContext
{
    /// <summary>
    /// Unique identifier for this specific execution.
    /// Used for logging, auditing, and correlation.
    /// </summary>
    public Guid ExecutionId { get; init; } = Guid.NewGuid();

    /// <summary>
    /// The conversation/agent session this execution belongs to.
    /// </summary>
    public Guid SessionId { get; init; }

    /// <summary>
    /// ID of the tool being executed.
    /// </summary>
    public string ToolId { get; init; } = string.Empty;

    /// <summary>
    /// Current workspace root path (if any).
    /// Tools should resolve relative paths against this.
    /// </summary>
    public string? WorkspacePath { get; init; }

    /// <summary>
    /// Input parameters from the LLM in JSON format.
    /// </summary>
    public JsonElement Parameters { get; init; }

    /// <summary>
    /// Service provider for accessing application services.
    /// </summary>
    public IServiceProvider Services { get; init; } = null!;

    /// <summary>
    /// Cancellation token for the execution.
    /// Tools should check this regularly during long operations.
    /// </summary>
    public CancellationToken CancellationToken { get; init; }

    /// <summary>
    /// Progress reporter for long-running tools.
    /// May be null if progress tracking is not needed.
    /// </summary>
    public IProgress<ToolProgress>? Progress { get; init; }

    /// <summary>
    /// Whether user has explicitly approved this execution.
    /// </summary>
    public bool IsApproved { get; init; }

    /// <summary>
    /// User-modified parameters (if changed during approval).
    /// Takes precedence over Parameters when present.
    /// </summary>
    public JsonElement? ModifiedParameters { get; init; }

    /// <summary>
    /// Additional metadata for this execution.
    /// </summary>
    public IReadOnlyDictionary<string, object>? Metadata { get; init; }

    /// <summary>
    /// Timestamp when execution started.
    /// </summary>
    public DateTime StartedAt { get; init; } = DateTime.UtcNow;

    /// <summary>
    /// Get the effective parameters (modified or original).
    /// </summary>
    public JsonElement EffectiveParameters =>
        ModifiedParameters ?? Parameters;

    /// <summary>
    /// Get a required service from the service provider.
    /// </summary>
    public T GetRequiredService<T>() where T : notnull =>
        Services.GetRequiredService<T>();

    /// <summary>
    /// Get an optional service from the service provider.
    /// </summary>
    public T? GetService<T>() =>
        Services.GetService<T>();

    /// <summary>
    /// Report progress if a progress reporter is available.
    /// </summary>
    public void ReportProgress(string message, double? percentComplete = null)
    {
        Progress?.Report(new ToolProgress
        {
            Message = message,
            PercentComplete = percentComplete,
            CurrentOperation = null
        });
    }

    /// <summary>
    /// Resolve a path relative to the workspace.
    /// </summary>
    /// <param name="relativePath">Path that may be relative</param>
    /// <returns>Absolute path resolved against workspace</returns>
    public string ResolvePath(string relativePath)
    {
        if (Path.IsPathRooted(relativePath))
            return relativePath;

        if (string.IsNullOrEmpty(WorkspacePath))
            throw new InvalidOperationException("Cannot resolve relative path without workspace");

        return Path.GetFullPath(Path.Combine(WorkspacePath, relativePath));
    }

    /// <summary>
    /// Check if a path is within the workspace.
    /// </summary>
    public bool IsPathInWorkspace(string path)
    {
        if (string.IsNullOrEmpty(WorkspacePath))
            return false;

        var fullPath = Path.GetFullPath(path);
        var workspaceFullPath = Path.GetFullPath(WorkspacePath);

        return fullPath.StartsWith(workspaceFullPath, StringComparison.OrdinalIgnoreCase);
    }
}
```

### ToolProgress Model

```csharp
namespace SeniorIntern.Core.Tools;

/// <summary>
/// Progress information for long-running tool executions.
/// </summary>
public sealed class ToolProgress
{
    /// <summary>
    /// Human-readable progress message.
    /// </summary>
    public string Message { get; init; } = string.Empty;

    /// <summary>
    /// Completion percentage (0.0 to 100.0), if known.
    /// </summary>
    public double? PercentComplete { get; init; }

    /// <summary>
    /// Current sub-operation being performed.
    /// </summary>
    public string? CurrentOperation { get; init; }

    /// <summary>
    /// Number of items processed (for batch operations).
    /// </summary>
    public int? ItemsProcessed { get; init; }

    /// <summary>
    /// Total number of items (for batch operations).
    /// </summary>
    public int? TotalItems { get; init; }

    /// <summary>
    /// Estimated time remaining, if calculable.
    /// </summary>
    public TimeSpan? EstimatedRemaining { get; init; }

    /// <summary>
    /// Whether this is an indeterminate progress update.
    /// </summary>
    public bool IsIndeterminate => PercentComplete == null && TotalItems == null;

    /// <summary>
    /// Create a simple message-only progress update.
    /// </summary>
    public static ToolProgress Message(string message) =>
        new() { Message = message };

    /// <summary>
    /// Create a progress update with percentage.
    /// </summary>
    public static ToolProgress WithPercent(string message, double percent) =>
        new() { Message = message, PercentComplete = percent };

    /// <summary>
    /// Create a progress update for item-based processing.
    /// </summary>
    public static ToolProgress Items(string message, int processed, int total) =>
        new()
        {
            Message = message,
            ItemsProcessed = processed,
            TotalItems = total,
            PercentComplete = total > 0 ? (processed * 100.0 / total) : null
        };
}
```

### ToolExecutionContextBuilder

```csharp
namespace SeniorIntern.Core.Tools;

/// <summary>
/// Fluent builder for creating ToolExecutionContext instances.
/// </summary>
public sealed class ToolExecutionContextBuilder
{
    private Guid _executionId = Guid.NewGuid();
    private Guid _sessionId;
    private string _toolId = string.Empty;
    private string? _workspacePath;
    private JsonElement _parameters;
    private IServiceProvider? _services;
    private CancellationToken _cancellationToken;
    private IProgress<ToolProgress>? _progress;
    private bool _isApproved;
    private JsonElement? _modifiedParameters;
    private Dictionary<string, object>? _metadata;

    public static ToolExecutionContextBuilder Create() => new();

    public ToolExecutionContextBuilder WithExecutionId(Guid id)
    {
        _executionId = id;
        return this;
    }

    public ToolExecutionContextBuilder WithSessionId(Guid id)
    {
        _sessionId = id;
        return this;
    }

    public ToolExecutionContextBuilder WithToolId(string toolId)
    {
        _toolId = toolId;
        return this;
    }

    public ToolExecutionContextBuilder WithWorkspace(string? path)
    {
        _workspacePath = path;
        return this;
    }

    public ToolExecutionContextBuilder WithParameters(JsonElement parameters)
    {
        _parameters = parameters;
        return this;
    }

    public ToolExecutionContextBuilder WithParametersFromObject(object obj)
    {
        var json = JsonSerializer.Serialize(obj);
        _parameters = JsonDocument.Parse(json).RootElement.Clone();
        return this;
    }

    public ToolExecutionContextBuilder WithServices(IServiceProvider services)
    {
        _services = services;
        return this;
    }

    public ToolExecutionContextBuilder WithCancellation(CancellationToken ct)
    {
        _cancellationToken = ct;
        return this;
    }

    public ToolExecutionContextBuilder WithProgress(IProgress<ToolProgress> progress)
    {
        _progress = progress;
        return this;
    }

    public ToolExecutionContextBuilder WithApproval(bool approved = true)
    {
        _isApproved = approved;
        return this;
    }

    public ToolExecutionContextBuilder WithModifiedParameters(JsonElement parameters)
    {
        _modifiedParameters = parameters;
        return this;
    }

    public ToolExecutionContextBuilder WithMetadata(string key, object value)
    {
        _metadata ??= new Dictionary<string, object>();
        _metadata[key] = value;
        return this;
    }

    public ToolExecutionContext Build()
    {
        if (_services == null)
            throw new InvalidOperationException("Services must be provided");

        return new ToolExecutionContext
        {
            ExecutionId = _executionId,
            SessionId = _sessionId,
            ToolId = _toolId,
            WorkspacePath = _workspacePath,
            Parameters = _parameters,
            Services = _services,
            CancellationToken = _cancellationToken,
            Progress = _progress,
            IsApproved = _isApproved,
            ModifiedParameters = _modifiedParameters,
            Metadata = _metadata
        };
    }
}
```

### Files to Create (v0.6.1b)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Tools/ToolExecutionContext.cs` | Execution context model |
| `src/SeniorIntern.Core/Tools/ToolProgress.cs` | Progress reporting model |
| `src/SeniorIntern.Core/Tools/ToolExecutionContextBuilder.cs` | Fluent builder |

### Implementation Notes
- Service provider injection allows tools to access any registered service
- Progress reporting is optional to avoid overhead for quick operations
- Path resolution methods help tools work safely within workspace bounds
- Builder pattern provides clean construction for tests and service layer

---

## v0.6.1c: Tool Result System

### Objective
Define the result types that tools return after execution, including success/failure states, artifacts produced, execution metadata, and suggested follow-up actions.

### ToolResult Model

```csharp
namespace SeniorIntern.Core.Tools;

/// <summary>
/// Result of a tool execution.
/// Contains success/failure status, output data, and metadata.
/// </summary>
public sealed class ToolResult
{
    /// <summary>
    /// Whether the tool executed successfully.
    /// </summary>
    public bool Success { get; init; }

    /// <summary>
    /// Result data to return to the LLM.
    /// Serialized to JSON for inclusion in conversation context.
    /// </summary>
    public object? Data { get; init; }

    /// <summary>
    /// Human-readable message about the result.
    /// Displayed in the UI and included in LLM context.
    /// </summary>
    public string Message { get; init; } = string.Empty;

    /// <summary>
    /// Error details if the execution failed.
    /// </summary>
    public string? Error { get; init; }

    /// <summary>
    /// Error code for programmatic error handling.
    /// </summary>
    public string? ErrorCode { get; init; }

    /// <summary>
    /// Exception that caused the failure, if any.
    /// Not serialized to LLM context.
    /// </summary>
    public Exception? Exception { get; init; }

    /// <summary>
    /// Any artifacts produced (files created, modified, etc.).
    /// </summary>
    public IReadOnlyList<ToolArtifact> Artifacts { get; init; } = Array.Empty<ToolArtifact>();

    /// <summary>
    /// Execution duration.
    /// </summary>
    public TimeSpan Duration { get; init; }

    /// <summary>
    /// Suggested follow-up actions or commands.
    /// </summary>
    public IReadOnlyList<string>? SuggestedFollowUps { get; init; }

    /// <summary>
    /// Whether the result should be truncated before sending to LLM.
    /// Set when Data is very large.
    /// </summary>
    public bool ShouldTruncate { get; init; }

    /// <summary>
    /// Maximum length of Data when serialized (for truncation).
    /// </summary>
    public int? MaxDataLength { get; init; }

    /// <summary>
    /// Additional metadata about the execution.
    /// </summary>
    public IReadOnlyDictionary<string, object>? Metadata { get; init; }

    #region Factory Methods

    /// <summary>
    /// Create a successful result.
    /// </summary>
    public static ToolResult Succeeded(object? data = null, string? message = null) =>
        new()
        {
            Success = true,
            Data = data,
            Message = message ?? "Operation completed successfully"
        };

    /// <summary>
    /// Create a successful result with artifacts.
    /// </summary>
    public static ToolResult SucceededWithArtifacts(
        IEnumerable<ToolArtifact> artifacts,
        object? data = null,
        string? message = null) =>
        new()
        {
            Success = true,
            Data = data,
            Message = message ?? "Operation completed successfully",
            Artifacts = artifacts.ToList()
        };

    /// <summary>
    /// Create a failed result.
    /// </summary>
    public static ToolResult Failed(string error, string? errorCode = null, object? partialData = null) =>
        new()
        {
            Success = false,
            Error = error,
            ErrorCode = errorCode,
            Data = partialData,
            Message = error
        };

    /// <summary>
    /// Create a failed result from an exception.
    /// </summary>
    public static ToolResult FromException(Exception ex, string? contextMessage = null) =>
        new()
        {
            Success = false,
            Error = contextMessage != null
                ? $"{contextMessage}: {ex.Message}"
                : ex.Message,
            ErrorCode = ex.GetType().Name,
            Exception = ex,
            Message = contextMessage ?? ex.Message
        };

    /// <summary>
    /// Create a cancelled result.
    /// </summary>
    public static ToolResult Cancelled(string? message = null) =>
        new()
        {
            Success = false,
            Error = "Operation was cancelled",
            ErrorCode = "Cancelled",
            Message = message ?? "Operation was cancelled by user"
        };

    /// <summary>
    /// Create a denied result (user denied approval).
    /// </summary>
    public static ToolResult Denied(string? reason = null) =>
        new()
        {
            Success = false,
            Error = "Operation was denied by user",
            ErrorCode = "Denied",
            Message = reason ?? "Operation was denied by user"
        };

    /// <summary>
    /// Create a validation failure result.
    /// </summary>
    public static ToolResult ValidationFailed(ToolValidationResult validation) =>
        new()
        {
            Success = false,
            Error = string.Join("; ", validation.Errors.Select(e => e.Message)),
            ErrorCode = "ValidationFailed",
            Message = "Parameter validation failed"
        };

    /// <summary>
    /// Create a timeout result.
    /// </summary>
    public static ToolResult Timeout(TimeSpan duration) =>
        new()
        {
            Success = false,
            Error = $"Operation timed out after {duration.TotalSeconds:F1}s",
            ErrorCode = "Timeout",
            Duration = duration,
            Message = "Operation timed out"
        };

    #endregion

    /// <summary>
    /// Get the serialized data for LLM context, with optional truncation.
    /// </summary>
    public string GetSerializedData(int maxLength = 50000)
    {
        if (Data == null) return string.Empty;

        var json = JsonSerializer.Serialize(Data, new JsonSerializerOptions
        {
            WriteIndented = false
        });

        if (json.Length <= maxLength) return json;

        // Truncate with indication
        return json[..(maxLength - 50)] + $"... [truncated, total {json.Length} chars]";
    }

    /// <summary>
    /// Convert to LLM-friendly format for conversation context.
    /// </summary>
    public string ToLlmContext()
    {
        var sb = new StringBuilder();

        if (Success)
        {
            sb.AppendLine($"Result: Success");
            sb.AppendLine($"Message: {Message}");
            if (Data != null)
            {
                sb.AppendLine($"Data: {GetSerializedData()}");
            }
        }
        else
        {
            sb.AppendLine($"Result: Failed");
            sb.AppendLine($"Error: {Error}");
        }

        if (Artifacts.Count > 0)
        {
            sb.AppendLine($"Artifacts:");
            foreach (var artifact in Artifacts)
            {
                sb.AppendLine($"  - {artifact.Type}: {artifact.Path}");
            }
        }

        if (SuggestedFollowUps?.Count > 0)
        {
            sb.AppendLine($"Suggested next steps:");
            foreach (var suggestion in SuggestedFollowUps)
            {
                sb.AppendLine($"  - {suggestion}");
            }
        }

        return sb.ToString();
    }
}
```

### ToolArtifact Model

```csharp
namespace SeniorIntern.Core.Tools;

/// <summary>
/// An artifact produced by a tool execution.
/// Represents files created, modified, or other tangible outputs.
/// </summary>
public sealed class ToolArtifact
{
    /// <summary>
    /// Type of artifact (e.g., "file", "directory", "output", "url").
    /// </summary>
    public string Type { get; init; } = string.Empty;

    /// <summary>
    /// Path or location of the artifact.
    /// </summary>
    public string Path { get; init; } = string.Empty;

    /// <summary>
    /// Human-readable description.
    /// </summary>
    public string? Description { get; init; }

    /// <summary>
    /// Size in bytes (for files).
    /// </summary>
    public long? Size { get; init; }

    /// <summary>
    /// MIME type (for files).
    /// </summary>
    public string? MimeType { get; init; }

    /// <summary>
    /// Hash of content (for verification).
    /// </summary>
    public string? ContentHash { get; init; }

    /// <summary>
    /// Whether this artifact was created (vs modified).
    /// </summary>
    public bool IsNew { get; init; }

    /// <summary>
    /// Timestamp when artifact was created/modified.
    /// </summary>
    public DateTime Timestamp { get; init; } = DateTime.UtcNow;

    #region Factory Methods

    /// <summary>
    /// Create a file artifact.
    /// </summary>
    public static ToolArtifact File(string path, bool isNew = false, string? description = null)
    {
        var fileInfo = new FileInfo(path);
        return new ToolArtifact
        {
            Type = "file",
            Path = path,
            Description = description,
            Size = fileInfo.Exists ? fileInfo.Length : null,
            IsNew = isNew,
            MimeType = MimeTypes.GetMimeType(path)
        };
    }

    /// <summary>
    /// Create a directory artifact.
    /// </summary>
    public static ToolArtifact Directory(string path, bool isNew = false, string? description = null) =>
        new()
        {
            Type = "directory",
            Path = path,
            Description = description,
            IsNew = isNew
        };

    /// <summary>
    /// Create a URL artifact.
    /// </summary>
    public static ToolArtifact Url(string url, string? description = null) =>
        new()
        {
            Type = "url",
            Path = url,
            Description = description
        };

    /// <summary>
    /// Create a terminal output artifact.
    /// </summary>
    public static ToolArtifact TerminalOutput(string output, string? description = null) =>
        new()
        {
            Type = "output",
            Path = "terminal",
            Description = description ?? "Terminal output",
            Size = output.Length
        };

    #endregion
}
```

### ToolResultBuilder

```csharp
namespace SeniorIntern.Core.Tools;

/// <summary>
/// Fluent builder for creating ToolResult instances.
/// </summary>
public sealed class ToolResultBuilder
{
    private bool _success = true;
    private object? _data;
    private string _message = string.Empty;
    private string? _error;
    private string? _errorCode;
    private Exception? _exception;
    private readonly List<ToolArtifact> _artifacts = new();
    private TimeSpan _duration;
    private readonly List<string> _suggestions = new();
    private bool _shouldTruncate;
    private int? _maxDataLength;
    private Dictionary<string, object>? _metadata;

    public static ToolResultBuilder Create() => new();

    public ToolResultBuilder AsSuccess()
    {
        _success = true;
        return this;
    }

    public ToolResultBuilder AsFailure(string error, string? errorCode = null)
    {
        _success = false;
        _error = error;
        _errorCode = errorCode;
        return this;
    }

    public ToolResultBuilder WithData(object? data)
    {
        _data = data;
        return this;
    }

    public ToolResultBuilder WithMessage(string message)
    {
        _message = message;
        return this;
    }

    public ToolResultBuilder WithException(Exception ex)
    {
        _exception = ex;
        _success = false;
        _error ??= ex.Message;
        _errorCode ??= ex.GetType().Name;
        return this;
    }

    public ToolResultBuilder WithArtifact(ToolArtifact artifact)
    {
        _artifacts.Add(artifact);
        return this;
    }

    public ToolResultBuilder WithFileArtifact(string path, bool isNew = false, string? description = null)
    {
        _artifacts.Add(ToolArtifact.File(path, isNew, description));
        return this;
    }

    public ToolResultBuilder WithDuration(TimeSpan duration)
    {
        _duration = duration;
        return this;
    }

    public ToolResultBuilder WithSuggestion(string suggestion)
    {
        _suggestions.Add(suggestion);
        return this;
    }

    public ToolResultBuilder WithTruncation(int maxLength = 50000)
    {
        _shouldTruncate = true;
        _maxDataLength = maxLength;
        return this;
    }

    public ToolResultBuilder WithMetadata(string key, object value)
    {
        _metadata ??= new Dictionary<string, object>();
        _metadata[key] = value;
        return this;
    }

    public ToolResult Build() => new()
    {
        Success = _success,
        Data = _data,
        Message = _message,
        Error = _error,
        ErrorCode = _errorCode,
        Exception = _exception,
        Artifacts = _artifacts,
        Duration = _duration,
        SuggestedFollowUps = _suggestions.Count > 0 ? _suggestions : null,
        ShouldTruncate = _shouldTruncate,
        MaxDataLength = _maxDataLength,
        Metadata = _metadata
    };
}
```

### Files to Create (v0.6.1c)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Tools/ToolResult.cs` | Result model with factory methods |
| `src/SeniorIntern.Core/Tools/ToolArtifact.cs` | Artifact model |
| `src/SeniorIntern.Core/Tools/ToolResultBuilder.cs` | Fluent result builder |
| `src/SeniorIntern.Core/Utilities/MimeTypes.cs` | MIME type helper |

### Implementation Notes
- Results should be immutable once created
- Large data should be truncated before sending to LLM
- Error codes enable programmatic error handling in agent loop
- Artifacts track side effects for undo/rollback potential

---

## v0.6.1d: Tool Validation

### Objective
Define the validation system for tool parameters, including validation results, error reporting, and integration with JSON schema validation.

### ToolValidationResult Model

```csharp
namespace SeniorIntern.Core.Tools;

/// <summary>
/// Result of validating tool parameters.
/// </summary>
public sealed class ToolValidationResult
{
    /// <summary>
    /// Whether all parameters are valid.
    /// </summary>
    public bool IsValid { get; init; }

    /// <summary>
    /// List of validation errors (empty if valid).
    /// </summary>
    public IReadOnlyList<ToolValidationError> Errors { get; init; } = Array.Empty<ToolValidationError>();

    /// <summary>
    /// List of validation warnings (non-blocking issues).
    /// </summary>
    public IReadOnlyList<ToolValidationWarning> Warnings { get; init; } = Array.Empty<ToolValidationWarning>();

    #region Factory Methods

    /// <summary>
    /// Create a valid result.
    /// </summary>
    public static ToolValidationResult Valid() =>
        new() { IsValid = true };

    /// <summary>
    /// Create a valid result with warnings.
    /// </summary>
    public static ToolValidationResult ValidWithWarnings(params ToolValidationWarning[] warnings) =>
        new() { IsValid = true, Warnings = warnings };

    /// <summary>
    /// Create an invalid result with errors.
    /// </summary>
    public static ToolValidationResult Invalid(params ToolValidationError[] errors) =>
        new() { IsValid = false, Errors = errors };

    /// <summary>
    /// Create an invalid result for a missing required parameter.
    /// </summary>
    public static ToolValidationResult MissingRequired(string parameterName) =>
        Invalid(ToolValidationError.Required(parameterName));

    /// <summary>
    /// Create an invalid result for an invalid parameter value.
    /// </summary>
    public static ToolValidationResult InvalidValue(string parameterName, string message) =>
        Invalid(ToolValidationError.InvalidValue(parameterName, message));

    #endregion

    /// <summary>
    /// Combine multiple validation results.
    /// </summary>
    public static ToolValidationResult Combine(params ToolValidationResult[] results)
    {
        var errors = results.SelectMany(r => r.Errors).ToList();
        var warnings = results.SelectMany(r => r.Warnings).ToList();

        return new ToolValidationResult
        {
            IsValid = errors.Count == 0,
            Errors = errors,
            Warnings = warnings
        };
    }

    /// <summary>
    /// Get a formatted error message for display.
    /// </summary>
    public string GetErrorMessage()
    {
        if (IsValid) return string.Empty;

        return string.Join(Environment.NewLine,
            Errors.Select(e => $"- {e.ParameterName}: {e.Message}"));
    }
}
```

### ToolValidationError Model

```csharp
namespace SeniorIntern.Core.Tools;

/// <summary>
/// A validation error for a tool parameter.
/// </summary>
public sealed class ToolValidationError
{
    /// <summary>
    /// Name of the parameter with the error.
    /// </summary>
    public string ParameterName { get; init; } = string.Empty;

    /// <summary>
    /// Human-readable error message.
    /// </summary>
    public string Message { get; init; } = string.Empty;

    /// <summary>
    /// Error code for programmatic handling.
    /// </summary>
    public string ErrorCode { get; init; } = string.Empty;

    /// <summary>
    /// The invalid value that was provided.
    /// </summary>
    public object? ProvidedValue { get; init; }

    /// <summary>
    /// Description of what was expected.
    /// </summary>
    public string? ExpectedDescription { get; init; }

    #region Factory Methods

    /// <summary>
    /// Create error for missing required parameter.
    /// </summary>
    public static ToolValidationError Required(string parameterName) =>
        new()
        {
            ParameterName = parameterName,
            Message = $"Required parameter '{parameterName}' is missing",
            ErrorCode = "required"
        };

    /// <summary>
    /// Create error for invalid value.
    /// </summary>
    public static ToolValidationError InvalidValue(
        string parameterName,
        string message,
        object? providedValue = null) =>
        new()
        {
            ParameterName = parameterName,
            Message = message,
            ErrorCode = "invalid_value",
            ProvidedValue = providedValue
        };

    /// <summary>
    /// Create error for type mismatch.
    /// </summary>
    public static ToolValidationError TypeMismatch(
        string parameterName,
        string expectedType,
        string actualType) =>
        new()
        {
            ParameterName = parameterName,
            Message = $"Expected {expectedType} but got {actualType}",
            ErrorCode = "type_mismatch",
            ExpectedDescription = expectedType
        };

    /// <summary>
    /// Create error for value out of range.
    /// </summary>
    public static ToolValidationError OutOfRange(
        string parameterName,
        object value,
        object? min,
        object? max) =>
        new()
        {
            ParameterName = parameterName,
            Message = $"Value {value} is out of range [{min ?? "∞"}, {max ?? "∞"}]",
            ErrorCode = "out_of_range",
            ProvidedValue = value
        };

    /// <summary>
    /// Create error for pattern mismatch.
    /// </summary>
    public static ToolValidationError PatternMismatch(
        string parameterName,
        string value,
        string pattern) =>
        new()
        {
            ParameterName = parameterName,
            Message = $"Value does not match required pattern: {pattern}",
            ErrorCode = "pattern_mismatch",
            ProvidedValue = value,
            ExpectedDescription = pattern
        };

    /// <summary>
    /// Create error for invalid enum value.
    /// </summary>
    public static ToolValidationError InvalidEnum(
        string parameterName,
        object value,
        IEnumerable<string> allowedValues) =>
        new()
        {
            ParameterName = parameterName,
            Message = $"Invalid value. Allowed: {string.Join(", ", allowedValues)}",
            ErrorCode = "invalid_enum",
            ProvidedValue = value,
            ExpectedDescription = string.Join(", ", allowedValues)
        };

    /// <summary>
    /// Create error for path not found.
    /// </summary>
    public static ToolValidationError PathNotFound(string parameterName, string path) =>
        new()
        {
            ParameterName = parameterName,
            Message = $"Path does not exist: {path}",
            ErrorCode = "path_not_found",
            ProvidedValue = path
        };

    /// <summary>
    /// Create error for path outside workspace.
    /// </summary>
    public static ToolValidationError PathOutsideWorkspace(string parameterName, string path) =>
        new()
        {
            ParameterName = parameterName,
            Message = $"Path is outside the workspace: {path}",
            ErrorCode = "path_outside_workspace",
            ProvidedValue = path
        };

    #endregion
}
```

### ToolValidationWarning Model

```csharp
namespace SeniorIntern.Core.Tools;

/// <summary>
/// A validation warning for a tool parameter.
/// Warnings don't block execution but should be noted.
/// </summary>
public sealed class ToolValidationWarning
{
    /// <summary>
    /// Name of the parameter with the warning.
    /// </summary>
    public string ParameterName { get; init; } = string.Empty;

    /// <summary>
    /// Human-readable warning message.
    /// </summary>
    public string Message { get; init; } = string.Empty;

    /// <summary>
    /// Warning code for programmatic handling.
    /// </summary>
    public string WarningCode { get; init; } = string.Empty;

    #region Factory Methods

    /// <summary>
    /// Create warning for deprecated parameter.
    /// </summary>
    public static ToolValidationWarning Deprecated(string parameterName, string? alternative = null) =>
        new()
        {
            ParameterName = parameterName,
            Message = alternative != null
                ? $"Parameter '{parameterName}' is deprecated. Use '{alternative}' instead."
                : $"Parameter '{parameterName}' is deprecated.",
            WarningCode = "deprecated"
        };

    /// <summary>
    /// Create warning for large value.
    /// </summary>
    public static ToolValidationWarning LargeValue(string parameterName, string details) =>
        new()
        {
            ParameterName = parameterName,
            Message = details,
            WarningCode = "large_value"
        };

    /// <summary>
    /// Create warning for potentially slow operation.
    /// </summary>
    public static ToolValidationWarning SlowOperation(string parameterName, string reason) =>
        new()
        {
            ParameterName = parameterName,
            Message = $"This may be slow: {reason}",
            WarningCode = "slow_operation"
        };

    #endregion
}
```

### IToolValidator Interface

```csharp
namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Service for validating tool parameters against JSON schemas.
/// </summary>
public interface IToolValidator
{
    /// <summary>
    /// Validate parameters against a JSON schema.
    /// </summary>
    /// <param name="parameters">Parameters to validate</param>
    /// <param name="schema">JSON schema to validate against</param>
    /// <returns>Validation result</returns>
    ToolValidationResult ValidateAgainstSchema(JsonElement parameters, JsonSchema schema);

    /// <summary>
    /// Validate a single parameter value.
    /// </summary>
    /// <param name="parameterName">Name of the parameter</param>
    /// <param name="value">Value to validate</param>
    /// <param name="property">Schema property definition</param>
    /// <returns>Validation errors (empty if valid)</returns>
    IEnumerable<ToolValidationError> ValidateParameter(
        string parameterName,
        JsonElement value,
        JsonSchemaProperty property);
}
```

### Files to Create (v0.6.1d)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Tools/ToolValidationResult.cs` | Validation result model |
| `src/SeniorIntern.Core/Tools/ToolValidationError.cs` | Validation error model |
| `src/SeniorIntern.Core/Tools/ToolValidationWarning.cs` | Validation warning model |
| `src/SeniorIntern.Core/Interfaces/IToolValidator.cs` | Validator interface |
| `src/SeniorIntern.Services/Tools/ToolValidator.cs` | Validator implementation |

### Implementation Notes
- Schema validation uses JSON Schema Draft 7 compatible rules
- Custom validation can be added by tools in their Validate() method
- Warnings are surfaced in UI but don't block execution
- Path validation is critical for security

---

## v0.6.1e: JSON Schema System

### Objective
Implement a JSON Schema representation and fluent builder that enables tools to declare their parameter schemas in a type-safe, maintainable way compatible with OpenAI function calling format.

### JsonSchema Model

```csharp
namespace SeniorIntern.Core.Tools;

using System.Text.Json;
using System.Text.Json.Serialization;

/// <summary>
/// JSON Schema definition for tool parameters.
/// Compatible with OpenAI function calling format.
/// </summary>
public sealed class JsonSchema
{
    /// <summary>
    /// Schema type (always "object" for tool parameters).
    /// </summary>
    [JsonPropertyName("type")]
    public string Type { get; init; } = "object";

    /// <summary>
    /// Description of the parameters object.
    /// </summary>
    [JsonPropertyName("description")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? Description { get; init; }

    /// <summary>
    /// Property definitions.
    /// </summary>
    [JsonPropertyName("properties")]
    public Dictionary<string, JsonSchemaProperty> Properties { get; init; } = new();

    /// <summary>
    /// List of required property names.
    /// </summary>
    [JsonPropertyName("required")]
    public List<string> Required { get; init; } = new();

    /// <summary>
    /// Whether additional properties are allowed.
    /// </summary>
    [JsonPropertyName("additionalProperties")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public bool AdditionalProperties { get; init; } = false;

    /// <summary>
    /// Serialize to JSON for LLM function calling.
    /// </summary>
    public string ToJson() => JsonSerializer.Serialize(this, new JsonSerializerOptions
    {
        WriteIndented = false,
        DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
    });

    /// <summary>
    /// Create an empty schema (no parameters).
    /// </summary>
    public static JsonSchema Empty => new()
    {
        Type = "object",
        Properties = new(),
        Required = new()
    };
}
```

### JsonSchemaProperty Model

```csharp
namespace SeniorIntern.Core.Tools;

using System.Text.Json.Serialization;

/// <summary>
/// Property definition within a JSON Schema.
/// </summary>
public sealed class JsonSchemaProperty
{
    /// <summary>
    /// Property type: "string", "integer", "number", "boolean", "array", "object"
    /// </summary>
    [JsonPropertyName("type")]
    public string Type { get; init; } = string.Empty;

    /// <summary>
    /// Description of the property.
    /// </summary>
    [JsonPropertyName("description")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? Description { get; init; }

    /// <summary>
    /// Allowed values for enum properties.
    /// </summary>
    [JsonPropertyName("enum")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string[]? Enum { get; init; }

    /// <summary>
    /// Regex pattern for string validation.
    /// </summary>
    [JsonPropertyName("pattern")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? Pattern { get; init; }

    /// <summary>
    /// Minimum value for numeric properties.
    /// </summary>
    [JsonPropertyName("minimum")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public double? Minimum { get; init; }

    /// <summary>
    /// Maximum value for numeric properties.
    /// </summary>
    [JsonPropertyName("maximum")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public double? Maximum { get; init; }

    /// <summary>
    /// Minimum length for string properties.
    /// </summary>
    [JsonPropertyName("minLength")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public int? MinLength { get; init; }

    /// <summary>
    /// Maximum length for string properties.
    /// </summary>
    [JsonPropertyName("maxLength")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public int? MaxLength { get; init; }

    /// <summary>
    /// Default value for the property.
    /// </summary>
    [JsonPropertyName("default")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public object? Default { get; init; }

    /// <summary>
    /// Schema for array items.
    /// </summary>
    [JsonPropertyName("items")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public JsonSchemaProperty? Items { get; init; }

    /// <summary>
    /// Minimum number of items for array properties.
    /// </summary>
    [JsonPropertyName("minItems")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public int? MinItems { get; init; }

    /// <summary>
    /// Maximum number of items for array properties.
    /// </summary>
    [JsonPropertyName("maxItems")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public int? MaxItems { get; init; }

    /// <summary>
    /// Whether array items must be unique.
    /// </summary>
    [JsonPropertyName("uniqueItems")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public bool UniqueItems { get; init; }

    /// <summary>
    /// Nested object properties.
    /// </summary>
    [JsonPropertyName("properties")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public Dictionary<string, JsonSchemaProperty>? ObjectProperties { get; init; }

    /// <summary>
    /// Required properties for nested objects.
    /// </summary>
    [JsonPropertyName("required")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public List<string>? ObjectRequired { get; init; }

    /// <summary>
    /// Examples of valid values.
    /// </summary>
    [JsonPropertyName("examples")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public object[]? Examples { get; init; }
}
```

### JsonSchemaBuilder

```csharp
namespace SeniorIntern.Core.Tools;

/// <summary>
/// Fluent builder for JSON Schema definitions.
/// </summary>
public sealed class JsonSchemaBuilder
{
    private readonly Dictionary<string, JsonSchemaProperty> _properties = new();
    private readonly List<string> _required = new();
    private string? _description;
    private bool _additionalProperties;

    /// <summary>
    /// Create a new schema builder.
    /// </summary>
    public static JsonSchemaBuilder Create() => new();

    /// <summary>
    /// Set the schema description.
    /// </summary>
    public JsonSchemaBuilder WithDescription(string description)
    {
        _description = description;
        return this;
    }

    /// <summary>
    /// Allow additional properties not defined in schema.
    /// </summary>
    public JsonSchemaBuilder AllowAdditionalProperties(bool allow = true)
    {
        _additionalProperties = allow;
        return this;
    }

    #region String Properties

    /// <summary>
    /// Add a string property.
    /// </summary>
    public JsonSchemaBuilder AddString(
        string name,
        string description,
        bool required = false,
        string? defaultValue = null,
        string? pattern = null,
        int? minLength = null,
        int? maxLength = null,
        string[]? examples = null)
    {
        _properties[name] = new JsonSchemaProperty
        {
            Type = "string",
            Description = description,
            Default = defaultValue,
            Pattern = pattern,
            MinLength = minLength,
            MaxLength = maxLength,
            Examples = examples
        };

        if (required) _required.Add(name);
        return this;
    }

    /// <summary>
    /// Add a string property with enum constraint.
    /// </summary>
    public JsonSchemaBuilder AddEnum(
        string name,
        string description,
        string[] values,
        bool required = false,
        string? defaultValue = null)
    {
        _properties[name] = new JsonSchemaProperty
        {
            Type = "string",
            Description = description,
            Enum = values,
            Default = defaultValue
        };

        if (required) _required.Add(name);
        return this;
    }

    /// <summary>
    /// Add a file path property with validation hint.
    /// </summary>
    public JsonSchemaBuilder AddPath(
        string name,
        string description,
        bool required = false,
        bool mustExist = false)
    {
        var desc = description;
        if (mustExist)
            desc += " (must exist)";

        _properties[name] = new JsonSchemaProperty
        {
            Type = "string",
            Description = desc
        };

        if (required) _required.Add(name);
        return this;
    }

    #endregion

    #region Numeric Properties

    /// <summary>
    /// Add an integer property.
    /// </summary>
    public JsonSchemaBuilder AddInteger(
        string name,
        string description,
        bool required = false,
        int? defaultValue = null,
        int? minimum = null,
        int? maximum = null)
    {
        _properties[name] = new JsonSchemaProperty
        {
            Type = "integer",
            Description = description,
            Default = defaultValue,
            Minimum = minimum,
            Maximum = maximum
        };

        if (required) _required.Add(name);
        return this;
    }

    /// <summary>
    /// Add a number (floating point) property.
    /// </summary>
    public JsonSchemaBuilder AddNumber(
        string name,
        string description,
        bool required = false,
        double? defaultValue = null,
        double? minimum = null,
        double? maximum = null)
    {
        _properties[name] = new JsonSchemaProperty
        {
            Type = "number",
            Description = description,
            Default = defaultValue,
            Minimum = minimum,
            Maximum = maximum
        };

        if (required) _required.Add(name);
        return this;
    }

    #endregion

    #region Boolean Properties

    /// <summary>
    /// Add a boolean property.
    /// </summary>
    public JsonSchemaBuilder AddBoolean(
        string name,
        string description,
        bool required = false,
        bool? defaultValue = null)
    {
        _properties[name] = new JsonSchemaProperty
        {
            Type = "boolean",
            Description = description,
            Default = defaultValue
        };

        if (required) _required.Add(name);
        return this;
    }

    #endregion

    #region Array Properties

    /// <summary>
    /// Add an array property with string items.
    /// </summary>
    public JsonSchemaBuilder AddStringArray(
        string name,
        string description,
        bool required = false,
        int? minItems = null,
        int? maxItems = null,
        bool uniqueItems = false)
    {
        _properties[name] = new JsonSchemaProperty
        {
            Type = "array",
            Description = description,
            Items = new JsonSchemaProperty { Type = "string" },
            MinItems = minItems,
            MaxItems = maxItems,
            UniqueItems = uniqueItems
        };

        if (required) _required.Add(name);
        return this;
    }

    /// <summary>
    /// Add an array property with custom item type.
    /// </summary>
    public JsonSchemaBuilder AddArray(
        string name,
        string description,
        JsonSchemaProperty itemSchema,
        bool required = false,
        int? minItems = null,
        int? maxItems = null)
    {
        _properties[name] = new JsonSchemaProperty
        {
            Type = "array",
            Description = description,
            Items = itemSchema,
            MinItems = minItems,
            MaxItems = maxItems
        };

        if (required) _required.Add(name);
        return this;
    }

    #endregion

    #region Object Properties

    /// <summary>
    /// Add a nested object property.
    /// </summary>
    public JsonSchemaBuilder AddObject(
        string name,
        string description,
        Action<JsonSchemaBuilder> configure,
        bool required = false)
    {
        var nestedBuilder = new JsonSchemaBuilder();
        configure(nestedBuilder);
        var nestedSchema = nestedBuilder.Build();

        _properties[name] = new JsonSchemaProperty
        {
            Type = "object",
            Description = description,
            ObjectProperties = nestedSchema.Properties,
            ObjectRequired = nestedSchema.Required.Count > 0 ? nestedSchema.Required : null
        };

        if (required) _required.Add(name);
        return this;
    }

    #endregion

    /// <summary>
    /// Build the JSON Schema.
    /// </summary>
    public JsonSchema Build() => new()
    {
        Type = "object",
        Description = _description,
        Properties = _properties,
        Required = _required,
        AdditionalProperties = _additionalProperties
    };
}
```

### JsonSchemaExtensions

```csharp
namespace SeniorIntern.Core.Tools;

/// <summary>
/// Extension methods for JSON Schema types.
/// </summary>
public static class JsonSchemaExtensions
{
    /// <summary>
    /// Get a property by name.
    /// </summary>
    public static JsonSchemaProperty? GetProperty(this JsonSchema schema, string name) =>
        schema.Properties.GetValueOrDefault(name);

    /// <summary>
    /// Check if a property is required.
    /// </summary>
    public static bool IsRequired(this JsonSchema schema, string propertyName) =>
        schema.Required.Contains(propertyName);

    /// <summary>
    /// Get all required property names.
    /// </summary>
    public static IEnumerable<string> GetRequiredProperties(this JsonSchema schema) =>
        schema.Required;

    /// <summary>
    /// Get all optional property names.
    /// </summary>
    public static IEnumerable<string> GetOptionalProperties(this JsonSchema schema) =>
        schema.Properties.Keys.Except(schema.Required);

    /// <summary>
    /// Create a schema for a .NET type using reflection.
    /// </summary>
    public static JsonSchema FromType<T>() where T : class =>
        JsonSchemaGenerator.Generate<T>();
}
```

### JsonSchemaGenerator

```csharp
namespace SeniorIntern.Core.Tools;

using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Reflection;

/// <summary>
/// Generates JSON Schema from .NET types using reflection.
/// </summary>
public static class JsonSchemaGenerator
{
    /// <summary>
    /// Generate a JSON Schema from a type.
    /// </summary>
    public static JsonSchema Generate<T>() where T : class =>
        Generate(typeof(T));

    /// <summary>
    /// Generate a JSON Schema from a type.
    /// </summary>
    public static JsonSchema Generate(Type type)
    {
        var builder = JsonSchemaBuilder.Create();

        // Get description from DescriptionAttribute
        var typeDesc = type.GetCustomAttribute<DescriptionAttribute>();
        if (typeDesc != null)
        {
            builder.WithDescription(typeDesc.Description);
        }

        // Process properties
        foreach (var prop in type.GetProperties(BindingFlags.Public | BindingFlags.Instance))
        {
            var propDesc = prop.GetCustomAttribute<DescriptionAttribute>()?.Description
                ?? prop.Name;

            var required = prop.GetCustomAttribute<RequiredAttribute>() != null;

            var propType = Nullable.GetUnderlyingType(prop.PropertyType) ?? prop.PropertyType;

            if (propType == typeof(string))
            {
                var maxLength = prop.GetCustomAttribute<MaxLengthAttribute>()?.Length;
                var minLength = prop.GetCustomAttribute<MinLengthAttribute>()?.Length;
                builder.AddString(prop.Name, propDesc, required,
                    minLength: minLength, maxLength: maxLength);
            }
            else if (propType == typeof(int) || propType == typeof(long))
            {
                var range = prop.GetCustomAttribute<RangeAttribute>();
                builder.AddInteger(prop.Name, propDesc, required,
                    minimum: range != null ? (int)range.Minimum : null,
                    maximum: range != null ? (int)range.Maximum : null);
            }
            else if (propType == typeof(double) || propType == typeof(float) || propType == typeof(decimal))
            {
                var range = prop.GetCustomAttribute<RangeAttribute>();
                builder.AddNumber(prop.Name, propDesc, required,
                    minimum: range != null ? (double)range.Minimum : null,
                    maximum: range != null ? (double)range.Maximum : null);
            }
            else if (propType == typeof(bool))
            {
                builder.AddBoolean(prop.Name, propDesc, required);
            }
            else if (propType.IsEnum)
            {
                var values = Enum.GetNames(propType);
                builder.AddEnum(prop.Name, propDesc, values, required);
            }
            // Add more type mappings as needed
        }

        return builder.Build();
    }
}
```

### Files to Create (v0.6.1e)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Tools/JsonSchema.cs` | Schema model |
| `src/SeniorIntern.Core/Tools/JsonSchemaProperty.cs` | Property model |
| `src/SeniorIntern.Core/Tools/JsonSchemaBuilder.cs` | Fluent builder |
| `src/SeniorIntern.Core/Tools/JsonSchemaExtensions.cs` | Extension methods |
| `src/SeniorIntern.Core/Tools/JsonSchemaGenerator.cs` | Type-based generation |

### Implementation Notes
- Schema format is compatible with OpenAI function calling
- Builder provides type-safe, fluent API for defining schemas
- Generator enables automatic schema creation from DTOs
- Examples help LLM understand expected formats

---

## v0.6.1f: Tool Base Class

### Objective
Create an abstract base class that provides common functionality for tool implementations, including parameter extraction, validation helpers, and path resolution utilities.

### ToolBase Abstract Class

```csharp
namespace SeniorIntern.Core.Tools;

using System.Text.Json;

/// <summary>
/// Abstract base class for implementing tools.
/// Provides common functionality and helper methods.
/// </summary>
public abstract class ToolBase : ITool
{
    #region Abstract Members (Must Implement)

    /// <inheritdoc />
    public abstract string Id { get; }

    /// <inheritdoc />
    public abstract string Name { get; }

    /// <inheritdoc />
    public abstract string Description { get; }

    /// <inheritdoc />
    public abstract ToolCategory Category { get; }

    /// <inheritdoc />
    public abstract JsonSchema InputSchema { get; }

    /// <summary>
    /// Core execution logic. Override this instead of ExecuteAsync.
    /// </summary>
    protected abstract Task<ToolResult> ExecuteCoreAsync(
        ToolExecutionContext context,
        CancellationToken ct);

    #endregion

    #region Virtual Members (Can Override)

    /// <inheritdoc />
    public virtual RiskLevel DefaultRiskLevel => RiskLevel.Low;

    /// <inheritdoc />
    public virtual bool IsAvailable => true;

    /// <inheritdoc />
    public virtual IReadOnlyList<string> Tags => Array.Empty<string>();

    /// <inheritdoc />
    public virtual ToolValidationResult Validate(JsonElement parameters)
    {
        // Default: validate against JSON schema
        var errors = new List<ToolValidationError>();

        // Check required parameters
        foreach (var required in InputSchema.Required)
        {
            if (!parameters.TryGetProperty(required, out _))
            {
                errors.Add(ToolValidationError.Required(required));
            }
        }

        return errors.Count > 0
            ? ToolValidationResult.Invalid(errors.ToArray())
            : ToolValidationResult.Valid();
    }

    /// <inheritdoc />
    public virtual string GetExecutionSummary(JsonElement parameters)
    {
        return $"Execute {Name}";
    }

    /// <inheritdoc />
    public virtual RiskLevel GetEffectiveRiskLevel(JsonElement parameters)
    {
        return DefaultRiskLevel;
    }

    #endregion

    #region Final Implementation

    /// <inheritdoc />
    public async Task<ToolResult> ExecuteAsync(
        ToolExecutionContext context,
        CancellationToken ct = default)
    {
        var stopwatch = Stopwatch.StartNew();

        try
        {
            // Validate before execution
            var validation = Validate(context.EffectiveParameters);
            if (!validation.IsValid)
            {
                return ToolResult.ValidationFailed(validation);
            }

            // Execute the core logic
            var result = await ExecuteCoreAsync(context, ct);

            stopwatch.Stop();
            return result with { Duration = stopwatch.Elapsed };
        }
        catch (OperationCanceledException)
        {
            stopwatch.Stop();
            return ToolResult.Cancelled() with { Duration = stopwatch.Elapsed };
        }
        catch (Exception ex)
        {
            stopwatch.Stop();
            return ToolResult.FromException(ex) with { Duration = stopwatch.Elapsed };
        }
    }

    #endregion

    #region Parameter Helpers

    /// <summary>
    /// Get a required string parameter.
    /// </summary>
    protected string GetRequiredString(JsonElement parameters, string name)
    {
        if (!parameters.TryGetProperty(name, out var prop))
            throw new ArgumentException($"Missing required parameter: {name}");

        if (prop.ValueKind != JsonValueKind.String)
            throw new ArgumentException($"Parameter '{name}' must be a string");

        return prop.GetString() ?? throw new ArgumentException($"Parameter '{name}' cannot be null");
    }

    /// <summary>
    /// Get an optional string parameter.
    /// </summary>
    protected string? GetOptionalString(JsonElement parameters, string name, string? defaultValue = null)
    {
        if (!parameters.TryGetProperty(name, out var prop))
            return defaultValue;

        if (prop.ValueKind == JsonValueKind.Null)
            return defaultValue;

        return prop.GetString() ?? defaultValue;
    }

    /// <summary>
    /// Get a required integer parameter.
    /// </summary>
    protected int GetRequiredInt(JsonElement parameters, string name)
    {
        if (!parameters.TryGetProperty(name, out var prop))
            throw new ArgumentException($"Missing required parameter: {name}");

        if (prop.ValueKind != JsonValueKind.Number)
            throw new ArgumentException($"Parameter '{name}' must be a number");

        return prop.GetInt32();
    }

    /// <summary>
    /// Get an optional integer parameter.
    /// </summary>
    protected int GetOptionalInt(JsonElement parameters, string name, int defaultValue = 0)
    {
        if (!parameters.TryGetProperty(name, out var prop))
            return defaultValue;

        if (prop.ValueKind == JsonValueKind.Null)
            return defaultValue;

        return prop.GetInt32();
    }

    /// <summary>
    /// Get a required boolean parameter.
    /// </summary>
    protected bool GetRequiredBool(JsonElement parameters, string name)
    {
        if (!parameters.TryGetProperty(name, out var prop))
            throw new ArgumentException($"Missing required parameter: {name}");

        if (prop.ValueKind != JsonValueKind.True && prop.ValueKind != JsonValueKind.False)
            throw new ArgumentException($"Parameter '{name}' must be a boolean");

        return prop.GetBoolean();
    }

    /// <summary>
    /// Get an optional boolean parameter.
    /// </summary>
    protected bool GetOptionalBool(JsonElement parameters, string name, bool defaultValue = false)
    {
        if (!parameters.TryGetProperty(name, out var prop))
            return defaultValue;

        if (prop.ValueKind == JsonValueKind.Null)
            return defaultValue;

        return prop.GetBoolean();
    }

    /// <summary>
    /// Get a required array parameter as string list.
    /// </summary>
    protected List<string> GetRequiredStringArray(JsonElement parameters, string name)
    {
        if (!parameters.TryGetProperty(name, out var prop))
            throw new ArgumentException($"Missing required parameter: {name}");

        if (prop.ValueKind != JsonValueKind.Array)
            throw new ArgumentException($"Parameter '{name}' must be an array");

        return prop.EnumerateArray()
            .Select(e => e.GetString() ?? string.Empty)
            .ToList();
    }

    /// <summary>
    /// Get an optional array parameter as string list.
    /// </summary>
    protected List<string> GetOptionalStringArray(JsonElement parameters, string name)
    {
        if (!parameters.TryGetProperty(name, out var prop))
            return new List<string>();

        if (prop.ValueKind == JsonValueKind.Null)
            return new List<string>();

        if (prop.ValueKind != JsonValueKind.Array)
            return new List<string>();

        return prop.EnumerateArray()
            .Select(e => e.GetString() ?? string.Empty)
            .ToList();
    }

    /// <summary>
    /// Deserialize parameters to a strongly-typed object.
    /// </summary>
    protected T GetParameters<T>(JsonElement parameters) where T : class
    {
        return parameters.Deserialize<T>()
            ?? throw new ArgumentException("Failed to deserialize parameters");
    }

    /// <summary>
    /// Try to deserialize parameters to a strongly-typed object.
    /// </summary>
    protected bool TryGetParameters<T>(JsonElement parameters, out T? result) where T : class
    {
        try
        {
            result = parameters.Deserialize<T>();
            return result != null;
        }
        catch
        {
            result = null;
            return false;
        }
    }

    #endregion

    #region Path Helpers

    /// <summary>
    /// Resolve a path parameter relative to workspace.
    /// </summary>
    protected string ResolvePath(ToolExecutionContext context, string relativePath)
    {
        return context.ResolvePath(relativePath);
    }

    /// <summary>
    /// Validate that a path is within the workspace.
    /// </summary>
    protected void ValidatePathInWorkspace(ToolExecutionContext context, string path)
    {
        var resolved = context.ResolvePath(path);
        if (!context.IsPathInWorkspace(resolved))
        {
            throw new UnauthorizedAccessException(
                $"Path '{path}' is outside the workspace");
        }
    }

    /// <summary>
    /// Ensure a directory exists, creating it if necessary.
    /// </summary>
    protected void EnsureDirectoryExists(string path)
    {
        var directory = Path.GetDirectoryName(path);
        if (!string.IsNullOrEmpty(directory) && !Directory.Exists(directory))
        {
            Directory.CreateDirectory(directory);
        }
    }

    #endregion

    #region Result Helpers

    /// <summary>
    /// Create a success result with file artifact.
    /// </summary>
    protected ToolResult SuccessWithFile(string path, string message, bool isNew = false)
    {
        return ToolResult.SucceededWithArtifacts(
            new[] { ToolArtifact.File(path, isNew) },
            data: new { path },
            message: message);
    }

    /// <summary>
    /// Create a success result with multiple file artifacts.
    /// </summary>
    protected ToolResult SuccessWithFiles(
        IEnumerable<string> paths,
        string message,
        bool areNew = false)
    {
        var artifacts = paths.Select(p => ToolArtifact.File(p, areNew)).ToList();
        return ToolResult.SucceededWithArtifacts(
            artifacts,
            data: new { files = paths.ToList() },
            message: message);
    }

    #endregion
}
```

### Files to Create (v0.6.1f)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Tools/ToolBase.cs` | Abstract base class |

### Implementation Notes
- ExecuteAsync handles timing, validation, and exception wrapping
- Parameter helpers reduce boilerplate in tool implementations
- Path helpers enforce workspace security boundaries
- Result helpers provide consistent output formats

---

## v0.6.1g: Tool Registry Interface

### Objective
Define the interface for the tool registry that manages tool registration, lookup, availability filtering, and function definition generation for LLM integration.

### IToolRegistry Interface

```csharp
namespace SeniorIntern.Core.Interfaces;

using SeniorIntern.Core.Tools;

/// <summary>
/// Registry for managing available tools.
/// </summary>
public interface IToolRegistry
{
    /// <summary>
    /// All registered tools.
    /// </summary>
    IReadOnlyList<ITool> Tools { get; }

    /// <summary>
    /// Number of registered tools.
    /// </summary>
    int Count { get; }

    /// <summary>
    /// Get available tools (filtered by current context).
    /// </summary>
    /// <param name="context">Availability context for filtering</param>
    /// <returns>List of available tools</returns>
    IReadOnlyList<ITool> GetAvailableTools(ToolAvailabilityContext? context = null);

    /// <summary>
    /// Get a tool by its ID.
    /// </summary>
    /// <param name="toolId">Tool ID to look up</param>
    /// <returns>The tool, or null if not found</returns>
    ITool? GetTool(string toolId);

    /// <summary>
    /// Check if a tool is registered.
    /// </summary>
    /// <param name="toolId">Tool ID to check</param>
    /// <returns>True if registered</returns>
    bool HasTool(string toolId);

    /// <summary>
    /// Register a new tool.
    /// </summary>
    /// <param name="tool">Tool to register</param>
    /// <exception cref="InvalidOperationException">If tool ID already registered</exception>
    void RegisterTool(ITool tool);

    /// <summary>
    /// Try to register a tool (no exception if duplicate).
    /// </summary>
    /// <param name="tool">Tool to register</param>
    /// <returns>True if registered, false if duplicate</returns>
    bool TryRegisterTool(ITool tool);

    /// <summary>
    /// Unregister a tool.
    /// </summary>
    /// <param name="toolId">ID of tool to unregister</param>
    /// <returns>True if tool was removed</returns>
    bool UnregisterTool(string toolId);

    /// <summary>
    /// Get tools by category.
    /// </summary>
    /// <param name="category">Category to filter by</param>
    /// <returns>Tools in the category</returns>
    IReadOnlyList<ITool> GetToolsByCategory(ToolCategory category);

    /// <summary>
    /// Get tools by tag.
    /// </summary>
    /// <param name="tag">Tag to filter by</param>
    /// <returns>Tools with the tag</returns>
    IReadOnlyList<ITool> GetToolsByTag(string tag);

    /// <summary>
    /// Get tools by risk level.
    /// </summary>
    /// <param name="maxRiskLevel">Maximum risk level to include</param>
    /// <returns>Tools at or below the risk level</returns>
    IReadOnlyList<ITool> GetToolsByRiskLevel(RiskLevel maxRiskLevel);

    /// <summary>
    /// Search tools by name or description.
    /// </summary>
    /// <param name="query">Search query</param>
    /// <returns>Matching tools</returns>
    IReadOnlyList<ITool> SearchTools(string query);

    /// <summary>
    /// Generate OpenAI-compatible function definitions for available tools.
    /// </summary>
    /// <param name="context">Availability context for filtering</param>
    /// <returns>List of function definitions</returns>
    IReadOnlyList<FunctionDefinition> GetFunctionDefinitions(ToolAvailabilityContext? context = null);

    /// <summary>
    /// Get a single function definition for a tool.
    /// </summary>
    /// <param name="toolId">Tool ID</param>
    /// <returns>Function definition, or null if not found</returns>
    FunctionDefinition? GetFunctionDefinition(string toolId);

    /// <summary>
    /// Event raised when tools are added or removed.
    /// </summary>
    event EventHandler<ToolRegistryChangedEventArgs>? ToolsChanged;
}
```

### ToolAvailabilityContext Model

```csharp
namespace SeniorIntern.Core.Tools;

/// <summary>
/// Context for determining tool availability.
/// </summary>
public sealed class ToolAvailabilityContext
{
    /// <summary>
    /// Whether a workspace is currently open.
    /// </summary>
    public bool HasWorkspace { get; init; }

    /// <summary>
    /// Path to the current workspace (if any).
    /// </summary>
    public string? WorkspacePath { get; init; }

    /// <summary>
    /// Whether a terminal is available.
    /// </summary>
    public bool HasTerminal { get; init; }

    /// <summary>
    /// Whether an editor is available.
    /// </summary>
    public bool HasEditor { get; init; }

    /// <summary>
    /// Whether a Git repository is available.
    /// </summary>
    public bool HasGitRepository { get; init; }

    /// <summary>
    /// Explicitly enabled tool IDs (whitelist).
    /// If set, only these tools are available.
    /// </summary>
    public IReadOnlySet<string>? EnabledToolIds { get; init; }

    /// <summary>
    /// Explicitly disabled tool IDs (blacklist).
    /// These tools are never available.
    /// </summary>
    public IReadOnlySet<string>? DisabledToolIds { get; init; }

    /// <summary>
    /// Maximum allowed risk level for available tools.
    /// </summary>
    public RiskLevel? MaxRiskLevel { get; init; }

    /// <summary>
    /// Categories to include (if set, filters to these).
    /// </summary>
    public IReadOnlySet<ToolCategory>? IncludedCategories { get; init; }

    /// <summary>
    /// Categories to exclude.
    /// </summary>
    public IReadOnlySet<ToolCategory>? ExcludedCategories { get; init; }

    /// <summary>
    /// Tags that tools must have (all required).
    /// </summary>
    public IReadOnlySet<string>? RequiredTags { get; init; }

    /// <summary>
    /// Create a default context with no restrictions.
    /// </summary>
    public static ToolAvailabilityContext Default => new()
    {
        HasWorkspace = true,
        HasTerminal = true,
        HasEditor = true,
        HasGitRepository = false
    };

    /// <summary>
    /// Create a minimal context (safe tools only).
    /// </summary>
    public static ToolAvailabilityContext SafeOnly => new()
    {
        HasWorkspace = true,
        HasTerminal = false,
        HasEditor = false,
        MaxRiskLevel = RiskLevel.Safe
    };
}
```

### FunctionDefinition Model

```csharp
namespace SeniorIntern.Core.Tools;

using System.Text.Json;
using System.Text.Json.Serialization;

/// <summary>
/// OpenAI-compatible function definition for tool calling.
/// </summary>
public sealed class FunctionDefinition
{
    /// <summary>
    /// Function name (same as tool ID).
    /// </summary>
    [JsonPropertyName("name")]
    public string Name { get; init; } = string.Empty;

    /// <summary>
    /// Function description for LLM.
    /// </summary>
    [JsonPropertyName("description")]
    public string Description { get; init; } = string.Empty;

    /// <summary>
    /// Parameter schema.
    /// </summary>
    [JsonPropertyName("parameters")]
    public JsonSchema Parameters { get; init; } = null!;

    /// <summary>
    /// Convert to JSON for API calls.
    /// </summary>
    public string ToJson() => JsonSerializer.Serialize(this, new JsonSerializerOptions
    {
        WriteIndented = false,
        DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
    });

    /// <summary>
    /// Create from a tool.
    /// </summary>
    public static FunctionDefinition FromTool(ITool tool) => new()
    {
        Name = tool.Id,
        Description = tool.Description,
        Parameters = tool.InputSchema
    };
}
```

### ToolRegistryChangedEventArgs

```csharp
namespace SeniorIntern.Core.Tools;

/// <summary>
/// Event args for tool registry changes.
/// </summary>
public sealed class ToolRegistryChangedEventArgs : EventArgs
{
    /// <summary>
    /// Type of change that occurred.
    /// </summary>
    public ToolRegistryChangeType ChangeType { get; init; }

    /// <summary>
    /// The tool that was added/removed.
    /// </summary>
    public ITool Tool { get; init; } = null!;

    /// <summary>
    /// Timestamp of the change.
    /// </summary>
    public DateTime Timestamp { get; init; } = DateTime.UtcNow;
}

/// <summary>
/// Types of tool registry changes.
/// </summary>
public enum ToolRegistryChangeType
{
    /// <summary>
    /// A tool was added.
    /// </summary>
    Added,

    /// <summary>
    /// A tool was removed.
    /// </summary>
    Removed,

    /// <summary>
    /// A tool was updated (replaced).
    /// </summary>
    Updated
}
```

### Files to Create (v0.6.1g)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/IToolRegistry.cs` | Registry interface |
| `src/SeniorIntern.Core/Tools/ToolAvailabilityContext.cs` | Availability context |
| `src/SeniorIntern.Core/Tools/FunctionDefinition.cs` | Function definition model |
| `src/SeniorIntern.Core/Tools/ToolRegistryChangedEventArgs.cs` | Registry event args |

### Implementation Notes
- Registry is the single source of truth for available tools
- Availability context enables flexible filtering for different scenarios
- Function definitions are formatted for OpenAI API compatibility
- Events enable UI updates when tools change

---

## v0.6.1h: Tool Registry Implementation

### Objective
Implement the tool registry service with thread-safe registration, efficient lookup, filtering capabilities, and event notification.

### ToolRegistry Implementation

```csharp
namespace SeniorIntern.Services;

using System.Collections.Concurrent;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Tools;

/// <summary>
/// Thread-safe implementation of the tool registry.
/// </summary>
public sealed class ToolRegistry : IToolRegistry
{
    private readonly ConcurrentDictionary<string, ITool> _tools = new(StringComparer.OrdinalIgnoreCase);
    private readonly ILogger<ToolRegistry> _logger;

    public ToolRegistry(ILogger<ToolRegistry> logger)
    {
        _logger = logger;
    }

    /// <inheritdoc />
    public IReadOnlyList<ITool> Tools => _tools.Values.ToList();

    /// <inheritdoc />
    public int Count => _tools.Count;

    /// <inheritdoc />
    public ITool? GetTool(string toolId) =>
        _tools.GetValueOrDefault(toolId);

    /// <inheritdoc />
    public bool HasTool(string toolId) =>
        _tools.ContainsKey(toolId);

    /// <inheritdoc />
    public void RegisterTool(ITool tool)
    {
        if (!TryRegisterTool(tool))
        {
            throw new InvalidOperationException($"Tool '{tool.Id}' is already registered");
        }
    }

    /// <inheritdoc />
    public bool TryRegisterTool(ITool tool)
    {
        if (_tools.TryAdd(tool.Id, tool))
        {
            _logger.LogInformation(
                "Registered tool: {ToolId} ({ToolName}) - Category: {Category}, Risk: {Risk}",
                tool.Id, tool.Name, tool.Category, tool.DefaultRiskLevel);

            OnToolsChanged(new ToolRegistryChangedEventArgs
            {
                ChangeType = ToolRegistryChangeType.Added,
                Tool = tool
            });

            return true;
        }

        _logger.LogWarning("Tool '{ToolId}' is already registered", tool.Id);
        return false;
    }

    /// <inheritdoc />
    public bool UnregisterTool(string toolId)
    {
        if (_tools.TryRemove(toolId, out var tool))
        {
            _logger.LogInformation("Unregistered tool: {ToolId}", toolId);

            OnToolsChanged(new ToolRegistryChangedEventArgs
            {
                ChangeType = ToolRegistryChangeType.Removed,
                Tool = tool
            });

            return true;
        }

        return false;
    }

    /// <inheritdoc />
    public IReadOnlyList<ITool> GetAvailableTools(ToolAvailabilityContext? context = null)
    {
        var tools = _tools.Values.AsEnumerable();

        // Filter by IsAvailable
        tools = tools.Where(t => t.IsAvailable);

        if (context == null)
            return tools.ToList();

        // Apply context filters
        tools = ApplyContextFilters(tools, context);

        return tools.ToList();
    }

    private IEnumerable<ITool> ApplyContextFilters(
        IEnumerable<ITool> tools,
        ToolAvailabilityContext context)
    {
        // Whitelist filter
        if (context.EnabledToolIds?.Count > 0)
        {
            tools = tools.Where(t => context.EnabledToolIds.Contains(t.Id));
        }

        // Blacklist filter
        if (context.DisabledToolIds?.Count > 0)
        {
            tools = tools.Where(t => !context.DisabledToolIds.Contains(t.Id));
        }

        // Risk level filter
        if (context.MaxRiskLevel.HasValue)
        {
            tools = tools.Where(t => t.DefaultRiskLevel <= context.MaxRiskLevel.Value);
        }

        // Category filters
        if (context.IncludedCategories?.Count > 0)
        {
            tools = tools.Where(t => context.IncludedCategories.Contains(t.Category));
        }

        if (context.ExcludedCategories?.Count > 0)
        {
            tools = tools.Where(t => !context.ExcludedCategories.Contains(t.Category));
        }

        // Tag filter
        if (context.RequiredTags?.Count > 0)
        {
            tools = tools.Where(t => context.RequiredTags.All(tag => t.Tags.Contains(tag)));
        }

        // Context-dependent availability
        if (!context.HasWorkspace)
        {
            tools = tools.Where(t => t.Category != ToolCategory.Workspace);
        }

        if (!context.HasTerminal)
        {
            tools = tools.Where(t => t.Category != ToolCategory.Terminal);
        }

        if (!context.HasEditor)
        {
            tools = tools.Where(t => t.Category != ToolCategory.Editor);
        }

        if (!context.HasGitRepository)
        {
            tools = tools.Where(t => t.Category != ToolCategory.Git);
        }

        return tools;
    }

    /// <inheritdoc />
    public IReadOnlyList<ITool> GetToolsByCategory(ToolCategory category) =>
        _tools.Values.Where(t => t.Category == category && t.IsAvailable).ToList();

    /// <inheritdoc />
    public IReadOnlyList<ITool> GetToolsByTag(string tag) =>
        _tools.Values.Where(t => t.Tags.Contains(tag, StringComparer.OrdinalIgnoreCase) && t.IsAvailable).ToList();

    /// <inheritdoc />
    public IReadOnlyList<ITool> GetToolsByRiskLevel(RiskLevel maxRiskLevel) =>
        _tools.Values.Where(t => t.DefaultRiskLevel <= maxRiskLevel && t.IsAvailable).ToList();

    /// <inheritdoc />
    public IReadOnlyList<ITool> SearchTools(string query)
    {
        if (string.IsNullOrWhiteSpace(query))
            return Tools;

        var lowerQuery = query.ToLowerInvariant();

        return _tools.Values
            .Where(t => t.IsAvailable &&
                (t.Id.Contains(lowerQuery, StringComparison.OrdinalIgnoreCase) ||
                 t.Name.Contains(lowerQuery, StringComparison.OrdinalIgnoreCase) ||
                 t.Description.Contains(lowerQuery, StringComparison.OrdinalIgnoreCase) ||
                 t.Tags.Any(tag => tag.Contains(lowerQuery, StringComparison.OrdinalIgnoreCase))))
            .ToList();
    }

    /// <inheritdoc />
    public IReadOnlyList<FunctionDefinition> GetFunctionDefinitions(ToolAvailabilityContext? context = null)
    {
        return GetAvailableTools(context)
            .Select(FunctionDefinition.FromTool)
            .ToList();
    }

    /// <inheritdoc />
    public FunctionDefinition? GetFunctionDefinition(string toolId)
    {
        var tool = GetTool(toolId);
        return tool != null ? FunctionDefinition.FromTool(tool) : null;
    }

    /// <inheritdoc />
    public event EventHandler<ToolRegistryChangedEventArgs>? ToolsChanged;

    private void OnToolsChanged(ToolRegistryChangedEventArgs args)
    {
        ToolsChanged?.Invoke(this, args);
    }
}
```

### ToolRegistryExtensions

```csharp
namespace SeniorIntern.Services;

using Microsoft.Extensions.DependencyInjection;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Tools;

/// <summary>
/// Extension methods for tool registry setup.
/// </summary>
public static class ToolRegistryExtensions
{
    /// <summary>
    /// Add the tool registry to services.
    /// </summary>
    public static IServiceCollection AddToolRegistry(this IServiceCollection services)
    {
        services.AddSingleton<IToolRegistry, ToolRegistry>();
        return services;
    }

    /// <summary>
    /// Register a tool type with the container and registry.
    /// </summary>
    public static IServiceCollection AddTool<TTool>(this IServiceCollection services)
        where TTool : class, ITool
    {
        services.AddSingleton<ITool, TTool>();
        return services;
    }

    /// <summary>
    /// Register multiple tools.
    /// </summary>
    public static IServiceCollection AddTools(
        this IServiceCollection services,
        params Type[] toolTypes)
    {
        foreach (var type in toolTypes)
        {
            if (!typeof(ITool).IsAssignableFrom(type))
                throw new ArgumentException($"{type.Name} does not implement ITool");

            services.AddSingleton(typeof(ITool), type);
        }

        return services;
    }

    /// <summary>
    /// Configure tools from registered ITool services.
    /// Call this in application startup after services are built.
    /// </summary>
    public static IServiceProvider ConfigureTools(this IServiceProvider services)
    {
        var registry = services.GetRequiredService<IToolRegistry>();
        var tools = services.GetServices<ITool>();

        foreach (var tool in tools)
        {
            registry.TryRegisterTool(tool);
        }

        return services;
    }
}
```

### Files to Create (v0.6.1h)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Services/Tools/ToolRegistry.cs` | Registry implementation |
| `src/SeniorIntern.Services/Tools/ToolRegistryExtensions.cs` | DI extensions |

### Files to Modify (v0.6.1h)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Services/ServiceCollectionExtensions.cs` | Add tool registry registration |

### Implementation Notes
- ConcurrentDictionary ensures thread safety
- Filtering is applied lazily for performance
- Extensions provide clean DI integration
- Tools can be registered from DI or manually

---

## v0.6.1i: Tool Execution Service

### Objective
Create the tool execution service that handles the complete lifecycle of tool invocation including validation, approval integration, execution, timeout handling, and result processing.

### IToolExecutionService Interface

```csharp
namespace SeniorIntern.Core.Interfaces;

using SeniorIntern.Core.Tools;

/// <summary>
/// Service for executing tools with proper lifecycle management.
/// </summary>
public interface IToolExecutionService
{
    /// <summary>
    /// Execute a tool with the given context.
    /// </summary>
    /// <param name="toolId">ID of the tool to execute</param>
    /// <param name="context">Execution context</param>
    /// <param name="ct">Cancellation token</param>
    /// <returns>Execution result</returns>
    Task<ToolExecutionResult> ExecuteAsync(
        string toolId,
        ToolExecutionContext context,
        CancellationToken ct = default);

    /// <summary>
    /// Validate tool parameters without executing.
    /// </summary>
    /// <param name="toolId">ID of the tool</param>
    /// <param name="parameters">Parameters to validate</param>
    /// <returns>Validation result</returns>
    ToolValidationResult Validate(string toolId, JsonElement parameters);

    /// <summary>
    /// Get the execution summary for a tool invocation.
    /// </summary>
    /// <param name="toolId">ID of the tool</param>
    /// <param name="parameters">Parameters for the invocation</param>
    /// <returns>Human-readable summary</returns>
    string GetExecutionSummary(string toolId, JsonElement parameters);

    /// <summary>
    /// Get the effective risk level for a tool invocation.
    /// </summary>
    /// <param name="toolId">ID of the tool</param>
    /// <param name="parameters">Parameters for the invocation</param>
    /// <returns>Effective risk level</returns>
    RiskLevel GetEffectiveRiskLevel(string toolId, JsonElement parameters);

    /// <summary>
    /// Event raised when execution starts.
    /// </summary>
    event EventHandler<ToolExecutionStartedEventArgs>? ExecutionStarted;

    /// <summary>
    /// Event raised when execution completes.
    /// </summary>
    event EventHandler<ToolExecutionCompletedEventArgs>? ExecutionCompleted;

    /// <summary>
    /// Event raised during execution progress.
    /// </summary>
    event EventHandler<ToolExecutionProgressEventArgs>? ExecutionProgress;
}
```

### ToolExecutionResult Model

```csharp
namespace SeniorIntern.Core.Tools;

/// <summary>
/// Complete result of a tool execution including metadata.
/// </summary>
public sealed class ToolExecutionResult
{
    /// <summary>
    /// The tool that was executed.
    /// </summary>
    public string ToolId { get; init; } = string.Empty;

    /// <summary>
    /// The execution ID.
    /// </summary>
    public Guid ExecutionId { get; init; }

    /// <summary>
    /// The tool result.
    /// </summary>
    public ToolResult Result { get; init; } = null!;

    /// <summary>
    /// Status of the execution.
    /// </summary>
    public ToolExecutionStatus Status { get; init; }

    /// <summary>
    /// When execution started.
    /// </summary>
    public DateTime StartedAt { get; init; }

    /// <summary>
    /// When execution completed.
    /// </summary>
    public DateTime CompletedAt { get; init; }

    /// <summary>
    /// Total execution time.
    /// </summary>
    public TimeSpan Duration => CompletedAt - StartedAt;

    /// <summary>
    /// Whether the tool was approved before execution.
    /// </summary>
    public bool WasApproved { get; init; }

    /// <summary>
    /// Whether execution timed out.
    /// </summary>
    public bool TimedOut { get; init; }

    /// <summary>
    /// Whether execution was cancelled.
    /// </summary>
    public bool WasCancelled { get; init; }

    #region Factory Methods

    public static ToolExecutionResult Success(
        string toolId,
        Guid executionId,
        ToolResult result,
        DateTime startedAt) =>
        new()
        {
            ToolId = toolId,
            ExecutionId = executionId,
            Result = result,
            Status = ToolExecutionStatus.Completed,
            StartedAt = startedAt,
            CompletedAt = DateTime.UtcNow,
            WasApproved = true
        };

    public static ToolExecutionResult Failed(
        string toolId,
        Guid executionId,
        ToolResult result,
        DateTime startedAt) =>
        new()
        {
            ToolId = toolId,
            ExecutionId = executionId,
            Result = result,
            Status = ToolExecutionStatus.Failed,
            StartedAt = startedAt,
            CompletedAt = DateTime.UtcNow
        };

    public static ToolExecutionResult Cancelled(
        string toolId,
        Guid executionId,
        DateTime startedAt) =>
        new()
        {
            ToolId = toolId,
            ExecutionId = executionId,
            Result = ToolResult.Cancelled(),
            Status = ToolExecutionStatus.Cancelled,
            StartedAt = startedAt,
            CompletedAt = DateTime.UtcNow,
            WasCancelled = true
        };

    public static ToolExecutionResult Timeout(
        string toolId,
        Guid executionId,
        DateTime startedAt,
        TimeSpan timeout) =>
        new()
        {
            ToolId = toolId,
            ExecutionId = executionId,
            Result = ToolResult.Timeout(timeout),
            Status = ToolExecutionStatus.Failed,
            StartedAt = startedAt,
            CompletedAt = DateTime.UtcNow,
            TimedOut = true
        };

    public static ToolExecutionResult ToolNotFound(string toolId) =>
        new()
        {
            ToolId = toolId,
            ExecutionId = Guid.NewGuid(),
            Result = ToolResult.Failed($"Tool '{toolId}' not found", "ToolNotFound"),
            Status = ToolExecutionStatus.Failed,
            StartedAt = DateTime.UtcNow,
            CompletedAt = DateTime.UtcNow
        };

    #endregion
}

/// <summary>
/// Status of a tool execution.
/// </summary>
public enum ToolExecutionStatus
{
    /// <summary>
    /// Execution is pending.
    /// </summary>
    Pending,

    /// <summary>
    /// Execution is in progress.
    /// </summary>
    InProgress,

    /// <summary>
    /// Execution completed successfully.
    /// </summary>
    Completed,

    /// <summary>
    /// Execution failed.
    /// </summary>
    Failed,

    /// <summary>
    /// Execution was cancelled.
    /// </summary>
    Cancelled
}
```

### ToolExecutionService Implementation

```csharp
namespace SeniorIntern.Services.Tools;

using System.Text.Json;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Tools;

/// <summary>
/// Service for executing tools with proper lifecycle management.
/// </summary>
public sealed class ToolExecutionService : IToolExecutionService
{
    private readonly IToolRegistry _registry;
    private readonly ILogger<ToolExecutionService> _logger;
    private readonly ToolExecutionOptions _options;

    public ToolExecutionService(
        IToolRegistry registry,
        ILogger<ToolExecutionService> logger,
        IOptions<ToolExecutionOptions> options)
    {
        _registry = registry;
        _logger = logger;
        _options = options.Value;
    }

    /// <inheritdoc />
    public async Task<ToolExecutionResult> ExecuteAsync(
        string toolId,
        ToolExecutionContext context,
        CancellationToken ct = default)
    {
        var startedAt = DateTime.UtcNow;

        // Get the tool
        var tool = _registry.GetTool(toolId);
        if (tool == null)
        {
            _logger.LogWarning("Tool not found: {ToolId}", toolId);
            return ToolExecutionResult.ToolNotFound(toolId);
        }

        // Log execution start
        _logger.LogInformation(
            "Starting tool execution: {ToolId} (ExecutionId: {ExecutionId})",
            toolId, context.ExecutionId);

        OnExecutionStarted(new ToolExecutionStartedEventArgs
        {
            ToolId = toolId,
            ToolName = tool.Name,
            ExecutionId = context.ExecutionId,
            StartedAt = startedAt
        });

        try
        {
            // Create timeout token
            using var timeoutCts = CancellationTokenSource.CreateLinkedTokenSource(ct);
            timeoutCts.CancelAfter(_options.ExecutionTimeout);

            // Create progress reporter
            var progress = new Progress<ToolProgress>(p =>
            {
                OnExecutionProgress(new ToolExecutionProgressEventArgs
                {
                    ToolId = toolId,
                    ExecutionId = context.ExecutionId,
                    Progress = p
                });
            });

            // Execute with timeout
            var contextWithProgress = context with { Progress = progress };
            var result = await tool.ExecuteAsync(contextWithProgress, timeoutCts.Token);

            // Create execution result
            var executionResult = result.Success
                ? ToolExecutionResult.Success(toolId, context.ExecutionId, result, startedAt)
                : ToolExecutionResult.Failed(toolId, context.ExecutionId, result, startedAt);

            // Log completion
            _logger.LogInformation(
                "Tool execution completed: {ToolId} (ExecutionId: {ExecutionId}, Success: {Success}, Duration: {Duration}ms)",
                toolId, context.ExecutionId, result.Success, executionResult.Duration.TotalMilliseconds);

            OnExecutionCompleted(new ToolExecutionCompletedEventArgs
            {
                ToolId = toolId,
                ExecutionId = context.ExecutionId,
                Result = executionResult,
                CompletedAt = DateTime.UtcNow
            });

            return executionResult;
        }
        catch (OperationCanceledException) when (ct.IsCancellationRequested)
        {
            _logger.LogInformation(
                "Tool execution cancelled: {ToolId} (ExecutionId: {ExecutionId})",
                toolId, context.ExecutionId);

            var result = ToolExecutionResult.Cancelled(toolId, context.ExecutionId, startedAt);

            OnExecutionCompleted(new ToolExecutionCompletedEventArgs
            {
                ToolId = toolId,
                ExecutionId = context.ExecutionId,
                Result = result,
                CompletedAt = DateTime.UtcNow
            });

            return result;
        }
        catch (OperationCanceledException)
        {
            // Timeout
            _logger.LogWarning(
                "Tool execution timed out: {ToolId} (ExecutionId: {ExecutionId}, Timeout: {Timeout})",
                toolId, context.ExecutionId, _options.ExecutionTimeout);

            var result = ToolExecutionResult.Timeout(
                toolId, context.ExecutionId, startedAt, _options.ExecutionTimeout);

            OnExecutionCompleted(new ToolExecutionCompletedEventArgs
            {
                ToolId = toolId,
                ExecutionId = context.ExecutionId,
                Result = result,
                CompletedAt = DateTime.UtcNow
            });

            return result;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex,
                "Tool execution failed with exception: {ToolId} (ExecutionId: {ExecutionId})",
                toolId, context.ExecutionId);

            var result = ToolExecutionResult.Failed(
                toolId,
                context.ExecutionId,
                ToolResult.FromException(ex),
                startedAt);

            OnExecutionCompleted(new ToolExecutionCompletedEventArgs
            {
                ToolId = toolId,
                ExecutionId = context.ExecutionId,
                Result = result,
                CompletedAt = DateTime.UtcNow
            });

            return result;
        }
    }

    /// <inheritdoc />
    public ToolValidationResult Validate(string toolId, JsonElement parameters)
    {
        var tool = _registry.GetTool(toolId);
        if (tool == null)
        {
            return ToolValidationResult.Invalid(
                new ToolValidationError
                {
                    ParameterName = "toolId",
                    Message = $"Tool '{toolId}' not found",
                    ErrorCode = "tool_not_found"
                });
        }

        return tool.Validate(parameters);
    }

    /// <inheritdoc />
    public string GetExecutionSummary(string toolId, JsonElement parameters)
    {
        var tool = _registry.GetTool(toolId);
        return tool?.GetExecutionSummary(parameters) ?? $"Execute {toolId}";
    }

    /// <inheritdoc />
    public RiskLevel GetEffectiveRiskLevel(string toolId, JsonElement parameters)
    {
        var tool = _registry.GetTool(toolId);
        return tool?.GetEffectiveRiskLevel(parameters) ?? RiskLevel.Medium;
    }

    #region Events

    /// <inheritdoc />
    public event EventHandler<ToolExecutionStartedEventArgs>? ExecutionStarted;

    /// <inheritdoc />
    public event EventHandler<ToolExecutionCompletedEventArgs>? ExecutionCompleted;

    /// <inheritdoc />
    public event EventHandler<ToolExecutionProgressEventArgs>? ExecutionProgress;

    private void OnExecutionStarted(ToolExecutionStartedEventArgs args) =>
        ExecutionStarted?.Invoke(this, args);

    private void OnExecutionCompleted(ToolExecutionCompletedEventArgs args) =>
        ExecutionCompleted?.Invoke(this, args);

    private void OnExecutionProgress(ToolExecutionProgressEventArgs args) =>
        ExecutionProgress?.Invoke(this, args);

    #endregion
}
```

### ToolExecutionOptions

```csharp
namespace SeniorIntern.Services.Tools;

/// <summary>
/// Options for tool execution.
/// </summary>
public sealed class ToolExecutionOptions
{
    /// <summary>
    /// Default execution timeout.
    /// </summary>
    public TimeSpan ExecutionTimeout { get; set; } = TimeSpan.FromMinutes(2);

    /// <summary>
    /// Maximum concurrent tool executions.
    /// </summary>
    public int MaxConcurrentExecutions { get; set; } = 3;

    /// <summary>
    /// Whether to log tool parameters (may contain sensitive data).
    /// </summary>
    public bool LogParameters { get; set; } = false;

    /// <summary>
    /// Whether to log tool results (may be large).
    /// </summary>
    public bool LogResults { get; set; } = true;
}
```

### Execution Event Args

```csharp
namespace SeniorIntern.Core.Tools;

/// <summary>
/// Event args for tool execution started.
/// </summary>
public sealed class ToolExecutionStartedEventArgs : EventArgs
{
    public string ToolId { get; init; } = string.Empty;
    public string ToolName { get; init; } = string.Empty;
    public Guid ExecutionId { get; init; }
    public DateTime StartedAt { get; init; }
}

/// <summary>
/// Event args for tool execution completed.
/// </summary>
public sealed class ToolExecutionCompletedEventArgs : EventArgs
{
    public string ToolId { get; init; } = string.Empty;
    public Guid ExecutionId { get; init; }
    public ToolExecutionResult Result { get; init; } = null!;
    public DateTime CompletedAt { get; init; }
}

/// <summary>
/// Event args for tool execution progress.
/// </summary>
public sealed class ToolExecutionProgressEventArgs : EventArgs
{
    public string ToolId { get; init; } = string.Empty;
    public Guid ExecutionId { get; init; }
    public ToolProgress Progress { get; init; } = null!;
}
```

### Files to Create (v0.6.1i)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/IToolExecutionService.cs` | Execution service interface |
| `src/SeniorIntern.Core/Tools/ToolExecutionResult.cs` | Execution result model |
| `src/SeniorIntern.Core/Tools/ToolExecutionStatus.cs` | Status enumeration |
| `src/SeniorIntern.Core/Tools/ToolExecutionEventArgs.cs` | Event argument models |
| `src/SeniorIntern.Services/Tools/ToolExecutionService.cs` | Service implementation |
| `src/SeniorIntern.Services/Tools/ToolExecutionOptions.cs` | Configuration options |

### Files to Modify (v0.6.1i)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Services/ServiceCollectionExtensions.cs` | Register execution service |

### Implementation Notes
- Timeout prevents runaway tool executions
- Events enable UI progress tracking
- Logging captures execution metadata for debugging
- Options allow runtime configuration

---

## v0.6.1j: Testing Infrastructure

### Objective
Create comprehensive unit tests, integration tests, and mock tools to validate the tool framework functionality.

### MockTool for Testing

```csharp
namespace SeniorIntern.Tests.Mocks;

using SeniorIntern.Core.Tools;

/// <summary>
/// Configurable mock tool for testing.
/// </summary>
public sealed class MockTool : ToolBase
{
    private readonly string _id;
    private readonly string _name;
    private readonly string _description;
    private readonly ToolCategory _category;
    private readonly RiskLevel _riskLevel;
    private readonly JsonSchema _schema;
    private readonly Func<ToolExecutionContext, CancellationToken, Task<ToolResult>>? _executeFunc;
    private readonly Func<JsonElement, ToolValidationResult>? _validateFunc;

    public MockTool(
        string id = "mock-tool",
        string name = "Mock Tool",
        string description = "A mock tool for testing",
        ToolCategory category = ToolCategory.Custom,
        RiskLevel riskLevel = RiskLevel.Safe,
        JsonSchema? schema = null,
        Func<ToolExecutionContext, CancellationToken, Task<ToolResult>>? executeFunc = null,
        Func<JsonElement, ToolValidationResult>? validateFunc = null)
    {
        _id = id;
        _name = name;
        _description = description;
        _category = category;
        _riskLevel = riskLevel;
        _schema = schema ?? JsonSchema.Empty;
        _executeFunc = executeFunc;
        _validateFunc = validateFunc;
    }

    public override string Id => _id;
    public override string Name => _name;
    public override string Description => _description;
    public override ToolCategory Category => _category;
    public override RiskLevel DefaultRiskLevel => _riskLevel;
    public override JsonSchema InputSchema => _schema;

    public int ExecuteCallCount { get; private set; }
    public int ValidateCallCount { get; private set; }
    public List<JsonElement> ExecutedParameters { get; } = new();

    protected override async Task<ToolResult> ExecuteCoreAsync(
        ToolExecutionContext context,
        CancellationToken ct)
    {
        ExecuteCallCount++;
        ExecutedParameters.Add(context.EffectiveParameters);

        if (_executeFunc != null)
        {
            return await _executeFunc(context, ct);
        }

        return ToolResult.Succeeded(new { executed = true }, "Mock tool executed");
    }

    public override ToolValidationResult Validate(JsonElement parameters)
    {
        ValidateCallCount++;

        if (_validateFunc != null)
        {
            return _validateFunc(parameters);
        }

        return base.Validate(parameters);
    }

    /// <summary>
    /// Create a mock tool that always succeeds.
    /// </summary>
    public static MockTool Succeeding(string id = "success-tool", object? data = null) =>
        new(id, executeFunc: (_, _) => Task.FromResult(
            ToolResult.Succeeded(data ?? new { success = true })));

    /// <summary>
    /// Create a mock tool that always fails.
    /// </summary>
    public static MockTool Failing(string id = "fail-tool", string error = "Test error") =>
        new(id, executeFunc: (_, _) => Task.FromResult(
            ToolResult.Failed(error)));

    /// <summary>
    /// Create a mock tool that throws.
    /// </summary>
    public static MockTool Throwing(string id = "throw-tool", Exception? ex = null) =>
        new(id, executeFunc: (_, _) => throw (ex ?? new Exception("Test exception")));

    /// <summary>
    /// Create a mock tool that delays.
    /// </summary>
    public static MockTool Delayed(string id = "delay-tool", TimeSpan delay = default) =>
        new(id, executeFunc: async (_, ct) =>
        {
            await Task.Delay(delay == default ? TimeSpan.FromMilliseconds(100) : delay, ct);
            return ToolResult.Succeeded();
        });
}
```

### Unit Tests

```csharp
namespace SeniorIntern.Tests.Unit.Tools;

using SeniorIntern.Core.Tools;
using SeniorIntern.Services.Tools;
using SeniorIntern.Tests.Mocks;

[TestFixture]
public class ToolRegistryTests
{
    private ToolRegistry _registry;

    [SetUp]
    public void SetUp()
    {
        _registry = new ToolRegistry(NullLogger<ToolRegistry>.Instance);
    }

    [Test]
    public void RegisterTool_AddsTool()
    {
        var tool = new MockTool("test-tool");

        _registry.RegisterTool(tool);

        Assert.That(_registry.Count, Is.EqualTo(1));
        Assert.That(_registry.HasTool("test-tool"), Is.True);
    }

    [Test]
    public void RegisterTool_Duplicate_ThrowsException()
    {
        var tool1 = new MockTool("test-tool");
        var tool2 = new MockTool("test-tool");

        _registry.RegisterTool(tool1);

        Assert.Throws<InvalidOperationException>(() => _registry.RegisterTool(tool2));
    }

    [Test]
    public void GetTool_ReturnsCorrectTool()
    {
        var tool = new MockTool("test-tool", name: "Test Tool");
        _registry.RegisterTool(tool);

        var retrieved = _registry.GetTool("test-tool");

        Assert.That(retrieved, Is.Not.Null);
        Assert.That(retrieved.Name, Is.EqualTo("Test Tool"));
    }

    [Test]
    public void GetTool_NotFound_ReturnsNull()
    {
        var tool = _registry.GetTool("nonexistent");

        Assert.That(tool, Is.Null);
    }

    [Test]
    public void UnregisterTool_RemovesTool()
    {
        var tool = new MockTool("test-tool");
        _registry.RegisterTool(tool);

        var removed = _registry.UnregisterTool("test-tool");

        Assert.That(removed, Is.True);
        Assert.That(_registry.Count, Is.EqualTo(0));
    }

    [Test]
    public void GetToolsByCategory_FiltersCorrectly()
    {
        _registry.RegisterTool(new MockTool("file-1", category: ToolCategory.FileSystem));
        _registry.RegisterTool(new MockTool("file-2", category: ToolCategory.FileSystem));
        _registry.RegisterTool(new MockTool("term-1", category: ToolCategory.Terminal));

        var fileTools = _registry.GetToolsByCategory(ToolCategory.FileSystem);

        Assert.That(fileTools, Has.Count.EqualTo(2));
    }

    [Test]
    public void GetAvailableTools_WithContext_FiltersCorrectly()
    {
        _registry.RegisterTool(new MockTool("file-tool", category: ToolCategory.FileSystem));
        _registry.RegisterTool(new MockTool("term-tool", category: ToolCategory.Terminal));

        var context = new ToolAvailabilityContext { HasTerminal = false };
        var tools = _registry.GetAvailableTools(context);

        Assert.That(tools, Has.Count.EqualTo(1));
        Assert.That(tools[0].Id, Is.EqualTo("file-tool"));
    }

    [Test]
    public void ToolsChanged_EventFires_OnRegister()
    {
        ToolRegistryChangedEventArgs? eventArgs = null;
        _registry.ToolsChanged += (_, args) => eventArgs = args;

        _registry.RegisterTool(new MockTool("test-tool"));

        Assert.That(eventArgs, Is.Not.Null);
        Assert.That(eventArgs.ChangeType, Is.EqualTo(ToolRegistryChangeType.Added));
    }
}

[TestFixture]
public class JsonSchemaBuilderTests
{
    [Test]
    public void Build_CreatesValidSchema()
    {
        var schema = JsonSchemaBuilder.Create()
            .WithDescription("Test schema")
            .AddString("name", "The name", required: true)
            .AddInteger("count", "The count", minimum: 0)
            .AddBoolean("enabled", "Whether enabled", defaultValue: true)
            .Build();

        Assert.That(schema.Type, Is.EqualTo("object"));
        Assert.That(schema.Description, Is.EqualTo("Test schema"));
        Assert.That(schema.Properties, Has.Count.EqualTo(3));
        Assert.That(schema.Required, Contains.Item("name"));
    }

    [Test]
    public void AddEnum_CreatesEnumProperty()
    {
        var schema = JsonSchemaBuilder.Create()
            .AddEnum("status", "The status", new[] { "active", "inactive" }, required: true)
            .Build();

        var prop = schema.Properties["status"];
        Assert.That(prop.Type, Is.EqualTo("string"));
        Assert.That(prop.Enum, Is.EqualTo(new[] { "active", "inactive" }));
    }

    [Test]
    public void AddArray_CreatesArrayProperty()
    {
        var schema = JsonSchemaBuilder.Create()
            .AddStringArray("tags", "List of tags", minItems: 1, maxItems: 10)
            .Build();

        var prop = schema.Properties["tags"];
        Assert.That(prop.Type, Is.EqualTo("array"));
        Assert.That(prop.Items?.Type, Is.EqualTo("string"));
        Assert.That(prop.MinItems, Is.EqualTo(1));
    }
}

[TestFixture]
public class ToolExecutionServiceTests
{
    private ToolRegistry _registry;
    private ToolExecutionService _service;

    [SetUp]
    public void SetUp()
    {
        _registry = new ToolRegistry(NullLogger<ToolRegistry>.Instance);
        _service = new ToolExecutionService(
            _registry,
            NullLogger<ToolExecutionService>.Instance,
            Options.Create(new ToolExecutionOptions()));
    }

    [Test]
    public async Task ExecuteAsync_Success_ReturnsSuccessResult()
    {
        var tool = MockTool.Succeeding("test-tool", new { value = 42 });
        _registry.RegisterTool(tool);

        var context = CreateContext("test-tool");
        var result = await _service.ExecuteAsync("test-tool", context);

        Assert.That(result.Status, Is.EqualTo(ToolExecutionStatus.Completed));
        Assert.That(result.Result.Success, Is.True);
    }

    [Test]
    public async Task ExecuteAsync_Failure_ReturnsFailedResult()
    {
        var tool = MockTool.Failing("test-tool", "Test failure");
        _registry.RegisterTool(tool);

        var context = CreateContext("test-tool");
        var result = await _service.ExecuteAsync("test-tool", context);

        Assert.That(result.Status, Is.EqualTo(ToolExecutionStatus.Failed));
        Assert.That(result.Result.Error, Is.EqualTo("Test failure"));
    }

    [Test]
    public async Task ExecuteAsync_ToolNotFound_ReturnsNotFoundResult()
    {
        var context = CreateContext("nonexistent");
        var result = await _service.ExecuteAsync("nonexistent", context);

        Assert.That(result.Status, Is.EqualTo(ToolExecutionStatus.Failed));
        Assert.That(result.Result.ErrorCode, Is.EqualTo("ToolNotFound"));
    }

    [Test]
    public async Task ExecuteAsync_Cancellation_ReturnsCancelledResult()
    {
        var tool = MockTool.Delayed("test-tool", TimeSpan.FromSeconds(10));
        _registry.RegisterTool(tool);

        using var cts = new CancellationTokenSource();
        var context = CreateContext("test-tool");

        var task = _service.ExecuteAsync("test-tool", context, cts.Token);
        cts.Cancel();

        var result = await task;

        Assert.That(result.WasCancelled, Is.True);
    }

    private ToolExecutionContext CreateContext(string toolId)
    {
        return ToolExecutionContextBuilder.Create()
            .WithToolId(toolId)
            .WithServices(new ServiceCollection().BuildServiceProvider())
            .WithParametersFromObject(new { })
            .Build();
    }
}

[TestFixture]
public class ToolValidationTests
{
    [Test]
    public void Validate_MissingRequired_ReturnsError()
    {
        var schema = JsonSchemaBuilder.Create()
            .AddString("name", "The name", required: true)
            .Build();

        var tool = new MockTool(schema: schema);
        var parameters = JsonDocument.Parse("{}").RootElement;

        var result = tool.Validate(parameters);

        Assert.That(result.IsValid, Is.False);
        Assert.That(result.Errors, Has.Count.EqualTo(1));
        Assert.That(result.Errors[0].ParameterName, Is.EqualTo("name"));
    }

    [Test]
    public void Validate_AllPresent_ReturnsValid()
    {
        var schema = JsonSchemaBuilder.Create()
            .AddString("name", "The name", required: true)
            .Build();

        var tool = new MockTool(schema: schema);
        var parameters = JsonDocument.Parse("{\"name\": \"test\"}").RootElement;

        var result = tool.Validate(parameters);

        Assert.That(result.IsValid, Is.True);
    }
}
```

### Integration Tests

```csharp
namespace SeniorIntern.Tests.Integration.Tools;

[TestFixture]
public class ToolFrameworkIntegrationTests
{
    private ServiceProvider _services;
    private IToolRegistry _registry;
    private IToolExecutionService _executionService;

    [SetUp]
    public void SetUp()
    {
        var serviceCollection = new ServiceCollection()
            .AddLogging()
            .AddToolRegistry()
            .AddSingleton<IToolExecutionService, ToolExecutionService>()
            .Configure<ToolExecutionOptions>(o => o.ExecutionTimeout = TimeSpan.FromSeconds(5));

        _services = serviceCollection.BuildServiceProvider();
        _registry = _services.GetRequiredService<IToolRegistry>();
        _executionService = _services.GetRequiredService<IToolExecutionService>();
    }

    [TearDown]
    public void TearDown()
    {
        _services.Dispose();
    }

    [Test]
    public async Task FullExecutionLifecycle_WorksCorrectly()
    {
        // Register tool
        var tool = new MockTool(
            "integration-tool",
            schema: JsonSchemaBuilder.Create()
                .AddString("input", "Input value", required: true)
                .Build(),
            executeFunc: (ctx, _) =>
            {
                var input = ctx.EffectiveParameters.GetProperty("input").GetString();
                return Task.FromResult(ToolResult.Succeeded(new { output = input + " processed" }));
            });

        _registry.RegisterTool(tool);

        // Validate
        var parameters = JsonDocument.Parse("{\"input\": \"test\"}").RootElement;
        var validation = _executionService.Validate("integration-tool", parameters);
        Assert.That(validation.IsValid, Is.True);

        // Execute
        var context = ToolExecutionContextBuilder.Create()
            .WithToolId("integration-tool")
            .WithServices(_services)
            .WithParameters(parameters)
            .WithApproval()
            .Build();

        var result = await _executionService.ExecuteAsync("integration-tool", context);

        Assert.That(result.Status, Is.EqualTo(ToolExecutionStatus.Completed));
        Assert.That(result.Result.Success, Is.True);
    }

    [Test]
    public void FunctionDefinitions_AreCorrectlyGenerated()
    {
        _registry.RegisterTool(new MockTool(
            "test-tool",
            description: "A test tool",
            schema: JsonSchemaBuilder.Create()
                .AddString("path", "File path", required: true)
                .AddBoolean("recursive", "Search recursively")
                .Build()));

        var definitions = _registry.GetFunctionDefinitions();

        Assert.That(definitions, Has.Count.EqualTo(1));

        var def = definitions[0];
        Assert.That(def.Name, Is.EqualTo("test-tool"));
        Assert.That(def.Description, Is.EqualTo("A test tool"));
        Assert.That(def.Parameters.Required, Contains.Item("path"));
    }
}
```

### Files to Create (v0.6.1j)

| File | Purpose |
|------|---------|
| `tests/SeniorIntern.Tests/Mocks/MockTool.cs` | Mock tool implementation |
| `tests/SeniorIntern.Tests/Unit/Tools/ToolRegistryTests.cs` | Registry unit tests |
| `tests/SeniorIntern.Tests/Unit/Tools/JsonSchemaBuilderTests.cs` | Schema builder tests |
| `tests/SeniorIntern.Tests/Unit/Tools/ToolExecutionServiceTests.cs` | Execution service tests |
| `tests/SeniorIntern.Tests/Unit/Tools/ToolValidationTests.cs` | Validation tests |
| `tests/SeniorIntern.Tests/Integration/Tools/ToolFrameworkIntegrationTests.cs` | Integration tests |

### Implementation Notes
- MockTool enables flexible test scenarios
- Unit tests cover individual components
- Integration tests verify end-to-end flows
- Test coverage should target >80% for core classes

---

## Summary

### Files to Create (Complete v0.6.1)

| Sub-Part | File Count | Key Files |
|----------|------------|-----------|
| v0.6.1a | 5 | ITool.cs, ToolCategory.cs, RiskLevel.cs |
| v0.6.1b | 3 | ToolExecutionContext.cs, ToolProgress.cs |
| v0.6.1c | 4 | ToolResult.cs, ToolArtifact.cs, MimeTypes.cs |
| v0.6.1d | 5 | ToolValidationResult.cs, ToolValidationError.cs, IToolValidator.cs |
| v0.6.1e | 5 | JsonSchema.cs, JsonSchemaBuilder.cs, JsonSchemaGenerator.cs |
| v0.6.1f | 1 | ToolBase.cs |
| v0.6.1g | 4 | IToolRegistry.cs, ToolAvailabilityContext.cs, FunctionDefinition.cs |
| v0.6.1h | 2 | ToolRegistry.cs, ToolRegistryExtensions.cs |
| v0.6.1i | 6 | IToolExecutionService.cs, ToolExecutionResult.cs, ToolExecutionService.cs |
| v0.6.1j | 6 | MockTool.cs, various test files |
| **Total** | **41** | |

### Files to Modify (Complete v0.6.1)

| File | Sub-Parts Affecting |
|------|-------------------|
| `src/SeniorIntern.Services/ServiceCollectionExtensions.cs` | v0.6.1h, v0.6.1i |

### Dependencies Between Sub-Parts

```
v0.6.1a (Core Models)
    ↓
v0.6.1e (JSON Schema) ←──────────────────┐
    ↓                                     │
v0.6.1d (Validation) ←────────────────────┤
    ↓                                     │
v0.6.1b (Execution Context)               │
    ↓                                     │
v0.6.1c (Tool Result)                     │
    ↓                                     │
v0.6.1f (Tool Base) ──────────────────────┘
    ↓
v0.6.1g (Registry Interface)
    ↓
v0.6.1h (Registry Implementation)
    ↓
v0.6.1i (Execution Service)
    ↓
v0.6.1j (Testing)
```

### Recommended Implementation Order

1. **v0.6.1a** - Core interfaces and enums (foundation)
2. **v0.6.1e** - JSON schema system (needed for tool definitions)
3. **v0.6.1d** - Validation system (needed for tool execution)
4. **v0.6.1b** - Execution context (needed for tool execution)
5. **v0.6.1c** - Tool result system (needed for tool execution)
6. **v0.6.1f** - Tool base class (convenience for implementations)
7. **v0.6.1g** - Registry interface (defines registry contract)
8. **v0.6.1h** - Registry implementation (implements contract)
9. **v0.6.1i** - Execution service (orchestrates tool execution)
10. **v0.6.1j** - Testing infrastructure (validates everything)

---

## Acceptance Criteria

### v0.6.1 Complete
- [ ] ITool interface defined with all required members
- [ ] ToolCategory and RiskLevel enums implemented
- [ ] ToolExecutionContext provides access to services and parameters
- [ ] ToolResult handles success, failure, and cancellation cases
- [ ] ToolValidationResult captures validation errors
- [ ] JsonSchemaBuilder creates valid schemas
- [ ] ToolBase simplifies tool implementation
- [ ] IToolRegistry interface supports registration and lookup
- [ ] ToolRegistry implementation is thread-safe
- [ ] IToolExecutionService handles execution lifecycle
- [ ] ToolExecutionService applies timeouts and cancellation
- [ ] All unit tests pass
- [ ] All integration tests pass
- [ ] Code coverage exceeds 80%

---

## References

- [v0.6.0 Tool Call Execution Design](v0.6.0-tool-call-execution.md)
- [OpenAI Function Calling](https://platform.openai.com/docs/guides/function-calling)
- [JSON Schema Specification](https://json-schema.org/)
- [Microsoft Semantic Kernel](https://github.com/microsoft/semantic-kernel)
- [System.Text.Json Documentation](https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/overview)
