# Design Specification: AIntern v0.6.5h "ChatViewModel Agent Integration"

## Overview

**Version**: v0.6.5h
**Parent**: v0.6.5 Agent Loop & Polish
**Focus**: Integrate agent mode into the ChatViewModel with full event handling

### Purpose

Integrate agent mode into the ChatViewModel:
1. Provide agent mode toggle (on/off)
2. Route messages through agent or regular chat based on mode
3. Handle all agent events (text, thinking, tools, approvals, completion)
4. Integrate with keyboard shortcuts via message handlers
5. Display tool results in chat messages
6. Manage cancellation and approval flows

### Dependencies

**From v0.6.5c (Agent Activity ViewModel)**:
- `AgentActivityViewModel`
- `AgentState` enum
- `AgentActivityItem`

**From v0.6.5g (Keyboard Shortcuts)**:
- Message classes: `ToggleAgentModeMessage`, `CancelAgentExecutionMessage`, `ApproveToolCallMessage`, `DenyToolCallMessage`

**From v0.6.4 (Safety & Approval)**:
- `ApprovalDecision`
- `ApprovalRequestEvent`

**From v0.6.2 (Semantic Kernel Integration)**:
- `IAgentService`
- `AgentRequest`
- All `AgentEvent` subclasses

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                    v0.6.5h ChatViewModel Agent Integration                    │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ChatViewModel Partial Class Structure:                                      │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  ChatViewModel.cs (main file)                                            │ │
│  │  ├── Core properties and commands                                       │ │
│  │  ├── SendMessageAsync() - routes to agent or regular                    │ │
│  │  └── General chat functionality                                         │ │
│  │                                                                          │ │
│  │  ChatViewModel.Agent.cs (partial - this spec)                           │ │
│  │  ├── Agent mode state (IsAgentMode, AgentState)                        │ │
│  │  ├── IRecipient<T> implementations                                      │ │
│  │  ├── SendAgentMessageAsync()                                            │ │
│  │  ├── HandleAgentEventAsync()                                            │ │
│  │  ├── ShowApprovalDialogAsync()                                          │ │
│  │  └── Message handlers for keyboard shortcuts                           │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  Class Diagram:                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  ChatViewModel : ViewModelBase,                                          │ │
│  │                  IRecipient<ToggleAgentModeMessage>,                    │ │
│  │                  IRecipient<CancelAgentExecutionMessage>,               │ │
│  │                  IRecipient<ApproveToolCallMessage>,                    │ │
│  │                  IRecipient<DenyToolCallMessage>                        │ │
│  │                                                                          │ │
│  │  Dependencies:                                                           │ │
│  │  ├── IAgentService _agentService                                        │ │
│  │  ├── ISettingsService _settingsService                                  │ │
│  │  ├── IConversationService _conversationService                          │ │
│  │  ├── IWorkspaceService _workspaceService                                │ │
│  │  └── ITerminalService _terminalService                                  │ │
│  │                                                                          │ │
│  │  Agent State:                                                            │ │
│  │  ├── _agentCancellationTokenSource: CancellationTokenSource?            │ │
│  │  ├── _pendingApprovalTcs: TaskCompletionSource<ApprovalDecision>?       │ │
│  │  ├── IsAgentMode: bool                                                  │ │
│  │  ├── AgentState: AgentState                                             │ │
│  │  ├── AgentActivities: ObservableCollection<AgentActivityItem>          │ │
│  │  ├── AgentActivityViewModel: AgentActivityViewModel?                   │ │
│  │  └── PendingApproval: ApprovalRequestEvent?                             │ │
│  │                                                                          │ │
│  │  Computed Properties:                                                    │ │
│  │  ├── AgentModeText: string                                              │ │
│  │  ├── IsAgentActive: bool                                                │ │
│  │  └── IsApprovalPending: bool                                            │ │
│  │                                                                          │ │
│  │  Commands:                                                               │ │
│  │  ├── ToggleAgentModeCommand                                             │ │
│  │  └── CancelAgentExecutionCommand (CanExecute: IsAgentActive)            │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Agent Event Flow

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                         Agent Event Processing Flow                           │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  SendAgentMessageAsync():                                                    │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  1. Create CancellationTokenSource                                       │ │
│  │  2. Build AgentRequest from:                                            │ │
│  │     ├── UserInput                                                       │ │
│  │     ├── ConversationId                                                  │ │
│  │     ├── Messages.Select(m => m.ToChatMessage())                         │ │
│  │     ├── AttachedContexts                                                │ │
│  │     ├── SystemPrompt                                                    │ │
│  │     └── ToolContext (workspace, terminal availability)                  │ │
│  │  3. Add user message to chat                                            │ │
│  │  4. Create assistant message placeholder                                │ │
│  │  5. Clear AgentActivities                                               │ │
│  │  6. Start activity tracking                                             │ │
│  │  7. Iterate over IAgentService.ProcessMessageAsync()                    │ │
│  │  8. For each event: HandleAgentEventAsync(evt, assistantMessage)        │ │
│  │  9. Handle exceptions (cancel, error)                                   │ │
│  │  10. Clean up CancellationTokenSource                                   │ │
│  │  11. Save conversation                                                  │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  HandleAgentEventAsync():                                                    │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  Event Type              │ Action                                        │ │
│  │  ─────────────────────── │ ───────────────────────────────────────────  │ │
│  │  TextGenerationEvent     │ Append token to assistant message content    │ │
│  │  ThinkingEvent           │ Add thinking activity to panel               │ │
│  │  ToolCallRequestEvent    │ Add tool request activity                    │ │
│  │  ApprovalRequestEvent    │ Show approval dialog, wait for decision      │ │
│  │  ToolExecutionEvent      │ Add "Executing" activity                     │ │
│  │  ToolResultEvent         │ Add result activity, record stats, add to    │ │
│  │                          │   assistant message ToolResults collection   │ │
│  │  IterationEvent          │ Increment iteration counter                  │ │
│  │  AgentErrorEvent         │ Add error activity                           │ │
│  │  AgentCompleteEvent      │ Stop tracking with completion summary        │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  ShowApprovalDialogAsync():                                                  │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  1. Create TaskCompletionSource<ApprovalDecision>                       │ │
│  │  2. Create ToolApprovalDialog with ViewModel                            │ │
│  │  3. Race between:                                                        │ │
│  │     ├── Dialog result (ShowDialog)                                      │ │
│  │     └── Keyboard shortcut (TaskCompletionSource)                        │ │
│  │  4. If shortcut wins: close dialog, return shortcut result              │ │
│  │  5. If dialog wins: return dialog result                                │ │
│  │  6. Clear _pendingApprovalTcs                                           │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Message Handler Flow

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                        Message Handler Flow                                   │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Keyboard Shortcut → Message → IRecipient Handler:                          │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  Ctrl+Shift+A                                                            │ │
│  │       │                                                                  │ │
│  │       ▼                                                                  │ │
│  │  ToggleAgentModeMessage ───→ IRecipient<ToggleAgentModeMessage>.Receive │ │
│  │       │                                                                  │ │
│  │       ▼                                                                  │ │
│  │  ToggleAgentMode() ───→ IsAgentMode = !IsAgentMode                      │ │
│  │                                                                          │ │
│  │  ─────────────────────────────────────────────────────────────────────  │ │
│  │                                                                          │ │
│  │  Escape (when agent active)                                              │ │
│  │       │                                                                  │ │
│  │       ▼                                                                  │ │
│  │  CancelAgentExecutionMessage ───→ IRecipient<...>.Receive               │ │
│  │       │                                                                  │ │
│  │       ▼                                                                  │ │
│  │  CancelAgentExecution() ───→ _agentCancellationTokenSource?.Cancel()    │ │
│  │                                                                          │ │
│  │  ─────────────────────────────────────────────────────────────────────  │ │
│  │                                                                          │ │
│  │  Enter (when approval pending)                                           │ │
│  │       │                                                                  │ │
│  │       ▼                                                                  │ │
│  │  ApproveToolCallMessage(remember: false)                                │ │
│  │       │                                                                  │ │
│  │       ▼                                                                  │ │
│  │  IRecipient<ApproveToolCallMessage>.Receive                             │ │
│  │       │                                                                  │ │
│  │       ▼                                                                  │ │
│  │  _pendingApprovalTcs.TrySetResult(ApprovalDecision { Approved = true }) │ │
│  │                                                                          │ │
│  │  ─────────────────────────────────────────────────────────────────────  │ │
│  │                                                                          │ │
│  │  Backspace (when approval pending)                                       │ │
│  │       │                                                                  │ │
│  │       ▼                                                                  │ │
│  │  DenyToolCallMessage                                                     │ │
│  │       │                                                                  │ │
│  │       ▼                                                                  │ │
│  │  IRecipient<DenyToolCallMessage>.Receive                                │ │
│  │       │                                                                  │ │
│  │       ▼                                                                  │ │
│  │  _pendingApprovalTcs.TrySetResult(ApprovalDecision { Approved = false })│ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Specifications

### 1. ChatViewModel.Agent.cs (Partial Class)

**Location**: `src/SeniorIntern.Desktop/ViewModels/ChatViewModel.Agent.cs`

```csharp
namespace SeniorIntern.Desktop.ViewModels;

using System;
using System.Collections.ObjectModel;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Avalonia.Controls;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using CommunityToolkit.Mvvm.Messaging;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Core.Tools;
using SeniorIntern.Desktop.Messages;
using SeniorIntern.Desktop.Models;
using SeniorIntern.Desktop.Views;

/// <summary>
/// Agent-related functionality for ChatViewModel.
/// </summary>
/// <remarks>
/// <para>
/// This partial class extends ChatViewModel with agent mode functionality,
/// including message handling, event processing, and approval flow management.
/// </para>
/// <para>
/// It implements the IRecipient interfaces to receive keyboard shortcut messages
/// for agent control.
/// </para>
/// </remarks>
public partial class ChatViewModel :
    IRecipient<ToggleAgentModeMessage>,
    IRecipient<CancelAgentExecutionMessage>,
    IRecipient<ApproveToolCallMessage>,
    IRecipient<DenyToolCallMessage>
{
    private readonly IAgentService _agentService;
    private readonly ILogger<ChatViewModel> _logger;

    private CancellationTokenSource? _agentCancellationTokenSource;
    private TaskCompletionSource<ApprovalDecision>? _pendingApprovalTcs;

    #region Observable Properties

    /// <summary>
    /// Whether agent mode is enabled.
    /// </summary>
    /// <remarks>
    /// When enabled, messages are processed through the agent service
    /// which can execute tools. When disabled, messages are sent directly
    /// to the LLM without tool execution capability.
    /// </remarks>
    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(AgentModeText))]
    [NotifyPropertyChangedFor(nameof(SendButtonText))]
    private bool _isAgentMode = true;

    /// <summary>
    /// Current agent state.
    /// </summary>
    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(IsAgentActive))]
    [NotifyPropertyChangedFor(nameof(IsApprovalPending))]
    [NotifyCanExecuteChangedFor(nameof(CancelAgentExecutionCommand))]
    private AgentState _agentState = AgentState.Idle;

    /// <summary>
    /// Agent activities for the activity panel.
    /// </summary>
    [ObservableProperty]
    private ObservableCollection<AgentActivityItem> _agentActivities = new();

    /// <summary>
    /// ViewModel for the agent activity panel.
    /// </summary>
    [ObservableProperty]
    private AgentActivityViewModel? _agentActivityViewModel;

    /// <summary>
    /// Current pending approval request, if any.
    /// </summary>
    [ObservableProperty]
    private ApprovalRequestEvent? _pendingApproval;

    #endregion

    #region Computed Properties

    /// <summary>
    /// Text for the agent mode toggle button.
    /// </summary>
    public string AgentModeText => IsAgentMode ? "Agent Mode: On" : "Agent Mode: Off";

    /// <summary>
    /// Text for the send button.
    /// </summary>
    public string SendButtonText => IsAgentMode ? "Send (Agent)" : "Send";

    /// <summary>
    /// Whether the agent is currently active (not idle).
    /// </summary>
    public bool IsAgentActive => AgentState != AgentState.Idle;

    /// <summary>
    /// Whether an approval is pending.
    /// </summary>
    public bool IsApprovalPending => AgentState == AgentState.WaitingForApproval;

    /// <summary>
    /// Whether the chat input is currently focused.
    /// </summary>
    public bool IsChatInputFocused { get; set; }

    #endregion

    #region Initialization

    /// <summary>
    /// Initialize agent-related functionality.
    /// </summary>
    /// <remarks>
    /// Called from the main ChatViewModel constructor after dependencies are set.
    /// </remarks>
    private void InitializeAgentMode()
    {
        // Subscribe to agent state changes
        _agentService.StateChanged += OnAgentStateChanged;

        // Register for keyboard shortcut messages
        WeakReferenceMessenger.Default.Register<ToggleAgentModeMessage>(this);
        WeakReferenceMessenger.Default.Register<CancelAgentExecutionMessage>(this);
        WeakReferenceMessenger.Default.Register<ApproveToolCallMessage>(this);
        WeakReferenceMessenger.Default.Register<DenyToolCallMessage>(this);

        // Create the activity ViewModel
        AgentActivityViewModel = new AgentActivityViewModel(_agentService);

        _logger.LogInformation("Agent mode initialized");
    }

    /// <summary>
    /// Cleanup agent-related resources.
    /// </summary>
    private void CleanupAgentMode()
    {
        _agentService.StateChanged -= OnAgentStateChanged;
        WeakReferenceMessenger.Default.UnregisterAll(this);
        AgentActivityViewModel?.Dispose();
    }

    #endregion

    #region Agent Message Processing

    /// <summary>
    /// Send a message using agent mode.
    /// </summary>
    private async Task SendAgentMessageAsync()
    {
        if (string.IsNullOrWhiteSpace(UserInput))
            return;

        _logger.LogInformation("Starting agent message processing");

        // Create cancellation token source
        _agentCancellationTokenSource = new CancellationTokenSource();
        var cancellationToken = _agentCancellationTokenSource.Token;

        // Build the agent request
        var request = BuildAgentRequest();

        // Capture and clear user input
        var userMessage = UserInput;
        UserInput = string.Empty;

        // Add user message to chat
        AddUserMessage(userMessage);

        // Create assistant message placeholder
        var assistantMessage = CreateAssistantMessagePlaceholder();
        Messages.Add(assistantMessage);

        // Prepare activity tracking
        AgentActivities.Clear();
        var settings = await _settingsService.GetAgentSettingsAsync();
        AgentActivityViewModel?.StartTracking(
            request.ConversationId,
            settings.MaxIterations,
            _agentCancellationTokenSource);

        try
        {
            // Process the message through the agent
            await foreach (var evt in _agentService.ProcessMessageAsync(request, cancellationToken))
            {
                await HandleAgentEventAsync(evt, assistantMessage);

                if (cancellationToken.IsCancellationRequested)
                    break;
            }
        }
        catch (OperationCanceledException)
        {
            _logger.LogInformation("Agent execution cancelled by user");
            AgentActivityViewModel?.StopTracking(ExecutionEndReason.UserCancelled);
            assistantMessage.Content += "\n\n*[Execution cancelled]*";
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Agent execution error");
            AgentActivityViewModel?.StopTracking(ExecutionEndReason.Error, ex.Message);
            assistantMessage.Content += $"\n\n*[Error: {ex.Message}]*";
        }
        finally
        {
            _agentCancellationTokenSource?.Dispose();
            _agentCancellationTokenSource = null;
        }

        // Save the conversation
        await _conversationService.SaveCurrentConversationAsync();
    }

    /// <summary>
    /// Build an agent request from the current state.
    /// </summary>
    private AgentRequest BuildAgentRequest()
    {
        return new AgentRequest
        {
            Message = UserInput,
            ConversationId = _conversation?.Id ?? Guid.NewGuid(),
            History = Messages.Select(m => m.ToChatMessage()).ToList(),
            AttachedFiles = AttachedContexts.Select(c => c.ToFileContext()).ToList(),
            SystemPrompt = CurrentSystemPrompt?.Content,
            ToolContext = new ToolAvailabilityContext
            {
                HasWorkspace = _workspaceService?.HasOpenWorkspace ?? false,
                HasTerminal = _terminalService?.Sessions.Count > 0,
                WorkspacePath = _workspaceService?.CurrentWorkspace?.RootPath
            }
        };
    }

    /// <summary>
    /// Create a placeholder assistant message for streaming.
    /// </summary>
    private static ChatMessageViewModel CreateAssistantMessagePlaceholder()
    {
        return new ChatMessageViewModel
        {
            Role = MessageRole.Assistant,
            Content = string.Empty,
            ToolResults = new ObservableCollection<ToolResultDisplay>()
        };
    }

    #endregion

    #region Event Handling

    /// <summary>
    /// Handle an agent event and update the UI accordingly.
    /// </summary>
    private async Task HandleAgentEventAsync(AgentEvent evt, ChatMessageViewModel assistantMessage)
    {
        switch (evt)
        {
            case TextGenerationEvent text:
                HandleTextGeneration(text, assistantMessage);
                break;

            case ThinkingEvent thinking:
                HandleThinking(thinking);
                break;

            case ToolCallRequestEvent toolRequest:
                HandleToolCallRequest(toolRequest);
                break;

            case ApprovalRequestEvent approval:
                await HandleApprovalRequest(approval);
                break;

            case ToolExecutionEvent execution:
                HandleToolExecution(execution);
                break;

            case ToolResultEvent result:
                HandleToolResult(result, assistantMessage);
                break;

            case IterationEvent iteration:
                HandleIteration(iteration);
                break;

            case AgentErrorEvent error:
                HandleAgentError(error);
                break;

            case AgentCompleteEvent complete:
                HandleAgentComplete(complete);
                break;
        }
    }

    private void HandleTextGeneration(TextGenerationEvent text, ChatMessageViewModel assistantMessage)
    {
        // Append token to the streaming message content
        assistantMessage.Content += text.Token;
    }

    private void HandleThinking(ThinkingEvent thinking)
    {
        AgentActivityViewModel?.AddActivity(ActivityType.Thinking, thinking.Content);
        _logger.LogDebug("Agent thinking: {Content}", thinking.Content);
    }

    private void HandleToolCallRequest(ToolCallRequestEvent toolRequest)
    {
        AgentActivityViewModel?.AddActivity(
            ActivityType.Tool,
            $"Tool: {toolRequest.ToolName}",
            toolRequest.ParametersSummary,
            toolRequest.ToolId,
            toolRequest.ToolName);

        _logger.LogDebug("Tool call requested: {Tool}", toolRequest.ToolName);
    }

    private async Task HandleApprovalRequest(ApprovalRequestEvent approval)
    {
        _logger.LogInformation("Approval requested for tool: {Tool}", approval.Request.ToolId);

        // Store the pending approval for UI
        PendingApproval = approval;

        // Add activity
        AgentActivityViewModel?.AddActivity(
            ActivityType.Approval,
            $"Requesting approval: {approval.Summary}");

        // Show the approval dialog and wait for decision
        var decision = await ShowApprovalDialogAsync(approval);

        // Set the result on the approval event
        approval.SetResult(decision);

        // Record the approval in activity tracking
        AgentActivityViewModel?.RecordApproval(decision.Approved, wasAutoApproved: false);

        // Clear pending approval
        PendingApproval = null;

        _logger.LogInformation("Approval decision: {Approved}", decision.Approved);
    }

    private void HandleToolExecution(ToolExecutionEvent execution)
    {
        AgentActivityViewModel?.AddActivity(
            ActivityType.Tool,
            $"Executing: {execution.ToolName}",
            toolId: execution.ToolId,
            toolName: execution.ToolName);
    }

    private void HandleToolResult(ToolResultEvent result, ChatMessageViewModel assistantMessage)
    {
        var resultType = result.Result.Success ? ActivityType.Success : ActivityType.Error;

        // Add activity
        AgentActivityViewModel?.AddActivity(
            resultType,
            result.Result.Success ? "Tool completed" : "Tool failed",
            result.Result.Message,
            result.ToolId);

        // Record tool execution statistics
        AgentActivityViewModel?.RecordToolExecution(
            result.ToolId,
            result.Result.Success,
            result.Duration);

        // Add tool result to the assistant message for display
        assistantMessage.ToolResults.Add(new ToolResultDisplay
        {
            ToolName = result.ToolId,
            Success = result.Result.Success,
            Summary = result.Result.Message,
            Duration = result.Duration,
            Details = result.Result.Success
                ? result.Result.Data?.ToString()
                : result.Result.Error
        });

        _logger.LogDebug("Tool {Tool} completed: {Success}", result.ToolId, result.Result.Success);
    }

    private void HandleIteration(IterationEvent iteration)
    {
        AgentActivityViewModel?.IncrementIteration();
        _logger.LogDebug("Agent iteration {Number} starting", iteration.IterationNumber);
    }

    private void HandleAgentError(AgentErrorEvent error)
    {
        AgentActivityViewModel?.AddActivity(ActivityType.Error, error.Error);
        _logger.LogError("Agent error: {Error}", error.Error);
    }

    private void HandleAgentComplete(AgentCompleteEvent complete)
    {
        AgentActivityViewModel?.StopTracking(
            ExecutionEndReason.Completed,
            $"Completed: {complete.ToolCallsExecuted} tools in {complete.TotalDuration.TotalSeconds:F1}s");

        _logger.LogInformation(
            "Agent completed. Tools executed: {Count}, Duration: {Duration}s",
            complete.ToolCallsExecuted,
            complete.TotalDuration.TotalSeconds);
    }

    #endregion

    #region Approval Dialog

    /// <summary>
    /// Show the approval dialog and wait for a decision.
    /// </summary>
    /// <remarks>
    /// This method races between the dialog result and a keyboard shortcut.
    /// The first one to complete wins.
    /// </remarks>
    private async Task<ApprovalDecision> ShowApprovalDialogAsync(ApprovalRequestEvent approval)
    {
        // Create completion source for keyboard shortcuts
        _pendingApprovalTcs = new TaskCompletionSource<ApprovalDecision>();

        // Create and configure the dialog
        var dialog = new ToolApprovalDialog
        {
            DataContext = new ToolApprovalViewModel(approval.Request)
        };

        // Get the main window for dialog owner
        var mainWindow = GetMainWindow();

        // Race between dialog result and keyboard shortcut
        var dialogTask = dialog.ShowDialog<ApprovalDecision?>(mainWindow);
        var shortcutTask = _pendingApprovalTcs.Task;

        var completedTask = await Task.WhenAny(dialogTask, shortcutTask);

        if (completedTask == shortcutTask)
        {
            // Keyboard shortcut was used, close the dialog
            _logger.LogDebug("Approval via keyboard shortcut");
            dialog.Close();
            var result = await shortcutTask;
            _pendingApprovalTcs = null;
            return result;
        }
        else
        {
            // Dialog was used
            _logger.LogDebug("Approval via dialog");
            _pendingApprovalTcs = null;
            var result = await dialogTask;
            return result ?? new ApprovalDecision { Approved = false, Reason = "Dialog closed" };
        }
    }

    /// <summary>
    /// Get the main window for dialog ownership.
    /// </summary>
    private Window GetMainWindow()
    {
        // This would be implemented based on your DI setup
        return App.Current?.MainWindow ?? throw new InvalidOperationException("Main window not found");
    }

    #endregion

    #region Commands

    /// <summary>
    /// Toggle agent mode on/off.
    /// </summary>
    [RelayCommand]
    private void ToggleAgentMode()
    {
        IsAgentMode = !IsAgentMode;
        _logger.LogInformation("Agent mode toggled: {State}", IsAgentMode ? "On" : "Off");
    }

    /// <summary>
    /// Cancel the current agent execution.
    /// </summary>
    [RelayCommand(CanExecute = nameof(IsAgentActive))]
    private void CancelAgentExecution()
    {
        _logger.LogInformation("Cancelling agent execution");
        _agentCancellationTokenSource?.Cancel();
    }

    #endregion

    #region Agent State Changed

    /// <summary>
    /// Handle agent state changes from the agent service.
    /// </summary>
    private void OnAgentStateChanged(object? sender, AgentStateChangedEventArgs e)
    {
        _logger.LogDebug("Agent state changed: {OldState} -> {NewState}", e.PreviousState, e.NewState);
        AgentState = e.NewState;
    }

    #endregion

    #region Message Handlers

    /// <summary>
    /// Handle toggle agent mode message (from keyboard shortcut).
    /// </summary>
    void IRecipient<ToggleAgentModeMessage>.Receive(ToggleAgentModeMessage message)
    {
        ToggleAgentMode();
    }

    /// <summary>
    /// Handle cancel agent execution message (from keyboard shortcut).
    /// </summary>
    void IRecipient<CancelAgentExecutionMessage>.Receive(CancelAgentExecutionMessage message)
    {
        if (IsAgentActive)
        {
            CancelAgentExecution();
        }
    }

    /// <summary>
    /// Handle approve tool call message (from keyboard shortcut).
    /// </summary>
    void IRecipient<ApproveToolCallMessage>.Receive(ApproveToolCallMessage message)
    {
        if (_pendingApprovalTcs is not null && IsApprovalPending)
        {
            _logger.LogDebug("Approval via keyboard: Approved (Remember: {Remember})", message.Remember);
            _pendingApprovalTcs.TrySetResult(new ApprovalDecision
            {
                Approved = true,
                RememberForSession = message.Remember
            });
        }
    }

    /// <summary>
    /// Handle deny tool call message (from keyboard shortcut).
    /// </summary>
    void IRecipient<DenyToolCallMessage>.Receive(DenyToolCallMessage message)
    {
        if (_pendingApprovalTcs is not null && IsApprovalPending)
        {
            _logger.LogDebug("Denial via keyboard");
            _pendingApprovalTcs.TrySetResult(new ApprovalDecision
            {
                Approved = false,
                Reason = message.Reason ?? "Denied via keyboard shortcut"
            });
        }
    }

    #endregion
}
```

### 2. ChatViewModel.cs (Main File Modification)

**Location**: `src/SeniorIntern.Desktop/ViewModels/ChatViewModel.cs` (modification)

```csharp
// Modify the existing SendMessageAsync method in ChatViewModel.cs

/// <summary>
/// Send the current message.
/// </summary>
[RelayCommand(CanExecute = nameof(CanSendMessage))]
private async Task SendMessageAsync()
{
    if (IsAgentMode)
    {
        await SendAgentMessageAsync();
    }
    else
    {
        await SendRegularMessageAsync();
    }
}

/// <summary>
/// Whether a message can be sent.
/// </summary>
private bool CanSendMessage =>
    !string.IsNullOrWhiteSpace(UserInput) &&
    !IsAgentActive;
```

### 3. ToolResultDisplay.cs

**Location**: `src/SeniorIntern.Desktop/Models/ToolResultDisplay.cs`

```csharp
namespace SeniorIntern.Desktop.Models;

using System;

/// <summary>
/// Display model for tool execution results in chat messages.
/// </summary>
public class ToolResultDisplay
{
    /// <summary>
    /// Tool identifier/name.
    /// </summary>
    public string ToolName { get; init; } = string.Empty;

    /// <summary>
    /// Whether the tool execution succeeded.
    /// </summary>
    public bool Success { get; init; }

    /// <summary>
    /// Brief summary of the result.
    /// </summary>
    public string Summary { get; init; } = string.Empty;

    /// <summary>
    /// Execution duration.
    /// </summary>
    public TimeSpan Duration { get; init; }

    /// <summary>
    /// Detailed result or error information.
    /// </summary>
    public string? Details { get; init; }

    /// <summary>
    /// Formatted duration string.
    /// </summary>
    public string DurationDisplay => Duration switch
    {
        { TotalMilliseconds: < 1000 } => $"{Duration.TotalMilliseconds:F0}ms",
        { TotalSeconds: < 60 } => $"{Duration.TotalSeconds:F1}s",
        _ => $"{Duration.TotalMinutes:F1}m"
    };

    /// <summary>
    /// Status icon based on success.
    /// </summary>
    public string StatusIcon => Success ? "✓" : "✗";
}
```

### 4. ChatView.axaml Additions

**Location**: `src/SeniorIntern.Desktop/Views/ChatView.axaml` (modifications)

```xml
<!-- Add to ChatView.axaml header area -->

<!-- Agent Mode Toggle -->
<ToggleButton Grid.Column="1"
              Content="{Binding AgentModeText}"
              IsChecked="{Binding IsAgentMode}"
              Classes="agent-mode-toggle"
              ToolTip.Tip="Toggle agent mode (Ctrl+Shift+A)"
              Margin="8,0" />

<!-- Cancel Button (visible when agent active) -->
<Button Grid.Column="2"
        Content="Cancel"
        Command="{Binding CancelAgentExecutionCommand}"
        IsVisible="{Binding IsAgentActive}"
        Classes="danger"
        ToolTip.Tip="Cancel execution (Escape)"
        Margin="8,0" />

<!-- Add to ChatView.axaml above the input area -->

<!-- Agent Activity Panel -->
<views:AgentActivityPanel Grid.Row="2"
                           DataContext="{Binding AgentActivityViewModel}"
                           IsVisible="{Binding IsAgentActive}"
                           Margin="0,0,0,8" />
```

### 5. ChatMessageViewModel Extensions

**Location**: `src/SeniorIntern.Desktop/ViewModels/ChatMessageViewModel.cs` (modification)

```csharp
namespace SeniorIntern.Desktop.ViewModels;

using System.Collections.ObjectModel;
using CommunityToolkit.Mvvm.ComponentModel;
using SeniorIntern.Desktop.Models;

/// <summary>
/// ViewModel for a chat message.
/// </summary>
public partial class ChatMessageViewModel : ViewModelBase
{
    // ... existing properties ...

    /// <summary>
    /// Tool execution results associated with this message.
    /// </summary>
    [ObservableProperty]
    private ObservableCollection<ToolResultDisplay>? _toolResults;

    /// <summary>
    /// Whether this message has tool results.
    /// </summary>
    public bool HasToolResults => ToolResults?.Count > 0;
}
```

---

## File Summary

| File | Location | Purpose | Lines |
|------|----------|---------|-------|
| `ChatViewModel.Agent.cs` | `ViewModels/` | Partial class for agent integration | ~400 |
| `ChatViewModel.cs` | `ViewModels/` | Modification: SendMessage routing | ~20 |
| `ToolResultDisplay.cs` | `Models/` | Tool result display model | ~50 |
| `ChatView.axaml` | `Views/` | UI additions for agent mode | ~30 |
| `ChatMessageViewModel.cs` | `ViewModels/` | Add ToolResults property | ~15 |

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | Agent mode toggle works via button |
| AC-2 | Agent mode toggle works via keyboard shortcut (Ctrl+Shift+A) |
| AC-3 | SendMessage routes to agent or regular based on mode |
| AC-4 | Agent events handled and displayed in activity panel |
| AC-5 | Approval dialog appears for risky tools |
| AC-6 | Keyboard shortcuts work for approval/denial |
| AC-7 | Cancellation stops agent execution |
| AC-8 | Tool results displayed in message |
| AC-9 | Conversation saved after agent completion |
| AC-10 | Message handlers registered correctly |

---

## Changelog Entry

```markdown
## v0.6.5h - ChatViewModel Agent Integration

### Added
- `ChatViewModel.Agent.cs` partial class
  - Agent mode properties: IsAgentMode, AgentState, AgentActivities, AgentActivityViewModel, PendingApproval
  - Computed properties: AgentModeText, SendButtonText, IsAgentActive, IsApprovalPending, IsChatInputFocused
  - Commands: ToggleAgentModeCommand, CancelAgentExecutionCommand
  - InitializeAgentMode() and CleanupAgentMode() methods
  - SendAgentMessageAsync() with full event loop
  - HandleAgentEventAsync() - handles all 9 event types
  - ShowApprovalDialogAsync() - races dialog vs keyboard shortcuts
  - IRecipient implementations for 4 message types
- `ToolResultDisplay` model
  - Properties: ToolName, Success, Summary, Duration, Details
  - Computed: DurationDisplay, StatusIcon
- ChatView.axaml additions
  - Agent mode toggle button
  - Cancel button (visible when agent active)
  - AgentActivityPanel integration
- ChatMessageViewModel extension
  - ToolResults collection property
  - HasToolResults computed property

### Modified
- `ChatViewModel.SendMessageAsync()` - routes to agent or regular mode

### Event Handling
| Event Type | Handler Action |
|------------|----------------|
| TextGenerationEvent | Append to message content |
| ThinkingEvent | Add thinking activity |
| ToolCallRequestEvent | Add tool request activity |
| ApprovalRequestEvent | Show dialog, wait for decision |
| ToolExecutionEvent | Add executing activity |
| ToolResultEvent | Add result, record stats, add to message |
| IterationEvent | Increment counter |
| AgentErrorEvent | Add error activity |
| AgentCompleteEvent | Stop tracking with summary |
```

---

## Timeline Estimate

| Version | Estimated Effort |
|---------|------------------|
| v0.6.5h | 0.75 day |
