# Design Specification: AIntern v0.6.2 "Semantic Kernel Integration"

## Executive Summary

This document provides a comprehensive design specification for v0.6.2, which integrates Microsoft Semantic Kernel with LLamaSharp to enable sophisticated function calling capabilities. This sub-version delivers the agent orchestration layer that bridges the LLM with the tool framework established in v0.6.1, enabling the AI to autonomously request and execute tools while maintaining user oversight through approval flows and streaming updates.

### v0.6.2 Scope (from v0.6.0 Design Document)
- Microsoft Semantic Kernel integration with LLamaSharp connector
- IAgentService interface for managing AI agent interactions
- Agent event system for streaming updates (thinking, tool calls, results)
- Function call parsing from LLM output
- Agent loop with iteration limits and cancellation
- Prompt engineering for tool use instructions
- Conversation history management with tool results
- Approval flow integration for tool execution

---

## Sub-Part Breakdown

| Part | Name | Focus |
|------|------|-------|
| v0.6.2a | NuGet Package Integration | Semantic Kernel packages, LLamaSharp connector |
| v0.6.2b | Semantic Kernel Configuration | Configuration model, system prompts, limits |
| v0.6.2c | Agent Request Models | AgentRequest, ToolAvailabilityContext, FileContext |
| v0.6.2d | Agent State Management | AgentState enum, state transitions, events |
| v0.6.2e | Agent Event System | Event hierarchy, streaming updates, completion events |
| v0.6.2f | Tool Call Request Models | ToolCallRequest, ApprovalDecision, request lifecycle |
| v0.6.2g | Function Call Parser | Regex parsing, streaming parser, format handling |
| v0.6.2h | IAgentService Interface | Service contract, event handling, cancellation |
| v0.6.2i | AgentService Implementation | Agent loop, prompt building, tool execution flow |
| v0.6.2j | Testing Infrastructure | Unit tests, integration tests, mock scenarios |

---

## v0.6.2a: NuGet Package Integration

### Objective
Integrate Microsoft Semantic Kernel and LLamaSharp connector packages to enable AI orchestration with local LLM models, establishing the foundation for function calling capabilities.

### New Package References

```xml
<!-- Directory.Packages.props additions -->
<ItemGroup>
  <!-- Semantic Kernel Core -->
  <PackageVersion Include="Microsoft.SemanticKernel" Version="1.28.0" />
  <PackageVersion Include="Microsoft.SemanticKernel.Abstractions" Version="1.28.0" />
  <PackageVersion Include="Microsoft.SemanticKernel.Connectors.OpenAI" Version="1.28.0" />

  <!-- LLamaSharp Semantic Kernel Connector -->
  <PackageVersion Include="LLamaSharp.SemanticKernel" Version="0.17.0" />
</ItemGroup>
```

### Package Purpose Matrix

| Package | Purpose | Key Types Used |
|---------|---------|----------------|
| Microsoft.SemanticKernel | AI orchestration framework | `Kernel`, `KernelFunction`, `KernelArguments` |
| Microsoft.SemanticKernel.Abstractions | Core abstractions | `IChatCompletionService`, `ChatMessageContent` |
| Microsoft.SemanticKernel.Connectors.OpenAI | Function calling support | `OpenAIPromptExecutionSettings` |
| LLamaSharp.SemanticKernel | LLamaSharp SK bridge | `LLamaSharpChatCompletion` |

### Project File Updates

```xml
<!-- src/SeniorIntern.Services/SeniorIntern.Services.csproj additions -->
<ItemGroup>
  <PackageReference Include="Microsoft.SemanticKernel" />
  <PackageReference Include="Microsoft.SemanticKernel.Abstractions" />
  <PackageReference Include="Microsoft.SemanticKernel.Connectors.OpenAI" />
  <PackageReference Include="LLamaSharp.SemanticKernel" />
</ItemGroup>
```

### Version Compatibility Notes

```csharp
namespace SeniorIntern.Services.AI;

/// <summary>
/// Documents version compatibility requirements for SK integration.
/// </summary>
internal static class SemanticKernelVersions
{
    /// <summary>
    /// Minimum required Semantic Kernel version.
    /// Function calling support requires 1.x+.
    /// </summary>
    public const string MinimumSkVersion = "1.28.0";

    /// <summary>
    /// Compatible LLamaSharp.SemanticKernel version.
    /// Must align with LLamaSharp version used in ILlmService.
    /// </summary>
    public const string LLamaSharpSkVersion = "0.17.0";

    /// <summary>
    /// Notes on version alignment.
    /// </summary>
    /// <remarks>
    /// - LLamaSharp.SemanticKernel 0.17.x works with LLamaSharp 0.17.x
    /// - Semantic Kernel 1.28+ has stable function calling APIs
    /// - Connector APIs may change between minor versions
    /// </remarks>
    public static void ValidateVersions()
    {
        // Runtime version validation if needed
    }
}
```

### Files to Create (v0.6.2a)

| File | Purpose |
|------|---------|
| N/A | Package references only |

### Files to Modify (v0.6.2a)

| File | Changes |
|------|---------|
| `Directory.Packages.props` | Add Semantic Kernel package versions |
| `src/SeniorIntern.Services/SeniorIntern.Services.csproj` | Add package references |

### Acceptance Criteria (v0.6.2a)
- [ ] All Semantic Kernel packages resolve correctly
- [ ] LLamaSharp.SemanticKernel is compatible with existing LLamaSharp version
- [ ] Solution builds without package conflicts
- [ ] No runtime assembly loading failures

---

## v0.6.2b: Semantic Kernel Configuration

### Objective
Define comprehensive configuration options for Semantic Kernel integration, including agent loop limits, timeout settings, system prompts for tool use, and behavior customization.

### SemanticKernelConfiguration Class

```csharp
namespace SeniorIntern.Services.AI;

/// <summary>
/// Configuration settings for Semantic Kernel integration and agent behavior.
/// </summary>
public sealed class SemanticKernelConfiguration
{
    /// <summary>
    /// Whether Semantic Kernel orchestration is enabled.
    /// When disabled, falls back to basic chat without tools.
    /// </summary>
    public bool Enabled { get; set; } = true;

    /// <summary>
    /// Maximum iterations for the agent loop before forcing completion.
    /// Prevents infinite loops when the LLM keeps calling tools.
    /// </summary>
    /// <remarks>
    /// Each iteration allows one LLM generation + tool execution cycle.
    /// A value of 10 typically allows complex multi-step tasks while
    /// preventing runaway loops.
    /// </remarks>
    public int MaxAgentIterations { get; set; } = 10;

    /// <summary>
    /// Maximum number of parallel tool calls per iteration.
    /// Controls resource usage when LLM requests multiple tools at once.
    /// </summary>
    public int MaxParallelToolCalls { get; set; } = 3;

    /// <summary>
    /// Timeout for single tool execution.
    /// Tools exceeding this timeout are cancelled with an error result.
    /// </summary>
    public TimeSpan ToolExecutionTimeout { get; set; } = TimeSpan.FromMinutes(2);

    /// <summary>
    /// Overall timeout for entire agent request.
    /// Includes all iterations, tool calls, and LLM generations.
    /// </summary>
    public TimeSpan AgentRequestTimeout { get; set; } = TimeSpan.FromMinutes(10);

    /// <summary>
    /// Delay between agent iterations to prevent overwhelming the system.
    /// Set to zero for maximum speed.
    /// </summary>
    public TimeSpan IterationDelay { get; set; } = TimeSpan.FromMilliseconds(100);

    /// <summary>
    /// Whether to include tool results in conversation history.
    /// Required for the LLM to see and reason about tool outputs.
    /// </summary>
    public bool IncludeToolResultsInHistory { get; set; } = true;

    /// <summary>
    /// Maximum tokens from tool results to include in history.
    /// Large results are truncated with a note about truncation.
    /// </summary>
    public int MaxToolResultTokens { get; set; } = 4096;

    /// <summary>
    /// Whether to automatically retry failed tool calls once.
    /// Useful for transient failures but may waste resources.
    /// </summary>
    public bool AutoRetryFailedTools { get; set; } = false;

    /// <summary>
    /// System prompt additions for tool use instructions.
    /// Appended to the base system prompt when tools are available.
    /// </summary>
    public string ToolUseSystemPrompt { get; set; } = """
        You are an AI assistant with access to tools that can help you complete tasks.
        When you need to perform an action, use the appropriate tool.
        Always explain what you're doing and why before using a tool.
        After using a tool, interpret the results for the user.
        If a tool fails, explain the error and suggest alternatives.

        Important guidelines:
        - Prefer reading files before modifying them
        - Break complex tasks into smaller steps
        - Ask for confirmation before destructive operations
        - Summarize changes after completing a task
        """;

    /// <summary>
    /// Format string for tool definitions in prompts.
    /// Uses placeholders: {name}, {description}, {parameters}
    /// </summary>
    public string ToolDefinitionFormat { get; set; } = """
        ## {name}
        {description}

        Parameters:
        ```json
        {parameters}
        ```
        """;

    /// <summary>
    /// Instructions for how to format tool call requests.
    /// </summary>
    public string ToolCallFormat { get; set; } = """
        To use a tool, respond with a JSON block in this format:
        ```tool_call
        {
          "tool": "tool_id",
          "parameters": { ... }
        }
        ```

        You may include text before or after the tool call to explain your reasoning.
        Wait for the tool result before continuing with your response.
        """;

    /// <summary>
    /// Whether to stream LLM output tokens as they arrive.
    /// Disable for batch processing scenarios.
    /// </summary>
    public bool EnableStreaming { get; set; } = true;

    /// <summary>
    /// Minimum tokens to buffer before emitting a streaming event.
    /// Higher values reduce event frequency but increase latency.
    /// </summary>
    public int StreamingBufferSize { get; set; } = 1;
}
```

### Configuration Validation

```csharp
namespace SeniorIntern.Services.AI;

/// <summary>
/// Validates Semantic Kernel configuration settings.
/// </summary>
public sealed class SemanticKernelConfigurationValidator
{
    /// <summary>
    /// Validation error messages.
    /// </summary>
    public IReadOnlyList<string> Errors => _errors;
    private readonly List<string> _errors = new();

    /// <summary>
    /// Whether the configuration is valid.
    /// </summary>
    public bool IsValid => _errors.Count == 0;

    /// <summary>
    /// Validates the configuration and populates error list.
    /// </summary>
    public bool Validate(SemanticKernelConfiguration config)
    {
        _errors.Clear();

        if (config.MaxAgentIterations < 1)
            _errors.Add("MaxAgentIterations must be at least 1");

        if (config.MaxAgentIterations > 100)
            _errors.Add("MaxAgentIterations should not exceed 100");

        if (config.MaxParallelToolCalls < 1)
            _errors.Add("MaxParallelToolCalls must be at least 1");

        if (config.MaxParallelToolCalls > 10)
            _errors.Add("MaxParallelToolCalls should not exceed 10");

        if (config.ToolExecutionTimeout < TimeSpan.FromSeconds(5))
            _errors.Add("ToolExecutionTimeout must be at least 5 seconds");

        if (config.AgentRequestTimeout < config.ToolExecutionTimeout)
            _errors.Add("AgentRequestTimeout must be >= ToolExecutionTimeout");

        if (config.MaxToolResultTokens < 100)
            _errors.Add("MaxToolResultTokens must be at least 100");

        if (string.IsNullOrWhiteSpace(config.ToolUseSystemPrompt))
            _errors.Add("ToolUseSystemPrompt cannot be empty");

        return IsValid;
    }
}
```

### Files to Create (v0.6.2b)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Services/AI/SemanticKernelConfiguration.cs` | Configuration model |
| `src/SeniorIntern.Services/AI/SemanticKernelConfigurationValidator.cs` | Validation logic |

### Files to Modify (v0.6.2b)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/ISettingsService.cs` | Add SK configuration property |

### Acceptance Criteria (v0.6.2b)
- [ ] Configuration class with all documented properties
- [ ] Sensible default values for all settings
- [ ] Validation with clear error messages
- [ ] Integration with existing settings infrastructure

---

## v0.6.2c: Agent Request Models

### Objective
Define the request models that encapsulate all information needed to process an agent request, including user message, conversation context, attached files, and tool availability.

### AgentRequest Class

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Represents a request to the agent service for processing.
/// Contains the user message along with all context needed for tool execution.
/// </summary>
public sealed class AgentRequest
{
    /// <summary>
    /// The user's message to process.
    /// </summary>
    public string Message { get; init; } = string.Empty;

    /// <summary>
    /// Unique identifier for this conversation.
    /// Used for session-based permission caching and history management.
    /// </summary>
    public Guid ConversationId { get; init; } = Guid.NewGuid();

    /// <summary>
    /// Request identifier for tracking and logging.
    /// </summary>
    public Guid RequestId { get; init; } = Guid.NewGuid();

    /// <summary>
    /// Previous conversation history.
    /// Includes user messages, assistant responses, and tool results.
    /// </summary>
    public IReadOnlyList<ChatMessage>? History { get; init; }

    /// <summary>
    /// Files attached to this request (code context, references).
    /// </summary>
    public IReadOnlyList<FileContext>? AttachedFiles { get; init; }

    /// <summary>
    /// Custom system prompt to prepend.
    /// Combined with tool use prompts when tools are available.
    /// </summary>
    public string? SystemPrompt { get; init; }

    /// <summary>
    /// Context for determining which tools are available.
    /// </summary>
    public ToolAvailabilityContext? ToolContext { get; init; }

    /// <summary>
    /// Inference options for this request.
    /// </summary>
    public InferenceOptions? InferenceOptions { get; init; }

    /// <summary>
    /// Whether to enable tool calling for this request.
    /// When false, acts as a simple chat without tool access.
    /// </summary>
    public bool EnableTools { get; init; } = true;

    /// <summary>
    /// Maximum iterations for this specific request.
    /// Overrides configuration default when set.
    /// </summary>
    public int? MaxIterations { get; init; }

    /// <summary>
    /// When this request was created.
    /// </summary>
    public DateTime CreatedAt { get; init; } = DateTime.UtcNow;
}
```

### ToolAvailabilityContext Class

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Context for determining which tools are available for a request.
/// </summary>
public sealed class ToolAvailabilityContext
{
    /// <summary>
    /// Current workspace path for file system operations.
    /// Null if no workspace is open.
    /// </summary>
    public string? WorkspacePath { get; init; }

    /// <summary>
    /// Whether a workspace is currently open.
    /// Some tools require an active workspace.
    /// </summary>
    public bool HasWorkspace => !string.IsNullOrEmpty(WorkspacePath);

    /// <summary>
    /// Currently active file in the editor.
    /// Some tools use this as default context.
    /// </summary>
    public string? ActiveFilePath { get; init; }

    /// <summary>
    /// Current selection in the editor (if any).
    /// </summary>
    public TextSelection? ActiveSelection { get; init; }

    /// <summary>
    /// Explicit list of enabled tool IDs.
    /// When null, all available tools are enabled.
    /// </summary>
    public IReadOnlySet<string>? EnabledToolIds { get; init; }

    /// <summary>
    /// Explicit list of disabled tool IDs.
    /// Takes precedence over EnabledToolIds.
    /// </summary>
    public IReadOnlySet<string>? DisabledToolIds { get; init; }

    /// <summary>
    /// Tool categories to include.
    /// When null, all categories are included.
    /// </summary>
    public IReadOnlySet<ToolCategory>? EnabledCategories { get; init; }

    /// <summary>
    /// Maximum risk level allowed for auto-approval.
    /// Tools above this level require explicit user approval.
    /// </summary>
    public RiskLevel MaxAutoApprovalRiskLevel { get; init; } = RiskLevel.Safe;

    /// <summary>
    /// Whether terminal/shell tools are enabled.
    /// May be restricted in some environments.
    /// </summary>
    public bool AllowTerminalTools { get; init; } = true;

    /// <summary>
    /// Whether network tools are enabled.
    /// May be restricted for security.
    /// </summary>
    public bool AllowNetworkTools { get; init; } = true;

    /// <summary>
    /// Whether file write operations are enabled.
    /// Can be disabled for read-only sessions.
    /// </summary>
    public bool AllowFileWrites { get; init; } = true;

    /// <summary>
    /// Session-specific tool permissions already granted.
    /// </summary>
    public IReadOnlyDictionary<string, ToolPermission>? SessionPermissions { get; init; }
}
```

### FileContext Class

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Represents a file attached to an agent request for context.
/// </summary>
public sealed class FileContext
{
    /// <summary>
    /// Relative or absolute path to the file.
    /// </summary>
    public string Path { get; init; } = string.Empty;

    /// <summary>
    /// File content (may be truncated for large files).
    /// </summary>
    public string Content { get; init; } = string.Empty;

    /// <summary>
    /// Programming language (inferred from extension).
    /// </summary>
    public string? Language { get; init; }

    /// <summary>
    /// Whether the content was truncated.
    /// </summary>
    public bool IsTruncated { get; init; }

    /// <summary>
    /// Starting line number if only a portion of the file.
    /// </summary>
    public int? StartLine { get; init; }

    /// <summary>
    /// Ending line number if only a portion of the file.
    /// </summary>
    public int? EndLine { get; init; }

    /// <summary>
    /// Total size of the file in bytes.
    /// </summary>
    public long FileSizeBytes { get; init; }

    /// <summary>
    /// Last modification time.
    /// </summary>
    public DateTime? LastModified { get; init; }
}
```

### TextSelection Class

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Represents a text selection in the editor.
/// </summary>
public sealed class TextSelection
{
    /// <summary>
    /// Starting line (1-based).
    /// </summary>
    public int StartLine { get; init; }

    /// <summary>
    /// Starting column (1-based).
    /// </summary>
    public int StartColumn { get; init; }

    /// <summary>
    /// Ending line (1-based).
    /// </summary>
    public int EndLine { get; init; }

    /// <summary>
    /// Ending column (1-based).
    /// </summary>
    public int EndColumn { get; init; }

    /// <summary>
    /// The selected text content.
    /// </summary>
    public string Text { get; init; } = string.Empty;

    /// <summary>
    /// Whether this is an empty selection (cursor position only).
    /// </summary>
    public bool IsEmpty => StartLine == EndLine && StartColumn == EndColumn;
}
```

### ToolPermission Class

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Represents a permission grant for a tool in a session.
/// </summary>
public sealed class ToolPermission
{
    /// <summary>
    /// Tool ID this permission applies to.
    /// </summary>
    public string ToolId { get; init; } = string.Empty;

    /// <summary>
    /// Whether the tool is auto-approved.
    /// </summary>
    public bool AutoApproved { get; init; }

    /// <summary>
    /// Pattern for auto-approval (e.g., specific paths).
    /// </summary>
    public string? ApprovalPattern { get; init; }

    /// <summary>
    /// When this permission was granted.
    /// </summary>
    public DateTime GrantedAt { get; init; }

    /// <summary>
    /// Whether this permission persists beyond the session.
    /// </summary>
    public bool IsPersistent { get; init; }
}
```

### Files to Create (v0.6.2c)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Models/AgentRequest.cs` | Agent request model |
| `src/SeniorIntern.Core/Models/ToolAvailabilityContext.cs` | Tool context model |
| `src/SeniorIntern.Core/Models/FileContext.cs` | File context model |
| `src/SeniorIntern.Core/Models/TextSelection.cs` | Selection model |
| `src/SeniorIntern.Core/Models/ToolPermission.cs` | Permission model |

### Files to Modify (v0.6.2c)

| File | Changes |
|------|---------|
| N/A | New files only |

### Acceptance Criteria (v0.6.2c)
- [ ] AgentRequest captures all needed context
- [ ] ToolAvailabilityContext enables flexible tool filtering
- [ ] FileContext supports partial file content
- [ ] All models are immutable with init-only setters

---

## v0.6.2d: Agent State Management

### Objective
Define the agent state machine that tracks execution progress, enabling accurate UI updates and proper handling of state transitions during the agent loop.

### AgentState Enum

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Current state of the agent during request processing.
/// </summary>
public enum AgentState
{
    /// <summary>
    /// Agent is not processing any request.
    /// Ready to accept new requests.
    /// </summary>
    Idle,

    /// <summary>
    /// Agent is initializing request processing.
    /// Building prompts and preparing context.
    /// </summary>
    Initializing,

    /// <summary>
    /// LLM is generating a response.
    /// May produce text or tool call requests.
    /// </summary>
    Thinking,

    /// <summary>
    /// Agent detected a tool call in LLM output.
    /// Parsing and validating the tool request.
    /// </summary>
    ParsingToolCall,

    /// <summary>
    /// Tool call is waiting for user approval.
    /// Agent is paused until user responds.
    /// </summary>
    WaitingForApproval,

    /// <summary>
    /// Tool is currently executing.
    /// May report progress during execution.
    /// </summary>
    ExecutingTool,

    /// <summary>
    /// Processing tool result for next iteration.
    /// Formatting result for LLM consumption.
    /// </summary>
    ProcessingResult,

    /// <summary>
    /// Agent is completing the response.
    /// Final text generation without tools.
    /// </summary>
    Responding,

    /// <summary>
    /// Request was cancelled by user.
    /// </summary>
    Cancelled,

    /// <summary>
    /// An error occurred during processing.
    /// </summary>
    Error,

    /// <summary>
    /// Request completed successfully.
    /// </summary>
    Completed
}
```

### AgentStateTransition Enum

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Valid state transitions for the agent state machine.
/// </summary>
public enum AgentStateTransition
{
    Start,           // Idle -> Initializing
    BeginThinking,   // Initializing -> Thinking, ProcessingResult -> Thinking
    DetectToolCall,  // Thinking -> ParsingToolCall
    RequestApproval, // ParsingToolCall -> WaitingForApproval
    ApprovalGranted, // WaitingForApproval -> ExecutingTool
    ApprovalDenied,  // WaitingForApproval -> Thinking (with denial message)
    ToolComplete,    // ExecutingTool -> ProcessingResult
    NoToolCalls,     // Thinking -> Responding
    Complete,        // Responding -> Completed
    Cancel,          // Any -> Cancelled
    Fail             // Any -> Error
}
```

### AgentStateChangedEventArgs Class

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Event arguments for agent state changes.
/// </summary>
public sealed class AgentStateChangedEventArgs : EventArgs
{
    /// <summary>
    /// Previous state before transition.
    /// </summary>
    public AgentState PreviousState { get; init; }

    /// <summary>
    /// New current state.
    /// </summary>
    public AgentState CurrentState { get; init; }

    /// <summary>
    /// The transition that caused this change.
    /// </summary>
    public AgentStateTransition Transition { get; init; }

    /// <summary>
    /// When the transition occurred.
    /// </summary>
    public DateTime Timestamp { get; init; } = DateTime.UtcNow;

    /// <summary>
    /// Additional context about the transition.
    /// </summary>
    public string? Context { get; init; }

    /// <summary>
    /// Current iteration number in the agent loop.
    /// </summary>
    public int IterationNumber { get; init; }
}
```

### AgentStateMachine Class

```csharp
namespace SeniorIntern.Services.AI;

/// <summary>
/// Manages agent state transitions and validates state changes.
/// </summary>
public sealed class AgentStateMachine
{
    private static readonly Dictionary<(AgentState, AgentStateTransition), AgentState> ValidTransitions = new()
    {
        // Starting up
        [(AgentState.Idle, AgentStateTransition.Start)] = AgentState.Initializing,
        [(AgentState.Initializing, AgentStateTransition.BeginThinking)] = AgentState.Thinking,

        // Tool detection and execution
        [(AgentState.Thinking, AgentStateTransition.DetectToolCall)] = AgentState.ParsingToolCall,
        [(AgentState.ParsingToolCall, AgentStateTransition.RequestApproval)] = AgentState.WaitingForApproval,
        [(AgentState.WaitingForApproval, AgentStateTransition.ApprovalGranted)] = AgentState.ExecutingTool,
        [(AgentState.WaitingForApproval, AgentStateTransition.ApprovalDenied)] = AgentState.Thinking,
        [(AgentState.ExecutingTool, AgentStateTransition.ToolComplete)] = AgentState.ProcessingResult,
        [(AgentState.ProcessingResult, AgentStateTransition.BeginThinking)] = AgentState.Thinking,

        // Completion
        [(AgentState.Thinking, AgentStateTransition.NoToolCalls)] = AgentState.Responding,
        [(AgentState.Responding, AgentStateTransition.Complete)] = AgentState.Completed,

        // Auto-approval path (skip WaitingForApproval)
        [(AgentState.ParsingToolCall, AgentStateTransition.ApprovalGranted)] = AgentState.ExecutingTool,
    };

    private AgentState _currentState = AgentState.Idle;
    private int _iterationNumber;

    public AgentState CurrentState => _currentState;
    public int IterationNumber => _iterationNumber;

    public event EventHandler<AgentStateChangedEventArgs>? StateChanged;

    public bool TryTransition(AgentStateTransition transition, string? context = null)
    {
        // Cancel and Fail can occur from any state
        if (transition == AgentStateTransition.Cancel)
        {
            return ChangeState(AgentState.Cancelled, transition, context);
        }

        if (transition == AgentStateTransition.Fail)
        {
            return ChangeState(AgentState.Error, transition, context);
        }

        // Check for valid transition
        if (!ValidTransitions.TryGetValue((_currentState, transition), out var newState))
        {
            return false;
        }

        return ChangeState(newState, transition, context);
    }

    private bool ChangeState(AgentState newState, AgentStateTransition transition, string? context)
    {
        var previousState = _currentState;
        _currentState = newState;

        if (transition == AgentStateTransition.BeginThinking)
        {
            _iterationNumber++;
        }

        StateChanged?.Invoke(this, new AgentStateChangedEventArgs
        {
            PreviousState = previousState,
            CurrentState = newState,
            Transition = transition,
            Context = context,
            IterationNumber = _iterationNumber
        });

        return true;
    }

    public void Reset()
    {
        _currentState = AgentState.Idle;
        _iterationNumber = 0;
    }

    public bool IsTerminalState => _currentState is
        AgentState.Completed or AgentState.Cancelled or AgentState.Error;

    public bool CanAcceptInput => _currentState is
        AgentState.Idle or AgentState.WaitingForApproval;
}
```

### Files to Create (v0.6.2d)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Models/AgentState.cs` | State and transition enums |
| `src/SeniorIntern.Core/Models/AgentStateChangedEventArgs.cs` | State change events |
| `src/SeniorIntern.Services/AI/AgentStateMachine.cs` | State machine logic |

### Files to Modify (v0.6.2d)

| File | Changes |
|------|---------|
| N/A | New files only |

### Acceptance Criteria (v0.6.2d)
- [ ] All agent states are clearly defined
- [ ] State transitions are validated
- [ ] State machine enforces valid transitions only
- [ ] Cancel/fail can occur from any state
- [ ] State changes emit events for UI updates

---

## v0.6.2e: Agent Event System

### Objective
Define a comprehensive event hierarchy for streaming agent updates to the UI, enabling real-time feedback during LLM generation, tool execution, and approval flows.

### AgentEvent Base Class

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Base class for all events emitted during agent execution.
/// Events are streamed to the UI for real-time updates.
/// </summary>
public abstract class AgentEvent
{
    /// <summary>
    /// Unique identifier for this event.
    /// </summary>
    public Guid EventId { get; init; } = Guid.NewGuid();

    /// <summary>
    /// When this event was created.
    /// </summary>
    public DateTime Timestamp { get; init; } = DateTime.UtcNow;

    /// <summary>
    /// Request ID this event belongs to.
    /// </summary>
    public Guid RequestId { get; init; }

    /// <summary>
    /// Current iteration number when this event occurred.
    /// </summary>
    public int IterationNumber { get; init; }
}
```

### TextGenerationEvent Class

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Event for streaming text tokens from the LLM.
/// </summary>
public sealed class TextGenerationEvent : AgentEvent
{
    /// <summary>
    /// The generated token or text fragment.
    /// </summary>
    public string Token { get; init; } = string.Empty;

    /// <summary>
    /// Whether this is the final token in the generation.
    /// </summary>
    public bool IsComplete { get; init; }

    /// <summary>
    /// Cumulative token count so far.
    /// </summary>
    public int TokenCount { get; init; }

    /// <summary>
    /// Whether this text is part of thinking/reasoning vs response.
    /// </summary>
    public bool IsThinking { get; init; }
}
```

### ToolCallRequestEvent Class

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Event when the LLM requests a tool call.
/// </summary>
public sealed class ToolCallRequestEvent : AgentEvent
{
    /// <summary>
    /// The parsed tool call request.
    /// </summary>
    public ToolCallRequest Request { get; init; } = null!;

    /// <summary>
    /// Index of this tool call in the current iteration.
    /// Multiple tool calls can occur per iteration.
    /// </summary>
    public int CallIndex { get; init; }

    /// <summary>
    /// Total tool calls detected in this iteration.
    /// </summary>
    public int TotalCalls { get; init; }
}
```

### ApprovalRequestEvent Class

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Event when user approval is needed for a tool call.
/// Contains a TaskCompletionSource to wait for the decision.
/// </summary>
public sealed class ApprovalRequestEvent : AgentEvent
{
    /// <summary>
    /// The tool call requiring approval.
    /// </summary>
    public ToolCallRequest Request { get; init; } = null!;

    /// <summary>
    /// Human-readable summary of what the tool will do.
    /// </summary>
    public string Summary { get; init; } = string.Empty;

    /// <summary>
    /// Risk level for this specific invocation.
    /// </summary>
    public RiskLevel RiskLevel { get; init; }

    /// <summary>
    /// Detailed breakdown of the operation for review.
    /// </summary>
    public IReadOnlyList<string>? Details { get; init; }

    /// <summary>
    /// Suggested actions or warnings.
    /// </summary>
    public IReadOnlyList<string>? Warnings { get; init; }

    /// <summary>
    /// Task completion source for the UI to provide the decision.
    /// </summary>
    public TaskCompletionSource<ApprovalDecision> ApprovalTask { get; init; } = new();

    /// <summary>
    /// Timeout for waiting on approval.
    /// </summary>
    public TimeSpan Timeout { get; init; } = TimeSpan.FromMinutes(5);
}
```

### ToolExecutionEvent Class

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Event for tool execution status updates.
/// </summary>
public sealed class ToolExecutionEvent : AgentEvent
{
    /// <summary>
    /// Tool ID being executed.
    /// </summary>
    public string ToolId { get; init; } = string.Empty;

    /// <summary>
    /// Human-readable tool name.
    /// </summary>
    public string ToolName { get; init; } = string.Empty;

    /// <summary>
    /// Current execution status.
    /// </summary>
    public ToolExecutionStatus Status { get; init; }

    /// <summary>
    /// Progress information if available.
    /// </summary>
    public ToolProgress? Progress { get; init; }

    /// <summary>
    /// Status message for UI display.
    /// </summary>
    public string? StatusMessage { get; init; }
}

/// <summary>
/// Status of tool execution.
/// </summary>
public enum ToolExecutionStatus
{
    Starting,
    InProgress,
    Completed,
    Failed,
    Cancelled,
    TimedOut
}

/// <summary>
/// Progress information for long-running tools.
/// </summary>
public sealed class ToolProgress
{
    /// <summary>
    /// Current progress value.
    /// </summary>
    public int Current { get; init; }

    /// <summary>
    /// Total expected progress.
    /// </summary>
    public int Total { get; init; }

    /// <summary>
    /// Progress percentage (0-100).
    /// </summary>
    public int Percentage => Total > 0 ? (Current * 100) / Total : 0;

    /// <summary>
    /// Description of current operation.
    /// </summary>
    public string? Message { get; init; }
}
```

### ToolResultEvent Class

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Event when a tool completes execution.
/// </summary>
public sealed class ToolResultEvent : AgentEvent
{
    /// <summary>
    /// Tool ID that completed.
    /// </summary>
    public string ToolId { get; init; } = string.Empty;

    /// <summary>
    /// Tool execution result.
    /// </summary>
    public ToolResult Result { get; init; } = null!;

    /// <summary>
    /// Execution duration.
    /// </summary>
    public TimeSpan Duration { get; init; }
}
```

### AgentIterationEvent Class

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Event at the start of each agent loop iteration.
/// </summary>
public sealed class AgentIterationEvent : AgentEvent
{
    /// <summary>
    /// Current iteration number (1-based).
    /// </summary>
    public new int IterationNumber { get; init; }

    /// <summary>
    /// Maximum allowed iterations.
    /// </summary>
    public int MaxIterations { get; init; }

    /// <summary>
    /// Whether this is the final allowed iteration.
    /// </summary>
    public bool IsFinalIteration => IterationNumber >= MaxIterations;

    /// <summary>
    /// Tool calls executed in previous iteration.
    /// </summary>
    public int ToolCallsInPreviousIteration { get; init; }
}
```

### AgentErrorEvent Class

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Event when an error occurs during agent execution.
/// </summary>
public sealed class AgentErrorEvent : AgentEvent
{
    /// <summary>
    /// Error message.
    /// </summary>
    public string Error { get; init; } = string.Empty;

    /// <summary>
    /// Whether this error is fatal (stops execution).
    /// </summary>
    public bool IsFatal { get; init; }

    /// <summary>
    /// Error category for handling.
    /// </summary>
    public AgentErrorCategory Category { get; init; }

    /// <summary>
    /// Underlying exception if available.
    /// </summary>
    public Exception? Exception { get; init; }

    /// <summary>
    /// Suggested recovery action.
    /// </summary>
    public string? RecoveryHint { get; init; }
}

/// <summary>
/// Categories of agent errors.
/// </summary>
public enum AgentErrorCategory
{
    LlmError,
    ToolError,
    ParsingError,
    PermissionError,
    TimeoutError,
    CancellationError,
    Unknown
}
```

### AgentCompleteEvent Class

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Event when agent execution completes.
/// </summary>
public sealed class AgentCompleteEvent : AgentEvent
{
    /// <summary>
    /// Final response text.
    /// </summary>
    public string FinalResponse { get; init; } = string.Empty;

    /// <summary>
    /// Total tool calls executed.
    /// </summary>
    public int ToolCallsExecuted { get; init; }

    /// <summary>
    /// Total iterations used.
    /// </summary>
    public int TotalIterations { get; init; }

    /// <summary>
    /// Total execution duration.
    /// </summary>
    public TimeSpan TotalDuration { get; init; }

    /// <summary>
    /// Whether execution was cancelled.
    /// </summary>
    public bool WasCancelled { get; init; }

    /// <summary>
    /// Total tokens generated.
    /// </summary>
    public int TotalTokens { get; init; }

    /// <summary>
    /// Summary of tools used.
    /// </summary>
    public IReadOnlyList<ToolUsageSummary>? ToolUsage { get; init; }
}

/// <summary>
/// Summary of a tool's usage in the request.
/// </summary>
public sealed class ToolUsageSummary
{
    public string ToolId { get; init; } = string.Empty;
    public string ToolName { get; init; } = string.Empty;
    public int InvocationCount { get; init; }
    public int SuccessCount { get; init; }
    public int FailureCount { get; init; }
    public TimeSpan TotalDuration { get; init; }
}
```

### Files to Create (v0.6.2e)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Models/AgentEvent.cs` | Base event class |
| `src/SeniorIntern.Core/Models/TextGenerationEvent.cs` | Token streaming event |
| `src/SeniorIntern.Core/Models/ToolCallRequestEvent.cs` | Tool call detection event |
| `src/SeniorIntern.Core/Models/ApprovalRequestEvent.cs` | Approval request event |
| `src/SeniorIntern.Core/Models/ToolExecutionEvent.cs` | Execution status event |
| `src/SeniorIntern.Core/Models/ToolResultEvent.cs` | Tool result event |
| `src/SeniorIntern.Core/Models/AgentIterationEvent.cs` | Iteration event |
| `src/SeniorIntern.Core/Models/AgentErrorEvent.cs` | Error event |
| `src/SeniorIntern.Core/Models/AgentCompleteEvent.cs` | Completion event |

### Files to Modify (v0.6.2e)

| File | Changes |
|------|---------|
| N/A | New files only |

### Acceptance Criteria (v0.6.2e)
- [ ] Complete event hierarchy for all agent activities
- [ ] Events support streaming updates to UI
- [ ] ApprovalRequestEvent includes TaskCompletionSource for async approval
- [ ] Error events include recovery hints
- [ ] Completion event includes comprehensive statistics

---

## v0.6.2f: Tool Call Request Models

### Objective
Define the models for representing tool call requests parsed from LLM output, including the approval decision flow and request lifecycle management.

### ToolCallRequest Class

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Represents a tool call request parsed from LLM output.
/// </summary>
public sealed class ToolCallRequest
{
    /// <summary>
    /// Unique identifier for this tool call.
    /// </summary>
    public Guid Id { get; init; } = Guid.NewGuid();

    /// <summary>
    /// Tool ID to invoke (e.g., "file-read", "terminal-execute").
    /// </summary>
    public string ToolId { get; init; } = string.Empty;

    /// <summary>
    /// Human-readable tool name.
    /// </summary>
    public string ToolName { get; init; } = string.Empty;

    /// <summary>
    /// Parameters parsed from the LLM output.
    /// </summary>
    public JsonElement Parameters { get; init; }

    /// <summary>
    /// Risk level for this specific invocation.
    /// May differ from tool default based on parameters.
    /// </summary>
    public RiskLevel RiskLevel { get; init; }

    /// <summary>
    /// Human-readable summary of what this call will do.
    /// Used in approval dialogs.
    /// </summary>
    public string ExecutionSummary { get; init; } = string.Empty;

    /// <summary>
    /// When this request was parsed.
    /// </summary>
    public DateTime RequestedAt { get; init; } = DateTime.UtcNow;

    /// <summary>
    /// Raw JSON from the LLM output.
    /// </summary>
    public string? RawJson { get; init; }

    /// <summary>
    /// Iteration number when this was requested.
    /// </summary>
    public int IterationNumber { get; init; }

    /// <summary>
    /// Validation result from pre-execution check.
    /// </summary>
    public ToolValidationResult? ValidationResult { get; init; }

    /// <summary>
    /// Whether this request passed validation.
    /// </summary>
    public bool IsValid => ValidationResult?.IsValid ?? true;
}
```

### ApprovalDecision Class

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// User's decision on a tool approval request.
/// </summary>
public sealed class ApprovalDecision
{
    /// <summary>
    /// Whether the tool call was approved.
    /// </summary>
    public bool Approved { get; init; }

    /// <summary>
    /// Reason for denial (if not approved).
    /// </summary>
    public string? Reason { get; init; }

    /// <summary>
    /// Modified parameters if user edited them.
    /// </summary>
    public JsonElement? ModifiedParameters { get; init; }

    /// <summary>
    /// Whether to remember this decision for the session.
    /// </summary>
    public bool RememberForSession { get; init; }

    /// <summary>
    /// Whether to remember this decision for this tool globally.
    /// </summary>
    public bool RememberForTool { get; init; }

    /// <summary>
    /// Pattern for remembering (e.g., specific path patterns).
    /// </summary>
    public string? RememberPattern { get; init; }

    /// <summary>
    /// When the decision was made.
    /// </summary>
    public DateTime DecidedAt { get; init; } = DateTime.UtcNow;

    /// <summary>
    /// How long the user took to decide.
    /// </summary>
    public TimeSpan DecisionDuration { get; init; }

    /// <summary>
    /// Creates an approval decision.
    /// </summary>
    public static ApprovalDecision Approve(
        bool rememberForSession = false,
        bool rememberForTool = false) => new()
    {
        Approved = true,
        RememberForSession = rememberForSession,
        RememberForTool = rememberForTool
    };

    /// <summary>
    /// Creates a denial decision.
    /// </summary>
    public static ApprovalDecision Deny(string? reason = null) => new()
    {
        Approved = false,
        Reason = reason
    };
}
```

### ToolCallLifecycle Class

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Tracks the full lifecycle of a tool call from request to completion.
/// </summary>
public sealed class ToolCallLifecycle
{
    /// <summary>
    /// The original request.
    /// </summary>
    public ToolCallRequest Request { get; init; } = null!;

    /// <summary>
    /// Current status.
    /// </summary>
    public ToolCallStatus Status { get; set; }

    /// <summary>
    /// Approval decision if required.
    /// </summary>
    public ApprovalDecision? ApprovalDecision { get; set; }

    /// <summary>
    /// Execution result.
    /// </summary>
    public ToolResult? Result { get; set; }

    /// <summary>
    /// When execution started.
    /// </summary>
    public DateTime? ExecutionStarted { get; set; }

    /// <summary>
    /// When execution completed.
    /// </summary>
    public DateTime? ExecutionCompleted { get; set; }

    /// <summary>
    /// Execution duration.
    /// </summary>
    public TimeSpan? Duration =>
        ExecutionStarted.HasValue && ExecutionCompleted.HasValue
            ? ExecutionCompleted - ExecutionStarted
            : null;

    /// <summary>
    /// Error message if failed.
    /// </summary>
    public string? ErrorMessage { get; set; }
}

/// <summary>
/// Status of a tool call in its lifecycle.
/// </summary>
public enum ToolCallStatus
{
    Parsed,
    Validating,
    ValidationFailed,
    AwaitingApproval,
    Approved,
    Denied,
    Executing,
    Completed,
    Failed,
    Cancelled,
    TimedOut
}
```

### Files to Create (v0.6.2f)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Models/ToolCallRequest.cs` | Tool call request model |
| `src/SeniorIntern.Core/Models/ApprovalDecision.cs` | Approval decision model |
| `src/SeniorIntern.Core/Models/ToolCallLifecycle.cs` | Lifecycle tracking |

### Files to Modify (v0.6.2f)

| File | Changes |
|------|---------|
| N/A | New files only |

### Acceptance Criteria (v0.6.2f)
- [ ] ToolCallRequest captures all parsed data
- [ ] ApprovalDecision supports remember options
- [ ] ToolCallLifecycle tracks full request lifecycle
- [ ] Status enum covers all possible states

---

## v0.6.2g: Function Call Parser

### Objective
Implement robust parsing of tool calls from LLM output, supporting both batch parsing of complete responses and streaming parsing of tokens as they arrive.

### FunctionCallParser Class

```csharp
namespace SeniorIntern.Services.AI;

using System.Text.Json;
using System.Text.RegularExpressions;

/// <summary>
/// Parses tool call requests from LLM output.
/// Supports both batch and streaming parsing modes.
/// </summary>
public sealed partial class FunctionCallParser
{
    private readonly IToolRegistry _toolRegistry;
    private readonly ILogger<FunctionCallParser> _logger;

    // Primary pattern: ```tool_call ... ```
    [GeneratedRegex(
        @"```tool_call\s*\n(?<json>\{[\s\S]*?\})\s*\n```",
        RegexOptions.Multiline | RegexOptions.Compiled)]
    private static partial Regex ToolCallBlockRegex();

    // Alternative pattern: JSON object with "tool" property
    [GeneratedRegex(
        @"\{[^{}]*""tool""\s*:\s*""(?<tool>[^""]+)""[^{}]*""parameters""\s*:\s*(?<params>\{[^{}]*\})[^{}]*\}",
        RegexOptions.Compiled)]
    private static partial Regex InlineToolCallRegex();

    // Opening pattern for streaming detection
    [GeneratedRegex(@"```tool_call\s*\n?", RegexOptions.Compiled)]
    private static partial Regex ToolCallOpenRegex();

    public FunctionCallParser(
        IToolRegistry toolRegistry,
        ILogger<FunctionCallParser> logger)
    {
        _toolRegistry = toolRegistry;
        _logger = logger;
    }

    /// <summary>
    /// Parse all tool calls from a complete response.
    /// </summary>
    public IReadOnlyList<ToolCallRequest> Parse(string content)
    {
        var requests = new List<ToolCallRequest>();

        // Try primary pattern first
        var matches = ToolCallBlockRegex().Matches(content);

        foreach (Match match in matches)
        {
            try
            {
                var request = ParseToolCallJson(match.Groups["json"].Value);
                if (request != null)
                {
                    requests.Add(request);
                }
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Failed to parse tool call block");
            }
        }

        // If no primary matches, try alternative pattern
        if (requests.Count == 0)
        {
            var altMatches = InlineToolCallRegex().Matches(content);
            foreach (Match match in altMatches)
            {
                try
                {
                    var request = ParseInlineToolCall(
                        match.Groups["tool"].Value,
                        match.Groups["params"].Value);
                    if (request != null)
                    {
                        requests.Add(request);
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogWarning(ex, "Failed to parse inline tool call");
                }
            }
        }

        return requests;
    }

    private ToolCallRequest? ParseToolCallJson(string json)
    {
        using var doc = JsonDocument.Parse(json);
        var root = doc.RootElement;

        var toolId = root.GetProperty("tool").GetString()
            ?? throw new JsonException("Missing 'tool' property");

        var parameters = root.TryGetProperty("parameters", out var p)
            ? p.Clone()
            : JsonDocument.Parse("{}").RootElement;

        var tool = _toolRegistry.GetTool(toolId);

        return new ToolCallRequest
        {
            ToolId = toolId,
            ToolName = tool?.Name ?? toolId,
            Parameters = parameters,
            RiskLevel = tool?.GetEffectiveRiskLevel(parameters) ?? RiskLevel.Medium,
            ExecutionSummary = tool?.GetExecutionSummary(parameters) ?? $"Execute {toolId}",
            RawJson = json
        };
    }

    private ToolCallRequest? ParseInlineToolCall(string toolId, string paramsJson)
    {
        var parameters = JsonDocument.Parse(paramsJson).RootElement;
        var tool = _toolRegistry.GetTool(toolId);

        return new ToolCallRequest
        {
            ToolId = toolId,
            ToolName = tool?.Name ?? toolId,
            Parameters = parameters,
            RiskLevel = tool?.GetEffectiveRiskLevel(parameters) ?? RiskLevel.Medium,
            ExecutionSummary = tool?.GetExecutionSummary(parameters) ?? $"Execute {toolId}"
        };
    }

    /// <summary>
    /// Extract non-tool-call text from a response.
    /// Returns the response with tool call blocks removed.
    /// </summary>
    public string ExtractText(string content)
    {
        // Remove tool call blocks
        var text = ToolCallBlockRegex().Replace(content, "");

        // Clean up extra whitespace
        text = Regex.Replace(text, @"\n{3,}", "\n\n");

        return text.Trim();
    }
}
```

### StreamingFunctionCallParser Class

```csharp
namespace SeniorIntern.Services.AI;

/// <summary>
/// Parses tool calls from streaming LLM output token by token.
/// </summary>
public sealed class StreamingFunctionCallParser
{
    private readonly FunctionCallParser _batchParser;
    private readonly StringBuilder _buffer = new();
    private readonly StringBuilder _textBuffer = new();

    private ParserState _state = ParserState.Text;
    private int _braceDepth;

    public StreamingFunctionCallParser(FunctionCallParser batchParser)
    {
        _batchParser = batchParser;
    }

    /// <summary>
    /// Process a streaming token and detect tool calls.
    /// </summary>
    public ParseResult ProcessToken(string token)
    {
        _buffer.Append(token);
        var content = _buffer.ToString();

        switch (_state)
        {
            case ParserState.Text:
                return ProcessTextState(token, content);

            case ParserState.InToolCallOpening:
                return ProcessToolCallOpening(content);

            case ParserState.InToolCallJson:
                return ProcessToolCallJson(token, content);

            case ParserState.InToolCallClosing:
                return ProcessToolCallClosing(content);

            default:
                return new ParseResult { IsText = true, Text = token };
        }
    }

    private ParseResult ProcessTextState(string token, string content)
    {
        // Check for start of tool call block
        if (content.Contains("```tool_call"))
        {
            _state = ParserState.InToolCallOpening;

            // Emit any text before the tool call
            var toolCallIndex = content.IndexOf("```tool_call");
            if (toolCallIndex > 0)
            {
                var textBefore = content[..toolCallIndex];
                _buffer.Clear();
                _buffer.Append(content[toolCallIndex..]);
                return new ParseResult { IsText = true, Text = textBefore };
            }

            return new ParseResult { IsBuffering = true };
        }

        // Regular text - check if we might be starting a tool call
        if (content.EndsWith("`") || content.EndsWith("``"))
        {
            // Might be start of ```, buffer
            return new ParseResult { IsBuffering = true };
        }

        // Emit text
        _buffer.Clear();
        return new ParseResult { IsText = true, Text = token };
    }

    private ParseResult ProcessToolCallOpening(string content)
    {
        // Look for the opening brace
        var jsonStart = content.IndexOf('{');
        if (jsonStart >= 0)
        {
            _state = ParserState.InToolCallJson;
            _braceDepth = 1;
            // Keep buffering, we need the full JSON
        }

        return new ParseResult { IsBuffering = true };
    }

    private ParseResult ProcessToolCallJson(string token, string content)
    {
        // Track brace depth
        foreach (var c in token)
        {
            if (c == '{') _braceDepth++;
            else if (c == '}') _braceDepth--;
        }

        if (_braceDepth == 0)
        {
            _state = ParserState.InToolCallClosing;
        }

        return new ParseResult { IsBuffering = true };
    }

    private ParseResult ProcessToolCallClosing(string content)
    {
        // Look for closing ```
        if (content.Contains("```", StringComparison.Ordinal) &&
            content.LastIndexOf("```") > content.IndexOf('{'))
        {
            // Complete tool call block
            var requests = _batchParser.Parse(content);
            _buffer.Clear();
            _state = ParserState.Text;

            if (requests.Count > 0)
            {
                return new ParseResult
                {
                    IsToolCall = true,
                    ToolCall = requests[0]
                };
            }
        }

        return new ParseResult { IsBuffering = true };
    }

    /// <summary>
    /// Reset parser state for a new response.
    /// </summary>
    public void Reset()
    {
        _buffer.Clear();
        _textBuffer.Clear();
        _state = ParserState.Text;
        _braceDepth = 0;
    }

    /// <summary>
    /// Get any remaining buffered content.
    /// </summary>
    public string Flush()
    {
        var remaining = _buffer.ToString();
        _buffer.Clear();
        return remaining;
    }

    private enum ParserState
    {
        Text,
        InToolCallOpening,
        InToolCallJson,
        InToolCallClosing
    }
}

/// <summary>
/// Result of parsing a streaming token.
/// </summary>
public sealed class ParseResult
{
    /// <summary>
    /// This is regular text content.
    /// </summary>
    public bool IsText { get; init; }

    /// <summary>
    /// The text content (when IsText is true).
    /// </summary>
    public string? Text { get; init; }

    /// <summary>
    /// A complete tool call was detected.
    /// </summary>
    public bool IsToolCall { get; init; }

    /// <summary>
    /// The parsed tool call (when IsToolCall is true).
    /// </summary>
    public ToolCallRequest? ToolCall { get; init; }

    /// <summary>
    /// Content is being buffered (potential tool call in progress).
    /// </summary>
    public bool IsBuffering { get; init; }
}
```

### Files to Create (v0.6.2g)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Services/AI/FunctionCallParser.cs` | Batch parser |
| `src/SeniorIntern.Services/AI/StreamingFunctionCallParser.cs` | Streaming parser |
| `src/SeniorIntern.Services/AI/ParseResult.cs` | Parse result model |

### Files to Modify (v0.6.2g)

| File | Changes |
|------|---------|
| N/A | New files only |

### Acceptance Criteria (v0.6.2g)
- [ ] Batch parser handles ```tool_call``` blocks
- [ ] Batch parser handles alternative JSON formats
- [ ] Streaming parser detects tool calls token-by-token
- [ ] Parser extracts text content separately from tool calls
- [ ] Parser handles malformed JSON gracefully

---

## v0.6.2h: IAgentService Interface

### Objective
Define the service interface for agent orchestration, establishing the contract for processing messages with tool execution, cancellation, and event streaming.

### IAgentService Interface

```csharp
namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Service for managing AI agent interactions with tool capabilities.
/// Orchestrates the agent loop, tool execution, and approval flows.
/// </summary>
public interface IAgentService
{
    /// <summary>
    /// Process a user message with potential tool execution.
    /// Yields events as processing progresses.
    /// </summary>
    /// <param name="request">The agent request with message and context</param>
    /// <param name="ct">Cancellation token</param>
    /// <returns>Async enumerable of agent events</returns>
    IAsyncEnumerable<AgentEvent> ProcessMessageAsync(
        AgentRequest request,
        CancellationToken ct = default);

    /// <summary>
    /// Cancel the current agent execution.
    /// </summary>
    Task CancelAsync();

    /// <summary>
    /// Current state of the agent.
    /// </summary>
    AgentState State { get; }

    /// <summary>
    /// Whether the agent is currently processing a request.
    /// </summary>
    bool IsProcessing { get; }

    /// <summary>
    /// Current iteration number if processing.
    /// </summary>
    int CurrentIteration { get; }

    /// <summary>
    /// Event fired when agent state changes.
    /// </summary>
    event EventHandler<AgentStateChangedEventArgs>? StateChanged;

    /// <summary>
    /// Provide an approval decision for a pending tool call.
    /// Called by UI when user responds to an approval request.
    /// </summary>
    /// <param name="requestId">The tool call request ID</param>
    /// <param name="decision">The user's decision</param>
    Task ProvideApprovalAsync(Guid requestId, ApprovalDecision decision);
}
```

### IPermissionManager Interface

```csharp
namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Manages tool execution permissions and approval caching.
/// </summary>
public interface IPermissionManager
{
    /// <summary>
    /// Check if a tool call requires approval.
    /// </summary>
    Task<PermissionCheckResult> CheckPermissionAsync(ToolCallRequest request);

    /// <summary>
    /// Remember a user's approval decision.
    /// </summary>
    Task RememberDecisionAsync(string toolId, ApprovalDecision decision);

    /// <summary>
    /// Clear session-based permission cache.
    /// </summary>
    Task ClearSessionPermissionsAsync();

    /// <summary>
    /// Get current permission settings for a tool.
    /// </summary>
    Task<ToolPermissionSettings?> GetToolPermissionsAsync(string toolId);

    /// <summary>
    /// Set permission settings for a tool.
    /// </summary>
    Task SetToolPermissionsAsync(string toolId, ToolPermissionSettings settings);
}

/// <summary>
/// Result of a permission check.
/// </summary>
public sealed class PermissionCheckResult
{
    /// <summary>
    /// Whether the tool call is allowed without approval.
    /// </summary>
    public bool IsAllowed { get; init; }

    /// <summary>
    /// Whether explicit user approval is required.
    /// </summary>
    public bool RequiresApproval { get; init; }

    /// <summary>
    /// Reason for requiring approval.
    /// </summary>
    public string? ApprovalReason { get; init; }

    /// <summary>
    /// Whether this permission was from cached decision.
    /// </summary>
    public bool WasCached { get; init; }
}

/// <summary>
/// Persistent permission settings for a tool.
/// </summary>
public sealed class ToolPermissionSettings
{
    public string ToolId { get; init; } = string.Empty;
    public bool AlwaysAllow { get; init; }
    public bool AlwaysDeny { get; init; }
    public IReadOnlyList<string>? AllowedPatterns { get; init; }
    public IReadOnlyList<string>? DeniedPatterns { get; init; }
}
```

### Files to Create (v0.6.2h)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/IAgentService.cs` | Agent service interface |
| `src/SeniorIntern.Core/Interfaces/IPermissionManager.cs` | Permission manager interface |
| `src/SeniorIntern.Core/Models/PermissionCheckResult.cs` | Permission check result |
| `src/SeniorIntern.Core/Models/ToolPermissionSettings.cs` | Permission settings |

### Files to Modify (v0.6.2h)

| File | Changes |
|------|---------|
| N/A | New files only |

### Acceptance Criteria (v0.6.2h)
- [ ] IAgentService supports async enumerable event streaming
- [ ] Cancellation is properly supported
- [ ] State tracking is accessible
- [ ] Approval flow integration via ProvideApprovalAsync
- [ ] IPermissionManager handles permission caching

---

## v0.6.2i: AgentService Implementation

### Objective
Implement the core agent service that orchestrates the agent loop, integrating LLM generation, tool call parsing, approval flows, and tool execution with streaming event updates.

### AgentService Class

```csharp
namespace SeniorIntern.Services.AI;

using System.Runtime.CompilerServices;

/// <summary>
/// Implementation of the agent service that orchestrates AI interactions with tool capabilities.
/// </summary>
public sealed class AgentService : IAgentService, IDisposable
{
    private readonly ILlmService _llmService;
    private readonly IToolRegistry _toolRegistry;
    private readonly IToolExecutionService _toolExecutionService;
    private readonly IPermissionManager _permissionManager;
    private readonly IConversationService _conversationService;
    private readonly FunctionCallParser _functionCallParser;
    private readonly SemanticKernelConfiguration _config;
    private readonly ILogger<AgentService> _logger;

    private readonly AgentStateMachine _stateMachine = new();
    private readonly ConcurrentDictionary<Guid, TaskCompletionSource<ApprovalDecision>> _pendingApprovals = new();

    private CancellationTokenSource? _cts;
    private Guid _currentRequestId;

    public AgentState State => _stateMachine.CurrentState;
    public bool IsProcessing => !_stateMachine.IsTerminalState && State != AgentState.Idle;
    public int CurrentIteration => _stateMachine.IterationNumber;

    public event EventHandler<AgentStateChangedEventArgs>? StateChanged
    {
        add => _stateMachine.StateChanged += value;
        remove => _stateMachine.StateChanged -= value;
    }

    public AgentService(
        ILlmService llmService,
        IToolRegistry toolRegistry,
        IToolExecutionService toolExecutionService,
        IPermissionManager permissionManager,
        IConversationService conversationService,
        FunctionCallParser functionCallParser,
        IOptions<SemanticKernelConfiguration> config,
        ILogger<AgentService> logger)
    {
        _llmService = llmService;
        _toolRegistry = toolRegistry;
        _toolExecutionService = toolExecutionService;
        _permissionManager = permissionManager;
        _conversationService = conversationService;
        _functionCallParser = functionCallParser;
        _config = config.Value;
        _logger = logger;
    }

    public async IAsyncEnumerable<AgentEvent> ProcessMessageAsync(
        AgentRequest request,
        [EnumeratorCancellation] CancellationToken ct = default)
    {
        _currentRequestId = request.RequestId;
        _cts = CancellationTokenSource.CreateLinkedTokenSource(ct);

        using var timeoutCts = new CancellationTokenSource(_config.AgentRequestTimeout);
        using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(
            _cts.Token, timeoutCts.Token);
        var linkedCt = linkedCts.Token;

        var startTime = DateTime.UtcNow;
        var toolCallsExecuted = 0;
        var totalTokens = 0;
        var responseBuilder = new StringBuilder();
        var toolUsageTracker = new Dictionary<string, ToolUsageSummary>();

        _stateMachine.Reset();
        _stateMachine.TryTransition(AgentStateTransition.Start);

        // Build initial conversation history
        var history = BuildConversationHistory(request);

        try
        {
            var maxIterations = request.MaxIterations ?? _config.MaxAgentIterations;

            while (_stateMachine.IterationNumber < maxIterations && !linkedCt.IsCancellationRequested)
            {
                _stateMachine.TryTransition(AgentStateTransition.BeginThinking);

                yield return new AgentIterationEvent
                {
                    RequestId = request.RequestId,
                    IterationNumber = _stateMachine.IterationNumber,
                    MaxIterations = maxIterations,
                    ToolCallsInPreviousIteration = toolCallsExecuted
                };

                // Build prompt with available tools
                var availableTools = request.EnableTools
                    ? _toolRegistry.GetAvailableTools(request.ToolContext)
                    : Array.Empty<ITool>();

                var prompt = BuildPromptWithTools(
                    history,
                    availableTools,
                    request.SystemPrompt);

                // Stream LLM response
                var iterationResponse = new StringBuilder();
                var toolCalls = new List<ToolCallRequest>();
                var streamingParser = new StreamingFunctionCallParser(_functionCallParser);

                await foreach (var token in _llmService.GenerateStreamingAsync(
                    prompt,
                    request.InferenceOptions ?? GetDefaultInferenceOptions(),
                    linkedCt))
                {
                    totalTokens++;

                    var parseResult = streamingParser.ProcessToken(token);

                    if (parseResult.IsText && !string.IsNullOrEmpty(parseResult.Text))
                    {
                        iterationResponse.Append(parseResult.Text);
                        responseBuilder.Append(parseResult.Text);

                        yield return new TextGenerationEvent
                        {
                            RequestId = request.RequestId,
                            IterationNumber = _stateMachine.IterationNumber,
                            Token = parseResult.Text,
                            TokenCount = totalTokens
                        };
                    }
                    else if (parseResult.IsToolCall && parseResult.ToolCall != null)
                    {
                        _stateMachine.TryTransition(AgentStateTransition.DetectToolCall);

                        var toolCall = parseResult.ToolCall with
                        {
                            IterationNumber = _stateMachine.IterationNumber
                        };

                        toolCalls.Add(toolCall);

                        yield return new ToolCallRequestEvent
                        {
                            RequestId = request.RequestId,
                            IterationNumber = _stateMachine.IterationNumber,
                            Request = toolCall,
                            CallIndex = toolCalls.Count - 1,
                            TotalCalls = toolCalls.Count
                        };
                    }
                }

                // Flush any remaining content
                var remaining = streamingParser.Flush();
                if (!string.IsNullOrEmpty(remaining))
                {
                    responseBuilder.Append(remaining);
                    yield return new TextGenerationEvent
                    {
                        RequestId = request.RequestId,
                        IterationNumber = _stateMachine.IterationNumber,
                        Token = remaining,
                        TokenCount = totalTokens
                    };
                }

                // If no tool calls, we're done
                if (toolCalls.Count == 0)
                {
                    _stateMachine.TryTransition(AgentStateTransition.NoToolCalls);
                    yield return new TextGenerationEvent
                    {
                        RequestId = request.RequestId,
                        IterationNumber = _stateMachine.IterationNumber,
                        IsComplete = true,
                        TokenCount = totalTokens
                    };
                    break;
                }

                // Add assistant message to history
                history.Add(new ChatMessage
                {
                    Role = MessageRole.Assistant,
                    Content = iterationResponse.ToString()
                });

                // Process tool calls
                foreach (var toolCall in toolCalls)
                {
                    var toolResult = await ProcessToolCallAsync(
                        request, toolCall, toolUsageTracker, linkedCt);

                    if (toolResult != null)
                    {
                        yield return toolResult.Event;

                        // Add tool result to history
                        if (_config.IncludeToolResultsInHistory)
                        {
                            history.Add(new ChatMessage
                            {
                                Role = MessageRole.Tool,
                                Content = FormatToolResultForHistory(toolCall, toolResult.Result)
                            });
                        }

                        if (toolResult.Result.IsSuccess)
                        {
                            toolCallsExecuted++;
                        }
                    }
                }

                // Small delay between iterations
                if (_config.IterationDelay > TimeSpan.Zero)
                {
                    await Task.Delay(_config.IterationDelay, linkedCt);
                }
            }

            _stateMachine.TryTransition(AgentStateTransition.Complete);

            yield return new AgentCompleteEvent
            {
                RequestId = request.RequestId,
                FinalResponse = responseBuilder.ToString(),
                ToolCallsExecuted = toolCallsExecuted,
                TotalIterations = _stateMachine.IterationNumber,
                TotalDuration = DateTime.UtcNow - startTime,
                TotalTokens = totalTokens,
                ToolUsage = toolUsageTracker.Values.ToList()
            };
        }
        catch (OperationCanceledException) when (timeoutCts.IsCancellationRequested)
        {
            _stateMachine.TryTransition(AgentStateTransition.Fail, "Request timed out");

            yield return new AgentErrorEvent
            {
                RequestId = request.RequestId,
                Error = "Request timed out",
                IsFatal = true,
                Category = AgentErrorCategory.TimeoutError
            };
        }
        catch (OperationCanceledException)
        {
            _stateMachine.TryTransition(AgentStateTransition.Cancel);

            yield return new AgentCompleteEvent
            {
                RequestId = request.RequestId,
                FinalResponse = responseBuilder.ToString(),
                ToolCallsExecuted = toolCallsExecuted,
                TotalIterations = _stateMachine.IterationNumber,
                TotalDuration = DateTime.UtcNow - startTime,
                WasCancelled = true
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Agent processing failed");
            _stateMachine.TryTransition(AgentStateTransition.Fail, ex.Message);

            yield return new AgentErrorEvent
            {
                RequestId = request.RequestId,
                Error = ex.Message,
                IsFatal = true,
                Category = AgentErrorCategory.Unknown,
                Exception = ex
            };
        }
        finally
        {
            _cts?.Dispose();
            _cts = null;
            _pendingApprovals.Clear();
        }
    }

    private async Task<(ToolResultEvent Event, ToolResult Result)?> ProcessToolCallAsync(
        AgentRequest request,
        ToolCallRequest toolCall,
        Dictionary<string, ToolUsageSummary> usageTracker,
        CancellationToken ct)
    {
        var startTime = DateTime.UtcNow;

        // Validate tool call
        var tool = _toolRegistry.GetTool(toolCall.ToolId);
        if (tool == null)
        {
            return CreateToolResultEvent(toolCall,
                ToolResult.Failed($"Tool not found: {toolCall.ToolId}"),
                DateTime.UtcNow - startTime);
        }

        var validation = tool.Validate(toolCall.Parameters);
        if (!validation.IsValid)
        {
            return CreateToolResultEvent(toolCall,
                ToolResult.Failed($"Validation failed: {string.Join(", ", validation.Errors)}"),
                DateTime.UtcNow - startTime);
        }

        // Check permission
        var permission = await _permissionManager.CheckPermissionAsync(toolCall);

        if (permission.RequiresApproval)
        {
            _stateMachine.TryTransition(AgentStateTransition.RequestApproval);

            var approvalTcs = new TaskCompletionSource<ApprovalDecision>();
            _pendingApprovals[toolCall.Id] = approvalTcs;

            // The UI will receive this event and call ProvideApprovalAsync
            // We yield this event separately, not from this method

            try
            {
                var decision = await approvalTcs.Task.WaitAsync(
                    TimeSpan.FromMinutes(5), ct);

                if (!decision.Approved)
                {
                    _stateMachine.TryTransition(AgentStateTransition.ApprovalDenied);
                    return CreateToolResultEvent(toolCall,
                        ToolResult.Failed($"Denied: {decision.Reason ?? "User denied"}"),
                        DateTime.UtcNow - startTime);
                }

                // Remember decision if requested
                if (decision.RememberForSession || decision.RememberForTool)
                {
                    await _permissionManager.RememberDecisionAsync(toolCall.ToolId, decision);
                }

                _stateMachine.TryTransition(AgentStateTransition.ApprovalGranted);
            }
            catch (TimeoutException)
            {
                return CreateToolResultEvent(toolCall,
                    ToolResult.Failed("Approval timed out"),
                    DateTime.UtcNow - startTime);
            }
            finally
            {
                _pendingApprovals.TryRemove(toolCall.Id, out _);
            }
        }
        else
        {
            _stateMachine.TryTransition(AgentStateTransition.ApprovalGranted);
        }

        // Execute tool
        var context = new ToolExecutionContext
        {
            SessionId = request.ConversationId,
            WorkspacePath = request.ToolContext?.WorkspacePath,
            Parameters = toolCall.Parameters,
            CancellationToken = ct,
            IsApproved = true
        };

        try
        {
            using var toolTimeoutCts = new CancellationTokenSource(_config.ToolExecutionTimeout);
            using var toolLinkedCts = CancellationTokenSource.CreateLinkedTokenSource(ct, toolTimeoutCts.Token);

            var result = await _toolExecutionService.ExecuteAsync(
                tool, context, toolLinkedCts.Token);

            var duration = DateTime.UtcNow - startTime;
            UpdateUsageTracker(usageTracker, toolCall, result, duration);

            _stateMachine.TryTransition(AgentStateTransition.ToolComplete);
            return CreateToolResultEvent(toolCall, result, duration);
        }
        catch (OperationCanceledException)
        {
            var duration = DateTime.UtcNow - startTime;
            var result = ToolResult.Failed("Tool execution cancelled");
            UpdateUsageTracker(usageTracker, toolCall, result, duration);
            return CreateToolResultEvent(toolCall, result, duration);
        }
        catch (Exception ex)
        {
            var duration = DateTime.UtcNow - startTime;
            var result = ToolResult.Failed(ex.Message);
            UpdateUsageTracker(usageTracker, toolCall, result, duration);
            return CreateToolResultEvent(toolCall, result, duration);
        }
    }

    public Task ProvideApprovalAsync(Guid requestId, ApprovalDecision decision)
    {
        if (_pendingApprovals.TryGetValue(requestId, out var tcs))
        {
            tcs.TrySetResult(decision);
        }
        return Task.CompletedTask;
    }

    public Task CancelAsync()
    {
        _cts?.Cancel();

        // Cancel any pending approvals
        foreach (var tcs in _pendingApprovals.Values)
        {
            tcs.TrySetCanceled();
        }

        return Task.CompletedTask;
    }

    private List<ChatMessage> BuildConversationHistory(AgentRequest request)
    {
        var history = new List<ChatMessage>();

        if (request.History != null)
        {
            history.AddRange(request.History);
        }

        history.Add(new ChatMessage
        {
            Role = MessageRole.User,
            Content = request.Message
        });

        return history;
    }

    private string BuildPromptWithTools(
        List<ChatMessage> history,
        IReadOnlyList<ITool> tools,
        string? customSystemPrompt)
    {
        var sb = new StringBuilder();

        // System prompt
        if (!string.IsNullOrEmpty(customSystemPrompt))
        {
            sb.AppendLine(customSystemPrompt);
            sb.AppendLine();
        }

        if (tools.Count > 0)
        {
            sb.AppendLine(_config.ToolUseSystemPrompt);
            sb.AppendLine();
            sb.AppendLine("Available tools:");
            sb.AppendLine();

            foreach (var tool in tools)
            {
                var toolDef = _config.ToolDefinitionFormat
                    .Replace("{name}", tool.Name)
                    .Replace("{description}", tool.Description)
                    .Replace("{parameters}", tool.InputSchema.ToJson());
                sb.AppendLine(toolDef);
                sb.AppendLine();
            }

            sb.AppendLine(_config.ToolCallFormat);
            sb.AppendLine();
        }

        // Conversation history
        foreach (var msg in history)
        {
            var role = msg.Role switch
            {
                MessageRole.User => "User",
                MessageRole.Assistant => "Assistant",
                MessageRole.System => "System",
                MessageRole.Tool => "Tool Result",
                _ => msg.Role.ToString()
            };

            sb.AppendLine($"{role}: {msg.Content}");
            sb.AppendLine();
        }

        return sb.ToString();
    }

    private string FormatToolResultForHistory(ToolCallRequest request, ToolResult result)
    {
        var content = result.IsSuccess
            ? result.Content ?? "(no output)"
            : $"Error: {result.ErrorMessage}";

        // Truncate if too long
        if (content.Length > _config.MaxToolResultTokens * 4)
        {
            content = content[..(_config.MaxToolResultTokens * 4)] +
                "\n...[truncated]";
        }

        return $"[{request.ToolName}]\n{content}";
    }

    private static (ToolResultEvent Event, ToolResult Result) CreateToolResultEvent(
        ToolCallRequest request, ToolResult result, TimeSpan duration)
    {
        return (new ToolResultEvent
        {
            ToolId = request.ToolId,
            Result = result,
            Duration = duration
        }, result);
    }

    private static void UpdateUsageTracker(
        Dictionary<string, ToolUsageSummary> tracker,
        ToolCallRequest request,
        ToolResult result,
        TimeSpan duration)
    {
        if (!tracker.TryGetValue(request.ToolId, out var summary))
        {
            summary = new ToolUsageSummary
            {
                ToolId = request.ToolId,
                ToolName = request.ToolName
            };
            tracker[request.ToolId] = summary;
        }

        // Update counts (would need mutable version or record with)
        tracker[request.ToolId] = summary with
        {
            InvocationCount = summary.InvocationCount + 1,
            SuccessCount = summary.SuccessCount + (result.IsSuccess ? 1 : 0),
            FailureCount = summary.FailureCount + (result.IsSuccess ? 0 : 1),
            TotalDuration = summary.TotalDuration + duration
        };
    }

    private InferenceOptions GetDefaultInferenceOptions() => new(
        MaxTokens: 4096,
        Temperature: 0.7f,
        TopP: 0.9f
    );

    public void Dispose()
    {
        _cts?.Dispose();
    }
}
```

### PermissionManager Implementation

```csharp
namespace SeniorIntern.Services.AI;

/// <summary>
/// Manages tool execution permissions and caching.
/// </summary>
public sealed class PermissionManager : IPermissionManager
{
    private readonly ISettingsService _settingsService;
    private readonly ConcurrentDictionary<string, ApprovalDecision> _sessionCache = new();
    private readonly ILogger<PermissionManager> _logger;

    public PermissionManager(
        ISettingsService settingsService,
        ILogger<PermissionManager> logger)
    {
        _settingsService = settingsService;
        _logger = logger;
    }

    public Task<PermissionCheckResult> CheckPermissionAsync(ToolCallRequest request)
    {
        // Check session cache first
        if (_sessionCache.TryGetValue(request.ToolId, out var cachedDecision))
        {
            if (cachedDecision.Approved)
            {
                return Task.FromResult(new PermissionCheckResult
                {
                    IsAllowed = true,
                    RequiresApproval = false,
                    WasCached = true
                });
            }
        }

        // Safe tools don't require approval
        if (request.RiskLevel == RiskLevel.Safe)
        {
            return Task.FromResult(new PermissionCheckResult
            {
                IsAllowed = true,
                RequiresApproval = false
            });
        }

        // Higher risk tools require approval
        return Task.FromResult(new PermissionCheckResult
        {
            IsAllowed = false,
            RequiresApproval = true,
            ApprovalReason = $"Tool {request.ToolName} has risk level {request.RiskLevel}"
        });
    }

    public Task RememberDecisionAsync(string toolId, ApprovalDecision decision)
    {
        if (decision.RememberForSession)
        {
            _sessionCache[toolId] = decision;
        }

        // TODO: Persist if RememberForTool

        return Task.CompletedTask;
    }

    public Task ClearSessionPermissionsAsync()
    {
        _sessionCache.Clear();
        return Task.CompletedTask;
    }

    public Task<ToolPermissionSettings?> GetToolPermissionsAsync(string toolId)
    {
        // TODO: Load from persistent storage
        return Task.FromResult<ToolPermissionSettings?>(null);
    }

    public Task SetToolPermissionsAsync(string toolId, ToolPermissionSettings settings)
    {
        // TODO: Save to persistent storage
        return Task.CompletedTask;
    }
}
```

### Files to Create (v0.6.2i)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Services/AI/AgentService.cs` | Agent service implementation |
| `src/SeniorIntern.Services/AI/PermissionManager.cs` | Permission manager implementation |

### Files to Modify (v0.6.2i)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Services/ServiceCollectionExtensions.cs` | Register AgentService and dependencies |

### Acceptance Criteria (v0.6.2i)
- [ ] Agent loop processes messages with tool support
- [ ] Streaming events are yielded during processing
- [ ] Tool calls are parsed and validated
- [ ] Approval flow works with TaskCompletionSource
- [ ] Cancellation stops processing cleanly
- [ ] Tool results are added to conversation history
- [ ] Iteration limits are enforced
- [ ] Timeouts are handled properly

---

## v0.6.2j: Testing Infrastructure

### Objective
Create comprehensive test infrastructure for the Semantic Kernel integration, including unit tests for parsing and state management, and integration tests for the agent loop with mock tools.

### Unit Tests for FunctionCallParser

```csharp
namespace SeniorIntern.Tests.Services.AI;

public class FunctionCallParserTests
{
    private readonly Mock<IToolRegistry> _mockRegistry;
    private readonly Mock<ILogger<FunctionCallParser>> _mockLogger;
    private readonly FunctionCallParser _parser;

    public FunctionCallParserTests()
    {
        _mockRegistry = new Mock<IToolRegistry>();
        _mockLogger = new Mock<ILogger<FunctionCallParser>>();
        _parser = new FunctionCallParser(_mockRegistry.Object, _mockLogger.Object);
    }

    [Fact]
    public void Parse_ValidToolCallBlock_ReturnsToolCallRequest()
    {
        // Arrange
        var content = """
            Here's what I'll do:

            ```tool_call
            {
              "tool": "file-read",
              "parameters": { "path": "src/Program.cs" }
            }
            ```

            This will read the file.
            """;

        var mockTool = new Mock<ITool>();
        mockTool.Setup(t => t.Name).Returns("Read File");
        mockTool.Setup(t => t.GetEffectiveRiskLevel(It.IsAny<JsonElement>()))
            .Returns(RiskLevel.Safe);
        mockTool.Setup(t => t.GetExecutionSummary(It.IsAny<JsonElement>()))
            .Returns("Read file 'src/Program.cs'");

        _mockRegistry.Setup(r => r.GetTool("file-read")).Returns(mockTool.Object);

        // Act
        var requests = _parser.Parse(content);

        // Assert
        Assert.Single(requests);
        Assert.Equal("file-read", requests[0].ToolId);
        Assert.Equal("Read File", requests[0].ToolName);
    }

    [Fact]
    public void Parse_MultipleToolCalls_ReturnsAllRequests()
    {
        // Arrange
        var content = """
            ```tool_call
            { "tool": "file-read", "parameters": { "path": "a.txt" } }
            ```

            ```tool_call
            { "tool": "file-read", "parameters": { "path": "b.txt" } }
            ```
            """;

        _mockRegistry.Setup(r => r.GetTool("file-read")).Returns((ITool?)null);

        // Act
        var requests = _parser.Parse(content);

        // Assert
        Assert.Equal(2, requests.Count);
    }

    [Fact]
    public void Parse_NoToolCalls_ReturnsEmptyList()
    {
        // Arrange
        var content = "Just a regular response without any tool calls.";

        // Act
        var requests = _parser.Parse(content);

        // Assert
        Assert.Empty(requests);
    }

    [Fact]
    public void Parse_MalformedJson_LogsWarningAndContinues()
    {
        // Arrange
        var content = """
            ```tool_call
            { invalid json }
            ```
            """;

        // Act
        var requests = _parser.Parse(content);

        // Assert
        Assert.Empty(requests);
    }

    [Fact]
    public void ExtractText_RemovesToolCallBlocks()
    {
        // Arrange
        var content = """
            Start text.

            ```tool_call
            { "tool": "test", "parameters": {} }
            ```

            End text.
            """;

        // Act
        var text = _parser.ExtractText(content);

        // Assert
        Assert.Contains("Start text", text);
        Assert.Contains("End text", text);
        Assert.DoesNotContain("tool_call", text);
    }
}
```

### Unit Tests for AgentStateMachine

```csharp
namespace SeniorIntern.Tests.Services.AI;

public class AgentStateMachineTests
{
    private readonly AgentStateMachine _stateMachine = new();

    [Fact]
    public void InitialState_IsIdle()
    {
        Assert.Equal(AgentState.Idle, _stateMachine.CurrentState);
    }

    [Fact]
    public void TryTransition_Start_MovesToInitializing()
    {
        var result = _stateMachine.TryTransition(AgentStateTransition.Start);

        Assert.True(result);
        Assert.Equal(AgentState.Initializing, _stateMachine.CurrentState);
    }

    [Fact]
    public void TryTransition_InvalidTransition_ReturnsFalse()
    {
        // Can't go directly from Idle to Thinking
        var result = _stateMachine.TryTransition(AgentStateTransition.BeginThinking);

        Assert.False(result);
        Assert.Equal(AgentState.Idle, _stateMachine.CurrentState);
    }

    [Fact]
    public void TryTransition_Cancel_WorksFromAnyState()
    {
        _stateMachine.TryTransition(AgentStateTransition.Start);
        _stateMachine.TryTransition(AgentStateTransition.BeginThinking);

        var result = _stateMachine.TryTransition(AgentStateTransition.Cancel);

        Assert.True(result);
        Assert.Equal(AgentState.Cancelled, _stateMachine.CurrentState);
    }

    [Fact]
    public void IterationNumber_IncrementsOnBeginThinking()
    {
        _stateMachine.TryTransition(AgentStateTransition.Start);
        Assert.Equal(0, _stateMachine.IterationNumber);

        _stateMachine.TryTransition(AgentStateTransition.BeginThinking);
        Assert.Equal(1, _stateMachine.IterationNumber);
    }

    [Fact]
    public void StateChanged_FiresOnTransition()
    {
        var eventFired = false;
        _stateMachine.StateChanged += (_, e) =>
        {
            eventFired = true;
            Assert.Equal(AgentState.Idle, e.PreviousState);
            Assert.Equal(AgentState.Initializing, e.CurrentState);
        };

        _stateMachine.TryTransition(AgentStateTransition.Start);

        Assert.True(eventFired);
    }
}
```

### Integration Tests for AgentService

```csharp
namespace SeniorIntern.Tests.Services.AI;

public class AgentServiceIntegrationTests : IAsyncLifetime
{
    private readonly ServiceProvider _serviceProvider;
    private readonly IAgentService _agentService;

    public AgentServiceIntegrationTests()
    {
        var services = new ServiceCollection();

        // Register mocks
        services.AddSingleton(CreateMockLlmService());
        services.AddSingleton(CreateMockToolRegistry());
        services.AddSingleton(CreateMockToolExecutionService());
        services.AddSingleton<IPermissionManager, PermissionManager>();
        services.AddSingleton(Mock.Of<IConversationService>());
        services.AddSingleton<FunctionCallParser>();
        services.Configure<SemanticKernelConfiguration>(c =>
        {
            c.MaxAgentIterations = 3;
            c.IterationDelay = TimeSpan.Zero;
        });
        services.AddLogging();
        services.AddSingleton<IAgentService, AgentService>();

        _serviceProvider = services.BuildServiceProvider();
        _agentService = _serviceProvider.GetRequiredService<IAgentService>();
    }

    [Fact]
    public async Task ProcessMessageAsync_SimpleMessage_ReturnsTextEvents()
    {
        // Arrange
        var request = new AgentRequest
        {
            Message = "Hello, how are you?",
            EnableTools = false
        };

        // Act
        var events = new List<AgentEvent>();
        await foreach (var evt in _agentService.ProcessMessageAsync(request))
        {
            events.Add(evt);
        }

        // Assert
        Assert.Contains(events, e => e is TextGenerationEvent);
        Assert.Contains(events, e => e is AgentCompleteEvent);
    }

    [Fact]
    public async Task ProcessMessageAsync_WithToolCall_ExecutesTool()
    {
        // Arrange - LLM will return a tool call
        var request = new AgentRequest
        {
            Message = "Read the file src/test.txt",
            EnableTools = true
        };

        // Act
        var events = new List<AgentEvent>();
        await foreach (var evt in _agentService.ProcessMessageAsync(request))
        {
            events.Add(evt);
        }

        // Assert
        Assert.Contains(events, e => e is ToolCallRequestEvent);
        Assert.Contains(events, e => e is ToolResultEvent);
    }

    [Fact]
    public async Task CancelAsync_StopsProcessing()
    {
        // Arrange
        var request = new AgentRequest
        {
            Message = "Do something slow",
            EnableTools = false
        };

        // Act
        var processTask = Task.Run(async () =>
        {
            var events = new List<AgentEvent>();
            await foreach (var evt in _agentService.ProcessMessageAsync(request))
            {
                events.Add(evt);
            }
            return events;
        });

        await Task.Delay(100);
        await _agentService.CancelAsync();

        var events = await processTask;

        // Assert
        var completeEvent = events.OfType<AgentCompleteEvent>().FirstOrDefault();
        Assert.NotNull(completeEvent);
        Assert.True(completeEvent.WasCancelled);
    }

    private static ILlmService CreateMockLlmService()
    {
        var mock = new Mock<ILlmService>();
        mock.Setup(s => s.IsModelLoaded).Returns(true);
        mock.Setup(s => s.GenerateStreamingAsync(
                It.IsAny<string>(),
                It.IsAny<InferenceOptions>(),
                It.IsAny<CancellationToken>()))
            .Returns(GenerateMockTokens());
        return mock.Object;
    }

    private static async IAsyncEnumerable<string> GenerateMockTokens()
    {
        yield return "Here ";
        yield return "is ";
        yield return "a ";
        yield return "response.";
        await Task.CompletedTask;
    }

    private static IToolRegistry CreateMockToolRegistry()
    {
        var mock = new Mock<IToolRegistry>();
        mock.Setup(r => r.GetAvailableTools(It.IsAny<ToolAvailabilityContext>()))
            .Returns(Array.Empty<ITool>());
        return mock.Object;
    }

    private static IToolExecutionService CreateMockToolExecutionService()
    {
        var mock = new Mock<IToolExecutionService>();
        mock.Setup(s => s.ExecuteAsync(
                It.IsAny<ITool>(),
                It.IsAny<ToolExecutionContext>(),
                It.IsAny<CancellationToken>()))
            .ReturnsAsync(ToolResult.Success("Mock result"));
        return mock.Object;
    }

    public Task InitializeAsync() => Task.CompletedTask;

    public async Task DisposeAsync()
    {
        await _serviceProvider.DisposeAsync();
    }
}
```

### Mock Tool for Testing

```csharp
namespace SeniorIntern.Tests.Mocks;

/// <summary>
/// Mock tool for testing agent behavior.
/// </summary>
public sealed class MockTool : ITool
{
    public string Id => "mock-tool";
    public string Name => "Mock Tool";
    public string Description => "A mock tool for testing";
    public ToolCategory Category => ToolCategory.Custom;
    public RiskLevel DefaultRiskLevel { get; set; } = RiskLevel.Safe;
    public JsonSchema InputSchema => new() { Type = "object" };
    public bool IsAvailable { get; set; } = true;
    public IReadOnlyList<string> Tags => Array.Empty<string>();

    public Func<ToolExecutionContext, Task<ToolResult>>? ExecuteHandler { get; set; }
    public Func<JsonElement, ToolValidationResult>? ValidateHandler { get; set; }

    public Task<ToolResult> ExecuteAsync(ToolExecutionContext context, CancellationToken ct = default)
    {
        return ExecuteHandler?.Invoke(context) ?? Task.FromResult(ToolResult.Success("Mock success"));
    }

    public ToolValidationResult Validate(JsonElement parameters)
    {
        return ValidateHandler?.Invoke(parameters) ?? ToolValidationResult.Valid();
    }

    public string GetExecutionSummary(JsonElement parameters) => "Execute mock tool";

    public RiskLevel GetEffectiveRiskLevel(JsonElement parameters) => DefaultRiskLevel;
}
```

### Files to Create (v0.6.2j)

| File | Purpose |
|------|---------|
| `tests/SeniorIntern.Tests/Services/AI/FunctionCallParserTests.cs` | Parser unit tests |
| `tests/SeniorIntern.Tests/Services/AI/StreamingFunctionCallParserTests.cs` | Streaming parser tests |
| `tests/SeniorIntern.Tests/Services/AI/AgentStateMachineTests.cs` | State machine tests |
| `tests/SeniorIntern.Tests/Services/AI/AgentServiceIntegrationTests.cs` | Integration tests |
| `tests/SeniorIntern.Tests/Services/AI/PermissionManagerTests.cs` | Permission tests |
| `tests/SeniorIntern.Tests/Mocks/MockTool.cs` | Mock tool for testing |
| `tests/SeniorIntern.Tests/Mocks/MockLlmService.cs` | Mock LLM for testing |

### Files to Modify (v0.6.2j)

| File | Changes |
|------|---------|
| N/A | New test files only |

### Acceptance Criteria (v0.6.2j)
- [ ] Parser tests cover valid and malformed input
- [ ] Streaming parser tests verify token-by-token parsing
- [ ] State machine tests verify all valid transitions
- [ ] Integration tests verify end-to-end agent loop
- [ ] Mock tools enable isolated testing
- [ ] All tests pass in CI

---

## Complete File Summary

### Files to Create (Total: 31)

| Part | Files |
|------|-------|
| v0.6.2a | 0 (package references only) |
| v0.6.2b | 2 |
| v0.6.2c | 5 |
| v0.6.2d | 3 |
| v0.6.2e | 9 |
| v0.6.2f | 3 |
| v0.6.2g | 3 |
| v0.6.2h | 4 |
| v0.6.2i | 2 |
| v0.6.2j | 7 |

### Files to Modify (Total: 3)

| File | Changes |
|------|---------|
| `Directory.Packages.props` | Add Semantic Kernel package versions |
| `src/SeniorIntern.Services/SeniorIntern.Services.csproj` | Add package references |
| `src/SeniorIntern.Services/ServiceCollectionExtensions.cs` | Register AgentService and dependencies |

---

## Dependencies

### Prerequisite Sub-Versions
- v0.6.1 (Tool Framework) - Required for ITool, IToolRegistry, ToolResult types

### External Dependencies
- Microsoft.SemanticKernel 1.28.0+
- LLamaSharp.SemanticKernel 0.17.0
- Microsoft.Extensions.Options (for configuration)
- Microsoft.Extensions.Logging (for logging)

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| SK API changes | Medium | High | Pin specific version, test upgrades |
| LLamaSharp connector compatibility | Medium | High | Version alignment with base LLamaSharp |
| Tool call parsing edge cases | High | Medium | Comprehensive parser tests, fallback patterns |
| Approval flow deadlocks | Low | High | Timeout handling, proper cancellation |
| Memory growth in agent loop | Medium | Medium | Limit history size, truncate results |

---

## Implementation Notes

1. **Streaming First**: The agent service is designed around async enumerable for streaming events, enabling real-time UI updates.

2. **State Machine**: The explicit state machine ensures valid transitions and simplifies debugging of agent behavior.

3. **Parser Resilience**: The function call parser supports multiple formats and handles malformed input gracefully.

4. **Approval Integration**: The TaskCompletionSource pattern allows the UI to asynchronously provide approval decisions without blocking the service.

5. **Tool Result Truncation**: Long tool results are truncated to prevent context overflow while preserving important information.

6. **Session Permissions**: Permission decisions can be cached per-session to reduce approval fatigue for repeated tool calls.
