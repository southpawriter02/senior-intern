# Design Specification: AIntern v0.6.3b "File Write Tools"

## Overview

**Version**: v0.6.3b
**Parent**: v0.6.3 Built-in Tools
**Focus**: WriteFileTool and FilePatchTool for creating and modifying files

### Purpose

Implement file writing capabilities that enable the AI agent to:
1. Create new files with automatic directory creation
2. Overwrite existing files with optional backup
3. Apply targeted patches for small edits
4. Support multiple encodings (UTF-8, ASCII, UTF-16)
5. Calculate and report diff statistics
6. Detect configuration files for elevated risk levels
7. Generate file artifacts for tracking changes

### Dependencies

**From v0.6.3a (File Read Tools)**:
- `ToolPathHelper` for path validation
- `PathValidationResult` for validation responses

**From v0.6.1 (Tool Framework)**:
- `ToolBase`, `ToolResult`, `ToolArtifact`
- `JsonSchemaBuilder`, `RiskLevel`

**From v0.3.x (Workspace Awareness)**:
- `IWorkspaceService`, `IFileSystemService`

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                    v0.6.3b File Write Tools Architecture                      │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  src/SeniorIntern.Services/Tools/FileSystem/                                 │
│  ├─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  WriteFileTool : ToolBase                                                │ │
│  │  ┌─────────────────────────────────────────────────────────────────────┐│ │
│  │  │  Id: "file-write"                                                    ││ │
│  │  │  DefaultRiskLevel: Medium (High for config files)                    ││ │
│  │  │                                                                      ││ │
│  │  │  Parameters                                                           ││ │
│  │  │  ├── path: string (required) - Target file path                      ││ │
│  │  │  ├── content: string (required) - Content to write                   ││ │
│  │  │  ├── create_directories: bool (default: true)                        ││ │
│  │  │  ├── create_backup: bool (default: false)                            ││ │
│  │  │  └── encoding: string (default: "utf-8")                             ││ │
│  │  │                                                                      ││ │
│  │  │  Features                                                             ││ │
│  │  │  ├── Automatic parent directory creation                             ││ │
│  │  │  ├── Timestamped backup files (.bak)                                 ││ │
│  │  │  ├── Diff statistics (lines added/removed)                           ││ │
│  │  │  └── File artifact generation                                        ││ │
│  │  └─────────────────────────────────────────────────────────────────────┘│ │
│  │                                                                          │ │
│  │  FilePatchTool : ToolBase                                                │ │
│  │  ┌─────────────────────────────────────────────────────────────────────┐│ │
│  │  │  Id: "file-patch"                                                    ││ │
│  │  │  DefaultRiskLevel: Medium                                            ││ │
│  │  │                                                                      ││ │
│  │  │  Parameters                                                           ││ │
│  │  │  ├── path: string (required) - File to patch                         ││ │
│  │  │  ├── old_content: string (required) - Content to find                ││ │
│  │  │  ├── new_content: string (required) - Replacement content            ││ │
│  │  │  └── occurrence: int (default: 1, 0=all)                             ││ │
│  │  │                                                                      ││ │
│  │  │  Features                                                             ││ │
│  │  │  ├── Exact string matching                                           ││ │
│  │  │  ├── Single or all occurrence replacement                            ││ │
│  │  │  └── Occurrence not found error handling                             ││ │
│  │  └─────────────────────────────────────────────────────────────────────┘│ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  src/SeniorIntern.Core/Models/                                               │
│  ├─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  WriteFileResultData                     FilePatchResultData             │ │
│  │  ├── Path: string                        ├── Path: string                │ │
│  │  ├── IsNewFile: bool                     ├── OccurrencesFound: int       │ │
│  │  ├── BytesWritten: int                   ├── OccurrencesReplaced: int    │ │
│  │  ├── LineCount: int                      ├── OldContentLength: int       │ │
│  │  ├── BackupPath: string?                 ├── NewContentLength: int       │ │
│  │  ├── LinesAdded: int                     └── CharactersDelta: int        │ │
│  │  ├── LinesRemoved: int                                                   │ │
│  │  └── LinesChanged: int                                                   │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Execution Flow

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                       WriteFileTool Execution Flow                            │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ExecuteAsync(context)                                                       │
│      │                                                                       │
│      ▼                                                                       │
│  ┌─────────────────────────────┐                                             │
│  │  1. Extract Parameters      │                                             │
│  │  ├── path, content          │                                             │
│  │  ├── create_directories     │                                             │
│  │  ├── create_backup          │                                             │
│  │  └── encoding               │                                             │
│  └─────────────┬───────────────┘                                             │
│                │                                                             │
│                ▼                                                             │
│  ┌─────────────────────────────┐                                             │
│  │  2. Validate Path           │                                             │
│  │  ToolPathHelper.ValidatePath│                                             │
│  └─────────────┬───────────────┘                                             │
│                │                                                             │
│                ▼                                                             │
│  ┌─────────────────────────────┐                                             │
│  │  3. Check Content Size      │                                             │
│  │  Max: 5 MB                  │                                             │
│  └─────────────┬───────────────┘                                             │
│                │                                                             │
│                ▼                                                             │
│  ┌─────────────────────────────┐                                             │
│  │  4. Check Existing File     │                                             │
│  │  ├── If exists: read old    │                                             │
│  │  │   content for diff       │                                             │
│  │  └── If backup: create .bak │                                             │
│  └─────────────┬───────────────┘                                             │
│                │                                                             │
│                ▼                                                             │
│  ┌─────────────────────────────┐                                             │
│  │  5. Create Directories      │                                             │
│  │  (if create_directories)    │                                             │
│  └─────────────┬───────────────┘                                             │
│                │                                                             │
│                ▼                                                             │
│  ┌─────────────────────────────┐                                             │
│  │  6. Write File              │                                             │
│  │  WriteFileAsync with        │                                             │
│  │  specified encoding         │                                             │
│  └─────────────┬───────────────┘                                             │
│                │                                                             │
│                ▼                                                             │
│  ┌─────────────────────────────┐                                             │
│  │  7. Calculate Diff Stats    │                                             │
│  │  ├── Lines added            │                                             │
│  │  ├── Lines removed          │                                             │
│  │  └── Lines changed          │                                             │
│  └─────────────┬───────────────┘                                             │
│                │                                                             │
│                ▼                                                             │
│  ┌─────────────────────────────┐                                             │
│  │  8. Build Result            │                                             │
│  │  ├── WriteFileResultData    │                                             │
│  │  ├── Success message        │                                             │
│  │  └── File artifact          │                                             │
│  └─────────────────────────────┘                                             │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────────────────────┐
│                       FilePatchTool Execution Flow                            │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ExecuteAsync(context)                                                       │
│      │                                                                       │
│      ▼                                                                       │
│  ┌─────────────────────────────┐                                             │
│  │  1. Extract Parameters      │                                             │
│  │  ├── path                   │                                             │
│  │  ├── old_content            │                                             │
│  │  ├── new_content            │                                             │
│  │  └── occurrence (1=first)   │                                             │
│  └─────────────┬───────────────┘                                             │
│                │                                                             │
│                ▼                                                             │
│  ┌─────────────────────────────┐                                             │
│  │  2. Validate & Read File    │                                             │
│  │  ├── Path validation        │                                             │
│  │  └── Read current content   │                                             │
│  └─────────────┬───────────────┘                                             │
│                │                                                             │
│                ▼                                                             │
│  ┌─────────────────────────────┐                                             │
│  │  3. Find Occurrences        │                                             │
│  │  Find all indices of        │                                             │
│  │  old_content in file        │                                             │
│  └─────────────┬───────────────┘                                             │
│                │                                                             │
│       ┌────────┴────────┐                                                    │
│       │ 0 occurrences   │ 1+ occurrences                                     │
│       ▼                 ▼                                                    │
│  ┌──────────┐    ┌─────────────────────────────┐                             │
│  │  RETURN  │    │  4. Apply Replacement       │                             │
│  │  Failed  │    │  ├── occurrence=0: all      │                             │
│  │  "not    │    │  ├── occurrence=N: Nth      │                             │
│  │  found"  │    │  └── Check bounds           │                             │
│  └──────────┘    └─────────────┬───────────────┘                             │
│                                │                                             │
│                                ▼                                             │
│                  ┌─────────────────────────────┐                             │
│                  │  5. Write Modified File     │                             │
│                  └─────────────┬───────────────┘                             │
│                                │                                             │
│                                ▼                                             │
│                  ┌─────────────────────────────┐                             │
│                  │  6. Build Result            │                             │
│                  │  ├── FilePatchResultData    │                             │
│                  │  └── Success message        │                             │
│                  └─────────────────────────────┘                             │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Specifications

### 1. WriteFileTool.cs

**Location**: `src/SeniorIntern.Services/Tools/FileSystem/WriteFileTool.cs`

```csharp
namespace SeniorIntern.Services.Tools.FileSystem;

using System.Text;
using System.Text.Json;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Core.Tools;
using SeniorIntern.Services.Tools;

/// <summary>
/// Tool for writing content to files in the workspace.
/// </summary>
/// <remarks>
/// <para>
/// WriteFileTool enables the AI agent to create and modify files:
/// </para>
/// <list type="bullet">
/// <item>Create new files with automatic directory creation</item>
/// <item>Overwrite existing files with optional backup</item>
/// <item>Support for multiple encodings</item>
/// <item>Diff statistics for change tracking</item>
/// </list>
/// <para>
/// For small, targeted edits, consider using FilePatchTool instead.
/// </para>
/// </remarks>
public sealed class WriteFileTool : ToolBase
{
    #region Tool Metadata

    public override string Id => "file-write";

    public override string Name => "Write File";

    public override string Description => """
        Write content to a file in the workspace.
        Creates the file if it doesn't exist, or overwrites if it does.
        Parent directories are created automatically.

        Use this when you need to:
        - Create new source files
        - Modify existing files (provide complete new content)
        - Create configuration files

        Note: For small edits, consider using file-patch instead.
        """;

    public override ToolCategory Category => ToolCategory.FileSystem;

    public override RiskLevel DefaultRiskLevel => RiskLevel.Medium;

    public override IReadOnlyList<string> Tags => new[] { "file", "write", "create", "modify" };

    public override JsonSchema InputSchema => JsonSchemaBuilder.Create()
        .WithDescription("Parameters for writing a file")
        .AddString("path", "Relative path for the file within the workspace", required: true)
        .AddString("content", "Content to write to the file", required: true)
        .AddBoolean("create_directories", "Create parent directories if needed (default: true)", required: false)
        .AddBoolean("create_backup", "Create backup of existing file (default: false)", required: false)
        .AddString("encoding", "File encoding: utf-8, utf-8-bom, ascii, utf-16 (default: utf-8)", required: false)
        .Build();

    #endregion

    #region Dependencies

    private readonly IFileSystemService _fileSystem;
    private readonly IWorkspaceService _workspace;
    private readonly ILogger<WriteFileTool> _logger;

    #endregion

    #region Constants

    /// <summary>
    /// Maximum content size in bytes (5 MB).
    /// </summary>
    public const int MaxFileSizeBytes = 5 * 1024 * 1024;

    /// <summary>
    /// Valid encoding names.
    /// </summary>
    private static readonly string[] ValidEncodings = { "utf-8", "utf-8-bom", "ascii", "utf-16", "unicode" };

    /// <summary>
    /// Configuration file patterns for elevated risk detection.
    /// </summary>
    private static readonly string[] ConfigPatterns =
    {
        ".env", ".gitignore", "package.json", "tsconfig.json",
        ".csproj", ".sln", "Cargo.toml", "go.mod", "Dockerfile",
        "docker-compose", ".yml", ".yaml", "Makefile", ".config"
    };

    #endregion

    public WriteFileTool(
        IFileSystemService fileSystem,
        IWorkspaceService workspace,
        ILogger<WriteFileTool> logger)
    {
        _fileSystem = fileSystem ?? throw new ArgumentNullException(nameof(fileSystem));
        _workspace = workspace ?? throw new ArgumentNullException(nameof(workspace));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    public override bool IsAvailable => _workspace.CurrentWorkspace != null;

    #region ExecuteAsync

    public override async Task<ToolResult> ExecuteAsync(
        ToolExecutionContext context,
        CancellationToken ct = default)
    {
        // Extract parameters
        var path = GetRequiredParameter<string>(context.Parameters, "path");
        var content = GetRequiredParameter<string>(context.Parameters, "content");
        var createDirs = GetOptionalParameter(context.Parameters, "create_directories", true);
        var createBackup = GetOptionalParameter(context.Parameters, "create_backup", false);
        var encodingName = GetOptionalParameter(context.Parameters, "encoding", "utf-8");

        _logger.LogDebug(
            "WriteFileTool executing: path={Path}, createDirs={CreateDirs}, backup={Backup}",
            path, createDirs, createBackup);

        // Validate path
        var fullPath = ToolPathHelper.ResolvePath(context.WorkspacePath, path);
        var pathValidation = ToolPathHelper.ValidatePath(fullPath, context.WorkspacePath);

        if (!pathValidation.IsValid)
        {
            _logger.LogWarning("Path validation failed: {Error}", pathValidation.ErrorMessage);
            return ToolResult.Failed(pathValidation.ErrorMessage!);
        }

        // Check content size
        var encoding = GetEncoding(encodingName);
        var contentBytes = encoding.GetByteCount(content);

        if (contentBytes > MaxFileSizeBytes)
        {
            return ToolResult.Failed(
                $"Content too large ({ToolPathHelper.FormatFileSize(contentBytes)}). " +
                $"Maximum: {ToolPathHelper.FormatFileSize(MaxFileSizeBytes)}");
        }

        try
        {
            var isNewFile = !await _fileSystem.FileExistsAsync(fullPath, ct);
            var previousContent = string.Empty;
            string? backupPath = null;

            // Handle existing file
            if (!isNewFile)
            {
                previousContent = await _fileSystem.ReadFileAsync(fullPath, ct);

                // Create backup if requested
                if (createBackup)
                {
                    backupPath = await CreateBackupAsync(fullPath, ct);
                    _logger.LogInformation("Created backup: {BackupPath}", backupPath);
                }
            }

            // Create parent directories
            var directory = Path.GetDirectoryName(fullPath);
            if (!string.IsNullOrEmpty(directory))
            {
                if (createDirs)
                {
                    if (!await _fileSystem.DirectoryExistsAsync(directory, ct))
                    {
                        await _fileSystem.CreateDirectoryAsync(directory, ct);
                        _logger.LogDebug("Created directory: {Directory}", directory);
                    }
                }
                else if (!await _fileSystem.DirectoryExistsAsync(directory, ct))
                {
                    return ToolResult.Failed($"Directory does not exist: {Path.GetDirectoryName(path)}");
                }
            }

            // Write file
            await _fileSystem.WriteFileAsync(fullPath, content, encoding, ct);

            // Calculate diff statistics
            var diffStats = CalculateDiffStats(previousContent, content);

            var resultData = new WriteFileResultData
            {
                Path = path,
                IsNewFile = isNewFile,
                BytesWritten = contentBytes,
                LineCount = content.Split('\n').Length,
                BackupPath = backupPath,
                LinesAdded = diffStats.Added,
                LinesRemoved = diffStats.Removed,
                LinesChanged = diffStats.Changed
            };

            var message = isNewFile
                ? $"Created file: {path} ({resultData.LineCount} lines)"
                : $"Updated file: {path} (+{diffStats.Added}/-{diffStats.Removed} lines)";

            _logger.LogInformation(
                "WriteFileTool success: {Path}, isNew={IsNew}, bytes={Bytes}",
                path, isNewFile, contentBytes);

            return ToolResult.Success(content: null, resultData, message)
                .WithArtifact(new ToolArtifact
                {
                    Type = ToolArtifactType.File,
                    Path = fullPath,
                    Description = isNewFile ? "Created file" : "Modified file"
                });
        }
        catch (UnauthorizedAccessException ex)
        {
            _logger.LogWarning(ex, "Access denied to file: {Path}", path);
            return ToolResult.Failed($"Access denied: {path}");
        }
        catch (IOException ex)
        {
            _logger.LogError(ex, "Failed to write file: {Path}", path);
            return ToolResult.Failed($"Failed to write file: {ex.Message}");
        }
    }

    #endregion

    #region Helper Methods

    /// <summary>
    /// Create a timestamped backup of a file.
    /// </summary>
    private async Task<string> CreateBackupAsync(string filePath, CancellationToken ct)
    {
        var timestamp = DateTime.Now.ToString("yyyyMMdd_HHmmss");
        var backupPath = $"{filePath}.{timestamp}.bak";
        await _fileSystem.CopyFileAsync(filePath, backupPath, ct);
        return backupPath;
    }

    /// <summary>
    /// Get encoding from name.
    /// </summary>
    private static Encoding GetEncoding(string name) => name.ToLowerInvariant() switch
    {
        "utf-8" => new UTF8Encoding(encoderShouldEmitUTF8Identifier: false),
        "utf-8-bom" => new UTF8Encoding(encoderShouldEmitUTF8Identifier: true),
        "ascii" => Encoding.ASCII,
        "utf-16" or "unicode" => Encoding.Unicode,
        _ => new UTF8Encoding(encoderShouldEmitUTF8Identifier: false)
    };

    /// <summary>
    /// Calculate diff statistics between old and new content.
    /// </summary>
    private static (int Added, int Removed, int Changed) CalculateDiffStats(
        string oldContent, string newContent)
    {
        if (string.IsNullOrEmpty(oldContent))
        {
            return (newContent.Split('\n').Length, 0, 0);
        }

        var oldLines = new HashSet<string>(oldContent.Split('\n'));
        var newLines = newContent.Split('\n');

        var added = newLines.Count(l => !oldLines.Contains(l));
        var removed = oldLines.Count(l => !newLines.Contains(l));

        return (added, removed, 0);
    }

    /// <summary>
    /// Check if a path is a configuration file.
    /// </summary>
    private static bool IsConfigurationFile(string path)
    {
        var fileName = Path.GetFileName(path).ToLowerInvariant();
        return ConfigPatterns.Any(p => fileName.Contains(p));
    }

    #endregion

    #region Overrides

    public override string GetExecutionSummary(JsonElement parameters)
    {
        var path = parameters.TryGetProperty("path", out var p)
            ? p.GetString() ?? "unknown"
            : "unknown";
        var shortPath = path.Length > 35 ? "..." + path[^32..] : path;

        if (parameters.TryGetProperty("content", out var c))
        {
            var content = c.GetString() ?? "";
            var lines = content.Split('\n').Length;
            return $"Write {lines} lines to '{shortPath}'";
        }

        return $"Write file '{shortPath}'";
    }

    public override RiskLevel GetEffectiveRiskLevel(JsonElement parameters)
    {
        if (parameters.TryGetProperty("path", out var p))
        {
            var path = p.GetString() ?? "";
            if (IsConfigurationFile(path))
            {
                return RiskLevel.High;
            }
        }

        return RiskLevel.Medium;
    }

    public override ToolValidationResult Validate(JsonElement parameters)
    {
        var errors = new List<ToolValidationError>();

        // Validate required path
        if (!parameters.TryGetProperty("path", out var pathProp) ||
            string.IsNullOrWhiteSpace(pathProp.GetString()))
        {
            errors.Add(ToolValidationError.Required("path"));
        }

        // Validate required content
        if (!parameters.TryGetProperty("content", out _))
        {
            errors.Add(ToolValidationError.Required("content"));
        }

        // Validate encoding if provided
        if (parameters.TryGetProperty("encoding", out var enc))
        {
            var encoding = enc.GetString()?.ToLowerInvariant();
            if (!string.IsNullOrEmpty(encoding) && !ValidEncodings.Contains(encoding))
            {
                errors.Add(new ToolValidationError
                {
                    ParameterName = "encoding",
                    Message = $"Invalid encoding. Valid options: {string.Join(", ", ValidEncodings)}",
                    Code = "INVALID_VALUE"
                });
            }
        }

        return errors.Count > 0
            ? ToolValidationResult.Invalid(errors)
            : ToolValidationResult.Valid();
    }

    #endregion
}
```

### 2. FilePatchTool.cs

**Location**: `src/SeniorIntern.Services/Tools/FileSystem/FilePatchTool.cs`

```csharp
namespace SeniorIntern.Services.Tools.FileSystem;

using System.Text.Json;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Core.Tools;
using SeniorIntern.Services.Tools;

/// <summary>
/// Tool for applying targeted edits to files.
/// </summary>
/// <remarks>
/// <para>
/// FilePatchTool is more efficient than WriteFileTool for small changes:
/// </para>
/// <list type="bullet">
/// <item>Find and replace exact string matches</item>
/// <item>Replace specific or all occurrences</item>
/// <item>Preserves unchanged content</item>
/// </list>
/// <para>
/// The old_content must match exactly, including whitespace and line endings.
/// </para>
/// </remarks>
public sealed class FilePatchTool : ToolBase
{
    #region Tool Metadata

    public override string Id => "file-patch";

    public override string Name => "Patch File";

    public override string Description => """
        Apply targeted edits to an existing file.
        Finds and replaces specific text content.
        Use this for making small, precise changes without rewriting entire files.

        The tool will find the exact 'old_content' in the file and replace it with 'new_content'.
        The old_content must match exactly (including whitespace).
        """;

    public override ToolCategory Category => ToolCategory.FileSystem;

    public override RiskLevel DefaultRiskLevel => RiskLevel.Medium;

    public override IReadOnlyList<string> Tags => new[] { "file", "edit", "patch", "replace" };

    public override JsonSchema InputSchema => JsonSchemaBuilder.Create()
        .WithDescription("Parameters for patching a file")
        .AddString("path", "Relative path to the file to patch", required: true)
        .AddString("old_content", "Exact content to find and replace", required: true)
        .AddString("new_content", "Content to replace with", required: true)
        .AddInteger("occurrence", "Which occurrence to replace (1-based, 0 for all, default: 1)", required: false)
        .Build();

    #endregion

    #region Dependencies

    private readonly IFileSystemService _fileSystem;
    private readonly IWorkspaceService _workspace;
    private readonly ILogger<FilePatchTool> _logger;

    #endregion

    public FilePatchTool(
        IFileSystemService fileSystem,
        IWorkspaceService workspace,
        ILogger<FilePatchTool> logger)
    {
        _fileSystem = fileSystem ?? throw new ArgumentNullException(nameof(fileSystem));
        _workspace = workspace ?? throw new ArgumentNullException(nameof(workspace));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    public override bool IsAvailable => _workspace.CurrentWorkspace != null;

    #region ExecuteAsync

    public override async Task<ToolResult> ExecuteAsync(
        ToolExecutionContext context,
        CancellationToken ct = default)
    {
        // Extract parameters
        var path = GetRequiredParameter<string>(context.Parameters, "path");
        var oldContent = GetRequiredParameter<string>(context.Parameters, "old_content");
        var newContent = GetRequiredParameter<string>(context.Parameters, "new_content");
        var occurrence = GetOptionalParameter(context.Parameters, "occurrence", 1);

        _logger.LogDebug(
            "FilePatchTool executing: path={Path}, occurrence={Occurrence}",
            path, occurrence);

        // Validate path
        var fullPath = ToolPathHelper.ResolvePath(context.WorkspacePath, path);
        var pathValidation = ToolPathHelper.ValidatePath(fullPath, context.WorkspacePath);

        if (!pathValidation.IsValid)
        {
            return ToolResult.Failed(pathValidation.ErrorMessage!);
        }

        // Check file exists
        if (!await _fileSystem.FileExistsAsync(fullPath, ct))
        {
            return ToolResult.Failed($"File not found: {path}");
        }

        try
        {
            var content = await _fileSystem.ReadFileAsync(fullPath, ct);

            // Find occurrences
            var occurrences = FindOccurrences(content, oldContent);

            if (occurrences.Count == 0)
            {
                _logger.LogWarning("Content not found in file: {Path}", path);
                return ToolResult.Failed(
                    "Could not find the specified content in the file. " +
                    "Make sure the old_content matches exactly, including whitespace and line endings.");
            }

            // Apply replacement
            string newFileContent;
            int replacementCount;

            if (occurrence == 0)
            {
                // Replace all occurrences
                newFileContent = content.Replace(oldContent, newContent);
                replacementCount = occurrences.Count;
                _logger.LogDebug("Replacing all {Count} occurrences", replacementCount);
            }
            else if (occurrence > occurrences.Count)
            {
                return ToolResult.Failed(
                    $"Requested occurrence {occurrence} but only found {occurrences.Count} occurrence(s)");
            }
            else
            {
                // Replace specific occurrence
                var index = occurrences[occurrence - 1];
                newFileContent = content[..index] + newContent + content[(index + oldContent.Length)..];
                replacementCount = 1;
                _logger.LogDebug("Replacing occurrence {N} at index {Index}", occurrence, index);
            }

            // Write file
            await _fileSystem.WriteFileAsync(fullPath, newFileContent, ct);

            var resultData = new FilePatchResultData
            {
                Path = path,
                OccurrencesFound = occurrences.Count,
                OccurrencesReplaced = replacementCount,
                OldContentLength = oldContent.Length,
                NewContentLength = newContent.Length,
                CharactersDelta = (newContent.Length - oldContent.Length) * replacementCount
            };

            var message = replacementCount == 1
                ? $"Patched {path}: replaced 1 occurrence"
                : $"Patched {path}: replaced {replacementCount} occurrences";

            _logger.LogInformation(
                "FilePatchTool success: {Path}, replaced {Count} of {Found}",
                path, replacementCount, occurrences.Count);

            return ToolResult.Success(content: null, resultData, message)
                .WithArtifact(new ToolArtifact
                {
                    Type = ToolArtifactType.File,
                    Path = fullPath,
                    Description = "Patched file"
                });
        }
        catch (IOException ex)
        {
            _logger.LogError(ex, "Failed to patch file: {Path}", path);
            return ToolResult.Failed($"Failed to patch file: {ex.Message}");
        }
    }

    #endregion

    #region Helper Methods

    /// <summary>
    /// Find all occurrences of a substring in content.
    /// </summary>
    private static List<int> FindOccurrences(string content, string search)
    {
        var occurrences = new List<int>();
        var index = 0;

        while ((index = content.IndexOf(search, index, StringComparison.Ordinal)) != -1)
        {
            occurrences.Add(index);
            index += search.Length;
        }

        return occurrences;
    }

    #endregion

    #region Overrides

    public override string GetExecutionSummary(JsonElement parameters)
    {
        var path = parameters.TryGetProperty("path", out var p)
            ? p.GetString() ?? "unknown"
            : "unknown";
        var shortPath = path.Length > 35 ? "..." + path[^32..] : path;

        var occurrence = parameters.TryGetProperty("occurrence", out var o)
            ? o.GetInt32()
            : 1;

        if (occurrence == 0)
        {
            return $"Patch '{shortPath}' (replace all occurrences)";
        }

        return $"Patch '{shortPath}' (occurrence {occurrence})";
    }

    public override ToolValidationResult Validate(JsonElement parameters)
    {
        var errors = new List<ToolValidationError>();

        // Validate required path
        if (!parameters.TryGetProperty("path", out var pathProp) ||
            string.IsNullOrWhiteSpace(pathProp.GetString()))
        {
            errors.Add(ToolValidationError.Required("path"));
        }

        // Validate required old_content
        if (!parameters.TryGetProperty("old_content", out var oldProp) ||
            string.IsNullOrEmpty(oldProp.GetString()))
        {
            errors.Add(ToolValidationError.Required("old_content"));
        }

        // Validate required new_content (empty string is valid)
        if (!parameters.TryGetProperty("new_content", out _))
        {
            errors.Add(ToolValidationError.Required("new_content"));
        }

        // Validate occurrence
        if (parameters.TryGetProperty("occurrence", out var occ))
        {
            var occurrence = occ.GetInt32();
            if (occurrence < 0)
            {
                errors.Add(new ToolValidationError
                {
                    ParameterName = "occurrence",
                    Message = "Occurrence must be >= 0 (0 means all)",
                    Code = "INVALID_RANGE"
                });
            }
        }

        return errors.Count > 0
            ? ToolValidationResult.Invalid(errors)
            : ToolValidationResult.Valid();
    }

    #endregion
}
```

### 3. WriteFileResultData.cs

**Location**: `src/SeniorIntern.Core/Models/WriteFileResultData.cs`

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Result data for file write operations.
/// </summary>
public sealed class WriteFileResultData
{
    /// <summary>
    /// Relative path to the file.
    /// </summary>
    public string Path { get; init; } = string.Empty;

    /// <summary>
    /// Whether a new file was created.
    /// </summary>
    public bool IsNewFile { get; init; }

    /// <summary>
    /// Total bytes written.
    /// </summary>
    public int BytesWritten { get; init; }

    /// <summary>
    /// Number of lines in the file.
    /// </summary>
    public int LineCount { get; init; }

    /// <summary>
    /// Path to backup file if created.
    /// </summary>
    public string? BackupPath { get; init; }

    /// <summary>
    /// Lines added compared to previous content.
    /// </summary>
    public int LinesAdded { get; init; }

    /// <summary>
    /// Lines removed compared to previous content.
    /// </summary>
    public int LinesRemoved { get; init; }

    /// <summary>
    /// Lines changed (semantic, not just diff).
    /// </summary>
    public int LinesChanged { get; init; }

    /// <summary>
    /// Net change in lines.
    /// </summary>
    public int NetLineChange => LinesAdded - LinesRemoved;

    /// <summary>
    /// Human-readable diff summary.
    /// </summary>
    public string DiffSummary => IsNewFile
        ? $"New file: {LineCount} lines"
        : $"+{LinesAdded}/-{LinesRemoved} lines";
}
```

### 4. FilePatchResultData.cs

**Location**: `src/SeniorIntern.Core/Models/FilePatchResultData.cs`

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Result data for file patch operations.
/// </summary>
public sealed class FilePatchResultData
{
    /// <summary>
    /// Relative path to the patched file.
    /// </summary>
    public string Path { get; init; } = string.Empty;

    /// <summary>
    /// Total occurrences found in file.
    /// </summary>
    public int OccurrencesFound { get; init; }

    /// <summary>
    /// Occurrences that were replaced.
    /// </summary>
    public int OccurrencesReplaced { get; init; }

    /// <summary>
    /// Length of the old content.
    /// </summary>
    public int OldContentLength { get; init; }

    /// <summary>
    /// Length of the new content.
    /// </summary>
    public int NewContentLength { get; init; }

    /// <summary>
    /// Net character change.
    /// </summary>
    public int CharactersDelta { get; init; }

    /// <summary>
    /// Whether all occurrences were replaced.
    /// </summary>
    public bool AllReplaced => OccurrencesFound == OccurrencesReplaced;

    /// <summary>
    /// Remaining unreplaced occurrences.
    /// </summary>
    public int RemainingOccurrences => OccurrencesFound - OccurrencesReplaced;
}
```

---

## File Summary

| File | Location | Purpose | Lines |
|------|----------|---------|-------|
| `WriteFileTool.cs` | `Services/Tools/FileSystem/` | Create/overwrite files | ~250 |
| `FilePatchTool.cs` | `Services/Tools/FileSystem/` | Find/replace edits | ~180 |
| `WriteFileResultData.cs` | `Core/Models/` | Write result metadata | ~55 |
| `FilePatchResultData.cs` | `Core/Models/` | Patch result metadata | ~45 |

---

## Unit Test Plan

| Test | Description |
|------|-------------|
| `WriteFileTool_NewFile_CreatesFile` | Basic file creation |
| `WriteFileTool_ExistingFile_Overwrites` | Overwrite behavior |
| `WriteFileTool_CreateDirectories_CreatesParents` | Directory creation |
| `WriteFileTool_Backup_CreatesTimestampedCopy` | Backup creation |
| `WriteFileTool_ConfigFile_ElevatesRisk` | Risk detection |
| `WriteFileTool_LargeContent_Rejects` | Size limit |
| `WriteFileTool_Encoding_WritesCorrectBOM` | Encoding support |
| `FilePatchTool_SingleOccurrence_ReplacesFirst` | Basic patch |
| `FilePatchTool_AllOccurrences_ReplacesAll` | Replace all |
| `FilePatchTool_SpecificOccurrence_ReplacesNth` | Nth occurrence |
| `FilePatchTool_NotFound_ReturnsError` | Missing content |
| `FilePatchTool_OccurrenceOutOfRange_ReturnsError` | Bounds check |

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | WriteFileTool creates new files |
| AC-2 | WriteFileTool overwrites existing files |
| AC-3 | Parent directories created automatically |
| AC-4 | Backup files created with timestamp |
| AC-5 | Diff statistics calculated correctly |
| AC-6 | FilePatchTool finds and replaces content |
| AC-7 | Occurrence selection works correctly |
| AC-8 | Config files detected for elevated risk |

---

## Changelog Entry

```markdown
## v0.6.3b - File Write Tools

### Added
- `WriteFileTool` for creating and modifying files
  - Automatic parent directory creation
  - Timestamped backup files (.bak)
  - Multiple encoding support (UTF-8, ASCII, UTF-16)
  - Diff statistics (lines added/removed)
  - Config file detection for elevated risk
  - 5 MB content size limit
- `FilePatchTool` for targeted find/replace edits
  - Exact string matching
  - Single or all occurrence replacement
  - Occurrence bounds validation
- `WriteFileResultData` for write operation metadata
- `FilePatchResultData` for patch operation metadata
```

---

## Timeline Estimate

| Version | Estimated Effort |
|---------|------------------|
| v0.6.3b | 0.75 day |
