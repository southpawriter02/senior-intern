# Design Specification: AIntern v0.6.3 "Built-in Tools"

## Executive Summary

This document provides a comprehensive design specification for v0.6.3, which implements the complete set of built-in tools that enable the AI agent to interact with the file system, execute terminal commands, search codebases, manage workspaces, and perform Git operations. These tools form the core capabilities that transform the assistant from a conversational AI into a powerful coding agent capable of reading, writing, and executing code autonomously.

### v0.6.3 Scope (from v0.6.0 Design Document)
- File system tools: read, write, delete, move, copy, list directory
- Terminal command execution with output capture
- File and content search with glob/regex support
- Workspace information and project detection
- Git operations: status, diff, log
- Tool registration and dependency injection
- Security validation for dangerous operations

---

## Sub-Part Breakdown

| Part | Name | Focus |
|------|------|-------|
| v0.6.3a | File Read Tools | ReadFileTool, line filtering, encoding detection |
| v0.6.3b | File Write Tools | WriteFileTool, directory creation, backup handling |
| v0.6.3c | File Management Tools | DeleteFileTool, MoveFileTool, CopyFileTool |
| v0.6.3d | Directory Tools | ListDirectoryTool, tree view, size calculation |
| v0.6.3e | Terminal Command Tool | RunCommandTool, shell detection, output capture |
| v0.6.3f | File Search Tools | SearchFilesTool with glob patterns |
| v0.6.3g | Content Search Tools | SearchContentTool with regex support |
| v0.6.3h | Workspace Tools | GetWorkspaceInfoTool, GetOpenFilesTool, project detection |
| v0.6.3i | Git Tools | GitStatusTool, GitDiffTool, GitLogTool |
| v0.6.3j | Tool Registration & Testing | DI extensions, unit tests, integration tests |

---

## v0.6.3a: File Read Tools

### Objective
Implement the ReadFileTool that enables the AI agent to read file contents from the workspace, with support for line filtering, encoding detection, and large file handling.

### ReadFileTool Implementation

```csharp
namespace SeniorIntern.Services.Tools.FileSystem;

/// <summary>
/// Tool for reading file contents from the workspace.
/// Supports line filtering and encoding detection.
/// </summary>
public sealed class ReadFileTool : ToolBase
{
    public override string Id => "file-read";
    public override string Name => "Read File";
    public override string Description => """
        Read the contents of a file from the workspace.
        Returns the file content as text with optional line filtering.
        Use this when you need to examine file contents before making changes.

        Supports:
        - Reading entire files or specific line ranges
        - Automatic encoding detection
        - Large file handling with truncation warnings
        """;

    public override ToolCategory Category => ToolCategory.FileSystem;
    public override RiskLevel DefaultRiskLevel => RiskLevel.Safe;
    public override IReadOnlyList<string> Tags => new[] { "file", "read", "view", "content" };

    public override JsonSchema InputSchema => JsonSchemaBuilder.Create()
        .WithDescription("Parameters for reading a file")
        .AddString("path", "Relative path to the file within the workspace", required: true)
        .AddInteger("start_line", "Starting line number (1-based, inclusive)", required: false)
        .AddInteger("end_line", "Ending line number (1-based, inclusive)", required: false)
        .AddInteger("max_lines", "Maximum number of lines to read (default: 1000)", required: false)
        .AddBoolean("include_line_numbers", "Include line numbers in output (default: true)", required: false)
        .Build();

    private readonly IFileSystemService _fileSystem;
    private readonly IWorkspaceService _workspace;
    private readonly ILogger<ReadFileTool> _logger;

    private const int DefaultMaxLines = 1000;
    private const int MaxFileSizeBytes = 10 * 1024 * 1024; // 10 MB

    public ReadFileTool(
        IFileSystemService fileSystem,
        IWorkspaceService workspace,
        ILogger<ReadFileTool> logger)
    {
        _fileSystem = fileSystem;
        _workspace = workspace;
        _logger = logger;
    }

    public override bool IsAvailable =>
        _workspace.CurrentWorkspace != null;

    public override async Task<ToolResult> ExecuteAsync(
        ToolExecutionContext context,
        CancellationToken ct = default)
    {
        var path = GetRequiredParameter<string>(context.Parameters, "path");
        var startLine = GetOptionalParameter<int?>(context.Parameters, "start_line");
        var endLine = GetOptionalParameter<int?>(context.Parameters, "end_line");
        var maxLines = GetOptionalParameter<int>(context.Parameters, "max_lines", DefaultMaxLines);
        var includeLineNumbers = GetOptionalParameter<bool>(context.Parameters, "include_line_numbers", true);

        // Resolve and validate path
        var fullPath = ResolvePath(context.WorkspacePath, path);
        var pathValidation = ValidatePath(fullPath, context.WorkspacePath);
        if (!pathValidation.IsValid)
        {
            return ToolResult.Failed(pathValidation.ErrorMessage!);
        }

        // Check file exists
        if (!await _fileSystem.FileExistsAsync(fullPath, ct))
        {
            return ToolResult.Failed($"File not found: {path}");
        }

        // Check file size
        var fileInfo = await _fileSystem.GetFileInfoAsync(fullPath, ct);
        if (fileInfo.Size > MaxFileSizeBytes)
        {
            return ToolResult.Failed(
                $"File too large ({FormatFileSize(fileInfo.Size)}). Maximum size: {FormatFileSize(MaxFileSizeBytes)}. " +
                "Consider using start_line/end_line parameters to read a portion.");
        }

        try
        {
            // Read file content
            var content = await _fileSystem.ReadFileAsync(fullPath, ct);
            var lines = content.Split('\n');
            var totalLines = lines.Length;

            // Apply line filtering
            var (filteredLines, actualStart, actualEnd, wasTruncated) =
                ApplyLineFilter(lines, startLine, endLine, maxLines);

            // Format output
            var output = FormatOutput(filteredLines, actualStart, includeLineNumbers);

            // Build result data
            var resultData = new ReadFileResultData
            {
                Path = path,
                TotalLines = totalLines,
                StartLine = actualStart,
                EndLine = actualEnd,
                LinesReturned = filteredLines.Length,
                WasTruncated = wasTruncated,
                Encoding = fileInfo.Encoding ?? "utf-8",
                FileSize = fileInfo.Size,
                LastModified = fileInfo.LastModified
            };

            var message = wasTruncated
                ? $"Read lines {actualStart}-{actualEnd} of {totalLines} (truncated to {maxLines} lines)"
                : $"Read {filteredLines.Length} lines from {path}";

            return ToolResult.Success(output, resultData, message);
        }
        catch (UnauthorizedAccessException)
        {
            return ToolResult.Failed($"Access denied: {path}");
        }
        catch (IOException ex)
        {
            _logger.LogError(ex, "Failed to read file: {Path}", path);
            return ToolResult.Failed($"Failed to read file: {ex.Message}");
        }
    }

    private (string[] Lines, int Start, int End, bool Truncated) ApplyLineFilter(
        string[] lines, int? startLine, int? endLine, int maxLines)
    {
        var start = Math.Max(1, startLine ?? 1);
        var end = Math.Min(lines.Length, endLine ?? lines.Length);

        // Adjust for 0-based indexing
        var startIndex = start - 1;
        var endIndex = end;

        var selectedLines = lines[startIndex..endIndex];
        var truncated = false;

        if (selectedLines.Length > maxLines)
        {
            selectedLines = selectedLines[..maxLines];
            truncated = true;
            end = start + maxLines - 1;
        }

        return (selectedLines, start, end, truncated);
    }

    private string FormatOutput(string[] lines, int startLine, bool includeLineNumbers)
    {
        if (!includeLineNumbers)
        {
            return string.Join('\n', lines);
        }

        var sb = new StringBuilder();
        var lineNumWidth = (startLine + lines.Length - 1).ToString().Length;

        for (int i = 0; i < lines.Length; i++)
        {
            var lineNum = (startLine + i).ToString().PadLeft(lineNumWidth);
            sb.AppendLine($"{lineNum} | {lines[i]}");
        }

        return sb.ToString().TrimEnd();
    }

    public override string GetExecutionSummary(JsonElement parameters)
    {
        var path = parameters.GetProperty("path").GetString() ?? "unknown";
        var shortPath = path.Length > 40 ? "..." + path[^37..] : path;

        if (parameters.TryGetProperty("start_line", out var start))
        {
            var startLine = start.GetInt32();
            if (parameters.TryGetProperty("end_line", out var end))
            {
                return $"Read '{shortPath}' lines {startLine}-{end.GetInt32()}";
            }
            return $"Read '{shortPath}' from line {startLine}";
        }

        return $"Read file '{shortPath}'";
    }

    public override ToolValidationResult Validate(JsonElement parameters)
    {
        var errors = new List<ToolValidationError>();

        if (!parameters.TryGetProperty("path", out var pathProp) ||
            string.IsNullOrWhiteSpace(pathProp.GetString()))
        {
            errors.Add(new ToolValidationError
            {
                ParameterName = "path",
                Message = "Path is required",
                Code = "REQUIRED"
            });
        }

        if (parameters.TryGetProperty("start_line", out var start) && start.GetInt32() < 1)
        {
            errors.Add(new ToolValidationError
            {
                ParameterName = "start_line",
                Message = "Start line must be at least 1",
                Code = "INVALID_RANGE"
            });
        }

        if (parameters.TryGetProperty("end_line", out var end))
        {
            var endLine = end.GetInt32();
            if (endLine < 1)
            {
                errors.Add(new ToolValidationError
                {
                    ParameterName = "end_line",
                    Message = "End line must be at least 1",
                    Code = "INVALID_RANGE"
                });
            }

            if (parameters.TryGetProperty("start_line", out start) && endLine < start.GetInt32())
            {
                errors.Add(new ToolValidationError
                {
                    ParameterName = "end_line",
                    Message = "End line must be >= start line",
                    Code = "INVALID_RANGE"
                });
            }
        }

        return errors.Count > 0
            ? ToolValidationResult.Invalid(errors)
            : ToolValidationResult.Valid();
    }
}

/// <summary>
/// Result data for file read operations.
/// </summary>
public sealed class ReadFileResultData
{
    public string Path { get; init; } = string.Empty;
    public int TotalLines { get; init; }
    public int StartLine { get; init; }
    public int EndLine { get; init; }
    public int LinesReturned { get; init; }
    public bool WasTruncated { get; init; }
    public string Encoding { get; init; } = "utf-8";
    public long FileSize { get; init; }
    public DateTime? LastModified { get; init; }
}
```

### IFileSystemService Extensions

```csharp
namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Extended file information for tool operations.
/// </summary>
public sealed class FileInfoResult
{
    public string Path { get; init; } = string.Empty;
    public long Size { get; init; }
    public DateTime? LastModified { get; init; }
    public DateTime? Created { get; init; }
    public string? Encoding { get; init; }
    public bool IsReadOnly { get; init; }
    public bool IsHidden { get; init; }
}

/// <summary>
/// Extensions to IFileSystemService for tool support.
/// </summary>
public interface IFileSystemService
{
    // ... existing methods ...

    /// <summary>
    /// Get detailed file information.
    /// </summary>
    Task<FileInfoResult> GetFileInfoAsync(string path, CancellationToken ct = default);

    /// <summary>
    /// Check if a file exists.
    /// </summary>
    Task<bool> FileExistsAsync(string path, CancellationToken ct = default);

    /// <summary>
    /// Check if a directory exists.
    /// </summary>
    Task<bool> DirectoryExistsAsync(string path, CancellationToken ct = default);

    /// <summary>
    /// Read file content as string.
    /// </summary>
    Task<string> ReadFileAsync(string path, CancellationToken ct = default);

    /// <summary>
    /// Read file content as bytes.
    /// </summary>
    Task<byte[]> ReadFileBytesAsync(string path, CancellationToken ct = default);
}
```

### Files to Create (v0.6.3a)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Services/Tools/FileSystem/ReadFileTool.cs` | Read file tool implementation |
| `src/SeniorIntern.Services/Tools/FileSystem/ReadFileResultData.cs` | Result data model |
| `src/SeniorIntern.Services/Tools/ToolPathHelper.cs` | Path validation utilities |

### Files to Modify (v0.6.3a)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/IFileSystemService.cs` | Add GetFileInfoAsync method |

### Acceptance Criteria (v0.6.3a)
- [ ] ReadFileTool reads files from workspace
- [ ] Line filtering works with start_line and end_line
- [ ] Large files are rejected with clear message
- [ ] Line numbers are optionally included
- [ ] File encoding is detected
- [ ] Path validation prevents directory traversal

---

## v0.6.3b: File Write Tools

### Objective
Implement the WriteFileTool that enables the AI agent to create and modify files in the workspace, with support for automatic directory creation, backup handling, and diff preview.

### WriteFileTool Implementation

```csharp
namespace SeniorIntern.Services.Tools.FileSystem;

/// <summary>
/// Tool for writing content to files in the workspace.
/// Supports creating new files and modifying existing ones.
/// </summary>
public sealed class WriteFileTool : ToolBase
{
    public override string Id => "file-write";
    public override string Name => "Write File";
    public override string Description => """
        Write content to a file in the workspace.
        Creates the file if it doesn't exist, or overwrites if it does.
        Parent directories are created automatically.

        Use this when you need to:
        - Create new source files
        - Modify existing files (provide complete new content)
        - Create configuration files

        Note: For small edits, consider using file-patch instead.
        """;

    public override ToolCategory Category => ToolCategory.FileSystem;
    public override RiskLevel DefaultRiskLevel => RiskLevel.Medium;
    public override IReadOnlyList<string> Tags => new[] { "file", "write", "create", "modify" };

    public override JsonSchema InputSchema => JsonSchemaBuilder.Create()
        .WithDescription("Parameters for writing a file")
        .AddString("path", "Relative path for the file within the workspace", required: true)
        .AddString("content", "Content to write to the file", required: true)
        .AddBoolean("create_directories", "Create parent directories if needed (default: true)", required: false)
        .AddBoolean("create_backup", "Create backup of existing file (default: false)", required: false)
        .AddString("encoding", "File encoding: utf-8, utf-8-bom, ascii, utf-16 (default: utf-8)", required: false)
        .Build();

    private readonly IFileSystemService _fileSystem;
    private readonly IWorkspaceService _workspace;
    private readonly ILogger<WriteFileTool> _logger;

    private const int MaxFileSizeBytes = 5 * 1024 * 1024; // 5 MB write limit

    public WriteFileTool(
        IFileSystemService fileSystem,
        IWorkspaceService workspace,
        ILogger<WriteFileTool> logger)
    {
        _fileSystem = fileSystem;
        _workspace = workspace;
        _logger = logger;
    }

    public override bool IsAvailable =>
        _workspace.CurrentWorkspace != null;

    public override async Task<ToolResult> ExecuteAsync(
        ToolExecutionContext context,
        CancellationToken ct = default)
    {
        var path = GetRequiredParameter<string>(context.Parameters, "path");
        var content = GetRequiredParameter<string>(context.Parameters, "content");
        var createDirs = GetOptionalParameter<bool>(context.Parameters, "create_directories", true);
        var createBackup = GetOptionalParameter<bool>(context.Parameters, "create_backup", false);
        var encodingName = GetOptionalParameter<string>(context.Parameters, "encoding", "utf-8");

        // Resolve and validate path
        var fullPath = ResolvePath(context.WorkspacePath, path);
        var pathValidation = ValidatePath(fullPath, context.WorkspacePath);
        if (!pathValidation.IsValid)
        {
            return ToolResult.Failed(pathValidation.ErrorMessage!);
        }

        // Check content size
        var contentBytes = GetEncoding(encodingName).GetByteCount(content);
        if (contentBytes > MaxFileSizeBytes)
        {
            return ToolResult.Failed(
                $"Content too large ({FormatFileSize(contentBytes)}). Maximum: {FormatFileSize(MaxFileSizeBytes)}");
        }

        try
        {
            var isNewFile = !await _fileSystem.FileExistsAsync(fullPath, ct);
            var previousContent = string.Empty;
            var backupPath = string.Empty;

            // Handle existing file
            if (!isNewFile)
            {
                previousContent = await _fileSystem.ReadFileAsync(fullPath, ct);

                // Create backup if requested
                if (createBackup)
                {
                    backupPath = await CreateBackupAsync(fullPath, ct);
                }
            }

            // Create parent directories
            var directory = Path.GetDirectoryName(fullPath);
            if (createDirs && !string.IsNullOrEmpty(directory))
            {
                if (!await _fileSystem.DirectoryExistsAsync(directory, ct))
                {
                    await _fileSystem.CreateDirectoryAsync(directory, ct);
                }
            }
            else if (!string.IsNullOrEmpty(directory) &&
                     !await _fileSystem.DirectoryExistsAsync(directory, ct))
            {
                return ToolResult.Failed($"Directory does not exist: {Path.GetDirectoryName(path)}");
            }

            // Write file
            await _fileSystem.WriteFileAsync(fullPath, content, GetEncoding(encodingName), ct);

            // Calculate diff statistics
            var diffStats = CalculateDiffStats(previousContent, content);

            var resultData = new WriteFileResultData
            {
                Path = path,
                IsNewFile = isNewFile,
                BytesWritten = contentBytes,
                LineCount = content.Split('\n').Length,
                BackupPath = string.IsNullOrEmpty(backupPath) ? null : backupPath,
                LinesAdded = diffStats.Added,
                LinesRemoved = diffStats.Removed,
                LinesChanged = diffStats.Changed
            };

            var message = isNewFile
                ? $"Created file: {path} ({resultData.LineCount} lines)"
                : $"Updated file: {path} (+{diffStats.Added}/-{diffStats.Removed} lines)";

            return ToolResult.Success(content: null, resultData, message)
                .WithArtifact(new ToolArtifact
                {
                    Type = ToolArtifactType.File,
                    Path = fullPath,
                    Description = isNewFile ? "Created file" : "Modified file"
                });
        }
        catch (UnauthorizedAccessException)
        {
            return ToolResult.Failed($"Access denied: {path}");
        }
        catch (IOException ex)
        {
            _logger.LogError(ex, "Failed to write file: {Path}", path);
            return ToolResult.Failed($"Failed to write file: {ex.Message}");
        }
    }

    private async Task<string> CreateBackupAsync(string filePath, CancellationToken ct)
    {
        var timestamp = DateTime.Now.ToString("yyyyMMdd_HHmmss");
        var backupPath = $"{filePath}.{timestamp}.bak";
        await _fileSystem.CopyFileAsync(filePath, backupPath, ct);
        return backupPath;
    }

    private Encoding GetEncoding(string name) => name.ToLowerInvariant() switch
    {
        "utf-8" => new UTF8Encoding(false),
        "utf-8-bom" => new UTF8Encoding(true),
        "ascii" => Encoding.ASCII,
        "utf-16" or "unicode" => Encoding.Unicode,
        _ => new UTF8Encoding(false)
    };

    private (int Added, int Removed, int Changed) CalculateDiffStats(string oldContent, string newContent)
    {
        if (string.IsNullOrEmpty(oldContent))
        {
            return (newContent.Split('\n').Length, 0, 0);
        }

        var oldLines = oldContent.Split('\n').ToHashSet();
        var newLines = newContent.Split('\n');

        var added = newLines.Count(l => !oldLines.Contains(l));
        var removed = oldLines.Count(l => !newLines.Contains(l));

        return (added, removed, 0);
    }

    public override string GetExecutionSummary(JsonElement parameters)
    {
        var path = parameters.GetProperty("path").GetString() ?? "unknown";
        var shortPath = path.Length > 35 ? "..." + path[^32..] : path;

        var content = parameters.GetProperty("content").GetString() ?? "";
        var lines = content.Split('\n').Length;

        return $"Write {lines} lines to '{shortPath}'";
    }

    public override RiskLevel GetEffectiveRiskLevel(JsonElement parameters)
    {
        var path = parameters.GetProperty("path").GetString() ?? "";

        // Higher risk for configuration files
        if (IsConfigurationFile(path))
        {
            return RiskLevel.High;
        }

        // Higher risk for overwriting existing files (checked at runtime)
        return RiskLevel.Medium;
    }

    private bool IsConfigurationFile(string path)
    {
        var configPatterns = new[]
        {
            ".env", ".gitignore", "package.json", "tsconfig.json",
            ".csproj", ".sln", "Cargo.toml", "go.mod", "Dockerfile",
            "docker-compose", ".yml", ".yaml", "Makefile"
        };

        var fileName = Path.GetFileName(path).ToLowerInvariant();
        return configPatterns.Any(p => fileName.Contains(p));
    }

    public override ToolValidationResult Validate(JsonElement parameters)
    {
        var errors = new List<ToolValidationError>();

        if (!parameters.TryGetProperty("path", out var pathProp) ||
            string.IsNullOrWhiteSpace(pathProp.GetString()))
        {
            errors.Add(new ToolValidationError
            {
                ParameterName = "path",
                Message = "Path is required",
                Code = "REQUIRED"
            });
        }

        if (!parameters.TryGetProperty("content", out _))
        {
            errors.Add(new ToolValidationError
            {
                ParameterName = "content",
                Message = "Content is required",
                Code = "REQUIRED"
            });
        }

        if (parameters.TryGetProperty("encoding", out var enc))
        {
            var encoding = enc.GetString()?.ToLowerInvariant();
            var validEncodings = new[] { "utf-8", "utf-8-bom", "ascii", "utf-16", "unicode" };
            if (!validEncodings.Contains(encoding))
            {
                errors.Add(new ToolValidationError
                {
                    ParameterName = "encoding",
                    Message = $"Invalid encoding. Valid options: {string.Join(", ", validEncodings)}",
                    Code = "INVALID_VALUE"
                });
            }
        }

        return errors.Count > 0
            ? ToolValidationResult.Invalid(errors)
            : ToolValidationResult.Valid();
    }
}

/// <summary>
/// Result data for file write operations.
/// </summary>
public sealed class WriteFileResultData
{
    public string Path { get; init; } = string.Empty;
    public bool IsNewFile { get; init; }
    public int BytesWritten { get; init; }
    public int LineCount { get; init; }
    public string? BackupPath { get; init; }
    public int LinesAdded { get; init; }
    public int LinesRemoved { get; init; }
    public int LinesChanged { get; init; }
}
```

### FilePatchTool Implementation

```csharp
namespace SeniorIntern.Services.Tools.FileSystem;

/// <summary>
/// Tool for applying targeted edits to files.
/// More efficient than WriteFileTool for small changes.
/// </summary>
public sealed class FilePatchTool : ToolBase
{
    public override string Id => "file-patch";
    public override string Name => "Patch File";
    public override string Description => """
        Apply targeted edits to an existing file.
        Finds and replaces specific text content.
        Use this for making small, precise changes without rewriting entire files.

        The tool will find the exact 'old_content' in the file and replace it with 'new_content'.
        The old_content must match exactly (including whitespace).
        """;

    public override ToolCategory Category => ToolCategory.FileSystem;
    public override RiskLevel DefaultRiskLevel => RiskLevel.Medium;
    public override IReadOnlyList<string> Tags => new[] { "file", "edit", "patch", "replace" };

    public override JsonSchema InputSchema => JsonSchemaBuilder.Create()
        .WithDescription("Parameters for patching a file")
        .AddString("path", "Relative path to the file to patch", required: true)
        .AddString("old_content", "Exact content to find and replace", required: true)
        .AddString("new_content", "Content to replace with", required: true)
        .AddInteger("occurrence", "Which occurrence to replace (1-based, 0 for all, default: 1)", required: false)
        .Build();

    private readonly IFileSystemService _fileSystem;
    private readonly IWorkspaceService _workspace;
    private readonly ILogger<FilePatchTool> _logger;

    public FilePatchTool(
        IFileSystemService fileSystem,
        IWorkspaceService workspace,
        ILogger<FilePatchTool> logger)
    {
        _fileSystem = fileSystem;
        _workspace = workspace;
        _logger = logger;
    }

    public override bool IsAvailable =>
        _workspace.CurrentWorkspace != null;

    public override async Task<ToolResult> ExecuteAsync(
        ToolExecutionContext context,
        CancellationToken ct = default)
    {
        var path = GetRequiredParameter<string>(context.Parameters, "path");
        var oldContent = GetRequiredParameter<string>(context.Parameters, "old_content");
        var newContent = GetRequiredParameter<string>(context.Parameters, "new_content");
        var occurrence = GetOptionalParameter<int>(context.Parameters, "occurrence", 1);

        // Resolve and validate path
        var fullPath = ResolvePath(context.WorkspacePath, path);
        var pathValidation = ValidatePath(fullPath, context.WorkspacePath);
        if (!pathValidation.IsValid)
        {
            return ToolResult.Failed(pathValidation.ErrorMessage!);
        }

        // Check file exists
        if (!await _fileSystem.FileExistsAsync(fullPath, ct))
        {
            return ToolResult.Failed($"File not found: {path}");
        }

        try
        {
            var content = await _fileSystem.ReadFileAsync(fullPath, ct);

            // Find occurrences
            var occurrences = FindOccurrences(content, oldContent);

            if (occurrences.Count == 0)
            {
                return ToolResult.Failed(
                    "Could not find the specified content in the file. " +
                    "Make sure the old_content matches exactly, including whitespace and line endings.");
            }

            // Apply replacement
            string newFileContent;
            int replacementCount;

            if (occurrence == 0)
            {
                // Replace all
                newFileContent = content.Replace(oldContent, newContent);
                replacementCount = occurrences.Count;
            }
            else if (occurrence > occurrences.Count)
            {
                return ToolResult.Failed(
                    $"Requested occurrence {occurrence} but only found {occurrences.Count} occurrence(s)");
            }
            else
            {
                // Replace specific occurrence
                var index = occurrences[occurrence - 1];
                newFileContent = content[..index] + newContent + content[(index + oldContent.Length)..];
                replacementCount = 1;
            }

            // Write file
            await _fileSystem.WriteFileAsync(fullPath, newFileContent, ct);

            var resultData = new FilePatchResultData
            {
                Path = path,
                OccurrencesFound = occurrences.Count,
                OccurrencesReplaced = replacementCount,
                OldContentLength = oldContent.Length,
                NewContentLength = newContent.Length,
                LinesAffected = CountLinesAffected(oldContent, newContent)
            };

            return ToolResult.Success(
                content: null,
                resultData,
                $"Patched {path}: replaced {replacementCount} occurrence(s)")
                .WithArtifact(new ToolArtifact
                {
                    Type = ToolArtifactType.File,
                    Path = fullPath,
                    Description = "Patched file"
                });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to patch file: {Path}", path);
            return ToolResult.Failed($"Failed to patch file: {ex.Message}");
        }
    }

    private List<int> FindOccurrences(string content, string search)
    {
        var indices = new List<int>();
        var index = 0;

        while ((index = content.IndexOf(search, index, StringComparison.Ordinal)) != -1)
        {
            indices.Add(index);
            index += search.Length;
        }

        return indices;
    }

    private int CountLinesAffected(string oldContent, string newContent)
    {
        var oldLines = oldContent.Split('\n').Length;
        var newLines = newContent.Split('\n').Length;
        return Math.Max(oldLines, newLines);
    }

    public override string GetExecutionSummary(JsonElement parameters)
    {
        var path = parameters.GetProperty("path").GetString() ?? "unknown";
        var shortPath = path.Length > 30 ? "..." + path[^27..] : path;
        return $"Patch file '{shortPath}'";
    }
}

/// <summary>
/// Result data for file patch operations.
/// </summary>
public sealed class FilePatchResultData
{
    public string Path { get; init; } = string.Empty;
    public int OccurrencesFound { get; init; }
    public int OccurrencesReplaced { get; init; }
    public int OldContentLength { get; init; }
    public int NewContentLength { get; init; }
    public int LinesAffected { get; init; }
}
```

### Files to Create (v0.6.3b)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Services/Tools/FileSystem/WriteFileTool.cs` | Write file tool |
| `src/SeniorIntern.Services/Tools/FileSystem/WriteFileResultData.cs` | Write result data |
| `src/SeniorIntern.Services/Tools/FileSystem/FilePatchTool.cs` | Patch file tool |
| `src/SeniorIntern.Services/Tools/FileSystem/FilePatchResultData.cs` | Patch result data |

### Files to Modify (v0.6.3b)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/IFileSystemService.cs` | Add WriteFileAsync, CopyFileAsync |

### Acceptance Criteria (v0.6.3b)
- [ ] WriteFileTool creates new files
- [ ] WriteFileTool overwrites existing files
- [ ] Parent directories are created automatically
- [ ] Backup creation works when requested
- [ ] FilePatchTool finds and replaces exact content
- [ ] Multiple occurrences can be targeted
- [ ] Encoding options are respected

---

## v0.6.3c: File Management Tools

### Objective
Implement file management tools for deleting, moving, and copying files within the workspace, with safety validations and proper error handling.

### DeleteFileTool Implementation

```csharp
namespace SeniorIntern.Services.Tools.FileSystem;

/// <summary>
/// Tool for deleting files from the workspace.
/// </summary>
public sealed class DeleteFileTool : ToolBase
{
    public override string Id => "file-delete";
    public override string Name => "Delete File";
    public override string Description => """
        Delete a file from the workspace.
        This operation cannot be undone (unless the file is under version control).

        Use with caution. Consider whether the file should be removed or renamed instead.
        """;

    public override ToolCategory Category => ToolCategory.FileSystem;
    public override RiskLevel DefaultRiskLevel => RiskLevel.High;
    public override IReadOnlyList<string> Tags => new[] { "file", "delete", "remove" };

    public override JsonSchema InputSchema => JsonSchemaBuilder.Create()
        .WithDescription("Parameters for deleting a file")
        .AddString("path", "Relative path to the file to delete", required: true)
        .Build();

    private readonly IFileSystemService _fileSystem;
    private readonly IWorkspaceService _workspace;
    private readonly ILogger<DeleteFileTool> _logger;

    public DeleteFileTool(
        IFileSystemService fileSystem,
        IWorkspaceService workspace,
        ILogger<DeleteFileTool> logger)
    {
        _fileSystem = fileSystem;
        _workspace = workspace;
        _logger = logger;
    }

    public override bool IsAvailable =>
        _workspace.CurrentWorkspace != null;

    public override async Task<ToolResult> ExecuteAsync(
        ToolExecutionContext context,
        CancellationToken ct = default)
    {
        var path = GetRequiredParameter<string>(context.Parameters, "path");

        var fullPath = ResolvePath(context.WorkspacePath, path);
        var pathValidation = ValidatePath(fullPath, context.WorkspacePath);
        if (!pathValidation.IsValid)
        {
            return ToolResult.Failed(pathValidation.ErrorMessage!);
        }

        if (!await _fileSystem.FileExistsAsync(fullPath, ct))
        {
            return ToolResult.Failed($"File not found: {path}");
        }

        try
        {
            // Get file info before deletion
            var fileInfo = await _fileSystem.GetFileInfoAsync(fullPath, ct);

            await _fileSystem.DeleteFileAsync(fullPath, ct);

            return ToolResult.Success(
                content: null,
                new { path, size = fileInfo.Size },
                $"Deleted file: {path}");
        }
        catch (UnauthorizedAccessException)
        {
            return ToolResult.Failed($"Access denied: {path}");
        }
        catch (IOException ex)
        {
            _logger.LogError(ex, "Failed to delete file: {Path}", path);
            return ToolResult.Failed($"Failed to delete file: {ex.Message}");
        }
    }

    public override string GetExecutionSummary(JsonElement parameters)
    {
        var path = parameters.GetProperty("path").GetString() ?? "unknown";
        return $"Delete file '{path}'";
    }

    public override RiskLevel GetEffectiveRiskLevel(JsonElement parameters)
    {
        // Always high risk for deletion
        return RiskLevel.High;
    }
}
```

### MoveFileTool Implementation

```csharp
namespace SeniorIntern.Services.Tools.FileSystem;

/// <summary>
/// Tool for moving or renaming files in the workspace.
/// </summary>
public sealed class MoveFileTool : ToolBase
{
    public override string Id => "file-move";
    public override string Name => "Move/Rename File";
    public override string Description => """
        Move a file to a new location or rename it.
        Creates parent directories for the destination automatically.

        Use this to:
        - Rename files
        - Move files to different directories
        - Reorganize project structure
        """;

    public override ToolCategory Category => ToolCategory.FileSystem;
    public override RiskLevel DefaultRiskLevel => RiskLevel.Medium;
    public override IReadOnlyList<string> Tags => new[] { "file", "move", "rename", "relocate" };

    public override JsonSchema InputSchema => JsonSchemaBuilder.Create()
        .WithDescription("Parameters for moving a file")
        .AddString("source", "Current path of the file", required: true)
        .AddString("destination", "New path for the file", required: true)
        .AddBoolean("overwrite", "Overwrite if destination exists (default: false)", required: false)
        .Build();

    private readonly IFileSystemService _fileSystem;
    private readonly IWorkspaceService _workspace;
    private readonly ILogger<MoveFileTool> _logger;

    public MoveFileTool(
        IFileSystemService fileSystem,
        IWorkspaceService workspace,
        ILogger<MoveFileTool> logger)
    {
        _fileSystem = fileSystem;
        _workspace = workspace;
        _logger = logger;
    }

    public override bool IsAvailable =>
        _workspace.CurrentWorkspace != null;

    public override async Task<ToolResult> ExecuteAsync(
        ToolExecutionContext context,
        CancellationToken ct = default)
    {
        var source = GetRequiredParameter<string>(context.Parameters, "source");
        var destination = GetRequiredParameter<string>(context.Parameters, "destination");
        var overwrite = GetOptionalParameter<bool>(context.Parameters, "overwrite", false);

        var sourcePath = ResolvePath(context.WorkspacePath, source);
        var destPath = ResolvePath(context.WorkspacePath, destination);

        // Validate both paths
        var sourceValidation = ValidatePath(sourcePath, context.WorkspacePath);
        if (!sourceValidation.IsValid)
        {
            return ToolResult.Failed($"Invalid source: {sourceValidation.ErrorMessage}");
        }

        var destValidation = ValidatePath(destPath, context.WorkspacePath);
        if (!destValidation.IsValid)
        {
            return ToolResult.Failed($"Invalid destination: {destValidation.ErrorMessage}");
        }

        if (!await _fileSystem.FileExistsAsync(sourcePath, ct))
        {
            return ToolResult.Failed($"Source file not found: {source}");
        }

        if (await _fileSystem.FileExistsAsync(destPath, ct) && !overwrite)
        {
            return ToolResult.Failed(
                $"Destination already exists: {destination}. Set overwrite=true to replace.");
        }

        try
        {
            // Create destination directory if needed
            var destDir = Path.GetDirectoryName(destPath);
            if (!string.IsNullOrEmpty(destDir) && !await _fileSystem.DirectoryExistsAsync(destDir, ct))
            {
                await _fileSystem.CreateDirectoryAsync(destDir, ct);
            }

            await _fileSystem.MoveFileAsync(sourcePath, destPath, overwrite, ct);

            return ToolResult.Success(
                content: null,
                new { source, destination },
                $"Moved: {source} → {destination}")
                .WithArtifact(new ToolArtifact
                {
                    Type = ToolArtifactType.File,
                    Path = destPath,
                    Description = "Moved file"
                });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to move file: {Source} -> {Dest}", source, destination);
            return ToolResult.Failed($"Failed to move file: {ex.Message}");
        }
    }

    public override string GetExecutionSummary(JsonElement parameters)
    {
        var source = parameters.GetProperty("source").GetString() ?? "?";
        var dest = parameters.GetProperty("destination").GetString() ?? "?";

        // Shorten paths for summary
        var shortSource = Path.GetFileName(source);
        var shortDest = Path.GetFileName(dest);

        if (Path.GetDirectoryName(source) == Path.GetDirectoryName(dest))
        {
            return $"Rename '{shortSource}' to '{shortDest}'";
        }

        return $"Move '{shortSource}' to '{dest}'";
    }
}
```

### CopyFileTool Implementation

```csharp
namespace SeniorIntern.Services.Tools.FileSystem;

/// <summary>
/// Tool for copying files within the workspace.
/// </summary>
public sealed class CopyFileTool : ToolBase
{
    public override string Id => "file-copy";
    public override string Name => "Copy File";
    public override string Description => """
        Copy a file to a new location.
        Creates parent directories for the destination automatically.

        The original file remains unchanged.
        """;

    public override ToolCategory Category => ToolCategory.FileSystem;
    public override RiskLevel DefaultRiskLevel => RiskLevel.Low;
    public override IReadOnlyList<string> Tags => new[] { "file", "copy", "duplicate" };

    public override JsonSchema InputSchema => JsonSchemaBuilder.Create()
        .WithDescription("Parameters for copying a file")
        .AddString("source", "Path of the file to copy", required: true)
        .AddString("destination", "Destination path for the copy", required: true)
        .AddBoolean("overwrite", "Overwrite if destination exists (default: false)", required: false)
        .Build();

    private readonly IFileSystemService _fileSystem;
    private readonly IWorkspaceService _workspace;
    private readonly ILogger<CopyFileTool> _logger;

    public CopyFileTool(
        IFileSystemService fileSystem,
        IWorkspaceService workspace,
        ILogger<CopyFileTool> logger)
    {
        _fileSystem = fileSystem;
        _workspace = workspace;
        _logger = logger;
    }

    public override bool IsAvailable =>
        _workspace.CurrentWorkspace != null;

    public override async Task<ToolResult> ExecuteAsync(
        ToolExecutionContext context,
        CancellationToken ct = default)
    {
        var source = GetRequiredParameter<string>(context.Parameters, "source");
        var destination = GetRequiredParameter<string>(context.Parameters, "destination");
        var overwrite = GetOptionalParameter<bool>(context.Parameters, "overwrite", false);

        var sourcePath = ResolvePath(context.WorkspacePath, source);
        var destPath = ResolvePath(context.WorkspacePath, destination);

        // Validate paths
        var sourceValidation = ValidatePath(sourcePath, context.WorkspacePath);
        if (!sourceValidation.IsValid)
        {
            return ToolResult.Failed($"Invalid source: {sourceValidation.ErrorMessage}");
        }

        var destValidation = ValidatePath(destPath, context.WorkspacePath);
        if (!destValidation.IsValid)
        {
            return ToolResult.Failed($"Invalid destination: {destValidation.ErrorMessage}");
        }

        if (!await _fileSystem.FileExistsAsync(sourcePath, ct))
        {
            return ToolResult.Failed($"Source file not found: {source}");
        }

        if (await _fileSystem.FileExistsAsync(destPath, ct) && !overwrite)
        {
            return ToolResult.Failed(
                $"Destination already exists: {destination}. Set overwrite=true to replace.");
        }

        try
        {
            // Create destination directory if needed
            var destDir = Path.GetDirectoryName(destPath);
            if (!string.IsNullOrEmpty(destDir) && !await _fileSystem.DirectoryExistsAsync(destDir, ct))
            {
                await _fileSystem.CreateDirectoryAsync(destDir, ct);
            }

            await _fileSystem.CopyFileAsync(sourcePath, destPath, overwrite, ct);

            var fileInfo = await _fileSystem.GetFileInfoAsync(destPath, ct);

            return ToolResult.Success(
                content: null,
                new { source, destination, size = fileInfo.Size },
                $"Copied: {source} → {destination}")
                .WithArtifact(new ToolArtifact
                {
                    Type = ToolArtifactType.File,
                    Path = destPath,
                    Description = "Copied file"
                });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to copy file: {Source} -> {Dest}", source, destination);
            return ToolResult.Failed($"Failed to copy file: {ex.Message}");
        }
    }

    public override string GetExecutionSummary(JsonElement parameters)
    {
        var source = Path.GetFileName(parameters.GetProperty("source").GetString() ?? "?");
        var dest = parameters.GetProperty("destination").GetString() ?? "?";
        return $"Copy '{source}' to '{dest}'";
    }
}
```

### Files to Create (v0.6.3c)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Services/Tools/FileSystem/DeleteFileTool.cs` | Delete file tool |
| `src/SeniorIntern.Services/Tools/FileSystem/MoveFileTool.cs` | Move/rename tool |
| `src/SeniorIntern.Services/Tools/FileSystem/CopyFileTool.cs` | Copy file tool |

### Files to Modify (v0.6.3c)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/IFileSystemService.cs` | Add DeleteFileAsync, MoveFileAsync |

### Acceptance Criteria (v0.6.3c)
- [ ] DeleteFileTool removes files with confirmation
- [ ] MoveFileTool relocates files to new paths
- [ ] MoveFileTool renames files in same directory
- [ ] CopyFileTool duplicates files
- [ ] All tools validate paths are within workspace
- [ ] Overwrite protection works correctly

---

## v0.6.3d: Directory Tools

### Objective
Implement directory tools for listing contents, creating directories, and viewing directory trees with filtering and size calculation.

### ListDirectoryTool Implementation

```csharp
namespace SeniorIntern.Services.Tools.FileSystem;

/// <summary>
/// Tool for listing directory contents.
/// </summary>
public sealed class ListDirectoryTool : ToolBase
{
    public override string Id => "directory-list";
    public override string Name => "List Directory";
    public override string Description => """
        List files and directories at a given path.
        Returns names, types, sizes, and modification dates.

        Use this to explore the workspace structure and find files.
        """;

    public override ToolCategory Category => ToolCategory.FileSystem;
    public override RiskLevel DefaultRiskLevel => RiskLevel.Safe;
    public override IReadOnlyList<string> Tags => new[] { "directory", "list", "files", "explore" };

    public override JsonSchema InputSchema => JsonSchemaBuilder.Create()
        .WithDescription("Parameters for listing a directory")
        .AddString("path", "Directory path (default: workspace root)", required: false)
        .AddBoolean("recursive", "List contents recursively (default: false)", required: false)
        .AddInteger("max_depth", "Maximum recursion depth (default: 3)", required: false)
        .AddBoolean("include_hidden", "Include hidden files/directories (default: false)", required: false)
        .AddBoolean("include_size", "Calculate file sizes (default: true)", required: false)
        .AddString("sort_by", "Sort by: name, size, modified (default: name)", required: false)
        .Build();

    private readonly IFileSystemService _fileSystem;
    private readonly IWorkspaceService _workspace;

    private const int MaxEntries = 1000;
    private const int DefaultMaxDepth = 3;

    public ListDirectoryTool(
        IFileSystemService fileSystem,
        IWorkspaceService workspace)
    {
        _fileSystem = fileSystem;
        _workspace = workspace;
    }

    public override bool IsAvailable =>
        _workspace.CurrentWorkspace != null;

    public override async Task<ToolResult> ExecuteAsync(
        ToolExecutionContext context,
        CancellationToken ct = default)
    {
        var path = GetOptionalParameter<string>(context.Parameters, "path", ".");
        var recursive = GetOptionalParameter<bool>(context.Parameters, "recursive", false);
        var maxDepth = GetOptionalParameter<int>(context.Parameters, "max_depth", DefaultMaxDepth);
        var includeHidden = GetOptionalParameter<bool>(context.Parameters, "include_hidden", false);
        var includeSize = GetOptionalParameter<bool>(context.Parameters, "include_size", true);
        var sortBy = GetOptionalParameter<string>(context.Parameters, "sort_by", "name");

        var fullPath = ResolvePath(context.WorkspacePath, path);
        var pathValidation = ValidatePath(fullPath, context.WorkspacePath);
        if (!pathValidation.IsValid)
        {
            return ToolResult.Failed(pathValidation.ErrorMessage!);
        }

        if (!await _fileSystem.DirectoryExistsAsync(fullPath, ct))
        {
            return ToolResult.Failed($"Directory not found: {path}");
        }

        try
        {
            var entries = new List<DirectoryEntry>();
            await CollectEntriesAsync(
                fullPath, context.WorkspacePath!, recursive, maxDepth, 0,
                includeHidden, includeSize, entries, ct);

            // Sort entries
            entries = SortEntries(entries, sortBy);

            // Check if truncated
            var truncated = entries.Count > MaxEntries;
            if (truncated)
            {
                entries = entries.Take(MaxEntries).ToList();
            }

            // Format output
            var output = FormatOutput(entries, context.WorkspacePath!);

            var resultData = new ListDirectoryResultData
            {
                Path = path,
                TotalEntries = entries.Count,
                FileCount = entries.Count(e => e.Type == "file"),
                DirectoryCount = entries.Count(e => e.Type == "directory"),
                TotalSize = entries.Where(e => e.Type == "file").Sum(e => e.Size),
                WasTruncated = truncated
            };

            return ToolResult.Success(output, resultData,
                $"Found {entries.Count} items in {path}");
        }
        catch (Exception ex)
        {
            return ToolResult.Failed($"Failed to list directory: {ex.Message}");
        }
    }

    private async Task CollectEntriesAsync(
        string path, string workspacePath, bool recursive, int maxDepth, int currentDepth,
        bool includeHidden, bool includeSize, List<DirectoryEntry> entries,
        CancellationToken ct)
    {
        if (entries.Count >= MaxEntries) return;
        if (recursive && currentDepth > maxDepth) return;

        var options = new EnumerationOptions
        {
            AttributesToSkip = includeHidden ? 0 : FileAttributes.Hidden
        };

        // Get directories
        foreach (var dir in Directory.EnumerateDirectories(path, "*", options))
        {
            ct.ThrowIfCancellationRequested();
            if (entries.Count >= MaxEntries) break;

            var name = Path.GetRelativePath(workspacePath, dir);
            entries.Add(new DirectoryEntry
            {
                Name = name,
                Type = "directory",
                Modified = Directory.GetLastWriteTimeUtc(dir)
            });

            if (recursive)
            {
                await CollectEntriesAsync(
                    dir, workspacePath, recursive, maxDepth, currentDepth + 1,
                    includeHidden, includeSize, entries, ct);
            }
        }

        // Get files
        foreach (var file in Directory.EnumerateFiles(path, "*", options))
        {
            ct.ThrowIfCancellationRequested();
            if (entries.Count >= MaxEntries) break;

            var info = new FileInfo(file);
            var name = Path.GetRelativePath(workspacePath, file);

            entries.Add(new DirectoryEntry
            {
                Name = name,
                Type = "file",
                Size = includeSize ? info.Length : 0,
                Modified = info.LastWriteTimeUtc
            });
        }
    }

    private List<DirectoryEntry> SortEntries(List<DirectoryEntry> entries, string sortBy)
    {
        return sortBy.ToLowerInvariant() switch
        {
            "size" => entries.OrderByDescending(e => e.Size).ThenBy(e => e.Name).ToList(),
            "modified" => entries.OrderByDescending(e => e.Modified).ThenBy(e => e.Name).ToList(),
            _ => entries.OrderBy(e => e.Type).ThenBy(e => e.Name).ToList()
        };
    }

    private string FormatOutput(List<DirectoryEntry> entries, string workspacePath)
    {
        var sb = new StringBuilder();

        foreach (var entry in entries)
        {
            var icon = entry.Type == "directory" ? "📁" : "📄";
            var size = entry.Type == "file" ? $" ({FormatFileSize(entry.Size)})" : "";
            sb.AppendLine($"{icon} {entry.Name}{size}");
        }

        return sb.ToString().TrimEnd();
    }

    public override string GetExecutionSummary(JsonElement parameters)
    {
        var path = parameters.TryGetProperty("path", out var p) ? p.GetString() : ".";
        var recursive = parameters.TryGetProperty("recursive", out var r) && r.GetBoolean();

        return recursive ? $"List '{path}' recursively" : $"List '{path}'";
    }
}

/// <summary>
/// A directory entry (file or subdirectory).
/// </summary>
public sealed class DirectoryEntry
{
    public string Name { get; init; } = string.Empty;
    public string Type { get; init; } = string.Empty; // "file" or "directory"
    public long Size { get; init; }
    public DateTime Modified { get; init; }
}

/// <summary>
/// Result data for directory listing.
/// </summary>
public sealed class ListDirectoryResultData
{
    public string Path { get; init; } = string.Empty;
    public int TotalEntries { get; init; }
    public int FileCount { get; init; }
    public int DirectoryCount { get; init; }
    public long TotalSize { get; init; }
    public bool WasTruncated { get; init; }
}
```

### CreateDirectoryTool Implementation

```csharp
namespace SeniorIntern.Services.Tools.FileSystem;

/// <summary>
/// Tool for creating directories.
/// </summary>
public sealed class CreateDirectoryTool : ToolBase
{
    public override string Id => "directory-create";
    public override string Name => "Create Directory";
    public override string Description => """
        Create a new directory in the workspace.
        Parent directories are created automatically if they don't exist.
        """;

    public override ToolCategory Category => ToolCategory.FileSystem;
    public override RiskLevel DefaultRiskLevel => RiskLevel.Low;
    public override IReadOnlyList<string> Tags => new[] { "directory", "create", "folder" };

    public override JsonSchema InputSchema => JsonSchemaBuilder.Create()
        .WithDescription("Parameters for creating a directory")
        .AddString("path", "Path for the new directory", required: true)
        .Build();

    private readonly IFileSystemService _fileSystem;
    private readonly IWorkspaceService _workspace;

    public CreateDirectoryTool(
        IFileSystemService fileSystem,
        IWorkspaceService workspace)
    {
        _fileSystem = fileSystem;
        _workspace = workspace;
    }

    public override bool IsAvailable =>
        _workspace.CurrentWorkspace != null;

    public override async Task<ToolResult> ExecuteAsync(
        ToolExecutionContext context,
        CancellationToken ct = default)
    {
        var path = GetRequiredParameter<string>(context.Parameters, "path");

        var fullPath = ResolvePath(context.WorkspacePath, path);
        var pathValidation = ValidatePath(fullPath, context.WorkspacePath);
        if (!pathValidation.IsValid)
        {
            return ToolResult.Failed(pathValidation.ErrorMessage!);
        }

        if (await _fileSystem.DirectoryExistsAsync(fullPath, ct))
        {
            return ToolResult.Success(
                content: null,
                new { path, already_existed = true },
                $"Directory already exists: {path}");
        }

        try
        {
            await _fileSystem.CreateDirectoryAsync(fullPath, ct);

            return ToolResult.Success(
                content: null,
                new { path, created = true },
                $"Created directory: {path}");
        }
        catch (Exception ex)
        {
            return ToolResult.Failed($"Failed to create directory: {ex.Message}");
        }
    }

    public override string GetExecutionSummary(JsonElement parameters)
    {
        var path = parameters.GetProperty("path").GetString() ?? "?";
        return $"Create directory '{path}'";
    }
}
```

### Files to Create (v0.6.3d)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Services/Tools/FileSystem/ListDirectoryTool.cs` | List directory tool |
| `src/SeniorIntern.Services/Tools/FileSystem/CreateDirectoryTool.cs` | Create directory tool |
| `src/SeniorIntern.Services/Tools/FileSystem/DeleteDirectoryTool.cs` | Delete directory tool |
| `src/SeniorIntern.Services/Tools/FileSystem/DirectoryEntry.cs` | Entry model |
| `src/SeniorIntern.Services/Tools/FileSystem/ListDirectoryResultData.cs` | Result data model |

### Acceptance Criteria (v0.6.3d)
- [ ] ListDirectoryTool returns files and directories
- [ ] Recursive listing respects max depth
- [ ] Hidden files are optionally included
- [ ] Results are sorted by name/size/date
- [ ] CreateDirectoryTool creates nested directories
- [ ] Large directories are properly truncated

---

## v0.6.3e: Terminal Command Tool

### Objective
Implement the RunCommandTool that enables the AI agent to execute shell commands in the workspace, with output capture, timeout handling, and security validations for dangerous commands.

### RunCommandTool Implementation

```csharp
namespace SeniorIntern.Services.Tools.Terminal;

/// <summary>
/// Tool for executing shell commands in the terminal.
/// </summary>
public sealed class RunCommandTool : ToolBase
{
    public override string Id => "terminal-run";
    public override string Name => "Run Command";
    public override string Description => """
        Execute a shell command in the integrated terminal.
        Returns the command output (stdout and stderr combined).
        Commands run in the workspace directory by default.

        Use this to:
        - Run build commands (dotnet build, npm run build)
        - Execute tests (dotnet test, npm test)
        - Install packages (dotnet add package, npm install)
        - Run scripts and tools

        Important: Be cautious with commands that modify the system.
        """;

    public override ToolCategory Category => ToolCategory.Terminal;
    public override RiskLevel DefaultRiskLevel => RiskLevel.High;
    public override IReadOnlyList<string> Tags => new[] { "terminal", "command", "shell", "execute" };

    public override JsonSchema InputSchema => JsonSchemaBuilder.Create()
        .WithDescription("Parameters for running a command")
        .AddString("command", "The command to execute", required: true)
        .AddString("working_directory", "Working directory (default: workspace root)", required: false)
        .AddInteger("timeout_seconds", "Timeout in seconds (default: 120, max: 600)", required: false)
        .AddBoolean("capture_output", "Capture output instead of streaming to terminal (default: true)", required: false)
        .AddObject("environment", "Additional environment variables", required: false)
        .Build();

    private readonly ITerminalService _terminalService;
    private readonly IWorkspaceService _workspace;
    private readonly ILogger<RunCommandTool> _logger;

    private const int DefaultTimeoutSeconds = 120;
    private const int MaxTimeoutSeconds = 600;
    private const int MaxOutputLength = 100_000;

    // Dangerous command patterns
    private static readonly string[] DangerousPatterns = new[]
    {
        @"rm\s+-rf\s+/",
        @"rm\s+-rf\s+~",
        @"rm\s+-rf\s+\*",
        @"sudo\s+rm\s+-rf",
        @"format\s+[a-zA-Z]:",
        @"mkfs\.",
        @"dd\s+if=.*/dev/",
        @">\s*/dev/sd[a-z]",
        @":(){:|:&};:",  // Fork bomb
        @"chmod\s+-R\s+777\s+/",
        @"chown\s+-R.*\s+/",
    };

    public RunCommandTool(
        ITerminalService terminalService,
        IWorkspaceService workspace,
        ILogger<RunCommandTool> logger)
    {
        _terminalService = terminalService;
        _workspace = workspace;
        _logger = logger;
    }

    public override bool IsAvailable =>
        _workspace.CurrentWorkspace != null &&
        _terminalService.ActiveSession != null;

    public override async Task<ToolResult> ExecuteAsync(
        ToolExecutionContext context,
        CancellationToken ct = default)
    {
        var command = GetRequiredParameter<string>(context.Parameters, "command");
        var workingDir = GetOptionalParameter<string?>(context.Parameters, "working_directory", null);
        var timeoutSeconds = GetOptionalParameter<int>(context.Parameters, "timeout_seconds", DefaultTimeoutSeconds);
        var captureOutput = GetOptionalParameter<bool>(context.Parameters, "capture_output", true);

        // Validate timeout
        timeoutSeconds = Math.Min(timeoutSeconds, MaxTimeoutSeconds);

        // Determine working directory
        var effectiveDir = workingDir != null
            ? ResolvePath(context.WorkspacePath, workingDir)
            : context.WorkspacePath ?? Environment.CurrentDirectory;

        if (workingDir != null)
        {
            var dirValidation = ValidatePath(effectiveDir, context.WorkspacePath);
            if (!dirValidation.IsValid)
            {
                return ToolResult.Failed($"Invalid working directory: {dirValidation.ErrorMessage}");
            }
        }

        // Get or create terminal session
        var session = _terminalService.ActiveSession;
        if (session == null)
        {
            return ToolResult.Failed("No active terminal session. Please open a terminal first.");
        }

        _logger.LogInformation("Executing command: {Command} in {Directory}", command, effectiveDir);

        using var cts = CancellationTokenSource.CreateLinkedTokenSource(ct);
        cts.CancelAfter(TimeSpan.FromSeconds(timeoutSeconds));

        var startTime = DateTime.UtcNow;

        try
        {
            var result = await _terminalService.ExecuteCommandAsync(
                session.Id,
                command,
                effectiveDir,
                captureOutput,
                cts.Token);

            if (result == null)
            {
                return ToolResult.Success(
                    content: null,
                    new { command, sent = true },
                    $"Command sent to terminal: {TruncateCommand(command)}");
            }

            var duration = DateTime.UtcNow - startTime;

            // Truncate output if too long
            var output = result.Output;
            var truncated = false;
            if (output.Length > MaxOutputLength)
            {
                output = output[..MaxOutputLength] + "\n\n[Output truncated...]";
                truncated = true;
            }

            var resultData = new CommandResultData
            {
                Command = command,
                ExitCode = result.ExitCode,
                Duration = duration,
                OutputLength = result.Output.Length,
                WasTruncated = truncated,
                WorkingDirectory = effectiveDir
            };

            var message = result.ExitCode == 0
                ? $"Command succeeded ({duration.TotalSeconds:F1}s)"
                : $"Command failed with exit code {result.ExitCode}";

            return new ToolResult
            {
                IsSuccess = result.ExitCode == 0,
                Content = output,
                Data = resultData,
                Message = message
            };
        }
        catch (OperationCanceledException)
        {
            return ToolResult.Failed($"Command timed out after {timeoutSeconds} seconds");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Command execution failed: {Command}", command);
            return ToolResult.Failed($"Command execution failed: {ex.Message}");
        }
    }

    public override ToolValidationResult Validate(JsonElement parameters)
    {
        var errors = new List<ToolValidationError>();

        if (!parameters.TryGetProperty("command", out var cmdProp) ||
            string.IsNullOrWhiteSpace(cmdProp.GetString()))
        {
            errors.Add(new ToolValidationError
            {
                ParameterName = "command",
                Message = "Command is required",
                Code = "REQUIRED"
            });
            return ToolValidationResult.Invalid(errors);
        }

        var command = cmdProp.GetString()!;

        // Check for dangerous patterns
        foreach (var pattern in DangerousPatterns)
        {
            if (Regex.IsMatch(command, pattern, RegexOptions.IgnoreCase))
            {
                errors.Add(new ToolValidationError
                {
                    ParameterName = "command",
                    Message = $"Potentially dangerous command detected. Pattern: {pattern}",
                    Code = "DANGEROUS_COMMAND"
                });
            }
        }

        return errors.Count > 0
            ? ToolValidationResult.Invalid(errors)
            : ToolValidationResult.Valid();
    }

    public override string GetExecutionSummary(JsonElement parameters)
    {
        var command = parameters.GetProperty("command").GetString() ?? "";
        return $"Run: {TruncateCommand(command)}";
    }

    public override RiskLevel GetEffectiveRiskLevel(JsonElement parameters)
    {
        var command = parameters.GetProperty("command").GetString() ?? "";

        // Check for sudo/admin commands
        if (command.StartsWith("sudo ") || command.Contains(" sudo "))
        {
            return RiskLevel.Critical;
        }

        // Check for package manager installations
        if (Regex.IsMatch(command, @"(npm|pip|gem|cargo)\s+install", RegexOptions.IgnoreCase))
        {
            return RiskLevel.High;
        }

        // Check for git push
        if (command.Contains("git push"))
        {
            return RiskLevel.High;
        }

        // Check for file deletion
        if (Regex.IsMatch(command, @"\brm\b.*-[rf]", RegexOptions.IgnoreCase))
        {
            return RiskLevel.High;
        }

        // Default to High for terminal commands
        return RiskLevel.High;
    }

    private string TruncateCommand(string command)
    {
        return command.Length > 60 ? command[..57] + "..." : command;
    }
}

/// <summary>
/// Result data for command execution.
/// </summary>
public sealed class CommandResultData
{
    public string Command { get; init; } = string.Empty;
    public int ExitCode { get; init; }
    public TimeSpan Duration { get; init; }
    public int OutputLength { get; init; }
    public bool WasTruncated { get; init; }
    public string? WorkingDirectory { get; init; }
}
```

### ITerminalService Extensions

```csharp
namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Result of command execution.
/// </summary>
public sealed class CommandExecutionResult
{
    public string Output { get; init; } = string.Empty;
    public string Error { get; init; } = string.Empty;
    public int ExitCode { get; init; }
    public TimeSpan Duration { get; init; }
}

/// <summary>
/// Extensions to ITerminalService for tool support.
/// </summary>
public interface ITerminalService
{
    // ... existing methods ...

    /// <summary>
    /// Execute a command and optionally capture output.
    /// </summary>
    Task<CommandExecutionResult?> ExecuteCommandAsync(
        Guid sessionId,
        string command,
        string? workingDirectory = null,
        bool captureOutput = true,
        CancellationToken ct = default);
}
```

### Files to Create (v0.6.3e)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Services/Tools/Terminal/RunCommandTool.cs` | Command execution tool |
| `src/SeniorIntern.Services/Tools/Terminal/CommandResultData.cs` | Result data model |
| `src/SeniorIntern.Core/Models/CommandExecutionResult.cs` | Execution result model |

### Files to Modify (v0.6.3e)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/ITerminalService.cs` | Add ExecuteCommandAsync |

### Acceptance Criteria (v0.6.3e)
- [ ] RunCommandTool executes shell commands
- [ ] Output is captured and returned
- [ ] Timeout handling prevents hung commands
- [ ] Dangerous commands are blocked
- [ ] Working directory can be specified
- [ ] Exit codes are properly returned

---

## v0.6.3f: File Search Tools

### Objective
Implement the SearchFilesTool that enables the AI agent to find files by name patterns using glob syntax, with support for excluding directories and limiting results.

### SearchFilesTool Implementation

```csharp
namespace SeniorIntern.Services.Tools.Search;

/// <summary>
/// Tool for searching files by name pattern.
/// </summary>
public sealed class SearchFilesTool : ToolBase
{
    public override string Id => "search-files";
    public override string Name => "Search Files";
    public override string Description => """
        Search for files by name pattern in the workspace.
        Supports glob patterns for flexible matching.

        Pattern examples:
        - *.cs - All C# files in current directory
        - **/*.cs - All C# files recursively
        - src/**/*.ts - All TypeScript files under src/
        - **/test*.js - All JS files starting with 'test'
        """;

    public override ToolCategory Category => ToolCategory.Search;
    public override RiskLevel DefaultRiskLevel => RiskLevel.Safe;
    public override IReadOnlyList<string> Tags => new[] { "search", "files", "find", "glob" };

    public override JsonSchema InputSchema => JsonSchemaBuilder.Create()
        .WithDescription("Parameters for file search")
        .AddString("pattern", "Glob pattern to match (e.g., '**/*.cs')", required: true)
        .AddString("path", "Starting directory (default: workspace root)", required: false)
        .AddArray("exclude", "Patterns to exclude (e.g., ['**/node_modules/**'])", required: false)
        .AddInteger("max_results", "Maximum results to return (default: 100)", required: false)
        .AddBoolean("include_hidden", "Include hidden files (default: false)", required: false)
        .Build();

    private readonly IFileSystemService _fileSystem;
    private readonly IWorkspaceService _workspace;

    private const int DefaultMaxResults = 100;
    private const int AbsoluteMaxResults = 1000;

    // Default exclude patterns
    private static readonly string[] DefaultExcludes = new[]
    {
        "**/node_modules/**",
        "**/bin/**",
        "**/obj/**",
        "**/.git/**",
        "**/dist/**",
        "**/build/**",
        "**/.vs/**",
        "**/__pycache__/**"
    };

    public SearchFilesTool(
        IFileSystemService fileSystem,
        IWorkspaceService workspace)
    {
        _fileSystem = fileSystem;
        _workspace = workspace;
    }

    public override bool IsAvailable =>
        _workspace.CurrentWorkspace != null;

    public override async Task<ToolResult> ExecuteAsync(
        ToolExecutionContext context,
        CancellationToken ct = default)
    {
        var pattern = GetRequiredParameter<string>(context.Parameters, "pattern");
        var path = GetOptionalParameter<string>(context.Parameters, "path", ".");
        var excludes = GetOptionalParameter<string[]?>(context.Parameters, "exclude", null);
        var maxResults = GetOptionalParameter<int>(context.Parameters, "max_results", DefaultMaxResults);
        var includeHidden = GetOptionalParameter<bool>(context.Parameters, "include_hidden", false);

        maxResults = Math.Min(maxResults, AbsoluteMaxResults);

        var fullPath = ResolvePath(context.WorkspacePath, path);
        var pathValidation = ValidatePath(fullPath, context.WorkspacePath);
        if (!pathValidation.IsValid)
        {
            return ToolResult.Failed(pathValidation.ErrorMessage!);
        }

        if (!await _fileSystem.DirectoryExistsAsync(fullPath, ct))
        {
            return ToolResult.Failed($"Directory not found: {path}");
        }

        try
        {
            // Build matcher
            var matcher = new Matcher();
            matcher.AddInclude(pattern);

            // Add excludes
            var allExcludes = excludes != null
                ? DefaultExcludes.Concat(excludes).ToArray()
                : DefaultExcludes;

            foreach (var exclude in allExcludes)
            {
                matcher.AddExclude(exclude);
            }

            // Execute search
            var result = matcher.Execute(new DirectoryInfoWrapper(new DirectoryInfo(fullPath)));

            var files = result.Files
                .Where(f => includeHidden || !IsHidden(f.Path))
                .Take(maxResults)
                .Select(f => new SearchFileResult
                {
                    Path = f.Path,
                    Stem = f.Stem
                })
                .ToList();

            var totalFound = result.Files.Count();
            var truncated = totalFound > maxResults;

            // Format output
            var output = string.Join('\n', files.Select(f => f.Path));

            var resultData = new SearchFilesResultData
            {
                Pattern = pattern,
                Path = path,
                MatchCount = files.Count,
                TotalMatches = totalFound,
                WasTruncated = truncated
            };

            return ToolResult.Success(output, resultData,
                $"Found {files.Count} files matching '{pattern}'");
        }
        catch (Exception ex)
        {
            return ToolResult.Failed($"Search failed: {ex.Message}");
        }
    }

    private bool IsHidden(string path)
    {
        var parts = path.Split(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar);
        return parts.Any(p => p.StartsWith('.'));
    }

    public override string GetExecutionSummary(JsonElement parameters)
    {
        var pattern = parameters.GetProperty("pattern").GetString() ?? "?";
        return $"Search for files: {pattern}";
    }
}

/// <summary>
/// A file search result.
/// </summary>
public sealed class SearchFileResult
{
    public string Path { get; init; } = string.Empty;
    public string Stem { get; init; } = string.Empty;
}

/// <summary>
/// Result data for file search.
/// </summary>
public sealed class SearchFilesResultData
{
    public string Pattern { get; init; } = string.Empty;
    public string Path { get; init; } = string.Empty;
    public int MatchCount { get; init; }
    public int TotalMatches { get; init; }
    public bool WasTruncated { get; init; }
}
```

### Files to Create (v0.6.3f)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Services/Tools/Search/SearchFilesTool.cs` | File search tool |
| `src/SeniorIntern.Services/Tools/Search/SearchFilesResultData.cs` | Result data model |

### Acceptance Criteria (v0.6.3f)
- [ ] SearchFilesTool finds files by glob pattern
- [ ] Common directories are excluded by default
- [ ] Custom exclusions can be specified
- [ ] Results are limited to prevent overflow
- [ ] Hidden files are optionally included

---

## v0.6.3g: Content Search Tools

### Objective
Implement the SearchContentTool that enables the AI agent to search for text content within files, with support for regular expressions, case sensitivity, and context lines.

### SearchContentTool Implementation

```csharp
namespace SeniorIntern.Services.Tools.Search;

/// <summary>
/// Tool for searching content within files.
/// </summary>
public sealed class SearchContentTool : ToolBase
{
    public override string Id => "search-content";
    public override string Name => "Search Content";
    public override string Description => """
        Search for text content within files in the workspace.
        Supports plain text and regular expression patterns.
        Returns matching lines with file paths and line numbers.

        Use this to:
        - Find where a function is defined or called
        - Locate specific error messages
        - Find TODO comments
        - Search for configuration values
        """;

    public override ToolCategory Category => ToolCategory.Search;
    public override RiskLevel DefaultRiskLevel => RiskLevel.Safe;
    public override IReadOnlyList<string> Tags => new[] { "search", "content", "grep", "text" };

    public override JsonSchema InputSchema => JsonSchemaBuilder.Create()
        .WithDescription("Parameters for content search")
        .AddString("query", "Search query (text or regex pattern)", required: true)
        .AddString("file_pattern", "Glob pattern to filter files (default: '**/*')", required: false)
        .AddBoolean("regex", "Treat query as regular expression (default: false)", required: false)
        .AddBoolean("case_sensitive", "Case-sensitive search (default: false)", required: false)
        .AddBoolean("whole_word", "Match whole words only (default: false)", required: false)
        .AddInteger("context_lines", "Lines of context before/after match (default: 0)", required: false)
        .AddInteger("max_results", "Maximum results (default: 50)", required: false)
        .Build();

    private readonly IFileSystemService _fileSystem;
    private readonly IWorkspaceService _workspace;

    private const int DefaultMaxResults = 50;
    private const int MaxContextLines = 5;
    private const int MaxFileSize = 1024 * 1024; // 1MB

    public SearchContentTool(
        IFileSystemService fileSystem,
        IWorkspaceService workspace)
    {
        _fileSystem = fileSystem;
        _workspace = workspace;
    }

    public override bool IsAvailable =>
        _workspace.CurrentWorkspace != null;

    public override async Task<ToolResult> ExecuteAsync(
        ToolExecutionContext context,
        CancellationToken ct = default)
    {
        var query = GetRequiredParameter<string>(context.Parameters, "query");
        var filePattern = GetOptionalParameter<string>(context.Parameters, "file_pattern", "**/*");
        var useRegex = GetOptionalParameter<bool>(context.Parameters, "regex", false);
        var caseSensitive = GetOptionalParameter<bool>(context.Parameters, "case_sensitive", false);
        var wholeWord = GetOptionalParameter<bool>(context.Parameters, "whole_word", false);
        var contextLines = GetOptionalParameter<int>(context.Parameters, "context_lines", 0);
        var maxResults = GetOptionalParameter<int>(context.Parameters, "max_results", DefaultMaxResults);

        contextLines = Math.Min(contextLines, MaxContextLines);

        try
        {
            // Build the search pattern
            var searchPattern = BuildSearchPattern(query, useRegex, wholeWord);
            var regexOptions = caseSensitive ? RegexOptions.None : RegexOptions.IgnoreCase;
            var regex = new Regex(searchPattern, regexOptions | RegexOptions.Compiled);

            // Find files to search
            var matcher = new Matcher();
            matcher.AddInclude(filePattern);
            AddDefaultExclusions(matcher);

            var matchResult = matcher.Execute(
                new DirectoryInfoWrapper(new DirectoryInfo(context.WorkspacePath!)));

            var results = new List<ContentSearchResult>();
            var filesSearched = 0;

            foreach (var file in matchResult.Files)
            {
                if (results.Count >= maxResults) break;
                ct.ThrowIfCancellationRequested();

                var fullPath = Path.Combine(context.WorkspacePath!, file.Path);

                // Skip binary and large files
                if (!await IsTextFileAsync(fullPath, ct)) continue;

                var fileInfo = await _fileSystem.GetFileInfoAsync(fullPath, ct);
                if (fileInfo.Size > MaxFileSize) continue;

                filesSearched++;

                var content = await _fileSystem.ReadFileAsync(fullPath, ct);
                var lines = content.Split('\n');

                for (int i = 0; i < lines.Length && results.Count < maxResults; i++)
                {
                    if (regex.IsMatch(lines[i]))
                    {
                        results.Add(new ContentSearchResult
                        {
                            File = file.Path,
                            Line = i + 1,
                            Content = lines[i].Trim(),
                            ContextBefore = GetContextLines(lines, i, -contextLines),
                            ContextAfter = GetContextLines(lines, i, contextLines)
                        });
                    }
                }
            }

            // Format output
            var output = FormatResults(results, contextLines > 0);

            var resultData = new ContentSearchResultData
            {
                Query = query,
                FilePattern = filePattern,
                MatchCount = results.Count,
                FilesSearched = filesSearched,
                WasTruncated = results.Count >= maxResults
            };

            return ToolResult.Success(output, resultData,
                $"Found {results.Count} matches for '{query}' in {filesSearched} files");
        }
        catch (RegexParseException ex)
        {
            return ToolResult.Failed($"Invalid regex pattern: {ex.Message}");
        }
        catch (Exception ex)
        {
            return ToolResult.Failed($"Search failed: {ex.Message}");
        }
    }

    private string BuildSearchPattern(string query, bool isRegex, bool wholeWord)
    {
        var pattern = isRegex ? query : Regex.Escape(query);

        if (wholeWord)
        {
            pattern = $@"\b{pattern}\b";
        }

        return pattern;
    }

    private void AddDefaultExclusions(Matcher matcher)
    {
        var exclusions = new[]
        {
            "**/node_modules/**", "**/bin/**", "**/obj/**",
            "**/.git/**", "**/dist/**", "**/*.min.js",
            "**/*.min.css", "**/package-lock.json", "**/yarn.lock"
        };

        foreach (var exclusion in exclusions)
        {
            matcher.AddExclude(exclusion);
        }
    }

    private async Task<bool> IsTextFileAsync(string path, CancellationToken ct)
    {
        // Check extension first
        var ext = Path.GetExtension(path).ToLowerInvariant();
        var binaryExtensions = new[] { ".exe", ".dll", ".so", ".dylib", ".png", ".jpg", ".gif", ".pdf", ".zip" };

        if (binaryExtensions.Contains(ext))
            return false;

        // Quick binary check by reading first bytes
        try
        {
            var bytes = await _fileSystem.ReadFileBytesAsync(path, ct);
            if (bytes.Length < 4) return true;

            // Check for null bytes (common in binary files)
            return !bytes.Take(1000).Contains((byte)0);
        }
        catch
        {
            return false;
        }
    }

    private string[] GetContextLines(string[] lines, int matchIndex, int count)
    {
        if (count == 0) return Array.Empty<string>();

        var start = count < 0 ? Math.Max(0, matchIndex + count) : matchIndex + 1;
        var end = count < 0 ? matchIndex : Math.Min(lines.Length, matchIndex + count + 1);
        var take = Math.Abs(count);

        return lines[start..end].Take(take).Select(l => l.Trim()).ToArray();
    }

    private string FormatResults(List<ContentSearchResult> results, bool includeContext)
    {
        var sb = new StringBuilder();

        foreach (var result in results)
        {
            sb.AppendLine($"{result.File}:{result.Line}: {result.Content}");

            if (includeContext && result.ContextAfter.Length > 0)
            {
                foreach (var ctx in result.ContextAfter)
                {
                    sb.AppendLine($"  {ctx}");
                }
            }
        }

        return sb.ToString().TrimEnd();
    }

    public override string GetExecutionSummary(JsonElement parameters)
    {
        var query = parameters.GetProperty("query").GetString() ?? "?";
        var shortQuery = query.Length > 30 ? query[..27] + "..." : query;
        return $"Search for '{shortQuery}'";
    }
}

/// <summary>
/// A content search result.
/// </summary>
public sealed class ContentSearchResult
{
    public string File { get; init; } = string.Empty;
    public int Line { get; init; }
    public string Content { get; init; } = string.Empty;
    public string[] ContextBefore { get; init; } = Array.Empty<string>();
    public string[] ContextAfter { get; init; } = Array.Empty<string>();
}

/// <summary>
/// Result data for content search.
/// </summary>
public sealed class ContentSearchResultData
{
    public string Query { get; init; } = string.Empty;
    public string FilePattern { get; init; } = string.Empty;
    public int MatchCount { get; init; }
    public int FilesSearched { get; init; }
    public bool WasTruncated { get; init; }
}
```

### Files to Create (v0.6.3g)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Services/Tools/Search/SearchContentTool.cs` | Content search tool |
| `src/SeniorIntern.Services/Tools/Search/ContentSearchResult.cs` | Result model |
| `src/SeniorIntern.Services/Tools/Search/ContentSearchResultData.cs` | Result data model |

### Acceptance Criteria (v0.6.3g)
- [ ] SearchContentTool finds text in files
- [ ] Regular expressions are supported
- [ ] Case sensitivity is configurable
- [ ] Whole word matching works
- [ ] Context lines are included when requested
- [ ] Binary files are skipped

---

## v0.6.3h: Workspace Tools

### Objective
Implement workspace tools that provide information about the current workspace, detect project types, and manage open files.

### GetWorkspaceInfoTool Implementation

```csharp
namespace SeniorIntern.Services.Tools.Workspace;

/// <summary>
/// Tool for getting workspace information.
/// </summary>
public sealed class GetWorkspaceInfoTool : ToolBase
{
    public override string Id => "workspace-info";
    public override string Name => "Get Workspace Info";
    public override string Description => """
        Get information about the current workspace.
        Returns project type, structure, key files, and git status.

        Use this at the start of a task to understand the project context.
        """;

    public override ToolCategory Category => ToolCategory.Workspace;
    public override RiskLevel DefaultRiskLevel => RiskLevel.Safe;
    public override IReadOnlyList<string> Tags => new[] { "workspace", "project", "info" };

    public override JsonSchema InputSchema => JsonSchemaBuilder.Create()
        .WithDescription("No parameters required")
        .Build();

    private readonly IWorkspaceService _workspace;
    private readonly IFileSystemService _fileSystem;
    private readonly IGitService? _gitService;

    public GetWorkspaceInfoTool(
        IWorkspaceService workspace,
        IFileSystemService fileSystem,
        IGitService? gitService = null)
    {
        _workspace = workspace;
        _fileSystem = fileSystem;
        _gitService = gitService;
    }

    public override bool IsAvailable =>
        _workspace.CurrentWorkspace != null;

    public override async Task<ToolResult> ExecuteAsync(
        ToolExecutionContext context,
        CancellationToken ct = default)
    {
        var workspace = _workspace.CurrentWorkspace;
        if (workspace == null)
        {
            return ToolResult.Failed("No workspace is currently open");
        }

        var rootPath = workspace.RootPath;

        // Detect project type
        var projectType = await DetectProjectTypeAsync(rootPath, ct);

        // Find key files
        var keyFiles = await FindKeyFilesAsync(rootPath, projectType, ct);

        // Get directory structure summary
        var structure = await GetStructureSummaryAsync(rootPath, ct);

        // Get git info if available
        GitInfo? gitInfo = null;
        if (_gitService != null && await _gitService.IsGitRepositoryAsync(rootPath, ct))
        {
            gitInfo = await GetGitInfoAsync(rootPath, ct);
        }

        var resultData = new WorkspaceInfoData
        {
            Name = workspace.DisplayName,
            Path = rootPath,
            ProjectType = projectType.Type,
            Framework = projectType.Framework,
            KeyFiles = keyFiles,
            Structure = structure,
            Git = gitInfo
        };

        // Format output
        var output = FormatWorkspaceInfo(resultData);

        return ToolResult.Success(output, resultData,
            $"Workspace: {workspace.DisplayName} ({projectType.Type})");
    }

    private async Task<ProjectTypeInfo> DetectProjectTypeAsync(string path, CancellationToken ct)
    {
        // .NET
        var csprojFiles = Directory.GetFiles(path, "*.csproj", SearchOption.AllDirectories);
        if (csprojFiles.Length > 0 || File.Exists(Path.Combine(path, "*.sln")))
        {
            var framework = await DetectDotNetFrameworkAsync(csprojFiles.FirstOrDefault(), ct);
            return new ProjectTypeInfo { Type = "dotnet", Framework = framework };
        }

        // Node.js
        var packageJson = Path.Combine(path, "package.json");
        if (File.Exists(packageJson))
        {
            var framework = await DetectNodeFrameworkAsync(packageJson, ct);
            return new ProjectTypeInfo { Type = "node", Framework = framework };
        }

        // Python
        if (File.Exists(Path.Combine(path, "pyproject.toml")) ||
            File.Exists(Path.Combine(path, "setup.py")) ||
            File.Exists(Path.Combine(path, "requirements.txt")))
        {
            return new ProjectTypeInfo { Type = "python" };
        }

        // Rust
        if (File.Exists(Path.Combine(path, "Cargo.toml")))
        {
            return new ProjectTypeInfo { Type = "rust" };
        }

        // Go
        if (File.Exists(Path.Combine(path, "go.mod")))
        {
            return new ProjectTypeInfo { Type = "go" };
        }

        return new ProjectTypeInfo { Type = "unknown" };
    }

    private async Task<string?> DetectDotNetFrameworkAsync(string? csprojPath, CancellationToken ct)
    {
        if (csprojPath == null || !File.Exists(csprojPath)) return null;

        var content = await _fileSystem.ReadFileAsync(csprojPath, ct);

        if (content.Contains("Avalonia")) return "Avalonia";
        if (content.Contains("Microsoft.AspNetCore")) return "ASP.NET Core";
        if (content.Contains("Microsoft.Maui")) return "MAUI";
        if (content.Contains("WPF")) return "WPF";

        return null;
    }

    private async Task<string?> DetectNodeFrameworkAsync(string packageJsonPath, CancellationToken ct)
    {
        var content = await _fileSystem.ReadFileAsync(packageJsonPath, ct);

        if (content.Contains("\"next\"")) return "Next.js";
        if (content.Contains("\"react\"")) return "React";
        if (content.Contains("\"vue\"")) return "Vue";
        if (content.Contains("\"angular\"")) return "Angular";
        if (content.Contains("\"express\"")) return "Express";

        return null;
    }

    private async Task<List<string>> FindKeyFilesAsync(
        string path, ProjectTypeInfo projectType, CancellationToken ct)
    {
        var keyFiles = new List<string>();

        var commonFiles = new[]
        {
            "README.md", "LICENSE", ".gitignore", "Dockerfile",
            "docker-compose.yml", ".env.example"
        };

        foreach (var file in commonFiles)
        {
            if (File.Exists(Path.Combine(path, file)))
            {
                keyFiles.Add(file);
            }
        }

        // Project-specific files
        switch (projectType.Type)
        {
            case "dotnet":
                keyFiles.AddRange(Directory.GetFiles(path, "*.sln").Select(Path.GetFileName)!);
                keyFiles.AddRange(Directory.GetFiles(path, "*.csproj").Take(3).Select(Path.GetFileName)!);
                break;
            case "node":
                keyFiles.Add("package.json");
                if (File.Exists(Path.Combine(path, "tsconfig.json")))
                    keyFiles.Add("tsconfig.json");
                break;
            case "python":
                if (File.Exists(Path.Combine(path, "pyproject.toml")))
                    keyFiles.Add("pyproject.toml");
                if (File.Exists(Path.Combine(path, "requirements.txt")))
                    keyFiles.Add("requirements.txt");
                break;
        }

        return keyFiles.Distinct().ToList();
    }

    private async Task<StructureSummary> GetStructureSummaryAsync(string path, CancellationToken ct)
    {
        var dirs = Directory.GetDirectories(path)
            .Select(Path.GetFileName)
            .Where(d => !d!.StartsWith('.'))
            .Take(10)
            .ToList();

        var fileCount = Directory.GetFiles(path, "*", SearchOption.AllDirectories).Length;
        var dirCount = Directory.GetDirectories(path, "*", SearchOption.AllDirectories).Length;

        return new StructureSummary
        {
            TopLevelDirectories = dirs!,
            TotalFiles = fileCount,
            TotalDirectories = dirCount
        };
    }

    private async Task<GitInfo> GetGitInfoAsync(string path, CancellationToken ct)
    {
        var branch = await _gitService!.GetCurrentBranchAsync(path, ct);
        var status = await _gitService.GetStatusAsync(path, ct);

        return new GitInfo
        {
            Branch = branch,
            HasUncommittedChanges = status.HasChanges,
            ModifiedFiles = status.ModifiedCount,
            UntrackedFiles = status.UntrackedCount
        };
    }

    private string FormatWorkspaceInfo(WorkspaceInfoData data)
    {
        var sb = new StringBuilder();

        sb.AppendLine($"# Workspace: {data.Name}");
        sb.AppendLine();
        sb.AppendLine($"**Path:** {data.Path}");
        sb.AppendLine($"**Type:** {data.ProjectType}");
        if (data.Framework != null)
            sb.AppendLine($"**Framework:** {data.Framework}");
        sb.AppendLine();

        sb.AppendLine("## Key Files");
        foreach (var file in data.KeyFiles)
        {
            sb.AppendLine($"- {file}");
        }
        sb.AppendLine();

        sb.AppendLine("## Structure");
        sb.AppendLine($"- {data.Structure.TotalFiles} files in {data.Structure.TotalDirectories} directories");
        sb.AppendLine($"- Top-level: {string.Join(", ", data.Structure.TopLevelDirectories)}");

        if (data.Git != null)
        {
            sb.AppendLine();
            sb.AppendLine("## Git");
            sb.AppendLine($"- Branch: {data.Git.Branch}");
            if (data.Git.HasUncommittedChanges)
            {
                sb.AppendLine($"- Changes: {data.Git.ModifiedFiles} modified, {data.Git.UntrackedFiles} untracked");
            }
            else
            {
                sb.AppendLine("- Working tree clean");
            }
        }

        return sb.ToString();
    }

    public override string GetExecutionSummary(JsonElement parameters) =>
        "Get workspace info";
}

public sealed class ProjectTypeInfo
{
    public string Type { get; init; } = "unknown";
    public string? Framework { get; init; }
}

public sealed class StructureSummary
{
    public List<string> TopLevelDirectories { get; init; } = new();
    public int TotalFiles { get; init; }
    public int TotalDirectories { get; init; }
}

public sealed class GitInfo
{
    public string Branch { get; init; } = string.Empty;
    public bool HasUncommittedChanges { get; init; }
    public int ModifiedFiles { get; init; }
    public int UntrackedFiles { get; init; }
}

public sealed class WorkspaceInfoData
{
    public string Name { get; init; } = string.Empty;
    public string Path { get; init; } = string.Empty;
    public string ProjectType { get; init; } = string.Empty;
    public string? Framework { get; init; }
    public List<string> KeyFiles { get; init; } = new();
    public StructureSummary Structure { get; init; } = new();
    public GitInfo? Git { get; init; }
}
```

### Files to Create (v0.6.3h)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Services/Tools/Workspace/GetWorkspaceInfoTool.cs` | Workspace info tool |
| `src/SeniorIntern.Services/Tools/Workspace/GetOpenFilesTool.cs` | Open files tool |
| `src/SeniorIntern.Services/Tools/Workspace/WorkspaceInfoData.cs` | Data models |

### Acceptance Criteria (v0.6.3h)
- [ ] GetWorkspaceInfoTool detects project type
- [ ] Key files are identified
- [ ] Directory structure is summarized
- [ ] Git status is included when available
- [ ] Framework detection works for common stacks

---

## v0.6.3i: Git Tools

### Objective
Implement Git tools that enable the AI agent to view repository status, diffs, and commit history.

### GitStatusTool Implementation

```csharp
namespace SeniorIntern.Services.Tools.Git;

/// <summary>
/// Tool for getting Git repository status.
/// </summary>
public sealed class GitStatusTool : ToolBase
{
    public override string Id => "git-status";
    public override string Name => "Git Status";
    public override string Description => """
        Get the status of the Git repository.
        Shows staged changes, unstaged changes, and untracked files.

        Use this to understand what changes exist before committing.
        """;

    public override ToolCategory Category => ToolCategory.Git;
    public override RiskLevel DefaultRiskLevel => RiskLevel.Safe;
    public override IReadOnlyList<string> Tags => new[] { "git", "status", "changes" };

    public override JsonSchema InputSchema => JsonSchemaBuilder.Create()
        .WithDescription("Parameters for git status")
        .AddBoolean("short", "Use short format output (default: false)", required: false)
        .Build();

    private readonly IGitService _gitService;
    private readonly IWorkspaceService _workspace;

    public GitStatusTool(
        IGitService gitService,
        IWorkspaceService workspace)
    {
        _gitService = gitService;
        _workspace = workspace;
    }

    public override bool IsAvailable =>
        _workspace.CurrentWorkspace != null;

    public override async Task<ToolResult> ExecuteAsync(
        ToolExecutionContext context,
        CancellationToken ct = default)
    {
        var shortFormat = GetOptionalParameter<bool>(context.Parameters, "short", false);

        var rootPath = context.WorkspacePath;
        if (!await _gitService.IsGitRepositoryAsync(rootPath!, ct))
        {
            return ToolResult.Failed("Not a Git repository");
        }

        try
        {
            var status = await _gitService.GetDetailedStatusAsync(rootPath!, ct);
            var branch = await _gitService.GetCurrentBranchAsync(rootPath!, ct);

            var output = shortFormat
                ? FormatShortStatus(status, branch)
                : FormatLongStatus(status, branch);

            var resultData = new GitStatusData
            {
                Branch = branch,
                HasChanges = status.HasChanges,
                StagedCount = status.StagedFiles.Count,
                ModifiedCount = status.ModifiedFiles.Count,
                UntrackedCount = status.UntrackedFiles.Count,
                DeletedCount = status.DeletedFiles.Count
            };

            var message = status.HasChanges
                ? $"On branch {branch}: {status.StagedFiles.Count} staged, {status.ModifiedFiles.Count} modified, {status.UntrackedFiles.Count} untracked"
                : $"On branch {branch}: working tree clean";

            return ToolResult.Success(output, resultData, message);
        }
        catch (Exception ex)
        {
            return ToolResult.Failed($"Git status failed: {ex.Message}");
        }
    }

    private string FormatShortStatus(DetailedGitStatus status, string branch)
    {
        var sb = new StringBuilder();
        sb.AppendLine($"## {branch}");

        foreach (var file in status.StagedFiles)
            sb.AppendLine($"A  {file}");
        foreach (var file in status.ModifiedFiles)
            sb.AppendLine($" M {file}");
        foreach (var file in status.DeletedFiles)
            sb.AppendLine($" D {file}");
        foreach (var file in status.UntrackedFiles)
            sb.AppendLine($"?? {file}");

        return sb.ToString().TrimEnd();
    }

    private string FormatLongStatus(DetailedGitStatus status, string branch)
    {
        var sb = new StringBuilder();
        sb.AppendLine($"On branch {branch}");
        sb.AppendLine();

        if (status.StagedFiles.Count > 0)
        {
            sb.AppendLine("Changes to be committed:");
            foreach (var file in status.StagedFiles)
                sb.AppendLine($"  new file:   {file}");
            sb.AppendLine();
        }

        if (status.ModifiedFiles.Count > 0)
        {
            sb.AppendLine("Changes not staged for commit:");
            foreach (var file in status.ModifiedFiles)
                sb.AppendLine($"  modified:   {file}");
            sb.AppendLine();
        }

        if (status.DeletedFiles.Count > 0)
        {
            sb.AppendLine("Deleted files:");
            foreach (var file in status.DeletedFiles)
                sb.AppendLine($"  deleted:    {file}");
            sb.AppendLine();
        }

        if (status.UntrackedFiles.Count > 0)
        {
            sb.AppendLine("Untracked files:");
            foreach (var file in status.UntrackedFiles)
                sb.AppendLine($"  {file}");
            sb.AppendLine();
        }

        if (!status.HasChanges)
        {
            sb.AppendLine("nothing to commit, working tree clean");
        }

        return sb.ToString().TrimEnd();
    }

    public override string GetExecutionSummary(JsonElement parameters) =>
        "Get git status";
}
```

### GitDiffTool Implementation

```csharp
namespace SeniorIntern.Services.Tools.Git;

/// <summary>
/// Tool for getting Git diffs.
/// </summary>
public sealed class GitDiffTool : ToolBase
{
    public override string Id => "git-diff";
    public override string Name => "Git Diff";
    public override string Description => """
        Get the diff of changes in the Git repository.
        Can show unstaged changes, staged changes, or compare commits.

        Use this to review changes before committing or to understand what was changed.
        """;

    public override ToolCategory Category => ToolCategory.Git;
    public override RiskLevel DefaultRiskLevel => RiskLevel.Safe;
    public override IReadOnlyList<string> Tags => new[] { "git", "diff", "changes" };

    public override JsonSchema InputSchema => JsonSchemaBuilder.Create()
        .WithDescription("Parameters for git diff")
        .AddString("path", "Specific file or directory to diff", required: false)
        .AddBoolean("staged", "Show staged changes only (default: false)", required: false)
        .AddString("commit", "Compare against a specific commit", required: false)
        .AddInteger("context_lines", "Lines of context (default: 3)", required: false)
        .Build();

    private readonly IGitService _gitService;
    private readonly IWorkspaceService _workspace;

    private const int MaxDiffLength = 50000;

    public GitDiffTool(
        IGitService gitService,
        IWorkspaceService workspace)
    {
        _gitService = gitService;
        _workspace = workspace;
    }

    public override bool IsAvailable =>
        _workspace.CurrentWorkspace != null;

    public override async Task<ToolResult> ExecuteAsync(
        ToolExecutionContext context,
        CancellationToken ct = default)
    {
        var path = GetOptionalParameter<string?>(context.Parameters, "path", null);
        var staged = GetOptionalParameter<bool>(context.Parameters, "staged", false);
        var commit = GetOptionalParameter<string?>(context.Parameters, "commit", null);
        var contextLines = GetOptionalParameter<int>(context.Parameters, "context_lines", 3);

        var rootPath = context.WorkspacePath;
        if (!await _gitService.IsGitRepositoryAsync(rootPath!, ct))
        {
            return ToolResult.Failed("Not a Git repository");
        }

        try
        {
            var diff = await _gitService.GetDiffAsync(rootPath!, new GitDiffOptions
            {
                Path = path,
                Staged = staged,
                Commit = commit,
                ContextLines = contextLines
            }, ct);

            if (string.IsNullOrEmpty(diff))
            {
                var message = staged ? "No staged changes" : "No changes";
                return ToolResult.Success("", new { has_changes = false }, message);
            }

            var truncated = false;
            if (diff.Length > MaxDiffLength)
            {
                diff = diff[..MaxDiffLength] + "\n\n[Diff truncated...]";
                truncated = true;
            }

            var stats = ParseDiffStats(diff);

            return ToolResult.Success(diff, new
            {
                has_changes = true,
                files_changed = stats.FilesChanged,
                insertions = stats.Insertions,
                deletions = stats.Deletions,
                truncated
            }, $"{stats.FilesChanged} files changed, +{stats.Insertions}/-{stats.Deletions}");
        }
        catch (Exception ex)
        {
            return ToolResult.Failed($"Git diff failed: {ex.Message}");
        }
    }

    private (int FilesChanged, int Insertions, int Deletions) ParseDiffStats(string diff)
    {
        var files = Regex.Matches(diff, @"^diff --git", RegexOptions.Multiline).Count;
        var insertions = Regex.Matches(diff, @"^\+[^+]", RegexOptions.Multiline).Count;
        var deletions = Regex.Matches(diff, @"^-[^-]", RegexOptions.Multiline).Count;

        return (files, insertions, deletions);
    }

    public override string GetExecutionSummary(JsonElement parameters)
    {
        var path = parameters.TryGetProperty("path", out var p) ? p.GetString() : null;
        var staged = parameters.TryGetProperty("staged", out var s) && s.GetBoolean();

        if (path != null)
            return $"Git diff: {Path.GetFileName(path)}";
        return staged ? "Git diff (staged)" : "Git diff";
    }
}
```

### GitLogTool Implementation

```csharp
namespace SeniorIntern.Services.Tools.Git;

/// <summary>
/// Tool for viewing Git commit history.
/// </summary>
public sealed class GitLogTool : ToolBase
{
    public override string Id => "git-log";
    public override string Name => "Git Log";
    public override string Description => """
        View the Git commit history.
        Shows commit messages, authors, and dates.

        Use this to understand the history of changes and find specific commits.
        """;

    public override ToolCategory Category => ToolCategory.Git;
    public override RiskLevel DefaultRiskLevel => RiskLevel.Safe;
    public override IReadOnlyList<string> Tags => new[] { "git", "log", "history", "commits" };

    public override JsonSchema InputSchema => JsonSchemaBuilder.Create()
        .WithDescription("Parameters for git log")
        .AddInteger("count", "Number of commits to show (default: 10)", required: false)
        .AddString("path", "Show commits for a specific file or directory", required: false)
        .AddString("author", "Filter by author", required: false)
        .AddString("since", "Show commits since date (e.g., '2024-01-01', '1 week ago')", required: false)
        .AddBoolean("oneline", "Use one-line format (default: false)", required: false)
        .Build();

    private readonly IGitService _gitService;
    private readonly IWorkspaceService _workspace;

    public GitLogTool(
        IGitService gitService,
        IWorkspaceService workspace)
    {
        _gitService = gitService;
        _workspace = workspace;
    }

    public override bool IsAvailable =>
        _workspace.CurrentWorkspace != null;

    public override async Task<ToolResult> ExecuteAsync(
        ToolExecutionContext context,
        CancellationToken ct = default)
    {
        var count = GetOptionalParameter<int>(context.Parameters, "count", 10);
        var path = GetOptionalParameter<string?>(context.Parameters, "path", null);
        var author = GetOptionalParameter<string?>(context.Parameters, "author", null);
        var since = GetOptionalParameter<string?>(context.Parameters, "since", null);
        var oneline = GetOptionalParameter<bool>(context.Parameters, "oneline", false);

        count = Math.Min(count, 100); // Limit to 100 commits

        var rootPath = context.WorkspacePath;
        if (!await _gitService.IsGitRepositoryAsync(rootPath!, ct))
        {
            return ToolResult.Failed("Not a Git repository");
        }

        try
        {
            var commits = await _gitService.GetLogAsync(rootPath!, new GitLogOptions
            {
                Count = count,
                Path = path,
                Author = author,
                Since = since
            }, ct);

            var output = oneline
                ? FormatOneline(commits)
                : FormatFull(commits);

            return ToolResult.Success(output, new
            {
                commit_count = commits.Count
            }, $"Showing {commits.Count} commits");
        }
        catch (Exception ex)
        {
            return ToolResult.Failed($"Git log failed: {ex.Message}");
        }
    }

    private string FormatOneline(List<GitCommit> commits)
    {
        var sb = new StringBuilder();
        foreach (var commit in commits)
        {
            sb.AppendLine($"{commit.ShortHash} {commit.Subject}");
        }
        return sb.ToString().TrimEnd();
    }

    private string FormatFull(List<GitCommit> commits)
    {
        var sb = new StringBuilder();
        foreach (var commit in commits)
        {
            sb.AppendLine($"commit {commit.Hash}");
            sb.AppendLine($"Author: {commit.Author} <{commit.AuthorEmail}>");
            sb.AppendLine($"Date:   {commit.Date:ddd MMM d HH:mm:ss yyyy}");
            sb.AppendLine();
            sb.AppendLine($"    {commit.Subject}");
            if (!string.IsNullOrEmpty(commit.Body))
            {
                sb.AppendLine();
                foreach (var line in commit.Body.Split('\n'))
                {
                    sb.AppendLine($"    {line}");
                }
            }
            sb.AppendLine();
        }
        return sb.ToString().TrimEnd();
    }

    public override string GetExecutionSummary(JsonElement parameters)
    {
        var count = parameters.TryGetProperty("count", out var c) ? c.GetInt32() : 10;
        return $"Git log ({count} commits)";
    }
}
```

### Files to Create (v0.6.3i)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Services/Tools/Git/GitStatusTool.cs` | Git status tool |
| `src/SeniorIntern.Services/Tools/Git/GitDiffTool.cs` | Git diff tool |
| `src/SeniorIntern.Services/Tools/Git/GitLogTool.cs` | Git log tool |
| `src/SeniorIntern.Services/Tools/Git/GitStatusData.cs` | Status data model |
| `src/SeniorIntern.Core/Interfaces/IGitService.cs` | Git service interface |
| `src/SeniorIntern.Services/Git/GitService.cs` | Git service implementation |

### Acceptance Criteria (v0.6.3i)
- [ ] GitStatusTool shows repository status
- [ ] GitDiffTool shows file changes
- [ ] GitLogTool shows commit history
- [ ] Filters work correctly (author, path, date)
- [ ] Output is properly formatted

---

## v0.6.3j: Tool Registration & Testing

### Objective
Create the dependency injection extensions for registering all built-in tools and comprehensive test suites for each tool category.

### BuiltInToolsExtensions

```csharp
namespace SeniorIntern.Services;

/// <summary>
/// Extension methods for registering built-in tools.
/// </summary>
public static class BuiltInToolsExtensions
{
    /// <summary>
    /// Registers all built-in tools with the service collection.
    /// </summary>
    public static IServiceCollection AddBuiltInTools(this IServiceCollection services)
    {
        // File system tools
        services.AddSingleton<ITool, ReadFileTool>();
        services.AddSingleton<ITool, WriteFileTool>();
        services.AddSingleton<ITool, FilePatchTool>();
        services.AddSingleton<ITool, DeleteFileTool>();
        services.AddSingleton<ITool, MoveFileTool>();
        services.AddSingleton<ITool, CopyFileTool>();
        services.AddSingleton<ITool, ListDirectoryTool>();
        services.AddSingleton<ITool, CreateDirectoryTool>();

        // Terminal tools
        services.AddSingleton<ITool, RunCommandTool>();

        // Search tools
        services.AddSingleton<ITool, SearchFilesTool>();
        services.AddSingleton<ITool, SearchContentTool>();

        // Workspace tools
        services.AddSingleton<ITool, GetWorkspaceInfoTool>();
        services.AddSingleton<ITool, GetOpenFilesTool>();

        // Git tools
        services.AddSingleton<ITool, GitStatusTool>();
        services.AddSingleton<ITool, GitDiffTool>();
        services.AddSingleton<ITool, GitLogTool>();

        return services;
    }

    /// <summary>
    /// Registers only safe (read-only) built-in tools.
    /// </summary>
    public static IServiceCollection AddSafeBuiltInTools(this IServiceCollection services)
    {
        services.AddSingleton<ITool, ReadFileTool>();
        services.AddSingleton<ITool, ListDirectoryTool>();
        services.AddSingleton<ITool, SearchFilesTool>();
        services.AddSingleton<ITool, SearchContentTool>();
        services.AddSingleton<ITool, GetWorkspaceInfoTool>();
        services.AddSingleton<ITool, GitStatusTool>();
        services.AddSingleton<ITool, GitDiffTool>();
        services.AddSingleton<ITool, GitLogTool>();

        return services;
    }
}
```

### Test Examples

```csharp
namespace SeniorIntern.Tests.Tools.FileSystem;

public class ReadFileToolTests : IAsyncLifetime
{
    private readonly string _tempDir;
    private readonly ReadFileTool _tool;

    public ReadFileToolTests()
    {
        _tempDir = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString());
        Directory.CreateDirectory(_tempDir);

        var fileSystem = new FileSystemService();
        var workspace = CreateMockWorkspace(_tempDir);
        var logger = new NullLogger<ReadFileTool>();

        _tool = new ReadFileTool(fileSystem, workspace, logger);
    }

    [Fact]
    public async Task ExecuteAsync_ExistingFile_ReturnsContent()
    {
        // Arrange
        var filePath = Path.Combine(_tempDir, "test.txt");
        await File.WriteAllTextAsync(filePath, "Hello\nWorld\nTest");

        var context = CreateContext("test.txt");

        // Act
        var result = await _tool.ExecuteAsync(context);

        // Assert
        Assert.True(result.IsSuccess);
        Assert.Contains("Hello", result.Content);
        Assert.Contains("World", result.Content);
    }

    [Fact]
    public async Task ExecuteAsync_NonExistentFile_ReturnsError()
    {
        var context = CreateContext("nonexistent.txt");

        var result = await _tool.ExecuteAsync(context);

        Assert.False(result.IsSuccess);
        Assert.Contains("not found", result.ErrorMessage);
    }

    [Fact]
    public async Task ExecuteAsync_LineFilter_ReturnsFilteredLines()
    {
        var filePath = Path.Combine(_tempDir, "lines.txt");
        await File.WriteAllTextAsync(filePath, "Line1\nLine2\nLine3\nLine4\nLine5");

        var context = CreateContext("lines.txt", startLine: 2, endLine: 4);

        var result = await _tool.ExecuteAsync(context);

        Assert.True(result.IsSuccess);
        Assert.Contains("Line2", result.Content);
        Assert.Contains("Line4", result.Content);
        Assert.DoesNotContain("Line1", result.Content);
        Assert.DoesNotContain("Line5", result.Content);
    }

    // ... more tests ...

    public Task InitializeAsync() => Task.CompletedTask;

    public Task DisposeAsync()
    {
        if (Directory.Exists(_tempDir))
            Directory.Delete(_tempDir, recursive: true);
        return Task.CompletedTask;
    }
}
```

### Files to Create (v0.6.3j)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Services/BuiltInToolsExtensions.cs` | DI registration |
| `tests/SeniorIntern.Tests/Tools/FileSystem/ReadFileToolTests.cs` | Read tool tests |
| `tests/SeniorIntern.Tests/Tools/FileSystem/WriteFileToolTests.cs` | Write tool tests |
| `tests/SeniorIntern.Tests/Tools/FileSystem/FilePatchToolTests.cs` | Patch tool tests |
| `tests/SeniorIntern.Tests/Tools/FileSystem/DirectoryToolTests.cs` | Directory tool tests |
| `tests/SeniorIntern.Tests/Tools/Terminal/RunCommandToolTests.cs` | Command tool tests |
| `tests/SeniorIntern.Tests/Tools/Search/SearchToolTests.cs` | Search tool tests |
| `tests/SeniorIntern.Tests/Tools/Git/GitToolTests.cs` | Git tool tests |
| `tests/SeniorIntern.Tests/Tools/ToolTestHelpers.cs` | Test utilities |

### Acceptance Criteria (v0.6.3j)
- [ ] All tools are registered via DI
- [ ] Safe-only registration option works
- [ ] Each tool has unit tests
- [ ] Integration tests use temp directories
- [ ] All tests pass in CI

---

## Complete File Summary

### Files to Create (Total: 42)

| Part | Count | Focus |
|------|-------|-------|
| v0.6.3a | 3 | Read file tool |
| v0.6.3b | 4 | Write and patch tools |
| v0.6.3c | 3 | Delete, move, copy tools |
| v0.6.3d | 5 | Directory tools |
| v0.6.3e | 3 | Terminal command tool |
| v0.6.3f | 2 | File search tool |
| v0.6.3g | 3 | Content search tool |
| v0.6.3h | 3 | Workspace tools |
| v0.6.3i | 6 | Git tools |
| v0.6.3j | 10 | Registration and tests |

### Files to Modify (Total: 4)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/IFileSystemService.cs` | Add tool-specific methods |
| `src/SeniorIntern.Core/Interfaces/ITerminalService.cs` | Add ExecuteCommandAsync |
| `src/SeniorIntern.Services/ServiceCollectionExtensions.cs` | Register built-in tools |
| `Directory.Packages.props` | Add FileSystemGlobbing package |

---

## Dependencies

### Prerequisite Sub-Versions
- v0.6.1 (Tool Framework) - Required for ToolBase, ITool, JsonSchema
- v0.6.2 (Semantic Kernel Integration) - Required for IAgentService integration

### External Dependencies
- Microsoft.Extensions.FileSystemGlobbing (for glob pattern matching)
- System.Text.RegularExpressions (for content search)

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Path traversal vulnerabilities | Medium | Critical | Strict path validation in all tools |
| Command injection | Medium | Critical | Pattern blocking, input sanitization |
| Large file handling | High | Medium | Size limits, streaming reads |
| Performance with large repos | Medium | Medium | Result limits, async enumeration |
| Binary file corruption | Low | High | Text file detection before content ops |

---

## Implementation Notes

1. **Path Security**: All file tools must validate paths are within the workspace to prevent directory traversal attacks.

2. **Risk Levels**: File write/delete operations are Medium/High risk; read operations are Safe.

3. **Result Limits**: All tools that return lists should have sensible defaults and maximum limits to prevent memory issues.

4. **Error Messages**: Error messages should be helpful without exposing sensitive system information.

5. **Cancellation**: All long-running operations must respect cancellation tokens.

6. **Tool Availability**: Tools should check prerequisites (workspace open, git repo, etc.) before executing.
