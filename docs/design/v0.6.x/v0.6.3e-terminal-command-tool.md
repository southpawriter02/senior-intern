# Design Specification: AIntern v0.6.3e "Terminal Command Tool"

## Overview

**Version**: v0.6.3e
**Parent**: v0.6.3 Built-in Tools
**Focus**: RunCommandTool for executing shell commands with output capture and safety validations

### Purpose

Implement the terminal command tool that enables the AI agent to:
1. Execute shell commands in the integrated terminal
2. Capture command output (stdout/stderr combined)
3. Handle command timeouts gracefully
4. Validate and block dangerous command patterns
5. Support custom working directories
6. Return exit codes and execution statistics
7. Integrate with existing terminal infrastructure (v0.5.x)

### Dependencies

**From v0.5.x (Integrated Terminal)**:
- `ITerminalService` for terminal operations
- `TerminalSession` for session management
- Shell detection and configuration

**From v0.6.3a (File Read Tools)**:
- `ToolPathHelper` for path validation

**From v0.6.1 (Tool Framework)**:
- `ToolBase`, `ToolResult`
- `JsonSchemaBuilder`, `RiskLevel`

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                   v0.6.3e Terminal Command Tool Architecture                  │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  src/SeniorIntern.Services/Tools/Terminal/                                   │
│  ├─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  RunCommandTool : ToolBase                                               │ │
│  │  ┌─────────────────────────────────────────────────────────────────────┐│ │
│  │  │  Id: "terminal-run"                                                  ││ │
│  │  │  DefaultRiskLevel: High                                              ││ │
│  │  │                                                                      ││ │
│  │  │  Parameters                                                           ││ │
│  │  │  ├── command: string (required) - Command to execute                 ││ │
│  │  │  ├── working_directory: string (optional)                            ││ │
│  │  │  ├── timeout_seconds: int (default: 120, max: 600)                   ││ │
│  │  │  ├── capture_output: bool (default: true)                            ││ │
│  │  │  └── environment: object (optional) - Extra env vars                 ││ │
│  │  │                                                                      ││ │
│  │  │  Constants                                                            ││ │
│  │  │  ├── DefaultTimeoutSeconds = 120                                     ││ │
│  │  │  ├── MaxTimeoutSeconds = 600                                         ││ │
│  │  │  └── MaxOutputLength = 100,000                                       ││ │
│  │  │                                                                      ││ │
│  │  │  Dangerous Command Patterns (blocked)                                 ││ │
│  │  │  ├── rm -rf / | rm -rf ~ | rm -rf *                                  ││ │
│  │  │  ├── sudo rm -rf                                                     ││ │
│  │  │  ├── format [drive]:                                                 ││ │
│  │  │  ├── mkfs. | dd if=/dev/                                             ││ │
│  │  │  ├── > /dev/sd[a-z]                                                  ││ │
│  │  │  ├── :(){:|:&};: (fork bomb)                                         ││ │
│  │  │  ├── chmod -R 777 /                                                  ││ │
│  │  │  └── chown -R ... /                                                  ││ │
│  │  └─────────────────────────────────────────────────────────────────────┘│ │
│  │                                                                          │ │
│  │  CommandResultData                                                       │ │
│  │  ├── Command: string                                                     │ │
│  │  ├── ExitCode: int                                                       │ │
│  │  ├── Duration: TimeSpan                                                  │ │
│  │  ├── OutputLength: int                                                   │ │
│  │  ├── WasTruncated: bool                                                  │ │
│  │  └── WorkingDirectory: string?                                           │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  src/SeniorIntern.Core/Models/                                               │
│  ├─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  CommandExecutionResult                                                  │ │
│  │  ├── Output: string (stdout + stderr combined)                          │ │
│  │  ├── Error: string (stderr only, if separated)                          │ │
│  │  ├── ExitCode: int                                                       │ │
│  │  └── Duration: TimeSpan                                                  │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Risk Level Assessment

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                    Dynamic Risk Level Assessment                              │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Command Pattern                         Risk Level      Reason              │
│  ──────────────────────────────────────────────────────────────────────────  │
│  sudo *                                  CRITICAL        Elevated privileges │
│  rm -rf / | rm -r ~                      BLOCKED         Destructive, blocked│
│  :(){:|:&};:                             BLOCKED         Fork bomb, blocked  │
│  npm install | pip install               HIGH            External packages   │
│  git push                                HIGH            Remote changes      │
│  rm -rf <path>                           HIGH            File deletion       │
│  dotnet build | npm run build            HIGH            Code execution      │
│  ls | pwd | cat                          HIGH            Default (any cmd)   │
│                                                                              │
│  Risk Escalation Flow:                                                       │
│  ┌────────────────────────────────────────────────────────────────────────┐ │
│  │  Command Input                                                          │ │
│  │      │                                                                  │ │
│  │      ▼                                                                  │ │
│  │  Validate() ─────────────────────────────────────────────────────────┐  │ │
│  │      │                                                               │  │ │
│  │      │ Check DangerousPatterns[]                                     │  │ │
│  │      │                                                               │  │ │
│  │      ▼                                                               ▼  │ │
│  │  [Match Found]                                             [No Match]   │ │
│  │      │                                                          │      │ │
│  │      ▼                                                          ▼      │ │
│  │  BLOCKED with                                          GetEffectiveRisk │ │
│  │  validation error                                            │         │ │
│  │                                                              ▼         │ │
│  │                                                    ┌─────────────────┐ │ │
│  │                                                    │ Check patterns: │ │ │
│  │                                                    │ • sudo → CRIT   │ │ │
│  │                                                    │ • install → HIGH│ │ │
│  │                                                    │ • push → HIGH   │ │ │
│  │                                                    │ • rm -rf → HIGH │ │ │
│  │                                                    │ • else → HIGH   │ │ │
│  │                                                    └─────────────────┘ │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Execution Flow

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                       RunCommandTool Execution Flow                           │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ExecuteAsync(context)                                                       │
│      │                                                                       │
│      ▼                                                                       │
│  ┌─────────────────────────────┐                                             │
│  │  1. Extract Parameters      │                                             │
│  │  ├── command (required)     │                                             │
│  │  ├── working_directory      │                                             │
│  │  ├── timeout_seconds        │                                             │
│  │  ├── capture_output         │                                             │
│  │  └── environment            │                                             │
│  └─────────────┬───────────────┘                                             │
│                │                                                             │
│                ▼                                                             │
│  ┌─────────────────────────────┐                                             │
│  │  2. Clamp Timeout           │                                             │
│  │  Min(timeout, MaxTimeout)   │                                             │
│  └─────────────┬───────────────┘                                             │
│                │                                                             │
│                ▼                                                             │
│  ┌─────────────────────────────┐                                             │
│  │  3. Resolve Working Dir     │                                             │
│  │  ├── If specified: validate │                                             │
│  │  └── Else: workspace root   │                                             │
│  └─────────────┬───────────────┘                                             │
│                │                                                             │
│                ▼                                                             │
│  ┌─────────────────────────────┐                                             │
│  │  4. Check Terminal Session  │                                             │
│  │  ActiveSession != null      │                                             │
│  └─────────────┬───────────────┘                                             │
│                │                                                             │
│       ┌────────┴────────┐                                                    │
│       │ No session      │ Session exists                                     │
│       ▼                 ▼                                                    │
│  ┌──────────┐    ┌─────────────────────────────┐                             │
│  │  RETURN  │    │  5. Create Linked CTS       │                             │
│  │  Failed  │    │  with timeout               │                             │
│  └──────────┘    └─────────────┬───────────────┘                             │
│                                │                                             │
│                                ▼                                             │
│                  ┌─────────────────────────────┐                             │
│                  │  6. Execute Command         │                             │
│                  │  ExecuteCommandAsync()      │                             │
│                  └─────────────┬───────────────┘                             │
│                                │                                             │
│                 ┌──────────────┼──────────────┐                              │
│                 │              │              │                              │
│                 ▼              ▼              ▼                              │
│         [Timeout]      [Success]      [Exception]                            │
│              │              │              │                                 │
│              ▼              ▼              ▼                                 │
│         ┌────────┐   ┌──────────────┐ ┌────────┐                             │
│         │ RETURN │   │ 7. Truncate  │ │ RETURN │                             │
│         │ Failed │   │ output if    │ │ Failed │                             │
│         │ timeout│   │ > MaxLength  │ └────────┘                             │
│         └────────┘   └──────┬───────┘                                        │
│                             │                                                │
│                             ▼                                                │
│                  ┌─────────────────────────────┐                             │
│                  │  8. Build Result            │                             │
│                  │  ├── IsSuccess = exitCode 0 │                             │
│                  │  ├── Content = output       │                             │
│                  │  ├── CommandResultData      │                             │
│                  │  └── Message with duration  │                             │
│                  └─────────────────────────────┘                             │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Specifications

### 1. RunCommandTool.cs

**Location**: `src/SeniorIntern.Services/Tools/Terminal/RunCommandTool.cs`

```csharp
namespace SeniorIntern.Services.Tools.Terminal;

using System.Text.Json;
using System.Text.RegularExpressions;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Core.Tools;
using SeniorIntern.Services.Tools;

/// <summary>
/// Tool for executing shell commands in the terminal.
/// </summary>
/// <remarks>
/// <para>
/// RunCommandTool enables the AI agent to execute shell commands:
/// </para>
/// <list type="bullet">
/// <item>Build commands (dotnet build, npm run build)</item>
/// <item>Test commands (dotnet test, npm test)</item>
/// <item>Package installations (npm install, pip install)</item>
/// <item>Git operations (git status, git diff)</item>
/// </list>
/// <para>
/// Commands are validated for dangerous patterns before execution.
/// </para>
/// </remarks>
public sealed class RunCommandTool : ToolBase
{
    #region Tool Metadata

    public override string Id => "terminal-run";

    public override string Name => "Run Command";

    public override string Description => """
        Execute a shell command in the integrated terminal.
        Returns the command output (stdout and stderr combined).
        Commands run in the workspace directory by default.

        Use this to:
        - Run build commands (dotnet build, npm run build)
        - Execute tests (dotnet test, npm test)
        - Install packages (dotnet add package, npm install)
        - Run scripts and tools

        Important: Be cautious with commands that modify the system.
        """;

    public override ToolCategory Category => ToolCategory.Terminal;

    public override RiskLevel DefaultRiskLevel => RiskLevel.High;

    public override IReadOnlyList<string> Tags => new[] { "terminal", "command", "shell", "execute" };

    public override JsonSchema InputSchema => JsonSchemaBuilder.Create()
        .WithDescription("Parameters for running a command")
        .AddString("command", "The command to execute", required: true)
        .AddString("working_directory", "Working directory (default: workspace root)", required: false)
        .AddInteger("timeout_seconds", "Timeout in seconds (default: 120, max: 600)", required: false)
        .AddBoolean("capture_output", "Capture output instead of streaming to terminal (default: true)", required: false)
        .AddObject("environment", "Additional environment variables", required: false)
        .Build();

    #endregion

    #region Dependencies

    private readonly ITerminalService _terminalService;
    private readonly IWorkspaceService _workspace;
    private readonly ILogger<RunCommandTool> _logger;

    #endregion

    #region Constants

    /// <summary>
    /// Default timeout in seconds.
    /// </summary>
    public const int DefaultTimeoutSeconds = 120;

    /// <summary>
    /// Maximum timeout in seconds (10 minutes).
    /// </summary>
    public const int MaxTimeoutSeconds = 600;

    /// <summary>
    /// Maximum output length before truncation.
    /// </summary>
    public const int MaxOutputLength = 100_000;

    /// <summary>
    /// Patterns for dangerous commands that are blocked.
    /// </summary>
    private static readonly string[] DangerousPatterns =
    {
        @"rm\s+-rf\s+/",           // rm -rf /
        @"rm\s+-rf\s+~",           // rm -rf ~
        @"rm\s+-rf\s+\*",          // rm -rf *
        @"sudo\s+rm\s+-rf",        // sudo rm -rf
        @"format\s+[a-zA-Z]:",     // format C:
        @"mkfs\.",                 // mkfs.ext4
        @"dd\s+if=.*/dev/",        // dd if=/dev/zero
        @">\s*/dev/sd[a-z]",       // > /dev/sda
        @":(){:|:&};:",            // Fork bomb
        @"chmod\s+-R\s+777\s+/",   // chmod -R 777 /
        @"chown\s+-R.*\s+/",       // chown -R ... /
    };

    #endregion

    public RunCommandTool(
        ITerminalService terminalService,
        IWorkspaceService workspace,
        ILogger<RunCommandTool> logger)
    {
        _terminalService = terminalService ?? throw new ArgumentNullException(nameof(terminalService));
        _workspace = workspace ?? throw new ArgumentNullException(nameof(workspace));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <summary>
    /// Available when workspace is active and terminal session exists.
    /// </summary>
    public override bool IsAvailable =>
        _workspace.CurrentWorkspace != null &&
        _terminalService.ActiveSession != null;

    #region ExecuteAsync

    public override async Task<ToolResult> ExecuteAsync(
        ToolExecutionContext context,
        CancellationToken ct = default)
    {
        // Extract parameters
        var command = GetRequiredParameter<string>(context.Parameters, "command");
        var workingDir = GetOptionalParameter<string?>(context.Parameters, "working_directory", null);
        var timeoutSeconds = GetOptionalParameter(context.Parameters, "timeout_seconds", DefaultTimeoutSeconds);
        var captureOutput = GetOptionalParameter(context.Parameters, "capture_output", true);

        _logger.LogDebug(
            "RunCommandTool executing: command={Command}, timeout={Timeout}",
            TruncateCommand(command), timeoutSeconds);

        // Clamp timeout to maximum
        timeoutSeconds = Math.Min(timeoutSeconds, MaxTimeoutSeconds);

        // Determine working directory
        var effectiveDir = workingDir != null
            ? ToolPathHelper.ResolvePath(context.WorkspacePath, workingDir)
            : context.WorkspacePath ?? Environment.CurrentDirectory;

        // Validate working directory if specified
        if (workingDir != null)
        {
            var dirValidation = ToolPathHelper.ValidatePath(effectiveDir, context.WorkspacePath);
            if (!dirValidation.IsValid)
            {
                return ToolResult.Failed($"Invalid working directory: {dirValidation.ErrorMessage}");
            }
        }

        // Check for active terminal session
        var session = _terminalService.ActiveSession;
        if (session == null)
        {
            _logger.LogWarning("No active terminal session");
            return ToolResult.Failed("No active terminal session. Please open a terminal first.");
        }

        _logger.LogInformation(
            "Executing command: {Command} in {Directory}",
            TruncateCommand(command), effectiveDir);

        // Create cancellation with timeout
        using var cts = CancellationTokenSource.CreateLinkedTokenSource(ct);
        cts.CancelAfter(TimeSpan.FromSeconds(timeoutSeconds));

        var startTime = DateTime.UtcNow;

        try
        {
            var result = await _terminalService.ExecuteCommandAsync(
                session.Id,
                command,
                effectiveDir,
                captureOutput,
                cts.Token);

            // Handle non-capturing mode (command sent but not waited)
            if (result == null)
            {
                return ToolResult.Success(
                    content: null,
                    new CommandResultData
                    {
                        Command = command,
                        ExitCode = 0,
                        Duration = TimeSpan.Zero,
                        OutputLength = 0,
                        WasTruncated = false,
                        WorkingDirectory = effectiveDir,
                        WasStreamed = true
                    },
                    $"Command sent to terminal: {TruncateCommand(command)}");
            }

            var duration = DateTime.UtcNow - startTime;

            // Truncate output if too long
            var output = result.Output;
            var truncated = false;
            if (output.Length > MaxOutputLength)
            {
                output = output[..MaxOutputLength] + "\n\n[Output truncated...]";
                truncated = true;
                _logger.LogDebug("Output truncated from {Original} to {Max} chars",
                    result.Output.Length, MaxOutputLength);
            }

            var resultData = new CommandResultData
            {
                Command = command,
                ExitCode = result.ExitCode,
                Duration = duration,
                OutputLength = result.Output.Length,
                WasTruncated = truncated,
                WorkingDirectory = effectiveDir,
                WasStreamed = false
            };

            var message = result.ExitCode == 0
                ? $"Command succeeded ({duration.TotalSeconds:F1}s)"
                : $"Command failed with exit code {result.ExitCode}";

            _logger.LogInformation(
                "Command completed: exitCode={ExitCode}, duration={Duration}s",
                result.ExitCode, duration.TotalSeconds);

            return new ToolResult
            {
                IsSuccess = result.ExitCode == 0,
                Content = output,
                Data = resultData,
                Message = message
            };
        }
        catch (OperationCanceledException)
        {
            _logger.LogWarning("Command timed out after {Timeout}s: {Command}",
                timeoutSeconds, TruncateCommand(command));
            return ToolResult.Failed($"Command timed out after {timeoutSeconds} seconds");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Command execution failed: {Command}", TruncateCommand(command));
            return ToolResult.Failed($"Command execution failed: {ex.Message}");
        }
    }

    #endregion

    #region Validation

    public override ToolValidationResult Validate(JsonElement parameters)
    {
        var errors = new List<ToolValidationError>();

        // Check required command
        if (!parameters.TryGetProperty("command", out var cmdProp) ||
            string.IsNullOrWhiteSpace(cmdProp.GetString()))
        {
            errors.Add(ToolValidationError.Required("command"));
            return ToolValidationResult.Invalid(errors);
        }

        var command = cmdProp.GetString()!;

        // Check for dangerous patterns
        foreach (var pattern in DangerousPatterns)
        {
            if (Regex.IsMatch(command, pattern, RegexOptions.IgnoreCase))
            {
                _logger.LogWarning(
                    "Dangerous command blocked: {Command}, pattern={Pattern}",
                    TruncateCommand(command), pattern);

                errors.Add(new ToolValidationError
                {
                    ParameterName = "command",
                    Message = "Potentially dangerous command detected and blocked for safety.",
                    Code = "DANGEROUS_COMMAND"
                });
            }
        }

        // Validate timeout if provided
        if (parameters.TryGetProperty("timeout_seconds", out var timeoutProp))
        {
            var timeout = timeoutProp.GetInt32();
            if (timeout < 1)
            {
                errors.Add(new ToolValidationError
                {
                    ParameterName = "timeout_seconds",
                    Message = "Timeout must be at least 1 second",
                    Code = "INVALID_RANGE"
                });
            }
        }

        return errors.Count > 0
            ? ToolValidationResult.Invalid(errors)
            : ToolValidationResult.Valid();
    }

    #endregion

    #region Risk Assessment

    public override RiskLevel GetEffectiveRiskLevel(JsonElement parameters)
    {
        if (!parameters.TryGetProperty("command", out var cmdProp))
        {
            return RiskLevel.High;
        }

        var command = cmdProp.GetString() ?? "";

        // Check for sudo/admin commands
        if (command.StartsWith("sudo ", StringComparison.OrdinalIgnoreCase) ||
            command.Contains(" sudo ", StringComparison.OrdinalIgnoreCase))
        {
            return RiskLevel.Critical;
        }

        // Check for package manager installations
        if (Regex.IsMatch(command, @"(npm|pip|gem|cargo|brew)\s+install", RegexOptions.IgnoreCase))
        {
            return RiskLevel.High;
        }

        // Check for git push
        if (command.Contains("git push", StringComparison.OrdinalIgnoreCase))
        {
            return RiskLevel.High;
        }

        // Check for file deletion
        if (Regex.IsMatch(command, @"\brm\b.*-[rf]", RegexOptions.IgnoreCase))
        {
            return RiskLevel.High;
        }

        // Default to High for terminal commands
        return RiskLevel.High;
    }

    #endregion

    #region Overrides

    public override string GetExecutionSummary(JsonElement parameters)
    {
        var command = parameters.TryGetProperty("command", out var c)
            ? c.GetString() ?? ""
            : "";
        return $"Run: {TruncateCommand(command)}";
    }

    #endregion

    #region Helper Methods

    /// <summary>
    /// Truncate command for display.
    /// </summary>
    private static string TruncateCommand(string command)
    {
        return command.Length > 60 ? command[..57] + "..." : command;
    }

    #endregion
}
```

### 2. CommandResultData.cs

**Location**: `src/SeniorIntern.Services/Tools/Terminal/CommandResultData.cs`

```csharp
namespace SeniorIntern.Services.Tools.Terminal;

/// <summary>
/// Result data for command execution.
/// </summary>
public sealed class CommandResultData
{
    /// <summary>
    /// The command that was executed.
    /// </summary>
    public string Command { get; init; } = string.Empty;

    /// <summary>
    /// Exit code from the command (0 = success).
    /// </summary>
    public int ExitCode { get; init; }

    /// <summary>
    /// How long the command took to execute.
    /// </summary>
    public TimeSpan Duration { get; init; }

    /// <summary>
    /// Length of the output in characters.
    /// </summary>
    public int OutputLength { get; init; }

    /// <summary>
    /// Whether the output was truncated.
    /// </summary>
    public bool WasTruncated { get; init; }

    /// <summary>
    /// Working directory where command was executed.
    /// </summary>
    public string? WorkingDirectory { get; init; }

    /// <summary>
    /// Whether output was streamed to terminal (not captured).
    /// </summary>
    public bool WasStreamed { get; init; }

    /// <summary>
    /// Whether the command succeeded (exit code 0).
    /// </summary>
    public bool Succeeded => ExitCode == 0;

    /// <summary>
    /// Human-readable duration.
    /// </summary>
    public string FormattedDuration => Duration.TotalSeconds < 1
        ? $"{Duration.TotalMilliseconds:F0}ms"
        : $"{Duration.TotalSeconds:F1}s";
}
```

### 3. CommandExecutionResult.cs

**Location**: `src/SeniorIntern.Core/Models/CommandExecutionResult.cs`

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Result of command execution in terminal.
/// </summary>
public sealed class CommandExecutionResult
{
    /// <summary>
    /// Combined stdout and stderr output.
    /// </summary>
    public string Output { get; init; } = string.Empty;

    /// <summary>
    /// Stderr output only (if captured separately).
    /// </summary>
    public string Error { get; init; } = string.Empty;

    /// <summary>
    /// Exit code from the process.
    /// </summary>
    public int ExitCode { get; init; }

    /// <summary>
    /// Execution duration.
    /// </summary>
    public TimeSpan Duration { get; init; }

    /// <summary>
    /// Whether the command succeeded.
    /// </summary>
    public bool IsSuccess => ExitCode == 0;

    /// <summary>
    /// Create a success result.
    /// </summary>
    public static CommandExecutionResult Success(string output, TimeSpan duration) => new()
    {
        Output = output,
        ExitCode = 0,
        Duration = duration
    };

    /// <summary>
    /// Create a failure result.
    /// </summary>
    public static CommandExecutionResult Failure(string output, int exitCode, TimeSpan duration) => new()
    {
        Output = output,
        ExitCode = exitCode,
        Duration = duration
    };
}
```

---

## ITerminalService Extension

Add this method to the existing `ITerminalService` interface:

```csharp
// In src/SeniorIntern.Core/Interfaces/ITerminalService.cs

/// <summary>
/// Execute a command and optionally capture output.
/// </summary>
/// <param name="sessionId">Terminal session ID.</param>
/// <param name="command">Command to execute.</param>
/// <param name="workingDirectory">Optional working directory.</param>
/// <param name="captureOutput">Whether to capture output (vs stream to terminal).</param>
/// <param name="ct">Cancellation token.</param>
/// <returns>Execution result, or null if not capturing.</returns>
Task<CommandExecutionResult?> ExecuteCommandAsync(
    Guid sessionId,
    string command,
    string? workingDirectory = null,
    bool captureOutput = true,
    CancellationToken ct = default);
```

---

## Dangerous Command Patterns

| Pattern | Example | Reason |
|---------|---------|--------|
| `rm\s+-rf\s+/` | `rm -rf /` | Delete root filesystem |
| `rm\s+-rf\s+~` | `rm -rf ~` | Delete home directory |
| `rm\s+-rf\s+\*` | `rm -rf *` | Delete all in directory |
| `sudo\s+rm\s+-rf` | `sudo rm -rf ...` | Elevated destructive |
| `format\s+[a-zA-Z]:` | `format C:` | Format Windows drive |
| `mkfs\.` | `mkfs.ext4 /dev/sda` | Format disk |
| `dd\s+if=.*/dev/` | `dd if=/dev/zero ...` | Disk overwrite |
| `>\s*/dev/sd[a-z]` | `> /dev/sda` | Redirect to disk |
| `:(){:\|:&};:` | Fork bomb | System hang |
| `chmod\s+-R\s+777\s+/` | `chmod -R 777 /` | Insecure permissions |
| `chown\s+-R.*\s+/` | `chown -R user /` | Change root ownership |

---

## File Summary

| File | Location | Purpose | Lines |
|------|----------|---------|-------|
| `RunCommandTool.cs` | `Services/Tools/Terminal/` | Command execution | ~280 |
| `CommandResultData.cs` | `Services/Tools/Terminal/` | Result data model | ~50 |
| `CommandExecutionResult.cs` | `Core/Models/` | Execution result | ~45 |

---

## Unit Test Plan

| Test | Description |
|------|-------------|
| `RunCommandTool_SimpleCommand_Succeeds` | Basic command execution |
| `RunCommandTool_FailingCommand_ReturnsExitCode` | Exit code handling |
| `RunCommandTool_Timeout_ReturnsFailed` | Timeout behavior |
| `RunCommandTool_DangerousCommand_Blocked` | Pattern blocking |
| `RunCommandTool_WorkingDirectory_Validated` | Directory validation |
| `RunCommandTool_LongOutput_Truncated` | Output truncation |
| `RunCommandTool_Sudo_CriticalRisk` | Risk escalation |
| `RunCommandTool_Install_HighRisk` | Package install risk |
| `RunCommandTool_NoSession_ReturnsFailed` | Session requirement |
| `Validate_DangerousPatterns_AllBlocked` | All patterns tested |

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | RunCommandTool executes shell commands |
| AC-2 | Output is captured and returned |
| AC-3 | Timeout handling prevents hung commands |
| AC-4 | Dangerous commands are blocked |
| AC-5 | Working directory can be specified |
| AC-6 | Exit codes are properly returned |

---

## Changelog Entry

```markdown
## v0.6.3e - Terminal Command Tool

### Added
- `RunCommandTool` for executing shell commands
  - Output capture (stdout + stderr combined)
  - Configurable timeout (default: 120s, max: 600s)
  - Working directory support
  - Output truncation at 100KB
  - Exit code reporting
- Dangerous command pattern blocking
  - 11 dangerous patterns blocked at validation
  - Fork bomb detection
  - Destructive rm commands
  - Disk format/overwrite commands
- Dynamic risk assessment
  - sudo commands → Critical
  - Package installs → High
  - git push → High
  - Default → High
- `CommandResultData` for execution metadata
- `CommandExecutionResult` for terminal service
- `ITerminalService.ExecuteCommandAsync` extension
```

---

## Integration with v0.5.x Terminal

This tool integrates with the terminal infrastructure from v0.5.x:

```
┌─────────────────────────────────────────────────────────────────┐
│  v0.5.x Terminal Infrastructure Integration                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  RunCommandTool                                                 │
│       │                                                         │
│       ▼                                                         │
│  ITerminalService.ExecuteCommandAsync()                         │
│       │                                                         │
│       ▼                                                         │
│  TerminalSession (from v0.5.1)                                  │
│       │                                                         │
│       ▼                                                         │
│  ShellProcess (from v0.5.3)                                     │
│       │                                                         │
│       ▼                                                         │
│  Platform Shell (zsh/bash/powershell/cmd)                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## Timeline Estimate

| Version | Estimated Effort |
|---------|------------------|
| v0.6.3e | 0.75 day |
