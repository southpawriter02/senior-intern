# v0.8.4: Hardware Monitoring - Detailed Design Specification

## Overview

This document provides a comprehensive design specification for v0.8.4 of The Senior Intern project. This version implements real-time hardware monitoring with GPU/CPU metrics collection, memory tracking, temperature monitoring, and streaming capabilities for live visualization in the training UI. This system integrates with the training infrastructure from v0.8.1 and provides the metrics foundation for the Training UI in v0.8.5.

### Objectives
- Create hardware monitoring service interface with start/stop control
- Implement GPU metrics collection for NVIDIA (CUDA) via nvidia-smi
- Implement GPU metrics collection for Apple Silicon (Metal) via system APIs
- Build CPU metrics collection for Windows, Linux, and macOS
- Create memory tracking for both system RAM and GPU VRAM
- Implement temperature monitoring for thermal management
- Design timestamped metrics history with configurable retention
- Build event-driven metrics streaming for real-time UI updates
- Create metric aggregation utilities for summary statistics

### Prerequisites
- v0.8.1 (Training Infrastructure) completed with TorchSharp integration
- v0.8.2 (Dataset Pipeline) completed
- v0.8.3 (LoRA Training Engine) completed
- TorchSharp runtime initialized with CUDA/Metal/CPU backend
- Understanding of platform-specific system metrics APIs

---

## Architecture Overview

### Hardware Monitoring Stack

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        Training UI (v0.8.5)                                  │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │  Real-time Graphs │ Hardware Gauges │ Temperature Alerts            │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────┘
                                      ▲
                                      │ MetricsUpdated Event
                                      │
┌─────────────────────────────────────────────────────────────────────────────┐
│                    v0.8.4: Hardware Monitoring                               │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                  IHardwareMonitorService                             │    │
│  │  StartMonitoring() │ StopMonitoring() │ GetCurrentMetrics()         │    │
│  │  GetHistory() │ ClearHistory() │ MetricsUpdated event              │    │
│  └────────────────────────────────────────────────────────────────────┘    │
│                                      │                                       │
│                                      ▼                                       │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                  HardwareMonitorService                              │    │
│  │  Timer-based collection │ History management │ Event dispatch        │    │
│  └────────────────────────────────────────────────────────────────────┘    │
│                                      │                                       │
│           ┌──────────────────────────┼──────────────────────────┐           │
│           ▼                          ▼                          ▼           │
│  ┌─────────────────┐    ┌─────────────────────┐    ┌─────────────────┐     │
│  │ GpuMetrics      │    │ CpuMetricsProvider  │    │ MemoryMetrics   │     │
│  │ Provider        │    │                     │    │ Provider        │     │
│  │ ┌─────────────┐ │    │ ┌─────────────────┐ │    │ ┌─────────────┐ │     │
│  │ │ CUDA (SMI)  │ │    │ │ Windows (PDH)   │ │    │ │ System RAM  │ │     │
│  │ │ Metal (IOKit)│ │    │ │ Linux (/proc)   │ │    │ │ GPU VRAM   │ │     │
│  │ │ CPU Fallback│ │    │ │ macOS (host_*) │ │    │ │ Managed Heap│ │     │
│  │ └─────────────┘ │    │ └─────────────────┘ │    │ └─────────────┘ │     │
│  └─────────────────┘    └─────────────────────┘    └─────────────────┘     │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                        Platform APIs                                         │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐              │
│  │ nvidia-smi      │  │ IOKit (macOS)   │  │ /proc (Linux)   │              │
│  │ NVML (optional) │  │ host_statistics │  │ PDH (Windows)   │              │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Metrics Collection Flow

```
┌──────────────────┐
│ StartMonitoring  │
│ (interval: 1s)   │
└────────┬─────────┘
         │
         ▼
┌──────────────────┐     ┌───────────────────────────────────────────────────┐
│ Timer Callback   │────▶│ CollectMetricsInternal()                         │
│ (every interval) │     │                                                   │
└──────────────────┘     │  1. Detect active GPU backend (CUDA/Metal/CPU)   │
                         │  2. Collect GPU metrics (utilization, memory, temp)│
                         │  3. Collect CPU metrics (utilization per core)    │
                         │  4. Collect memory metrics (RAM, managed heap)    │
                         │  5. Create timestamped HardwareMetrics            │
                         └───────────────────────────────────────────────────┘
                                              │
                                              ▼
                         ┌───────────────────────────────────────────────────┐
                         │ History Management                                 │
                         │                                                   │
                         │  • Enqueue new TimestampedMetrics                │
                         │  • Trim history to max size (default: 3600)      │
                         │  • Support time-based queries                     │
                         └───────────────────────────────────────────────────┘
                                              │
                                              ▼
                         ┌───────────────────────────────────────────────────┐
                         │ Event Dispatch                                    │
                         │                                                   │
                         │  MetricsUpdated?.Invoke(this, new EventArgs      │
                         │  {                                                │
                         │      Metrics = latestMetrics                     │
                         │  });                                              │
                         └───────────────────────────────────────────────────┘
                                              │
                                              ▼
                         ┌───────────────────────────────────────────────────┐
                         │ UI Update (v0.8.5)                                │
                         │                                                   │
                         │  • Update real-time charts                       │
                         │  • Update gauge displays                         │
                         │  • Check thermal thresholds                      │
                         │  • Trigger alerts if needed                      │
                         └───────────────────────────────────────────────────┘
```

---

## Sub-version Breakdown

| Version | Focus | Files to Create | Files to Modify |
|---------|-------|-----------------|-----------------|
| v0.8.4a | Hardware Metrics Models | 4 | 0 |
| v0.8.4b | Hardware Monitor Service Interface | 2 | 0 |
| v0.8.4c | GPU Metrics Provider - NVIDIA (CUDA) | 2 | 0 |
| v0.8.4d | GPU Metrics Provider - Apple Silicon (Metal) | 2 | 0 |
| v0.8.4e | CPU Metrics Provider (Cross-Platform) | 3 | 0 |
| v0.8.4f | Memory Metrics Provider | 2 | 0 |
| v0.8.4g | Hardware Monitor Service Implementation | 2 | 0 |
| v0.8.4h | Metrics Aggregation & Statistics | 2 | 0 |
| v0.8.4i | Thermal Management & Alerts | 2 | 0 |
| v0.8.4j | Unit Testing & Integration | 8 | 0 |

**Totals: 29 files to create, 0 files to modify**

---

## v0.8.4a: Hardware Metrics Models

### Objective
Define the core data models for hardware metrics including GPU, CPU, memory, and thermal information with support for multi-GPU systems.

### File: `src/SeniorIntern.Core/Training/Models/HardwareMetrics.cs`

```csharp
namespace SeniorIntern.Core.Training.Models;

/// <summary>
/// Comprehensive hardware metrics snapshot.
/// </summary>
public sealed record HardwareMetrics
{
    /// <summary>
    /// Timestamp when metrics were collected.
    /// </summary>
    public DateTime Timestamp { get; init; } = DateTime.UtcNow;

    /// <summary>
    /// GPU metrics for each available GPU (null if no GPU).
    /// </summary>
    public IReadOnlyList<GpuMetrics> GpuMetrics { get; init; } = Array.Empty<GpuMetrics>();

    /// <summary>
    /// CPU metrics.
    /// </summary>
    public CpuMetrics CpuMetrics { get; init; } = new();

    /// <summary>
    /// System memory metrics.
    /// </summary>
    public MemoryMetrics MemoryMetrics { get; init; } = new();

    /// <summary>
    /// Active training device type.
    /// </summary>
    public DeviceType ActiveDevice { get; init; } = DeviceType.Cpu;

    /// <summary>
    /// Whether monitoring is currently active.
    /// </summary>
    public bool IsMonitoring { get; init; }

    // Convenience properties for primary GPU (for single-GPU systems)

    /// <summary>
    /// Primary GPU utilization percentage (0-100).
    /// </summary>
    public float GpuUtilization => GpuMetrics.FirstOrDefault()?.Utilization ?? 0;

    /// <summary>
    /// Primary GPU memory used in bytes.
    /// </summary>
    public long GpuMemoryUsed => GpuMetrics.FirstOrDefault()?.MemoryUsed ?? 0;

    /// <summary>
    /// Primary GPU total memory in bytes.
    /// </summary>
    public long GpuMemoryTotal => GpuMetrics.FirstOrDefault()?.MemoryTotal ?? 0;

    /// <summary>
    /// Primary GPU temperature in Celsius.
    /// </summary>
    public float GpuTemperature => GpuMetrics.FirstOrDefault()?.Temperature ?? 0;

    /// <summary>
    /// CPU utilization percentage (0-100).
    /// </summary>
    public float CpuUtilization => CpuMetrics.TotalUtilization;

    /// <summary>
    /// System RAM used in bytes.
    /// </summary>
    public long RamUsed => MemoryMetrics.UsedBytes;

    /// <summary>
    /// System RAM total in bytes.
    /// </summary>
    public long RamTotal => MemoryMetrics.TotalBytes;
}

/// <summary>
/// Device type for training operations.
/// </summary>
public enum DeviceType
{
    /// <summary>
    /// CPU-only computation.
    /// </summary>
    Cpu,

    /// <summary>
    /// NVIDIA CUDA GPU.
    /// </summary>
    Cuda,

    /// <summary>
    /// Apple Metal Performance Shaders (Apple Silicon).
    /// </summary>
    Metal
}
```

### File: `src/SeniorIntern.Core/Training/Models/GpuMetrics.cs`

```csharp
namespace SeniorIntern.Core.Training.Models;

/// <summary>
/// Metrics for a single GPU device.
/// </summary>
public sealed record GpuMetrics
{
    /// <summary>
    /// GPU device index (0-based).
    /// </summary>
    public int DeviceIndex { get; init; }

    /// <summary>
    /// GPU device name (e.g., "NVIDIA RTX 4090").
    /// </summary>
    public string DeviceName { get; init; } = string.Empty;

    /// <summary>
    /// GPU type (CUDA, Metal).
    /// </summary>
    public GpuType GpuType { get; init; }

    /// <summary>
    /// GPU utilization percentage (0-100).
    /// </summary>
    public float Utilization { get; init; }

    /// <summary>
    /// GPU memory used in bytes.
    /// </summary>
    public long MemoryUsed { get; init; }

    /// <summary>
    /// GPU total memory in bytes.
    /// </summary>
    public long MemoryTotal { get; init; }

    /// <summary>
    /// GPU temperature in Celsius (0 if unavailable).
    /// </summary>
    public float Temperature { get; init; }

    /// <summary>
    /// GPU power draw in watts (0 if unavailable).
    /// </summary>
    public float PowerDraw { get; init; }

    /// <summary>
    /// GPU power limit in watts (0 if unavailable).
    /// </summary>
    public float PowerLimit { get; init; }

    /// <summary>
    /// GPU fan speed percentage (0-100, 0 if unavailable).
    /// </summary>
    public float FanSpeed { get; init; }

    /// <summary>
    /// GPU memory clock speed in MHz (0 if unavailable).
    /// </summary>
    public int MemoryClockMhz { get; init; }

    /// <summary>
    /// GPU graphics clock speed in MHz (0 if unavailable).
    /// </summary>
    public int GraphicsClockMhz { get; init; }

    /// <summary>
    /// Memory utilization percentage (calculated).
    /// </summary>
    public float MemoryUtilization => MemoryTotal > 0
        ? (float)MemoryUsed / MemoryTotal * 100f
        : 0f;

    /// <summary>
    /// Available memory in bytes.
    /// </summary>
    public long MemoryAvailable => MemoryTotal - MemoryUsed;

    /// <summary>
    /// Power utilization percentage (calculated).
    /// </summary>
    public float PowerUtilization => PowerLimit > 0
        ? PowerDraw / PowerLimit * 100f
        : 0f;
}

/// <summary>
/// GPU hardware type.
/// </summary>
public enum GpuType
{
    /// <summary>
    /// Unknown GPU type.
    /// </summary>
    Unknown,

    /// <summary>
    /// NVIDIA GPU with CUDA support.
    /// </summary>
    NvidiaCuda,

    /// <summary>
    /// AMD GPU with ROCm support (future).
    /// </summary>
    AmdRocm,

    /// <summary>
    /// Apple Silicon with Metal support.
    /// </summary>
    AppleMetal,

    /// <summary>
    /// Intel integrated graphics (CPU fallback).
    /// </summary>
    IntelIntegrated
}
```

### File: `src/SeniorIntern.Core/Training/Models/CpuMetrics.cs`

```csharp
namespace SeniorIntern.Core.Training.Models;

/// <summary>
/// CPU performance metrics.
/// </summary>
public sealed record CpuMetrics
{
    /// <summary>
    /// CPU model name (e.g., "Intel Core i9-12900K").
    /// </summary>
    public string ModelName { get; init; } = string.Empty;

    /// <summary>
    /// Number of physical cores.
    /// </summary>
    public int PhysicalCores { get; init; }

    /// <summary>
    /// Number of logical processors (threads).
    /// </summary>
    public int LogicalProcessors { get; init; }

    /// <summary>
    /// Total CPU utilization percentage (0-100).
    /// </summary>
    public float TotalUtilization { get; init; }

    /// <summary>
    /// Per-core utilization percentages.
    /// </summary>
    public IReadOnlyList<float> PerCoreUtilization { get; init; } = Array.Empty<float>();

    /// <summary>
    /// Current process CPU utilization percentage.
    /// </summary>
    public float ProcessUtilization { get; init; }

    /// <summary>
    /// Current CPU frequency in MHz (0 if unavailable).
    /// </summary>
    public int CurrentFrequencyMhz { get; init; }

    /// <summary>
    /// Maximum CPU frequency in MHz (0 if unavailable).
    /// </summary>
    public int MaxFrequencyMhz { get; init; }

    /// <summary>
    /// CPU package temperature in Celsius (0 if unavailable).
    /// </summary>
    public float Temperature { get; init; }

    /// <summary>
    /// Thread count for current process.
    /// </summary>
    public int ProcessThreadCount { get; init; }
}
```

### File: `src/SeniorIntern.Core/Training/Models/MemoryMetrics.cs`

```csharp
namespace SeniorIntern.Core.Training.Models;

/// <summary>
/// System and managed memory metrics.
/// </summary>
public sealed record MemoryMetrics
{
    /// <summary>
    /// Total physical RAM in bytes.
    /// </summary>
    public long TotalBytes { get; init; }

    /// <summary>
    /// Used physical RAM in bytes.
    /// </summary>
    public long UsedBytes { get; init; }

    /// <summary>
    /// Available physical RAM in bytes.
    /// </summary>
    public long AvailableBytes => TotalBytes - UsedBytes;

    /// <summary>
    /// RAM utilization percentage.
    /// </summary>
    public float Utilization => TotalBytes > 0
        ? (float)UsedBytes / TotalBytes * 100f
        : 0f;

    /// <summary>
    /// Current process working set (private memory) in bytes.
    /// </summary>
    public long ProcessWorkingSet { get; init; }

    /// <summary>
    /// Current process private memory in bytes.
    /// </summary>
    public long ProcessPrivateMemory { get; init; }

    /// <summary>
    /// .NET managed heap size in bytes.
    /// </summary>
    public long ManagedHeapSize { get; init; }

    /// <summary>
    /// .NET GC total allocated bytes.
    /// </summary>
    public long GcTotalAllocated { get; init; }

    /// <summary>
    /// .NET GC generation 0 collection count.
    /// </summary>
    public int GcGen0Collections { get; init; }

    /// <summary>
    /// .NET GC generation 1 collection count.
    /// </summary>
    public int GcGen1Collections { get; init; }

    /// <summary>
    /// .NET GC generation 2 collection count.
    /// </summary>
    public int GcGen2Collections { get; init; }

    /// <summary>
    /// Virtual memory committed by the process.
    /// </summary>
    public long VirtualMemoryCommitted { get; init; }

    /// <summary>
    /// Page file usage (Windows) or swap usage (Linux/macOS).
    /// </summary>
    public long PageFileUsage { get; init; }
}
```

---

## v0.8.4b: Hardware Monitor Service Interface

### Objective
Define the service interface for hardware monitoring with start/stop control, metrics retrieval, history management, and event-based streaming.

### File: `src/SeniorIntern.Core/Interfaces/IHardwareMonitorService.cs`

```csharp
namespace SeniorIntern.Core.Interfaces;

using SeniorIntern.Core.Training.Models;

/// <summary>
/// Service for real-time hardware monitoring during training.
/// </summary>
public interface IHardwareMonitorService : IDisposable
{
    /// <summary>
    /// Gets whether monitoring is currently active.
    /// </summary>
    bool IsMonitoring { get; }

    /// <summary>
    /// Gets the current monitoring interval.
    /// </summary>
    TimeSpan MonitoringInterval { get; }

    /// <summary>
    /// Start periodic hardware monitoring.
    /// </summary>
    /// <param name="interval">Collection interval (minimum 100ms, default 1s).</param>
    void StartMonitoring(TimeSpan? interval = null);

    /// <summary>
    /// Stop hardware monitoring.
    /// </summary>
    void StopMonitoring();

    /// <summary>
    /// Get current metrics snapshot (collects fresh data).
    /// </summary>
    /// <returns>Current hardware metrics.</returns>
    HardwareMetrics GetCurrentMetrics();

    /// <summary>
    /// Get the last collected metrics (no new collection).
    /// </summary>
    /// <returns>Last metrics or null if never collected.</returns>
    HardwareMetrics? GetLastMetrics();

    /// <summary>
    /// Get metrics history for a specified duration.
    /// </summary>
    /// <param name="duration">Time span to retrieve (from now backwards).</param>
    /// <returns>List of timestamped metrics ordered by time ascending.</returns>
    IReadOnlyList<TimestampedMetrics> GetHistory(TimeSpan duration);

    /// <summary>
    /// Get all available metrics history.
    /// </summary>
    /// <returns>All stored timestamped metrics ordered by time ascending.</returns>
    IReadOnlyList<TimestampedMetrics> GetFullHistory();

    /// <summary>
    /// Clear all metrics history.
    /// </summary>
    void ClearHistory();

    /// <summary>
    /// Get aggregated statistics for a time period.
    /// </summary>
    /// <param name="duration">Time span to aggregate.</param>
    /// <returns>Aggregated metrics statistics.</returns>
    MetricsStatistics GetStatistics(TimeSpan duration);

    /// <summary>
    /// Set the maximum history size.
    /// </summary>
    /// <param name="maxSize">Maximum number of metrics to retain.</param>
    void SetMaxHistorySize(int maxSize);

    /// <summary>
    /// Event raised when new metrics are collected.
    /// </summary>
    event EventHandler<HardwareMetricsEventArgs>? MetricsUpdated;

    /// <summary>
    /// Event raised when a thermal threshold is exceeded.
    /// </summary>
    event EventHandler<ThermalAlertEventArgs>? ThermalAlert;

    /// <summary>
    /// Event raised when memory usage exceeds a threshold.
    /// </summary>
    event EventHandler<MemoryAlertEventArgs>? MemoryAlert;
}

/// <summary>
/// Timestamped hardware metrics for history storage.
/// </summary>
public sealed class TimestampedMetrics
{
    /// <summary>
    /// When the metrics were collected.
    /// </summary>
    public DateTime Timestamp { get; init; }

    /// <summary>
    /// The collected metrics.
    /// </summary>
    public HardwareMetrics Metrics { get; init; } = null!;
}

/// <summary>
/// Event args for metrics update events.
/// </summary>
public sealed class HardwareMetricsEventArgs : EventArgs
{
    /// <summary>
    /// The newly collected metrics.
    /// </summary>
    public HardwareMetrics Metrics { get; init; } = null!;

    /// <summary>
    /// Time since last collection.
    /// </summary>
    public TimeSpan TimeSinceLastCollection { get; init; }
}

/// <summary>
/// Event args for thermal alert events.
/// </summary>
public sealed class ThermalAlertEventArgs : EventArgs
{
    /// <summary>
    /// The component that triggered the alert.
    /// </summary>
    public ThermalComponent Component { get; init; }

    /// <summary>
    /// Current temperature in Celsius.
    /// </summary>
    public float CurrentTemperature { get; init; }

    /// <summary>
    /// Threshold that was exceeded.
    /// </summary>
    public float ThresholdTemperature { get; init; }

    /// <summary>
    /// Alert severity level.
    /// </summary>
    public AlertSeverity Severity { get; init; }

    /// <summary>
    /// GPU device index (if GPU-related).
    /// </summary>
    public int? DeviceIndex { get; init; }
}

/// <summary>
/// Event args for memory alert events.
/// </summary>
public sealed class MemoryAlertEventArgs : EventArgs
{
    /// <summary>
    /// The memory type that triggered the alert.
    /// </summary>
    public MemoryType MemoryType { get; init; }

    /// <summary>
    /// Current usage in bytes.
    /// </summary>
    public long CurrentUsage { get; init; }

    /// <summary>
    /// Total capacity in bytes.
    /// </summary>
    public long TotalCapacity { get; init; }

    /// <summary>
    /// Usage percentage that triggered the alert.
    /// </summary>
    public float UsagePercentage { get; init; }

    /// <summary>
    /// Threshold percentage that was exceeded.
    /// </summary>
    public float ThresholdPercentage { get; init; }

    /// <summary>
    /// Alert severity level.
    /// </summary>
    public AlertSeverity Severity { get; init; }

    /// <summary>
    /// GPU device index (if GPU memory).
    /// </summary>
    public int? DeviceIndex { get; init; }
}

/// <summary>
/// Components that can trigger thermal alerts.
/// </summary>
public enum ThermalComponent
{
    Gpu,
    Cpu
}

/// <summary>
/// Memory types for alerts.
/// </summary>
public enum MemoryType
{
    SystemRam,
    GpuVram,
    ManagedHeap
}

/// <summary>
/// Alert severity levels.
/// </summary>
public enum AlertSeverity
{
    /// <summary>
    /// Warning level - approaching threshold.
    /// </summary>
    Warning,

    /// <summary>
    /// Critical level - threshold exceeded.
    /// </summary>
    Critical,

    /// <summary>
    /// Emergency level - immediate action required.
    /// </summary>
    Emergency
}
```

### File: `src/SeniorIntern.Core/Training/Models/MetricsStatistics.cs`

```csharp
namespace SeniorIntern.Core.Training.Models;

/// <summary>
/// Aggregated statistics for hardware metrics over a time period.
/// </summary>
public sealed record MetricsStatistics
{
    /// <summary>
    /// Start of the statistics period.
    /// </summary>
    public DateTime PeriodStart { get; init; }

    /// <summary>
    /// End of the statistics period.
    /// </summary>
    public DateTime PeriodEnd { get; init; }

    /// <summary>
    /// Number of samples in the period.
    /// </summary>
    public int SampleCount { get; init; }

    /// <summary>
    /// GPU statistics (primary GPU).
    /// </summary>
    public ComponentStatistics GpuUtilization { get; init; } = new();

    /// <summary>
    /// GPU memory statistics (primary GPU).
    /// </summary>
    public ComponentStatistics GpuMemory { get; init; } = new();

    /// <summary>
    /// GPU temperature statistics (primary GPU).
    /// </summary>
    public ComponentStatistics GpuTemperature { get; init; } = new();

    /// <summary>
    /// CPU utilization statistics.
    /// </summary>
    public ComponentStatistics CpuUtilization { get; init; } = new();

    /// <summary>
    /// System RAM statistics.
    /// </summary>
    public ComponentStatistics RamUsage { get; init; } = new();

    /// <summary>
    /// Peak GPU memory usage in bytes.
    /// </summary>
    public long PeakGpuMemory { get; init; }

    /// <summary>
    /// Peak system RAM usage in bytes.
    /// </summary>
    public long PeakRamUsage { get; init; }

    /// <summary>
    /// Maximum GPU temperature recorded.
    /// </summary>
    public float MaxGpuTemperature { get; init; }

    /// <summary>
    /// Thermal throttling detected during period.
    /// </summary>
    public bool ThermalThrottlingDetected { get; init; }

    /// <summary>
    /// Out of memory events detected during period.
    /// </summary>
    public int OutOfMemoryEvents { get; init; }
}

/// <summary>
/// Statistical summary for a single metric.
/// </summary>
public sealed record ComponentStatistics
{
    /// <summary>
    /// Minimum value observed.
    /// </summary>
    public float Minimum { get; init; }

    /// <summary>
    /// Maximum value observed.
    /// </summary>
    public float Maximum { get; init; }

    /// <summary>
    /// Average (mean) value.
    /// </summary>
    public float Average { get; init; }

    /// <summary>
    /// Median value (50th percentile).
    /// </summary>
    public float Median { get; init; }

    /// <summary>
    /// Standard deviation.
    /// </summary>
    public float StandardDeviation { get; init; }

    /// <summary>
    /// 95th percentile value.
    /// </summary>
    public float Percentile95 { get; init; }

    /// <summary>
    /// 99th percentile value.
    /// </summary>
    public float Percentile99 { get; init; }

    /// <summary>
    /// Current/latest value.
    /// </summary>
    public float Current { get; init; }
}
```

---

## v0.8.4c: GPU Metrics Provider - NVIDIA (CUDA)

### Objective
Implement GPU metrics collection for NVIDIA GPUs using nvidia-smi command-line tool and TorchSharp CUDA APIs for memory information.

### File: `src/SeniorIntern.Services/Training/Providers/NvidiaGpuMetricsProvider.cs`

```csharp
namespace SeniorIntern.Services.Training.Providers;

using System.Diagnostics;
using System.Globalization;
using System.Text.RegularExpressions;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Training.Models;
using TorchSharp;

/// <summary>
/// GPU metrics provider for NVIDIA GPUs using nvidia-smi and TorchSharp CUDA APIs.
/// </summary>
public sealed class NvidiaGpuMetricsProvider : IGpuMetricsProvider
{
    private readonly ILogger<NvidiaGpuMetricsProvider> _logger;
    private readonly bool _nvidiaSmiAvailable;
    private readonly string _nvidiaSmiPath;
    private readonly int _deviceCount;
    private readonly Dictionary<int, string> _deviceNames;

    // nvidia-smi query fields
    private const string QueryFields =
        "index,name,utilization.gpu,memory.used,memory.total," +
        "temperature.gpu,power.draw,power.limit,fan.speed," +
        "clocks.current.memory,clocks.current.graphics";

    public NvidiaGpuMetricsProvider(ILogger<NvidiaGpuMetricsProvider> logger)
    {
        _logger = logger;
        _deviceNames = new Dictionary<int, string>();

        // Check if CUDA is available via TorchSharp
        if (!torch.cuda.is_available())
        {
            _nvidiaSmiAvailable = false;
            _deviceCount = 0;
            _nvidiaSmiPath = string.Empty;
            _logger.LogInformation("CUDA not available, NVIDIA GPU metrics disabled");
            return;
        }

        _deviceCount = (int)torch.cuda.device_count();
        _nvidiaSmiPath = FindNvidiaSmi();
        _nvidiaSmiAvailable = !string.IsNullOrEmpty(_nvidiaSmiPath);

        if (_nvidiaSmiAvailable)
        {
            _logger.LogInformation(
                "NVIDIA GPU metrics provider initialized: {DeviceCount} GPU(s), nvidia-smi at {Path}",
                _deviceCount, _nvidiaSmiPath);

            // Cache device names
            for (int i = 0; i < _deviceCount; i++)
            {
                _deviceNames[i] = torch.cuda.get_device_name(i);
            }
        }
        else
        {
            _logger.LogWarning(
                "nvidia-smi not found, GPU metrics will be limited to TorchSharp APIs");
        }
    }

    /// <inheritdoc/>
    public bool IsAvailable => _deviceCount > 0;

    /// <inheritdoc/>
    public int DeviceCount => _deviceCount;

    /// <inheritdoc/>
    public GpuType GpuType => GpuType.NvidiaCuda;

    /// <inheritdoc/>
    public IReadOnlyList<GpuMetrics> CollectMetrics()
    {
        if (_deviceCount == 0)
            return Array.Empty<GpuMetrics>();

        var metrics = new List<GpuMetrics>();

        if (_nvidiaSmiAvailable)
        {
            // Use nvidia-smi for comprehensive metrics
            var smiMetrics = QueryNvidiaSmi();
            if (smiMetrics.Count > 0)
            {
                return smiMetrics;
            }
        }

        // Fallback to TorchSharp-only metrics
        for (int i = 0; i < _deviceCount; i++)
        {
            metrics.Add(CollectTorchSharpMetrics(i));
        }

        return metrics;
    }

    /// <inheritdoc/>
    public GpuMetrics CollectMetrics(int deviceIndex)
    {
        if (deviceIndex < 0 || deviceIndex >= _deviceCount)
        {
            throw new ArgumentOutOfRangeException(
                nameof(deviceIndex),
                $"Device index must be between 0 and {_deviceCount - 1}");
        }

        if (_nvidiaSmiAvailable)
        {
            var smiMetrics = QueryNvidiaSmiSingleDevice(deviceIndex);
            if (smiMetrics != null)
                return smiMetrics;
        }

        return CollectTorchSharpMetrics(deviceIndex);
    }

    private List<GpuMetrics> QueryNvidiaSmi()
    {
        var metrics = new List<GpuMetrics>();

        try
        {
            var output = ExecuteNvidiaSmi($"--query-gpu={QueryFields} --format=csv,noheader,nounits");
            if (string.IsNullOrWhiteSpace(output))
                return metrics;

            var lines = output.Split('\n', StringSplitOptions.RemoveEmptyEntries);
            foreach (var line in lines)
            {
                var parsed = ParseNvidiaSmiLine(line);
                if (parsed != null)
                    metrics.Add(parsed);
            }
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Failed to query nvidia-smi");
        }

        return metrics;
    }

    private GpuMetrics? QueryNvidiaSmiSingleDevice(int deviceIndex)
    {
        try
        {
            var output = ExecuteNvidiaSmi(
                $"--query-gpu={QueryFields} --format=csv,noheader,nounits -i {deviceIndex}");

            if (string.IsNullOrWhiteSpace(output))
                return null;

            return ParseNvidiaSmiLine(output.Trim());
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Failed to query nvidia-smi for device {Index}", deviceIndex);
            return null;
        }
    }

    private GpuMetrics? ParseNvidiaSmiLine(string line)
    {
        // Format: index, name, utilization.gpu, memory.used, memory.total,
        //         temperature.gpu, power.draw, power.limit, fan.speed,
        //         clocks.current.memory, clocks.current.graphics
        var parts = line.Split(',').Select(p => p.Trim()).ToArray();

        if (parts.Length < 11)
            return null;

        try
        {
            return new GpuMetrics
            {
                DeviceIndex = ParseInt(parts[0]),
                DeviceName = parts[1],
                GpuType = GpuType.NvidiaCuda,
                Utilization = ParseFloat(parts[2]),
                MemoryUsed = ParseLong(parts[3]) * 1024 * 1024, // MiB to bytes
                MemoryTotal = ParseLong(parts[4]) * 1024 * 1024,
                Temperature = ParseFloat(parts[5]),
                PowerDraw = ParseFloat(parts[6]),
                PowerLimit = ParseFloat(parts[7]),
                FanSpeed = ParseFloat(parts[8]),
                MemoryClockMhz = ParseInt(parts[9]),
                GraphicsClockMhz = ParseInt(parts[10])
            };
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Failed to parse nvidia-smi line: {Line}", line);
            return null;
        }
    }

    private GpuMetrics CollectTorchSharpMetrics(int deviceIndex)
    {
        // Switch to the correct device context
        using var _ = torch.cuda.device(deviceIndex);

        var (free, total) = torch.cuda.mem_get_info(deviceIndex);

        return new GpuMetrics
        {
            DeviceIndex = deviceIndex,
            DeviceName = _deviceNames.GetValueOrDefault(deviceIndex, $"CUDA:{deviceIndex}"),
            GpuType = GpuType.NvidiaCuda,
            Utilization = 0, // Not available without nvidia-smi
            MemoryUsed = (long)(total - free),
            MemoryTotal = (long)total,
            Temperature = 0,
            PowerDraw = 0,
            PowerLimit = 0,
            FanSpeed = 0,
            MemoryClockMhz = 0,
            GraphicsClockMhz = 0
        };
    }

    private string ExecuteNvidiaSmi(string arguments)
    {
        try
        {
            using var process = new Process
            {
                StartInfo = new ProcessStartInfo
                {
                    FileName = _nvidiaSmiPath,
                    Arguments = arguments,
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    UseShellExecute = false,
                    CreateNoWindow = true
                }
            };

            process.Start();
            var output = process.StandardOutput.ReadToEnd();
            process.WaitForExit(timeout: 5000);

            if (process.ExitCode != 0)
            {
                var error = process.StandardError.ReadToEnd();
                _logger.LogWarning("nvidia-smi returned non-zero: {Error}", error);
                return string.Empty;
            }

            return output;
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Failed to execute nvidia-smi");
            return string.Empty;
        }
    }

    private static string FindNvidiaSmi()
    {
        if (OperatingSystem.IsWindows())
        {
            // Try standard Windows locations
            var paths = new[]
            {
                @"C:\Windows\System32\nvidia-smi.exe",
                @"C:\Program Files\NVIDIA Corporation\NVSMI\nvidia-smi.exe"
            };

            foreach (var path in paths)
            {
                if (File.Exists(path))
                    return path;
            }

            // Try PATH
            return "nvidia-smi.exe";
        }
        else
        {
            // Linux/macOS - try PATH
            return "nvidia-smi";
        }
    }

    private static float ParseFloat(string value)
    {
        if (string.IsNullOrWhiteSpace(value) || value == "[N/A]" || value == "N/A")
            return 0f;

        return float.TryParse(value, NumberStyles.Float, CultureInfo.InvariantCulture, out var result)
            ? result
            : 0f;
    }

    private static int ParseInt(string value)
    {
        if (string.IsNullOrWhiteSpace(value) || value == "[N/A]" || value == "N/A")
            return 0;

        return int.TryParse(value, NumberStyles.Integer, CultureInfo.InvariantCulture, out var result)
            ? result
            : 0;
    }

    private static long ParseLong(string value)
    {
        if (string.IsNullOrWhiteSpace(value) || value == "[N/A]" || value == "N/A")
            return 0;

        return long.TryParse(value, NumberStyles.Integer, CultureInfo.InvariantCulture, out var result)
            ? result
            : 0;
    }
}
```

### File: `src/SeniorIntern.Services/Training/Providers/IGpuMetricsProvider.cs`

```csharp
namespace SeniorIntern.Services.Training.Providers;

using SeniorIntern.Core.Training.Models;

/// <summary>
/// Interface for GPU-specific metrics collection.
/// </summary>
public interface IGpuMetricsProvider
{
    /// <summary>
    /// Gets whether this GPU type is available on the system.
    /// </summary>
    bool IsAvailable { get; }

    /// <summary>
    /// Gets the number of available GPU devices.
    /// </summary>
    int DeviceCount { get; }

    /// <summary>
    /// Gets the GPU type this provider handles.
    /// </summary>
    GpuType GpuType { get; }

    /// <summary>
    /// Collect metrics from all available GPUs.
    /// </summary>
    /// <returns>List of GPU metrics for each device.</returns>
    IReadOnlyList<GpuMetrics> CollectMetrics();

    /// <summary>
    /// Collect metrics from a specific GPU device.
    /// </summary>
    /// <param name="deviceIndex">Zero-based device index.</param>
    /// <returns>GPU metrics for the specified device.</returns>
    GpuMetrics CollectMetrics(int deviceIndex);
}
```

---

## v0.8.4d: GPU Metrics Provider - Apple Silicon (Metal)

### Objective
Implement GPU metrics collection for Apple Silicon Macs using Metal Performance Shaders info and system APIs for unified memory tracking.

### File: `src/SeniorIntern.Services/Training/Providers/MetalGpuMetricsProvider.cs`

```csharp
namespace SeniorIntern.Services.Training.Providers;

using System.Diagnostics;
using System.Runtime.InteropServices;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Training.Models;
using TorchSharp;

/// <summary>
/// GPU metrics provider for Apple Silicon Macs using Metal/MPS.
/// </summary>
public sealed class MetalGpuMetricsProvider : IGpuMetricsProvider
{
    private readonly ILogger<MetalGpuMetricsProvider> _logger;
    private readonly bool _isAvailable;
    private readonly string _deviceName;
    private readonly long _unifiedMemoryTotal;

    public MetalGpuMetricsProvider(ILogger<MetalGpuMetricsProvider> logger)
    {
        _logger = logger;

        // Check if running on macOS with MPS support
        if (!OperatingSystem.IsMacOS())
        {
            _isAvailable = false;
            _deviceName = string.Empty;
            _unifiedMemoryTotal = 0;
            return;
        }

        // Check MPS availability via TorchSharp
        try
        {
            _isAvailable = torch.mps.is_available();
        }
        catch
        {
            _isAvailable = false;
        }

        if (_isAvailable)
        {
            _deviceName = GetAppleSiliconChipName();
            _unifiedMemoryTotal = GetUnifiedMemoryTotal();

            _logger.LogInformation(
                "Metal GPU metrics provider initialized: {Device}, {Memory}GB unified memory",
                _deviceName, _unifiedMemoryTotal / (1024 * 1024 * 1024));
        }
        else
        {
            _deviceName = string.Empty;
            _unifiedMemoryTotal = 0;
            _logger.LogInformation("Metal/MPS not available");
        }
    }

    /// <inheritdoc/>
    public bool IsAvailable => _isAvailable;

    /// <inheritdoc/>
    public int DeviceCount => _isAvailable ? 1 : 0;

    /// <inheritdoc/>
    public GpuType GpuType => GpuType.AppleMetal;

    /// <inheritdoc/>
    public IReadOnlyList<GpuMetrics> CollectMetrics()
    {
        if (!_isAvailable)
            return Array.Empty<GpuMetrics>();

        return new[] { CollectMetrics(0) };
    }

    /// <inheritdoc/>
    public GpuMetrics CollectMetrics(int deviceIndex)
    {
        if (!_isAvailable || deviceIndex != 0)
        {
            throw new InvalidOperationException("Metal GPU not available");
        }

        var memoryUsed = GetMetalMemoryUsed();
        var gpuUtilization = GetGpuUtilization();

        return new GpuMetrics
        {
            DeviceIndex = 0,
            DeviceName = _deviceName,
            GpuType = GpuType.AppleMetal,
            Utilization = gpuUtilization,
            MemoryUsed = memoryUsed,
            MemoryTotal = _unifiedMemoryTotal,
            Temperature = GetGpuTemperature(),
            PowerDraw = 0, // Not available on Apple Silicon
            PowerLimit = 0,
            FanSpeed = 0, // Most Macs don't have GPU fans
            MemoryClockMhz = 0,
            GraphicsClockMhz = 0
        };
    }

    private long GetMetalMemoryUsed()
    {
        try
        {
            // Use sysctl to get memory pressure
            var output = ExecuteCommand("sysctl", "hw.memsize vm.page_pageable_internal_count vm.page_purgeable_count");
            // This is approximate since Apple Silicon uses unified memory

            // Get process-specific memory as approximation
            using var process = Process.GetCurrentProcess();
            return process.WorkingSet64;
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Failed to get Metal memory usage");
            return 0;
        }
    }

    private float GetGpuUtilization()
    {
        try
        {
            // Use powermetrics or ioreg to get GPU utilization
            // Note: This requires elevated permissions in most cases
            var output = ExecuteCommand("ioreg", "-r -c AppleARMIODevice -d 1");

            // Parse GPU utilization from output
            // This is a simplified approach; actual parsing would be more complex
            return ParseGpuUtilizationFromIoreg(output);
        }
        catch (Exception ex)
        {
            _logger.LogDebug(ex, "GPU utilization not available (may require elevated permissions)");
            return 0;
        }
    }

    private float GetGpuTemperature()
    {
        try
        {
            // Use powermetrics or SMC to get temperature
            // This typically requires sudo access
            var output = ExecuteCommand("sudo", "powermetrics --samplers smc -n 1 -i 1");
            return ParseTemperatureFromPowermetrics(output);
        }
        catch
        {
            // Temperature monitoring often requires elevated permissions
            return 0;
        }
    }

    private static string GetAppleSiliconChipName()
    {
        try
        {
            var output = ExecuteCommand("sysctl", "-n machdep.cpu.brand_string");
            var chipName = output.Trim();

            if (string.IsNullOrEmpty(chipName))
            {
                // Fallback to checking for Apple Silicon
                output = ExecuteCommand("uname", "-m");
                chipName = output.Trim() == "arm64" ? "Apple Silicon" : "Unknown";
            }

            return chipName;
        }
        catch
        {
            return "Apple Silicon";
        }
    }

    private static long GetUnifiedMemoryTotal()
    {
        try
        {
            var output = ExecuteCommand("sysctl", "-n hw.memsize");
            if (long.TryParse(output.Trim(), out var memsize))
                return memsize;
        }
        catch
        {
            // Ignore
        }

        // Fallback to GC info
        return GC.GetGCMemoryInfo().TotalAvailableMemoryBytes;
    }

    private static string ExecuteCommand(string command, string arguments)
    {
        try
        {
            using var process = new Process
            {
                StartInfo = new ProcessStartInfo
                {
                    FileName = command,
                    Arguments = arguments,
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    UseShellExecute = false,
                    CreateNoWindow = true
                }
            };

            process.Start();
            var output = process.StandardOutput.ReadToEnd();
            process.WaitForExit(timeout: 2000);
            return output;
        }
        catch
        {
            return string.Empty;
        }
    }

    private static float ParseGpuUtilizationFromIoreg(string output)
    {
        // Simplified parsing - actual implementation would parse the IORegistry output
        // Looking for GPU performance state or utilization counters
        return 0; // Return 0 if parsing fails
    }

    private static float ParseTemperatureFromPowermetrics(string output)
    {
        // Parse temperature from powermetrics output
        // Format varies by macOS version
        if (string.IsNullOrEmpty(output))
            return 0;

        // Look for GPU die temperature
        var lines = output.Split('\n');
        foreach (var line in lines)
        {
            if (line.Contains("GPU") && line.Contains("die temperature"))
            {
                // Extract temperature value
                var match = System.Text.RegularExpressions.Regex.Match(line, @"(\d+\.?\d*)\s*C");
                if (match.Success && float.TryParse(match.Groups[1].Value, out var temp))
                    return temp;
            }
        }

        return 0;
    }
}
```

### File: `src/SeniorIntern.Services/Training/Providers/GpuMetricsProviderFactory.cs`

```csharp
namespace SeniorIntern.Services.Training.Providers;

using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Training.Models;

/// <summary>
/// Factory for creating the appropriate GPU metrics provider based on available hardware.
/// </summary>
public sealed class GpuMetricsProviderFactory
{
    private readonly ILoggerFactory _loggerFactory;

    public GpuMetricsProviderFactory(ILoggerFactory loggerFactory)
    {
        _loggerFactory = loggerFactory;
    }

    /// <summary>
    /// Create a GPU metrics provider for the current system.
    /// </summary>
    /// <returns>The appropriate GPU metrics provider, or null if no GPU is available.</returns>
    public IGpuMetricsProvider? CreateProvider()
    {
        // Try NVIDIA first (most common for training)
        var nvidiaProvider = new NvidiaGpuMetricsProvider(
            _loggerFactory.CreateLogger<NvidiaGpuMetricsProvider>());

        if (nvidiaProvider.IsAvailable)
            return nvidiaProvider;

        // Try Apple Silicon Metal
        if (OperatingSystem.IsMacOS())
        {
            var metalProvider = new MetalGpuMetricsProvider(
                _loggerFactory.CreateLogger<MetalGpuMetricsProvider>());

            if (metalProvider.IsAvailable)
                return metalProvider;
        }

        // No GPU available
        return null;
    }

    /// <summary>
    /// Create all available GPU metrics providers.
    /// </summary>
    /// <returns>List of available GPU metrics providers.</returns>
    public IReadOnlyList<IGpuMetricsProvider> CreateAllProviders()
    {
        var providers = new List<IGpuMetricsProvider>();

        var nvidiaProvider = new NvidiaGpuMetricsProvider(
            _loggerFactory.CreateLogger<NvidiaGpuMetricsProvider>());

        if (nvidiaProvider.IsAvailable)
            providers.Add(nvidiaProvider);

        if (OperatingSystem.IsMacOS())
        {
            var metalProvider = new MetalGpuMetricsProvider(
                _loggerFactory.CreateLogger<MetalGpuMetricsProvider>());

            if (metalProvider.IsAvailable)
                providers.Add(metalProvider);
        }

        return providers;
    }

    /// <summary>
    /// Get the device type for the best available GPU.
    /// </summary>
    public DeviceType GetBestDeviceType()
    {
        var provider = CreateProvider();

        return provider?.GpuType switch
        {
            GpuType.NvidiaCuda => DeviceType.Cuda,
            GpuType.AppleMetal => DeviceType.Metal,
            _ => DeviceType.Cpu
        };
    }
}
```

---

## v0.8.4e: CPU Metrics Provider (Cross-Platform)

### Objective
Implement CPU metrics collection for Windows (PDH/WMI), Linux (/proc), and macOS (host_statistics) with per-core utilization tracking.

### File: `src/SeniorIntern.Services/Training/Providers/ICpuMetricsProvider.cs`

```csharp
namespace SeniorIntern.Services.Training.Providers;

using SeniorIntern.Core.Training.Models;

/// <summary>
/// Interface for CPU metrics collection.
/// </summary>
public interface ICpuMetricsProvider
{
    /// <summary>
    /// Collect current CPU metrics.
    /// </summary>
    /// <returns>CPU metrics snapshot.</returns>
    CpuMetrics CollectMetrics();

    /// <summary>
    /// Gets the number of physical CPU cores.
    /// </summary>
    int PhysicalCores { get; }

    /// <summary>
    /// Gets the number of logical processors (threads).
    /// </summary>
    int LogicalProcessors { get; }

    /// <summary>
    /// Gets the CPU model name.
    /// </summary>
    string ModelName { get; }
}
```

### File: `src/SeniorIntern.Services/Training/Providers/CpuMetricsProvider.cs`

```csharp
namespace SeniorIntern.Services.Training.Providers;

using System.Diagnostics;
using System.Globalization;
using System.Runtime.InteropServices;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Training.Models;

/// <summary>
/// Cross-platform CPU metrics provider.
/// </summary>
public sealed class CpuMetricsProvider : ICpuMetricsProvider, IDisposable
{
    private readonly ILogger<CpuMetricsProvider> _logger;
    private readonly string _modelName;
    private readonly int _physicalCores;
    private readonly int _logicalProcessors;

    // For calculating CPU usage over time
    private DateTime _lastSampleTime = DateTime.MinValue;
    private TimeSpan _lastTotalProcessorTime = TimeSpan.Zero;
    private long[]? _lastPerCoreIdleTime;
    private long[]? _lastPerCoreTotalTime;

    // Platform-specific helpers
    private readonly IPlatformCpuHelper _platformHelper;

    public CpuMetricsProvider(ILogger<CpuMetricsProvider> logger)
    {
        _logger = logger;
        _logicalProcessors = Environment.ProcessorCount;

        // Create platform-specific helper
        _platformHelper = CreatePlatformHelper();

        _modelName = _platformHelper.GetCpuModelName();
        _physicalCores = _platformHelper.GetPhysicalCoreCount();

        _logger.LogInformation(
            "CPU metrics provider initialized: {Model}, {Physical} physical cores, {Logical} logical processors",
            _modelName, _physicalCores, _logicalProcessors);
    }

    /// <inheritdoc/>
    public int PhysicalCores => _physicalCores;

    /// <inheritdoc/>
    public int LogicalProcessors => _logicalProcessors;

    /// <inheritdoc/>
    public string ModelName => _modelName;

    /// <inheritdoc/>
    public CpuMetrics CollectMetrics()
    {
        var currentProcess = Process.GetCurrentProcess();
        var now = DateTime.UtcNow;

        // Calculate process CPU utilization
        var processUtilization = CalculateProcessCpuUtilization(currentProcess, now);

        // Get total and per-core utilization
        var (totalUtilization, perCoreUtilization) = _platformHelper.GetCpuUtilization();

        // Get frequency info
        var (currentFreq, maxFreq) = _platformHelper.GetCpuFrequency();

        // Get temperature (if available)
        var temperature = _platformHelper.GetCpuTemperature();

        return new CpuMetrics
        {
            ModelName = _modelName,
            PhysicalCores = _physicalCores,
            LogicalProcessors = _logicalProcessors,
            TotalUtilization = totalUtilization,
            PerCoreUtilization = perCoreUtilization,
            ProcessUtilization = processUtilization,
            CurrentFrequencyMhz = currentFreq,
            MaxFrequencyMhz = maxFreq,
            Temperature = temperature,
            ProcessThreadCount = currentProcess.Threads.Count
        };
    }

    private float CalculateProcessCpuUtilization(Process process, DateTime now)
    {
        if (_lastSampleTime == DateTime.MinValue)
        {
            _lastSampleTime = now;
            _lastTotalProcessorTime = process.TotalProcessorTime;
            return 0;
        }

        var elapsedTime = now - _lastSampleTime;
        var elapsedCpuTime = process.TotalProcessorTime - _lastTotalProcessorTime;

        _lastSampleTime = now;
        _lastTotalProcessorTime = process.TotalProcessorTime;

        if (elapsedTime.TotalMilliseconds <= 0)
            return 0;

        // CPU utilization = (CPU time used / wall clock time) / number of processors * 100
        var utilization = (float)(elapsedCpuTime.TotalMilliseconds /
                                   elapsedTime.TotalMilliseconds /
                                   _logicalProcessors * 100);

        return Math.Clamp(utilization, 0, 100);
    }

    private IPlatformCpuHelper CreatePlatformHelper()
    {
        if (OperatingSystem.IsWindows())
            return new WindowsCpuHelper(_logger);
        else if (OperatingSystem.IsLinux())
            return new LinuxCpuHelper(_logger);
        else if (OperatingSystem.IsMacOS())
            return new MacOsCpuHelper(_logger);
        else
            return new FallbackCpuHelper(_logger);
    }

    public void Dispose()
    {
        _platformHelper.Dispose();
    }
}

/// <summary>
/// Platform-specific CPU metrics helper interface.
/// </summary>
internal interface IPlatformCpuHelper : IDisposable
{
    string GetCpuModelName();
    int GetPhysicalCoreCount();
    (float total, IReadOnlyList<float> perCore) GetCpuUtilization();
    (int current, int max) GetCpuFrequency();
    float GetCpuTemperature();
}

/// <summary>
/// Windows-specific CPU metrics using Performance Counters.
/// </summary>
internal sealed class WindowsCpuHelper : IPlatformCpuHelper
{
    private readonly ILogger _logger;
    private PerformanceCounter? _cpuCounter;
    private PerformanceCounter[]? _perCoreCounters;

    public WindowsCpuHelper(ILogger logger)
    {
        _logger = logger;
        InitializeCounters();
    }

    private void InitializeCounters()
    {
        try
        {
            _cpuCounter = new PerformanceCounter("Processor", "% Processor Time", "_Total");
            _cpuCounter.NextValue(); // First call always returns 0

            var coreCount = Environment.ProcessorCount;
            _perCoreCounters = new PerformanceCounter[coreCount];

            for (int i = 0; i < coreCount; i++)
            {
                _perCoreCounters[i] = new PerformanceCounter("Processor", "% Processor Time", i.ToString());
                _perCoreCounters[i].NextValue();
            }
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Failed to initialize Windows performance counters");
        }
    }

    public string GetCpuModelName()
    {
        try
        {
            // Use WMI to get CPU name
            var output = ExecuteCommand("wmic", "cpu get name /value");
            var match = System.Text.RegularExpressions.Regex.Match(output, @"Name=(.+)");
            if (match.Success)
                return match.Groups[1].Value.Trim();
        }
        catch (Exception ex)
        {
            _logger.LogDebug(ex, "Failed to get CPU model name from WMI");
        }

        return "Unknown CPU";
    }

    public int GetPhysicalCoreCount()
    {
        try
        {
            var output = ExecuteCommand("wmic", "cpu get NumberOfCores /value");
            var match = System.Text.RegularExpressions.Regex.Match(output, @"NumberOfCores=(\d+)");
            if (match.Success && int.TryParse(match.Groups[1].Value, out var cores))
                return cores;
        }
        catch (Exception ex)
        {
            _logger.LogDebug(ex, "Failed to get physical core count from WMI");
        }

        return Environment.ProcessorCount / 2; // Assume hyperthreading
    }

    public (float total, IReadOnlyList<float> perCore) GetCpuUtilization()
    {
        var perCore = new List<float>();
        float total = 0;

        try
        {
            if (_cpuCounter != null)
            {
                total = _cpuCounter.NextValue();
            }

            if (_perCoreCounters != null)
            {
                foreach (var counter in _perCoreCounters)
                {
                    perCore.Add(counter.NextValue());
                }
            }
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Failed to read CPU performance counters");
        }

        return (total, perCore);
    }

    public (int current, int max) GetCpuFrequency()
    {
        try
        {
            var output = ExecuteCommand("wmic", "cpu get CurrentClockSpeed,MaxClockSpeed /value");

            var currentMatch = System.Text.RegularExpressions.Regex.Match(output, @"CurrentClockSpeed=(\d+)");
            var maxMatch = System.Text.RegularExpressions.Regex.Match(output, @"MaxClockSpeed=(\d+)");

            int current = currentMatch.Success && int.TryParse(currentMatch.Groups[1].Value, out var c) ? c : 0;
            int max = maxMatch.Success && int.TryParse(maxMatch.Groups[1].Value, out var m) ? m : 0;

            return (current, max);
        }
        catch
        {
            return (0, 0);
        }
    }

    public float GetCpuTemperature()
    {
        // Windows temperature monitoring requires WMI with specific hardware support
        // or third-party libraries like OpenHardwareMonitor
        return 0;
    }

    public void Dispose()
    {
        _cpuCounter?.Dispose();
        if (_perCoreCounters != null)
        {
            foreach (var counter in _perCoreCounters)
            {
                counter?.Dispose();
            }
        }
    }

    private static string ExecuteCommand(string command, string arguments)
    {
        try
        {
            using var process = new Process
            {
                StartInfo = new ProcessStartInfo
                {
                    FileName = command,
                    Arguments = arguments,
                    RedirectStandardOutput = true,
                    UseShellExecute = false,
                    CreateNoWindow = true
                }
            };

            process.Start();
            var output = process.StandardOutput.ReadToEnd();
            process.WaitForExit(timeout: 2000);
            return output;
        }
        catch
        {
            return string.Empty;
        }
    }
}

/// <summary>
/// Linux-specific CPU metrics using /proc filesystem.
/// </summary>
internal sealed class LinuxCpuHelper : IPlatformCpuHelper
{
    private readonly ILogger _logger;
    private long[]? _lastIdleTimes;
    private long[]? _lastTotalTimes;
    private DateTime _lastSampleTime = DateTime.MinValue;

    public LinuxCpuHelper(ILogger logger)
    {
        _logger = logger;
    }

    public string GetCpuModelName()
    {
        try
        {
            var cpuInfo = File.ReadAllText("/proc/cpuinfo");
            var match = System.Text.RegularExpressions.Regex.Match(cpuInfo, @"model name\s*:\s*(.+)");
            if (match.Success)
                return match.Groups[1].Value.Trim();
        }
        catch (Exception ex)
        {
            _logger.LogDebug(ex, "Failed to read CPU model from /proc/cpuinfo");
        }

        return "Unknown CPU";
    }

    public int GetPhysicalCoreCount()
    {
        try
        {
            var cpuInfo = File.ReadAllText("/proc/cpuinfo");
            var matches = System.Text.RegularExpressions.Regex.Matches(cpuInfo, @"core id\s*:\s*(\d+)");

            var uniqueCores = matches.Select(m => int.Parse(m.Groups[1].Value)).Distinct().Count();
            return uniqueCores > 0 ? uniqueCores : Environment.ProcessorCount;
        }
        catch (Exception ex)
        {
            _logger.LogDebug(ex, "Failed to get physical core count from /proc/cpuinfo");
        }

        return Environment.ProcessorCount;
    }

    public (float total, IReadOnlyList<float> perCore) GetCpuUtilization()
    {
        try
        {
            var lines = File.ReadAllLines("/proc/stat")
                .Where(l => l.StartsWith("cpu"))
                .ToArray();

            var perCore = new List<float>();
            float total = 0;

            foreach (var line in lines)
            {
                var parts = line.Split(' ', StringSplitOptions.RemoveEmptyEntries);
                if (parts.Length < 5) continue;

                var name = parts[0];
                var values = parts.Skip(1).Select(long.Parse).ToArray();

                var idle = values[3]; // idle time
                var totalTime = values.Sum();

                if (name == "cpu")
                {
                    total = CalculateUtilization(0, idle, totalTime, isTotal: true);
                }
                else if (name.StartsWith("cpu") && int.TryParse(name.Substring(3), out var coreIndex))
                {
                    perCore.Add(CalculateUtilization(coreIndex + 1, idle, totalTime, isTotal: false));
                }
            }

            return (total, perCore);
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Failed to read CPU stats from /proc/stat");
            return (0, Array.Empty<float>());
        }
    }

    private float CalculateUtilization(int index, long idle, long total, bool isTotal)
    {
        if (_lastIdleTimes == null || _lastTotalTimes == null)
        {
            var size = Environment.ProcessorCount + 1;
            _lastIdleTimes = new long[size];
            _lastTotalTimes = new long[size];
        }

        var lastIdle = _lastIdleTimes[index];
        var lastTotal = _lastTotalTimes[index];

        _lastIdleTimes[index] = idle;
        _lastTotalTimes[index] = total;

        var idleDelta = idle - lastIdle;
        var totalDelta = total - lastTotal;

        if (totalDelta == 0) return 0;

        return (1.0f - (float)idleDelta / totalDelta) * 100f;
    }

    public (int current, int max) GetCpuFrequency()
    {
        try
        {
            int current = 0;
            int max = 0;

            var currentPath = "/sys/devices/system/cpu/cpu0/cpufreq/scaling_cur_freq";
            var maxPath = "/sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq";

            if (File.Exists(currentPath))
            {
                var freq = File.ReadAllText(currentPath).Trim();
                if (int.TryParse(freq, out var kHz))
                    current = kHz / 1000; // Convert kHz to MHz
            }

            if (File.Exists(maxPath))
            {
                var freq = File.ReadAllText(maxPath).Trim();
                if (int.TryParse(freq, out var kHz))
                    max = kHz / 1000;
            }

            return (current, max);
        }
        catch
        {
            return (0, 0);
        }
    }

    public float GetCpuTemperature()
    {
        try
        {
            // Try various thermal zone paths
            var paths = new[]
            {
                "/sys/class/thermal/thermal_zone0/temp",
                "/sys/devices/platform/coretemp.0/hwmon/hwmon2/temp1_input"
            };

            foreach (var path in paths)
            {
                if (File.Exists(path))
                {
                    var temp = File.ReadAllText(path).Trim();
                    if (int.TryParse(temp, out var milliCelsius))
                        return milliCelsius / 1000f;
                }
            }
        }
        catch
        {
            // Ignore
        }

        return 0;
    }

    public void Dispose() { }
}

/// <summary>
/// macOS-specific CPU metrics using system calls.
/// </summary>
internal sealed class MacOsCpuHelper : IPlatformCpuHelper
{
    private readonly ILogger _logger;

    public MacOsCpuHelper(ILogger logger)
    {
        _logger = logger;
    }

    public string GetCpuModelName()
    {
        try
        {
            return ExecuteCommand("sysctl", "-n machdep.cpu.brand_string").Trim();
        }
        catch
        {
            return "Apple CPU";
        }
    }

    public int GetPhysicalCoreCount()
    {
        try
        {
            var output = ExecuteCommand("sysctl", "-n hw.physicalcpu");
            if (int.TryParse(output.Trim(), out var cores))
                return cores;
        }
        catch
        {
            // Ignore
        }

        return Environment.ProcessorCount;
    }

    public (float total, IReadOnlyList<float> perCore) GetCpuUtilization()
    {
        try
        {
            // Use top command for CPU usage
            var output = ExecuteCommand("top", "-l 1 -n 0 -s 0");
            var match = System.Text.RegularExpressions.Regex.Match(
                output,
                @"CPU usage:\s+([\d.]+)%\s+user,\s+([\d.]+)%\s+sys");

            if (match.Success)
            {
                var user = float.Parse(match.Groups[1].Value, CultureInfo.InvariantCulture);
                var sys = float.Parse(match.Groups[2].Value, CultureInfo.InvariantCulture);
                return (user + sys, Array.Empty<float>());
            }
        }
        catch (Exception ex)
        {
            _logger.LogDebug(ex, "Failed to get CPU utilization on macOS");
        }

        return (0, Array.Empty<float>());
    }

    public (int current, int max) GetCpuFrequency()
    {
        // macOS doesn't expose CPU frequency in the same way
        return (0, 0);
    }

    public float GetCpuTemperature()
    {
        // Requires elevated permissions or specific tools
        return 0;
    }

    private static string ExecuteCommand(string command, string arguments)
    {
        try
        {
            using var process = new Process
            {
                StartInfo = new ProcessStartInfo
                {
                    FileName = command,
                    Arguments = arguments,
                    RedirectStandardOutput = true,
                    UseShellExecute = false,
                    CreateNoWindow = true
                }
            };

            process.Start();
            var output = process.StandardOutput.ReadToEnd();
            process.WaitForExit(timeout: 2000);
            return output;
        }
        catch
        {
            return string.Empty;
        }
    }

    public void Dispose() { }
}

/// <summary>
/// Fallback CPU helper for unsupported platforms.
/// </summary>
internal sealed class FallbackCpuHelper : IPlatformCpuHelper
{
    private readonly ILogger _logger;

    public FallbackCpuHelper(ILogger logger)
    {
        _logger = logger;
        _logger.LogWarning("Using fallback CPU metrics provider - limited functionality");
    }

    public string GetCpuModelName() => "Unknown CPU";
    public int GetPhysicalCoreCount() => Environment.ProcessorCount;
    public (float total, IReadOnlyList<float> perCore) GetCpuUtilization() => (0, Array.Empty<float>());
    public (int current, int max) GetCpuFrequency() => (0, 0);
    public float GetCpuTemperature() => 0;
    public void Dispose() { }
}
```

### File: `src/SeniorIntern.Services/Training/Providers/CpuMetricsProviderFactory.cs`

```csharp
namespace SeniorIntern.Services.Training.Providers;

using Microsoft.Extensions.Logging;

/// <summary>
/// Factory for creating CPU metrics providers.
/// </summary>
public sealed class CpuMetricsProviderFactory
{
    private readonly ILoggerFactory _loggerFactory;

    public CpuMetricsProviderFactory(ILoggerFactory loggerFactory)
    {
        _loggerFactory = loggerFactory;
    }

    /// <summary>
    /// Create a CPU metrics provider for the current platform.
    /// </summary>
    public ICpuMetricsProvider CreateProvider()
    {
        return new CpuMetricsProvider(_loggerFactory.CreateLogger<CpuMetricsProvider>());
    }
}
```

---

## v0.8.4f: Memory Metrics Provider

### Objective
Implement memory metrics collection for system RAM, GPU VRAM, and .NET managed heap with garbage collection statistics.

### File: `src/SeniorIntern.Services/Training/Providers/IMemoryMetricsProvider.cs`

```csharp
namespace SeniorIntern.Services.Training.Providers;

using SeniorIntern.Core.Training.Models;

/// <summary>
/// Interface for memory metrics collection.
/// </summary>
public interface IMemoryMetricsProvider
{
    /// <summary>
    /// Collect current memory metrics.
    /// </summary>
    /// <returns>Memory metrics snapshot.</returns>
    MemoryMetrics CollectMetrics();

    /// <summary>
    /// Gets the total system RAM in bytes.
    /// </summary>
    long TotalSystemRam { get; }

    /// <summary>
    /// Force a garbage collection and return updated metrics.
    /// </summary>
    /// <param name="generation">GC generation to collect (0-2), or -1 for all.</param>
    /// <returns>Updated memory metrics after collection.</returns>
    MemoryMetrics ForceGarbageCollection(int generation = -1);
}
```

### File: `src/SeniorIntern.Services/Training/Providers/MemoryMetricsProvider.cs`

```csharp
namespace SeniorIntern.Services.Training.Providers;

using System.Diagnostics;
using System.Runtime;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Training.Models;

/// <summary>
/// Cross-platform memory metrics provider.
/// </summary>
public sealed class MemoryMetricsProvider : IMemoryMetricsProvider
{
    private readonly ILogger<MemoryMetricsProvider> _logger;
    private readonly long _totalSystemRam;
    private int _lastGen0Collections;
    private int _lastGen1Collections;
    private int _lastGen2Collections;

    public MemoryMetricsProvider(ILogger<MemoryMetricsProvider> logger)
    {
        _logger = logger;
        _totalSystemRam = GetTotalPhysicalMemory();

        // Initialize GC collection counters
        _lastGen0Collections = GC.CollectionCount(0);
        _lastGen1Collections = GC.CollectionCount(1);
        _lastGen2Collections = GC.CollectionCount(2);

        _logger.LogInformation(
            "Memory metrics provider initialized: {TotalRam}GB system RAM",
            _totalSystemRam / (1024 * 1024 * 1024));
    }

    /// <inheritdoc/>
    public long TotalSystemRam => _totalSystemRam;

    /// <inheritdoc/>
    public MemoryMetrics CollectMetrics()
    {
        var process = Process.GetCurrentProcess();
        var gcInfo = GC.GetGCMemoryInfo();

        // Get system memory info
        var (usedRam, availableRam) = GetSystemMemoryUsage();

        return new MemoryMetrics
        {
            TotalBytes = _totalSystemRam,
            UsedBytes = usedRam,
            ProcessWorkingSet = process.WorkingSet64,
            ProcessPrivateMemory = process.PrivateMemorySize64,
            ManagedHeapSize = GC.GetTotalMemory(forceFullCollection: false),
            GcTotalAllocated = GC.GetTotalAllocatedBytes(precise: false),
            GcGen0Collections = GC.CollectionCount(0),
            GcGen1Collections = GC.CollectionCount(1),
            GcGen2Collections = GC.CollectionCount(2),
            VirtualMemoryCommitted = process.VirtualMemorySize64,
            PageFileUsage = GetPageFileUsage(process)
        };
    }

    /// <inheritdoc/>
    public MemoryMetrics ForceGarbageCollection(int generation = -1)
    {
        if (generation < 0)
        {
            GC.Collect();
        }
        else
        {
            GC.Collect(Math.Min(generation, 2));
        }

        GC.WaitForPendingFinalizers();

        return CollectMetrics();
    }

    private static long GetTotalPhysicalMemory()
    {
        try
        {
            var gcInfo = GC.GetGCMemoryInfo();
            return gcInfo.TotalAvailableMemoryBytes;
        }
        catch
        {
            // Fallback: assume 8GB
            return 8L * 1024 * 1024 * 1024;
        }
    }

    private (long used, long available) GetSystemMemoryUsage()
    {
        try
        {
            if (OperatingSystem.IsWindows())
            {
                return GetWindowsMemoryUsage();
            }
            else if (OperatingSystem.IsLinux())
            {
                return GetLinuxMemoryUsage();
            }
            else if (OperatingSystem.IsMacOS())
            {
                return GetMacOsMemoryUsage();
            }
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Failed to get system memory usage");
        }

        // Fallback to process-based estimate
        var process = Process.GetCurrentProcess();
        return (process.WorkingSet64, _totalSystemRam - process.WorkingSet64);
    }

    private (long used, long available) GetWindowsMemoryUsage()
    {
        // Use GlobalMemoryStatusEx via P/Invoke or rely on GC info
        var gcInfo = GC.GetGCMemoryInfo();
        var total = gcInfo.TotalAvailableMemoryBytes;

        // Estimate used memory based on process memory and a factor
        var process = Process.GetCurrentProcess();
        var estimatedUsed = total - (total / 4); // Rough estimate

        return (estimatedUsed, total - estimatedUsed);
    }

    private (long used, long available) GetLinuxMemoryUsage()
    {
        try
        {
            var memInfo = File.ReadAllLines("/proc/meminfo");
            long total = 0, available = 0;

            foreach (var line in memInfo)
            {
                if (line.StartsWith("MemTotal:"))
                {
                    var value = ParseMemInfoValue(line);
                    total = value * 1024; // Convert KB to bytes
                }
                else if (line.StartsWith("MemAvailable:"))
                {
                    var value = ParseMemInfoValue(line);
                    available = value * 1024;
                }
            }

            return (total - available, available);
        }
        catch
        {
            return (0, _totalSystemRam);
        }
    }

    private (long used, long available) GetMacOsMemoryUsage()
    {
        try
        {
            // Use vm_stat command
            using var process = new Process
            {
                StartInfo = new ProcessStartInfo
                {
                    FileName = "vm_stat",
                    RedirectStandardOutput = true,
                    UseShellExecute = false,
                    CreateNoWindow = true
                }
            };

            process.Start();
            var output = process.StandardOutput.ReadToEnd();
            process.WaitForExit(timeout: 2000);

            // Parse vm_stat output
            var pageSize = 16384L; // Default page size on Apple Silicon
            long freePages = 0, activePages = 0, inactivePages = 0, wiredPages = 0;

            foreach (var line in output.Split('\n'))
            {
                if (line.Contains("page size of"))
                {
                    var match = System.Text.RegularExpressions.Regex.Match(line, @"(\d+)");
                    if (match.Success && long.TryParse(match.Value, out var size))
                        pageSize = size;
                }
                else if (line.StartsWith("Pages free:"))
                {
                    freePages = ParseVmStatValue(line);
                }
                else if (line.StartsWith("Pages active:"))
                {
                    activePages = ParseVmStatValue(line);
                }
                else if (line.StartsWith("Pages inactive:"))
                {
                    inactivePages = ParseVmStatValue(line);
                }
                else if (line.StartsWith("Pages wired down:"))
                {
                    wiredPages = ParseVmStatValue(line);
                }
            }

            var used = (activePages + wiredPages) * pageSize;
            var available = (freePages + inactivePages) * pageSize;

            return (used, available);
        }
        catch
        {
            return (0, _totalSystemRam);
        }
    }

    private static long ParseMemInfoValue(string line)
    {
        var match = System.Text.RegularExpressions.Regex.Match(line, @"(\d+)");
        return match.Success && long.TryParse(match.Value, out var value) ? value : 0;
    }

    private static long ParseVmStatValue(string line)
    {
        var match = System.Text.RegularExpressions.Regex.Match(line, @"(\d+)");
        return match.Success && long.TryParse(match.Value, out var value) ? value : 0;
    }

    private static long GetPageFileUsage(Process process)
    {
        try
        {
            return process.PagedMemorySize64;
        }
        catch
        {
            return 0;
        }
    }
}
```

---

## v0.8.4g: Hardware Monitor Service Implementation

### Objective
Implement the main hardware monitoring service that coordinates all providers, manages history, and dispatches events to subscribers.

### File: `src/SeniorIntern.Services/Training/HardwareMonitorService.cs`

```csharp
namespace SeniorIntern.Services.Training;

using System.Collections.Concurrent;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Training.Models;
using SeniorIntern.Services.Training.Providers;

/// <summary>
/// Real-time hardware monitoring service for training operations.
/// </summary>
public sealed class HardwareMonitorService : IHardwareMonitorService
{
    private readonly ILogger<HardwareMonitorService> _logger;
    private readonly IGpuMetricsProvider? _gpuProvider;
    private readonly ICpuMetricsProvider _cpuProvider;
    private readonly IMemoryMetricsProvider _memoryProvider;
    private readonly ConcurrentQueue<TimestampedMetrics> _history;
    private readonly object _lock = new();

    private Timer? _timer;
    private int _maxHistorySize = 3600; // Default: 1 hour at 1-second intervals
    private TimeSpan _monitoringInterval = TimeSpan.FromSeconds(1);
    private DateTime _lastCollectionTime = DateTime.MinValue;
    private HardwareMetrics? _lastMetrics;

    // Alert thresholds
    private float _gpuTempWarningThreshold = 80f;
    private float _gpuTempCriticalThreshold = 90f;
    private float _cpuTempWarningThreshold = 85f;
    private float _cpuTempCriticalThreshold = 95f;
    private float _memoryWarningThreshold = 85f;
    private float _memoryCriticalThreshold = 95f;

    /// <inheritdoc/>
    public event EventHandler<HardwareMetricsEventArgs>? MetricsUpdated;

    /// <inheritdoc/>
    public event EventHandler<ThermalAlertEventArgs>? ThermalAlert;

    /// <inheritdoc/>
    public event EventHandler<MemoryAlertEventArgs>? MemoryAlert;

    public HardwareMonitorService(
        ILogger<HardwareMonitorService> logger,
        GpuMetricsProviderFactory gpuFactory,
        CpuMetricsProviderFactory cpuFactory,
        IMemoryMetricsProvider memoryProvider)
    {
        _logger = logger;
        _gpuProvider = gpuFactory.CreateProvider();
        _cpuProvider = cpuFactory.CreateProvider();
        _memoryProvider = memoryProvider;
        _history = new ConcurrentQueue<TimestampedMetrics>();

        _logger.LogInformation(
            "Hardware monitor service initialized. GPU: {GpuAvailable}, CPU: {CpuCores} cores",
            _gpuProvider?.IsAvailable ?? false,
            _cpuProvider.LogicalProcessors);
    }

    /// <inheritdoc/>
    public bool IsMonitoring { get; private set; }

    /// <inheritdoc/>
    public TimeSpan MonitoringInterval => _monitoringInterval;

    /// <inheritdoc/>
    public void StartMonitoring(TimeSpan? interval = null)
    {
        lock (_lock)
        {
            if (IsMonitoring)
            {
                _logger.LogWarning("Monitoring already active");
                return;
            }

            _monitoringInterval = interval ?? TimeSpan.FromSeconds(1);

            // Enforce minimum interval of 100ms
            if (_monitoringInterval < TimeSpan.FromMilliseconds(100))
            {
                _monitoringInterval = TimeSpan.FromMilliseconds(100);
                _logger.LogWarning("Monitoring interval clamped to minimum 100ms");
            }

            _timer = new Timer(
                OnTimerCallback,
                null,
                TimeSpan.Zero,
                _monitoringInterval);

            IsMonitoring = true;
            _logger.LogInformation("Hardware monitoring started with interval: {Interval}ms",
                _monitoringInterval.TotalMilliseconds);
        }
    }

    /// <inheritdoc/>
    public void StopMonitoring()
    {
        lock (_lock)
        {
            if (!IsMonitoring)
                return;

            _timer?.Dispose();
            _timer = null;
            IsMonitoring = false;

            _logger.LogInformation("Hardware monitoring stopped");
        }
    }

    /// <inheritdoc/>
    public HardwareMetrics GetCurrentMetrics()
    {
        return CollectMetricsInternal();
    }

    /// <inheritdoc/>
    public HardwareMetrics? GetLastMetrics()
    {
        return _lastMetrics;
    }

    /// <inheritdoc/>
    public IReadOnlyList<TimestampedMetrics> GetHistory(TimeSpan duration)
    {
        var cutoff = DateTime.UtcNow - duration;
        return _history
            .Where(m => m.Timestamp >= cutoff)
            .OrderBy(m => m.Timestamp)
            .ToList();
    }

    /// <inheritdoc/>
    public IReadOnlyList<TimestampedMetrics> GetFullHistory()
    {
        return _history.OrderBy(m => m.Timestamp).ToList();
    }

    /// <inheritdoc/>
    public void ClearHistory()
    {
        while (_history.TryDequeue(out _)) { }
        _logger.LogInformation("Metrics history cleared");
    }

    /// <inheritdoc/>
    public MetricsStatistics GetStatistics(TimeSpan duration)
    {
        var history = GetHistory(duration);
        return CalculateStatistics(history);
    }

    /// <inheritdoc/>
    public void SetMaxHistorySize(int maxSize)
    {
        if (maxSize < 10)
            throw new ArgumentOutOfRangeException(nameof(maxSize), "Max history size must be at least 10");

        _maxHistorySize = maxSize;
        TrimHistory();

        _logger.LogInformation("Max history size set to {Size}", maxSize);
    }

    private void OnTimerCallback(object? state)
    {
        try
        {
            var metrics = CollectMetricsInternal();
            var now = DateTime.UtcNow;
            var timeSinceLastCollection = _lastCollectionTime == DateTime.MinValue
                ? TimeSpan.Zero
                : now - _lastCollectionTime;

            var timestamped = new TimestampedMetrics
            {
                Timestamp = now,
                Metrics = metrics
            };

            _history.Enqueue(timestamped);
            TrimHistory();

            _lastMetrics = metrics;
            _lastCollectionTime = now;

            // Dispatch metrics event
            MetricsUpdated?.Invoke(this, new HardwareMetricsEventArgs
            {
                Metrics = metrics,
                TimeSinceLastCollection = timeSinceLastCollection
            });

            // Check for alerts
            CheckThermalAlerts(metrics);
            CheckMemoryAlerts(metrics);
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Failed to collect hardware metrics");
        }
    }

    private HardwareMetrics CollectMetricsInternal()
    {
        var gpuMetrics = _gpuProvider?.CollectMetrics() ?? Array.Empty<GpuMetrics>();
        var cpuMetrics = _cpuProvider.CollectMetrics();
        var memoryMetrics = _memoryProvider.CollectMetrics();

        var deviceType = _gpuProvider?.GpuType switch
        {
            GpuType.NvidiaCuda => DeviceType.Cuda,
            GpuType.AppleMetal => DeviceType.Metal,
            _ => DeviceType.Cpu
        };

        return new HardwareMetrics
        {
            Timestamp = DateTime.UtcNow,
            GpuMetrics = gpuMetrics,
            CpuMetrics = cpuMetrics,
            MemoryMetrics = memoryMetrics,
            ActiveDevice = deviceType,
            IsMonitoring = IsMonitoring
        };
    }

    private void TrimHistory()
    {
        while (_history.Count > _maxHistorySize)
        {
            _history.TryDequeue(out _);
        }
    }

    private void CheckThermalAlerts(HardwareMetrics metrics)
    {
        // Check GPU temperatures
        foreach (var gpu in metrics.GpuMetrics)
        {
            if (gpu.Temperature >= _gpuTempCriticalThreshold)
            {
                RaiseThermalAlert(ThermalComponent.Gpu, gpu.Temperature,
                    _gpuTempCriticalThreshold, AlertSeverity.Critical, gpu.DeviceIndex);
            }
            else if (gpu.Temperature >= _gpuTempWarningThreshold)
            {
                RaiseThermalAlert(ThermalComponent.Gpu, gpu.Temperature,
                    _gpuTempWarningThreshold, AlertSeverity.Warning, gpu.DeviceIndex);
            }
        }

        // Check CPU temperature
        if (metrics.CpuMetrics.Temperature >= _cpuTempCriticalThreshold)
        {
            RaiseThermalAlert(ThermalComponent.Cpu, metrics.CpuMetrics.Temperature,
                _cpuTempCriticalThreshold, AlertSeverity.Critical, null);
        }
        else if (metrics.CpuMetrics.Temperature >= _cpuTempWarningThreshold)
        {
            RaiseThermalAlert(ThermalComponent.Cpu, metrics.CpuMetrics.Temperature,
                _cpuTempWarningThreshold, AlertSeverity.Warning, null);
        }
    }

    private void CheckMemoryAlerts(HardwareMetrics metrics)
    {
        // Check GPU memory
        foreach (var gpu in metrics.GpuMetrics)
        {
            var utilization = gpu.MemoryUtilization;
            if (utilization >= _memoryCriticalThreshold)
            {
                RaiseMemoryAlert(MemoryType.GpuVram, gpu.MemoryUsed, gpu.MemoryTotal,
                    utilization, _memoryCriticalThreshold, AlertSeverity.Critical, gpu.DeviceIndex);
            }
            else if (utilization >= _memoryWarningThreshold)
            {
                RaiseMemoryAlert(MemoryType.GpuVram, gpu.MemoryUsed, gpu.MemoryTotal,
                    utilization, _memoryWarningThreshold, AlertSeverity.Warning, gpu.DeviceIndex);
            }
        }

        // Check system RAM
        var ramUtilization = metrics.MemoryMetrics.Utilization;
        if (ramUtilization >= _memoryCriticalThreshold)
        {
            RaiseMemoryAlert(MemoryType.SystemRam, metrics.MemoryMetrics.UsedBytes,
                metrics.MemoryMetrics.TotalBytes, ramUtilization,
                _memoryCriticalThreshold, AlertSeverity.Critical, null);
        }
        else if (ramUtilization >= _memoryWarningThreshold)
        {
            RaiseMemoryAlert(MemoryType.SystemRam, metrics.MemoryMetrics.UsedBytes,
                metrics.MemoryMetrics.TotalBytes, ramUtilization,
                _memoryWarningThreshold, AlertSeverity.Warning, null);
        }
    }

    private void RaiseThermalAlert(ThermalComponent component, float current,
        float threshold, AlertSeverity severity, int? deviceIndex)
    {
        ThermalAlert?.Invoke(this, new ThermalAlertEventArgs
        {
            Component = component,
            CurrentTemperature = current,
            ThresholdTemperature = threshold,
            Severity = severity,
            DeviceIndex = deviceIndex
        });

        _logger.LogWarning(
            "Thermal alert: {Component} temperature {Current}°C exceeds {Severity} threshold {Threshold}°C",
            component, current, severity, threshold);
    }

    private void RaiseMemoryAlert(MemoryType memoryType, long current, long total,
        float utilization, float threshold, AlertSeverity severity, int? deviceIndex)
    {
        MemoryAlert?.Invoke(this, new MemoryAlertEventArgs
        {
            MemoryType = memoryType,
            CurrentUsage = current,
            TotalCapacity = total,
            UsagePercentage = utilization,
            ThresholdPercentage = threshold,
            Severity = severity,
            DeviceIndex = deviceIndex
        });

        _logger.LogWarning(
            "Memory alert: {Type} usage {Utilization:F1}% exceeds {Severity} threshold {Threshold}%",
            memoryType, utilization, severity, threshold);
    }

    private static MetricsStatistics CalculateStatistics(IReadOnlyList<TimestampedMetrics> history)
    {
        if (history.Count == 0)
        {
            return new MetricsStatistics
            {
                PeriodStart = DateTime.UtcNow,
                PeriodEnd = DateTime.UtcNow,
                SampleCount = 0
            };
        }

        var gpuUtils = history.Select(m => m.Metrics.GpuUtilization).ToList();
        var gpuMems = history.Select(m => (float)m.Metrics.GpuMemoryUsed).ToList();
        var gpuTemps = history.Select(m => m.Metrics.GpuTemperature).ToList();
        var cpuUtils = history.Select(m => m.Metrics.CpuUtilization).ToList();
        var ramUsages = history.Select(m => (float)m.Metrics.RamUsed).ToList();

        return new MetricsStatistics
        {
            PeriodStart = history.First().Timestamp,
            PeriodEnd = history.Last().Timestamp,
            SampleCount = history.Count,
            GpuUtilization = CalculateComponentStats(gpuUtils),
            GpuMemory = CalculateComponentStats(gpuMems),
            GpuTemperature = CalculateComponentStats(gpuTemps),
            CpuUtilization = CalculateComponentStats(cpuUtils),
            RamUsage = CalculateComponentStats(ramUsages),
            PeakGpuMemory = (long)gpuMems.DefaultIfEmpty(0).Max(),
            PeakRamUsage = (long)ramUsages.DefaultIfEmpty(0).Max(),
            MaxGpuTemperature = gpuTemps.DefaultIfEmpty(0).Max(),
            ThermalThrottlingDetected = gpuTemps.Any(t => t > 90),
            OutOfMemoryEvents = 0 // Would need to track OOM exceptions
        };
    }

    private static ComponentStatistics CalculateComponentStats(List<float> values)
    {
        if (values.Count == 0)
            return new ComponentStatistics();

        var sorted = values.OrderBy(v => v).ToList();
        var count = sorted.Count;

        var sum = sorted.Sum();
        var mean = sum / count;
        var variance = sorted.Sum(v => (v - mean) * (v - mean)) / count;
        var stdDev = (float)Math.Sqrt(variance);

        return new ComponentStatistics
        {
            Minimum = sorted.First(),
            Maximum = sorted.Last(),
            Average = mean,
            Median = sorted[count / 2],
            StandardDeviation = stdDev,
            Percentile95 = sorted[(int)(count * 0.95)],
            Percentile99 = sorted[(int)(count * 0.99)],
            Current = values.Last()
        };
    }

    public void Dispose()
    {
        StopMonitoring();
        (_cpuProvider as IDisposable)?.Dispose();
    }
}
```

### File: `src/SeniorIntern.Services/Training/HardwareMonitorServiceConfiguration.cs`

```csharp
namespace SeniorIntern.Services.Training;

/// <summary>
/// Configuration options for the hardware monitor service.
/// </summary>
public sealed class HardwareMonitorServiceConfiguration
{
    /// <summary>
    /// Default monitoring interval.
    /// </summary>
    public TimeSpan DefaultInterval { get; set; } = TimeSpan.FromSeconds(1);

    /// <summary>
    /// Maximum number of metrics to retain in history.
    /// </summary>
    public int MaxHistorySize { get; set; } = 3600;

    /// <summary>
    /// GPU temperature warning threshold (Celsius).
    /// </summary>
    public float GpuTemperatureWarning { get; set; } = 80f;

    /// <summary>
    /// GPU temperature critical threshold (Celsius).
    /// </summary>
    public float GpuTemperatureCritical { get; set; } = 90f;

    /// <summary>
    /// CPU temperature warning threshold (Celsius).
    /// </summary>
    public float CpuTemperatureWarning { get; set; } = 85f;

    /// <summary>
    /// CPU temperature critical threshold (Celsius).
    /// </summary>
    public float CpuTemperatureCritical { get; set; } = 95f;

    /// <summary>
    /// Memory utilization warning threshold (percentage).
    /// </summary>
    public float MemoryWarning { get; set; } = 85f;

    /// <summary>
    /// Memory utilization critical threshold (percentage).
    /// </summary>
    public float MemoryCritical { get; set; } = 95f;

    /// <summary>
    /// Whether to automatically start monitoring on service creation.
    /// </summary>
    public bool AutoStart { get; set; } = false;

    /// <summary>
    /// Enable detailed logging of each metrics collection.
    /// </summary>
    public bool VerboseLogging { get; set; } = false;
}
```

---

## v0.8.4h: Metrics Aggregation & Statistics

### Objective
Implement utilities for aggregating metrics over time periods and calculating statistical summaries for analysis and reporting.

### File: `src/SeniorIntern.Services/Training/MetricsAggregator.cs`

```csharp
namespace SeniorIntern.Services.Training;

using SeniorIntern.Core.Training.Models;

/// <summary>
/// Utility class for aggregating and analyzing hardware metrics.
/// </summary>
public static class MetricsAggregator
{
    /// <summary>
    /// Calculate rolling average over the specified window.
    /// </summary>
    public static HardwareMetrics CalculateRollingAverage(
        IReadOnlyList<TimestampedMetrics> history,
        TimeSpan window)
    {
        var cutoff = DateTime.UtcNow - window;
        var relevant = history.Where(m => m.Timestamp >= cutoff).ToList();

        if (relevant.Count == 0)
            return new HardwareMetrics();

        return new HardwareMetrics
        {
            Timestamp = DateTime.UtcNow,
            GpuMetrics = AggregateGpuMetrics(relevant),
            CpuMetrics = AggregateCpuMetrics(relevant),
            MemoryMetrics = AggregateMemoryMetrics(relevant),
            ActiveDevice = relevant.Last().Metrics.ActiveDevice,
            IsMonitoring = true
        };
    }

    /// <summary>
    /// Detect anomalies in metrics using z-score method.
    /// </summary>
    public static IReadOnlyList<MetricsAnomaly> DetectAnomalies(
        IReadOnlyList<TimestampedMetrics> history,
        float zScoreThreshold = 2.5f)
    {
        var anomalies = new List<MetricsAnomaly>();

        if (history.Count < 10)
            return anomalies;

        // GPU utilization anomalies
        var gpuUtils = history.Select(m => m.Metrics.GpuUtilization).ToList();
        DetectAnomaliesInSeries(gpuUtils, history, "GPU Utilization", zScoreThreshold, anomalies);

        // GPU temperature anomalies
        var gpuTemps = history.Select(m => m.Metrics.GpuTemperature).ToList();
        DetectAnomaliesInSeries(gpuTemps, history, "GPU Temperature", zScoreThreshold, anomalies);

        // CPU utilization anomalies
        var cpuUtils = history.Select(m => m.Metrics.CpuUtilization).ToList();
        DetectAnomaliesInSeries(cpuUtils, history, "CPU Utilization", zScoreThreshold, anomalies);

        return anomalies;
    }

    /// <summary>
    /// Calculate trend (increasing, decreasing, stable) for a metric.
    /// </summary>
    public static MetricTrend CalculateTrend(
        IReadOnlyList<TimestampedMetrics> history,
        Func<HardwareMetrics, float> selector,
        TimeSpan window)
    {
        var cutoff = DateTime.UtcNow - window;
        var relevant = history
            .Where(m => m.Timestamp >= cutoff)
            .Select(m => selector(m.Metrics))
            .ToList();

        if (relevant.Count < 3)
            return MetricTrend.Stable;

        // Calculate linear regression slope
        var n = relevant.Count;
        var sumX = n * (n - 1) / 2f;
        var sumX2 = n * (n - 1) * (2 * n - 1) / 6f;
        var sumY = relevant.Sum();
        var sumXY = relevant.Select((y, x) => x * y).Sum();

        var slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);

        // Determine trend based on slope relative to mean
        var mean = sumY / n;
        var normalizedSlope = mean > 0 ? slope / mean : slope;

        if (normalizedSlope > 0.05f)
            return MetricTrend.Increasing;
        else if (normalizedSlope < -0.05f)
            return MetricTrend.Decreasing;
        else
            return MetricTrend.Stable;
    }

    /// <summary>
    /// Downsample metrics history for efficient storage/visualization.
    /// </summary>
    public static IReadOnlyList<TimestampedMetrics> Downsample(
        IReadOnlyList<TimestampedMetrics> history,
        int targetSamples)
    {
        if (history.Count <= targetSamples)
            return history;

        var result = new List<TimestampedMetrics>(targetSamples);
        var step = (float)history.Count / targetSamples;

        for (int i = 0; i < targetSamples; i++)
        {
            var startIndex = (int)(i * step);
            var endIndex = Math.Min((int)((i + 1) * step), history.Count);

            // Take the average of metrics in this bucket
            var bucket = history.Skip(startIndex).Take(endIndex - startIndex).ToList();
            if (bucket.Count > 0)
            {
                result.Add(new TimestampedMetrics
                {
                    Timestamp = bucket[bucket.Count / 2].Timestamp,
                    Metrics = AverageMetrics(bucket.Select(b => b.Metrics).ToList())
                });
            }
        }

        return result;
    }

    /// <summary>
    /// Export metrics to a format suitable for charting.
    /// </summary>
    public static MetricsChartData ExportForChart(
        IReadOnlyList<TimestampedMetrics> history,
        TimeSpan? startOffset = null)
    {
        var baseTime = history.FirstOrDefault()?.Timestamp ?? DateTime.UtcNow;

        return new MetricsChartData
        {
            TimePoints = history.Select(m =>
                (m.Timestamp - baseTime).TotalSeconds).ToList(),
            GpuUtilization = history.Select(m => m.Metrics.GpuUtilization).ToList(),
            GpuMemoryMB = history.Select(m => m.Metrics.GpuMemoryUsed / (1024f * 1024f)).ToList(),
            GpuTemperature = history.Select(m => m.Metrics.GpuTemperature).ToList(),
            CpuUtilization = history.Select(m => m.Metrics.CpuUtilization).ToList(),
            RamUsageGB = history.Select(m => m.Metrics.RamUsed / (1024f * 1024f * 1024f)).ToList()
        };
    }

    private static IReadOnlyList<GpuMetrics> AggregateGpuMetrics(
        IReadOnlyList<TimestampedMetrics> history)
    {
        var firstGpuMetrics = history.FirstOrDefault()?.Metrics.GpuMetrics;
        if (firstGpuMetrics == null || firstGpuMetrics.Count == 0)
            return Array.Empty<GpuMetrics>();

        var count = firstGpuMetrics.Count;
        var result = new List<GpuMetrics>();

        for (int i = 0; i < count; i++)
        {
            var gpuData = history
                .Select(m => m.Metrics.GpuMetrics.ElementAtOrDefault(i))
                .Where(g => g != null)
                .ToList();

            if (gpuData.Count == 0) continue;

            result.Add(new GpuMetrics
            {
                DeviceIndex = gpuData.First()!.DeviceIndex,
                DeviceName = gpuData.First()!.DeviceName,
                GpuType = gpuData.First()!.GpuType,
                Utilization = gpuData.Average(g => g!.Utilization),
                MemoryUsed = (long)gpuData.Average(g => g!.MemoryUsed),
                MemoryTotal = gpuData.First()!.MemoryTotal,
                Temperature = gpuData.Average(g => g!.Temperature),
                PowerDraw = gpuData.Average(g => g!.PowerDraw),
                PowerLimit = gpuData.First()!.PowerLimit,
                FanSpeed = gpuData.Average(g => g!.FanSpeed),
                MemoryClockMhz = (int)gpuData.Average(g => g!.MemoryClockMhz),
                GraphicsClockMhz = (int)gpuData.Average(g => g!.GraphicsClockMhz)
            });
        }

        return result;
    }

    private static CpuMetrics AggregateCpuMetrics(IReadOnlyList<TimestampedMetrics> history)
    {
        var cpuData = history.Select(m => m.Metrics.CpuMetrics).ToList();
        var first = cpuData.First();

        return new CpuMetrics
        {
            ModelName = first.ModelName,
            PhysicalCores = first.PhysicalCores,
            LogicalProcessors = first.LogicalProcessors,
            TotalUtilization = cpuData.Average(c => c.TotalUtilization),
            PerCoreUtilization = AggregatePerCoreUtilization(cpuData),
            ProcessUtilization = cpuData.Average(c => c.ProcessUtilization),
            CurrentFrequencyMhz = (int)cpuData.Average(c => c.CurrentFrequencyMhz),
            MaxFrequencyMhz = first.MaxFrequencyMhz,
            Temperature = cpuData.Average(c => c.Temperature),
            ProcessThreadCount = (int)cpuData.Average(c => c.ProcessThreadCount)
        };
    }

    private static IReadOnlyList<float> AggregatePerCoreUtilization(
        IReadOnlyList<CpuMetrics> cpuData)
    {
        var maxCores = cpuData.Max(c => c.PerCoreUtilization.Count);
        if (maxCores == 0) return Array.Empty<float>();

        var result = new float[maxCores];
        for (int i = 0; i < maxCores; i++)
        {
            var coreIndex = i;
            var coreValues = cpuData
                .Where(c => c.PerCoreUtilization.Count > coreIndex)
                .Select(c => c.PerCoreUtilization[coreIndex])
                .ToList();

            result[i] = coreValues.Count > 0 ? coreValues.Average() : 0;
        }

        return result;
    }

    private static MemoryMetrics AggregateMemoryMetrics(IReadOnlyList<TimestampedMetrics> history)
    {
        var memData = history.Select(m => m.Metrics.MemoryMetrics).ToList();
        var first = memData.First();

        return new MemoryMetrics
        {
            TotalBytes = first.TotalBytes,
            UsedBytes = (long)memData.Average(m => m.UsedBytes),
            ProcessWorkingSet = (long)memData.Average(m => m.ProcessWorkingSet),
            ProcessPrivateMemory = (long)memData.Average(m => m.ProcessPrivateMemory),
            ManagedHeapSize = (long)memData.Average(m => m.ManagedHeapSize),
            GcTotalAllocated = memData.Last().GcTotalAllocated,
            GcGen0Collections = memData.Last().GcGen0Collections,
            GcGen1Collections = memData.Last().GcGen1Collections,
            GcGen2Collections = memData.Last().GcGen2Collections,
            VirtualMemoryCommitted = (long)memData.Average(m => m.VirtualMemoryCommitted),
            PageFileUsage = (long)memData.Average(m => m.PageFileUsage)
        };
    }

    private static HardwareMetrics AverageMetrics(IReadOnlyList<HardwareMetrics> metrics)
    {
        return new HardwareMetrics
        {
            Timestamp = metrics[metrics.Count / 2].Timestamp,
            GpuMetrics = metrics.First().GpuMetrics, // Simplified
            CpuMetrics = new CpuMetrics
            {
                TotalUtilization = metrics.Average(m => m.CpuUtilization)
            },
            MemoryMetrics = new MemoryMetrics
            {
                TotalBytes = metrics.First().MemoryMetrics.TotalBytes,
                UsedBytes = (long)metrics.Average(m => m.RamUsed)
            },
            ActiveDevice = metrics.First().ActiveDevice,
            IsMonitoring = true
        };
    }

    private static void DetectAnomaliesInSeries(
        List<float> values,
        IReadOnlyList<TimestampedMetrics> history,
        string metricName,
        float zScoreThreshold,
        List<MetricsAnomaly> anomalies)
    {
        var mean = values.Average();
        var stdDev = (float)Math.Sqrt(values.Average(v => (v - mean) * (v - mean)));

        if (stdDev < 0.001f) return; // Too little variance

        for (int i = 0; i < values.Count; i++)
        {
            var zScore = (values[i] - mean) / stdDev;
            if (Math.Abs(zScore) > zScoreThreshold)
            {
                anomalies.Add(new MetricsAnomaly
                {
                    Timestamp = history[i].Timestamp,
                    MetricName = metricName,
                    Value = values[i],
                    ExpectedValue = mean,
                    ZScore = zScore
                });
            }
        }
    }
}

/// <summary>
/// Represents an anomaly detected in metrics.
/// </summary>
public sealed record MetricsAnomaly
{
    public DateTime Timestamp { get; init; }
    public string MetricName { get; init; } = string.Empty;
    public float Value { get; init; }
    public float ExpectedValue { get; init; }
    public float ZScore { get; init; }
}

/// <summary>
/// Trend direction for a metric.
/// </summary>
public enum MetricTrend
{
    Stable,
    Increasing,
    Decreasing
}

/// <summary>
/// Chart-ready metrics data.
/// </summary>
public sealed class MetricsChartData
{
    public IReadOnlyList<double> TimePoints { get; init; } = Array.Empty<double>();
    public IReadOnlyList<float> GpuUtilization { get; init; } = Array.Empty<float>();
    public IReadOnlyList<float> GpuMemoryMB { get; init; } = Array.Empty<float>();
    public IReadOnlyList<float> GpuTemperature { get; init; } = Array.Empty<float>();
    public IReadOnlyList<float> CpuUtilization { get; init; } = Array.Empty<float>();
    public IReadOnlyList<float> RamUsageGB { get; init; } = Array.Empty<float>();
}
```

### File: `src/SeniorIntern.Services/Training/MetricsExporter.cs`

```csharp
namespace SeniorIntern.Services.Training;

using System.Text;
using System.Text.Json;
using SeniorIntern.Core.Training.Models;

/// <summary>
/// Export metrics data to various formats.
/// </summary>
public static class MetricsExporter
{
    /// <summary>
    /// Export metrics history to CSV format.
    /// </summary>
    public static string ToCsv(IReadOnlyList<TimestampedMetrics> history)
    {
        var sb = new StringBuilder();

        // Header
        sb.AppendLine("Timestamp,GPU_Utilization,GPU_Memory_MB,GPU_Temp,CPU_Utilization,RAM_Used_GB");

        // Data rows
        foreach (var item in history)
        {
            var m = item.Metrics;
            sb.AppendLine($"{item.Timestamp:O}," +
                          $"{m.GpuUtilization:F2}," +
                          $"{m.GpuMemoryUsed / (1024.0 * 1024.0):F2}," +
                          $"{m.GpuTemperature:F1}," +
                          $"{m.CpuUtilization:F2}," +
                          $"{m.RamUsed / (1024.0 * 1024.0 * 1024.0):F2}");
        }

        return sb.ToString();
    }

    /// <summary>
    /// Export metrics history to JSON format.
    /// </summary>
    public static string ToJson(IReadOnlyList<TimestampedMetrics> history, bool indented = false)
    {
        var options = new JsonSerializerOptions
        {
            WriteIndented = indented,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        };

        return JsonSerializer.Serialize(history, options);
    }

    /// <summary>
    /// Export metrics statistics to a summary report.
    /// </summary>
    public static string ToSummaryReport(MetricsStatistics stats)
    {
        var sb = new StringBuilder();

        sb.AppendLine("=== Hardware Metrics Summary Report ===");
        sb.AppendLine();
        sb.AppendLine($"Period: {stats.PeriodStart:g} - {stats.PeriodEnd:g}");
        sb.AppendLine($"Samples: {stats.SampleCount}");
        sb.AppendLine();

        sb.AppendLine("GPU Utilization:");
        AppendComponentStats(sb, stats.GpuUtilization, "%");
        sb.AppendLine();

        sb.AppendLine($"GPU Memory: Peak {stats.PeakGpuMemory / (1024.0 * 1024.0):F0} MB");
        sb.AppendLine();

        sb.AppendLine($"GPU Temperature: Max {stats.MaxGpuTemperature:F1}°C");
        if (stats.ThermalThrottlingDetected)
            sb.AppendLine("  ⚠ Thermal throttling detected during period");
        sb.AppendLine();

        sb.AppendLine("CPU Utilization:");
        AppendComponentStats(sb, stats.CpuUtilization, "%");
        sb.AppendLine();

        sb.AppendLine($"RAM Usage: Peak {stats.PeakRamUsage / (1024.0 * 1024.0 * 1024.0):F2} GB");

        return sb.ToString();
    }

    private static void AppendComponentStats(StringBuilder sb, ComponentStatistics stats, string unit)
    {
        sb.AppendLine($"  Min: {stats.Minimum:F1}{unit}");
        sb.AppendLine($"  Max: {stats.Maximum:F1}{unit}");
        sb.AppendLine($"  Avg: {stats.Average:F1}{unit}");
        sb.AppendLine($"  P95: {stats.Percentile95:F1}{unit}");
    }

    /// <summary>
    /// Save metrics history to a file.
    /// </summary>
    public static async Task SaveToFileAsync(
        IReadOnlyList<TimestampedMetrics> history,
        string filePath,
        MetricsExportFormat format = MetricsExportFormat.Json)
    {
        var content = format switch
        {
            MetricsExportFormat.Csv => ToCsv(history),
            MetricsExportFormat.Json => ToJson(history, indented: true),
            _ => throw new ArgumentException($"Unsupported format: {format}")
        };

        await File.WriteAllTextAsync(filePath, content);
    }
}

/// <summary>
/// Export format options.
/// </summary>
public enum MetricsExportFormat
{
    Csv,
    Json
}
```

---

## v0.8.4i: Thermal Management & Alerts

### Objective
Implement thermal management policies and alert handling for safe training operations.

### File: `src/SeniorIntern.Services/Training/ThermalManager.cs`

```csharp
namespace SeniorIntern.Services.Training;

using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Training.Models;

/// <summary>
/// Manages thermal policies and actions during training.
/// </summary>
public sealed class ThermalManager : IDisposable
{
    private readonly ILogger<ThermalManager> _logger;
    private readonly IHardwareMonitorService _monitorService;
    private readonly ThermalPolicy _policy;

    private bool _isThrottling;
    private DateTime _lastThrottleTime = DateTime.MinValue;
    private int _consecutiveHighTempReadings;

    /// <summary>
    /// Event raised when thermal throttling state changes.
    /// </summary>
    public event EventHandler<ThermalThrottlingEventArgs>? ThrottlingStateChanged;

    /// <summary>
    /// Event raised when emergency thermal shutdown is recommended.
    /// </summary>
    public event EventHandler<EmergencyShutdownEventArgs>? EmergencyShutdownRecommended;

    public ThermalManager(
        ILogger<ThermalManager> logger,
        IHardwareMonitorService monitorService,
        ThermalPolicy? policy = null)
    {
        _logger = logger;
        _monitorService = monitorService;
        _policy = policy ?? new ThermalPolicy();

        _monitorService.ThermalAlert += OnThermalAlert;
    }

    /// <summary>
    /// Gets whether thermal throttling is currently active.
    /// </summary>
    public bool IsThrottling => _isThrottling;

    /// <summary>
    /// Gets the current thermal state.
    /// </summary>
    public ThermalState CurrentState { get; private set; } = ThermalState.Normal;

    /// <summary>
    /// Evaluate current thermal conditions and return recommended action.
    /// </summary>
    public ThermalAction EvaluateConditions()
    {
        var metrics = _monitorService.GetLastMetrics();
        if (metrics == null)
            return ThermalAction.Continue;

        var maxGpuTemp = metrics.GpuMetrics.DefaultIfEmpty(new GpuMetrics())
            .Max(g => g.Temperature);
        var cpuTemp = metrics.CpuMetrics.Temperature;

        // Check for emergency conditions
        if (maxGpuTemp >= _policy.EmergencyTemperature ||
            cpuTemp >= _policy.EmergencyTemperature)
        {
            CurrentState = ThermalState.Emergency;
            return ThermalAction.Stop;
        }

        // Check for critical conditions
        if (maxGpuTemp >= _policy.CriticalTemperature ||
            cpuTemp >= _policy.CriticalTemperature)
        {
            _consecutiveHighTempReadings++;

            if (_consecutiveHighTempReadings >= _policy.ThrottleAfterConsecutiveReadings)
            {
                CurrentState = ThermalState.Critical;
                EnableThrottling();
                return ThermalAction.Throttle;
            }
        }
        else if (maxGpuTemp >= _policy.WarningTemperature ||
                 cpuTemp >= _policy.WarningTemperature)
        {
            CurrentState = ThermalState.Warning;
            _consecutiveHighTempReadings = Math.Max(0, _consecutiveHighTempReadings - 1);
        }
        else
        {
            CurrentState = ThermalState.Normal;
            _consecutiveHighTempReadings = 0;

            if (_isThrottling)
            {
                DisableThrottling();
            }
        }

        return _isThrottling ? ThermalAction.Throttle : ThermalAction.Continue;
    }

    /// <summary>
    /// Get recommended batch size multiplier based on thermal conditions.
    /// </summary>
    public float GetBatchSizeMultiplier()
    {
        return CurrentState switch
        {
            ThermalState.Normal => 1.0f,
            ThermalState.Warning => 0.9f,
            ThermalState.Critical => 0.5f,
            ThermalState.Emergency => 0.0f,
            _ => 1.0f
        };
    }

    /// <summary>
    /// Get recommended delay between batches for cooling.
    /// </summary>
    public TimeSpan GetCoolingDelay()
    {
        return CurrentState switch
        {
            ThermalState.Normal => TimeSpan.Zero,
            ThermalState.Warning => TimeSpan.FromMilliseconds(100),
            ThermalState.Critical => TimeSpan.FromMilliseconds(500),
            ThermalState.Emergency => TimeSpan.FromSeconds(5),
            _ => TimeSpan.Zero
        };
    }

    private void OnThermalAlert(object? sender, ThermalAlertEventArgs e)
    {
        _logger.LogWarning(
            "Thermal alert: {Component} at {Temp}°C ({Severity})",
            e.Component, e.CurrentTemperature, e.Severity);

        if (e.Severity == AlertSeverity.Emergency)
        {
            EmergencyShutdownRecommended?.Invoke(this, new EmergencyShutdownEventArgs
            {
                Component = e.Component,
                Temperature = e.CurrentTemperature,
                Reason = $"{e.Component} temperature critical: {e.CurrentTemperature}°C"
            });
        }
    }

    private void EnableThrottling()
    {
        if (_isThrottling) return;

        _isThrottling = true;
        _lastThrottleTime = DateTime.UtcNow;

        _logger.LogWarning("Thermal throttling enabled due to high temperatures");

        ThrottlingStateChanged?.Invoke(this, new ThermalThrottlingEventArgs
        {
            IsThrottling = true,
            Reason = "High temperature detected"
        });
    }

    private void DisableThrottling()
    {
        if (!_isThrottling) return;

        // Only disable if we've been throttling for minimum duration
        if (DateTime.UtcNow - _lastThrottleTime < _policy.MinimumThrottleDuration)
            return;

        _isThrottling = false;

        _logger.LogInformation("Thermal throttling disabled - temperatures normalized");

        ThrottlingStateChanged?.Invoke(this, new ThermalThrottlingEventArgs
        {
            IsThrottling = false,
            Reason = "Temperatures normalized"
        });
    }

    public void Dispose()
    {
        _monitorService.ThermalAlert -= OnThermalAlert;
    }
}

/// <summary>
/// Thermal policy configuration.
/// </summary>
public sealed class ThermalPolicy
{
    /// <summary>
    /// Temperature at which to show warnings (Celsius).
    /// </summary>
    public float WarningTemperature { get; set; } = 75f;

    /// <summary>
    /// Temperature at which to enable throttling (Celsius).
    /// </summary>
    public float CriticalTemperature { get; set; } = 85f;

    /// <summary>
    /// Temperature at which to recommend stopping training (Celsius).
    /// </summary>
    public float EmergencyTemperature { get; set; } = 95f;

    /// <summary>
    /// Number of consecutive high-temp readings before throttling.
    /// </summary>
    public int ThrottleAfterConsecutiveReadings { get; set; } = 3;

    /// <summary>
    /// Minimum duration to maintain throttling before re-evaluating.
    /// </summary>
    public TimeSpan MinimumThrottleDuration { get; set; } = TimeSpan.FromSeconds(30);
}

/// <summary>
/// Current thermal state.
/// </summary>
public enum ThermalState
{
    Normal,
    Warning,
    Critical,
    Emergency
}

/// <summary>
/// Recommended thermal action.
/// </summary>
public enum ThermalAction
{
    Continue,
    Throttle,
    Stop
}

/// <summary>
/// Event args for throttling state changes.
/// </summary>
public sealed class ThermalThrottlingEventArgs : EventArgs
{
    public bool IsThrottling { get; init; }
    public string Reason { get; init; } = string.Empty;
}

/// <summary>
/// Event args for emergency shutdown recommendation.
/// </summary>
public sealed class EmergencyShutdownEventArgs : EventArgs
{
    public ThermalComponent Component { get; init; }
    public float Temperature { get; init; }
    public string Reason { get; init; } = string.Empty;
}
```

### File: `src/SeniorIntern.Services/Training/MemoryGuard.cs`

```csharp
namespace SeniorIntern.Services.Training;

using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Training.Models;

/// <summary>
/// Monitors memory usage and provides safeguards against OOM conditions.
/// </summary>
public sealed class MemoryGuard : IDisposable
{
    private readonly ILogger<MemoryGuard> _logger;
    private readonly IHardwareMonitorService _monitorService;
    private readonly MemoryGuardPolicy _policy;

    private int _oomWarningCount;
    private DateTime _lastGcTime = DateTime.MinValue;

    /// <summary>
    /// Event raised when memory pressure is high and action is recommended.
    /// </summary>
    public event EventHandler<MemoryPressureEventArgs>? MemoryPressureDetected;

    public MemoryGuard(
        ILogger<MemoryGuard> logger,
        IHardwareMonitorService monitorService,
        MemoryGuardPolicy? policy = null)
    {
        _logger = logger;
        _monitorService = monitorService;
        _policy = policy ?? new MemoryGuardPolicy();

        _monitorService.MemoryAlert += OnMemoryAlert;
    }

    /// <summary>
    /// Check if there's sufficient memory to continue training.
    /// </summary>
    /// <param name="requiredBytes">Estimated memory needed for next operation.</param>
    public MemoryCheckResult CheckMemory(long requiredBytes = 0)
    {
        var metrics = _monitorService.GetLastMetrics();
        if (metrics == null)
            return new MemoryCheckResult { CanContinue = true };

        // Check GPU memory
        var gpuCheck = CheckGpuMemory(metrics, requiredBytes);
        if (!gpuCheck.CanContinue)
            return gpuCheck;

        // Check system RAM
        return CheckSystemRam(metrics, requiredBytes);
    }

    /// <summary>
    /// Attempt to free memory through garbage collection.
    /// </summary>
    /// <param name="aggressive">If true, perform full GC with compaction.</param>
    public long TryFreeMemory(bool aggressive = false)
    {
        var beforeGc = GC.GetTotalMemory(forceFullCollection: false);

        if (aggressive)
        {
            _logger.LogInformation("Performing aggressive garbage collection");
            GCSettings.LargeObjectHeapCompactionMode = GCLargeObjectHeapCompactionMode.CompactOnce;
            GC.Collect(2, GCCollectionMode.Aggressive, blocking: true, compacting: true);
        }
        else
        {
            GC.Collect(1, GCCollectionMode.Optimized);
        }

        GC.WaitForPendingFinalizers();

        var afterGc = GC.GetTotalMemory(forceFullCollection: false);
        var freed = beforeGc - afterGc;

        _lastGcTime = DateTime.UtcNow;
        _logger.LogInformation("Freed {FreedMB}MB through garbage collection", freed / (1024 * 1024));

        return freed;
    }

    /// <summary>
    /// Get recommended batch size based on available memory.
    /// </summary>
    /// <param name="baseBatchSize">The requested batch size.</param>
    /// <param name="bytesPerSample">Estimated memory per training sample.</param>
    public int GetSafeBatchSize(int baseBatchSize, long bytesPerSample)
    {
        var metrics = _monitorService.GetLastMetrics();
        if (metrics == null)
            return baseBatchSize;

        // Use GPU memory if available, otherwise system RAM
        long availableMemory;
        if (metrics.GpuMetrics.Count > 0)
        {
            var gpu = metrics.GpuMetrics[0];
            availableMemory = (long)(gpu.MemoryAvailable * _policy.SafeMemoryFactor);
        }
        else
        {
            availableMemory = (long)(metrics.MemoryMetrics.AvailableBytes * _policy.SafeMemoryFactor);
        }

        var maxBatchSize = (int)(availableMemory / bytesPerSample);
        return Math.Min(baseBatchSize, Math.Max(1, maxBatchSize));
    }

    private MemoryCheckResult CheckGpuMemory(HardwareMetrics metrics, long requiredBytes)
    {
        if (metrics.GpuMetrics.Count == 0)
            return new MemoryCheckResult { CanContinue = true };

        var gpu = metrics.GpuMetrics[0];
        var utilizationPercent = gpu.MemoryUtilization;
        var availableBytes = gpu.MemoryAvailable;

        if (utilizationPercent >= _policy.CriticalThreshold)
        {
            return new MemoryCheckResult
            {
                CanContinue = false,
                MemoryType = MemoryType.GpuVram,
                AvailableBytes = availableBytes,
                RequiredBytes = requiredBytes,
                UtilizationPercent = utilizationPercent,
                Recommendation = "GPU memory critically low. Consider reducing batch size or using gradient checkpointing."
            };
        }

        if (requiredBytes > 0 && availableBytes < requiredBytes)
        {
            return new MemoryCheckResult
            {
                CanContinue = false,
                MemoryType = MemoryType.GpuVram,
                AvailableBytes = availableBytes,
                RequiredBytes = requiredBytes,
                UtilizationPercent = utilizationPercent,
                Recommendation = $"Insufficient GPU memory. Need {requiredBytes / (1024 * 1024)}MB, have {availableBytes / (1024 * 1024)}MB."
            };
        }

        return new MemoryCheckResult
        {
            CanContinue = true,
            MemoryType = MemoryType.GpuVram,
            AvailableBytes = availableBytes,
            UtilizationPercent = utilizationPercent
        };
    }

    private MemoryCheckResult CheckSystemRam(HardwareMetrics metrics, long requiredBytes)
    {
        var utilizationPercent = metrics.MemoryMetrics.Utilization;
        var availableBytes = metrics.MemoryMetrics.AvailableBytes;

        if (utilizationPercent >= _policy.CriticalThreshold)
        {
            // Try to free memory first
            if (DateTime.UtcNow - _lastGcTime > TimeSpan.FromSeconds(30))
            {
                TryFreeMemory(aggressive: true);

                // Re-check after GC
                var newMetrics = _monitorService.GetCurrentMetrics();
                availableBytes = newMetrics.MemoryMetrics.AvailableBytes;
                utilizationPercent = newMetrics.MemoryMetrics.Utilization;
            }

            if (utilizationPercent >= _policy.CriticalThreshold)
            {
                return new MemoryCheckResult
                {
                    CanContinue = false,
                    MemoryType = MemoryType.SystemRam,
                    AvailableBytes = availableBytes,
                    RequiredBytes = requiredBytes,
                    UtilizationPercent = utilizationPercent,
                    Recommendation = "System memory critically low. Close other applications or reduce dataset size."
                };
            }
        }

        return new MemoryCheckResult
        {
            CanContinue = true,
            MemoryType = MemoryType.SystemRam,
            AvailableBytes = availableBytes,
            UtilizationPercent = utilizationPercent
        };
    }

    private void OnMemoryAlert(object? sender, MemoryAlertEventArgs e)
    {
        _oomWarningCount++;

        _logger.LogWarning(
            "Memory alert #{Count}: {Type} at {Utilization:F1}%",
            _oomWarningCount, e.MemoryType, e.UsagePercentage);

        MemoryPressureDetected?.Invoke(this, new MemoryPressureEventArgs
        {
            MemoryType = e.MemoryType,
            UtilizationPercent = e.UsagePercentage,
            Severity = e.Severity,
            RecommendedAction = e.Severity == AlertSeverity.Critical
                ? MemoryAction.ReduceBatchSize
                : MemoryAction.Monitor
        });
    }

    public void Dispose()
    {
        _monitorService.MemoryAlert -= OnMemoryAlert;
    }
}

/// <summary>
/// Memory guard policy configuration.
/// </summary>
public sealed class MemoryGuardPolicy
{
    /// <summary>
    /// Warning threshold percentage.
    /// </summary>
    public float WarningThreshold { get; set; } = 80f;

    /// <summary>
    /// Critical threshold percentage (may block operations).
    /// </summary>
    public float CriticalThreshold { get; set; } = 95f;

    /// <summary>
    /// Factor to apply when calculating safe memory usage (0.0-1.0).
    /// </summary>
    public float SafeMemoryFactor { get; set; } = 0.8f;

    /// <summary>
    /// Enable automatic garbage collection on memory pressure.
    /// </summary>
    public bool AutoGcOnPressure { get; set; } = true;
}

/// <summary>
/// Result of a memory check operation.
/// </summary>
public sealed class MemoryCheckResult
{
    public bool CanContinue { get; init; }
    public MemoryType MemoryType { get; init; }
    public long AvailableBytes { get; init; }
    public long RequiredBytes { get; init; }
    public float UtilizationPercent { get; init; }
    public string? Recommendation { get; init; }
}

/// <summary>
/// Event args for memory pressure events.
/// </summary>
public sealed class MemoryPressureEventArgs : EventArgs
{
    public MemoryType MemoryType { get; init; }
    public float UtilizationPercent { get; init; }
    public AlertSeverity Severity { get; init; }
    public MemoryAction RecommendedAction { get; init; }
}

/// <summary>
/// Recommended memory action.
/// </summary>
public enum MemoryAction
{
    Monitor,
    ReduceBatchSize,
    PauseTraining,
    StopTraining
}
```

---

## v0.8.4j: Unit Testing & Integration

### Objective
Create comprehensive unit tests for all hardware monitoring components, including mocked providers for CI/CD environments.

### File: `tests/SeniorIntern.Tests/Training/HardwareMetricsTests.cs`

```csharp
namespace SeniorIntern.Tests.Training;

using SeniorIntern.Core.Training.Models;
using Xunit;

public class HardwareMetricsTests
{
    [Fact]
    public void GpuMetrics_MemoryUtilization_CalculatesCorrectly()
    {
        var gpu = new GpuMetrics
        {
            MemoryUsed = 8L * 1024 * 1024 * 1024, // 8 GB
            MemoryTotal = 24L * 1024 * 1024 * 1024 // 24 GB
        };

        Assert.Equal(33.33f, gpu.MemoryUtilization, precision: 1);
    }

    [Fact]
    public void GpuMetrics_MemoryAvailable_CalculatesCorrectly()
    {
        var gpu = new GpuMetrics
        {
            MemoryUsed = 8L * 1024 * 1024 * 1024,
            MemoryTotal = 24L * 1024 * 1024 * 1024
        };

        Assert.Equal(16L * 1024 * 1024 * 1024, gpu.MemoryAvailable);
    }

    [Fact]
    public void HardwareMetrics_PrimaryGpu_ReturnsFirstGpu()
    {
        var metrics = new HardwareMetrics
        {
            GpuMetrics = new[]
            {
                new GpuMetrics { DeviceIndex = 0, Utilization = 50 },
                new GpuMetrics { DeviceIndex = 1, Utilization = 75 }
            }
        };

        Assert.Equal(50, metrics.GpuUtilization);
    }

    [Fact]
    public void HardwareMetrics_NoGpu_ReturnsZero()
    {
        var metrics = new HardwareMetrics
        {
            GpuMetrics = Array.Empty<GpuMetrics>()
        };

        Assert.Equal(0, metrics.GpuUtilization);
        Assert.Equal(0, metrics.GpuMemoryUsed);
    }

    [Fact]
    public void MemoryMetrics_Utilization_CalculatesCorrectly()
    {
        var memory = new MemoryMetrics
        {
            TotalBytes = 32L * 1024 * 1024 * 1024,
            UsedBytes = 24L * 1024 * 1024 * 1024
        };

        Assert.Equal(75, memory.Utilization);
    }
}
```

### File: `tests/SeniorIntern.Tests/Training/MockGpuMetricsProvider.cs`

```csharp
namespace SeniorIntern.Tests.Training;

using SeniorIntern.Core.Training.Models;
using SeniorIntern.Services.Training.Providers;

/// <summary>
/// Mock GPU metrics provider for testing.
/// </summary>
public sealed class MockGpuMetricsProvider : IGpuMetricsProvider
{
    private readonly List<GpuMetrics> _metrics;
    private int _collectionCount;

    public MockGpuMetricsProvider(int deviceCount = 1, float baseUtilization = 50f)
    {
        _metrics = new List<GpuMetrics>();

        for (int i = 0; i < deviceCount; i++)
        {
            _metrics.Add(new GpuMetrics
            {
                DeviceIndex = i,
                DeviceName = $"Mock GPU {i}",
                GpuType = GpuType.NvidiaCuda,
                Utilization = baseUtilization + i * 10,
                MemoryUsed = 8L * 1024 * 1024 * 1024,
                MemoryTotal = 24L * 1024 * 1024 * 1024,
                Temperature = 65 + i * 5,
                PowerDraw = 200 + i * 50,
                PowerLimit = 350,
                FanSpeed = 40 + i * 10,
                MemoryClockMhz = 8000,
                GraphicsClockMhz = 2100
            });
        }
    }

    public bool IsAvailable => _metrics.Count > 0;
    public int DeviceCount => _metrics.Count;
    public GpuType GpuType => GpuType.NvidiaCuda;
    public int CollectionCount => _collectionCount;

    public IReadOnlyList<GpuMetrics> CollectMetrics()
    {
        _collectionCount++;
        return _metrics;
    }

    public GpuMetrics CollectMetrics(int deviceIndex)
    {
        _collectionCount++;
        return _metrics[deviceIndex];
    }

    /// <summary>
    /// Update metrics for testing different scenarios.
    /// </summary>
    public void SetMetrics(int deviceIndex, GpuMetrics metrics)
    {
        _metrics[deviceIndex] = metrics;
    }

    /// <summary>
    /// Simulate temperature increase.
    /// </summary>
    public void SimulateTemperatureIncrease(int deviceIndex, float increase)
    {
        var current = _metrics[deviceIndex];
        _metrics[deviceIndex] = current with
        {
            Temperature = current.Temperature + increase
        };
    }

    /// <summary>
    /// Simulate memory pressure.
    /// </summary>
    public void SimulateMemoryPressure(int deviceIndex, float utilizationPercent)
    {
        var current = _metrics[deviceIndex];
        var used = (long)(current.MemoryTotal * utilizationPercent / 100);
        _metrics[deviceIndex] = current with
        {
            MemoryUsed = used
        };
    }
}
```

### File: `tests/SeniorIntern.Tests/Training/MockCpuMetricsProvider.cs`

```csharp
namespace SeniorIntern.Tests.Training;

using SeniorIntern.Core.Training.Models;
using SeniorIntern.Services.Training.Providers;

/// <summary>
/// Mock CPU metrics provider for testing.
/// </summary>
public sealed class MockCpuMetricsProvider : ICpuMetricsProvider
{
    private CpuMetrics _metrics;
    private int _collectionCount;

    public MockCpuMetricsProvider(int physicalCores = 8, int logicalProcessors = 16)
    {
        PhysicalCores = physicalCores;
        LogicalProcessors = logicalProcessors;
        ModelName = "Mock CPU";

        _metrics = new CpuMetrics
        {
            ModelName = ModelName,
            PhysicalCores = physicalCores,
            LogicalProcessors = logicalProcessors,
            TotalUtilization = 25,
            PerCoreUtilization = Enumerable.Repeat(25f, logicalProcessors).ToList(),
            ProcessUtilization = 15,
            CurrentFrequencyMhz = 3600,
            MaxFrequencyMhz = 5000,
            Temperature = 55,
            ProcessThreadCount = 32
        };
    }

    public int PhysicalCores { get; }
    public int LogicalProcessors { get; }
    public string ModelName { get; }
    public int CollectionCount => _collectionCount;

    public CpuMetrics CollectMetrics()
    {
        _collectionCount++;
        return _metrics;
    }

    /// <summary>
    /// Set total CPU utilization for testing.
    /// </summary>
    public void SetUtilization(float utilization)
    {
        _metrics = _metrics with
        {
            TotalUtilization = utilization,
            PerCoreUtilization = Enumerable.Repeat(utilization, LogicalProcessors).ToList()
        };
    }

    /// <summary>
    /// Set CPU temperature for testing.
    /// </summary>
    public void SetTemperature(float temperature)
    {
        _metrics = _metrics with { Temperature = temperature };
    }
}
```

### File: `tests/SeniorIntern.Tests/Training/MockMemoryMetricsProvider.cs`

```csharp
namespace SeniorIntern.Tests.Training;

using SeniorIntern.Core.Training.Models;
using SeniorIntern.Services.Training.Providers;

/// <summary>
/// Mock memory metrics provider for testing.
/// </summary>
public sealed class MockMemoryMetricsProvider : IMemoryMetricsProvider
{
    private MemoryMetrics _metrics;
    private int _collectionCount;
    private int _gcCount;

    public MockMemoryMetricsProvider(long totalRamGb = 32)
    {
        TotalSystemRam = totalRamGb * 1024 * 1024 * 1024;

        _metrics = new MemoryMetrics
        {
            TotalBytes = TotalSystemRam,
            UsedBytes = TotalSystemRam / 2,
            ProcessWorkingSet = 2L * 1024 * 1024 * 1024,
            ProcessPrivateMemory = 1L * 1024 * 1024 * 1024,
            ManagedHeapSize = 500 * 1024 * 1024,
            GcTotalAllocated = 2L * 1024 * 1024 * 1024,
            GcGen0Collections = 100,
            GcGen1Collections = 20,
            GcGen2Collections = 5,
            VirtualMemoryCommitted = 4L * 1024 * 1024 * 1024,
            PageFileUsage = 1L * 1024 * 1024 * 1024
        };
    }

    public long TotalSystemRam { get; }
    public int CollectionCount => _collectionCount;
    public int GcCount => _gcCount;

    public MemoryMetrics CollectMetrics()
    {
        _collectionCount++;
        return _metrics;
    }

    public MemoryMetrics ForceGarbageCollection(int generation = -1)
    {
        _gcCount++;

        // Simulate memory being freed
        _metrics = _metrics with
        {
            ManagedHeapSize = _metrics.ManagedHeapSize - 100 * 1024 * 1024,
            GcGen0Collections = _metrics.GcGen0Collections + 1
        };

        return _metrics;
    }

    /// <summary>
    /// Set memory utilization for testing.
    /// </summary>
    public void SetUtilization(float utilizationPercent)
    {
        _metrics = _metrics with
        {
            UsedBytes = (long)(TotalSystemRam * utilizationPercent / 100)
        };
    }
}
```

### File: `tests/SeniorIntern.Tests/Training/HardwareMonitorServiceTests.cs`

```csharp
namespace SeniorIntern.Tests.Training;

using Microsoft.Extensions.Logging.Abstractions;
using SeniorIntern.Core.Training.Models;
using SeniorIntern.Services.Training;
using SeniorIntern.Services.Training.Providers;
using Xunit;

public class HardwareMonitorServiceTests
{
    private readonly MockGpuMetricsProvider _gpuProvider;
    private readonly MockCpuMetricsProvider _cpuProvider;
    private readonly MockMemoryMetricsProvider _memoryProvider;

    public HardwareMonitorServiceTests()
    {
        _gpuProvider = new MockGpuMetricsProvider();
        _cpuProvider = new MockCpuMetricsProvider();
        _memoryProvider = new MockMemoryMetricsProvider();
    }

    [Fact]
    public void GetCurrentMetrics_CollectsFromAllProviders()
    {
        var service = CreateService();

        var metrics = service.GetCurrentMetrics();

        Assert.NotNull(metrics);
        Assert.Single(metrics.GpuMetrics);
        Assert.NotNull(metrics.CpuMetrics);
        Assert.NotNull(metrics.MemoryMetrics);
    }

    [Fact]
    public void StartMonitoring_SetsIsMonitoringTrue()
    {
        var service = CreateService();

        service.StartMonitoring(TimeSpan.FromSeconds(1));

        Assert.True(service.IsMonitoring);

        service.StopMonitoring();
    }

    [Fact]
    public void StopMonitoring_SetsIsMonitoringFalse()
    {
        var service = CreateService();
        service.StartMonitoring(TimeSpan.FromSeconds(1));

        service.StopMonitoring();

        Assert.False(service.IsMonitoring);
    }

    [Fact]
    public async Task Monitoring_CollectsMetricsPeriodically()
    {
        var service = CreateService();
        var collectedMetrics = new List<HardwareMetrics>();

        service.MetricsUpdated += (_, e) => collectedMetrics.Add(e.Metrics);
        service.StartMonitoring(TimeSpan.FromMilliseconds(100));

        await Task.Delay(350);
        service.StopMonitoring();

        Assert.True(collectedMetrics.Count >= 2);
    }

    [Fact]
    public void GetHistory_ReturnsCollectedMetrics()
    {
        var service = CreateService();
        service.StartMonitoring(TimeSpan.FromMilliseconds(100));
        Thread.Sleep(350);
        service.StopMonitoring();

        var history = service.GetHistory(TimeSpan.FromSeconds(10));

        Assert.True(history.Count >= 2);
    }

    [Fact]
    public void ClearHistory_RemovesAllMetrics()
    {
        var service = CreateService();
        service.StartMonitoring(TimeSpan.FromMilliseconds(100));
        Thread.Sleep(250);
        service.StopMonitoring();

        service.ClearHistory();
        var history = service.GetFullHistory();

        Assert.Empty(history);
    }

    [Fact]
    public async Task ThermalAlert_RaisedWhenThresholdExceeded()
    {
        var service = CreateService();
        var alertRaised = false;

        service.ThermalAlert += (_, e) =>
        {
            alertRaised = true;
            Assert.Equal(ThermalComponent.Gpu, e.Component);
        };

        _gpuProvider.SetMetrics(0, new GpuMetrics
        {
            Temperature = 95 // Above critical threshold
        });

        service.StartMonitoring(TimeSpan.FromMilliseconds(100));
        await Task.Delay(200);
        service.StopMonitoring();

        Assert.True(alertRaised);
    }

    [Fact]
    public void GetStatistics_CalculatesCorrectly()
    {
        var service = CreateService();

        // Collect some metrics
        service.StartMonitoring(TimeSpan.FromMilliseconds(100));
        Thread.Sleep(350);
        service.StopMonitoring();

        var stats = service.GetStatistics(TimeSpan.FromSeconds(10));

        Assert.True(stats.SampleCount >= 2);
        Assert.True(stats.GpuUtilization.Average > 0);
    }

    private HardwareMonitorService CreateService()
    {
        var logger = NullLogger<HardwareMonitorService>.Instance;
        var gpuFactory = new TestGpuMetricsProviderFactory(_gpuProvider);
        var cpuFactory = new TestCpuMetricsProviderFactory(_cpuProvider);

        return new HardwareMonitorService(
            logger,
            gpuFactory,
            cpuFactory,
            _memoryProvider);
    }

    private class TestGpuMetricsProviderFactory : GpuMetricsProviderFactory
    {
        private readonly IGpuMetricsProvider _provider;

        public TestGpuMetricsProviderFactory(IGpuMetricsProvider provider)
            : base(NullLoggerFactory.Instance)
        {
            _provider = provider;
        }

        public new IGpuMetricsProvider CreateProvider() => _provider;
    }

    private class TestCpuMetricsProviderFactory : CpuMetricsProviderFactory
    {
        private readonly ICpuMetricsProvider _provider;

        public TestCpuMetricsProviderFactory(ICpuMetricsProvider provider)
            : base(NullLoggerFactory.Instance)
        {
            _provider = provider;
        }

        public new ICpuMetricsProvider CreateProvider() => _provider;
    }
}
```

### File: `tests/SeniorIntern.Tests/Training/ThermalManagerTests.cs`

```csharp
namespace SeniorIntern.Tests.Training;

using Microsoft.Extensions.Logging.Abstractions;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Training.Models;
using SeniorIntern.Services.Training;
using Moq;
using Xunit;

public class ThermalManagerTests
{
    [Fact]
    public void EvaluateConditions_Normal_ReturnsContinue()
    {
        var mockMonitor = CreateMockMonitor(gpuTemp: 60, cpuTemp: 55);
        var manager = new ThermalManager(
            NullLogger<ThermalManager>.Instance,
            mockMonitor.Object);

        var action = manager.EvaluateConditions();

        Assert.Equal(ThermalAction.Continue, action);
        Assert.Equal(ThermalState.Normal, manager.CurrentState);
    }

    [Fact]
    public void EvaluateConditions_Warning_ReturnsWarningState()
    {
        var mockMonitor = CreateMockMonitor(gpuTemp: 78, cpuTemp: 55);
        var manager = new ThermalManager(
            NullLogger<ThermalManager>.Instance,
            mockMonitor.Object);

        manager.EvaluateConditions();

        Assert.Equal(ThermalState.Warning, manager.CurrentState);
    }

    [Fact]
    public void EvaluateConditions_Critical_EventuallyThrottles()
    {
        var mockMonitor = CreateMockMonitor(gpuTemp: 88, cpuTemp: 55);
        var manager = new ThermalManager(
            NullLogger<ThermalManager>.Instance,
            mockMonitor.Object,
            new ThermalPolicy { ThrottleAfterConsecutiveReadings = 2 });

        // First reading
        manager.EvaluateConditions();
        Assert.False(manager.IsThrottling);

        // Second reading - should now throttle
        manager.EvaluateConditions();
        Assert.True(manager.IsThrottling);
    }

    [Fact]
    public void EvaluateConditions_Emergency_ReturnsStop()
    {
        var mockMonitor = CreateMockMonitor(gpuTemp: 98, cpuTemp: 55);
        var manager = new ThermalManager(
            NullLogger<ThermalManager>.Instance,
            mockMonitor.Object);

        var action = manager.EvaluateConditions();

        Assert.Equal(ThermalAction.Stop, action);
        Assert.Equal(ThermalState.Emergency, manager.CurrentState);
    }

    [Fact]
    public void GetBatchSizeMultiplier_ScalesWithState()
    {
        var mockMonitor = CreateMockMonitor(gpuTemp: 60, cpuTemp: 55);
        var manager = new ThermalManager(
            NullLogger<ThermalManager>.Instance,
            mockMonitor.Object);

        Assert.Equal(1.0f, manager.GetBatchSizeMultiplier());

        // Force critical state
        mockMonitor.Setup(m => m.GetLastMetrics()).Returns(new HardwareMetrics
        {
            GpuMetrics = new[] { new GpuMetrics { Temperature = 88 } },
            CpuMetrics = new CpuMetrics { Temperature = 55 }
        });

        for (int i = 0; i < 3; i++)
            manager.EvaluateConditions();

        Assert.Equal(0.5f, manager.GetBatchSizeMultiplier());
    }

    private Mock<IHardwareMonitorService> CreateMockMonitor(float gpuTemp, float cpuTemp)
    {
        var mock = new Mock<IHardwareMonitorService>();

        mock.Setup(m => m.GetLastMetrics()).Returns(new HardwareMetrics
        {
            GpuMetrics = new[] { new GpuMetrics { Temperature = gpuTemp } },
            CpuMetrics = new CpuMetrics { Temperature = cpuTemp }
        });

        return mock;
    }
}
```

### File: `tests/SeniorIntern.Tests/Training/MemoryGuardTests.cs`

```csharp
namespace SeniorIntern.Tests.Training;

using Microsoft.Extensions.Logging.Abstractions;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Training.Models;
using SeniorIntern.Services.Training;
using Moq;
using Xunit;

public class MemoryGuardTests
{
    [Fact]
    public void CheckMemory_NormalUsage_CanContinue()
    {
        var mockMonitor = CreateMockMonitor(gpuMemoryPercent: 50, ramPercent: 60);
        var guard = new MemoryGuard(
            NullLogger<MemoryGuard>.Instance,
            mockMonitor.Object);

        var result = guard.CheckMemory();

        Assert.True(result.CanContinue);
    }

    [Fact]
    public void CheckMemory_CriticalGpuMemory_CannotContinue()
    {
        var mockMonitor = CreateMockMonitor(gpuMemoryPercent: 96, ramPercent: 60);
        var guard = new MemoryGuard(
            NullLogger<MemoryGuard>.Instance,
            mockMonitor.Object);

        var result = guard.CheckMemory();

        Assert.False(result.CanContinue);
        Assert.Equal(MemoryType.GpuVram, result.MemoryType);
        Assert.NotNull(result.Recommendation);
    }

    [Fact]
    public void GetSafeBatchSize_ReducesBatchWhenMemoryLow()
    {
        var mockMonitor = CreateMockMonitor(gpuMemoryPercent: 85, ramPercent: 60);
        var guard = new MemoryGuard(
            NullLogger<MemoryGuard>.Instance,
            mockMonitor.Object);

        var bytesPerSample = 100 * 1024 * 1024L; // 100MB per sample
        var safeBatch = guard.GetSafeBatchSize(16, bytesPerSample);

        // With 15% of 24GB available (~3.6GB) and 100MB/sample
        // Safe factor 0.8 gives ~2.88GB usable
        // That's about 28 samples max, but original was 16
        Assert.True(safeBatch <= 16);
    }

    [Fact]
    public void TryFreeMemory_ReturnsFreedAmount()
    {
        var mockMonitor = CreateMockMonitor(gpuMemoryPercent: 50, ramPercent: 60);
        var guard = new MemoryGuard(
            NullLogger<MemoryGuard>.Instance,
            mockMonitor.Object);

        var freed = guard.TryFreeMemory(aggressive: false);

        // In tests, this might be 0 or small since we're not actually using much memory
        Assert.True(freed >= 0);
    }

    private Mock<IHardwareMonitorService> CreateMockMonitor(float gpuMemoryPercent, float ramPercent)
    {
        var mock = new Mock<IHardwareMonitorService>();

        var totalGpuMemory = 24L * 1024 * 1024 * 1024;
        var usedGpuMemory = (long)(totalGpuMemory * gpuMemoryPercent / 100);

        var totalRam = 32L * 1024 * 1024 * 1024;
        var usedRam = (long)(totalRam * ramPercent / 100);

        var metrics = new HardwareMetrics
        {
            GpuMetrics = new[]
            {
                new GpuMetrics
                {
                    MemoryUsed = usedGpuMemory,
                    MemoryTotal = totalGpuMemory
                }
            },
            MemoryMetrics = new MemoryMetrics
            {
                TotalBytes = totalRam,
                UsedBytes = usedRam
            }
        };

        mock.Setup(m => m.GetLastMetrics()).Returns(metrics);
        mock.Setup(m => m.GetCurrentMetrics()).Returns(metrics);

        return mock;
    }
}
```

### File: `tests/SeniorIntern.Tests/Training/MetricsAggregatorTests.cs`

```csharp
namespace SeniorIntern.Tests.Training;

using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Training.Models;
using SeniorIntern.Services.Training;
using Xunit;

public class MetricsAggregatorTests
{
    [Fact]
    public void CalculateRollingAverage_ReturnsAveragedMetrics()
    {
        var history = CreateTestHistory(10, baseGpuUtil: 50);

        var average = MetricsAggregator.CalculateRollingAverage(
            history, TimeSpan.FromMinutes(5));

        Assert.True(average.GpuUtilization >= 45 && average.GpuUtilization <= 55);
    }

    [Fact]
    public void Downsample_ReducesToTargetSize()
    {
        var history = CreateTestHistory(100, baseGpuUtil: 50);

        var downsampled = MetricsAggregator.Downsample(history, targetSamples: 10);

        Assert.Equal(10, downsampled.Count);
    }

    [Fact]
    public void Downsample_PreservesDataWhenUnderTarget()
    {
        var history = CreateTestHistory(5, baseGpuUtil: 50);

        var downsampled = MetricsAggregator.Downsample(history, targetSamples: 10);

        Assert.Equal(5, downsampled.Count);
    }

    [Fact]
    public void CalculateTrend_DetectsIncreasing()
    {
        var history = new List<TimestampedMetrics>();
        for (int i = 0; i < 10; i++)
        {
            history.Add(new TimestampedMetrics
            {
                Timestamp = DateTime.UtcNow.AddSeconds(-10 + i),
                Metrics = new HardwareMetrics
                {
                    GpuMetrics = new[] { new GpuMetrics { Utilization = 30 + i * 5 } }
                }
            });
        }

        var trend = MetricsAggregator.CalculateTrend(
            history,
            m => m.GpuUtilization,
            TimeSpan.FromMinutes(1));

        Assert.Equal(MetricTrend.Increasing, trend);
    }

    [Fact]
    public void ExportForChart_CreatesValidChartData()
    {
        var history = CreateTestHistory(10, baseGpuUtil: 50);

        var chartData = MetricsAggregator.ExportForChart(history);

        Assert.Equal(10, chartData.TimePoints.Count);
        Assert.Equal(10, chartData.GpuUtilization.Count);
        Assert.Equal(10, chartData.CpuUtilization.Count);
    }

    [Fact]
    public void DetectAnomalies_FindsOutliers()
    {
        var history = CreateTestHistory(20, baseGpuUtil: 50);

        // Add an anomaly
        var anomalyMetrics = new HardwareMetrics
        {
            GpuMetrics = new[] { new GpuMetrics { Utilization = 100 } },
            CpuMetrics = new CpuMetrics { TotalUtilization = 25 },
            MemoryMetrics = new MemoryMetrics()
        };

        history.Add(new TimestampedMetrics
        {
            Timestamp = DateTime.UtcNow,
            Metrics = anomalyMetrics
        });

        var anomalies = MetricsAggregator.DetectAnomalies(history, zScoreThreshold: 2.0f);

        Assert.NotEmpty(anomalies);
        Assert.Contains(anomalies, a => a.MetricName == "GPU Utilization");
    }

    private List<TimestampedMetrics> CreateTestHistory(int count, float baseGpuUtil)
    {
        var history = new List<TimestampedMetrics>();
        var random = new Random(42);

        for (int i = 0; i < count; i++)
        {
            history.Add(new TimestampedMetrics
            {
                Timestamp = DateTime.UtcNow.AddSeconds(-count + i),
                Metrics = new HardwareMetrics
                {
                    GpuMetrics = new[]
                    {
                        new GpuMetrics
                        {
                            Utilization = baseGpuUtil + (float)(random.NextDouble() * 10 - 5),
                            MemoryUsed = 8L * 1024 * 1024 * 1024,
                            MemoryTotal = 24L * 1024 * 1024 * 1024,
                            Temperature = 65 + (float)(random.NextDouble() * 5)
                        }
                    },
                    CpuMetrics = new CpuMetrics
                    {
                        TotalUtilization = 25 + (float)(random.NextDouble() * 10)
                    },
                    MemoryMetrics = new MemoryMetrics
                    {
                        TotalBytes = 32L * 1024 * 1024 * 1024,
                        UsedBytes = 16L * 1024 * 1024 * 1024
                    }
                }
            });
        }

        return history;
    }
}
```

### File: `tests/SeniorIntern.Tests/Training/MetricsExporterTests.cs`

```csharp
namespace SeniorIntern.Tests.Training;

using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Training.Models;
using SeniorIntern.Services.Training;
using Xunit;

public class MetricsExporterTests
{
    [Fact]
    public void ToCsv_CreatesValidCsv()
    {
        var history = CreateTestHistory(3);

        var csv = MetricsExporter.ToCsv(history);

        Assert.Contains("Timestamp,GPU_Utilization", csv);
        Assert.Contains("50.00", csv); // GPU utilization
        var lines = csv.Split('\n', StringSplitOptions.RemoveEmptyEntries);
        Assert.Equal(4, lines.Length); // Header + 3 data rows
    }

    [Fact]
    public void ToJson_CreatesValidJson()
    {
        var history = CreateTestHistory(2);

        var json = MetricsExporter.ToJson(history);

        Assert.StartsWith("[", json);
        Assert.EndsWith("]", json);
        Assert.Contains("\"timestamp\"", json);
    }

    [Fact]
    public void ToSummaryReport_CreatesReadableReport()
    {
        var stats = new MetricsStatistics
        {
            PeriodStart = DateTime.UtcNow.AddHours(-1),
            PeriodEnd = DateTime.UtcNow,
            SampleCount = 3600,
            GpuUtilization = new ComponentStatistics
            {
                Minimum = 20,
                Maximum = 95,
                Average = 75,
                Percentile95 = 90
            },
            PeakGpuMemory = 20L * 1024 * 1024 * 1024,
            MaxGpuTemperature = 82
        };

        var report = MetricsExporter.ToSummaryReport(stats);

        Assert.Contains("Hardware Metrics Summary Report", report);
        Assert.Contains("GPU Utilization", report);
        Assert.Contains("Samples: 3600", report);
    }

    [Fact]
    public async Task SaveToFileAsync_CreatesFile()
    {
        var history = CreateTestHistory(2);
        var tempFile = Path.GetTempFileName();

        try
        {
            await MetricsExporter.SaveToFileAsync(history, tempFile, MetricsExportFormat.Csv);

            Assert.True(File.Exists(tempFile));
            var content = await File.ReadAllTextAsync(tempFile);
            Assert.Contains("GPU_Utilization", content);
        }
        finally
        {
            if (File.Exists(tempFile))
                File.Delete(tempFile);
        }
    }

    private List<TimestampedMetrics> CreateTestHistory(int count)
    {
        var history = new List<TimestampedMetrics>();

        for (int i = 0; i < count; i++)
        {
            history.Add(new TimestampedMetrics
            {
                Timestamp = DateTime.UtcNow.AddSeconds(-count + i),
                Metrics = new HardwareMetrics
                {
                    GpuMetrics = new[]
                    {
                        new GpuMetrics
                        {
                            Utilization = 50,
                            MemoryUsed = 8L * 1024 * 1024 * 1024,
                            MemoryTotal = 24L * 1024 * 1024 * 1024,
                            Temperature = 65
                        }
                    },
                    CpuMetrics = new CpuMetrics { TotalUtilization = 25 },
                    MemoryMetrics = new MemoryMetrics
                    {
                        TotalBytes = 32L * 1024 * 1024 * 1024,
                        UsedBytes = 16L * 1024 * 1024 * 1024
                    }
                }
            });
        }

        return history;
    }
}
```

---

## Dependency Injection Registration

### File: `src/SeniorIntern.Services/ServiceCollectionExtensions.cs` (Addition)

```csharp
// Add to existing ServiceCollectionExtensions.cs

/// <summary>
/// Register hardware monitoring services.
/// </summary>
public static IServiceCollection AddHardwareMonitoring(
    this IServiceCollection services,
    Action<HardwareMonitorServiceConfiguration>? configure = null)
{
    var config = new HardwareMonitorServiceConfiguration();
    configure?.Invoke(config);

    services.AddSingleton(config);
    services.AddSingleton<GpuMetricsProviderFactory>();
    services.AddSingleton<CpuMetricsProviderFactory>();
    services.AddSingleton<IMemoryMetricsProvider, MemoryMetricsProvider>();
    services.AddSingleton<IHardwareMonitorService, HardwareMonitorService>();
    services.AddSingleton<ThermalManager>();
    services.AddSingleton<MemoryGuard>();

    return services;
}
```

---

## Integration with Training Engine

The Hardware Monitoring system integrates with the training engine from v0.8.3:

```csharp
// In LoraTrainingEngine (v0.8.3)
public async Task<TrainingResult> TrainAsync(
    TrainingJob job,
    IProgress<TrainingProgress>? progress = null,
    CancellationToken cancellationToken = default)
{
    // Start hardware monitoring
    _hardwareMonitorService.StartMonitoring(TimeSpan.FromSeconds(1));

    try
    {
        for (int epoch = 0; epoch < job.Configuration.Epochs; epoch++)
        {
            foreach (var batch in dataLoader)
            {
                // Check thermal conditions
                var thermalAction = _thermalManager.EvaluateConditions();
                if (thermalAction == ThermalAction.Stop)
                {
                    throw new TrainingException("Training stopped due to thermal emergency");
                }

                if (thermalAction == ThermalAction.Throttle)
                {
                    await Task.Delay(_thermalManager.GetCoolingDelay());
                }

                // Check memory
                var memoryCheck = _memoryGuard.CheckMemory();
                if (!memoryCheck.CanContinue)
                {
                    _memoryGuard.TryFreeMemory(aggressive: true);
                }

                // Training step...
            }
        }
    }
    finally
    {
        _hardwareMonitorService.StopMonitoring();
    }
}
```

---

## Summary

v0.8.4 Hardware Monitoring provides:

1. **Comprehensive Metrics Collection**
   - GPU metrics (NVIDIA CUDA, Apple Metal)
   - CPU metrics (Windows, Linux, macOS)
   - Memory metrics (System RAM, managed heap, GC stats)

2. **Real-time Monitoring**
   - Timer-based periodic collection
   - Event-driven streaming to UI
   - Configurable collection intervals

3. **History & Analysis**
   - Timestamped metrics history
   - Statistical aggregation
   - Anomaly detection
   - Trend analysis

4. **Safety Features**
   - Thermal management with throttling
   - Memory guards against OOM
   - Automatic garbage collection

5. **Export Capabilities**
   - CSV and JSON export
   - Summary reports
   - Chart-ready data format

**Total: 29 files to create, 0 files to modify**
