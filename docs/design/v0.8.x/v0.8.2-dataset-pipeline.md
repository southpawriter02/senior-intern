# v0.8.2: Dataset Pipeline - Detailed Design Specification

## Overview

This document provides a comprehensive design specification for v0.8.2 of The Senior Intern project. This version implements the dataset preparation pipeline for code-based fine-tuning, including code scanning, symbol extraction, instruction formatting, tokenization, deduplication, and efficient batching. This pipeline transforms user code folders into properly formatted training examples for LoRA fine-tuning.

### Objectives
- Create training example models for instruction fine-tuning
- Implement code scanning and file discovery with filtering
- Build code symbol extraction using regex and AST parsing
- Generate diverse instruction templates for multiple task types
- Implement tokenization service with chat template formatting
- Add deduplication using MinHash similarity detection
- Create efficient data loaders with batching and shuffling
- Provide dataset persistence for saving/loading datasets

### Prerequisites
- v0.8.1 (Training Infrastructure) completed
- TorchSharp initialized with hardware detection
- LLamaSharp tokenizer available from v0.4.x
- Understanding of instruction-tuning data formats

---

## Architecture Overview

### Dataset Pipeline Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           User Code Folder                                   │
│                    /path/to/my-project                                       │
└─────────────────────────────────────────────────────────────────────────────┘
                                     │
                                     ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                         v0.8.2a: Code Scanner                                │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐             │
│  │ File Discovery  │  │ Pattern Filter  │  │ Language Detect │             │
│  │ (Recursive)     │→ │ (Include/Excl)  │→ │ (Extension Map) │             │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘             │
│                                                      │                       │
│                    Output: List<CodeFileInfo>        │                       │
└──────────────────────────────────────────────────────┼───────────────────────┘
                                                       │
                                                       ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                      v0.8.2c: Symbol Extractor                               │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐             │
│  │ Parse File      │  │ Extract Symbols │  │ Quality Filter  │             │
│  │ (Regex/AST)     │→ │ (Class/Method)  │→ │ (Min Lines)     │             │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘             │
│                                                      │                       │
│                    Output: List<CodeSymbol>          │                       │
└──────────────────────────────────────────────────────┼───────────────────────┘
                                                       │
                                                       ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                   v0.8.2d: Instruction Generator                             │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐             │
│  │ Select Template │  │ Format Example  │  │ Add Metadata    │             │
│  │ (Task Type)     │→ │ (Instruct/IO)   │→ │ (Source Info)   │             │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘             │
│                                                      │                       │
│                    Output: List<TrainingExample>     │                       │
└──────────────────────────────────────────────────────┼───────────────────────┘
                                                       │
                                                       ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                      v0.8.2g: Deduplication                                  │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐             │
│  │ MinHash         │  │ LSH Buckets     │  │ Remove Dups     │             │
│  │ Signature       │→ │ (Near-Dup)      │→ │ (Threshold)     │             │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘             │
│                                                      │                       │
│                    Output: List<TrainingExample>     │ (deduplicated)        │
└──────────────────────────────────────────────────────┼───────────────────────┘
                                                       │
                                                       ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                       v0.8.2f: Tokenization                                  │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐             │
│  │ Chat Template   │  │ Tokenize Text   │  │ Create Labels   │             │
│  │ (ChatML/Llama)  │→ │ (LLamaSharp)    │→ │ (Mask Instruct) │             │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘             │
│                                                      │                       │
│                    Output: List<TokenizedExample>    │                       │
└──────────────────────────────────────────────────────┼───────────────────────┘
                                                       │
                                                       ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                        v0.8.2h: Data Loader                                  │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐             │
│  │ Train/Val Split │  │ Batch Examples  │  │ Pad & Collate   │             │
│  │ (Stratified)    │→ │ (Dynamic Size)  │→ │ (Tensor)        │             │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘             │
│                                                      │                       │
│                    Output: IDataLoader               │                       │
└──────────────────────────────────────────────────────┼───────────────────────┘
                                                       │
                                                       ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                    Training Engine (v0.8.3)                                  │
│                    Consumes TrainingBatch tensors                            │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Component Dependencies

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          IDatasetService                                     │
│                       (Main Orchestrator)                                    │
│  CreateDatasetFromCodeAsync() → TokenizeDatasetAsync() → CreateDataLoaders()│
└─────────────────────────────────────────────────────────────────────────────┘
         │                    │                    │
         ▼                    ▼                    ▼
┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐
│   CodeScanner   │  │ TokenizationSvc │  │ DataLoaderFact  │
│   SymbolExtract │  │                 │  │                 │
│   InstructGen   │  │                 │  │                 │
│   Deduplicator  │  │                 │  │                 │
└─────────────────┘  └─────────────────┘  └─────────────────┘
```

---

## v0.8.2a: Training Example & Dataset Models

### Objective
Define the core data models for training examples, tokenized data, batches, and dataset containers used throughout the pipeline.

### Files to Create

#### 1. Core/Training/TrainingExample.cs

```csharp
namespace SeniorIntern.Core.Training;

/// <summary>
/// A single training example for instruction fine-tuning.
/// Follows the instruction-input-output format common for LLM fine-tuning.
/// </summary>
public sealed class TrainingExample
{
    /// <summary>
    /// Unique identifier for this example
    /// </summary>
    public Guid Id { get; init; } = Guid.NewGuid();

    /// <summary>
    /// The instruction/task description for the model
    /// Example: "Complete the following C# code:"
    /// </summary>
    public string Instruction { get; init; } = string.Empty;

    /// <summary>
    /// Optional input context (code, text, etc.)
    /// Example: The partial code to complete
    /// </summary>
    public string Input { get; init; } = string.Empty;

    /// <summary>
    /// The expected output/response
    /// Example: The completed code
    /// </summary>
    public string Output { get; init; } = string.Empty;

    /// <summary>
    /// Optional system prompt to set model behavior
    /// </summary>
    public string? SystemPrompt { get; init; }

    /// <summary>
    /// Source information for this example
    /// </summary>
    public ExampleSource Source { get; init; } = new();

    /// <summary>
    /// The type of example (completion, explanation, etc.)
    /// </summary>
    public ExampleGenerationType ExampleType { get; init; }

    /// <summary>
    /// Optional additional metadata
    /// </summary>
    public IReadOnlyDictionary<string, string>? Metadata { get; init; }

    /// <summary>
    /// Hash for deduplication purposes
    /// </summary>
    public string? ContentHash { get; init; }
}

/// <summary>
/// Source information for a training example
/// </summary>
public sealed class ExampleSource
{
    /// <summary>
    /// Path to the source file
    /// </summary>
    public string FilePath { get; init; } = string.Empty;

    /// <summary>
    /// Starting line number (1-based)
    /// </summary>
    public int StartLine { get; init; }

    /// <summary>
    /// Ending line number (1-based)
    /// </summary>
    public int EndLine { get; init; }

    /// <summary>
    /// Detected programming language
    /// </summary>
    public string? Language { get; init; }

    /// <summary>
    /// Name of the symbol (class, method, etc.)
    /// </summary>
    public string? SymbolName { get; init; }

    /// <summary>
    /// Type of the symbol
    /// </summary>
    public SymbolType? SymbolType { get; init; }
}

/// <summary>
/// Types of code symbols that can be extracted
/// </summary>
public enum SymbolType
{
    Unknown = 0,
    Class,
    Interface,
    Struct,
    Enum,
    Method,
    Function,
    Property,
    Field,
    Constructor,
    Namespace,
    Module
}

/// <summary>
/// Types of training examples to generate
/// </summary>
[Flags]
public enum ExampleGenerationType
{
    None = 0,

    /// <summary>Complete partial code</summary>
    CodeCompletion = 1,

    /// <summary>Explain what code does</summary>
    CodeExplanation = 2,

    /// <summary>Suggest code improvements</summary>
    CodeRefactoring = 4,

    /// <summary>Generate documentation</summary>
    DocstringGeneration = 8,

    /// <summary>Identify potential bugs</summary>
    BugFinding = 16,

    /// <summary>Generate unit tests</summary>
    TestGeneration = 32,

    /// <summary>Code-to-code translation</summary>
    CodeTranslation = 64,

    /// <summary>Answer questions about code</summary>
    CodeQA = 128,

    /// <summary>All example types</summary>
    All = CodeCompletion | CodeExplanation | CodeRefactoring |
          DocstringGeneration | BugFinding | TestGeneration |
          CodeTranslation | CodeQA
}
```

#### 2. Core/Training/TokenizedExample.cs

```csharp
namespace SeniorIntern.Core.Training;

/// <summary>
/// A tokenized training example ready for the model
/// </summary>
public sealed class TokenizedExample
{
    /// <summary>
    /// Token IDs for the input sequence
    /// </summary>
    public int[] InputIds { get; init; } = Array.Empty<int>();

    /// <summary>
    /// Attention mask (1 for real tokens, 0 for padding)
    /// </summary>
    public int[] AttentionMask { get; init; } = Array.Empty<int>();

    /// <summary>
    /// Labels for training (-100 for ignored tokens like instructions)
    /// </summary>
    public int[] Labels { get; init; } = Array.Empty<int>();

    /// <summary>
    /// Length of the sequence (excluding padding)
    /// </summary>
    public int SequenceLength { get; init; }

    /// <summary>
    /// Reference to the original example ID
    /// </summary>
    public Guid OriginalExampleId { get; init; }
}

/// <summary>
/// A batch of tokenized examples converted to tensors
/// </summary>
public sealed class TrainingBatch : IDisposable
{
    /// <summary>
    /// Input token IDs tensor [batch_size, seq_length]
    /// </summary>
    public torch.Tensor InputIds { get; init; } = null!;

    /// <summary>
    /// Attention mask tensor [batch_size, seq_length]
    /// </summary>
    public torch.Tensor AttentionMask { get; init; } = null!;

    /// <summary>
    /// Labels tensor [batch_size, seq_length]
    /// </summary>
    public torch.Tensor Labels { get; init; } = null!;

    /// <summary>
    /// Number of examples in this batch
    /// </summary>
    public int BatchSize { get; init; }

    /// <summary>
    /// Maximum sequence length in this batch
    /// </summary>
    public int SequenceLength { get; init; }

    /// <summary>
    /// Total number of non-padding tokens
    /// </summary>
    public int TotalTokens { get; init; }

    /// <summary>
    /// Move batch to specified device
    /// </summary>
    public TrainingBatch ToDevice(torch.Device device)
    {
        return new TrainingBatch
        {
            InputIds = InputIds.to(device),
            AttentionMask = AttentionMask.to(device),
            Labels = Labels.to(device),
            BatchSize = BatchSize,
            SequenceLength = SequenceLength,
            TotalTokens = TotalTokens
        };
    }

    public void Dispose()
    {
        InputIds?.Dispose();
        AttentionMask?.Dispose();
        Labels?.Dispose();
    }
}
```

#### 3. Core/Training/TrainingDataset.cs

```csharp
namespace SeniorIntern.Core.Training;

/// <summary>
/// Container for a training dataset with examples and metadata
/// </summary>
public sealed class TrainingDataset
{
    /// <summary>
    /// Unique identifier for this dataset
    /// </summary>
    public Guid Id { get; init; } = Guid.NewGuid();

    /// <summary>
    /// Human-readable name
    /// </summary>
    public string Name { get; init; } = string.Empty;

    /// <summary>
    /// When the dataset was created
    /// </summary>
    public DateTimeOffset CreatedAt { get; init; } = DateTimeOffset.UtcNow;

    /// <summary>
    /// Source folder path
    /// </summary>
    public string SourcePath { get; init; } = string.Empty;

    /// <summary>
    /// All training examples
    /// </summary>
    public IReadOnlyList<TrainingExample> Examples { get; init; } = Array.Empty<TrainingExample>();

    /// <summary>
    /// Dataset statistics
    /// </summary>
    public DatasetStatistics Statistics { get; init; } = new();

    /// <summary>
    /// Creation options used
    /// </summary>
    public DatasetCreationOptions Options { get; init; } = new();
}

/// <summary>
/// Container for a tokenized dataset ready for training
/// </summary>
public sealed class TokenizedDataset
{
    /// <summary>
    /// Reference to source dataset
    /// </summary>
    public Guid SourceDatasetId { get; init; }

    /// <summary>
    /// Training split examples
    /// </summary>
    public IReadOnlyList<TokenizedExample> TrainExamples { get; init; } = Array.Empty<TokenizedExample>();

    /// <summary>
    /// Validation split examples
    /// </summary>
    public IReadOnlyList<TokenizedExample> ValidationExamples { get; init; } = Array.Empty<TokenizedExample>();

    /// <summary>
    /// Tokenization options used
    /// </summary>
    public TokenizationOptions Options { get; init; } = new();

    /// <summary>
    /// Vocabulary size of the tokenizer
    /// </summary>
    public int VocabSize { get; init; }

    /// <summary>
    /// Special token IDs
    /// </summary>
    public SpecialTokenIds SpecialTokens { get; init; } = new();
}

/// <summary>
/// Special token IDs for the tokenizer
/// </summary>
public sealed class SpecialTokenIds
{
    public int PadTokenId { get; init; } = 0;
    public int BosTokenId { get; init; } = 1;
    public int EosTokenId { get; init; } = 2;
    public int UnkTokenId { get; init; } = 0;
}

/// <summary>
/// Statistics about a dataset
/// </summary>
public sealed class DatasetStatistics
{
    public int TotalExamples { get; init; }
    public int TotalTokens { get; init; }
    public int TrainExamples { get; init; }
    public int ValidationExamples { get; init; }
    public double AverageTokensPerExample { get; init; }
    public int MinSequenceLength { get; init; }
    public int MaxSequenceLength { get; init; }
    public int MedianSequenceLength { get; init; }
    public Dictionary<string, int> ExamplesByLanguage { get; init; } = new();
    public Dictionary<string, int> ExamplesByType { get; init; } = new();
    public int DuplicatesRemoved { get; init; }
    public int FilesScanned { get; init; }
    public int SymbolsExtracted { get; init; }
}
```

#### 4. Core/Training/DatasetCreationOptions.cs

```csharp
namespace SeniorIntern.Core.Training;

/// <summary>
/// Options for creating a training dataset from code
/// </summary>
public sealed class DatasetCreationOptions
{
    /// <summary>
    /// Types of training examples to generate
    /// </summary>
    public ExampleGenerationType GenerationType { get; init; } = ExampleGenerationType.All;

    /// <summary>
    /// Glob patterns for files to include
    /// </summary>
    public IReadOnlyList<string> IncludePatterns { get; init; } = new[]
    {
        "**/*.cs",    // C#
        "**/*.ts",    // TypeScript
        "**/*.tsx",   // TSX
        "**/*.js",    // JavaScript
        "**/*.jsx",   // JSX
        "**/*.py",    // Python
        "**/*.go",    // Go
        "**/*.rs",    // Rust
        "**/*.java",  // Java
        "**/*.cpp",   // C++
        "**/*.c",     // C
        "**/*.h",     // C/C++ headers
        "**/*.hpp"    // C++ headers
    };

    /// <summary>
    /// Glob patterns for files to exclude
    /// </summary>
    public IReadOnlyList<string> ExcludePatterns { get; init; } = new[]
    {
        "**/node_modules/**",
        "**/bin/**",
        "**/obj/**",
        "**/dist/**",
        "**/build/**",
        "**/.git/**",
        "**/vendor/**",
        "**/__pycache__/**",
        "**/*.min.js",
        "**/*.min.css",
        "**/*.generated.cs",
        "**/*.Designer.cs",
        "**/Migrations/**"
    };

    /// <summary>
    /// Minimum lines of code for a valid symbol
    /// </summary>
    public int MinCodeLines { get; init; } = 5;

    /// <summary>
    /// Maximum lines of code for a single example
    /// </summary>
    public int MaxCodeLines { get; init; } = 150;

    /// <summary>
    /// Whether to include comments in extracted code
    /// </summary>
    public bool IncludeComments { get; init; } = true;

    /// <summary>
    /// Whether to deduplicate similar examples
    /// </summary>
    public bool Deduplicate { get; init; } = true;

    /// <summary>
    /// Similarity threshold for deduplication (0.0-1.0)
    /// Examples above this threshold are considered duplicates
    /// </summary>
    public float DeduplicationThreshold { get; init; } = 0.85f;

    /// <summary>
    /// Maximum number of examples to generate (0 = unlimited)
    /// </summary>
    public int MaxExamples { get; init; } = 0;

    /// <summary>
    /// Random seed for reproducibility
    /// </summary>
    public int? RandomSeed { get; init; }

    /// <summary>
    /// Whether to shuffle examples after generation
    /// </summary>
    public bool Shuffle { get; init; } = true;

    /// <summary>
    /// Custom instruction templates to use (optional)
    /// Key: ExampleGenerationType name, Value: Array of template strings
    /// </summary>
    public IReadOnlyDictionary<string, string[]>? CustomTemplates { get; init; }

    /// <summary>
    /// System prompt to include with all examples (optional)
    /// </summary>
    public string? SystemPrompt { get; init; }

    /// <summary>
    /// Symbol types to extract
    /// </summary>
    public SymbolType SymbolTypesToExtract { get; init; } =
        SymbolType.Class | SymbolType.Method | SymbolType.Function | SymbolType.Interface;
}
```

### v0.8.2a File Summary

| File | Purpose | Lines (Est.) |
|------|---------|--------------|
| `Core/Training/TrainingExample.cs` | Training example and source models | ~120 |
| `Core/Training/TokenizedExample.cs` | Tokenized example and batch models | ~100 |
| `Core/Training/TrainingDataset.cs` | Dataset container and statistics | ~110 |
| `Core/Training/DatasetCreationOptions.cs` | Dataset creation configuration | ~100 |

**v0.8.2a Total: 4 files to create**

---

## v0.8.2b: Code Scanner & File Discovery

### Objective
Implement file discovery that recursively scans directories, applies include/exclude patterns, and detects programming languages for each file.

### Files to Create

#### 1. Core/Training/CodeFileInfo.cs

```csharp
namespace SeniorIntern.Core.Training;

/// <summary>
/// Information about a discovered code file
/// </summary>
public sealed class CodeFileInfo
{
    /// <summary>
    /// Full path to the file
    /// </summary>
    public string FilePath { get; init; } = string.Empty;

    /// <summary>
    /// Path relative to scan root
    /// </summary>
    public string RelativePath { get; init; } = string.Empty;

    /// <summary>
    /// Detected programming language
    /// </summary>
    public string Language { get; init; } = string.Empty;

    /// <summary>
    /// File extension (including dot)
    /// </summary>
    public string Extension { get; init; } = string.Empty;

    /// <summary>
    /// File size in bytes
    /// </summary>
    public long SizeBytes { get; init; }

    /// <summary>
    /// Number of lines in the file
    /// </summary>
    public int LineCount { get; init; }

    /// <summary>
    /// Last modified timestamp
    /// </summary>
    public DateTimeOffset LastModified { get; init; }

    /// <summary>
    /// Whether file passed quality checks
    /// </summary>
    public bool IsValid { get; init; } = true;

    /// <summary>
    /// Reason for invalidity if IsValid is false
    /// </summary>
    public string? InvalidReason { get; init; }
}

/// <summary>
/// Result of a code scanning operation
/// </summary>
public sealed class CodeScanResult
{
    /// <summary>
    /// Root path that was scanned
    /// </summary>
    public string RootPath { get; init; } = string.Empty;

    /// <summary>
    /// All discovered valid files
    /// </summary>
    public IReadOnlyList<CodeFileInfo> Files { get; init; } = Array.Empty<CodeFileInfo>();

    /// <summary>
    /// Files that were skipped
    /// </summary>
    public IReadOnlyList<CodeFileInfo> SkippedFiles { get; init; } = Array.Empty<CodeFileInfo>();

    /// <summary>
    /// Total files found before filtering
    /// </summary>
    public int TotalFilesFound { get; init; }

    /// <summary>
    /// Files excluded by pattern
    /// </summary>
    public int FilesExcludedByPattern { get; init; }

    /// <summary>
    /// Files excluded by size/content checks
    /// </summary>
    public int FilesExcludedByQuality { get; init; }

    /// <summary>
    /// Time taken to scan
    /// </summary>
    public TimeSpan ScanDuration { get; init; }

    /// <summary>
    /// Count by language
    /// </summary>
    public Dictionary<string, int> FilesByLanguage { get; init; } = new();
}
```

#### 2. Services/Training/LanguageDetector.cs

```csharp
namespace SeniorIntern.Services.Training;

/// <summary>
/// Detects programming language from file extension
/// </summary>
public sealed class LanguageDetector
{
    private static readonly Dictionary<string, string> ExtensionToLanguage = new(StringComparer.OrdinalIgnoreCase)
    {
        // C#
        [".cs"] = "csharp",
        [".csx"] = "csharp",

        // TypeScript/JavaScript
        [".ts"] = "typescript",
        [".tsx"] = "typescript",
        [".js"] = "javascript",
        [".jsx"] = "javascript",
        [".mjs"] = "javascript",
        [".cjs"] = "javascript",

        // Python
        [".py"] = "python",
        [".pyw"] = "python",
        [".pyi"] = "python",

        // Go
        [".go"] = "go",

        // Rust
        [".rs"] = "rust",

        // Java
        [".java"] = "java",

        // Kotlin
        [".kt"] = "kotlin",
        [".kts"] = "kotlin",

        // C/C++
        [".c"] = "c",
        [".h"] = "c",
        [".cpp"] = "cpp",
        [".cc"] = "cpp",
        [".cxx"] = "cpp",
        [".hpp"] = "cpp",
        [".hxx"] = "cpp",

        // Ruby
        [".rb"] = "ruby",
        [".rake"] = "ruby",

        // PHP
        [".php"] = "php",

        // Swift
        [".swift"] = "swift",

        // Scala
        [".scala"] = "scala",
        [".sc"] = "scala",

        // Shell
        [".sh"] = "shell",
        [".bash"] = "shell",
        [".zsh"] = "shell",

        // PowerShell
        [".ps1"] = "powershell",
        [".psm1"] = "powershell",

        // SQL
        [".sql"] = "sql",

        // Lua
        [".lua"] = "lua",

        // Dart
        [".dart"] = "dart",

        // F#
        [".fs"] = "fsharp",
        [".fsx"] = "fsharp",

        // VB.NET
        [".vb"] = "vbnet"
    };

    private static readonly HashSet<string> SupportedLanguages = new(StringComparer.OrdinalIgnoreCase)
    {
        "csharp", "typescript", "javascript", "python", "go", "rust",
        "java", "kotlin", "c", "cpp", "ruby", "php", "swift", "scala",
        "shell", "powershell", "sql", "lua", "dart", "fsharp", "vbnet"
    };

    /// <summary>
    /// Detect language from file extension
    /// </summary>
    public string? DetectLanguage(string filePath)
    {
        var extension = Path.GetExtension(filePath);
        if (string.IsNullOrEmpty(extension))
            return null;

        return ExtensionToLanguage.TryGetValue(extension, out var language)
            ? language
            : null;
    }

    /// <summary>
    /// Check if a language is supported for training
    /// </summary>
    public bool IsLanguageSupported(string language)
    {
        return SupportedLanguages.Contains(language);
    }

    /// <summary>
    /// Get all supported file extensions
    /// </summary>
    public IReadOnlyList<string> GetSupportedExtensions()
    {
        return ExtensionToLanguage.Keys.ToList();
    }

    /// <summary>
    /// Get comment syntax for a language
    /// </summary>
    public (string? SingleLine, string? MultiLineStart, string? MultiLineEnd) GetCommentSyntax(string language)
    {
        return language.ToLowerInvariant() switch
        {
            "csharp" or "java" or "kotlin" or "cpp" or "c" or "go" or
            "rust" or "swift" or "scala" or "dart" or "javascript" or "typescript"
                => ("//", "/*", "*/"),
            "python" or "ruby" or "shell" or "powershell"
                => ("#", "'''", "'''"),
            "lua"
                => ("--", "--[[", "]]"),
            "sql"
                => ("--", "/*", "*/"),
            "fsharp"
                => ("//", "(*", "*)"),
            "vbnet"
                => ("'", null, null),
            "php"
                => ("//", "/*", "*/"),
            _ => (null, null, null)
        };
    }
}
```

#### 3. Services/Training/CodeScanner.cs

```csharp
namespace SeniorIntern.Services.Training;

using Microsoft.Extensions.FileSystemGlobbing;
using Microsoft.Extensions.FileSystemGlobbing.Abstractions;

/// <summary>
/// Scans directories for code files matching specified patterns
/// </summary>
public sealed class CodeScanner
{
    private readonly ILogger<CodeScanner> _logger;
    private readonly LanguageDetector _languageDetector;

    // Size limits
    private const long MaxFileSizeBytes = 1024 * 1024; // 1MB
    private const int MaxLineCount = 10000;
    private const int MinLineCount = 3;

    public CodeScanner(ILogger<CodeScanner> logger)
    {
        _logger = logger;
        _languageDetector = new LanguageDetector();
    }

    /// <summary>
    /// Scan a directory for code files
    /// </summary>
    public async Task<CodeScanResult> ScanDirectoryAsync(
        string rootPath,
        DatasetCreationOptions options,
        IProgress<CodeScanProgress>? progress = null,
        CancellationToken ct = default)
    {
        var stopwatch = Stopwatch.StartNew();

        if (!Directory.Exists(rootPath))
        {
            throw new DirectoryNotFoundException($"Directory not found: {rootPath}");
        }

        rootPath = Path.GetFullPath(rootPath);

        _logger.LogInformation("Scanning directory: {Path}", rootPath);

        // Build glob matcher
        var matcher = new Matcher();
        foreach (var pattern in options.IncludePatterns)
        {
            matcher.AddInclude(pattern);
        }
        foreach (var pattern in options.ExcludePatterns)
        {
            matcher.AddExclude(pattern);
        }

        // Find matching files
        var directoryInfo = new DirectoryInfoWrapper(new DirectoryInfo(rootPath));
        var matchResult = matcher.Execute(directoryInfo);

        var allFiles = matchResult.Files.Select(f => f.Path).ToList();
        var totalFiles = allFiles.Count;

        _logger.LogInformation("Found {Count} files matching patterns", totalFiles);

        var validFiles = new List<CodeFileInfo>();
        var skippedFiles = new List<CodeFileInfo>();
        var filesByLanguage = new Dictionary<string, int>();
        var excludedByPattern = 0;
        var excludedByQuality = 0;
        var processedCount = 0;

        // Process files in parallel with limited concurrency
        var semaphore = new SemaphoreSlim(Environment.ProcessorCount * 2);
        var tasks = allFiles.Select(async relativePath =>
        {
            await semaphore.WaitAsync(ct);
            try
            {
                ct.ThrowIfCancellationRequested();

                var fullPath = Path.Combine(rootPath, relativePath);
                var fileInfo = await ProcessFileAsync(fullPath, relativePath, options, ct);

                Interlocked.Increment(ref processedCount);
                progress?.Report(new CodeScanProgress
                {
                    CurrentFile = relativePath,
                    FilesProcessed = processedCount,
                    TotalFiles = totalFiles,
                    ValidFilesFound = validFiles.Count
                });

                return fileInfo;
            }
            finally
            {
                semaphore.Release();
            }
        });

        var results = await Task.WhenAll(tasks);

        foreach (var fileInfo in results.Where(f => f != null))
        {
            if (fileInfo!.IsValid)
            {
                validFiles.Add(fileInfo);
                var lang = fileInfo.Language;
                filesByLanguage[lang] = filesByLanguage.GetValueOrDefault(lang) + 1;
            }
            else
            {
                skippedFiles.Add(fileInfo);
                if (fileInfo.InvalidReason?.Contains("pattern") == true)
                    excludedByPattern++;
                else
                    excludedByQuality++;
            }
        }

        stopwatch.Stop();

        _logger.LogInformation(
            "Scan complete: {Valid} valid files, {Skipped} skipped in {Duration:F2}s",
            validFiles.Count, skippedFiles.Count, stopwatch.Elapsed.TotalSeconds);

        return new CodeScanResult
        {
            RootPath = rootPath,
            Files = validFiles.OrderBy(f => f.FilePath).ToList(),
            SkippedFiles = skippedFiles,
            TotalFilesFound = totalFiles,
            FilesExcludedByPattern = excludedByPattern,
            FilesExcludedByQuality = excludedByQuality,
            ScanDuration = stopwatch.Elapsed,
            FilesByLanguage = filesByLanguage
        };
    }

    private async Task<CodeFileInfo?> ProcessFileAsync(
        string fullPath,
        string relativePath,
        DatasetCreationOptions options,
        CancellationToken ct)
    {
        try
        {
            var info = new FileInfo(fullPath);
            if (!info.Exists)
                return null;

            // Size check
            if (info.Length > MaxFileSizeBytes)
            {
                return new CodeFileInfo
                {
                    FilePath = fullPath,
                    RelativePath = relativePath,
                    Extension = info.Extension,
                    SizeBytes = info.Length,
                    IsValid = false,
                    InvalidReason = $"File too large ({info.Length / 1024}KB > {MaxFileSizeBytes / 1024}KB)"
                };
            }

            // Language detection
            var language = _languageDetector.DetectLanguage(fullPath);
            if (language == null)
            {
                return new CodeFileInfo
                {
                    FilePath = fullPath,
                    RelativePath = relativePath,
                    Extension = info.Extension,
                    SizeBytes = info.Length,
                    IsValid = false,
                    InvalidReason = "Unknown language/extension"
                };
            }

            // Read and count lines
            var content = await File.ReadAllTextAsync(fullPath, ct);
            var lineCount = content.Count(c => c == '\n') + 1;

            // Line count checks
            if (lineCount < MinLineCount)
            {
                return new CodeFileInfo
                {
                    FilePath = fullPath,
                    RelativePath = relativePath,
                    Extension = info.Extension,
                    Language = language,
                    SizeBytes = info.Length,
                    LineCount = lineCount,
                    LastModified = info.LastWriteTimeUtc,
                    IsValid = false,
                    InvalidReason = $"Too few lines ({lineCount} < {MinLineCount})"
                };
            }

            if (lineCount > MaxLineCount)
            {
                return new CodeFileInfo
                {
                    FilePath = fullPath,
                    RelativePath = relativePath,
                    Extension = info.Extension,
                    Language = language,
                    SizeBytes = info.Length,
                    LineCount = lineCount,
                    LastModified = info.LastWriteTimeUtc,
                    IsValid = false,
                    InvalidReason = $"Too many lines ({lineCount} > {MaxLineCount})"
                };
            }

            // Check for binary content
            if (IsBinaryContent(content))
            {
                return new CodeFileInfo
                {
                    FilePath = fullPath,
                    RelativePath = relativePath,
                    Extension = info.Extension,
                    Language = language,
                    SizeBytes = info.Length,
                    IsValid = false,
                    InvalidReason = "Binary or non-text content detected"
                };
            }

            return new CodeFileInfo
            {
                FilePath = fullPath,
                RelativePath = relativePath,
                Extension = info.Extension,
                Language = language,
                SizeBytes = info.Length,
                LineCount = lineCount,
                LastModified = info.LastWriteTimeUtc,
                IsValid = true
            };
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Error processing file: {Path}", fullPath);
            return new CodeFileInfo
            {
                FilePath = fullPath,
                RelativePath = relativePath,
                IsValid = false,
                InvalidReason = $"Error: {ex.Message}"
            };
        }
    }

    private static bool IsBinaryContent(string content)
    {
        // Check for null bytes or high ratio of non-printable characters
        var nonPrintable = content.Count(c => c < 32 && c != '\n' && c != '\r' && c != '\t');
        return nonPrintable > content.Length * 0.1; // More than 10% non-printable
    }
}

/// <summary>
/// Progress information for code scanning
/// </summary>
public sealed class CodeScanProgress
{
    public string CurrentFile { get; init; } = string.Empty;
    public int FilesProcessed { get; init; }
    public int TotalFiles { get; init; }
    public int ValidFilesFound { get; init; }
    public double PercentComplete => TotalFiles > 0 ? (double)FilesProcessed / TotalFiles * 100 : 0;
}
```

### v0.8.2b File Summary

| File | Purpose | Lines (Est.) |
|------|---------|--------------|
| `Core/Training/CodeFileInfo.cs` | File info and scan result models | ~90 |
| `Services/Training/LanguageDetector.cs` | Programming language detection | ~140 |
| `Services/Training/CodeScanner.cs` | Directory scanning with patterns | ~220 |

**v0.8.2b Total: 3 files to create**

---

## v0.8.2c: Code Symbol Extractor

### Objective
Extract meaningful code symbols (classes, methods, functions) from source files using a combination of regex patterns and optional AST parsing for supported languages.

### Files to Create

#### 1. Core/Training/CodeSymbol.cs

```csharp
namespace SeniorIntern.Core.Training;

/// <summary>
/// Represents an extracted code symbol (class, method, function, etc.)
/// </summary>
public sealed class CodeSymbol
{
    /// <summary>
    /// Unique identifier
    /// </summary>
    public Guid Id { get; init; } = Guid.NewGuid();

    /// <summary>
    /// Name of the symbol
    /// </summary>
    public string Name { get; init; } = string.Empty;

    /// <summary>
    /// Full qualified name (e.g., Namespace.Class.Method)
    /// </summary>
    public string FullName { get; init; } = string.Empty;

    /// <summary>
    /// Type of symbol
    /// </summary>
    public SymbolType SymbolType { get; init; }

    /// <summary>
    /// The actual code content
    /// </summary>
    public string Content { get; init; } = string.Empty;

    /// <summary>
    /// Source file path
    /// </summary>
    public string FilePath { get; init; } = string.Empty;

    /// <summary>
    /// Starting line number (1-based)
    /// </summary>
    public int StartLine { get; init; }

    /// <summary>
    /// Ending line number (1-based)
    /// </summary>
    public int EndLine { get; init; }

    /// <summary>
    /// Starting column (0-based)
    /// </summary>
    public int StartColumn { get; init; }

    /// <summary>
    /// Ending column (0-based)
    /// </summary>
    public int EndColumn { get; init; }

    /// <summary>
    /// Programming language
    /// </summary>
    public string Language { get; init; } = string.Empty;

    /// <summary>
    /// Number of lines of code
    /// </summary>
    public int LineCount => EndLine - StartLine + 1;

    /// <summary>
    /// Documentation comment if present
    /// </summary>
    public string? Documentation { get; init; }

    /// <summary>
    /// Parent symbol (e.g., class for a method)
    /// </summary>
    public string? ParentName { get; init; }

    /// <summary>
    /// Access modifier (public, private, etc.)
    /// </summary>
    public string? AccessModifier { get; init; }

    /// <summary>
    /// Method/function signature if applicable
    /// </summary>
    public string? Signature { get; init; }

    /// <summary>
    /// Return type if applicable
    /// </summary>
    public string? ReturnType { get; init; }

    /// <summary>
    /// Parameters if method/function
    /// </summary>
    public IReadOnlyList<ParameterInfo>? Parameters { get; init; }
}

/// <summary>
/// Parameter information for methods/functions
/// </summary>
public sealed class ParameterInfo
{
    public string Name { get; init; } = string.Empty;
    public string Type { get; init; } = string.Empty;
    public string? DefaultValue { get; init; }
    public bool IsOptional { get; init; }
}

/// <summary>
/// Result of symbol extraction for a file
/// </summary>
public sealed class SymbolExtractionResult
{
    public string FilePath { get; init; } = string.Empty;
    public string Language { get; init; } = string.Empty;
    public IReadOnlyList<CodeSymbol> Symbols { get; init; } = Array.Empty<CodeSymbol>();
    public int TotalSymbolsFound { get; init; }
    public int SymbolsFiltered { get; init; }
    public TimeSpan ExtractionTime { get; init; }
    public bool UsedAstParsing { get; init; }
    public string? Error { get; init; }
}
```

#### 2. Core/Interfaces/ICodeSymbolExtractor.cs

```csharp
namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Interface for extracting code symbols from source files
/// </summary>
public interface ICodeSymbolExtractor
{
    /// <summary>
    /// Languages this extractor supports
    /// </summary>
    IReadOnlyList<string> SupportedLanguages { get; }

    /// <summary>
    /// Extract symbols from a file
    /// </summary>
    Task<SymbolExtractionResult> ExtractSymbolsAsync(
        string filePath,
        string content,
        string language,
        SymbolExtractionOptions options,
        CancellationToken ct = default);

    /// <summary>
    /// Check if this extractor can handle a language
    /// </summary>
    bool CanExtract(string language);
}

/// <summary>
/// Options for symbol extraction
/// </summary>
public sealed class SymbolExtractionOptions
{
    /// <summary>
    /// Types of symbols to extract
    /// </summary>
    public SymbolType TypesToExtract { get; init; } =
        SymbolType.Class | SymbolType.Method | SymbolType.Function | SymbolType.Interface;

    /// <summary>
    /// Minimum lines of code for a symbol
    /// </summary>
    public int MinLines { get; init; } = 5;

    /// <summary>
    /// Maximum lines of code for a symbol
    /// </summary>
    public int MaxLines { get; init; } = 150;

    /// <summary>
    /// Whether to extract nested symbols (methods in classes)
    /// </summary>
    public bool ExtractNested { get; init; } = true;

    /// <summary>
    /// Whether to include documentation comments
    /// </summary>
    public bool IncludeDocumentation { get; init; } = true;

    /// <summary>
    /// Whether to use AST parsing when available
    /// </summary>
    public bool PreferAstParsing { get; init; } = true;
}
```

#### 3. Services/Training/RegexSymbolExtractor.cs

```csharp
namespace SeniorIntern.Services.Training;

/// <summary>
/// Regex-based symbol extractor that works for all supported languages
/// </summary>
public sealed class RegexSymbolExtractor : ICodeSymbolExtractor
{
    private readonly ILogger<RegexSymbolExtractor> _logger;

    public IReadOnlyList<string> SupportedLanguages { get; } = new[]
    {
        "csharp", "java", "kotlin", "typescript", "javascript",
        "python", "go", "rust", "cpp", "c", "swift", "scala"
    };

    public RegexSymbolExtractor(ILogger<RegexSymbolExtractor> logger)
    {
        _logger = logger;
    }

    public bool CanExtract(string language)
    {
        return SupportedLanguages.Contains(language, StringComparer.OrdinalIgnoreCase);
    }

    public async Task<SymbolExtractionResult> ExtractSymbolsAsync(
        string filePath,
        string content,
        string language,
        SymbolExtractionOptions options,
        CancellationToken ct = default)
    {
        var stopwatch = Stopwatch.StartNew();
        var symbols = new List<CodeSymbol>();
        var filtered = 0;

        try
        {
            var patterns = GetPatternsForLanguage(language);
            var lines = content.Split('\n');

            foreach (var (symbolType, pattern) in patterns)
            {
                if (!options.TypesToExtract.HasFlag(symbolType))
                    continue;

                var matches = pattern.Matches(content);

                foreach (Match match in matches)
                {
                    ct.ThrowIfCancellationRequested();

                    // Find line numbers
                    var startPos = match.Index;
                    var startLine = content.Take(startPos).Count(c => c == '\n') + 1;

                    // Find the end of the symbol (matching braces)
                    var (endLine, symbolContent) = ExtractSymbolContent(
                        lines, startLine - 1, language);

                    var lineCount = endLine - startLine + 1;

                    // Apply filters
                    if (lineCount < options.MinLines)
                    {
                        filtered++;
                        continue;
                    }

                    if (lineCount > options.MaxLines)
                    {
                        filtered++;
                        continue;
                    }

                    var name = ExtractName(match, symbolType, language);
                    var documentation = options.IncludeDocumentation
                        ? ExtractDocumentation(lines, startLine - 1, language)
                        : null;

                    symbols.Add(new CodeSymbol
                    {
                        Name = name,
                        FullName = name, // Could be enhanced with namespace detection
                        SymbolType = symbolType,
                        Content = symbolContent,
                        FilePath = filePath,
                        StartLine = startLine,
                        EndLine = endLine,
                        Language = language,
                        Documentation = documentation,
                        AccessModifier = ExtractAccessModifier(match, language),
                        Signature = ExtractSignature(match, symbolType)
                    });
                }
            }

            stopwatch.Stop();

            return new SymbolExtractionResult
            {
                FilePath = filePath,
                Language = language,
                Symbols = symbols,
                TotalSymbolsFound = symbols.Count + filtered,
                SymbolsFiltered = filtered,
                ExtractionTime = stopwatch.Elapsed,
                UsedAstParsing = false
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error extracting symbols from {File}", filePath);
            return new SymbolExtractionResult
            {
                FilePath = filePath,
                Language = language,
                Symbols = Array.Empty<CodeSymbol>(),
                Error = ex.Message,
                ExtractionTime = stopwatch.Elapsed
            };
        }
    }

    private static Dictionary<SymbolType, Regex> GetPatternsForLanguage(string language)
    {
        return language.ToLowerInvariant() switch
        {
            "csharp" => new Dictionary<SymbolType, Regex>
            {
                [SymbolType.Class] = new Regex(
                    @"(?:public|private|internal|protected)?\s*(?:sealed|abstract|static|partial)?\s*class\s+(\w+)",
                    RegexOptions.Compiled),
                [SymbolType.Interface] = new Regex(
                    @"(?:public|private|internal|protected)?\s*interface\s+(\w+)",
                    RegexOptions.Compiled),
                [SymbolType.Method] = new Regex(
                    @"(?:public|private|internal|protected)\s+(?:static\s+)?(?:async\s+)?(?:virtual\s+)?(?:override\s+)?(?:\w+(?:<[^>]+>)?)\s+(\w+)\s*\([^)]*\)",
                    RegexOptions.Compiled),
                [SymbolType.Struct] = new Regex(
                    @"(?:public|private|internal|protected)?\s*(?:readonly\s+)?struct\s+(\w+)",
                    RegexOptions.Compiled),
                [SymbolType.Enum] = new Regex(
                    @"(?:public|private|internal|protected)?\s*enum\s+(\w+)",
                    RegexOptions.Compiled)
            },

            "typescript" or "javascript" => new Dictionary<SymbolType, Regex>
            {
                [SymbolType.Class] = new Regex(
                    @"(?:export\s+)?(?:abstract\s+)?class\s+(\w+)",
                    RegexOptions.Compiled),
                [SymbolType.Interface] = new Regex(
                    @"(?:export\s+)?interface\s+(\w+)",
                    RegexOptions.Compiled),
                [SymbolType.Function] = new Regex(
                    @"(?:export\s+)?(?:async\s+)?function\s+(\w+)\s*\([^)]*\)",
                    RegexOptions.Compiled),
                [SymbolType.Method] = new Regex(
                    @"(?:public|private|protected)?\s*(?:static\s+)?(?:async\s+)?(\w+)\s*\([^)]*\)\s*(?::\s*\w+)?\s*\{",
                    RegexOptions.Compiled)
            },

            "python" => new Dictionary<SymbolType, Regex>
            {
                [SymbolType.Class] = new Regex(
                    @"^class\s+(\w+)\s*(?:\([^)]*\))?:",
                    RegexOptions.Compiled | RegexOptions.Multiline),
                [SymbolType.Function] = new Regex(
                    @"^(?:async\s+)?def\s+(\w+)\s*\([^)]*\)\s*(?:->\s*[^:]+)?:",
                    RegexOptions.Compiled | RegexOptions.Multiline)
            },

            "go" => new Dictionary<SymbolType, Regex>
            {
                [SymbolType.Struct] = new Regex(
                    @"type\s+(\w+)\s+struct\s*\{",
                    RegexOptions.Compiled),
                [SymbolType.Interface] = new Regex(
                    @"type\s+(\w+)\s+interface\s*\{",
                    RegexOptions.Compiled),
                [SymbolType.Function] = new Regex(
                    @"func\s+(?:\([^)]+\)\s+)?(\w+)\s*\([^)]*\)",
                    RegexOptions.Compiled)
            },

            "rust" => new Dictionary<SymbolType, Regex>
            {
                [SymbolType.Struct] = new Regex(
                    @"(?:pub\s+)?struct\s+(\w+)",
                    RegexOptions.Compiled),
                [SymbolType.Enum] = new Regex(
                    @"(?:pub\s+)?enum\s+(\w+)",
                    RegexOptions.Compiled),
                [SymbolType.Function] = new Regex(
                    @"(?:pub\s+)?(?:async\s+)?fn\s+(\w+)\s*(?:<[^>]+>)?\s*\([^)]*\)",
                    RegexOptions.Compiled)
            },

            "java" => new Dictionary<SymbolType, Regex>
            {
                [SymbolType.Class] = new Regex(
                    @"(?:public|private|protected)?\s*(?:abstract|final)?\s*class\s+(\w+)",
                    RegexOptions.Compiled),
                [SymbolType.Interface] = new Regex(
                    @"(?:public|private|protected)?\s*interface\s+(\w+)",
                    RegexOptions.Compiled),
                [SymbolType.Method] = new Regex(
                    @"(?:public|private|protected)\s+(?:static\s+)?(?:synchronized\s+)?(?:\w+(?:<[^>]+>)?)\s+(\w+)\s*\([^)]*\)",
                    RegexOptions.Compiled)
            },

            _ => new Dictionary<SymbolType, Regex>()
        };
    }

    private static (int EndLine, string Content) ExtractSymbolContent(
        string[] lines, int startIndex, string language)
    {
        var useBraces = language is not "python";

        if (useBraces)
        {
            return ExtractBraceDelimited(lines, startIndex);
        }
        else
        {
            return ExtractIndentDelimited(lines, startIndex);
        }
    }

    private static (int EndLine, string Content) ExtractBraceDelimited(
        string[] lines, int startIndex)
    {
        var braceCount = 0;
        var started = false;
        var endIndex = startIndex;

        for (int i = startIndex; i < lines.Length; i++)
        {
            foreach (char c in lines[i])
            {
                if (c == '{')
                {
                    braceCount++;
                    started = true;
                }
                else if (c == '}')
                {
                    braceCount--;
                    if (started && braceCount == 0)
                    {
                        endIndex = i;
                        var content = string.Join('\n', lines.Skip(startIndex).Take(endIndex - startIndex + 1));
                        return (endIndex + 1, content); // 1-based line number
                    }
                }
            }
        }

        // Fallback: take a reasonable number of lines
        endIndex = Math.Min(startIndex + 50, lines.Length - 1);
        return (endIndex + 1, string.Join('\n', lines.Skip(startIndex).Take(endIndex - startIndex + 1)));
    }

    private static (int EndLine, string Content) ExtractIndentDelimited(
        string[] lines, int startIndex)
    {
        if (startIndex >= lines.Length)
            return (startIndex + 1, string.Empty);

        // Get base indentation of the definition line
        var baseIndent = GetIndentation(lines[startIndex]);
        var endIndex = startIndex;

        for (int i = startIndex + 1; i < lines.Length; i++)
        {
            var line = lines[i];

            // Skip empty lines
            if (string.IsNullOrWhiteSpace(line))
            {
                endIndex = i;
                continue;
            }

            var indent = GetIndentation(line);

            // If we hit a line with same or less indentation, we're done
            if (indent <= baseIndent && !string.IsNullOrWhiteSpace(line.Trim()))
            {
                break;
            }

            endIndex = i;
        }

        var content = string.Join('\n', lines.Skip(startIndex).Take(endIndex - startIndex + 1));
        return (endIndex + 1, content); // 1-based line number
    }

    private static int GetIndentation(string line)
    {
        var count = 0;
        foreach (var c in line)
        {
            if (c == ' ') count++;
            else if (c == '\t') count += 4;
            else break;
        }
        return count;
    }

    private static string ExtractName(Match match, SymbolType type, string language)
    {
        // Group 1 typically contains the name in our patterns
        return match.Groups.Count > 1 ? match.Groups[1].Value : match.Value;
    }

    private static string? ExtractDocumentation(string[] lines, int symbolLineIndex, string language)
    {
        // Look backwards for documentation comments
        var docLines = new List<string>();

        for (int i = symbolLineIndex - 1; i >= 0 && i >= symbolLineIndex - 20; i--)
        {
            var line = lines[i].Trim();

            if (language is "csharp" or "java" or "kotlin")
            {
                if (line.StartsWith("///") || line.StartsWith("/**") ||
                    line.StartsWith("*") || line.StartsWith("*/"))
                {
                    docLines.Insert(0, line);
                }
                else if (!string.IsNullOrEmpty(line) && !line.StartsWith("[") && !line.StartsWith("@"))
                {
                    break;
                }
            }
            else if (language is "python")
            {
                if (line.StartsWith("#") || line.StartsWith("\"\"\"") || line.StartsWith("'''"))
                {
                    docLines.Insert(0, line);
                }
                else if (!string.IsNullOrEmpty(line))
                {
                    break;
                }
            }
            else if (line.StartsWith("//") || line.StartsWith("/*"))
            {
                docLines.Insert(0, line);
            }
            else if (!string.IsNullOrEmpty(line))
            {
                break;
            }
        }

        return docLines.Count > 0 ? string.Join('\n', docLines) : null;
    }

    private static string? ExtractAccessModifier(Match match, string language)
    {
        var text = match.Value.ToLowerInvariant();

        if (text.Contains("public")) return "public";
        if (text.Contains("private")) return "private";
        if (text.Contains("protected")) return "protected";
        if (text.Contains("internal")) return "internal";
        if (language == "python" && text.Contains("_")) return "private";

        return null;
    }

    private static string? ExtractSignature(Match match, SymbolType type)
    {
        if (type is SymbolType.Method or SymbolType.Function)
        {
            return match.Value.Trim();
        }
        return null;
    }
}
```

#### 4. Services/Training/RoslynSymbolExtractor.cs

```csharp
namespace SeniorIntern.Services.Training;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

/// <summary>
/// Roslyn-based AST symbol extractor for C# files
/// Provides more accurate extraction than regex
/// </summary>
public sealed class RoslynSymbolExtractor : ICodeSymbolExtractor
{
    private readonly ILogger<RoslynSymbolExtractor> _logger;

    public IReadOnlyList<string> SupportedLanguages { get; } = new[] { "csharp" };

    public RoslynSymbolExtractor(ILogger<RoslynSymbolExtractor> logger)
    {
        _logger = logger;
    }

    public bool CanExtract(string language)
    {
        return language.Equals("csharp", StringComparison.OrdinalIgnoreCase);
    }

    public async Task<SymbolExtractionResult> ExtractSymbolsAsync(
        string filePath,
        string content,
        string language,
        SymbolExtractionOptions options,
        CancellationToken ct = default)
    {
        var stopwatch = Stopwatch.StartNew();
        var symbols = new List<CodeSymbol>();
        var filtered = 0;

        try
        {
            var tree = CSharpSyntaxTree.ParseText(content, cancellationToken: ct);
            var root = await tree.GetRootAsync(ct);
            var lines = content.Split('\n');

            // Extract classes
            if (options.TypesToExtract.HasFlag(SymbolType.Class))
            {
                var classes = root.DescendantNodes()
                    .OfType<ClassDeclarationSyntax>();

                foreach (var classDecl in classes)
                {
                    var symbol = ExtractClassSymbol(classDecl, filePath, lines, options);
                    if (symbol != null)
                    {
                        if (symbol.LineCount >= options.MinLines && symbol.LineCount <= options.MaxLines)
                            symbols.Add(symbol);
                        else
                            filtered++;
                    }
                }
            }

            // Extract interfaces
            if (options.TypesToExtract.HasFlag(SymbolType.Interface))
            {
                var interfaces = root.DescendantNodes()
                    .OfType<InterfaceDeclarationSyntax>();

                foreach (var interfaceDecl in interfaces)
                {
                    var symbol = ExtractInterfaceSymbol(interfaceDecl, filePath, lines, options);
                    if (symbol != null)
                    {
                        if (symbol.LineCount >= options.MinLines && symbol.LineCount <= options.MaxLines)
                            symbols.Add(symbol);
                        else
                            filtered++;
                    }
                }
            }

            // Extract methods
            if (options.TypesToExtract.HasFlag(SymbolType.Method))
            {
                var methods = root.DescendantNodes()
                    .OfType<MethodDeclarationSyntax>();

                foreach (var methodDecl in methods)
                {
                    var symbol = ExtractMethodSymbol(methodDecl, filePath, lines, options);
                    if (symbol != null)
                    {
                        if (symbol.LineCount >= options.MinLines && symbol.LineCount <= options.MaxLines)
                            symbols.Add(symbol);
                        else
                            filtered++;
                    }
                }
            }

            // Extract structs
            if (options.TypesToExtract.HasFlag(SymbolType.Struct))
            {
                var structs = root.DescendantNodes()
                    .OfType<StructDeclarationSyntax>();

                foreach (var structDecl in structs)
                {
                    var symbol = ExtractStructSymbol(structDecl, filePath, lines, options);
                    if (symbol != null)
                    {
                        if (symbol.LineCount >= options.MinLines && symbol.LineCount <= options.MaxLines)
                            symbols.Add(symbol);
                        else
                            filtered++;
                    }
                }
            }

            stopwatch.Stop();

            return new SymbolExtractionResult
            {
                FilePath = filePath,
                Language = language,
                Symbols = symbols,
                TotalSymbolsFound = symbols.Count + filtered,
                SymbolsFiltered = filtered,
                ExtractionTime = stopwatch.Elapsed,
                UsedAstParsing = true
            };
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Roslyn parsing failed for {File}, falling back", filePath);
            return new SymbolExtractionResult
            {
                FilePath = filePath,
                Language = language,
                Symbols = Array.Empty<CodeSymbol>(),
                Error = ex.Message,
                ExtractionTime = stopwatch.Elapsed,
                UsedAstParsing = true
            };
        }
    }

    private CodeSymbol? ExtractClassSymbol(
        ClassDeclarationSyntax classDecl,
        string filePath,
        string[] lines,
        SymbolExtractionOptions options)
    {
        var span = classDecl.GetLocation().GetLineSpan();
        var startLine = span.StartLinePosition.Line + 1;
        var endLine = span.EndLinePosition.Line + 1;

        var content = classDecl.ToFullString();
        var documentation = options.IncludeDocumentation
            ? ExtractXmlDocumentation(classDecl)
            : null;

        return new CodeSymbol
        {
            Name = classDecl.Identifier.Text,
            FullName = GetFullName(classDecl),
            SymbolType = SymbolType.Class,
            Content = content,
            FilePath = filePath,
            StartLine = startLine,
            EndLine = endLine,
            Language = "csharp",
            Documentation = documentation,
            AccessModifier = GetAccessModifier(classDecl.Modifiers)
        };
    }

    private CodeSymbol? ExtractInterfaceSymbol(
        InterfaceDeclarationSyntax interfaceDecl,
        string filePath,
        string[] lines,
        SymbolExtractionOptions options)
    {
        var span = interfaceDecl.GetLocation().GetLineSpan();
        var startLine = span.StartLinePosition.Line + 1;
        var endLine = span.EndLinePosition.Line + 1;

        var content = interfaceDecl.ToFullString();
        var documentation = options.IncludeDocumentation
            ? ExtractXmlDocumentation(interfaceDecl)
            : null;

        return new CodeSymbol
        {
            Name = interfaceDecl.Identifier.Text,
            FullName = GetFullName(interfaceDecl),
            SymbolType = SymbolType.Interface,
            Content = content,
            FilePath = filePath,
            StartLine = startLine,
            EndLine = endLine,
            Language = "csharp",
            Documentation = documentation,
            AccessModifier = GetAccessModifier(interfaceDecl.Modifiers)
        };
    }

    private CodeSymbol? ExtractMethodSymbol(
        MethodDeclarationSyntax methodDecl,
        string filePath,
        string[] lines,
        SymbolExtractionOptions options)
    {
        var span = methodDecl.GetLocation().GetLineSpan();
        var startLine = span.StartLinePosition.Line + 1;
        var endLine = span.EndLinePosition.Line + 1;

        var content = methodDecl.ToFullString();
        var documentation = options.IncludeDocumentation
            ? ExtractXmlDocumentation(methodDecl)
            : null;

        var parentClass = methodDecl.Ancestors()
            .OfType<TypeDeclarationSyntax>()
            .FirstOrDefault();

        var parameters = methodDecl.ParameterList.Parameters
            .Select(p => new ParameterInfo
            {
                Name = p.Identifier.Text,
                Type = p.Type?.ToString() ?? "object",
                DefaultValue = p.Default?.Value.ToString(),
                IsOptional = p.Default != null
            })
            .ToList();

        return new CodeSymbol
        {
            Name = methodDecl.Identifier.Text,
            FullName = parentClass != null
                ? $"{GetFullName(parentClass)}.{methodDecl.Identifier.Text}"
                : methodDecl.Identifier.Text,
            SymbolType = SymbolType.Method,
            Content = content,
            FilePath = filePath,
            StartLine = startLine,
            EndLine = endLine,
            Language = "csharp",
            Documentation = documentation,
            ParentName = parentClass?.Identifier.Text,
            AccessModifier = GetAccessModifier(methodDecl.Modifiers),
            Signature = $"{methodDecl.ReturnType} {methodDecl.Identifier}{methodDecl.ParameterList}",
            ReturnType = methodDecl.ReturnType.ToString(),
            Parameters = parameters
        };
    }

    private CodeSymbol? ExtractStructSymbol(
        StructDeclarationSyntax structDecl,
        string filePath,
        string[] lines,
        SymbolExtractionOptions options)
    {
        var span = structDecl.GetLocation().GetLineSpan();
        var startLine = span.StartLinePosition.Line + 1;
        var endLine = span.EndLinePosition.Line + 1;

        var content = structDecl.ToFullString();
        var documentation = options.IncludeDocumentation
            ? ExtractXmlDocumentation(structDecl)
            : null;

        return new CodeSymbol
        {
            Name = structDecl.Identifier.Text,
            FullName = GetFullName(structDecl),
            SymbolType = SymbolType.Struct,
            Content = content,
            FilePath = filePath,
            StartLine = startLine,
            EndLine = endLine,
            Language = "csharp",
            Documentation = documentation,
            AccessModifier = GetAccessModifier(structDecl.Modifiers)
        };
    }

    private static string GetFullName(TypeDeclarationSyntax typeDecl)
    {
        var names = new List<string> { typeDecl.Identifier.Text };

        var parent = typeDecl.Parent;
        while (parent != null)
        {
            if (parent is NamespaceDeclarationSyntax ns)
            {
                names.Insert(0, ns.Name.ToString());
            }
            else if (parent is FileScopedNamespaceDeclarationSyntax fsNs)
            {
                names.Insert(0, fsNs.Name.ToString());
            }
            else if (parent is TypeDeclarationSyntax parentType)
            {
                names.Insert(0, parentType.Identifier.Text);
            }
            parent = parent.Parent;
        }

        return string.Join(".", names);
    }

    private static string? GetAccessModifier(SyntaxTokenList modifiers)
    {
        if (modifiers.Any(SyntaxKind.PublicKeyword)) return "public";
        if (modifiers.Any(SyntaxKind.PrivateKeyword)) return "private";
        if (modifiers.Any(SyntaxKind.ProtectedKeyword)) return "protected";
        if (modifiers.Any(SyntaxKind.InternalKeyword)) return "internal";
        return null;
    }

    private static string? ExtractXmlDocumentation(SyntaxNode node)
    {
        var trivia = node.GetLeadingTrivia()
            .Where(t => t.IsKind(SyntaxKind.SingleLineDocumentationCommentTrivia) ||
                       t.IsKind(SyntaxKind.MultiLineDocumentationCommentTrivia))
            .Select(t => t.ToFullString())
            .ToList();

        return trivia.Count > 0 ? string.Join("", trivia).Trim() : null;
    }
}
```

#### 5. Services/Training/SymbolExtractorFactory.cs

```csharp
namespace SeniorIntern.Services.Training;

/// <summary>
/// Factory for creating appropriate symbol extractors based on language
/// </summary>
public sealed class SymbolExtractorFactory
{
    private readonly IServiceProvider _serviceProvider;
    private readonly ILogger<SymbolExtractorFactory> _logger;

    public SymbolExtractorFactory(
        IServiceProvider serviceProvider,
        ILogger<SymbolExtractorFactory> logger)
    {
        _serviceProvider = serviceProvider;
        _logger = logger;
    }

    /// <summary>
    /// Get the best extractor for a language
    /// </summary>
    public ICodeSymbolExtractor GetExtractor(string language, bool preferAst = true)
    {
        if (preferAst)
        {
            // Try to get AST-based extractor first
            if (language.Equals("csharp", StringComparison.OrdinalIgnoreCase))
            {
                var roslyn = _serviceProvider.GetService<RoslynSymbolExtractor>();
                if (roslyn != null)
                {
                    _logger.LogDebug("Using Roslyn extractor for C#");
                    return roslyn;
                }
            }

            // Add more AST extractors here (e.g., Tree-sitter based)
        }

        // Fall back to regex extractor
        var regex = _serviceProvider.GetRequiredService<RegexSymbolExtractor>();
        _logger.LogDebug("Using Regex extractor for {Language}", language);
        return regex;
    }

    /// <summary>
    /// Extract symbols from a file, automatically selecting the best extractor
    /// </summary>
    public async Task<SymbolExtractionResult> ExtractFromFileAsync(
        CodeFileInfo fileInfo,
        string content,
        SymbolExtractionOptions options,
        CancellationToken ct = default)
    {
        var extractor = GetExtractor(fileInfo.Language, options.PreferAstParsing);

        var result = await extractor.ExtractSymbolsAsync(
            fileInfo.FilePath,
            content,
            fileInfo.Language,
            options,
            ct);

        // If AST extraction failed, try regex fallback
        if (result.Error != null && options.PreferAstParsing)
        {
            _logger.LogWarning(
                "AST extraction failed for {File}, trying regex fallback",
                fileInfo.FilePath);

            var regexExtractor = _serviceProvider.GetRequiredService<RegexSymbolExtractor>();
            result = await regexExtractor.ExtractSymbolsAsync(
                fileInfo.FilePath,
                content,
                fileInfo.Language,
                options,
                ct);
        }

        return result;
    }
}
```

### v0.8.2c File Summary

| File | Purpose | Lines (Est.) |
|------|---------|--------------|
| `Core/Training/CodeSymbol.cs` | Code symbol model | ~120 |
| `Core/Interfaces/ICodeSymbolExtractor.cs` | Extractor interface and options | ~60 |
| `Services/Training/RegexSymbolExtractor.cs` | Regex-based extraction | ~350 |
| `Services/Training/RoslynSymbolExtractor.cs` | Roslyn AST extraction for C# | ~280 |
| `Services/Training/SymbolExtractorFactory.cs` | Factory for extractor selection | ~80 |

**v0.8.2c Total: 5 files to create**

---

## v0.8.2d: Instruction Template Generator

### Objective
Generate diverse training examples from extracted code symbols using various instruction templates for different task types (completion, explanation, documentation, etc.).

### Files to Create

#### 1. Services/Training/InstructionTemplateGenerator.cs

```csharp
namespace SeniorIntern.Services.Training;

/// <summary>
/// Generates training examples from code symbols using instruction templates
/// </summary>
public sealed class InstructionTemplateGenerator
{
    private readonly ILogger<InstructionTemplateGenerator> _logger;
    private readonly Random _random;

    public InstructionTemplateGenerator(ILogger<InstructionTemplateGenerator> logger)
    {
        _logger = logger;
        _random = new Random();
    }

    public InstructionTemplateGenerator(
        ILogger<InstructionTemplateGenerator> logger,
        int seed)
    {
        _logger = logger;
        _random = new Random(seed);
    }

    /// <summary>
    /// Generate training examples from a code symbol
    /// </summary>
    public IEnumerable<TrainingExample> GenerateExamples(
        CodeSymbol symbol,
        ExampleGenerationType types,
        GenerationOptions? options = null)
    {
        options ??= new GenerationOptions();

        foreach (ExampleGenerationType type in Enum.GetValues<ExampleGenerationType>())
        {
            if (type == ExampleGenerationType.None ||
                type == ExampleGenerationType.All ||
                !types.HasFlag(type))
                continue;

            var example = GenerateExample(symbol, type, options);
            if (example != null)
            {
                yield return example;
            }
        }
    }

    private TrainingExample? GenerateExample(
        CodeSymbol symbol,
        ExampleGenerationType type,
        GenerationOptions options)
    {
        var templates = GetTemplatesForType(type, symbol.Language, options.CustomTemplates);
        if (templates.Length == 0)
            return null;

        var template = templates[_random.Next(templates.Length)];
        var instruction = FormatTemplate(template, symbol);

        var (input, output) = type switch
        {
            ExampleGenerationType.CodeCompletion => GenerateCompletionPair(symbol),
            ExampleGenerationType.CodeExplanation => GenerateExplanationPair(symbol),
            ExampleGenerationType.CodeRefactoring => GenerateRefactoringPair(symbol),
            ExampleGenerationType.DocstringGeneration => GenerateDocstringPair(symbol),
            ExampleGenerationType.BugFinding => GenerateBugFindingPair(symbol),
            ExampleGenerationType.TestGeneration => GenerateTestPair(symbol),
            ExampleGenerationType.CodeTranslation => GenerateTranslationPair(symbol),
            ExampleGenerationType.CodeQA => GenerateQAPair(symbol),
            _ => (null, null)
        };

        if (string.IsNullOrEmpty(input) || string.IsNullOrEmpty(output))
            return null;

        return new TrainingExample
        {
            Instruction = instruction,
            Input = input,
            Output = output,
            SystemPrompt = options.SystemPrompt,
            ExampleType = type,
            Source = new ExampleSource
            {
                FilePath = symbol.FilePath,
                StartLine = symbol.StartLine,
                EndLine = symbol.EndLine,
                Language = symbol.Language,
                SymbolName = symbol.Name,
                SymbolType = symbol.SymbolType
            },
            ContentHash = ComputeContentHash(input, output)
        };
    }

    private static string[] GetTemplatesForType(
        ExampleGenerationType type,
        string language,
        IReadOnlyDictionary<string, string[]>? customTemplates)
    {
        // Check for custom templates first
        var typeName = type.ToString();
        if (customTemplates?.TryGetValue(typeName, out var custom) == true)
            return custom;

        return type switch
        {
            ExampleGenerationType.CodeCompletion => new[]
            {
                $"Complete the following {language} code:",
                $"Finish implementing this {language} code:",
                "Continue writing the code below:",
                $"Write the rest of this {language} function/method:",
                "Complete the implementation:"
            },

            ExampleGenerationType.CodeExplanation => new[]
            {
                $"Explain what this {language} code does:",
                "Describe the purpose and behavior of this code:",
                $"What does the following {language} code do?",
                "Analyze this code and explain its functionality:",
                "Provide a clear explanation of this code:"
            },

            ExampleGenerationType.CodeRefactoring => new[]
            {
                $"Refactor this {language} code to improve readability:",
                "Suggest improvements for this code:",
                $"Optimize and clean up this {language} code:",
                "Refactor this code following best practices:",
                "Improve the code quality of the following:"
            },

            ExampleGenerationType.DocstringGeneration => new[]
            {
                $"Write documentation for this {language} code:",
                "Generate comprehensive documentation comments:",
                $"Add proper documentation to this {language} function/class:",
                "Write a detailed docstring for the following code:",
                "Document this code with clear comments:"
            },

            ExampleGenerationType.BugFinding => new[]
            {
                $"Find potential bugs or issues in this {language} code:",
                "Review this code and identify any problems:",
                "What bugs or edge cases might this code have?",
                "Analyze this code for potential issues:",
                "Identify any errors or vulnerabilities in this code:"
            },

            ExampleGenerationType.TestGeneration => new[]
            {
                $"Write unit tests for this {language} code:",
                "Generate comprehensive test cases:",
                $"Create tests to verify this {language} function works correctly:",
                "Write test methods covering edge cases:",
                "Generate a test suite for the following code:"
            },

            ExampleGenerationType.CodeTranslation => new[]
            {
                "Translate this code to a more idiomatic style:",
                "Rewrite this code using modern language features:",
                "Convert this code to follow project conventions:",
                "Transform this code to be more maintainable:",
                "Modernize the following code:"
            },

            ExampleGenerationType.CodeQA => new[]
            {
                "Answer questions about this code:",
                "What is the purpose of this code?",
                "How would you use this code?",
                "Explain the key parts of this implementation:",
                "What are the inputs and outputs of this code?"
            },

            _ => Array.Empty<string>()
        };
    }

    private static string FormatTemplate(string template, CodeSymbol symbol)
    {
        return template
            .Replace("{language}", symbol.Language)
            .Replace("{name}", symbol.Name)
            .Replace("{type}", symbol.SymbolType.ToString().ToLower());
    }

    private (string? Input, string? Output) GenerateCompletionPair(CodeSymbol symbol)
    {
        var lines = symbol.Content.Split('\n');
        if (lines.Length < 4)
            return (null, null);

        // Split roughly in the middle
        var splitPoint = lines.Length / 2;

        // Try to split at a logical point (after a complete statement)
        for (int i = splitPoint - 1; i < Math.Min(splitPoint + 3, lines.Length - 1); i++)
        {
            var line = lines[i].TrimEnd();
            if (line.EndsWith(";") || line.EndsWith("{") || line.EndsWith(":"))
            {
                splitPoint = i + 1;
                break;
            }
        }

        var input = string.Join('\n', lines.Take(splitPoint));
        var output = string.Join('\n', lines.Skip(splitPoint));

        // Add a hint for completion
        input += "\n// TODO: Complete the implementation";

        return (input, output);
    }

    private (string? Input, string? Output) GenerateExplanationPair(CodeSymbol symbol)
    {
        var explanation = GenerateExplanation(symbol);
        return (symbol.Content, explanation);
    }

    private string GenerateExplanation(CodeSymbol symbol)
    {
        var purpose = InferPurpose(symbol.Name);

        var sb = new StringBuilder();

        sb.AppendLine($"This {symbol.Language} {symbol.SymbolType.ToString().ToLower()} `{symbol.Name}` {purpose}.");
        sb.AppendLine();

        if (symbol.Documentation != null)
        {
            sb.AppendLine("According to the documentation:");
            sb.AppendLine(CleanDocumentation(symbol.Documentation));
            sb.AppendLine();
        }

        if (symbol.Parameters?.Count > 0)
        {
            sb.AppendLine("Parameters:");
            foreach (var param in symbol.Parameters)
            {
                sb.AppendLine($"- `{param.Name}` ({param.Type}): {InferParameterPurpose(param.Name)}");
            }
            sb.AppendLine();
        }

        if (symbol.ReturnType != null && symbol.ReturnType != "void")
        {
            sb.AppendLine($"Returns: {symbol.ReturnType} - {InferReturnPurpose(symbol.Name, symbol.ReturnType)}");
        }

        return sb.ToString().Trim();
    }

    private (string? Input, string? Output) GenerateRefactoringPair(CodeSymbol symbol)
    {
        // For training data, we use the same code as both input and output
        // In production, this could be enhanced with actual refactoring suggestions
        var suggestions = GenerateRefactoringSuggestions(symbol);
        return (symbol.Content, $"// Refactoring suggestions:\n{suggestions}\n\n{symbol.Content}");
    }

    private string GenerateRefactoringSuggestions(CodeSymbol symbol)
    {
        var suggestions = new List<string>();

        if (symbol.LineCount > 50)
            suggestions.Add("- Consider breaking this into smaller methods");

        if (symbol.Name.Length < 3)
            suggestions.Add("- Use a more descriptive name");

        if (symbol.Documentation == null)
            suggestions.Add("- Add documentation comments");

        if (!symbol.AccessModifier?.Equals("public", StringComparison.OrdinalIgnoreCase) == true &&
            symbol.SymbolType is SymbolType.Method or SymbolType.Function)
            suggestions.Add("- Consider making this public if it needs to be accessed externally");

        if (suggestions.Count == 0)
            suggestions.Add("- Code looks well-structured");

        return string.Join('\n', suggestions);
    }

    private (string? Input, string? Output) GenerateDocstringPair(CodeSymbol symbol)
    {
        var docstring = GenerateDocstring(symbol);
        return (symbol.Content, $"{docstring}\n{symbol.Content}");
    }

    private string GenerateDocstring(CodeSymbol symbol)
    {
        return symbol.Language.ToLowerInvariant() switch
        {
            "csharp" => GenerateCSharpDoc(symbol),
            "python" => GeneratePythonDoc(symbol),
            "typescript" or "javascript" => GenerateJsDoc(symbol),
            "java" => GenerateJavaDoc(symbol),
            "go" => GenerateGoDoc(symbol),
            _ => $"/// <summary>\n/// {symbol.Name}\n/// </summary>"
        };
    }

    private string GenerateCSharpDoc(CodeSymbol symbol)
    {
        var sb = new StringBuilder();
        sb.AppendLine($"/// <summary>");
        sb.AppendLine($"/// {InferPurpose(symbol.Name).Capitalize()}.");
        sb.AppendLine($"/// </summary>");

        if (symbol.Parameters?.Count > 0)
        {
            foreach (var param in symbol.Parameters)
            {
                sb.AppendLine($"/// <param name=\"{param.Name}\">{InferParameterPurpose(param.Name)}.</param>");
            }
        }

        if (symbol.ReturnType != null && symbol.ReturnType != "void")
        {
            sb.AppendLine($"/// <returns>{InferReturnPurpose(symbol.Name, symbol.ReturnType)}.</returns>");
        }

        return sb.ToString().TrimEnd();
    }

    private string GeneratePythonDoc(CodeSymbol symbol)
    {
        var sb = new StringBuilder();
        sb.AppendLine($"\"\"\"");
        sb.AppendLine($"{InferPurpose(symbol.Name).Capitalize()}.");
        sb.AppendLine();

        if (symbol.Parameters?.Count > 0)
        {
            sb.AppendLine("Args:");
            foreach (var param in symbol.Parameters)
            {
                sb.AppendLine($"    {param.Name}: {InferParameterPurpose(param.Name)}");
            }
            sb.AppendLine();
        }

        if (symbol.ReturnType != null && symbol.ReturnType != "None")
        {
            sb.AppendLine("Returns:");
            sb.AppendLine($"    {InferReturnPurpose(symbol.Name, symbol.ReturnType)}");
        }

        sb.AppendLine("\"\"\"");
        return sb.ToString().TrimEnd();
    }

    private string GenerateJsDoc(CodeSymbol symbol)
    {
        var sb = new StringBuilder();
        sb.AppendLine("/**");
        sb.AppendLine($" * {InferPurpose(symbol.Name).Capitalize()}.");

        if (symbol.Parameters?.Count > 0)
        {
            foreach (var param in symbol.Parameters)
            {
                sb.AppendLine($" * @param {{{param.Type}}} {param.Name} - {InferParameterPurpose(param.Name)}");
            }
        }

        if (symbol.ReturnType != null && symbol.ReturnType != "void")
        {
            sb.AppendLine($" * @returns {{{symbol.ReturnType}}} {InferReturnPurpose(symbol.Name, symbol.ReturnType)}");
        }

        sb.AppendLine(" */");
        return sb.ToString().TrimEnd();
    }

    private string GenerateJavaDoc(CodeSymbol symbol)
    {
        var sb = new StringBuilder();
        sb.AppendLine("/**");
        sb.AppendLine($" * {InferPurpose(symbol.Name).Capitalize()}.");
        sb.AppendLine(" *");

        if (symbol.Parameters?.Count > 0)
        {
            foreach (var param in symbol.Parameters)
            {
                sb.AppendLine($" * @param {param.Name} {InferParameterPurpose(param.Name)}");
            }
        }

        if (symbol.ReturnType != null && symbol.ReturnType != "void")
        {
            sb.AppendLine($" * @return {InferReturnPurpose(symbol.Name, symbol.ReturnType)}");
        }

        sb.AppendLine(" */");
        return sb.ToString().TrimEnd();
    }

    private string GenerateGoDoc(CodeSymbol symbol)
    {
        return $"// {symbol.Name} {InferPurpose(symbol.Name)}.";
    }

    private (string? Input, string? Output) GenerateBugFindingPair(CodeSymbol symbol)
    {
        var analysis = PerformStaticAnalysis(symbol);
        return (symbol.Content, analysis);
    }

    private string PerformStaticAnalysis(CodeSymbol symbol)
    {
        var issues = new List<string>();
        var content = symbol.Content;

        // Simple static analysis checks
        if (content.Contains("catch (Exception") || content.Contains("catch(Exception"))
            issues.Add("- Catching generic Exception may hide specific errors");

        if (content.Contains("// TODO") || content.Contains("// FIXME"))
            issues.Add("- Contains TODO/FIXME comments indicating incomplete work");

        if (content.Contains("throw new Exception(") && !content.Contains("throw new"))
            issues.Add("- Consider using a more specific exception type");

        if (Regex.IsMatch(content, @"\bcatch\s*\(\s*\)") || content.Contains("catch {}"))
            issues.Add("- Empty catch block silently swallows exceptions");

        if (content.Contains("null!"))
            issues.Add("- Null-forgiving operator may hide null reference issues");

        if (content.Contains("Thread.Sleep"))
            issues.Add("- Thread.Sleep blocks the thread; consider async/await");

        if (symbol.Language == "csharp" && content.Contains("async void"))
            issues.Add("- async void methods cannot be awaited and may cause unhandled exceptions");

        if (issues.Count == 0)
        {
            return "No obvious bugs or issues found in this code. The code appears to be well-structured.";
        }

        var sb = new StringBuilder();
        sb.AppendLine("Potential issues found:");
        sb.AppendLine();
        foreach (var issue in issues)
        {
            sb.AppendLine(issue);
        }

        return sb.ToString().Trim();
    }

    private (string? Input, string? Output) GenerateTestPair(CodeSymbol symbol)
    {
        var testCode = GenerateTestSkeleton(symbol);
        return (symbol.Content, testCode);
    }

    private string GenerateTestSkeleton(CodeSymbol symbol)
    {
        return symbol.Language.ToLowerInvariant() switch
        {
            "csharp" => GenerateCSharpTests(symbol),
            "python" => GeneratePythonTests(symbol),
            "typescript" or "javascript" => GenerateTypeScriptTests(symbol),
            "java" => GenerateJavaTests(symbol),
            "go" => GenerateGoTests(symbol),
            _ => "// TODO: Implement tests"
        };
    }

    private string GenerateCSharpTests(CodeSymbol symbol)
    {
        var sb = new StringBuilder();
        var testClassName = $"{symbol.Name}Tests";
        var methodName = symbol.SymbolType == SymbolType.Method ? symbol.Name : "Execute";

        sb.AppendLine($"public class {testClassName}");
        sb.AppendLine("{");
        sb.AppendLine($"    [Fact]");
        sb.AppendLine($"    public void {methodName}_WithValidInput_ReturnsExpectedResult()");
        sb.AppendLine("    {");
        sb.AppendLine("        // Arrange");
        sb.AppendLine("        ");
        sb.AppendLine("        // Act");
        sb.AppendLine("        ");
        sb.AppendLine("        // Assert");
        sb.AppendLine("        Assert.True(false, \"Test not yet implemented\");");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine($"    [Fact]");
        sb.AppendLine($"    public void {methodName}_WithNullInput_ThrowsArgumentNullException()");
        sb.AppendLine("    {");
        sb.AppendLine("        // Arrange");
        sb.AppendLine("        ");
        sb.AppendLine("        // Act & Assert");
        sb.AppendLine("        Assert.Throws<ArgumentNullException>(() => { });");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine($"    [Theory]");
        sb.AppendLine($"    [InlineData(\"input1\", \"expected1\")]");
        sb.AppendLine($"    [InlineData(\"input2\", \"expected2\")]");
        sb.AppendLine($"    public void {methodName}_WithVariousInputs_ReturnsCorrectResults(string input, string expected)");
        sb.AppendLine("    {");
        sb.AppendLine("        // Test implementation");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private string GeneratePythonTests(CodeSymbol symbol)
    {
        var funcName = ToSnakeCase(symbol.Name);
        var sb = new StringBuilder();

        sb.AppendLine("import pytest");
        sb.AppendLine();
        sb.AppendLine($"class Test{symbol.Name}:");
        sb.AppendLine($"    def test_{funcName}_with_valid_input(self):");
        sb.AppendLine("        # Arrange");
        sb.AppendLine("        ");
        sb.AppendLine("        # Act");
        sb.AppendLine("        ");
        sb.AppendLine("        # Assert");
        sb.AppendLine("        assert False, \"Test not yet implemented\"");
        sb.AppendLine();
        sb.AppendLine($"    def test_{funcName}_with_none_raises_error(self):");
        sb.AppendLine("        with pytest.raises(ValueError):");
        sb.AppendLine("            pass  # Call function with None");
        sb.AppendLine();
        sb.AppendLine($"    @pytest.mark.parametrize(\"input_val,expected\", [");
        sb.AppendLine("        (\"input1\", \"expected1\"),");
        sb.AppendLine("        (\"input2\", \"expected2\"),");
        sb.AppendLine("    ])");
        sb.AppendLine($"    def test_{funcName}_parametrized(self, input_val, expected):");
        sb.AppendLine("        # Test implementation");
        sb.AppendLine("        pass");

        return sb.ToString();
    }

    private string GenerateTypeScriptTests(CodeSymbol symbol)
    {
        var sb = new StringBuilder();

        sb.AppendLine($"describe('{symbol.Name}', () => {{");
        sb.AppendLine($"    it('should work with valid input', () => {{");
        sb.AppendLine("        // Arrange");
        sb.AppendLine("        ");
        sb.AppendLine("        // Act");
        sb.AppendLine("        ");
        sb.AppendLine("        // Assert");
        sb.AppendLine("        expect(true).toBe(false); // TODO: Implement");
        sb.AppendLine("    });");
        sb.AppendLine();
        sb.AppendLine($"    it('should throw on null input', () => {{");
        sb.AppendLine("        expect(() => {");
        sb.AppendLine("            // Call with null");
        sb.AppendLine("        }).toThrow();");
        sb.AppendLine("    });");
        sb.AppendLine();
        sb.AppendLine($"    it.each([");
        sb.AppendLine("        ['input1', 'expected1'],");
        sb.AppendLine("        ['input2', 'expected2'],");
        sb.AppendLine("    ])('should return %s for input %s', (input, expected) => {");
        sb.AppendLine("        // Test implementation");
        sb.AppendLine("    });");
        sb.AppendLine("});");

        return sb.ToString();
    }

    private string GenerateJavaTests(CodeSymbol symbol)
    {
        var sb = new StringBuilder();

        sb.AppendLine($"public class {symbol.Name}Test {{");
        sb.AppendLine();
        sb.AppendLine("    @Test");
        sb.AppendLine($"    public void {ToLowerCamelCase(symbol.Name)}_withValidInput_returnsExpected() {{");
        sb.AppendLine("        // Arrange");
        sb.AppendLine("        ");
        sb.AppendLine("        // Act");
        sb.AppendLine("        ");
        sb.AppendLine("        // Assert");
        sb.AppendLine("        fail(\"Not yet implemented\");");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    @Test(expected = IllegalArgumentException.class)");
        sb.AppendLine($"    public void {ToLowerCamelCase(symbol.Name)}_withNullInput_throwsException() {{");
        sb.AppendLine("        // Call with null");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private string GenerateGoTests(CodeSymbol symbol)
    {
        var sb = new StringBuilder();

        sb.AppendLine($"func Test{symbol.Name}(t *testing.T) {{");
        sb.AppendLine("    tests := []struct {");
        sb.AppendLine("        name     string");
        sb.AppendLine("        input    string");
        sb.AppendLine("        expected string");
        sb.AppendLine("    }{");
        sb.AppendLine("        {\"valid input\", \"input\", \"expected\"},");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    for _, tt := range tests {");
        sb.AppendLine("        t.Run(tt.name, func(t *testing.T) {");
        sb.AppendLine("            // Test implementation");
        sb.AppendLine("        })");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private (string? Input, string? Output) GenerateTranslationPair(CodeSymbol symbol)
    {
        // Generate modernized/idiomatic version hints
        var hints = $"// Modernized version with improved readability\n{symbol.Content}";
        return (symbol.Content, hints);
    }

    private (string? Input, string? Output) GenerateQAPair(CodeSymbol symbol)
    {
        var qa = GenerateQA(symbol);
        return (symbol.Content, qa);
    }

    private string GenerateQA(CodeSymbol symbol)
    {
        var sb = new StringBuilder();

        sb.AppendLine($"Q: What is the purpose of `{symbol.Name}`?");
        sb.AppendLine($"A: This {symbol.SymbolType.ToString().ToLower()} {InferPurpose(symbol.Name)}.");
        sb.AppendLine();

        if (symbol.Parameters?.Count > 0)
        {
            sb.AppendLine("Q: What parameters does it accept?");
            sb.Append("A: It accepts ");
            sb.AppendLine(string.Join(", ", symbol.Parameters.Select(p => $"`{p.Name}` ({p.Type})")));
            sb.AppendLine();
        }

        if (symbol.ReturnType != null && symbol.ReturnType != "void")
        {
            sb.AppendLine("Q: What does it return?");
            sb.AppendLine($"A: It returns {symbol.ReturnType} - {InferReturnPurpose(symbol.Name, symbol.ReturnType)}.");
        }

        return sb.ToString().Trim();
    }

    // Helper methods

    private static string InferPurpose(string name)
    {
        var lower = name.ToLower();

        if (lower.StartsWith("get") || lower.StartsWith("fetch") || lower.StartsWith("load"))
            return "retrieves data";
        if (lower.StartsWith("set") || lower.StartsWith("update"))
            return "updates or modifies data";
        if (lower.StartsWith("create") || lower.StartsWith("add") || lower.StartsWith("insert"))
            return "creates a new instance or adds data";
        if (lower.StartsWith("delete") || lower.StartsWith("remove") || lower.StartsWith("clear"))
            return "removes or deletes data";
        if (lower.StartsWith("is") || lower.StartsWith("has") || lower.StartsWith("can"))
            return "checks a condition and returns a boolean";
        if (lower.StartsWith("validate") || lower.StartsWith("check") || lower.StartsWith("verify"))
            return "validates input or state";
        if (lower.StartsWith("parse") || lower.StartsWith("convert") || lower.StartsWith("transform"))
            return "converts or transforms data";
        if (lower.StartsWith("save") || lower.StartsWith("write") || lower.StartsWith("store"))
            return "persists data";
        if (lower.StartsWith("find") || lower.StartsWith("search") || lower.StartsWith("query"))
            return "searches for data";
        if (lower.StartsWith("calculate") || lower.StartsWith("compute"))
            return "performs a calculation";
        if (lower.StartsWith("handle") || lower.StartsWith("process"))
            return "processes or handles data";
        if (lower.StartsWith("init") || lower.StartsWith("setup"))
            return "initializes or sets up the system";
        if (lower.StartsWith("dispose") || lower.StartsWith("cleanup"))
            return "cleans up resources";
        if (lower.StartsWith("notify") || lower.StartsWith("send") || lower.StartsWith("emit"))
            return "sends notifications or events";
        if (lower.StartsWith("render") || lower.StartsWith("display") || lower.StartsWith("show"))
            return "renders or displays output";

        return "performs an operation";
    }

    private static string InferParameterPurpose(string paramName)
    {
        var lower = paramName.ToLower();

        if (lower.Contains("id")) return "The identifier";
        if (lower.Contains("name")) return "The name";
        if (lower.Contains("path")) return "The file or resource path";
        if (lower.Contains("options") || lower.Contains("config")) return "Configuration options";
        if (lower.Contains("callback") || lower.Contains("handler")) return "Callback function";
        if (lower.Contains("token")) return "Cancellation or authentication token";
        if (lower.Contains("count") || lower.Contains("size") || lower.Contains("length")) return "The count or size";
        if (lower.Contains("data") || lower.Contains("content")) return "The data to process";
        if (lower.Contains("source")) return "The source";
        if (lower.Contains("target") || lower.Contains("dest")) return "The destination";
        if (lower.Contains("ct") || lower == "cancellationtoken") return "Cancellation token for async operations";

        return $"The {paramName}";
    }

    private static string InferReturnPurpose(string methodName, string returnType)
    {
        var lower = methodName.ToLower();

        if (returnType.Contains("bool") || returnType == "bool")
            return "true if successful, false otherwise";
        if (returnType.Contains("Task") && !returnType.Contains("<"))
            return "A task representing the async operation";
        if (returnType.Contains("Task<"))
            return $"A task that returns the result";
        if (returnType.Contains("List") || returnType.Contains("IEnumerable") || returnType.Contains("[]"))
            return "A collection of results";
        if (lower.StartsWith("get") || lower.StartsWith("find"))
            return $"The requested {returnType}";
        if (lower.StartsWith("create") || lower.StartsWith("add"))
            return $"The newly created {returnType}";

        return $"The {returnType} result";
    }

    private static string ToSnakeCase(string name)
    {
        return string.Concat(name.Select((c, i) =>
            i > 0 && char.IsUpper(c) ? "_" + char.ToLower(c) : char.ToLower(c).ToString()));
    }

    private static string ToLowerCamelCase(string name)
    {
        if (string.IsNullOrEmpty(name)) return name;
        return char.ToLower(name[0]) + name.Substring(1);
    }

    private static string CleanDocumentation(string doc)
    {
        // Remove XML tags for display
        return Regex.Replace(doc, @"<[^>]+>", "").Trim();
    }

    private static string ComputeContentHash(string input, string output)
    {
        var combined = $"{input}|||{output}";
        using var sha = System.Security.Cryptography.SHA256.Create();
        var hash = sha.ComputeHash(Encoding.UTF8.GetBytes(combined));
        return Convert.ToBase64String(hash)[..16];
    }
}

/// <summary>
/// Options for instruction generation
/// </summary>
public sealed class GenerationOptions
{
    public string? SystemPrompt { get; init; }
    public IReadOnlyDictionary<string, string[]>? CustomTemplates { get; init; }
}

/// <summary>
/// Extension methods for string manipulation
/// </summary>
internal static class StringExtensions
{
    public static string Capitalize(this string s)
    {
        if (string.IsNullOrEmpty(s)) return s;
        return char.ToUpper(s[0]) + s.Substring(1);
    }
}
```

### v0.8.2d File Summary

| File | Purpose | Lines (Est.) |
|------|---------|--------------|
| `Services/Training/InstructionTemplateGenerator.cs` | Generate training examples from symbols | ~650 |

**v0.8.2d Total: 1 file to create**

---

## v0.8.2e: Dataset Service Interface & Implementation

### Objective
Create the main dataset service that orchestrates the entire pipeline from code folder to training-ready dataset.

### Files to Create

#### 1. Core/Interfaces/IDatasetService.cs

```csharp
namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Service for creating, managing, and processing training datasets
/// </summary>
public interface IDatasetService
{
    /// <summary>
    /// Create a training dataset from a code folder
    /// </summary>
    Task<TrainingDataset> CreateDatasetFromCodeAsync(
        string folderPath,
        DatasetCreationOptions options,
        IProgress<DatasetCreationProgress>? progress = null,
        CancellationToken ct = default);

    /// <summary>
    /// Load an existing dataset from disk
    /// </summary>
    Task<TrainingDataset> LoadDatasetAsync(
        string datasetPath,
        CancellationToken ct = default);

    /// <summary>
    /// Save a dataset to disk
    /// </summary>
    Task SaveDatasetAsync(
        TrainingDataset dataset,
        string outputPath,
        CancellationToken ct = default);

    /// <summary>
    /// Tokenize a dataset for training
    /// </summary>
    Task<TokenizedDataset> TokenizeDatasetAsync(
        TrainingDataset dataset,
        TokenizationOptions options,
        IProgress<TokenizationProgress>? progress = null,
        CancellationToken ct = default);

    /// <summary>
    /// Create data loaders for training and validation
    /// </summary>
    (IDataLoader Train, IDataLoader Validation) CreateDataLoaders(
        TokenizedDataset dataset,
        DataLoaderOptions options);

    /// <summary>
    /// Get statistics for a dataset
    /// </summary>
    DatasetStatistics GetStatistics(TrainingDataset dataset);

    /// <summary>
    /// Validate a dataset for training readiness
    /// </summary>
    DatasetValidationResult ValidateDataset(TrainingDataset dataset);
}

/// <summary>
/// Progress information for dataset creation
/// </summary>
public sealed class DatasetCreationProgress
{
    public DatasetCreationStage Stage { get; init; }
    public string CurrentFile { get; init; } = string.Empty;
    public int FilesProcessed { get; init; }
    public int TotalFiles { get; init; }
    public int ExamplesGenerated { get; init; }
    public int SymbolsExtracted { get; init; }
    public string Message { get; init; } = string.Empty;
    public double PercentComplete => TotalFiles > 0
        ? (double)FilesProcessed / TotalFiles * 100
        : 0;
}

public enum DatasetCreationStage
{
    Initializing,
    ScanningFiles,
    ExtractingSymbols,
    GeneratingExamples,
    Deduplicating,
    Finalizing,
    Complete
}

/// <summary>
/// Progress information for tokenization
/// </summary>
public sealed class TokenizationProgress
{
    public int ExamplesProcessed { get; init; }
    public int TotalExamples { get; init; }
    public int TokensGenerated { get; init; }
    public double PercentComplete => TotalExamples > 0
        ? (double)ExamplesProcessed / TotalExamples * 100
        : 0;
}

/// <summary>
/// Result of dataset validation
/// </summary>
public sealed class DatasetValidationResult
{
    public bool IsValid { get; init; }
    public IReadOnlyList<string> Errors { get; init; } = Array.Empty<string>();
    public IReadOnlyList<string> Warnings { get; init; } = Array.Empty<string>();
    public int MinimumExamplesRequired { get; init; } = 10;
    public int ActualExamples { get; init; }
}
```

#### 2. Services/Training/DatasetService.cs

```csharp
namespace SeniorIntern.Services.Training;

/// <summary>
/// Main service for dataset creation and management
/// </summary>
public sealed class DatasetService : IDatasetService
{
    private readonly ILogger<DatasetService> _logger;
    private readonly CodeScanner _codeScanner;
    private readonly SymbolExtractorFactory _extractorFactory;
    private readonly InstructionTemplateGenerator _templateGenerator;
    private readonly TokenizationService _tokenizationService;
    private readonly ExampleDeduplicator _deduplicator;
    private readonly DataLoaderFactory _dataLoaderFactory;
    private readonly IDatasetSerializer _serializer;

    public DatasetService(
        ILogger<DatasetService> logger,
        CodeScanner codeScanner,
        SymbolExtractorFactory extractorFactory,
        InstructionTemplateGenerator templateGenerator,
        TokenizationService tokenizationService,
        ExampleDeduplicator deduplicator,
        DataLoaderFactory dataLoaderFactory,
        IDatasetSerializer serializer)
    {
        _logger = logger;
        _codeScanner = codeScanner;
        _extractorFactory = extractorFactory;
        _templateGenerator = templateGenerator;
        _tokenizationService = tokenizationService;
        _deduplicator = deduplicator;
        _dataLoaderFactory = dataLoaderFactory;
        _serializer = serializer;
    }

    public async Task<TrainingDataset> CreateDatasetFromCodeAsync(
        string folderPath,
        DatasetCreationOptions options,
        IProgress<DatasetCreationProgress>? progress = null,
        CancellationToken ct = default)
    {
        var stopwatch = Stopwatch.StartNew();

        _logger.LogInformation("Creating dataset from {Path}", folderPath);

        // Stage 1: Scan for code files
        progress?.Report(new DatasetCreationProgress
        {
            Stage = DatasetCreationStage.ScanningFiles,
            Message = "Scanning for code files..."
        });

        var scanProgress = new Progress<CodeScanProgress>(p =>
        {
            progress?.Report(new DatasetCreationProgress
            {
                Stage = DatasetCreationStage.ScanningFiles,
                CurrentFile = p.CurrentFile,
                FilesProcessed = p.FilesProcessed,
                TotalFiles = p.TotalFiles,
                Message = $"Scanning: {p.CurrentFile}"
            });
        });

        var scanResult = await _codeScanner.ScanDirectoryAsync(
            folderPath, options, scanProgress, ct);

        _logger.LogInformation("Found {Count} valid code files", scanResult.Files.Count);

        if (scanResult.Files.Count == 0)
        {
            throw new InvalidOperationException(
                $"No valid code files found in {folderPath}. " +
                $"Checked patterns: {string.Join(", ", options.IncludePatterns)}");
        }

        // Stage 2: Extract symbols from files
        progress?.Report(new DatasetCreationProgress
        {
            Stage = DatasetCreationStage.ExtractingSymbols,
            TotalFiles = scanResult.Files.Count,
            Message = "Extracting code symbols..."
        });

        var allSymbols = new List<CodeSymbol>();
        var extractionOptions = new SymbolExtractionOptions
        {
            TypesToExtract = options.SymbolTypesToExtract,
            MinLines = options.MinCodeLines,
            MaxLines = options.MaxCodeLines,
            IncludeDocumentation = options.IncludeComments,
            PreferAstParsing = true
        };

        var processedFiles = 0;
        foreach (var file in scanResult.Files)
        {
            ct.ThrowIfCancellationRequested();

            try
            {
                var content = await File.ReadAllTextAsync(file.FilePath, ct);
                var extractionResult = await _extractorFactory.ExtractFromFileAsync(
                    file, content, extractionOptions, ct);

                allSymbols.AddRange(extractionResult.Symbols);

                processedFiles++;
                progress?.Report(new DatasetCreationProgress
                {
                    Stage = DatasetCreationStage.ExtractingSymbols,
                    CurrentFile = file.RelativePath,
                    FilesProcessed = processedFiles,
                    TotalFiles = scanResult.Files.Count,
                    SymbolsExtracted = allSymbols.Count,
                    Message = $"Extracted {extractionResult.Symbols.Count} symbols from {file.RelativePath}"
                });
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Failed to extract symbols from {File}", file.FilePath);
            }
        }

        _logger.LogInformation("Extracted {Count} symbols from {Files} files",
            allSymbols.Count, processedFiles);

        if (allSymbols.Count == 0)
        {
            throw new InvalidOperationException(
                "No code symbols could be extracted. " +
                "Check MinCodeLines and MaxCodeLines settings.");
        }

        // Stage 3: Generate training examples
        progress?.Report(new DatasetCreationProgress
        {
            Stage = DatasetCreationStage.GeneratingExamples,
            Message = "Generating training examples..."
        });

        var allExamples = new List<TrainingExample>();
        var generationOptions = new GenerationOptions
        {
            SystemPrompt = options.SystemPrompt,
            CustomTemplates = options.CustomTemplates
        };

        foreach (var symbol in allSymbols)
        {
            ct.ThrowIfCancellationRequested();

            var examples = _templateGenerator.GenerateExamples(
                symbol, options.GenerationType, generationOptions);

            allExamples.AddRange(examples);

            if (options.MaxExamples > 0 && allExamples.Count >= options.MaxExamples)
            {
                allExamples = allExamples.Take(options.MaxExamples).ToList();
                break;
            }
        }

        _logger.LogInformation("Generated {Count} training examples", allExamples.Count);

        // Stage 4: Deduplicate examples
        var duplicatesRemoved = 0;
        if (options.Deduplicate)
        {
            progress?.Report(new DatasetCreationProgress
            {
                Stage = DatasetCreationStage.Deduplicating,
                ExamplesGenerated = allExamples.Count,
                Message = "Removing duplicate examples..."
            });

            var originalCount = allExamples.Count;
            allExamples = await _deduplicator.DeduplicateAsync(
                allExamples, options.DeduplicationThreshold, ct);

            duplicatesRemoved = originalCount - allExamples.Count;
            _logger.LogInformation("Removed {Count} duplicate examples", duplicatesRemoved);
        }

        // Stage 5: Shuffle if requested
        if (options.Shuffle)
        {
            var rng = options.RandomSeed.HasValue
                ? new Random(options.RandomSeed.Value)
                : new Random();
            allExamples = allExamples.OrderBy(_ => rng.Next()).ToList();
        }

        // Stage 6: Build final dataset
        progress?.Report(new DatasetCreationProgress
        {
            Stage = DatasetCreationStage.Finalizing,
            ExamplesGenerated = allExamples.Count,
            Message = "Finalizing dataset..."
        });

        stopwatch.Stop();

        var dataset = new TrainingDataset
        {
            Name = Path.GetFileName(folderPath),
            SourcePath = folderPath,
            Examples = allExamples,
            Options = options,
            Statistics = CalculateStatistics(
                allExamples,
                scanResult.Files.Count,
                allSymbols.Count,
                duplicatesRemoved)
        };

        progress?.Report(new DatasetCreationProgress
        {
            Stage = DatasetCreationStage.Complete,
            ExamplesGenerated = allExamples.Count,
            FilesProcessed = scanResult.Files.Count,
            TotalFiles = scanResult.Files.Count,
            SymbolsExtracted = allSymbols.Count,
            Message = $"Created dataset with {allExamples.Count} examples in {stopwatch.Elapsed.TotalSeconds:F1}s"
        });

        _logger.LogInformation(
            "Dataset creation complete: {Examples} examples from {Files} files in {Duration:F1}s",
            allExamples.Count, scanResult.Files.Count, stopwatch.Elapsed.TotalSeconds);

        return dataset;
    }

    public async Task<TrainingDataset> LoadDatasetAsync(
        string datasetPath,
        CancellationToken ct = default)
    {
        _logger.LogInformation("Loading dataset from {Path}", datasetPath);
        return await _serializer.LoadAsync(datasetPath, ct);
    }

    public async Task SaveDatasetAsync(
        TrainingDataset dataset,
        string outputPath,
        CancellationToken ct = default)
    {
        _logger.LogInformation("Saving dataset to {Path}", outputPath);
        await _serializer.SaveAsync(dataset, outputPath, ct);
    }

    public async Task<TokenizedDataset> TokenizeDatasetAsync(
        TrainingDataset dataset,
        TokenizationOptions options,
        IProgress<TokenizationProgress>? progress = null,
        CancellationToken ct = default)
    {
        _logger.LogInformation("Tokenizing dataset with {Count} examples", dataset.Examples.Count);

        var trainExamples = new List<TokenizedExample>();
        var valExamples = new List<TokenizedExample>();

        // Split into train/validation
        var splitIndex = (int)(dataset.Examples.Count * (1 - options.ValidationSplit));
        var trainSet = dataset.Examples.Take(splitIndex).ToList();
        var valSet = dataset.Examples.Skip(splitIndex).ToList();

        var total = dataset.Examples.Count;
        var processed = 0;
        var totalTokens = 0;

        // Tokenize training set
        foreach (var example in trainSet)
        {
            ct.ThrowIfCancellationRequested();

            var tokenized = _tokenizationService.TokenizeExample(example, options);
            trainExamples.Add(tokenized);

            processed++;
            totalTokens += tokenized.SequenceLength;

            progress?.Report(new TokenizationProgress
            {
                ExamplesProcessed = processed,
                TotalExamples = total,
                TokensGenerated = totalTokens
            });
        }

        // Tokenize validation set
        foreach (var example in valSet)
        {
            ct.ThrowIfCancellationRequested();

            var tokenized = _tokenizationService.TokenizeExample(example, options);
            valExamples.Add(tokenized);

            processed++;
            totalTokens += tokenized.SequenceLength;

            progress?.Report(new TokenizationProgress
            {
                ExamplesProcessed = processed,
                TotalExamples = total,
                TokensGenerated = totalTokens
            });
        }

        _logger.LogInformation(
            "Tokenization complete: {Train} train, {Val} validation, {Tokens} total tokens",
            trainExamples.Count, valExamples.Count, totalTokens);

        return new TokenizedDataset
        {
            SourceDatasetId = dataset.Id,
            TrainExamples = trainExamples,
            ValidationExamples = valExamples,
            Options = options,
            VocabSize = _tokenizationService.VocabSize,
            SpecialTokens = _tokenizationService.GetSpecialTokens()
        };
    }

    public (IDataLoader Train, IDataLoader Validation) CreateDataLoaders(
        TokenizedDataset dataset,
        DataLoaderOptions options)
    {
        var trainLoader = _dataLoaderFactory.Create(
            dataset.TrainExamples, options with { Shuffle = true });

        var valLoader = _dataLoaderFactory.Create(
            dataset.ValidationExamples, options with { Shuffle = false });

        return (trainLoader, valLoader);
    }

    public DatasetStatistics GetStatistics(TrainingDataset dataset)
    {
        return dataset.Statistics;
    }

    public DatasetValidationResult ValidateDataset(TrainingDataset dataset)
    {
        var errors = new List<string>();
        var warnings = new List<string>();
        const int minExamples = 10;

        if (dataset.Examples.Count < minExamples)
        {
            errors.Add($"Dataset has only {dataset.Examples.Count} examples. Minimum recommended is {minExamples}.");
        }

        if (dataset.Examples.Count < 100)
        {
            warnings.Add($"Dataset has only {dataset.Examples.Count} examples. Consider adding more for better training results.");
        }

        var avgLength = dataset.Statistics.AverageTokensPerExample;
        if (avgLength < 50)
        {
            warnings.Add($"Average example length is only {avgLength:F0} tokens. Longer examples may improve training.");
        }

        if (dataset.Statistics.ExamplesByLanguage.Count == 1)
        {
            warnings.Add("Dataset contains only one programming language. Consider adding more variety.");
        }

        if (dataset.Statistics.ExamplesByType.Count < 3)
        {
            warnings.Add("Dataset contains few example types. Consider enabling more generation types.");
        }

        return new DatasetValidationResult
        {
            IsValid = errors.Count == 0,
            Errors = errors,
            Warnings = warnings,
            MinimumExamplesRequired = minExamples,
            ActualExamples = dataset.Examples.Count
        };
    }

    private static DatasetStatistics CalculateStatistics(
        List<TrainingExample> examples,
        int filesScanned,
        int symbolsExtracted,
        int duplicatesRemoved)
    {
        var byLanguage = examples
            .Where(e => e.Source.Language != null)
            .GroupBy(e => e.Source.Language!)
            .ToDictionary(g => g.Key, g => g.Count());

        var byType = examples
            .GroupBy(e => e.ExampleType.ToString())
            .ToDictionary(g => g.Key, g => g.Count());

        // Estimate token counts (rough approximation)
        var tokenCounts = examples
            .Select(e => (e.Instruction.Length + e.Input.Length + e.Output.Length) / 4)
            .ToList();

        var totalTokens = tokenCounts.Sum();
        var sorted = tokenCounts.OrderBy(x => x).ToList();
        var median = sorted.Count > 0 ? sorted[sorted.Count / 2] : 0;

        return new DatasetStatistics
        {
            TotalExamples = examples.Count,
            TotalTokens = totalTokens,
            TrainExamples = (int)(examples.Count * 0.9),
            ValidationExamples = (int)(examples.Count * 0.1),
            AverageTokensPerExample = examples.Count > 0 ? (double)totalTokens / examples.Count : 0,
            MinSequenceLength = sorted.Count > 0 ? sorted.First() : 0,
            MaxSequenceLength = sorted.Count > 0 ? sorted.Last() : 0,
            MedianSequenceLength = median,
            ExamplesByLanguage = byLanguage,
            ExamplesByType = byType,
            DuplicatesRemoved = duplicatesRemoved,
            FilesScanned = filesScanned,
            SymbolsExtracted = symbolsExtracted
        };
    }
}
```

### v0.8.2e File Summary

| File | Purpose | Lines (Est.) |
|------|---------|--------------|
| `Core/Interfaces/IDatasetService.cs` | Dataset service interface | ~100 |
| `Services/Training/DatasetService.cs` | Dataset service implementation | ~320 |

**v0.8.2e Total: 2 files to create**

---

## v0.8.2f: Tokenization Service

### Objective
Implement tokenization of training examples using LLamaSharp with support for multiple chat template formats.

### Files to Create

#### 1. Core/Training/TokenizationOptions.cs

```csharp
namespace SeniorIntern.Core.Training;

/// <summary>
/// Options for tokenizing training examples
/// </summary>
public sealed class TokenizationOptions
{
    /// <summary>
    /// Maximum sequence length (tokens will be truncated)
    /// </summary>
    public int MaxLength { get; init; } = 2048;

    /// <summary>
    /// Whether to mask instruction tokens in labels
    /// (set to -100 so loss isn't computed on them)
    /// </summary>
    public bool MaskInstructionTokens { get; init; } = true;

    /// <summary>
    /// Chat template format to use
    /// </summary>
    public ChatTemplateFormat ChatTemplate { get; init; } = ChatTemplateFormat.ChatML;

    /// <summary>
    /// Whether to add BOS token at start
    /// </summary>
    public bool AddBosToken { get; init; } = true;

    /// <summary>
    /// Whether to add EOS token at end
    /// </summary>
    public bool AddEosToken { get; init; } = true;

    /// <summary>
    /// Padding token ID (usually 0)
    /// </summary>
    public int PadTokenId { get; init; } = 0;

    /// <summary>
    /// Label to use for masked tokens
    /// </summary>
    public int IgnoreLabelId { get; init; } = -100;

    /// <summary>
    /// Validation split ratio (0.0 to 1.0)
    /// </summary>
    public float ValidationSplit { get; init; } = 0.1f;
}

/// <summary>
/// Chat template formats for different model families
/// </summary>
public enum ChatTemplateFormat
{
    /// <summary>
    /// ChatML format: &lt;|im_start|&gt;role\ncontent&lt;|im_end|&gt;
    /// Used by: Qwen, many fine-tuned models
    /// </summary>
    ChatML,

    /// <summary>
    /// Llama 2 format: [INST] user [/INST] assistant
    /// Used by: Llama 2, Code Llama
    /// </summary>
    Llama2,

    /// <summary>
    /// Llama 3 format: &lt;|start_header_id|&gt;role&lt;|end_header_id|&gt;
    /// Used by: Llama 3, Llama 3.1
    /// </summary>
    Llama3,

    /// <summary>
    /// Alpaca format: ### Instruction:\n### Response:
    /// Used by: Alpaca-style models
    /// </summary>
    Alpaca,

    /// <summary>
    /// Vicuna format: USER: content ASSISTANT: response
    /// Used by: Vicuna models
    /// </summary>
    Vicuna,

    /// <summary>
    /// Mistral format: [INST] content [/INST]
    /// Used by: Mistral, Mixtral
    /// </summary>
    Mistral,

    /// <summary>
    /// DeepSeek format: User: content\n\nAssistant: response
    /// Used by: DeepSeek models
    /// </summary>
    DeepSeek
}
```

#### 2. Services/Training/TokenizationService.cs

```csharp
namespace SeniorIntern.Services.Training;

using LLama;
using LLama.Common;
using LLama.Native;

/// <summary>
/// Service for tokenizing training examples using LLamaSharp
/// </summary>
public sealed class TokenizationService : IDisposable
{
    private readonly ILogger<TokenizationService> _logger;
    private LLamaWeights? _model;
    private LLamaContext? _context;
    private bool _initialized;

    public int VocabSize { get; private set; }
    public bool IsInitialized => _initialized;

    public TokenizationService(ILogger<TokenizationService> logger)
    {
        _logger = logger;
    }

    /// <summary>
    /// Initialize the tokenizer from a model file
    /// </summary>
    public async Task InitializeAsync(string modelPath, CancellationToken ct = default)
    {
        if (_initialized)
        {
            _logger.LogWarning("Tokenizer already initialized, reinitializing...");
            Dispose();
        }

        _logger.LogInformation("Initializing tokenizer from {Path}", modelPath);

        var modelParams = new ModelParams(modelPath)
        {
            ContextSize = 512,    // Small context for tokenization only
            GpuLayerCount = 0,    // CPU only for tokenizer
            UseMemorymap = true,
            UseMemoryLock = false
        };

        _model = await LLamaWeights.LoadFromFileAsync(modelParams, ct);

        var contextParams = new ModelParams(modelPath)
        {
            ContextSize = 512
        };

        _context = _model.CreateContext(contextParams);
        VocabSize = _model.VocabCount;
        _initialized = true;

        _logger.LogInformation("Tokenizer initialized. Vocab size: {Size}", VocabSize);
    }

    /// <summary>
    /// Tokenize a single training example
    /// </summary>
    public TokenizedExample TokenizeExample(
        TrainingExample example,
        TokenizationOptions options)
    {
        if (!_initialized)
            throw new InvalidOperationException("Tokenizer not initialized. Call InitializeAsync first.");

        // Format as chat template
        var formattedText = FormatAsChatTemplate(example, options);

        // Tokenize the full text
        var tokens = _context!.Tokenize(formattedText, addBos: options.AddBosToken);
        var tokenArray = tokens.ToArray();

        // Truncate if needed
        if (tokenArray.Length > options.MaxLength)
        {
            _logger.LogDebug(
                "Truncating sequence from {Original} to {Max} tokens",
                tokenArray.Length, options.MaxLength);
            tokenArray = tokenArray.Take(options.MaxLength).ToArray();
        }

        // Create attention mask (all 1s for real tokens)
        var attentionMask = Enumerable.Repeat(1, tokenArray.Length).ToArray();

        // Create labels
        var labels = CreateLabels(example, formattedText, tokenArray, options);

        return new TokenizedExample
        {
            InputIds = tokenArray,
            AttentionMask = attentionMask,
            Labels = labels,
            SequenceLength = tokenArray.Length,
            OriginalExampleId = example.Id
        };
    }

    /// <summary>
    /// Get special token IDs
    /// </summary>
    public SpecialTokenIds GetSpecialTokens()
    {
        if (!_initialized)
            throw new InvalidOperationException("Tokenizer not initialized.");

        return new SpecialTokenIds
        {
            BosTokenId = (int)_model!.BeginOfSentenceToken,
            EosTokenId = (int)_model.EndOfSentenceToken,
            PadTokenId = 0,
            UnkTokenId = 0
        };
    }

    private string FormatAsChatTemplate(
        TrainingExample example,
        TokenizationOptions options)
    {
        return options.ChatTemplate switch
        {
            ChatTemplateFormat.ChatML => FormatChatML(example),
            ChatTemplateFormat.Llama2 => FormatLlama2(example),
            ChatTemplateFormat.Llama3 => FormatLlama3(example),
            ChatTemplateFormat.Alpaca => FormatAlpaca(example),
            ChatTemplateFormat.Vicuna => FormatVicuna(example),
            ChatTemplateFormat.Mistral => FormatMistral(example),
            ChatTemplateFormat.DeepSeek => FormatDeepSeek(example),
            _ => FormatChatML(example)
        };
    }

    private static string FormatChatML(TrainingExample example)
    {
        var sb = new StringBuilder();

        if (!string.IsNullOrEmpty(example.SystemPrompt))
        {
            sb.AppendLine("<|im_start|>system");
            sb.AppendLine(example.SystemPrompt);
            sb.AppendLine("<|im_end|>");
        }

        sb.AppendLine("<|im_start|>user");
        sb.AppendLine(example.Instruction);
        if (!string.IsNullOrEmpty(example.Input))
        {
            sb.AppendLine();
            sb.AppendLine(example.Input);
        }
        sb.AppendLine("<|im_end|>");

        sb.AppendLine("<|im_start|>assistant");
        sb.AppendLine(example.Output);
        sb.Append("<|im_end|>");

        return sb.ToString();
    }

    private static string FormatLlama2(TrainingExample example)
    {
        var sb = new StringBuilder();

        if (!string.IsNullOrEmpty(example.SystemPrompt))
        {
            sb.AppendLine($"<<SYS>>{example.SystemPrompt}<</SYS>>");
            sb.AppendLine();
        }

        sb.Append("[INST] ");
        sb.Append(example.Instruction);
        if (!string.IsNullOrEmpty(example.Input))
        {
            sb.AppendLine();
            sb.Append(example.Input);
        }
        sb.AppendLine(" [/INST]");
        sb.Append(example.Output);

        return sb.ToString();
    }

    private static string FormatLlama3(TrainingExample example)
    {
        var sb = new StringBuilder();

        sb.AppendLine("<|begin_of_text|>");

        if (!string.IsNullOrEmpty(example.SystemPrompt))
        {
            sb.AppendLine("<|start_header_id|>system<|end_header_id|>");
            sb.AppendLine();
            sb.AppendLine(example.SystemPrompt);
            sb.AppendLine("<|eot_id|>");
        }

        sb.AppendLine("<|start_header_id|>user<|end_header_id|>");
        sb.AppendLine();
        sb.Append(example.Instruction);
        if (!string.IsNullOrEmpty(example.Input))
        {
            sb.AppendLine();
            sb.Append(example.Input);
        }
        sb.AppendLine();
        sb.AppendLine("<|eot_id|>");

        sb.AppendLine("<|start_header_id|>assistant<|end_header_id|>");
        sb.AppendLine();
        sb.Append(example.Output);
        sb.Append("<|eot_id|>");

        return sb.ToString();
    }

    private static string FormatAlpaca(TrainingExample example)
    {
        var sb = new StringBuilder();

        sb.AppendLine("### Instruction:");
        sb.AppendLine(example.Instruction);

        if (!string.IsNullOrEmpty(example.Input))
        {
            sb.AppendLine();
            sb.AppendLine("### Input:");
            sb.AppendLine(example.Input);
        }

        sb.AppendLine();
        sb.AppendLine("### Response:");
        sb.Append(example.Output);

        return sb.ToString();
    }

    private static string FormatVicuna(TrainingExample example)
    {
        var sb = new StringBuilder();

        if (!string.IsNullOrEmpty(example.SystemPrompt))
        {
            sb.AppendLine(example.SystemPrompt);
            sb.AppendLine();
        }

        sb.Append("USER: ");
        sb.Append(example.Instruction);
        if (!string.IsNullOrEmpty(example.Input))
        {
            sb.AppendLine();
            sb.Append(example.Input);
        }
        sb.AppendLine();
        sb.Append("ASSISTANT: ");
        sb.Append(example.Output);

        return sb.ToString();
    }

    private static string FormatMistral(TrainingExample example)
    {
        var sb = new StringBuilder();

        sb.Append("[INST] ");
        if (!string.IsNullOrEmpty(example.SystemPrompt))
        {
            sb.Append(example.SystemPrompt);
            sb.AppendLine();
            sb.AppendLine();
        }
        sb.Append(example.Instruction);
        if (!string.IsNullOrEmpty(example.Input))
        {
            sb.AppendLine();
            sb.Append(example.Input);
        }
        sb.AppendLine(" [/INST]");
        sb.Append(example.Output);

        return sb.ToString();
    }

    private static string FormatDeepSeek(TrainingExample example)
    {
        var sb = new StringBuilder();

        if (!string.IsNullOrEmpty(example.SystemPrompt))
        {
            sb.AppendLine(example.SystemPrompt);
            sb.AppendLine();
        }

        sb.Append("User: ");
        sb.Append(example.Instruction);
        if (!string.IsNullOrEmpty(example.Input))
        {
            sb.AppendLine();
            sb.Append(example.Input);
        }
        sb.AppendLine();
        sb.AppendLine();
        sb.Append("Assistant: ");
        sb.Append(example.Output);

        return sb.ToString();
    }

    private int[] CreateLabels(
        TrainingExample example,
        string formattedText,
        int[] tokens,
        TokenizationOptions options)
    {
        var labels = new int[tokens.Length];
        Array.Copy(tokens, labels, tokens.Length);

        if (options.MaskInstructionTokens)
        {
            // Find where the assistant's response starts
            var responseStart = FindResponseStart(formattedText, options.ChatTemplate);

            if (responseStart >= 0)
            {
                // Tokenize just the prefix to find how many tokens to mask
                var prefixText = formattedText.Substring(0, responseStart);
                var prefixTokens = _context!.Tokenize(prefixText, addBos: options.AddBosToken);
                var prefixLength = prefixTokens.Count();

                // Mask all tokens before the response
                for (int i = 0; i < Math.Min(prefixLength, labels.Length); i++)
                {
                    labels[i] = options.IgnoreLabelId;
                }
            }
        }

        return labels;
    }

    private static int FindResponseStart(string text, ChatTemplateFormat format)
    {
        return format switch
        {
            ChatTemplateFormat.ChatML =>
                text.LastIndexOf("<|im_start|>assistant") is int idx && idx >= 0
                    ? text.IndexOf('\n', idx) + 1
                    : -1,
            ChatTemplateFormat.Llama2 =>
                text.LastIndexOf("[/INST]") is int idx && idx >= 0
                    ? idx + "[/INST]".Length
                    : -1,
            ChatTemplateFormat.Llama3 =>
                text.LastIndexOf("<|start_header_id|>assistant<|end_header_id|>") is int idx && idx >= 0
                    ? text.IndexOf('\n', text.IndexOf('\n', idx) + 1) + 1
                    : -1,
            ChatTemplateFormat.Alpaca =>
                text.LastIndexOf("### Response:") is int idx && idx >= 0
                    ? text.IndexOf('\n', idx) + 1
                    : -1,
            ChatTemplateFormat.Vicuna =>
                text.LastIndexOf("ASSISTANT: ") is int idx && idx >= 0
                    ? idx + "ASSISTANT: ".Length
                    : -1,
            ChatTemplateFormat.Mistral =>
                text.LastIndexOf("[/INST]") is int idx && idx >= 0
                    ? text.IndexOf('\n', idx) + 1
                    : -1,
            ChatTemplateFormat.DeepSeek =>
                text.LastIndexOf("Assistant: ") is int idx && idx >= 0
                    ? idx + "Assistant: ".Length
                    : -1,
            _ => -1
        };
    }

    public void Dispose()
    {
        _context?.Dispose();
        _model?.Dispose();
        _context = null;
        _model = null;
        _initialized = false;
    }
}
```

### v0.8.2f File Summary

| File | Purpose | Lines (Est.) |
|------|---------|--------------|
| `Core/Training/TokenizationOptions.cs` | Tokenization configuration | ~80 |
| `Services/Training/TokenizationService.cs` | Tokenization implementation | ~320 |

**v0.8.2f Total: 2 files to create**

---

## v0.8.2g: Deduplication & Quality Filtering

### Objective
Implement deduplication using MinHash algorithm to remove near-duplicate training examples while preserving quality and diversity.

### Files to Create

#### 1. Services/Training/ExampleDeduplicator.cs

```csharp
namespace SeniorIntern.Services.Training;

/// <summary>
/// Removes near-duplicate training examples using MinHash LSH
/// </summary>
public sealed class ExampleDeduplicator
{
    private readonly ILogger<ExampleDeduplicator> _logger;

    // MinHash parameters
    private const int NumHashFunctions = 128;
    private const int NumBands = 16;
    private const int RowsPerBand = NumHashFunctions / NumBands; // 8
    private const int ShingleSize = 3; // Character n-grams

    private readonly int[] _hashSeeds;

    public ExampleDeduplicator(ILogger<ExampleDeduplicator> logger)
    {
        _logger = logger;

        // Generate stable hash seeds
        var rng = new Random(42);
        _hashSeeds = Enumerable.Range(0, NumHashFunctions * 2)
            .Select(_ => rng.Next())
            .ToArray();
    }

    /// <summary>
    /// Remove near-duplicate examples based on content similarity
    /// </summary>
    public async Task<List<TrainingExample>> DeduplicateAsync(
        IReadOnlyList<TrainingExample> examples,
        float threshold,
        CancellationToken ct = default)
    {
        if (examples.Count == 0)
            return new List<TrainingExample>();

        _logger.LogInformation(
            "Deduplicating {Count} examples with threshold {Threshold}",
            examples.Count, threshold);

        var stopwatch = Stopwatch.StartNew();

        // Compute MinHash signatures for all examples
        var signatures = await Task.Run(() =>
        {
            var sigs = new Dictionary<Guid, int[]>();

            foreach (var example in examples)
            {
                ct.ThrowIfCancellationRequested();
                var content = $"{example.Input}\n{example.Output}";
                sigs[example.Id] = ComputeMinHashSignature(content);
            }

            return sigs;
        }, ct);

        // LSH bucketing to find candidate pairs
        var buckets = new Dictionary<string, List<Guid>>();

        foreach (var (id, signature) in signatures)
        {
            for (int band = 0; band < NumBands; band++)
            {
                var bandHash = ComputeBandHash(signature, band);
                var bucketKey = $"{band}:{bandHash}";

                if (!buckets.TryGetValue(bucketKey, out var bucket))
                {
                    bucket = new List<Guid>();
                    buckets[bucketKey] = bucket;
                }
                bucket.Add(id);
            }
        }

        // Find duplicates
        var duplicates = new HashSet<Guid>();
        var exampleDict = examples.ToDictionary(e => e.Id);

        foreach (var bucket in buckets.Values.Where(b => b.Count > 1))
        {
            ct.ThrowIfCancellationRequested();

            // Check all pairs in this bucket
            for (int i = 0; i < bucket.Count; i++)
            {
                if (duplicates.Contains(bucket[i]))
                    continue;

                for (int j = i + 1; j < bucket.Count; j++)
                {
                    if (duplicates.Contains(bucket[j]))
                        continue;

                    var similarity = ComputeJaccardSimilarity(
                        signatures[bucket[i]],
                        signatures[bucket[j]]);

                    if (similarity >= threshold)
                    {
                        // Keep the one with longer output (more informative)
                        var ex1 = exampleDict[bucket[i]];
                        var ex2 = exampleDict[bucket[j]];

                        if (ex1.Output.Length >= ex2.Output.Length)
                            duplicates.Add(bucket[j]);
                        else
                            duplicates.Add(bucket[i]);
                    }
                }
            }
        }

        var result = examples
            .Where(e => !duplicates.Contains(e.Id))
            .ToList();

        stopwatch.Stop();

        _logger.LogInformation(
            "Deduplication complete: removed {Removed} duplicates in {Duration:F2}s",
            duplicates.Count, stopwatch.Elapsed.TotalSeconds);

        return result;
    }

    private int[] ComputeMinHashSignature(string text)
    {
        // Generate shingles (character n-grams)
        var shingles = new HashSet<string>();
        var normalizedText = text.ToLowerInvariant();

        for (int i = 0; i <= normalizedText.Length - ShingleSize; i++)
        {
            shingles.Add(normalizedText.Substring(i, ShingleSize));
        }

        if (shingles.Count == 0)
        {
            // Return max values if no shingles (will be unique)
            return Enumerable.Repeat(int.MaxValue, NumHashFunctions).ToArray();
        }

        // Compute MinHash signature
        var signature = new int[NumHashFunctions];

        for (int h = 0; h < NumHashFunctions; h++)
        {
            var minHash = int.MaxValue;
            var a = _hashSeeds[h * 2];
            var b = _hashSeeds[h * 2 + 1];

            foreach (var shingle in shingles)
            {
                var shingleHash = ComputeHash(shingle, a, b);
                minHash = Math.Min(minHash, shingleHash);
            }

            signature[h] = minHash;
        }

        return signature;
    }

    private static int ComputeHash(string text, int a, int b)
    {
        // Simple polynomial hash
        unchecked
        {
            var hash = 0;
            foreach (var c in text)
            {
                hash = hash * a + c + b;
            }
            return hash;
        }
    }

    private static int ComputeBandHash(int[] signature, int band)
    {
        unchecked
        {
            var hash = 0;
            var start = band * RowsPerBand;

            for (int i = 0; i < RowsPerBand; i++)
            {
                hash = hash * 31 + signature[start + i];
            }

            return hash;
        }
    }

    private static float ComputeJaccardSimilarity(int[] sig1, int[] sig2)
    {
        var matches = 0;

        for (int i = 0; i < sig1.Length; i++)
        {
            if (sig1[i] == sig2[i])
                matches++;
        }

        return (float)matches / sig1.Length;
    }
}
```

#### 2. Services/Training/QualityFilter.cs

```csharp
namespace SeniorIntern.Services.Training;

/// <summary>
/// Filters training examples based on quality criteria
/// </summary>
public sealed class QualityFilter
{
    private readonly ILogger<QualityFilter> _logger;

    // Quality thresholds
    private const int MinInputLength = 10;
    private const int MinOutputLength = 10;
    private const int MaxInputLength = 50000;
    private const int MaxOutputLength = 50000;
    private const float MaxRepetitionRatio = 0.5f;

    public QualityFilter(ILogger<QualityFilter> logger)
    {
        _logger = logger;
    }

    /// <summary>
    /// Filter examples based on quality criteria
    /// </summary>
    public List<TrainingExample> Filter(
        IReadOnlyList<TrainingExample> examples,
        QualityFilterOptions? options = null)
    {
        options ??= new QualityFilterOptions();
        var filtered = new List<TrainingExample>();
        var removedReasons = new Dictionary<string, int>();

        foreach (var example in examples)
        {
            var (isValid, reason) = ValidateExample(example, options);

            if (isValid)
            {
                filtered.Add(example);
            }
            else if (reason != null)
            {
                removedReasons[reason] = removedReasons.GetValueOrDefault(reason) + 1;
            }
        }

        if (removedReasons.Count > 0)
        {
            _logger.LogInformation(
                "Quality filter removed {Count} examples: {Reasons}",
                examples.Count - filtered.Count,
                string.Join(", ", removedReasons.Select(kv => $"{kv.Key}={kv.Value}")));
        }

        return filtered;
    }

    private (bool IsValid, string? Reason) ValidateExample(
        TrainingExample example,
        QualityFilterOptions options)
    {
        // Length checks
        if (example.Input.Length < options.MinInputLength)
            return (false, "input_too_short");

        if (example.Output.Length < options.MinOutputLength)
            return (false, "output_too_short");

        if (example.Input.Length > options.MaxInputLength)
            return (false, "input_too_long");

        if (example.Output.Length > options.MaxOutputLength)
            return (false, "output_too_long");

        // Repetition check
        if (options.FilterHighRepetition)
        {
            if (HasHighRepetition(example.Output, options.MaxRepetitionRatio))
                return (false, "high_repetition");
        }

        // Empty content check
        if (string.IsNullOrWhiteSpace(example.Input) ||
            string.IsNullOrWhiteSpace(example.Output))
            return (false, "empty_content");

        // Instruction required
        if (string.IsNullOrWhiteSpace(example.Instruction))
            return (false, "missing_instruction");

        // Check for potential encoding issues
        if (HasEncodingIssues(example.Input) || HasEncodingIssues(example.Output))
            return (false, "encoding_issues");

        return (true, null);
    }

    private static bool HasHighRepetition(string text, float threshold)
    {
        if (text.Length < 50)
            return false;

        // Check for repeated lines
        var lines = text.Split('\n', StringSplitOptions.RemoveEmptyEntries);
        if (lines.Length > 3)
        {
            var uniqueLines = lines.Distinct().Count();
            var repetitionRatio = 1.0f - (float)uniqueLines / lines.Length;
            if (repetitionRatio > threshold)
                return true;
        }

        // Check for repeated n-grams
        var ngrams = new Dictionary<string, int>();
        const int ngramSize = 10;

        for (int i = 0; i <= text.Length - ngramSize; i++)
        {
            var ngram = text.Substring(i, ngramSize);
            ngrams[ngram] = ngrams.GetValueOrDefault(ngram) + 1;
        }

        if (ngrams.Count > 0)
        {
            var maxCount = ngrams.Values.Max();
            var totalNgrams = text.Length - ngramSize + 1;
            var repetitionRatio = (float)maxCount / totalNgrams;

            if (repetitionRatio > threshold)
                return true;
        }

        return false;
    }

    private static bool HasEncodingIssues(string text)
    {
        // Check for common encoding issue indicators
        return text.Contains('\uFFFD') ||  // Replacement character
               text.Contains('\0') ||       // Null bytes
               Regex.IsMatch(text, @"[\x00-\x08\x0B\x0C\x0E-\x1F]"); // Control chars
    }
}

/// <summary>
/// Options for quality filtering
/// </summary>
public sealed class QualityFilterOptions
{
    public int MinInputLength { get; init; } = 10;
    public int MinOutputLength { get; init; } = 10;
    public int MaxInputLength { get; init; } = 50000;
    public int MaxOutputLength { get; init; } = 50000;
    public bool FilterHighRepetition { get; init; } = true;
    public float MaxRepetitionRatio { get; init; } = 0.5f;
}
```

### v0.8.2g File Summary

| File | Purpose | Lines (Est.) |
|------|---------|--------------|
| `Services/Training/ExampleDeduplicator.cs` | MinHash-based deduplication | ~220 |
| `Services/Training/QualityFilter.cs` | Quality-based filtering | ~160 |

**v0.8.2g Total: 2 files to create**

---

## v0.8.2h: Data Loaders & Batching

### Objective
Implement efficient data loaders that create batches of tokenized examples for training, with support for shuffling, padding, and dynamic batching.

### Files to Create

#### 1. Core/Training/DataLoaderOptions.cs

```csharp
namespace SeniorIntern.Core.Training;

/// <summary>
/// Options for creating data loaders
/// </summary>
public sealed record DataLoaderOptions
{
    /// <summary>
    /// Batch size (number of examples per batch)
    /// </summary>
    public int BatchSize { get; init; } = 4;

    /// <summary>
    /// Whether to shuffle examples
    /// </summary>
    public bool Shuffle { get; init; } = true;

    /// <summary>
    /// Random seed for shuffling (null for random)
    /// </summary>
    public int? ShuffleSeed { get; init; }

    /// <summary>
    /// Whether to drop the last incomplete batch
    /// </summary>
    public bool DropLast { get; init; } = false;

    /// <summary>
    /// Padding token ID
    /// </summary>
    public int PadTokenId { get; init; } = 0;

    /// <summary>
    /// Label ID for padded positions
    /// </summary>
    public int PadLabelId { get; init; } = -100;

    /// <summary>
    /// Maximum sequence length (for padding)
    /// </summary>
    public int MaxSequenceLength { get; init; } = 2048;

    /// <summary>
    /// Whether to use dynamic batching (batch by similar lengths)
    /// </summary>
    public bool DynamicBatching { get; init; } = true;

    /// <summary>
    /// Number of batches to prefetch
    /// </summary>
    public int PrefetchCount { get; init; } = 2;
}
```

#### 2. Core/Interfaces/IDataLoader.cs

```csharp
namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Interface for iterating over training batches
/// </summary>
public interface IDataLoader : IEnumerable<TrainingBatch>, IDisposable
{
    /// <summary>
    /// Total number of batches in one epoch
    /// </summary>
    int TotalBatches { get; }

    /// <summary>
    /// Current batch index
    /// </summary>
    int CurrentBatch { get; }

    /// <summary>
    /// Total number of examples
    /// </summary>
    int TotalExamples { get; }

    /// <summary>
    /// Batch size being used
    /// </summary>
    int BatchSize { get; }

    /// <summary>
    /// Reset to the beginning
    /// </summary>
    void Reset();

    /// <summary>
    /// Shuffle the data
    /// </summary>
    void Shuffle();

    /// <summary>
    /// Move batches to a specific device
    /// </summary>
    void SetDevice(torch.Device device);
}
```

#### 3. Services/Training/TrainingDataLoader.cs

```csharp
namespace SeniorIntern.Services.Training;

/// <summary>
/// Data loader that creates batches of tokenized examples
/// </summary>
public sealed class TrainingDataLoader : IDataLoader
{
    private readonly IReadOnlyList<TokenizedExample> _examples;
    private readonly DataLoaderOptions _options;
    private readonly ILogger<TrainingDataLoader> _logger;

    private List<int> _indices;
    private Random _random;
    private torch.Device _device = torch.CPU;
    private int _currentBatch;

    public int TotalBatches { get; }
    public int CurrentBatch => _currentBatch;
    public int TotalExamples => _examples.Count;
    public int BatchSize => _options.BatchSize;

    public TrainingDataLoader(
        IReadOnlyList<TokenizedExample> examples,
        DataLoaderOptions options,
        ILogger<TrainingDataLoader> logger)
    {
        _examples = examples;
        _options = options;
        _logger = logger;

        _random = options.ShuffleSeed.HasValue
            ? new Random(options.ShuffleSeed.Value)
            : new Random();

        _indices = Enumerable.Range(0, examples.Count).ToList();

        // Calculate total batches
        var fullBatches = examples.Count / options.BatchSize;
        var hasRemainder = examples.Count % options.BatchSize > 0;
        TotalBatches = options.DropLast ? fullBatches : fullBatches + (hasRemainder ? 1 : 0);

        // Sort by length for dynamic batching
        if (options.DynamicBatching)
        {
            SortByLength();
        }

        // Initial shuffle if requested
        if (options.Shuffle)
        {
            Shuffle();
        }

        _logger.LogDebug(
            "Created data loader: {Examples} examples, {Batches} batches, batch size {Size}",
            examples.Count, TotalBatches, options.BatchSize);
    }

    public void Reset()
    {
        _currentBatch = 0;
    }

    public void Shuffle()
    {
        if (_options.DynamicBatching)
        {
            // Shuffle within buckets of similar lengths
            ShuffleWithinBuckets();
        }
        else
        {
            // Full shuffle
            _indices = _indices.OrderBy(_ => _random.Next()).ToList();
        }
    }

    public void SetDevice(torch.Device device)
    {
        _device = device;
    }

    public IEnumerator<TrainingBatch> GetEnumerator()
    {
        _currentBatch = 0;

        for (int batchStart = 0; batchStart < _examples.Count; batchStart += _options.BatchSize)
        {
            var batchEnd = Math.Min(batchStart + _options.BatchSize, _examples.Count);
            var batchSize = batchEnd - batchStart;

            if (_options.DropLast && batchSize < _options.BatchSize)
                break;

            var batchIndices = _indices.Skip(batchStart).Take(batchSize).ToList();
            var batchExamples = batchIndices.Select(i => _examples[i]).ToList();

            var batch = CreateBatch(batchExamples);

            if (_device.type != DeviceType.CPU)
            {
                batch = batch.ToDevice(_device);
            }

            _currentBatch++;
            yield return batch;
        }
    }

    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    private TrainingBatch CreateBatch(List<TokenizedExample> examples)
    {
        var batchSize = examples.Count;
        var maxLength = examples.Max(e => e.SequenceLength);
        maxLength = Math.Min(maxLength, _options.MaxSequenceLength);

        // Create padded arrays
        var inputIds = new int[batchSize, maxLength];
        var attentionMask = new int[batchSize, maxLength];
        var labels = new int[batchSize, maxLength];

        // Initialize with padding
        for (int i = 0; i < batchSize; i++)
        {
            for (int j = 0; j < maxLength; j++)
            {
                inputIds[i, j] = _options.PadTokenId;
                attentionMask[i, j] = 0;
                labels[i, j] = _options.PadLabelId;
            }
        }

        // Fill in actual values
        var totalTokens = 0;
        for (int i = 0; i < batchSize; i++)
        {
            var example = examples[i];
            var seqLen = Math.Min(example.SequenceLength, maxLength);

            for (int j = 0; j < seqLen; j++)
            {
                inputIds[i, j] = example.InputIds[j];
                attentionMask[i, j] = example.AttentionMask[j];
                labels[i, j] = example.Labels[j];
            }

            totalTokens += seqLen;
        }

        // Convert to tensors
        return new TrainingBatch
        {
            InputIds = torch.tensor(inputIds, dtype: torch.int64),
            AttentionMask = torch.tensor(attentionMask, dtype: torch.int64),
            Labels = torch.tensor(labels, dtype: torch.int64),
            BatchSize = batchSize,
            SequenceLength = maxLength,
            TotalTokens = totalTokens
        };
    }

    private void SortByLength()
    {
        _indices = _indices
            .OrderBy(i => _examples[i].SequenceLength)
            .ToList();
    }

    private void ShuffleWithinBuckets()
    {
        // Group into buckets of similar lengths
        var bucketSize = _options.BatchSize * 4;
        var buckets = new List<List<int>>();

        for (int i = 0; i < _indices.Count; i += bucketSize)
        {
            var bucket = _indices.Skip(i).Take(bucketSize).ToList();
            buckets.Add(bucket);
        }

        // Shuffle within each bucket
        foreach (var bucket in buckets)
        {
            for (int i = bucket.Count - 1; i > 0; i--)
            {
                var j = _random.Next(i + 1);
                (bucket[i], bucket[j]) = (bucket[j], bucket[i]);
            }
        }

        // Shuffle bucket order
        buckets = buckets.OrderBy(_ => _random.Next()).ToList();

        // Flatten back
        _indices = buckets.SelectMany(b => b).ToList();
    }

    public void Dispose()
    {
        // No unmanaged resources to dispose
    }
}
```

#### 4. Services/Training/DataLoaderFactory.cs

```csharp
namespace SeniorIntern.Services.Training;

/// <summary>
/// Factory for creating data loaders
/// </summary>
public sealed class DataLoaderFactory
{
    private readonly ILogger<TrainingDataLoader> _loaderLogger;

    public DataLoaderFactory(ILogger<TrainingDataLoader> loaderLogger)
    {
        _loaderLogger = loaderLogger;
    }

    /// <summary>
    /// Create a data loader for the given examples
    /// </summary>
    public IDataLoader Create(
        IReadOnlyList<TokenizedExample> examples,
        DataLoaderOptions options)
    {
        return new TrainingDataLoader(examples, options, _loaderLogger);
    }

    /// <summary>
    /// Create train and validation loaders with an 80/20 split
    /// </summary>
    public (IDataLoader Train, IDataLoader Validation) CreateSplit(
        IReadOnlyList<TokenizedExample> examples,
        DataLoaderOptions options,
        float validationRatio = 0.1f)
    {
        var splitIndex = (int)(examples.Count * (1 - validationRatio));

        var trainExamples = examples.Take(splitIndex).ToList();
        var valExamples = examples.Skip(splitIndex).ToList();

        var trainLoader = new TrainingDataLoader(
            trainExamples,
            options with { Shuffle = true },
            _loaderLogger);

        var valLoader = new TrainingDataLoader(
            valExamples,
            options with { Shuffle = false, DropLast = false },
            _loaderLogger);

        return (trainLoader, valLoader);
    }
}
```

### v0.8.2h File Summary

| File | Purpose | Lines (Est.) |
|------|---------|--------------|
| `Core/Training/DataLoaderOptions.cs` | Data loader configuration | ~60 |
| `Core/Interfaces/IDataLoader.cs` | Data loader interface | ~45 |
| `Services/Training/TrainingDataLoader.cs` | Data loader implementation | ~200 |
| `Services/Training/DataLoaderFactory.cs` | Factory for creating loaders | ~60 |

**v0.8.2h Total: 4 files to create**

---

## v0.8.2i: Dataset Persistence

### Objective
Implement serialization and deserialization of datasets for saving/loading to disk.

### Files to Create

#### 1. Core/Interfaces/IDatasetSerializer.cs

```csharp
namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Interface for serializing and deserializing datasets
/// </summary>
public interface IDatasetSerializer
{
    /// <summary>
    /// Save a dataset to disk
    /// </summary>
    Task SaveAsync(
        TrainingDataset dataset,
        string path,
        CancellationToken ct = default);

    /// <summary>
    /// Load a dataset from disk
    /// </summary>
    Task<TrainingDataset> LoadAsync(
        string path,
        CancellationToken ct = default);

    /// <summary>
    /// Check if a dataset file exists
    /// </summary>
    bool Exists(string path);
}
```

#### 2. Services/Training/JsonDatasetSerializer.cs

```csharp
namespace SeniorIntern.Services.Training;

using System.IO.Compression;
using System.Text.Json;
using System.Text.Json.Serialization;

/// <summary>
/// JSON-based dataset serializer with optional compression
/// </summary>
public sealed class JsonDatasetSerializer : IDatasetSerializer
{
    private readonly ILogger<JsonDatasetSerializer> _logger;

    private static readonly JsonSerializerOptions JsonOptions = new()
    {
        WriteIndented = false,
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
        Converters =
        {
            new JsonStringEnumConverter(JsonNamingPolicy.CamelCase)
        },
        DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
    };

    public JsonDatasetSerializer(ILogger<JsonDatasetSerializer> logger)
    {
        _logger = logger;
    }

    public async Task SaveAsync(
        TrainingDataset dataset,
        string path,
        CancellationToken ct = default)
    {
        _logger.LogInformation("Saving dataset to {Path}", path);
        var stopwatch = Stopwatch.StartNew();

        var directory = Path.GetDirectoryName(path);
        if (!string.IsNullOrEmpty(directory))
        {
            Directory.CreateDirectory(directory);
        }

        // Determine if we should compress based on extension
        var useCompression = path.EndsWith(".gz", StringComparison.OrdinalIgnoreCase);

        if (useCompression)
        {
            await using var fileStream = File.Create(path);
            await using var gzipStream = new GZipStream(fileStream, CompressionLevel.Optimal);
            await JsonSerializer.SerializeAsync(gzipStream, dataset, JsonOptions, ct);
        }
        else
        {
            var json = JsonSerializer.Serialize(dataset, JsonOptions);
            await File.WriteAllTextAsync(path, json, ct);
        }

        stopwatch.Stop();
        var fileSize = new FileInfo(path).Length;

        _logger.LogInformation(
            "Dataset saved: {Size:F2} MB in {Duration:F2}s",
            fileSize / (1024.0 * 1024.0),
            stopwatch.Elapsed.TotalSeconds);
    }

    public async Task<TrainingDataset> LoadAsync(
        string path,
        CancellationToken ct = default)
    {
        _logger.LogInformation("Loading dataset from {Path}", path);
        var stopwatch = Stopwatch.StartNew();

        if (!File.Exists(path))
        {
            throw new FileNotFoundException($"Dataset file not found: {path}");
        }

        TrainingDataset? dataset;
        var useCompression = path.EndsWith(".gz", StringComparison.OrdinalIgnoreCase);

        if (useCompression)
        {
            await using var fileStream = File.OpenRead(path);
            await using var gzipStream = new GZipStream(fileStream, CompressionMode.Decompress);
            dataset = await JsonSerializer.DeserializeAsync<TrainingDataset>(
                gzipStream, JsonOptions, ct);
        }
        else
        {
            var json = await File.ReadAllTextAsync(path, ct);
            dataset = JsonSerializer.Deserialize<TrainingDataset>(json, JsonOptions);
        }

        if (dataset == null)
        {
            throw new InvalidOperationException($"Failed to deserialize dataset from {path}");
        }

        stopwatch.Stop();

        _logger.LogInformation(
            "Dataset loaded: {Examples} examples in {Duration:F2}s",
            dataset.Examples.Count,
            stopwatch.Elapsed.TotalSeconds);

        return dataset;
    }

    public bool Exists(string path)
    {
        return File.Exists(path);
    }
}
```

#### 3. Services/Training/DatasetExporter.cs

```csharp
namespace SeniorIntern.Services.Training;

/// <summary>
/// Exports datasets to various formats for external tools
/// </summary>
public sealed class DatasetExporter
{
    private readonly ILogger<DatasetExporter> _logger;

    public DatasetExporter(ILogger<DatasetExporter> logger)
    {
        _logger = logger;
    }

    /// <summary>
    /// Export to JSONL format (one JSON object per line)
    /// </summary>
    public async Task ExportToJsonlAsync(
        TrainingDataset dataset,
        string outputPath,
        JsonlExportOptions? options = null,
        CancellationToken ct = default)
    {
        options ??= new JsonlExportOptions();

        _logger.LogInformation("Exporting dataset to JSONL: {Path}", outputPath);

        var directory = Path.GetDirectoryName(outputPath);
        if (!string.IsNullOrEmpty(directory))
        {
            Directory.CreateDirectory(directory);
        }

        await using var writer = new StreamWriter(outputPath);

        foreach (var example in dataset.Examples)
        {
            ct.ThrowIfCancellationRequested();

            var jsonObject = options.Format switch
            {
                JsonlFormat.Alpaca => new
                {
                    instruction = example.Instruction,
                    input = example.Input,
                    output = example.Output
                },
                JsonlFormat.ShareGPT => new
                {
                    conversations = new[]
                    {
                        new { from = "human", value = $"{example.Instruction}\n{example.Input}".Trim() },
                        new { from = "gpt", value = example.Output }
                    }
                },
                JsonlFormat.OpenAI => new
                {
                    messages = new object[]
                    {
                        example.SystemPrompt != null
                            ? new { role = "system", content = example.SystemPrompt }
                            : null!,
                        new { role = "user", content = $"{example.Instruction}\n{example.Input}".Trim() },
                        new { role = "assistant", content = example.Output }
                    }.Where(m => m != null)
                },
                _ => (object)new
                {
                    instruction = example.Instruction,
                    input = example.Input,
                    output = example.Output
                }
            };

            var json = JsonSerializer.Serialize(jsonObject, new JsonSerializerOptions
            {
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase
            });

            await writer.WriteLineAsync(json);
        }

        _logger.LogInformation("Exported {Count} examples to JSONL", dataset.Examples.Count);
    }

    /// <summary>
    /// Export to CSV format
    /// </summary>
    public async Task ExportToCsvAsync(
        TrainingDataset dataset,
        string outputPath,
        CancellationToken ct = default)
    {
        _logger.LogInformation("Exporting dataset to CSV: {Path}", outputPath);

        var directory = Path.GetDirectoryName(outputPath);
        if (!string.IsNullOrEmpty(directory))
        {
            Directory.CreateDirectory(directory);
        }

        await using var writer = new StreamWriter(outputPath);

        // Write header
        await writer.WriteLineAsync("instruction,input,output,language,example_type");

        foreach (var example in dataset.Examples)
        {
            ct.ThrowIfCancellationRequested();

            var line = string.Join(",",
                EscapeCsv(example.Instruction),
                EscapeCsv(example.Input),
                EscapeCsv(example.Output),
                EscapeCsv(example.Source.Language ?? ""),
                EscapeCsv(example.ExampleType.ToString()));

            await writer.WriteLineAsync(line);
        }

        _logger.LogInformation("Exported {Count} examples to CSV", dataset.Examples.Count);
    }

    private static string EscapeCsv(string value)
    {
        if (value.Contains(',') || value.Contains('"') || value.Contains('\n'))
        {
            return $"\"{value.Replace("\"", "\"\"")}\"";
        }
        return value;
    }
}

/// <summary>
/// JSONL export format options
/// </summary>
public sealed class JsonlExportOptions
{
    public JsonlFormat Format { get; init; } = JsonlFormat.Alpaca;
}

public enum JsonlFormat
{
    /// <summary>instruction, input, output format</summary>
    Alpaca,

    /// <summary>ShareGPT conversations format</summary>
    ShareGPT,

    /// <summary>OpenAI messages format</summary>
    OpenAI
}
```

### v0.8.2i File Summary

| File | Purpose | Lines (Est.) |
|------|---------|--------------|
| `Core/Interfaces/IDatasetSerializer.cs` | Serializer interface | ~30 |
| `Services/Training/JsonDatasetSerializer.cs` | JSON serialization | ~120 |
| `Services/Training/DatasetExporter.cs` | Export to external formats | ~130 |

**v0.8.2i Total: 3 files to create**

---

## v0.8.2j: Unit Testing

### Objective
Create comprehensive unit tests for all dataset pipeline components.

### Files to Create

| File | Purpose |
|------|---------|
| `Tests/Training/TrainingExampleTests.cs` | Tests for training example models |
| `Tests/Training/CodeScannerTests.cs` | Tests for code scanner |
| `Tests/Training/LanguageDetectorTests.cs` | Tests for language detection |
| `Tests/Training/RegexSymbolExtractorTests.cs` | Tests for regex extraction |
| `Tests/Training/RoslynSymbolExtractorTests.cs` | Tests for Roslyn extraction |
| `Tests/Training/InstructionTemplateGeneratorTests.cs` | Tests for template generation |
| `Tests/Training/ExampleDeduplicatorTests.cs` | Tests for deduplication |
| `Tests/Training/TokenizationServiceTests.cs` | Tests for tokenization |
| `Tests/Training/TrainingDataLoaderTests.cs` | Tests for data loader |
| `Tests/Training/DatasetServiceTests.cs` | Integration tests for dataset service |
| `Tests/Training/JsonDatasetSerializerTests.cs` | Tests for serialization |

**v0.8.2j Total: 11 test files to create**

---

## Success Criteria

### Functional Requirements
- [ ] Code scanning discovers all supported language files
- [ ] Symbol extraction works for C#, TypeScript, Python, Go, Rust, Java
- [ ] Instruction templates generate diverse training examples
- [ ] Deduplication removes near-duplicates with configurable threshold
- [ ] Tokenization supports multiple chat template formats
- [ ] Data loaders create properly padded batches
- [ ] Datasets can be saved and loaded without data loss

### Performance Requirements
- [ ] Scan 10,000 files in under 30 seconds
- [ ] Extract symbols from 1,000 files in under 60 seconds
- [ ] Generate 100,000 examples in under 2 minutes
- [ ] Tokenize 10,000 examples in under 60 seconds
- [ ] Data loader iteration adds less than 10ms per batch

### Quality Requirements
- [ ] All public APIs have XML documentation
- [ ] Unit test coverage exceeds 80%
- [ ] No memory leaks during dataset processing
- [ ] Proper cancellation token support throughout

---

## File Summary

| Sub-Version | Files to Create | Files to Modify |
|-------------|-----------------|-----------------|
| v0.8.2a | 4 | 0 |
| v0.8.2b | 3 | 0 |
| v0.8.2c | 5 | 0 |
| v0.8.2d | 1 | 0 |
| v0.8.2e | 2 | 0 |
| v0.8.2f | 2 | 0 |
| v0.8.2g | 2 | 0 |
| v0.8.2h | 4 | 0 |
| v0.8.2i | 3 | 0 |
| v0.8.2j | 11 | 0 |
| **Total** | **37** | **0** |

---

## Dependencies

### NuGet Packages Required
```xml
<PackageReference Include="Microsoft.Extensions.FileSystemGlobbing" Version="8.0.0" />
<PackageReference Include="Microsoft.CodeAnalysis.CSharp" Version="4.8.0" />
<PackageReference Include="LLamaSharp" Version="0.11.0" />
<PackageReference Include="TorchSharp" Version="0.102.0" />
```

### Project References
- `SeniorIntern.Core` (interfaces and models)
- `SeniorIntern.Services` (service implementations)

---

## Integration with v0.8.1

The Dataset Pipeline integrates with the Training Infrastructure (v0.8.1) through:

1. **TorchSharp Tensors**: `TrainingBatch` uses `torch.Tensor` for batch data
2. **Device Support**: Data loaders support moving batches to GPU via `ToDevice()`
3. **Configuration**: Uses `TrainingConfiguration` for batch size and sequence length settings

---

## Next Steps (v0.8.3)

After completing the Dataset Pipeline, the next version (v0.8.3: LoRA Training Engine) will:

1. Consume `IDataLoader` for training iteration
2. Use `TrainingBatch` tensors for forward/backward passes
3. Integrate with `TrainingConfiguration` for hyperparameters
4. Build on TorchSharp infrastructure from v0.8.1
