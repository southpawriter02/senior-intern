# Design Specification: AIntern v0.5.2c "Terminal Control"

## Overview

**Version**: v0.5.2c
**Parent**: v0.5.2 Terminal UI
**Focus**: Main terminal control with input handling, selection, clipboard, and cursor blinking

### Purpose

This sub-version creates the main `TerminalControl` UserControl that wraps the `TerminalRenderer` and provides:
1. Keyboard input handling with VT100/xterm escape sequence generation
2. Mouse input handling for text selection (single, double, triple click)
3. Clipboard integration (copy/paste with Ctrl+Shift+C/V)
4. Cursor blink animation controlled by the active theme
5. Terminal session attachment and lifecycle management
6. Size synchronization with the underlying PTY

### Dependencies

- **v0.5.1c**: `ITerminalService` interface, `TerminalBuffer`, `TerminalSession`, `TerminalSessionState`
- **v0.5.2a**: `TerminalTheme`, `CursorStyle` (for cursor blinking and theme integration)
- **v0.5.2b**: `TerminalRenderer`, `TerminalFontMetrics` (for rendering and coordinate conversion)

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                      v0.5.2c Terminal Control Architecture                    │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                       TerminalControl (UserControl)                      │ │
│  │  src/AIntern.Desktop/Controls/Terminal/                                 │ │
│  ├─────────────────────────────────────────────────────────────────────────┤ │
│  │                                                                          │ │
│  │  ┌────────────────────────────────────────────────────────────────────┐ │ │
│  │  │                        XAML Structure                               │ │ │
│  │  │  ┌─────────────────────────────────────────────────────────────┐   │ │ │
│  │  │  │  <Grid>                                                      │   │ │ │
│  │  │  │    ├── TerminalRenderer x:Name="Renderer"                   │   │ │ │
│  │  │  │    │   └── FontFamily, FontSize bound to parent             │   │ │ │
│  │  │  │    └── ScrollBar x:Name="VerticalScrollBar"                 │   │ │ │
│  │  │  │        └── Orientation="Vertical", HorizontalAlignment="Right"│   │ │ │
│  │  │  └─────────────────────────────────────────────────────────────┘   │ │ │
│  │  └────────────────────────────────────────────────────────────────────┘ │ │
│  │                                                                          │ │
│  │  ┌────────────────────────────────────────────────────────────────────┐ │ │
│  │  │                      Styled Properties                              │ │ │
│  │  │  ├── FontFamily: string = "Cascadia Mono"                          │ │ │
│  │  │  ├── FontSize: double = 14.0                                       │ │ │
│  │  │  └── Theme: TerminalTheme = TerminalTheme.Dark                     │ │ │
│  │  └────────────────────────────────────────────────────────────────────┘ │ │
│  │                                                                          │ │
│  │  ┌────────────────────────────────────────────────────────────────────┐ │ │
│  │  │                      Input Handling                                 │ │ │
│  │  │  ┌─────────────────────────────────────────────────────────────┐   │ │ │
│  │  │  │  Keyboard:                                                   │   │ │ │
│  │  │  │  ├── OnKeyDown → GetKeySequence → WriteInputAsync           │   │ │ │
│  │  │  │  │   ├── Function keys (F1-F12) → VT escape sequences       │   │ │ │
│  │  │  │  │   ├── Arrow keys → CSI A/B/C/D                           │   │ │ │
│  │  │  │  │   ├── Home/End/PgUp/PgDn → CSI sequences                 │   │ │ │
│  │  │  │  │   └── Ctrl+key → Control characters                      │   │ │ │
│  │  │  │  ├── OnTextInput → WriteInputAsync (printable chars)        │   │ │ │
│  │  │  │  └── Clipboard: Ctrl+Shift+C (copy), Ctrl+Shift+V (paste)   │   │ │ │
│  │  │  └─────────────────────────────────────────────────────────────┘   │ │ │
│  │  │  ┌─────────────────────────────────────────────────────────────┐   │ │ │
│  │  │  │  Mouse:                                                      │   │ │ │
│  │  │  │  ├── Single click → Start selection                         │   │ │ │
│  │  │  │  ├── Double click → SelectWord                              │   │ │ │
│  │  │  │  ├── Triple click → SelectLine                              │   │ │ │
│  │  │  │  ├── Drag → UpdateSelection                                 │   │ │ │
│  │  │  │  ├── Right click → Paste (if no selection)                  │   │ │ │
│  │  │  │  └── Wheel → Scroll buffer (3 lines per tick)               │   │ │ │
│  │  │  └─────────────────────────────────────────────────────────────┘   │ │ │
│  │  └────────────────────────────────────────────────────────────────────┘ │ │
│  │                                                                          │ │
│  │  ┌────────────────────────────────────────────────────────────────────┐ │ │
│  │  │                      Session Management                             │ │ │
│  │  │  ├── AttachSessionAsync(ITerminalService, Guid)                    │ │ │
│  │  │  │   ├── Detach from previous session                              │ │ │
│  │  │  │   ├── Get buffer from service                                   │ │ │
│  │  │  │   ├── Configure renderer                                        │ │ │
│  │  │  │   ├── Subscribe to OutputReceived / SessionStateChanged         │ │ │
│  │  │  │   └── Sync terminal size                                        │ │ │
│  │  │  └── DetachSession()                                               │ │ │
│  │  └────────────────────────────────────────────────────────────────────┘ │ │
│  │                                                                          │ │
│  │  ┌────────────────────────────────────────────────────────────────────┐ │ │
│  │  │                      Cursor Blink Animation                         │ │ │
│  │  │  ├── _cursorBlinkTimer: DispatcherTimer                            │ │ │
│  │  │  ├── Interval: Theme.CursorBlinkIntervalMs (default 530ms)         │ │ │
│  │  │  ├── OnGotFocus → Start timer if CursorBlink enabled               │ │ │
│  │  │  ├── OnLostFocus → Stop timer, show cursor                         │ │ │
│  │  │  └── ResetCursorBlink → Called on keystroke/output                 │ │ │
│  │  └────────────────────────────────────────────────────────────────────┘ │ │
│  │                                                                          │ │
│  │  ┌────────────────────────────────────────────────────────────────────┐ │ │
│  │  │                      Size Synchronization                           │ │ │
│  │  │  ├── OnBoundsChanged → SyncTerminalSizeAsync                       │ │ │
│  │  │  ├── Calculate (cols, rows) using Renderer.Metrics                 │ │ │
│  │  │  ├── Call ITerminalService.ResizeAsync                             │ │ │
│  │  │  └── Raise SizeChanged event                                       │ │ │
│  │  └────────────────────────────────────────────────────────────────────┘ │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                      Supporting Types                                    │ │
│  ├─────────────────────────────────────────────────────────────────────────┤ │
│  │                                                                          │ │
│  │  ┌──────────────────────────────────────┐                               │ │
│  │  │  TerminalSizeChangedEventArgs        │                               │ │
│  │  │  ├── Columns: int                    │                               │ │
│  │  │  └── Rows: int                       │                               │ │
│  │  └──────────────────────────────────────┘                               │ │
│  │                                                                          │ │
│  │  ┌──────────────────────────────────────┐                               │ │
│  │  │  TerminalSelection (from v0.5.1b)    │                               │ │
│  │  │  ├── StartLine: int                  │                               │ │
│  │  │  ├── StartColumn: int                │                               │ │
│  │  │  ├── EndLine: int                    │                               │ │
│  │  │  ├── EndColumn: int                  │                               │ │
│  │  │  ├── IsBlock: bool                   │                               │ │
│  │  │  ├── IsEmpty (computed)              │                               │ │
│  │  │  └── Contains(line, col) method      │                               │ │
│  │  └──────────────────────────────────────┘                               │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Key Sequence Mapping

The terminal control translates Avalonia key events to VT100/xterm escape sequences:

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                        Key Sequence Mapping                                   │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  Special Keys                                                            │ │
│  │  ┌──────────────────┬─────────────────────────────────────────────────┐ │ │
│  │  │  Key             │  Escape Sequence                                │ │ │
│  │  ├──────────────────┼─────────────────────────────────────────────────┤ │ │
│  │  │  Enter           │  \r (Carriage Return)                           │ │ │
│  │  │  Escape          │  \x1B (ESC)                                     │ │ │
│  │  │  Tab             │  \t                                             │ │ │
│  │  │  Shift+Tab       │  \x1B[Z (Back Tab)                              │ │ │
│  │  │  Backspace       │  \x7F (DEL)                                     │ │ │
│  │  │  Delete          │  \x1B[3~ (CSI 3 ~)                              │ │ │
│  │  │  Insert          │  \x1B[2~ (CSI 2 ~)                              │ │ │
│  │  └──────────────────┴─────────────────────────────────────────────────┘ │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  Arrow Keys                                                              │ │
│  │  ┌──────────────────┬─────────────────────────────────────────────────┐ │ │
│  │  │  Key             │  Escape Sequence                                │ │ │
│  │  ├──────────────────┼─────────────────────────────────────────────────┤ │ │
│  │  │  Up              │  \x1B[A (CSI A)                                 │ │ │
│  │  │  Down            │  \x1B[B (CSI B)                                 │ │ │
│  │  │  Right           │  \x1B[C (CSI C)                                 │ │ │
│  │  │  Left            │  \x1B[D (CSI D)                                 │ │ │
│  │  └──────────────────┴─────────────────────────────────────────────────┘ │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  Navigation Keys                                                         │ │
│  │  ┌──────────────────┬─────────────────────────────────────────────────┐ │ │
│  │  │  Key             │  Escape Sequence                                │ │ │
│  │  ├──────────────────┼─────────────────────────────────────────────────┤ │ │
│  │  │  Home            │  \x1B[H                                         │ │ │
│  │  │  Ctrl+Home       │  \x1B[1;5H                                      │ │ │
│  │  │  End             │  \x1B[F                                         │ │ │
│  │  │  Ctrl+End        │  \x1B[1;5F                                      │ │ │
│  │  │  PageUp          │  \x1B[5~ (CSI 5 ~)                              │ │ │
│  │  │  PageDown        │  \x1B[6~ (CSI 6 ~)                              │ │ │
│  │  └──────────────────┴─────────────────────────────────────────────────┘ │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  Function Keys                                                           │ │
│  │  ┌──────────────────┬─────────────────────────────────────────────────┐ │ │
│  │  │  Key             │  Escape Sequence                                │ │ │
│  │  ├──────────────────┼─────────────────────────────────────────────────┤ │ │
│  │  │  F1              │  \x1BOP (ESC O P)                               │ │ │
│  │  │  F2              │  \x1BOQ (ESC O Q)                               │ │ │
│  │  │  F3              │  \x1BOR (ESC O R)                               │ │ │
│  │  │  F4              │  \x1BOS (ESC O S)                               │ │ │
│  │  │  F5              │  \x1B[15~                                       │ │ │
│  │  │  F6              │  \x1B[17~                                       │ │ │
│  │  │  F7              │  \x1B[18~                                       │ │ │
│  │  │  F8              │  \x1B[19~                                       │ │ │
│  │  │  F9              │  \x1B[20~                                       │ │ │
│  │  │  F10             │  \x1B[21~                                       │ │ │
│  │  │  F11             │  \x1B[23~                                       │ │ │
│  │  │  F12             │  \x1B[24~                                       │ │ │
│  │  └──────────────────┴─────────────────────────────────────────────────┘ │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  Control Key Combinations                                                │ │
│  │  ┌──────────────────┬─────────────────────────────────────────────────┐ │ │
│  │  │  Combination     │  Control Char / Purpose                         │ │ │
│  │  ├──────────────────┼─────────────────────────────────────────────────┤ │ │
│  │  │  Ctrl+C          │  \x03 (ETX / SIGINT)                            │ │ │
│  │  │  Ctrl+Z          │  \x1A (SUB / SIGTSTP)                           │ │ │
│  │  │  Ctrl+D          │  \x04 (EOT / EOF)                               │ │ │
│  │  │  Ctrl+L          │  \x0C (FF / Clear screen)                       │ │ │
│  │  │  Ctrl+A          │  \x01 (SOH / Beginning of line)                 │ │ │
│  │  │  Ctrl+E          │  \x05 (ENQ / End of line)                       │ │ │
│  │  │  Ctrl+K          │  \x0B (VT / Kill to end of line)                │ │ │
│  │  │  Ctrl+U          │  \x15 (NAK / Kill to beginning)                 │ │ │
│  │  │  Ctrl+W          │  \x17 (ETB / Kill word backward)                │ │ │
│  │  │  Ctrl+R          │  \x12 (DC2 / Reverse search)                    │ │ │
│  │  │  Ctrl+P          │  \x10 (DLE / Previous history)                  │ │ │
│  │  │  Ctrl+N          │  \x0E (SO / Next history)                       │ │ │
│  │  │  Ctrl+[A-Z]      │  \x01-\x1A (ASCII control character)            │ │ │
│  │  └──────────────────┴─────────────────────────────────────────────────┘ │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Selection Behavior

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                        Text Selection Behavior                                │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  Click Detection (500ms window, 5px tolerance)                          │ │
│  │  ┌───────────────────────────────────────────────────────────────────┐  │ │
│  │  │  1. Track _lastClickTime and _lastClickPosition                  │  │ │
│  │  │  2. If click within 500ms and 5px of last click: _clickCount++   │  │ │
│  │  │  3. Otherwise: _clickCount = 1                                    │  │ │
│  │  └───────────────────────────────────────────────────────────────────┘  │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  Selection Modes                                                         │ │
│  │  ┌───────────────────────────────────────────────────────────────────┐  │ │
│  │  │  _clickCount == 1: Character Selection                           │  │ │
│  │  │    • Set _isSelecting = true                                      │  │ │
│  │  │    • Record _selectionStartPixel                                  │  │ │
│  │  │    • Update selection on PointerMoved                             │  │ │
│  │  │    • Clear _isSelecting on PointerReleased                        │  │ │
│  │  ├───────────────────────────────────────────────────────────────────┤  │ │
│  │  │  _clickCount == 2: Word Selection                                 │  │ │
│  │  │    • Convert pointer position to cell coordinates                 │  │ │
│  │  │    • Get line from buffer                                         │  │ │
│  │  │    • Expand left while IsWordChar(char)                           │  │ │
│  │  │    • Expand right while IsWordChar(char)                          │  │ │
│  │  │    • IsWordChar: char.IsLetterOrDigit(c) || c == '_' || c == '-'  │  │ │
│  │  ├───────────────────────────────────────────────────────────────────┤  │ │
│  │  │  _clickCount == 3: Line Selection                                 │  │ │
│  │  │    • Convert pointer position to cell row                         │  │ │
│  │  │    • Set StartColumn = 0                                          │  │ │
│  │  │    • Set EndColumn = buffer.Columns - 1                           │  │ │
│  │  └───────────────────────────────────────────────────────────────────┘  │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  Coordinate Conversion                                                   │ │
│  │  ┌───────────────────────────────────────────────────────────────────┐  │ │
│  │  │  PixelToCell(Point):                                              │  │ │
│  │  │    col = (int)(x / metrics.CharWidth)                             │  │ │
│  │  │    row = (int)(y / metrics.LineHeight)                            │  │ │
│  │  │                                                                    │  │ │
│  │  │  Scrollback adjustment:                                            │  │ │
│  │  │    scrollbackStart = buffer.TotalLines - buffer.Rows - ScrollOffset│  │ │
│  │  │    absoluteLine = scrollbackStart + row                            │  │ │
│  │  └───────────────────────────────────────────────────────────────────┘  │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Specifications

### 1. TerminalControl.axaml

**Location**: `src/AIntern.Desktop/Controls/Terminal/TerminalControl.axaml`
**Type**: UserControl XAML
**Purpose**: Define the visual layout of the terminal control

```xml
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:local="using:AIntern.Desktop.Controls.Terminal"
             x:Class="AIntern.Desktop.Controls.Terminal.TerminalControl"
             Focusable="True"
             Background="Transparent">

    <!--
        Terminal Control Layout (v0.5.2c)
        Contains the TerminalRenderer with an overlay scrollbar.
    -->
    <Grid>
        <!-- Terminal Renderer - Main display area -->
        <local:TerminalRenderer x:Name="Renderer"
                                FontFamily="{Binding FontFamily, RelativeSource={RelativeSource AncestorType=local:TerminalControl}}"
                                FontSize="{Binding FontSize, RelativeSource={RelativeSource AncestorType=local:TerminalControl}}" />

        <!-- Vertical Scrollbar - Overlay on right edge -->
        <ScrollBar x:Name="VerticalScrollBar"
                   Orientation="Vertical"
                   HorizontalAlignment="Right"
                   VerticalAlignment="Stretch"
                   Minimum="0"
                   Opacity="0"
                   Width="10"
                   Margin="0,0,2,0"
                   Theme="{DynamicResource TerminalScrollBar}" />
    </Grid>

</UserControl>
```

---

### 2. TerminalControl.axaml.cs

**Location**: `src/AIntern.Desktop/Controls/Terminal/TerminalControl.axaml.cs`
**Type**: Code-behind class
**Purpose**: Implement input handling, selection, clipboard, and cursor blinking

```csharp
namespace AIntern.Desktop.Controls.Terminal;

using Avalonia;
using Avalonia.Controls;
using Avalonia.Input;
using Avalonia.Interactivity;
using Avalonia.Threading;
using AIntern.Core.Interfaces;
using AIntern.Core.Models.Terminal;
using Microsoft.Extensions.Logging;

/// <summary>
/// Complete terminal control with input handling, selection, and clipboard support.
/// Wraps TerminalRenderer and manages terminal session attachment.
/// </summary>
/// <remarks>
/// <para>Added in v0.5.2c.</para>
/// <para>
/// Features:
/// - Keyboard input with VT100/xterm escape sequence generation
/// - Mouse text selection (single, double, triple click)
/// - Clipboard integration (Ctrl+Shift+C/V)
/// - Cursor blink animation
/// - Terminal size synchronization
/// </para>
/// </remarks>
public partial class TerminalControl : UserControl
{
    private readonly ILogger<TerminalControl>? _logger;
    private ITerminalService? _terminalService;
    private Guid _sessionId;
    private TerminalBuffer? _buffer;

    // ═══════════════════════════════════════════════════════════════
    // Selection State
    // ═══════════════════════════════════════════════════════════════

    private bool _isSelecting;
    private Point _selectionStartPixel;
    private TerminalSelection? _currentSelection;

    // ═══════════════════════════════════════════════════════════════
    // Cursor Blink
    // ═══════════════════════════════════════════════════════════════

    private DispatcherTimer? _cursorBlinkTimer;
    private bool _cursorBlinkState = true;

    // ═══════════════════════════════════════════════════════════════
    // Double/Triple Click Detection
    // ═══════════════════════════════════════════════════════════════

    private DateTime _lastClickTime;
    private Point _lastClickPosition;
    private int _clickCount;

    private const int ClickTimeWindowMs = 500;
    private const double ClickPositionTolerancePx = 5.0;
    private const int ScrollLinesPerTick = 3;

    // ═══════════════════════════════════════════════════════════════
    // Styled Properties
    // ═══════════════════════════════════════════════════════════════

    /// <summary>
    /// Font family for terminal text.
    /// </summary>
    public static readonly StyledProperty<string> FontFamilyProperty =
        AvaloniaProperty.Register<TerminalControl, string>(nameof(FontFamily), "Cascadia Mono");

    /// <summary>
    /// Font size for terminal text in points.
    /// </summary>
    public static readonly StyledProperty<double> FontSizeProperty =
        AvaloniaProperty.Register<TerminalControl, double>(nameof(FontSize), 14.0);

    /// <summary>
    /// Terminal color theme.
    /// </summary>
    public static readonly StyledProperty<TerminalTheme> ThemeProperty =
        AvaloniaProperty.Register<TerminalControl, TerminalTheme>(nameof(Theme), TerminalTheme.Dark);

    /// <summary>
    /// Gets or sets the font family for terminal text.
    /// </summary>
    public string FontFamily
    {
        get => GetValue(FontFamilyProperty);
        set => SetValue(FontFamilyProperty, value);
    }

    /// <summary>
    /// Gets or sets the font size for terminal text.
    /// </summary>
    public double FontSize
    {
        get => GetValue(FontSizeProperty);
        set => SetValue(FontSizeProperty, value);
    }

    /// <summary>
    /// Gets or sets the terminal color theme.
    /// </summary>
    public TerminalTheme Theme
    {
        get => GetValue(ThemeProperty);
        set => SetValue(ThemeProperty, value);
    }

    // ═══════════════════════════════════════════════════════════════
    // Events
    // ═══════════════════════════════════════════════════════════════

    /// <summary>
    /// Raised when the terminal size changes (columns/rows).
    /// </summary>
    public event EventHandler<TerminalSizeChangedEventArgs>? SizeChanged;

    // ═══════════════════════════════════════════════════════════════
    // Constructor
    // ═══════════════════════════════════════════════════════════════

    /// <summary>
    /// Creates a new TerminalControl instance.
    /// </summary>
    public TerminalControl()
    {
        InitializeComponent();

        // Pointer events
        PointerPressed += OnPointerPressed;
        PointerMoved += OnPointerMoved;
        PointerReleased += OnPointerReleased;
        PointerWheelChanged += OnPointerWheelChanged;
        DoubleTapped += OnDoubleTapped;

        // Focus events
        GotFocus += OnGotFocus;
        LostFocus += OnLostFocus;

        // Property changes
        PropertyChanged += OnControlPropertyChanged;

        _logger?.LogDebug("TerminalControl created");
    }

    // ═══════════════════════════════════════════════════════════════
    // Lifecycle
    // ═══════════════════════════════════════════════════════════════

    protected override void OnLoaded(RoutedEventArgs e)
    {
        base.OnLoaded(e);
        SetupCursorBlink();
        _logger?.LogDebug("TerminalControl loaded");
    }

    protected override void OnUnloaded(RoutedEventArgs e)
    {
        base.OnUnloaded(e);
        _cursorBlinkTimer?.Stop();
        _logger?.LogDebug("TerminalControl unloaded");
    }

    // ═══════════════════════════════════════════════════════════════
    // Session Management
    // ═══════════════════════════════════════════════════════════════

    /// <summary>
    /// Attaches to a terminal session.
    /// </summary>
    /// <param name="terminalService">The terminal service.</param>
    /// <param name="sessionId">The session ID to attach to.</param>
    public async Task AttachSessionAsync(
        ITerminalService terminalService,
        Guid sessionId)
    {
        _logger?.LogInformation("Attaching to session {SessionId}", sessionId);

        // Detach from previous session
        if (_terminalService != null)
        {
            _terminalService.OutputReceived -= OnOutputReceived;
            _terminalService.SessionStateChanged -= OnSessionStateChanged;
        }

        _terminalService = terminalService;
        _sessionId = sessionId;
        _buffer = terminalService.GetBuffer(sessionId);

        // Configure renderer
        Renderer.SetBuffer(_buffer);
        Renderer.SetTheme(Theme);

        // Subscribe to events
        _terminalService.OutputReceived += OnOutputReceived;
        _terminalService.SessionStateChanged += OnSessionStateChanged;

        // Sync size
        await SyncTerminalSizeAsync();

        // Reset cursor blink
        ResetCursorBlink();
    }

    /// <summary>
    /// Detaches from the current session.
    /// </summary>
    public void DetachSession()
    {
        _logger?.LogInformation("Detaching from session {SessionId}", _sessionId);

        if (_terminalService != null)
        {
            _terminalService.OutputReceived -= OnOutputReceived;
            _terminalService.SessionStateChanged -= OnSessionStateChanged;
        }

        _terminalService = null;
        _sessionId = Guid.Empty;
        _buffer = null;
    }

    // ═══════════════════════════════════════════════════════════════
    // Property Change Handling
    // ═══════════════════════════════════════════════════════════════

    private void OnControlPropertyChanged(object? sender, AvaloniaPropertyChangedEventArgs e)
    {
        if (e.Property == BoundsProperty)
        {
            _ = SyncTerminalSizeAsync();
        }
        else if (e.Property == ThemeProperty)
        {
            Renderer.SetTheme(Theme);
        }
    }

    private async Task SyncTerminalSizeAsync()
    {
        if (_terminalService == null || _sessionId == Guid.Empty)
            return;

        var metrics = Renderer.Metrics;
        if (!metrics.IsValid)
            return;

        var (cols, rows) = metrics.CalculateTerminalSize(Bounds.Width, Bounds.Height);

        if (cols > 0 && rows > 0)
        {
            _logger?.LogDebug("Resizing terminal to {Cols}x{Rows}", cols, rows);
            await _terminalService.ResizeAsync(_sessionId, new TerminalSize(cols, rows));
            SizeChanged?.Invoke(this, new TerminalSizeChangedEventArgs(cols, rows));
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // Terminal Service Event Handlers
    // ═══════════════════════════════════════════════════════════════

    private void OnOutputReceived(object? sender, TerminalOutputEventArgs e)
    {
        if (e.SessionId != _sessionId)
            return;

        // Reset cursor blink on output
        Dispatcher.UIThread.Post(ResetCursorBlink);
    }

    private void OnSessionStateChanged(object? sender, TerminalSessionEventArgs e)
    {
        if (e.Session.Id != _sessionId)
            return;

        // Stop cursor blink on session end
        if (e.Session.State == TerminalSessionState.Exited ||
            e.Session.State == TerminalSessionState.Error)
        {
            Dispatcher.UIThread.Post(() =>
            {
                _cursorBlinkTimer?.Stop();
                _logger?.LogInformation("Session {SessionId} ended with state {State}",
                    _sessionId, e.Session.State);
            });
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // Keyboard Input
    // ═══════════════════════════════════════════════════════════════

    protected override void OnKeyDown(KeyEventArgs e)
    {
        base.OnKeyDown(e);

        if (_terminalService == null || _sessionId == Guid.Empty)
            return;

        var ctrl = e.KeyModifiers.HasFlag(KeyModifiers.Control);
        var shift = e.KeyModifiers.HasFlag(KeyModifiers.Shift);

        // Clipboard shortcuts: Ctrl+Shift+C/V
        if (ctrl && shift && e.Key == Key.C)
        {
            _ = CopySelectionAsync();
            e.Handled = true;
            return;
        }

        if (ctrl && shift && e.Key == Key.V)
        {
            _ = PasteAsync();
            e.Handled = true;
            return;
        }

        // Convert key to terminal sequence
        var sequence = GetKeySequence(e);
        if (sequence != null)
        {
            _ = _terminalService.WriteInputAsync(_sessionId, sequence);
            ClearSelection();
            ResetCursorBlink();
            e.Handled = true;
        }
    }

    protected override void OnTextInput(TextInputEventArgs e)
    {
        base.OnTextInput(e);

        if (_terminalService == null || _sessionId == Guid.Empty)
            return;

        if (!string.IsNullOrEmpty(e.Text))
        {
            _ = _terminalService.WriteInputAsync(_sessionId, e.Text);
            ClearSelection();
            ResetCursorBlink();
            e.Handled = true;
        }
    }

    private string? GetKeySequence(KeyEventArgs e)
    {
        var ctrl = e.KeyModifiers.HasFlag(KeyModifiers.Control);
        var alt = e.KeyModifiers.HasFlag(KeyModifiers.Alt);
        var shift = e.KeyModifiers.HasFlag(KeyModifiers.Shift);

        // Special keys
        var sequence = e.Key switch
        {
            Key.Enter => "\r",
            Key.Escape => "\x1B",
            Key.Tab => shift ? "\x1B[Z" : "\t",
            Key.Back => "\x7F",
            Key.Delete => "\x1B[3~",
            Key.Up => "\x1B[A",
            Key.Down => "\x1B[B",
            Key.Right => "\x1B[C",
            Key.Left => "\x1B[D",
            Key.Home => ctrl ? "\x1B[1;5H" : "\x1B[H",
            Key.End => ctrl ? "\x1B[1;5F" : "\x1B[F",
            Key.PageUp => "\x1B[5~",
            Key.PageDown => "\x1B[6~",
            Key.Insert => "\x1B[2~",
            Key.F1 => "\x1BOP",
            Key.F2 => "\x1BOQ",
            Key.F3 => "\x1BOR",
            Key.F4 => "\x1BOS",
            Key.F5 => "\x1B[15~",
            Key.F6 => "\x1B[17~",
            Key.F7 => "\x1B[18~",
            Key.F8 => "\x1B[19~",
            Key.F9 => "\x1B[20~",
            Key.F10 => "\x1B[21~",
            Key.F11 => "\x1B[23~",
            Key.F12 => "\x1B[24~",
            _ => null
        };

        if (sequence != null)
            return sequence;

        // Ctrl+key combinations
        if (ctrl && !alt)
        {
            return e.Key switch
            {
                Key.C => "\x03",       // SIGINT
                Key.Z => "\x1A",       // SIGTSTP
                Key.D => "\x04",       // EOF
                Key.L => "\x0C",       // Clear screen
                Key.A => "\x01",       // Beginning of line
                Key.E => "\x05",       // End of line
                Key.K => "\x0B",       // Kill to end of line
                Key.U => "\x15",       // Kill to beginning of line
                Key.W => "\x17",       // Kill word backward
                Key.R => "\x12",       // Reverse search
                Key.P => "\x10",       // Previous history
                Key.N => "\x0E",       // Next history
                >= Key.A and <= Key.Z => ((char)(e.Key - Key.A + 1)).ToString(),
                _ => null
            };
        }

        return null;
    }

    // ═══════════════════════════════════════════════════════════════
    // Mouse Input & Selection
    // ═══════════════════════════════════════════════════════════════

    private void OnPointerPressed(object? sender, PointerPressedEventArgs e)
    {
        if (_buffer == null)
            return;

        var point = e.GetCurrentPoint(Renderer);
        var position = point.Position;

        // Handle click count for double/triple click
        var now = DateTime.UtcNow;
        if ((now - _lastClickTime).TotalMilliseconds < ClickTimeWindowMs &&
            Math.Abs(position.X - _lastClickPosition.X) < ClickPositionTolerancePx &&
            Math.Abs(position.Y - _lastClickPosition.Y) < ClickPositionTolerancePx)
        {
            _clickCount++;
        }
        else
        {
            _clickCount = 1;
        }

        _lastClickTime = now;
        _lastClickPosition = position;

        if (point.Properties.IsLeftButtonPressed)
        {
            Focus();

            if (_clickCount == 3)
            {
                SelectLine(position);
            }
            else if (_clickCount == 2)
            {
                SelectWord(position);
            }
            else
            {
                _isSelecting = true;
                _selectionStartPixel = position;
                _currentSelection = null;
                Renderer.Selection = null;
            }

            e.Handled = true;
        }
        else if (point.Properties.IsRightButtonPressed)
        {
            // Right click - paste if no selection
            if (_currentSelection == null || _currentSelection.IsEmpty)
            {
                _ = PasteAsync();
            }
            e.Handled = true;
        }
    }

    private void OnPointerMoved(object? sender, PointerEventArgs e)
    {
        if (!_isSelecting || _buffer == null)
            return;

        var position = e.GetPosition(Renderer);
        UpdateSelection(_selectionStartPixel, position);
    }

    private void OnPointerReleased(object? sender, PointerReleasedEventArgs e)
    {
        _isSelecting = false;
    }

    private void OnPointerWheelChanged(object? sender, PointerWheelEventArgs e)
    {
        if (_buffer == null)
            return;

        var delta = e.Delta.Y > 0 ? -ScrollLinesPerTick : ScrollLinesPerTick;
        var newOffset = Math.Clamp(
            _buffer.ScrollOffset + delta,
            0,
            _buffer.ScrollbackLines);

        _buffer.ScrollOffset = newOffset;

        // Update scrollbar
        VerticalScrollBar.Value = _buffer.ScrollbackLines - newOffset;

        e.Handled = true;
    }

    private void OnDoubleTapped(object? sender, TappedEventArgs e)
    {
        // Handled in OnPointerPressed via click count
    }

    private void UpdateSelection(Point start, Point end)
    {
        var metrics = Renderer.Metrics;
        var (startCol, startRow) = metrics.PixelToCell(start.X, start.Y);
        var (endCol, endRow) = metrics.PixelToCell(end.X, end.Y);

        var scrollbackStart = _buffer!.TotalLines - _buffer.Rows - _buffer.ScrollOffset;

        _currentSelection = new TerminalSelection(
            StartLine: scrollbackStart + startRow,
            StartColumn: startCol,
            EndLine: scrollbackStart + endRow,
            EndColumn: endCol);

        Renderer.Selection = _currentSelection;
    }

    private void SelectWord(Point position)
    {
        if (_buffer == null)
            return;

        var metrics = Renderer.Metrics;
        var (col, row) = metrics.PixelToCell(position.X, position.Y);

        var line = _buffer.GetLine(row);
        if (line == null)
            return;

        // Find word boundaries
        var startCol = col;
        var endCol = col;

        // Expand left
        while (startCol > 0 && IsWordChar(line[startCol - 1].Character))
            startCol--;

        // Expand right
        while (endCol < line.Length - 1 && IsWordChar(line[endCol + 1].Character))
            endCol++;

        var scrollbackStart = _buffer.TotalLines - _buffer.Rows - _buffer.ScrollOffset;

        _currentSelection = new TerminalSelection(
            StartLine: scrollbackStart + row,
            StartColumn: startCol,
            EndLine: scrollbackStart + row,
            EndColumn: endCol);

        Renderer.Selection = _currentSelection;
    }

    private void SelectLine(Point position)
    {
        if (_buffer == null)
            return;

        var metrics = Renderer.Metrics;
        var (_, row) = metrics.PixelToCell(position.X, position.Y);

        var scrollbackStart = _buffer.TotalLines - _buffer.Rows - _buffer.ScrollOffset;

        _currentSelection = new TerminalSelection(
            StartLine: scrollbackStart + row,
            StartColumn: 0,
            EndLine: scrollbackStart + row,
            EndColumn: _buffer.Columns - 1);

        Renderer.Selection = _currentSelection;
    }

    private static bool IsWordChar(Rune rune)
    {
        var c = (char)rune.Value;
        return char.IsLetterOrDigit(c) || c == '_' || c == '-';
    }

    private void ClearSelection()
    {
        _currentSelection = null;
        Renderer.Selection = null;
    }

    // ═══════════════════════════════════════════════════════════════
    // Clipboard
    // ═══════════════════════════════════════════════════════════════

    /// <summary>
    /// Copies the selected text to the clipboard.
    /// </summary>
    public async Task CopySelectionAsync()
    {
        if (_currentSelection == null || _currentSelection.IsEmpty || _buffer == null)
            return;

        var text = _buffer.GetSelectedText(_currentSelection);
        if (!string.IsNullOrEmpty(text))
        {
            var clipboard = TopLevel.GetTopLevel(this)?.Clipboard;
            if (clipboard != null)
            {
                await clipboard.SetTextAsync(text);
                _logger?.LogDebug("Copied {Length} characters to clipboard", text.Length);
            }
        }
    }

    /// <summary>
    /// Pastes text from the clipboard to the terminal.
    /// </summary>
    public async Task PasteAsync()
    {
        if (_terminalService == null || _sessionId == Guid.Empty)
            return;

        var clipboard = TopLevel.GetTopLevel(this)?.Clipboard;
        if (clipboard == null)
            return;

        var text = await clipboard.GetTextAsync();
        if (!string.IsNullOrEmpty(text))
        {
            // Convert Windows line endings to Unix
            text = text.Replace("\r\n", "\r").Replace("\n", "\r");

            await _terminalService.WriteInputAsync(_sessionId, text);
            _logger?.LogDebug("Pasted {Length} characters from clipboard", text.Length);
        }
    }

    /// <summary>
    /// Selects all text in the buffer.
    /// </summary>
    public void SelectAll()
    {
        if (_buffer == null)
            return;

        _currentSelection = new TerminalSelection(
            StartLine: 0,
            StartColumn: 0,
            EndLine: _buffer.TotalLines - 1,
            EndColumn: _buffer.Columns - 1);

        Renderer.Selection = _currentSelection;
    }

    // ═══════════════════════════════════════════════════════════════
    // Cursor Blink
    // ═══════════════════════════════════════════════════════════════

    private void SetupCursorBlink()
    {
        _cursorBlinkTimer = new DispatcherTimer
        {
            Interval = TimeSpan.FromMilliseconds(Theme.CursorBlinkIntervalMs)
        };
        _cursorBlinkTimer.Tick += OnCursorBlinkTick;

        if (IsFocused && Theme.CursorBlink)
        {
            _cursorBlinkTimer.Start();
        }
    }

    private void OnCursorBlinkTick(object? sender, EventArgs e)
    {
        _cursorBlinkState = !_cursorBlinkState;
        Renderer.CursorVisible = _cursorBlinkState;
    }

    private void ResetCursorBlink()
    {
        _cursorBlinkState = true;
        Renderer.CursorVisible = true;
        _cursorBlinkTimer?.Stop();

        if (IsFocused && Theme.CursorBlink)
        {
            _cursorBlinkTimer?.Start();
        }
    }

    private void OnGotFocus(object? sender, GotFocusEventArgs e)
    {
        ResetCursorBlink();
    }

    private void OnLostFocus(object? sender, RoutedEventArgs e)
    {
        _cursorBlinkTimer?.Stop();
        Renderer.CursorVisible = true;
    }
}

/// <summary>
/// Event args for terminal size changes.
/// </summary>
public sealed class TerminalSizeChangedEventArgs : EventArgs
{
    /// <summary>
    /// Number of columns.
    /// </summary>
    public int Columns { get; }

    /// <summary>
    /// Number of rows.
    /// </summary>
    public int Rows { get; }

    /// <summary>
    /// Creates a new TerminalSizeChangedEventArgs instance.
    /// </summary>
    public TerminalSizeChangedEventArgs(int columns, int rows)
    {
        Columns = columns;
        Rows = rows;
    }
}
```

---

## File Summary

### Files to Create

| File | Location | Purpose |
|------|----------|---------|
| `TerminalControl.axaml` | `src/AIntern.Desktop/Controls/Terminal/` | Terminal control XAML layout |
| `TerminalControl.axaml.cs` | `src/AIntern.Desktop/Controls/Terminal/` | Input handling, selection, clipboard, cursor blink |

### Files Modified

None - this version creates new files only.

---

## Unit Test Plan

### Test Categories

| Category | Test Count | Description |
|----------|------------|-------------|
| Key Sequence Mapping | 12 | Verify correct escape sequences for special keys |
| Selection Logic | 8 | Verify word/line boundary detection |
| Click Detection | 5 | Verify double/triple click timing |
| Coordinate Conversion | 4 | Verify pixel-to-cell calculations |

### Sample Test Cases

```csharp
public class TerminalControlTests
{
    [Theory]
    [InlineData(Key.Enter, "\r")]
    [InlineData(Key.Escape, "\x1B")]
    [InlineData(Key.Up, "\x1B[A")]
    [InlineData(Key.Down, "\x1B[B")]
    [InlineData(Key.F1, "\x1BOP")]
    public void GetKeySequence_SpecialKeys_ReturnsCorrectSequence(Key key, string expected)
    {
        // Arrange & Act
        var result = TerminalControl.GetKeySequenceForTesting(key, KeyModifiers.None);

        // Assert
        Assert.Equal(expected, result);
    }

    [Fact]
    public void GetKeySequence_CtrlC_ReturnsSigInt()
    {
        var result = TerminalControl.GetKeySequenceForTesting(Key.C, KeyModifiers.Control);
        Assert.Equal("\x03", result);
    }

    [Theory]
    [InlineData('a', true)]
    [InlineData('Z', true)]
    [InlineData('_', true)]
    [InlineData('-', true)]
    [InlineData(' ', false)]
    [InlineData('.', false)]
    public void IsWordChar_VariousChars_ReturnsExpected(char c, bool expected)
    {
        var result = TerminalControl.IsWordCharForTesting(new Rune(c));
        Assert.Equal(expected, result);
    }
}
```

---

## Verification Steps

### 1. Build Verification

```bash
# Verify Desktop project builds
dotnet build src/AIntern.Desktop
```

### 2. Runtime Verification

After building, manually verify:
1. Terminal accepts keyboard input
2. Arrow keys navigate in shells (bash, zsh, PowerShell)
3. Ctrl+C sends interrupt signal
4. Text selection works with mouse drag
5. Double-click selects word
6. Triple-click selects line
7. Ctrl+Shift+C copies selection
8. Ctrl+Shift+V pastes clipboard
9. Cursor blinks when focused
10. Cursor stops blinking when unfocused

---

## Integration Notes

### Usage in v0.5.2d (ViewModels)

The `TerminalControl` will be used by `TerminalSessionViewModel`:

```csharp
// In TerminalPanel.axaml
<local:TerminalControl x:Name="Terminal"
                       FontFamily="{Binding FontFamily}"
                       FontSize="{Binding FontSize}"
                       Theme="{Binding Theme}" />

// In TerminalSessionViewModel
public async Task InitializeAsync()
{
    await _terminalControl.AttachSessionAsync(_terminalService, Session.Id);
}
```

### Keyboard Focus Considerations

- Set `Focusable="True"` on the UserControl
- Handle focus programmatically when tab is selected
- Ensure focus is correctly passed through the visual tree

---

## Changelog Entry

```markdown
## v0.5.2c - Terminal Control

### Added
- `TerminalControl` UserControl with complete input handling
- Keyboard input with VT100/xterm escape sequence generation
  - All function keys (F1-F12)
  - Arrow keys and navigation (Home, End, PgUp, PgDn)
  - Delete, Insert, Backspace, Tab
  - All Ctrl+key combinations (A-Z)
- Mouse text selection
  - Single click to start selection
  - Double click to select word (letters, digits, underscore, hyphen)
  - Triple click to select line
  - Drag to update selection
- Clipboard integration
  - Ctrl+Shift+C to copy selection
  - Ctrl+Shift+V to paste
  - Right-click to paste (when no selection)
- Cursor blink animation using DispatcherTimer
  - Configurable interval via Theme.CursorBlinkIntervalMs
  - Resets on keystroke and output
  - Stops when control loses focus
- Terminal size synchronization with PTY
- Scrollbar overlay for buffer navigation
- `TerminalSizeChangedEventArgs` for size change notifications

### Files Created
- `src/AIntern.Desktop/Controls/Terminal/TerminalControl.axaml`
- `src/AIntern.Desktop/Controls/Terminal/TerminalControl.axaml.cs`
```
