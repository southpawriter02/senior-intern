# Design Specification: AIntern v0.5.2 "Terminal UI"

## Executive Summary

This document provides a comprehensive design specification for v0.5.2, which creates the Avalonia terminal user interface for AIntern. This sub-version implements the visual terminal control using SkiaSharp for high-performance rendering, creates the terminal panel with tab support, handles keyboard input and text selection, and integrates the terminal into the main window layout. This builds directly on the v0.5.1 Terminal Foundation.

### v0.5.2 Scope (from v0.5.0 Design Document)
- Avalonia terminal control with SkiaSharp rendering
- Panel integration with resize handling
- Tab support for multiple terminal sessions
- Text selection and clipboard operations
- Keyboard input handling
- Theme support and styling

### Dependencies
- v0.5.1 Terminal Foundation (TerminalService, TerminalBuffer, AnsiParser)

---

## Sub-Part Breakdown

| Part | Name | Focus |
|------|------|-------|
| v0.5.2a | Theme & Styles | Terminal theme model, color palette, and AXAML styles |
| v0.5.2b | Terminal Renderer | SkiaSharp-based rendering control for terminal buffer |
| v0.5.2c | Terminal Control | Main control with input handling, selection, and clipboard |
| v0.5.2d | ViewModels | TerminalPanelViewModel and TerminalSessionViewModel |
| v0.5.2e | Terminal Panel | Tab bar, session management UI, panel layout |
| v0.5.2f | Main Window Integration | Panel placement, resize splitter, keyboard shortcuts |

---

## v0.5.2a: Theme & Styles

### Objective
Create the terminal theme model with support for customizable colors, define the 256-color palette calculation, and add terminal-specific styles to the application theme.

### TerminalTheme Model

```csharp
namespace SeniorIntern.Core.Models.Terminal;

/// <summary>
/// Defines the color scheme for terminal rendering
/// </summary>
public sealed class TerminalTheme
{
    /// <summary>
    /// Display name for the theme
    /// </summary>
    public string Name { get; init; } = "Default";

    /// <summary>
    /// Default background color
    /// </summary>
    public TerminalColor Background { get; init; } = TerminalColor.FromRgb(30, 30, 30);

    /// <summary>
    /// Default foreground (text) color
    /// </summary>
    public TerminalColor Foreground { get; init; } = TerminalColor.FromRgb(204, 204, 204);

    /// <summary>
    /// Cursor color
    /// </summary>
    public TerminalColor Cursor { get; init; } = TerminalColor.FromRgb(204, 204, 204);

    /// <summary>
    /// Selection highlight color (alpha will be applied)
    /// </summary>
    public TerminalColor Selection { get; init; } = TerminalColor.FromRgb(68, 119, 170);

    /// <summary>
    /// Selection highlight alpha (0-255)
    /// </summary>
    public byte SelectionAlpha { get; init; } = 80;

    /// <summary>
    /// Bold text color (null = use foreground with bold style)
    /// </summary>
    public TerminalColor? BoldForeground { get; init; }

    /// <summary>
    /// 16-color ANSI palette (colors 0-15)
    /// </summary>
    public TerminalColor[] AnsiPalette { get; init; } = CreateDefaultAnsiPalette();

    /// <summary>
    /// Cursor style
    /// </summary>
    public CursorStyle CursorStyle { get; init; } = CursorStyle.Block;

    /// <summary>
    /// Whether cursor should blink
    /// </summary>
    public bool CursorBlink { get; init; } = true;

    /// <summary>
    /// Cursor blink interval in milliseconds
    /// </summary>
    public int CursorBlinkIntervalMs { get; init; } = 530;

    /// <summary>
    /// Gets a color from the extended 256-color palette
    /// </summary>
    public TerminalColor GetPaletteColor(int index)
    {
        if (index < 0 || index > 255)
            return Foreground;

        // Colors 0-15: ANSI palette
        if (index < 16)
            return AnsiPalette[index];

        // Colors 16-231: 6x6x6 color cube
        if (index < 232)
        {
            index -= 16;
            var r = (byte)((index / 36) * 51);
            var g = (byte)(((index / 6) % 6) * 51);
            var b = (byte)((index % 6) * 51);
            return TerminalColor.FromRgb(r, g, b);
        }

        // Colors 232-255: Grayscale ramp
        var gray = (byte)((index - 232) * 10 + 8);
        return TerminalColor.FromRgb(gray, gray, gray);
    }

    /// <summary>
    /// Resolve a TerminalColor to its actual RGB values
    /// </summary>
    public TerminalColor ResolveColor(TerminalColor color, bool isForeground)
    {
        if (color.IsDefault)
            return isForeground ? Foreground : Background;

        if (color.PaletteIndex.HasValue)
            return GetPaletteColor(color.PaletteIndex.Value);

        return color;
    }

    private static TerminalColor[] CreateDefaultAnsiPalette() => new[]
    {
        // Standard colors (0-7)
        TerminalColor.FromRgb(0, 0, 0),         // 0: Black
        TerminalColor.FromRgb(205, 49, 49),     // 1: Red
        TerminalColor.FromRgb(13, 188, 121),    // 2: Green
        TerminalColor.FromRgb(229, 229, 16),    // 3: Yellow
        TerminalColor.FromRgb(36, 114, 200),    // 4: Blue
        TerminalColor.FromRgb(188, 63, 188),    // 5: Magenta
        TerminalColor.FromRgb(17, 168, 205),    // 6: Cyan
        TerminalColor.FromRgb(229, 229, 229),   // 7: White

        // Bright colors (8-15)
        TerminalColor.FromRgb(102, 102, 102),   // 8: Bright Black (Gray)
        TerminalColor.FromRgb(241, 76, 76),     // 9: Bright Red
        TerminalColor.FromRgb(35, 209, 139),    // 10: Bright Green
        TerminalColor.FromRgb(245, 245, 67),    // 11: Bright Yellow
        TerminalColor.FromRgb(59, 142, 234),    // 12: Bright Blue
        TerminalColor.FromRgb(214, 112, 214),   // 13: Bright Magenta
        TerminalColor.FromRgb(41, 184, 219),    // 14: Bright Cyan
        TerminalColor.FromRgb(255, 255, 255),   // 15: Bright White
    };

    /// <summary>
    /// Default dark theme matching VS Code's terminal
    /// </summary>
    public static TerminalTheme Dark => new()
    {
        Name = "Dark",
        Background = TerminalColor.FromRgb(30, 30, 30),
        Foreground = TerminalColor.FromRgb(204, 204, 204),
        Cursor = TerminalColor.FromRgb(204, 204, 204),
        Selection = TerminalColor.FromRgb(68, 119, 170),
        SelectionAlpha = 80
    };

    /// <summary>
    /// Light theme
    /// </summary>
    public static TerminalTheme Light => new()
    {
        Name = "Light",
        Background = TerminalColor.FromRgb(255, 255, 255),
        Foreground = TerminalColor.FromRgb(0, 0, 0),
        Cursor = TerminalColor.FromRgb(0, 0, 0),
        Selection = TerminalColor.FromRgb(173, 214, 255),
        SelectionAlpha = 100,
        AnsiPalette = new[]
        {
            TerminalColor.FromRgb(0, 0, 0),
            TerminalColor.FromRgb(205, 49, 49),
            TerminalColor.FromRgb(0, 135, 0),
            TerminalColor.FromRgb(135, 135, 0),
            TerminalColor.FromRgb(0, 0, 205),
            TerminalColor.FromRgb(135, 0, 135),
            TerminalColor.FromRgb(0, 135, 135),
            TerminalColor.FromRgb(229, 229, 229),
            TerminalColor.FromRgb(102, 102, 102),
            TerminalColor.FromRgb(241, 76, 76),
            TerminalColor.FromRgb(0, 175, 0),
            TerminalColor.FromRgb(175, 175, 0),
            TerminalColor.FromRgb(0, 0, 255),
            TerminalColor.FromRgb(175, 0, 175),
            TerminalColor.FromRgb(0, 175, 175),
            TerminalColor.FromRgb(255, 255, 255),
        }
    };

    /// <summary>
    /// Solarized Dark theme
    /// </summary>
    public static TerminalTheme SolarizedDark => new()
    {
        Name = "Solarized Dark",
        Background = TerminalColor.FromRgb(0, 43, 54),
        Foreground = TerminalColor.FromRgb(131, 148, 150),
        Cursor = TerminalColor.FromRgb(131, 148, 150),
        Selection = TerminalColor.FromRgb(7, 54, 66),
        SelectionAlpha = 120,
        AnsiPalette = new[]
        {
            TerminalColor.FromRgb(7, 54, 66),      // Base02
            TerminalColor.FromRgb(220, 50, 47),    // Red
            TerminalColor.FromRgb(133, 153, 0),    // Green
            TerminalColor.FromRgb(181, 137, 0),    // Yellow
            TerminalColor.FromRgb(38, 139, 210),   // Blue
            TerminalColor.FromRgb(211, 54, 130),   // Magenta
            TerminalColor.FromRgb(42, 161, 152),   // Cyan
            TerminalColor.FromRgb(238, 232, 213),  // Base2
            TerminalColor.FromRgb(0, 43, 54),      // Base03
            TerminalColor.FromRgb(203, 75, 22),    // Orange
            TerminalColor.FromRgb(88, 110, 117),   // Base01
            TerminalColor.FromRgb(101, 123, 131),  // Base00
            TerminalColor.FromRgb(131, 148, 150),  // Base0
            TerminalColor.FromRgb(108, 113, 196),  // Violet
            TerminalColor.FromRgb(147, 161, 161),  // Base1
            TerminalColor.FromRgb(253, 246, 227),  // Base3
        }
    };
}

/// <summary>
/// Terminal cursor display style
/// </summary>
public enum CursorStyle
{
    /// <summary>
    /// Solid block cursor
    /// </summary>
    Block,

    /// <summary>
    /// Underline cursor
    /// </summary>
    Underline,

    /// <summary>
    /// Vertical bar cursor
    /// </summary>
    Bar
}
```

### TerminalThemeColor Enum

```csharp
namespace SeniorIntern.Core.Models.Terminal;

/// <summary>
/// Named semantic colors in a terminal theme
/// </summary>
public enum TerminalThemeColor
{
    Background,
    Foreground,
    Cursor,
    Selection,
    BoldForeground
}
```

### Terminal Styles (Dark.axaml additions)

```xml
<!-- Terminal Panel Styles -->
<SolidColorBrush x:Key="TerminalBackground" Color="#1E1E1E" />
<SolidColorBrush x:Key="TerminalForeground" Color="#CCCCCC" />
<SolidColorBrush x:Key="TerminalTabBarBackground" Color="#252526" />
<SolidColorBrush x:Key="TerminalTabBackground" Color="Transparent" />
<SolidColorBrush x:Key="TerminalTabActiveBackground" Color="#1E1E1E" />
<SolidColorBrush x:Key="TerminalTabHoverBackground" Color="#2D2D30" />
<SolidColorBrush x:Key="TerminalTabBorder" Color="#3C3C3C" />
<SolidColorBrush x:Key="TerminalScrollBarThumb" Color="#424242" />
<SolidColorBrush x:Key="TerminalScrollBarThumbHover" Color="#4F4F4F" />

<!-- Terminal Tab Style -->
<ControlTheme x:Key="TerminalTab" TargetType="Button">
    <Setter Property="Background" Value="{DynamicResource TerminalTabBackground}" />
    <Setter Property="Foreground" Value="{DynamicResource TextPrimary}" />
    <Setter Property="Padding" Value="12,6" />
    <Setter Property="CornerRadius" Value="0" />
    <Setter Property="BorderThickness" Value="1,0,1,0" />
    <Setter Property="BorderBrush" Value="Transparent" />
    <Setter Property="MinWidth" Value="100" />
    <Setter Property="MaxWidth" Value="200" />
    <Setter Property="HorizontalContentAlignment" Value="Stretch" />

    <Style Selector="^:pointerover">
        <Setter Property="Background" Value="{DynamicResource TerminalTabHoverBackground}" />
    </Style>

    <Style Selector="^.active">
        <Setter Property="Background" Value="{DynamicResource TerminalTabActiveBackground}" />
        <Setter Property="BorderBrush" Value="{DynamicResource TerminalTabBorder}" />
    </Style>
</ControlTheme>

<!-- Terminal Tab Close Button -->
<ControlTheme x:Key="TerminalTabCloseButton" TargetType="Button">
    <Setter Property="Background" Value="Transparent" />
    <Setter Property="Foreground" Value="{DynamicResource TextMuted}" />
    <Setter Property="Padding" Value="4" />
    <Setter Property="CornerRadius" Value="2" />
    <Setter Property="Width" Value="20" />
    <Setter Property="Height" Value="20" />
    <Setter Property="VerticalAlignment" Value="Center" />
    <Setter Property="Opacity" Value="0" />

    <Style Selector="^:pointerover">
        <Setter Property="Background" Value="{DynamicResource ControlBackground}" />
        <Setter Property="Foreground" Value="{DynamicResource TextPrimary}" />
        <Setter Property="Opacity" Value="1" />
    </Style>
</ControlTheme>

<!-- Make close button visible on tab hover -->
<Style Selector="Button.terminal-tab:pointerover Button.tab-close">
    <Setter Property="Opacity" Value="0.6" />
</Style>

<Style Selector="Button.terminal-tab.active Button.tab-close">
    <Setter Property="Opacity" Value="0.6" />
</Style>

<!-- New Tab Button -->
<ControlTheme x:Key="TerminalNewTabButton" TargetType="Button">
    <Setter Property="Background" Value="Transparent" />
    <Setter Property="Foreground" Value="{DynamicResource TextMuted}" />
    <Setter Property="Padding" Value="8,6" />
    <Setter Property="CornerRadius" Value="0" />
    <Setter Property="VerticalAlignment" Value="Center" />

    <Style Selector="^:pointerover">
        <Setter Property="Background" Value="{DynamicResource TerminalTabHoverBackground}" />
        <Setter Property="Foreground" Value="{DynamicResource TextPrimary}" />
    </Style>
</ControlTheme>

<!-- Terminal Icon Button -->
<ControlTheme x:Key="TerminalIconButton" TargetType="Button">
    <Setter Property="Background" Value="Transparent" />
    <Setter Property="Foreground" Value="{DynamicResource TextMuted}" />
    <Setter Property="Padding" Value="6" />
    <Setter Property="CornerRadius" Value="4" />
    <Setter Property="Width" Value="28" />
    <Setter Property="Height" Value="28" />
    <Setter Property="VerticalAlignment" Value="Center" />

    <Style Selector="^:pointerover">
        <Setter Property="Background" Value="{DynamicResource ControlBackground}" />
        <Setter Property="Foreground" Value="{DynamicResource TextPrimary}" />
    </Style>
</ControlTheme>

<!-- Terminal ScrollViewer Style -->
<ControlTheme x:Key="TerminalScrollBar" TargetType="ScrollBar">
    <Setter Property="Width" Value="10" />
    <Setter Property="Background" Value="Transparent" />

    <Style Selector="^ /template/ Thumb">
        <Setter Property="Background" Value="{DynamicResource TerminalScrollBarThumb}" />
        <Setter Property="CornerRadius" Value="5" />
        <Setter Property="MinHeight" Value="30" />
    </Style>

    <Style Selector="^ /template/ Thumb:pointerover">
        <Setter Property="Background" Value="{DynamicResource TerminalScrollBarThumbHover}" />
    </Style>
</ControlTheme>
```

### Terminal Icons (IconPaths.axaml)

```xml
<!-- Terminal Icons -->
<StreamGeometry x:Key="TerminalIcon">M2 4.75A2.75 2.75 0 0 1 4.75 2h10.5A2.75 2.75 0 0 1 18 4.75v10.5A2.75 2.75 0 0 1 15.25 18H4.75A2.75 2.75 0 0 1 2 15.25V4.75ZM6.22 6.22a.75.75 0 0 1 1.06 0l2.25 2.25a.75.75 0 0 1 0 1.06l-2.25 2.25a.75.75 0 0 1-1.06-1.06L7.94 9 6.22 7.28a.75.75 0 0 1 0-1.06ZM10 12.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 0 1.5h-3.5a.75.75 0 0 1-.75-.75Z</StreamGeometry>
<StreamGeometry x:Key="PlusIcon">M10 2.5a.75.75 0 0 1 .75.75v6h6a.75.75 0 0 1 0 1.5h-6v6a.75.75 0 0 1-1.5 0v-6h-6a.75.75 0 0 1 0-1.5h6v-6A.75.75 0 0 1 10 2.5Z</StreamGeometry>
<StreamGeometry x:Key="CloseIcon">M6.28 5.22a.75.75 0 0 0-1.06 1.06L8.94 10l-3.72 3.72a.75.75 0 1 0 1.06 1.06L10 11.06l3.72 3.72a.75.75 0 1 0 1.06-1.06L11.06 10l3.72-3.72a.75.75 0 0 0-1.06-1.06L10 8.94 6.28 5.22Z</StreamGeometry>
<StreamGeometry x:Key="MaximizeIcon">M3.75 2A1.75 1.75 0 0 0 2 3.75v12.5c0 .966.784 1.75 1.75 1.75h12.5A1.75 1.75 0 0 0 18 16.25V3.75A1.75 1.75 0 0 0 16.25 2H3.75ZM3.5 3.75a.25.25 0 0 1 .25-.25h12.5a.25.25 0 0 1 .25.25v12.5a.25.25 0 0 1-.25.25H3.75a.25.25 0 0 1-.25-.25V3.75Z</StreamGeometry>
<StreamGeometry x:Key="MinimizeIcon">M3.75 2A1.75 1.75 0 0 0 2 3.75v12.5c0 .966.784 1.75 1.75 1.75h12.5A1.75 1.75 0 0 0 18 16.25V3.75A1.75 1.75 0 0 0 16.25 2H3.75ZM3.5 3.75a.25.25 0 0 1 .25-.25h12.5a.25.25 0 0 1 .25.25v4.75H3.5V3.75Z</StreamGeometry>
<StreamGeometry x:Key="ChevronDownIcon">M5.22 8.22a.75.75 0 0 1 1.06 0L10 11.94l3.72-3.72a.75.75 0 1 1 1.06 1.06l-4.25 4.25a.75.75 0 0 1-1.06 0L5.22 9.28a.75.75 0 0 1 0-1.06Z</StreamGeometry>
<StreamGeometry x:Key="ChevronUpIcon">M14.78 11.78a.75.75 0 0 1-1.06 0L10 8.06l-3.72 3.72a.75.75 0 0 1-1.06-1.06l4.25-4.25a.75.75 0 0 1 1.06 0l4.25 4.25a.75.75 0 0 1 0 1.06Z</StreamGeometry>
<StreamGeometry x:Key="SplitHorizontalIcon">M2 3.75C2 2.784 2.784 2 3.75 2h12.5c.966 0 1.75.784 1.75 1.75v12.5A1.75 1.75 0 0 1 16.25 18H3.75A1.75 1.75 0 0 1 2 16.25V3.75ZM3.75 3.5a.25.25 0 0 0-.25.25v12.5c0 .138.112.25.25.25H9.5v-13H3.75ZM11 3.5v13h5.25a.25.25 0 0 0 .25-.25V3.75a.25.25 0 0 0-.25-.25H11Z</StreamGeometry>
```

### v0.5.2a Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Models/Terminal/TerminalTheme.cs` | Theme model with palette calculation |
| `src/SeniorIntern.Core/Models/Terminal/CursorStyle.cs` | Cursor style enum |
| `src/SeniorIntern.Desktop/Resources/IconPaths.axaml` | Terminal and UI icons |

### v0.5.2a Files to Modify

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/Themes/Dark.axaml` | Add terminal styles |
| `src/SeniorIntern.Desktop/App.axaml` | Include IconPaths resource dictionary |

### v0.5.2a Verification

```bash
# Verify Core builds with theme model
dotnet build src/SeniorIntern.Core

# Verify Desktop builds with styles
dotnet build src/SeniorIntern.Desktop
```

---

## v0.5.2b: Terminal Renderer

### Objective
Create a high-performance SkiaSharp-based control that renders the terminal buffer to screen, handling font metrics, cell backgrounds, text attributes, cursor display, and selection highlighting.

### TerminalFontMetrics Class

```csharp
namespace SeniorIntern.Desktop.Controls.Terminal;

using SkiaSharp;

/// <summary>
/// Manages font metrics for terminal rendering
/// </summary>
public sealed class TerminalFontMetrics : IDisposable
{
    private SKTypeface? _typeface;
    private SKPaint? _measurePaint;

    /// <summary>
    /// The loaded typeface
    /// </summary>
    public SKTypeface Typeface => _typeface ?? SKTypeface.Default;

    /// <summary>
    /// Font size in points
    /// </summary>
    public float FontSize { get; private set; }

    /// <summary>
    /// Width of a single character cell
    /// </summary>
    public float CharWidth { get; private set; }

    /// <summary>
    /// Height of a line (ascent + descent + leading)
    /// </summary>
    public float LineHeight { get; private set; }

    /// <summary>
    /// Distance from top of cell to text baseline
    /// </summary>
    public float Baseline { get; private set; }

    /// <summary>
    /// Font ascent (distance from baseline to top)
    /// </summary>
    public float Ascent { get; private set; }

    /// <summary>
    /// Font descent (distance from baseline to bottom)
    /// </summary>
    public float Descent { get; private set; }

    /// <summary>
    /// Whether metrics have been calculated
    /// </summary>
    public bool IsValid => _typeface != null && CharWidth > 0;

    /// <summary>
    /// Update font and recalculate metrics
    /// </summary>
    public void Update(string fontFamily, float fontSize)
    {
        FontSize = fontSize;

        // Try to load the requested font family
        _typeface?.Dispose();
        _typeface = SKTypeface.FromFamilyName(fontFamily, SKFontStyle.Normal);

        // Fall back to a monospace font if not found
        if (_typeface == null || _typeface.FamilyName != fontFamily)
        {
            _typeface?.Dispose();
            _typeface = SKTypeface.FromFamilyName("Consolas", SKFontStyle.Normal)
                ?? SKTypeface.FromFamilyName("Monaco", SKFontStyle.Normal)
                ?? SKTypeface.FromFamilyName("Courier New", SKFontStyle.Normal)
                ?? SKTypeface.Default;
        }

        CalculateMetrics();
    }

    private void CalculateMetrics()
    {
        _measurePaint?.Dispose();
        _measurePaint = new SKPaint
        {
            Typeface = _typeface,
            TextSize = FontSize,
            IsAntialias = true
        };

        // Measure character width using 'M' (em-width) for monospace
        CharWidth = _measurePaint.MeasureText("M");

        // Get font metrics
        var metrics = _measurePaint.FontMetrics;
        Ascent = -metrics.Ascent;
        Descent = metrics.Descent;
        LineHeight = Ascent + Descent + (metrics.Leading > 0 ? metrics.Leading : 2);
        Baseline = Ascent;
    }

    /// <summary>
    /// Calculate terminal size in columns/rows for given pixel dimensions
    /// </summary>
    public (int Columns, int Rows) CalculateTerminalSize(double width, double height)
    {
        if (!IsValid || width <= 0 || height <= 0)
            return (80, 24);

        var cols = Math.Max(1, (int)(width / CharWidth));
        var rows = Math.Max(1, (int)(height / LineHeight));

        return (cols, rows);
    }

    /// <summary>
    /// Convert pixel position to cell coordinates
    /// </summary>
    public (int Column, int Row) PixelToCell(double x, double y)
    {
        if (!IsValid)
            return (0, 0);

        var col = Math.Max(0, (int)(x / CharWidth));
        var row = Math.Max(0, (int)(y / LineHeight));

        return (col, row);
    }

    /// <summary>
    /// Convert cell coordinates to pixel position
    /// </summary>
    public (float X, float Y) CellToPixel(int column, int row)
    {
        return (column * CharWidth, row * LineHeight);
    }

    /// <summary>
    /// Create a paint for rendering text with given attributes
    /// </summary>
    public SKPaint CreateTextPaint(bool bold = false, bool italic = false)
    {
        var style = SKFontStyle.Normal;

        if (bold && italic)
            style = SKFontStyle.BoldItalic;
        else if (bold)
            style = SKFontStyle.Bold;
        else if (italic)
            style = SKFontStyle.Italic;

        var typeface = _typeface;
        if (style != SKFontStyle.Normal)
        {
            typeface = SKTypeface.FromFamilyName(_typeface?.FamilyName ?? "monospace", style);
        }

        return new SKPaint
        {
            Typeface = typeface,
            TextSize = FontSize,
            IsAntialias = true
        };
    }

    public void Dispose()
    {
        _measurePaint?.Dispose();
        _typeface?.Dispose();
    }
}
```

### TerminalRenderer Control

```csharp
namespace SeniorIntern.Desktop.Controls.Terminal;

using Avalonia;
using Avalonia.Controls;
using Avalonia.Media;
using Avalonia.Platform;
using Avalonia.Rendering.SceneGraph;
using Avalonia.Skia;
using SeniorIntern.Core.Models.Terminal;
using SkiaSharp;

/// <summary>
/// SkiaSharp-based terminal buffer renderer
/// </summary>
public class TerminalRenderer : Control
{
    private TerminalBuffer? _buffer;
    private TerminalTheme _theme = TerminalTheme.Dark;
    private readonly TerminalFontMetrics _fontMetrics = new();
    private TerminalSelection? _selection;
    private bool _cursorVisible = true;

    // Dependency properties
    public static readonly StyledProperty<string> FontFamilyProperty =
        AvaloniaProperty.Register<TerminalRenderer, string>(nameof(FontFamily), "Cascadia Mono");

    public static readonly StyledProperty<double> FontSizeProperty =
        AvaloniaProperty.Register<TerminalRenderer, double>(nameof(FontSize), 14.0);

    public string FontFamily
    {
        get => GetValue(FontFamilyProperty);
        set => SetValue(FontFamilyProperty, value);
    }

    public double FontSize
    {
        get => GetValue(FontSizeProperty);
        set => SetValue(FontSizeProperty, value);
    }

    /// <summary>
    /// Font metrics for calculating sizes
    /// </summary>
    public TerminalFontMetrics Metrics => _fontMetrics;

    /// <summary>
    /// Current selection (for highlighting)
    /// </summary>
    public TerminalSelection? Selection
    {
        get => _selection;
        set
        {
            _selection = value;
            InvalidateVisual();
        }
    }

    /// <summary>
    /// Whether the cursor should be shown (for blink animation)
    /// </summary>
    public bool CursorVisible
    {
        get => _cursorVisible;
        set
        {
            if (_cursorVisible != value)
            {
                _cursorVisible = value;
                InvalidateVisual();
            }
        }
    }

    static TerminalRenderer()
    {
        AffectsRender<TerminalRenderer>(FontFamilyProperty, FontSizeProperty);
    }

    public TerminalRenderer()
    {
        ClipToBounds = true;
    }

    protected override void OnPropertyChanged(AvaloniaPropertyChangedEventArgs change)
    {
        base.OnPropertyChanged(change);

        if (change.Property == FontFamilyProperty || change.Property == FontSizeProperty)
        {
            _fontMetrics.Update(FontFamily, (float)FontSize);
            InvalidateVisual();
        }
    }

    protected override void OnLoaded(RoutedEventArgs e)
    {
        base.OnLoaded(e);
        _fontMetrics.Update(FontFamily, (float)FontSize);
    }

    /// <summary>
    /// Set the buffer to render
    /// </summary>
    public void SetBuffer(TerminalBuffer buffer)
    {
        if (_buffer != null)
        {
            _buffer.ContentChanged -= OnBufferContentChanged;
        }

        _buffer = buffer;

        if (_buffer != null)
        {
            _buffer.ContentChanged += OnBufferContentChanged;
        }

        InvalidateVisual();
    }

    /// <summary>
    /// Set the color theme
    /// </summary>
    public void SetTheme(TerminalTheme theme)
    {
        _theme = theme;
        InvalidateVisual();
    }

    private void OnBufferContentChanged(object? sender, EventArgs e)
    {
        // Marshal to UI thread and invalidate
        Avalonia.Threading.Dispatcher.UIThread.Post(InvalidateVisual);
    }

    public override void Render(DrawingContext context)
    {
        base.Render(context);

        if (_buffer == null || !_fontMetrics.IsValid)
            return;

        // Use custom drawing operation for SkiaSharp
        context.Custom(new TerminalRenderOperation(
            new Rect(0, 0, Bounds.Width, Bounds.Height),
            _buffer,
            _theme,
            _fontMetrics,
            _selection,
            _cursorVisible && _buffer.CursorVisible,
            IsFocused));
    }

    private bool IsFocused =>
        TopLevel.GetTopLevel(this)?.FocusManager?.GetFocusedElement() == this
        || TopLevel.GetTopLevel(this)?.FocusManager?.GetFocusedElement()?.FindAncestorOfType<TerminalControl>() != null;

    /// <summary>
    /// Custom drawing operation for SkiaSharp rendering
    /// </summary>
    private sealed class TerminalRenderOperation : ICustomDrawOperation
    {
        private readonly Rect _bounds;
        private readonly TerminalBuffer _buffer;
        private readonly TerminalTheme _theme;
        private readonly TerminalFontMetrics _metrics;
        private readonly TerminalSelection? _selection;
        private readonly bool _showCursor;
        private readonly bool _isFocused;

        public TerminalRenderOperation(
            Rect bounds,
            TerminalBuffer buffer,
            TerminalTheme theme,
            TerminalFontMetrics metrics,
            TerminalSelection? selection,
            bool showCursor,
            bool isFocused)
        {
            _bounds = bounds;
            _buffer = buffer;
            _theme = theme;
            _metrics = metrics;
            _selection = selection;
            _showCursor = showCursor;
            _isFocused = isFocused;
        }

        public Rect Bounds => _bounds;

        public bool HitTest(Point p) => _bounds.Contains(p);

        public bool Equals(ICustomDrawOperation? other) => false;

        public void Dispose() { }

        public void Render(ImmediateDrawingContext context)
        {
            var leaseFeature = context.TryGetFeature<ISkiaSharpApiLeaseFeature>();
            if (leaseFeature == null)
                return;

            using var lease = leaseFeature.Lease();
            var canvas = lease.SkCanvas;

            RenderTerminal(canvas);
        }

        private void RenderTerminal(SKCanvas canvas)
        {
            // Clear with background color
            var bgColor = ToSKColor(_theme.Background);
            canvas.Clear(bgColor);

            var lines = _buffer.GetVisibleLines();
            var charWidth = _metrics.CharWidth;
            var lineHeight = _metrics.LineHeight;
            var baseline = _metrics.Baseline;

            using var textPaint = new SKPaint
            {
                Typeface = _metrics.Typeface,
                TextSize = _metrics.FontSize,
                IsAntialias = true
            };

            using var bgPaint = new SKPaint { Style = SKPaintStyle.Fill };
            using var selectionPaint = new SKPaint
            {
                Color = ToSKColor(_theme.Selection).WithAlpha(_theme.SelectionAlpha),
                Style = SKPaintStyle.Fill
            };

            float y = 0;
            var lineIndex = _buffer.TotalLines - _buffer.Rows - _buffer.ScrollOffset;

            foreach (var line in lines)
            {
                float x = 0;

                for (int col = 0; col < line.Length && col < _buffer.Columns; col++)
                {
                    ref readonly var cell = ref line.ReadOnlyCells[col];

                    // Skip continuation cells
                    if (cell.IsContinuation)
                    {
                        x += charWidth;
                        continue;
                    }

                    var attrs = cell.Attributes;
                    var isSelected = _selection?.Contains(lineIndex, col) ?? false;

                    // Draw cell background
                    var hasBg = !attrs.Background.IsDefault || attrs.Inverse || isSelected;
                    if (hasBg)
                    {
                        SKColor cellBg;
                        if (isSelected)
                        {
                            cellBg = ToSKColor(_theme.Selection).WithAlpha(_theme.SelectionAlpha);
                        }
                        else if (attrs.Inverse)
                        {
                            cellBg = ResolveColor(attrs.Foreground, true);
                        }
                        else
                        {
                            cellBg = ResolveColor(attrs.Background, false);
                        }

                        bgPaint.Color = cellBg;
                        canvas.DrawRect(x, y, charWidth * cell.Width, lineHeight, bgPaint);
                    }

                    // Draw character
                    var charValue = cell.Character.Value;
                    if (charValue != ' ' && charValue != 0 && !attrs.Hidden)
                    {
                        var fgColor = attrs.Inverse
                            ? ResolveColor(attrs.Background, false)
                            : ResolveColor(attrs.Foreground, true);

                        textPaint.Color = fgColor;
                        textPaint.FakeBoldText = attrs.Bold;

                        // Handle dim
                        if (attrs.Dim)
                        {
                            textPaint.Color = fgColor.WithAlpha(128);
                        }

                        canvas.DrawText(
                            cell.Character.ToString(),
                            x,
                            y + baseline,
                            textPaint);

                        // Draw underline
                        if (attrs.Underline)
                        {
                            var underlineY = y + lineHeight - 2;
                            canvas.DrawLine(x, underlineY, x + charWidth, underlineY, textPaint);
                        }

                        // Draw strikethrough
                        if (attrs.Strikethrough)
                        {
                            var strikeY = y + lineHeight / 2;
                            canvas.DrawLine(x, strikeY, x + charWidth, strikeY, textPaint);
                        }
                    }

                    x += charWidth * cell.Width;
                }

                y += lineHeight;
                lineIndex++;
            }

            // Draw cursor
            if (_showCursor && _buffer.ScrollOffset == 0)
            {
                DrawCursor(canvas, charWidth, lineHeight);
            }
        }

        private void DrawCursor(SKCanvas canvas, float charWidth, float lineHeight)
        {
            var cursorX = _buffer.CursorX * charWidth;
            var cursorY = _buffer.CursorY * lineHeight;

            using var cursorPaint = new SKPaint
            {
                Color = ToSKColor(_theme.Cursor),
                Style = _isFocused ? SKPaintStyle.Fill : SKPaintStyle.Stroke,
                StrokeWidth = 1
            };

            switch (_theme.CursorStyle)
            {
                case CursorStyle.Block:
                    canvas.DrawRect(cursorX, cursorY, charWidth, lineHeight, cursorPaint);

                    // Draw character under cursor in inverse if focused
                    if (_isFocused)
                    {
                        var line = _buffer.GetLine(_buffer.CursorY);
                        if (line != null && _buffer.CursorX < line.Length)
                        {
                            var cell = line[_buffer.CursorX];
                            if (cell.Character.Value != ' ' && cell.Character.Value != 0)
                            {
                                using var textPaint = new SKPaint
                                {
                                    Typeface = _metrics.Typeface,
                                    TextSize = _metrics.FontSize,
                                    Color = ToSKColor(_theme.Background),
                                    IsAntialias = true
                                };
                                canvas.DrawText(
                                    cell.Character.ToString(),
                                    cursorX,
                                    cursorY + _metrics.Baseline,
                                    textPaint);
                            }
                        }
                    }
                    break;

                case CursorStyle.Underline:
                    canvas.DrawRect(cursorX, cursorY + lineHeight - 2, charWidth, 2, cursorPaint);
                    break;

                case CursorStyle.Bar:
                    canvas.DrawRect(cursorX, cursorY, 2, lineHeight, cursorPaint);
                    break;
            }
        }

        private SKColor ResolveColor(TerminalColor color, bool isForeground)
        {
            var resolved = _theme.ResolveColor(color, isForeground);
            return ToSKColor(resolved);
        }

        private static SKColor ToSKColor(TerminalColor color) =>
            new(color.R, color.G, color.B);
    }
}
```

### v0.5.2b Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/Controls/Terminal/TerminalFontMetrics.cs` | Font measurement and utilities |
| `src/SeniorIntern.Desktop/Controls/Terminal/TerminalRenderer.cs` | SkiaSharp rendering control |

### v0.5.2b Verification

```bash
# Verify Desktop builds with renderer
dotnet build src/SeniorIntern.Desktop
```

---

## v0.5.2c: Terminal Control

### Objective
Create the main terminal control that wraps the renderer and handles keyboard input, mouse interaction, text selection, clipboard operations, and cursor blinking.

### TerminalControl.axaml

```xml
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:local="using:SeniorIntern.Desktop.Controls.Terminal"
             x:Class="SeniorIntern.Desktop.Controls.Terminal.TerminalControl"
             Focusable="True"
             Background="Transparent">

    <Grid>
        <!-- Terminal Renderer -->
        <local:TerminalRenderer x:Name="Renderer"
                                FontFamily="{Binding FontFamily, RelativeSource={RelativeSource AncestorType=local:TerminalControl}}"
                                FontSize="{Binding FontSize, RelativeSource={RelativeSource AncestorType=local:TerminalControl}}" />

        <!-- Scrollbar overlay -->
        <ScrollBar x:Name="VerticalScrollBar"
                   Orientation="Vertical"
                   HorizontalAlignment="Right"
                   VerticalAlignment="Stretch"
                   Minimum="0"
                   Opacity="0"
                   Width="10"
                   Margin="0,0,2,0"
                   Theme="{DynamicResource TerminalScrollBar}" />
    </Grid>

</UserControl>
```

### TerminalControl.axaml.cs

```csharp
namespace SeniorIntern.Desktop.Controls.Terminal;

using Avalonia;
using Avalonia.Controls;
using Avalonia.Input;
using Avalonia.Interactivity;
using Avalonia.Threading;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models.Terminal;

/// <summary>
/// Complete terminal control with input handling, selection, and clipboard support
/// </summary>
public partial class TerminalControl : UserControl
{
    private ITerminalService? _terminalService;
    private Guid _sessionId;
    private TerminalBuffer? _buffer;

    // Selection state
    private bool _isSelecting;
    private Point _selectionStartPixel;
    private TerminalSelection? _currentSelection;

    // Cursor blink
    private DispatcherTimer? _cursorBlinkTimer;
    private bool _cursorBlinkState = true;

    // Double-click word selection
    private DateTime _lastClickTime;
    private Point _lastClickPosition;
    private int _clickCount;

    // Styled properties
    public static readonly StyledProperty<string> FontFamilyProperty =
        AvaloniaProperty.Register<TerminalControl, string>(nameof(FontFamily), "Cascadia Mono");

    public static readonly StyledProperty<double> FontSizeProperty =
        AvaloniaProperty.Register<TerminalControl, double>(nameof(FontSize), 14.0);

    public static readonly StyledProperty<TerminalTheme> ThemeProperty =
        AvaloniaProperty.Register<TerminalControl, TerminalTheme>(nameof(Theme), TerminalTheme.Dark);

    public string FontFamily
    {
        get => GetValue(FontFamilyProperty);
        set => SetValue(FontFamilyProperty, value);
    }

    public double FontSize
    {
        get => GetValue(FontSizeProperty);
        set => SetValue(FontSizeProperty, value);
    }

    public TerminalTheme Theme
    {
        get => GetValue(ThemeProperty);
        set => SetValue(ThemeProperty, value);
    }

    /// <summary>
    /// Event raised when the terminal size changes
    /// </summary>
    public event EventHandler<TerminalSizeChangedEventArgs>? SizeChanged;

    public TerminalControl()
    {
        InitializeComponent();

        // Handle pointer events
        PointerPressed += OnPointerPressed;
        PointerMoved += OnPointerMoved;
        PointerReleased += OnPointerReleased;
        PointerWheelChanged += OnPointerWheelChanged;
        DoubleTapped += OnDoubleTapped;

        // Handle focus for cursor blink
        GotFocus += OnGotFocus;
        LostFocus += OnLostFocus;

        // Handle size changes
        PropertyChanged += OnControlPropertyChanged;
    }

    protected override void OnLoaded(RoutedEventArgs e)
    {
        base.OnLoaded(e);
        SetupCursorBlink();
    }

    protected override void OnUnloaded(RoutedEventArgs e)
    {
        base.OnUnloaded(e);
        _cursorBlinkTimer?.Stop();
    }

    /// <summary>
    /// Attach to a terminal session
    /// </summary>
    public async Task AttachSessionAsync(
        ITerminalService terminalService,
        Guid sessionId)
    {
        // Detach from previous session
        if (_terminalService != null)
        {
            _terminalService.OutputReceived -= OnOutputReceived;
            _terminalService.SessionStateChanged -= OnSessionStateChanged;
        }

        _terminalService = terminalService;
        _sessionId = sessionId;
        _buffer = terminalService.GetBuffer(sessionId);

        // Set up renderer
        Renderer.SetBuffer(_buffer);
        Renderer.SetTheme(Theme);

        // Subscribe to events
        _terminalService.OutputReceived += OnOutputReceived;
        _terminalService.SessionStateChanged += OnSessionStateChanged;

        // Sync size
        await SyncTerminalSizeAsync();

        // Reset cursor blink
        ResetCursorBlink();
    }

    /// <summary>
    /// Detach from current session
    /// </summary>
    public void DetachSession()
    {
        if (_terminalService != null)
        {
            _terminalService.OutputReceived -= OnOutputReceived;
            _terminalService.SessionStateChanged -= OnSessionStateChanged;
        }

        _terminalService = null;
        _sessionId = Guid.Empty;
        _buffer = null;
    }

    private void OnControlPropertyChanged(object? sender, AvaloniaPropertyChangedEventArgs e)
    {
        if (e.Property == BoundsProperty)
        {
            _ = SyncTerminalSizeAsync();
        }
        else if (e.Property == ThemeProperty)
        {
            Renderer.SetTheme(Theme);
        }
    }

    private async Task SyncTerminalSizeAsync()
    {
        if (_terminalService == null || _sessionId == Guid.Empty)
            return;

        var metrics = Renderer.Metrics;
        if (!metrics.IsValid)
            return;

        var (cols, rows) = metrics.CalculateTerminalSize(Bounds.Width, Bounds.Height);

        if (cols > 0 && rows > 0)
        {
            await _terminalService.ResizeAsync(_sessionId, new TerminalSize(cols, rows));
            SizeChanged?.Invoke(this, new TerminalSizeChangedEventArgs(cols, rows));
        }
    }

    private void OnOutputReceived(object? sender, TerminalOutputEventArgs e)
    {
        if (e.SessionId != _sessionId)
            return;

        // Reset cursor blink on output
        Dispatcher.UIThread.Post(ResetCursorBlink);
    }

    private void OnSessionStateChanged(object? sender, TerminalSessionStateEventArgs e)
    {
        if (e.Session.Id != _sessionId)
            return;

        // Handle session end
        if (e.NewState == TerminalSessionState.Exited ||
            e.NewState == TerminalSessionState.Error)
        {
            Dispatcher.UIThread.Post(() =>
            {
                _cursorBlinkTimer?.Stop();
            });
        }
    }

    #region Keyboard Input

    protected override void OnKeyDown(KeyEventArgs e)
    {
        base.OnKeyDown(e);

        if (_terminalService == null || _sessionId == Guid.Empty)
            return;

        // Handle clipboard shortcuts
        var ctrl = e.KeyModifiers.HasFlag(KeyModifiers.Control);
        var shift = e.KeyModifiers.HasFlag(KeyModifiers.Shift);

        if (ctrl && shift && e.Key == Key.C)
        {
            _ = CopySelectionAsync();
            e.Handled = true;
            return;
        }

        if (ctrl && shift && e.Key == Key.V)
        {
            _ = PasteAsync();
            e.Handled = true;
            return;
        }

        // Convert key to terminal sequence
        var sequence = GetKeySequence(e);
        if (sequence != null)
        {
            _ = _terminalService.WriteInputAsync(_sessionId, sequence);
            ClearSelection();
            ResetCursorBlink();
            e.Handled = true;
        }
    }

    protected override void OnTextInput(TextInputEventArgs e)
    {
        base.OnTextInput(e);

        if (_terminalService == null || _sessionId == Guid.Empty)
            return;

        if (!string.IsNullOrEmpty(e.Text))
        {
            _ = _terminalService.WriteInputAsync(_sessionId, e.Text);
            ClearSelection();
            ResetCursorBlink();
            e.Handled = true;
        }
    }

    private string? GetKeySequence(KeyEventArgs e)
    {
        var ctrl = e.KeyModifiers.HasFlag(KeyModifiers.Control);
        var alt = e.KeyModifiers.HasFlag(KeyModifiers.Alt);
        var shift = e.KeyModifiers.HasFlag(KeyModifiers.Shift);

        // Special keys
        var sequence = e.Key switch
        {
            Key.Enter => "\r",
            Key.Escape => "\x1B",
            Key.Tab => shift ? "\x1B[Z" : "\t",
            Key.Back => "\x7F",
            Key.Delete => "\x1B[3~",
            Key.Up => "\x1B[A",
            Key.Down => "\x1B[B",
            Key.Right => "\x1B[C",
            Key.Left => "\x1B[D",
            Key.Home => ctrl ? "\x1B[1;5H" : "\x1B[H",
            Key.End => ctrl ? "\x1B[1;5F" : "\x1B[F",
            Key.PageUp => "\x1B[5~",
            Key.PageDown => "\x1B[6~",
            Key.Insert => "\x1B[2~",
            Key.F1 => "\x1BOP",
            Key.F2 => "\x1BOQ",
            Key.F3 => "\x1BOR",
            Key.F4 => "\x1BOS",
            Key.F5 => "\x1B[15~",
            Key.F6 => "\x1B[17~",
            Key.F7 => "\x1B[18~",
            Key.F8 => "\x1B[19~",
            Key.F9 => "\x1B[20~",
            Key.F10 => "\x1B[21~",
            Key.F11 => "\x1B[23~",
            Key.F12 => "\x1B[24~",
            _ => null
        };

        if (sequence != null)
            return sequence;

        // Ctrl+key combinations
        if (ctrl && !alt)
        {
            return e.Key switch
            {
                Key.C => "\x03",       // SIGINT
                Key.Z => "\x1A",       // SIGTSTP
                Key.D => "\x04",       // EOF
                Key.L => "\x0C",       // Clear screen
                Key.A => "\x01",       // Beginning of line
                Key.E => "\x05",       // End of line
                Key.K => "\x0B",       // Kill to end of line
                Key.U => "\x15",       // Kill to beginning of line
                Key.W => "\x17",       // Kill word backward
                Key.R => "\x12",       // Reverse search
                Key.P => "\x10",       // Previous history
                Key.N => "\x0E",       // Next history
                >= Key.A and <= Key.Z => ((char)(e.Key - Key.A + 1)).ToString(),
                _ => null
            };
        }

        return null;
    }

    #endregion

    #region Mouse Input & Selection

    private void OnPointerPressed(object? sender, PointerPressedEventArgs e)
    {
        if (_buffer == null)
            return;

        var point = e.GetCurrentPoint(Renderer);
        var position = point.Position;

        // Handle click count for double/triple click
        var now = DateTime.UtcNow;
        if ((now - _lastClickTime).TotalMilliseconds < 500 &&
            Math.Abs(position.X - _lastClickPosition.X) < 5 &&
            Math.Abs(position.Y - _lastClickPosition.Y) < 5)
        {
            _clickCount++;
        }
        else
        {
            _clickCount = 1;
        }

        _lastClickTime = now;
        _lastClickPosition = position;

        if (point.Properties.IsLeftButtonPressed)
        {
            Focus();

            if (_clickCount == 3)
            {
                // Triple click - select line
                SelectLine(position);
            }
            else if (_clickCount == 2)
            {
                // Double click - select word
                SelectWord(position);
            }
            else
            {
                // Single click - start selection
                _isSelecting = true;
                _selectionStartPixel = position;
                _currentSelection = null;
                Renderer.Selection = null;
            }

            e.Handled = true;
        }
        else if (point.Properties.IsRightButtonPressed)
        {
            // Right click - paste if no selection, else context menu
            if (_currentSelection == null || _currentSelection.IsEmpty)
            {
                _ = PasteAsync();
            }
            e.Handled = true;
        }
    }

    private void OnPointerMoved(object? sender, PointerEventArgs e)
    {
        if (!_isSelecting || _buffer == null)
            return;

        var position = e.GetPosition(Renderer);
        UpdateSelection(_selectionStartPixel, position);
    }

    private void OnPointerReleased(object? sender, PointerReleasedEventArgs e)
    {
        _isSelecting = false;
    }

    private void OnPointerWheelChanged(object? sender, PointerWheelEventArgs e)
    {
        if (_buffer == null)
            return;

        var delta = e.Delta.Y > 0 ? -3 : 3;
        var newOffset = Math.Clamp(
            _buffer.ScrollOffset + delta,
            0,
            _buffer.ScrollbackLines);

        _buffer.ScrollOffset = newOffset;

        // Update scrollbar
        VerticalScrollBar.Value = _buffer.ScrollbackLines - newOffset;

        e.Handled = true;
    }

    private void OnDoubleTapped(object? sender, TappedEventArgs e)
    {
        // Handled in OnPointerPressed via click count
    }

    private void UpdateSelection(Point start, Point end)
    {
        var metrics = Renderer.Metrics;
        var (startCol, startRow) = metrics.PixelToCell(start.X, start.Y);
        var (endCol, endRow) = metrics.PixelToCell(end.X, end.Y);

        var scrollbackStart = _buffer!.TotalLines - _buffer.Rows - _buffer.ScrollOffset;

        _currentSelection = new TerminalSelection
        {
            StartLine = scrollbackStart + startRow,
            StartColumn = startCol,
            EndLine = scrollbackStart + endRow,
            EndColumn = endCol,
            IsBlock = false
        };

        Renderer.Selection = _currentSelection;
    }

    private void SelectWord(Point position)
    {
        if (_buffer == null)
            return;

        var metrics = Renderer.Metrics;
        var (col, row) = metrics.PixelToCell(position.X, position.Y);

        var line = _buffer.GetLine(row);
        if (line == null)
            return;

        // Find word boundaries
        var startCol = col;
        var endCol = col;

        // Expand left
        while (startCol > 0 && IsWordChar(line[startCol - 1].Character))
            startCol--;

        // Expand right
        while (endCol < line.Length - 1 && IsWordChar(line[endCol + 1].Character))
            endCol++;

        var scrollbackStart = _buffer.TotalLines - _buffer.Rows - _buffer.ScrollOffset;

        _currentSelection = new TerminalSelection
        {
            StartLine = scrollbackStart + row,
            StartColumn = startCol,
            EndLine = scrollbackStart + row,
            EndColumn = endCol
        };

        Renderer.Selection = _currentSelection;
    }

    private void SelectLine(Point position)
    {
        if (_buffer == null)
            return;

        var metrics = Renderer.Metrics;
        var (_, row) = metrics.PixelToCell(position.X, position.Y);

        var scrollbackStart = _buffer.TotalLines - _buffer.Rows - _buffer.ScrollOffset;

        _currentSelection = new TerminalSelection
        {
            StartLine = scrollbackStart + row,
            StartColumn = 0,
            EndLine = scrollbackStart + row,
            EndColumn = _buffer.Columns - 1
        };

        Renderer.Selection = _currentSelection;
    }

    private static bool IsWordChar(Rune rune)
    {
        var c = (char)rune.Value;
        return char.IsLetterOrDigit(c) || c == '_' || c == '-';
    }

    private void ClearSelection()
    {
        _currentSelection = null;
        Renderer.Selection = null;
    }

    #endregion

    #region Clipboard

    /// <summary>
    /// Copy selected text to clipboard
    /// </summary>
    public async Task CopySelectionAsync()
    {
        if (_currentSelection == null || _currentSelection.IsEmpty || _buffer == null)
            return;

        var text = _buffer.GetSelectedText(_currentSelection);
        if (!string.IsNullOrEmpty(text))
        {
            var clipboard = TopLevel.GetTopLevel(this)?.Clipboard;
            if (clipboard != null)
            {
                await clipboard.SetTextAsync(text);
            }
        }
    }

    /// <summary>
    /// Paste text from clipboard
    /// </summary>
    public async Task PasteAsync()
    {
        if (_terminalService == null || _sessionId == Guid.Empty)
            return;

        var clipboard = TopLevel.GetTopLevel(this)?.Clipboard;
        if (clipboard == null)
            return;

        var text = await clipboard.GetTextAsync();
        if (!string.IsNullOrEmpty(text))
        {
            // Convert Windows line endings to Unix
            text = text.Replace("\r\n", "\r").Replace("\n", "\r");

            // Use bracketed paste mode if supported
            // For now, just write directly
            await _terminalService.WriteInputAsync(_sessionId, text);
        }
    }

    /// <summary>
    /// Select all text in the buffer
    /// </summary>
    public void SelectAll()
    {
        if (_buffer == null)
            return;

        _currentSelection = new TerminalSelection
        {
            StartLine = 0,
            StartColumn = 0,
            EndLine = _buffer.TotalLines - 1,
            EndColumn = _buffer.Columns - 1
        };

        Renderer.Selection = _currentSelection;
    }

    #endregion

    #region Cursor Blink

    private void SetupCursorBlink()
    {
        _cursorBlinkTimer = new DispatcherTimer
        {
            Interval = TimeSpan.FromMilliseconds(Theme.CursorBlinkIntervalMs)
        };
        _cursorBlinkTimer.Tick += OnCursorBlinkTick;

        if (IsFocused && Theme.CursorBlink)
        {
            _cursorBlinkTimer.Start();
        }
    }

    private void OnCursorBlinkTick(object? sender, EventArgs e)
    {
        _cursorBlinkState = !_cursorBlinkState;
        Renderer.CursorVisible = _cursorBlinkState;
    }

    private void ResetCursorBlink()
    {
        _cursorBlinkState = true;
        Renderer.CursorVisible = true;
        _cursorBlinkTimer?.Stop();

        if (IsFocused && Theme.CursorBlink)
        {
            _cursorBlinkTimer?.Start();
        }
    }

    private void OnGotFocus(object? sender, GotFocusEventArgs e)
    {
        ResetCursorBlink();
    }

    private void OnLostFocus(object? sender, RoutedEventArgs e)
    {
        _cursorBlinkTimer?.Stop();
        Renderer.CursorVisible = true;
    }

    #endregion
}

/// <summary>
/// Event args for terminal size changes
/// </summary>
public sealed class TerminalSizeChangedEventArgs : EventArgs
{
    public int Columns { get; }
    public int Rows { get; }

    public TerminalSizeChangedEventArgs(int columns, int rows)
    {
        Columns = columns;
        Rows = rows;
    }
}
```

### v0.5.2c Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/Controls/Terminal/TerminalControl.axaml` | Terminal control XAML |
| `src/SeniorIntern.Desktop/Controls/Terminal/TerminalControl.axaml.cs` | Terminal control code-behind |

### v0.5.2c Verification

```bash
# Verify Desktop builds
dotnet build src/SeniorIntern.Desktop
```

---

## v0.5.2d: ViewModels

### Objective
Create the ViewModel layer for the terminal panel, managing session state, tab selection, and commands for creating/closing terminals.

### TerminalSessionViewModel

```csharp
namespace SeniorIntern.Desktop.ViewModels;

using CommunityToolkit.Mvvm.ComponentModel;
using SeniorIntern.Core.Models.Terminal;

/// <summary>
/// ViewModel for a single terminal session (tab)
/// </summary>
public partial class TerminalSessionViewModel : ViewModelBase
{
    private readonly TerminalSession _session;

    /// <summary>
    /// Session ID
    /// </summary>
    public Guid Id => _session.Id;

    /// <summary>
    /// Display name for the tab
    /// </summary>
    [ObservableProperty]
    private string _name;

    /// <summary>
    /// Whether this session is the active/selected one
    /// </summary>
    [ObservableProperty]
    private bool _isActive;

    /// <summary>
    /// Current session state
    /// </summary>
    [ObservableProperty]
    private TerminalSessionState _state;

    /// <summary>
    /// Current working directory
    /// </summary>
    [ObservableProperty]
    private string _workingDirectory;

    /// <summary>
    /// Shell type (for icon display)
    /// </summary>
    public string ShellType { get; }

    /// <summary>
    /// Whether the session has exited
    /// </summary>
    public bool HasExited => State == TerminalSessionState.Exited ||
                             State == TerminalSessionState.Error;

    /// <summary>
    /// Exit code if session has ended
    /// </summary>
    public int? ExitCode => _session.ExitCode;

    public TerminalSessionViewModel(TerminalSession session)
    {
        _session = session;
        _name = session.Name;
        _state = session.State;
        _workingDirectory = session.WorkingDirectory;
        ShellType = GetShellType(session.ShellPath);
    }

    /// <summary>
    /// Update from the underlying session
    /// </summary>
    public void UpdateFromSession()
    {
        Name = _session.Title ?? _session.Name;
        State = _session.State;
        WorkingDirectory = _session.WorkingDirectory;
    }

    private static string GetShellType(string shellPath)
    {
        var fileName = Path.GetFileNameWithoutExtension(shellPath).ToLowerInvariant();
        return fileName switch
        {
            "bash" => "bash",
            "zsh" => "zsh",
            "fish" => "fish",
            "pwsh" or "powershell" => "powershell",
            "cmd" => "cmd",
            "nu" => "nushell",
            _ => "terminal"
        };
    }
}
```

### TerminalPanelViewModel

```csharp
namespace SeniorIntern.Desktop.ViewModels;

using System.Collections.ObjectModel;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models.Terminal;

/// <summary>
/// ViewModel for the terminal panel
/// </summary>
public partial class TerminalPanelViewModel : ViewModelBase
{
    private readonly ITerminalService _terminalService;
    private readonly IWorkspaceService? _workspaceService;

    /// <summary>
    /// All terminal sessions
    /// </summary>
    public ObservableCollection<TerminalSessionViewModel> Sessions { get; } = new();

    /// <summary>
    /// Currently active session
    /// </summary>
    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(HasActiveSession))]
    [NotifyCanExecuteChangedFor(nameof(CloseActiveSessionCommand))]
    [NotifyCanExecuteChangedFor(nameof(ClearTerminalCommand))]
    private TerminalSessionViewModel? _activeSession;

    /// <summary>
    /// Whether there is an active session
    /// </summary>
    public bool HasActiveSession => ActiveSession != null;

    /// <summary>
    /// Whether the panel is visible
    /// </summary>
    [ObservableProperty]
    private bool _isVisible;

    /// <summary>
    /// Whether the panel is maximized
    /// </summary>
    [ObservableProperty]
    private bool _isMaximized;

    /// <summary>
    /// Panel height when not maximized
    /// </summary>
    [ObservableProperty]
    private double _panelHeight = 300;

    /// <summary>
    /// Terminal font family setting
    /// </summary>
    [ObservableProperty]
    private string _fontFamily = "Cascadia Mono";

    /// <summary>
    /// Terminal font size setting
    /// </summary>
    [ObservableProperty]
    private double _fontSize = 14;

    /// <summary>
    /// Current terminal theme
    /// </summary>
    [ObservableProperty]
    private TerminalTheme _theme = TerminalTheme.Dark;

    /// <summary>
    /// Event raised when the active session changes
    /// </summary>
    public event EventHandler<TerminalSessionViewModel?>? ActiveSessionChanged;

    public TerminalPanelViewModel(
        ITerminalService terminalService,
        IWorkspaceService? workspaceService = null)
    {
        _terminalService = terminalService;
        _workspaceService = workspaceService;

        // Subscribe to service events
        _terminalService.SessionCreated += OnSessionCreated;
        _terminalService.SessionClosed += OnSessionClosed;
        _terminalService.SessionStateChanged += OnSessionStateChanged;
        _terminalService.TitleChanged += OnTitleChanged;
    }

    /// <summary>
    /// Create a new terminal session
    /// </summary>
    [RelayCommand]
    private async Task NewSessionAsync()
    {
        try
        {
            IsBusy = true;
            ClearError();

            var options = new TerminalSessionOptions
            {
                WorkingDirectory = _workspaceService?.CurrentWorkspace?.RootPath,
                Size = new TerminalSize(80, 24)
            };

            var session = await _terminalService.CreateSessionAsync(options);

            // Show panel if hidden
            IsVisible = true;
        }
        catch (Exception ex)
        {
            SetError($"Failed to create terminal: {ex.Message}");
        }
        finally
        {
            IsBusy = false;
        }
    }

    /// <summary>
    /// Close a specific session
    /// </summary>
    [RelayCommand]
    private async Task CloseSessionAsync(TerminalSessionViewModel? session)
    {
        if (session == null)
            return;

        try
        {
            await _terminalService.CloseSessionAsync(session.Id);
        }
        catch (Exception ex)
        {
            SetError($"Failed to close terminal: {ex.Message}");
        }
    }

    /// <summary>
    /// Close the active session
    /// </summary>
    [RelayCommand(CanExecute = nameof(HasActiveSession))]
    private async Task CloseActiveSessionAsync()
    {
        if (ActiveSession != null)
        {
            await CloseSessionAsync(ActiveSession);
        }
    }

    /// <summary>
    /// Activate a session (switch tabs)
    /// </summary>
    [RelayCommand]
    private void ActivateSession(TerminalSessionViewModel? session)
    {
        if (session == null || session == ActiveSession)
            return;

        // Deactivate current
        if (ActiveSession != null)
        {
            ActiveSession.IsActive = false;
        }

        // Activate new
        session.IsActive = true;
        ActiveSession = session;
        _terminalService.ActiveSession = _terminalService.Sessions
            .FirstOrDefault(s => s.Id == session.Id);

        ActiveSessionChanged?.Invoke(this, session);
    }

    /// <summary>
    /// Toggle panel visibility
    /// </summary>
    [RelayCommand]
    private void TogglePanel()
    {
        if (IsVisible)
        {
            HidePanel();
        }
        else
        {
            ShowPanel();
        }
    }

    /// <summary>
    /// Show the terminal panel
    /// </summary>
    [RelayCommand]
    private void ShowPanel()
    {
        IsVisible = true;

        // Create a session if none exist
        if (Sessions.Count == 0)
        {
            _ = NewSessionAsync();
        }
    }

    /// <summary>
    /// Hide the terminal panel
    /// </summary>
    [RelayCommand]
    private void HidePanel()
    {
        IsVisible = false;
        IsMaximized = false;
    }

    /// <summary>
    /// Toggle maximized state
    /// </summary>
    [RelayCommand]
    private void ToggleMaximize()
    {
        IsMaximized = !IsMaximized;
    }

    /// <summary>
    /// Clear the terminal screen
    /// </summary>
    [RelayCommand(CanExecute = nameof(HasActiveSession))]
    private async Task ClearTerminalAsync()
    {
        if (ActiveSession == null)
            return;

        try
        {
            await _terminalService.ExecuteCommandAsync(
                ActiveSession.Id,
                "clear");
        }
        catch
        {
            // Ignore clear failures
        }
    }

    /// <summary>
    /// Navigate to next tab
    /// </summary>
    [RelayCommand]
    private void NextTab()
    {
        if (Sessions.Count <= 1)
            return;

        var currentIndex = ActiveSession != null
            ? Sessions.IndexOf(ActiveSession)
            : -1;

        var nextIndex = (currentIndex + 1) % Sessions.Count;
        ActivateSession(Sessions[nextIndex]);
    }

    /// <summary>
    /// Navigate to previous tab
    /// </summary>
    [RelayCommand]
    private void PreviousTab()
    {
        if (Sessions.Count <= 1)
            return;

        var currentIndex = ActiveSession != null
            ? Sessions.IndexOf(ActiveSession)
            : 0;

        var prevIndex = currentIndex > 0 ? currentIndex - 1 : Sessions.Count - 1;
        ActivateSession(Sessions[prevIndex]);
    }

    private void OnSessionCreated(object? sender, TerminalSessionEventArgs e)
    {
        Avalonia.Threading.Dispatcher.UIThread.Post(() =>
        {
            var viewModel = new TerminalSessionViewModel(e.Session);
            Sessions.Add(viewModel);

            // Auto-activate new sessions
            ActivateSession(viewModel);
        });
    }

    private void OnSessionClosed(object? sender, TerminalSessionEventArgs e)
    {
        Avalonia.Threading.Dispatcher.UIThread.Post(() =>
        {
            var session = Sessions.FirstOrDefault(s => s.Id == e.Session.Id);
            if (session == null)
                return;

            var wasActive = session.IsActive;
            var index = Sessions.IndexOf(session);

            Sessions.Remove(session);

            // Activate adjacent session if closed was active
            if (wasActive && Sessions.Count > 0)
            {
                var newIndex = Math.Min(index, Sessions.Count - 1);
                ActivateSession(Sessions[newIndex]);
            }
            else if (Sessions.Count == 0)
            {
                ActiveSession = null;
            }
        });
    }

    private void OnSessionStateChanged(object? sender, TerminalSessionStateEventArgs e)
    {
        Avalonia.Threading.Dispatcher.UIThread.Post(() =>
        {
            var session = Sessions.FirstOrDefault(s => s.Id == e.Session.Id);
            session?.UpdateFromSession();
        });
    }

    private void OnTitleChanged(object? sender, TerminalTitleEventArgs e)
    {
        Avalonia.Threading.Dispatcher.UIThread.Post(() =>
        {
            var session = Sessions.FirstOrDefault(s => s.Id == e.SessionId);
            if (session != null)
            {
                session.Name = e.Title;
            }
        });
    }
}
```

### v0.5.2d Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/ViewModels/TerminalSessionViewModel.cs` | Session tab ViewModel |
| `src/SeniorIntern.Desktop/ViewModels/TerminalPanelViewModel.cs` | Panel ViewModel |

### v0.5.2d Verification

```bash
# Verify Desktop builds
dotnet build src/SeniorIntern.Desktop
```

---

## v0.5.2e: Terminal Panel

### Objective
Create the terminal panel UI with tab bar, session tabs, and panel controls. This integrates the TerminalControl with the ViewModels.

### TerminalPanel.axaml

```xml
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:vm="using:SeniorIntern.Desktop.ViewModels"
             xmlns:terminal="using:SeniorIntern.Desktop.Controls.Terminal"
             x:Class="SeniorIntern.Desktop.Views.TerminalPanel"
             x:DataType="vm:TerminalPanelViewModel"
             Background="{DynamicResource TerminalBackground}">

    <Grid RowDefinitions="Auto, *">
        <!-- Tab Bar -->
        <Border Grid.Row="0"
                Background="{DynamicResource TerminalTabBarBackground}"
                BorderBrush="{DynamicResource BorderBrush}"
                BorderThickness="0,0,0,1"
                Padding="4,0">
            <Grid ColumnDefinitions="*, Auto">
                <!-- Tabs ScrollViewer -->
                <ScrollViewer Grid.Column="0"
                              HorizontalScrollBarVisibility="Auto"
                              VerticalScrollBarVisibility="Disabled">
                    <StackPanel Orientation="Horizontal" Spacing="0">
                        <!-- Tab Items -->
                        <ItemsControl ItemsSource="{Binding Sessions}">
                            <ItemsControl.ItemsPanel>
                                <ItemsPanelTemplate>
                                    <StackPanel Orientation="Horizontal" />
                                </ItemsPanelTemplate>
                            </ItemsControl.ItemsPanel>
                            <ItemsControl.ItemTemplate>
                                <DataTemplate x:DataType="vm:TerminalSessionViewModel">
                                    <Button Theme="{DynamicResource TerminalTab}"
                                            Classes.active="{Binding IsActive}"
                                            Command="{Binding $parent[UserControl].((vm:TerminalPanelViewModel)DataContext).ActivateSessionCommand}"
                                            CommandParameter="{Binding}">
                                        <Grid ColumnDefinitions="Auto, *, Auto" MinWidth="80">
                                            <!-- Shell Icon -->
                                            <PathIcon Grid.Column="0"
                                                      Data="{StaticResource TerminalIcon}"
                                                      Width="14" Height="14"
                                                      Foreground="{DynamicResource TextMuted}"
                                                      Margin="0,0,6,0" />

                                            <!-- Tab Name -->
                                            <TextBlock Grid.Column="1"
                                                       Text="{Binding Name}"
                                                       VerticalAlignment="Center"
                                                       TextTrimming="CharacterEllipsis"
                                                       MaxWidth="120" />

                                            <!-- Close Button -->
                                            <Button Grid.Column="2"
                                                    Theme="{DynamicResource TerminalTabCloseButton}"
                                                    Classes="tab-close"
                                                    Command="{Binding $parent[UserControl].((vm:TerminalPanelViewModel)DataContext).CloseSessionCommand}"
                                                    CommandParameter="{Binding}"
                                                    ToolTip.Tip="Close terminal">
                                                <PathIcon Data="{StaticResource CloseIcon}"
                                                          Width="10" Height="10" />
                                            </Button>
                                        </Grid>
                                    </Button>
                                </DataTemplate>
                            </ItemsControl.ItemTemplate>
                        </ItemsControl>

                        <!-- New Tab Button -->
                        <Button Theme="{DynamicResource TerminalNewTabButton}"
                                Command="{Binding NewSessionCommand}"
                                ToolTip.Tip="New terminal (Ctrl+Shift+`)">
                            <PathIcon Data="{StaticResource PlusIcon}"
                                      Width="12" Height="12" />
                        </Button>
                    </StackPanel>
                </ScrollViewer>

                <!-- Panel Actions -->
                <StackPanel Grid.Column="1"
                            Orientation="Horizontal"
                            Spacing="2"
                            Margin="8,0,0,0">
                    <!-- Split Terminal -->
                    <Button Theme="{DynamicResource TerminalIconButton}"
                            ToolTip.Tip="Split terminal"
                            IsVisible="False">
                        <PathIcon Data="{StaticResource SplitHorizontalIcon}"
                                  Width="14" Height="14" />
                    </Button>

                    <!-- Maximize/Restore -->
                    <Button Theme="{DynamicResource TerminalIconButton}"
                            Command="{Binding ToggleMaximizeCommand}"
                            ToolTip.Tip="{Binding IsMaximized, Converter={x:Static StringConverters.FalseIsEmpty}, ConverterParameter='Restore terminal,Maximize terminal'}">
                        <PathIcon Data="{Binding IsMaximized, Converter={x:Static BoolConverters.ToSelector}, ConverterParameter={StaticResource MinimizeIcon}:{StaticResource MaximizeIcon}}"
                                  Width="14" Height="14" />
                    </Button>

                    <!-- Hide Panel -->
                    <Button Theme="{DynamicResource TerminalIconButton}"
                            Command="{Binding HidePanelCommand}"
                            ToolTip.Tip="Hide terminal panel (Ctrl+`)">
                        <PathIcon Data="{StaticResource ChevronDownIcon}"
                                  Width="14" Height="14" />
                    </Button>
                </StackPanel>
            </Grid>
        </Border>

        <!-- Terminal Content Area -->
        <Grid Grid.Row="1">
            <!-- Terminal Control -->
            <terminal:TerminalControl x:Name="TerminalView"
                                       FontFamily="{Binding FontFamily}"
                                       FontSize="{Binding FontSize}"
                                       Theme="{Binding Theme}"
                                       IsVisible="{Binding HasActiveSession}" />

            <!-- Empty State -->
            <StackPanel HorizontalAlignment="Center"
                        VerticalAlignment="Center"
                        Spacing="16"
                        IsVisible="{Binding !HasActiveSession}">
                <PathIcon Data="{StaticResource TerminalIcon}"
                          Width="48" Height="48"
                          Foreground="{DynamicResource TextMuted}" />
                <TextBlock Text="No terminal sessions"
                           Foreground="{DynamicResource TextMuted}"
                           HorizontalAlignment="Center" />
                <Button Theme="{DynamicResource PrimaryButton}"
                        Command="{Binding NewSessionCommand}"
                        Content="Create Terminal"
                        HorizontalAlignment="Center" />
            </StackPanel>
        </Grid>
    </Grid>

</UserControl>
```

### TerminalPanel.axaml.cs

```csharp
namespace SeniorIntern.Desktop.Views;

using Avalonia.Controls;
using Avalonia.Interactivity;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Desktop.ViewModels;

/// <summary>
/// Terminal panel with tabs and session management
/// </summary>
public partial class TerminalPanel : UserControl
{
    private ITerminalService? _terminalService;
    private TerminalPanelViewModel? _viewModel;

    public TerminalPanel()
    {
        InitializeComponent();
    }

    protected override void OnLoaded(RoutedEventArgs e)
    {
        base.OnLoaded(e);

        _viewModel = DataContext as TerminalPanelViewModel;
        if (_viewModel != null)
        {
            _viewModel.ActiveSessionChanged += OnActiveSessionChanged;
        }
    }

    protected override void OnUnloaded(RoutedEventArgs e)
    {
        base.OnUnloaded(e);

        if (_viewModel != null)
        {
            _viewModel.ActiveSessionChanged -= OnActiveSessionChanged;
        }
    }

    /// <summary>
    /// Initialize with the terminal service
    /// </summary>
    public void Initialize(ITerminalService terminalService)
    {
        _terminalService = terminalService;
    }

    private async void OnActiveSessionChanged(object? sender, TerminalSessionViewModel? session)
    {
        if (_terminalService == null)
            return;

        if (session != null)
        {
            await TerminalView.AttachSessionAsync(_terminalService, session.Id);
            TerminalView.Focus();
        }
        else
        {
            TerminalView.DetachSession();
        }
    }
}
```

### v0.5.2e Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/Views/TerminalPanel.axaml` | Terminal panel XAML |
| `src/SeniorIntern.Desktop/Views/TerminalPanel.axaml.cs` | Terminal panel code-behind |

### v0.5.2e Verification

```bash
# Verify Desktop builds
dotnet build src/SeniorIntern.Desktop
```

---

## v0.5.2f: Main Window Integration

### Objective
Integrate the terminal panel into the main window with a resizable splitter, add keyboard shortcuts for terminal operations, and update the MainWindowViewModel.

### MainWindow.axaml Updates

```xml
<!-- Updated MainWindow.axaml structure -->
<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:vm="using:SeniorIntern.Desktop.ViewModels"
        xmlns:views="using:SeniorIntern.Desktop.Views"
        x:Class="SeniorIntern.Desktop.Views.MainWindow"
        x:DataType="vm:MainWindowViewModel"
        Title="The Senior Intern"
        Width="1200" Height="800"
        MinWidth="800" MinHeight="600"
        Background="{DynamicResource WindowBackground}">

    <Window.KeyBindings>
        <!-- Terminal Shortcuts -->
        <KeyBinding Gesture="Ctrl+`" Command="{Binding TerminalPanelViewModel.TogglePanelCommand}" />
        <KeyBinding Gesture="Ctrl+Shift+`" Command="{Binding TerminalPanelViewModel.NewSessionCommand}" />
        <KeyBinding Gesture="Ctrl+Shift+W" Command="{Binding TerminalPanelViewModel.CloseActiveSessionCommand}" />
        <KeyBinding Gesture="Ctrl+PageDown" Command="{Binding TerminalPanelViewModel.NextTabCommand}" />
        <KeyBinding Gesture="Ctrl+PageUp" Command="{Binding TerminalPanelViewModel.PreviousTabCommand}" />
    </Window.KeyBindings>

    <Grid RowDefinitions="*, Auto, Auto, Auto">
        <!-- Main Content (Editor + Chat) -->
        <Grid Grid.Row="0" ColumnDefinitions="280, Auto, *">
            <!-- Sidebar -->
            <Border Grid.Column="0"
                    Background="{DynamicResource SidebarBackground}"
                    BorderBrush="{DynamicResource BorderBrush}"
                    BorderThickness="0,0,1,0">
                <DockPanel>
                    <!-- Model Selector at Top -->
                    <views:ModelSelectorView DockPanel.Dock="Top"
                                             DataContext="{Binding ModelSelectorViewModel}" />

                    <!-- Future: Chat History List -->
                    <Border DockPanel.Dock="Bottom" Padding="16">
                        <StackPanel Spacing="8">
                            <TextBlock Text="Chat History"
                                       FontWeight="SemiBold"
                                       Foreground="{DynamicResource TextMuted}" />
                            <TextBlock Text="Coming in v0.2.0"
                                       Foreground="{DynamicResource TextMuted}"
                                       FontStyle="Italic"
                                       FontSize="12" />
                        </StackPanel>
                    </Border>
                </DockPanel>
            </Border>

            <!-- Splitter -->
            <GridSplitter Grid.Column="1"
                          Width="4"
                          Background="Transparent"
                          ResizeDirection="Columns" />

            <!-- Chat Area -->
            <views:ChatView Grid.Column="2"
                            DataContext="{Binding ChatViewModel}" />
        </Grid>

        <!-- Terminal Resize Handle -->
        <GridSplitter Grid.Row="1"
                      Height="4"
                      Background="Transparent"
                      ResizeDirection="Rows"
                      IsVisible="{Binding TerminalPanelViewModel.IsVisible}" />

        <!-- Terminal Panel -->
        <views:TerminalPanel Grid.Row="2"
                             x:Name="TerminalPanel"
                             DataContext="{Binding TerminalPanelViewModel}"
                             Height="{Binding TerminalPanelViewModel.PanelHeight, Mode=TwoWay}"
                             MinHeight="100"
                             MaxHeight="{Binding Bounds.Height, RelativeSource={RelativeSource AncestorType=Window}, Converter={StaticResource MultiplyConverter}, ConverterParameter=0.7}"
                             IsVisible="{Binding TerminalPanelViewModel.IsVisible}">
            <!-- Handle maximized state -->
            <views:TerminalPanel.Styles>
                <Style Selector="views|TerminalPanel[IsMaximized=True]">
                    <Setter Property="Height" Value="{Binding Bounds.Height, RelativeSource={RelativeSource AncestorType=Grid}}" />
                </Style>
            </views:TerminalPanel.Styles>
        </views:TerminalPanel>

        <!-- Status Bar -->
        <Border Grid.Row="3"
                Background="{DynamicResource StatusBarBackground}"
                BorderBrush="{DynamicResource BorderBrush}"
                BorderThickness="0,1,0,0"
                Padding="12,6">
            <Grid ColumnDefinitions="Auto, *, Auto, Auto">
                <!-- Terminal Toggle Button -->
                <Button Grid.Column="0"
                        Theme="{DynamicResource SubtleButton}"
                        Command="{Binding TerminalPanelViewModel.TogglePanelCommand}"
                        ToolTip.Tip="Toggle terminal (Ctrl+`)"
                        Margin="0,0,12,0">
                    <StackPanel Orientation="Horizontal" Spacing="6">
                        <PathIcon Data="{StaticResource TerminalIcon}"
                                  Width="14" Height="14"
                                  Foreground="{DynamicResource TextSecondary}" />
                        <TextBlock Text="Terminal"
                                   Foreground="{DynamicResource TextSecondary}"
                                   VerticalAlignment="Center" />
                    </StackPanel>
                </Button>

                <TextBlock Grid.Column="1"
                           Text="{Binding StatusMessage}"
                           VerticalAlignment="Center"
                           Foreground="{DynamicResource TextSecondary}" />

                <TextBlock Grid.Column="2"
                           Text="{Binding TokenInfo}"
                           VerticalAlignment="Center"
                           Foreground="{DynamicResource TextMuted}"
                           Margin="16,0" />

                <ProgressBar Grid.Column="3"
                             IsVisible="{Binding ChatViewModel.IsGenerating}"
                             IsIndeterminate="True"
                             Width="80"
                             Height="4" />
            </Grid>
        </Border>
    </Grid>

</Window>
```

### MainWindow.axaml.cs Updates

```csharp
// Add to MainWindow.axaml.cs
protected override void OnLoaded(RoutedEventArgs e)
{
    base.OnLoaded(e);

    // Initialize terminal panel with service
    if (DataContext is MainWindowViewModel vm)
    {
        var terminalService = App.Services.GetRequiredService<ITerminalService>();
        TerminalPanel.Initialize(terminalService);
    }
}
```

### MainWindowViewModel Updates

```csharp
namespace SeniorIntern.Desktop.ViewModels;

using CommunityToolkit.Mvvm.ComponentModel;
using SeniorIntern.Core.Events;
using SeniorIntern.Core.Interfaces;

public partial class MainWindowViewModel : ViewModelBase
{
    private readonly ILlmService _llmService;
    private readonly ISettingsService _settingsService;

    public ChatViewModel ChatViewModel { get; }
    public ModelSelectorViewModel ModelSelectorViewModel { get; }
    public TerminalPanelViewModel TerminalPanelViewModel { get; }

    [ObservableProperty]
    private string _statusMessage = "No model loaded";

    [ObservableProperty]
    private string _tokenInfo = string.Empty;

    public MainWindowViewModel(
        ChatViewModel chatViewModel,
        ModelSelectorViewModel modelSelectorViewModel,
        TerminalPanelViewModel terminalPanelViewModel,
        ILlmService llmService,
        ISettingsService settingsService)
    {
        ChatViewModel = chatViewModel;
        ModelSelectorViewModel = modelSelectorViewModel;
        TerminalPanelViewModel = terminalPanelViewModel;
        _llmService = llmService;
        _settingsService = settingsService;

        // Subscribe to service events
        _llmService.ModelStateChanged += OnModelStateChanged;
        _llmService.InferenceProgress += OnInferenceProgress;

        // Load settings on startup
        _ = LoadSettingsAsync();
    }

    private async Task LoadSettingsAsync()
    {
        await _settingsService.LoadSettingsAsync();
    }

    private void OnModelStateChanged(object? sender, ModelStateChangedEventArgs e)
    {
        StatusMessage = e.IsLoaded
            ? $"Model: {e.ModelName}"
            : "No model loaded";
    }

    private void OnInferenceProgress(object? sender, InferenceProgressEventArgs e)
    {
        TokenInfo = $"Tokens: {e.TokensGenerated} ({e.TokensPerSecond:F1} tok/s)";
    }
}
```

### MultiplyConverter for Max Height

```csharp
namespace SeniorIntern.Desktop.Converters;

using Avalonia.Data.Converters;
using System.Globalization;

/// <summary>
/// Multiplies a value by a factor
/// </summary>
public class MultiplyConverter : IValueConverter
{
    public static readonly MultiplyConverter Instance = new();

    public object? Convert(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        if (value is double d && parameter is string s && double.TryParse(s, out var factor))
        {
            return d * factor;
        }
        return value;
    }

    public object? ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        throw new NotImplementedException();
    }
}
```

### DI Registration Updates

```csharp
// In App.axaml.cs ConfigureServices
services.AddSingleton<TerminalPanelViewModel>();
```

### v0.5.2f Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/Converters/MultiplyConverter.cs` | Value converter for max height |

### v0.5.2f Files to Modify

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/Views/MainWindow.axaml` | Add terminal panel and keyboard shortcuts |
| `src/SeniorIntern.Desktop/Views/MainWindow.axaml.cs` | Initialize terminal panel |
| `src/SeniorIntern.Desktop/ViewModels/MainWindowViewModel.cs` | Add TerminalPanelViewModel |
| `src/SeniorIntern.Desktop/App.axaml.cs` | Register TerminalPanelViewModel |
| `src/SeniorIntern.Desktop/App.axaml` | Add converter to resources |

### v0.5.2f Verification

```bash
# Run the application
dotnet run --project src/SeniorIntern.Desktop

# Verify:
# 1. Terminal panel appears when pressing Ctrl+`
# 2. New terminal created with Ctrl+Shift+`
# 3. Tab switching works
# 4. Terminal input/output functions
# 5. Resize splitter works
# 6. Close tab works
```

---

## Files Summary

### Files to Create (Total: 13)

| Part | File | Purpose |
|------|------|---------|
| v0.5.2a | `src/SeniorIntern.Core/Models/Terminal/TerminalTheme.cs` | Theme model |
| v0.5.2a | `src/SeniorIntern.Core/Models/Terminal/CursorStyle.cs` | Cursor style enum |
| v0.5.2a | `src/SeniorIntern.Desktop/Resources/IconPaths.axaml` | UI icons |
| v0.5.2b | `src/SeniorIntern.Desktop/Controls/Terminal/TerminalFontMetrics.cs` | Font metrics |
| v0.5.2b | `src/SeniorIntern.Desktop/Controls/Terminal/TerminalRenderer.cs` | SkiaSharp renderer |
| v0.5.2c | `src/SeniorIntern.Desktop/Controls/Terminal/TerminalControl.axaml` | Control XAML |
| v0.5.2c | `src/SeniorIntern.Desktop/Controls/Terminal/TerminalControl.axaml.cs` | Control code |
| v0.5.2d | `src/SeniorIntern.Desktop/ViewModels/TerminalSessionViewModel.cs` | Session VM |
| v0.5.2d | `src/SeniorIntern.Desktop/ViewModels/TerminalPanelViewModel.cs` | Panel VM |
| v0.5.2e | `src/SeniorIntern.Desktop/Views/TerminalPanel.axaml` | Panel XAML |
| v0.5.2e | `src/SeniorIntern.Desktop/Views/TerminalPanel.axaml.cs` | Panel code |
| v0.5.2f | `src/SeniorIntern.Desktop/Converters/MultiplyConverter.cs` | Value converter |

### Files to Modify (Total: 6)

| Part | File | Changes |
|------|------|---------|
| v0.5.2a | `src/SeniorIntern.Desktop/Themes/Dark.axaml` | Add terminal styles |
| v0.5.2a | `src/SeniorIntern.Desktop/App.axaml` | Include icon resources |
| v0.5.2f | `src/SeniorIntern.Desktop/Views/MainWindow.axaml` | Add terminal panel |
| v0.5.2f | `src/SeniorIntern.Desktop/Views/MainWindow.axaml.cs` | Initialize panel |
| v0.5.2f | `src/SeniorIntern.Desktop/ViewModels/MainWindowViewModel.cs` | Add TerminalPanelViewModel |
| v0.5.2f | `src/SeniorIntern.Desktop/App.axaml.cs` | Register services |

---

## Testing Strategy

### Unit Tests
- TerminalFontMetrics: pixel-to-cell conversion accuracy
- TerminalTheme: palette color calculation (256-color mode)
- TerminalSessionViewModel: state updates

### Integration Tests
- Terminal panel shows/hides correctly
- Tab creation and switching
- Keyboard shortcuts trigger commands
- Resize splitter updates terminal size

### Visual Tests
- Correct color rendering for ANSI codes
- Cursor styles (block, underline, bar)
- Selection highlighting
- Font rendering (bold, italic, underline)
- Scrollbar appearance and behavior

### Manual Testing Checklist
- [ ] Create new terminal with Ctrl+Shift+`
- [ ] Toggle panel with Ctrl+`
- [ ] Close tab with close button
- [ ] Switch tabs with click
- [ ] Switch tabs with Ctrl+PageDown/PageUp
- [ ] Type input and see output
- [ ] Select text with mouse drag
- [ ] Double-click to select word
- [ ] Triple-click to select line
- [ ] Copy with Ctrl+Shift+C
- [ ] Paste with Ctrl+Shift+V or right-click
- [ ] Scroll with mouse wheel
- [ ] Resize panel with splitter
- [ ] Maximize panel
- [ ] Test colored output (e.g., `ls --color`)

---

## Acceptance Criteria

### v0.5.2a
- [ ] TerminalTheme model supports all color modes
- [ ] 256-color palette calculation correct
- [ ] Terminal styles added to Dark theme
- [ ] Icons load correctly

### v0.5.2b
- [ ] TerminalRenderer displays buffer content
- [ ] Font metrics calculate correctly
- [ ] Colors render accurately
- [ ] Cursor renders in correct position

### v0.5.2c
- [ ] Keyboard input works (letters, special keys)
- [ ] Mouse selection works (single, double, triple click)
- [ ] Clipboard copy/paste works
- [ ] Cursor blink animation works
- [ ] Scrollbar updates on content

### v0.5.2d
- [ ] TerminalSessionViewModel updates from session
- [ ] TerminalPanelViewModel manages multiple sessions
- [ ] Commands execute correctly
- [ ] Events properly propagate

### v0.5.2e
- [ ] Tab bar displays sessions
- [ ] Tab click activates session
- [ ] Close button removes session
- [ ] New tab button creates session
- [ ] Panel actions work (maximize, hide)

### v0.5.2f
- [ ] Terminal panel integrated in main window
- [ ] Keyboard shortcuts work globally
- [ ] Resize splitter functions
- [ ] Status bar toggle button works
- [ ] Panel state persists correctly

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| SkiaSharp rendering performance | Medium | High | Implement dirty-rect rendering |
| Font fallback not working | Low | Medium | Provide multiple fallback fonts |
| Keyboard shortcuts conflict | Low | Low | Document and test all shortcuts |
| Selection across wrapped lines | Medium | Medium | Handle line wrapping in selection |
| Focus issues between tabs | Medium | Medium | Careful focus management |

---

## Dependencies

### External
- SkiaSharp (via Avalonia.Skia)
- CommunityToolkit.Mvvm

### Internal
- v0.5.1 Terminal Foundation (ITerminalService, TerminalBuffer, etc.)

---

## Future Considerations

Features deferred to later sub-versions:
- Split terminal panes (v0.5.3+)
- Terminal profiles/shell selection (v0.5.3)
- Search within terminal output (v0.5.5)
- Hyperlink detection and clicking (v0.5.5)
- Custom keyboard shortcuts configuration
- Theme customization UI
