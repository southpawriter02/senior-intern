# v0.5.1d – Terminal Service

## Overview

This specification defines the **Terminal Service** component for AIntern v0.5.1. The Terminal Service provides the core abstraction for managing terminal sessions, handling PTY (pseudo-terminal) operations, and coordinating between the UI layer and underlying shell processes. It serves as the central orchestrator for all terminal-related functionality.

**Parent Specification:** [v0.5.1-terminal-foundation.md](./v0.5.1-terminal-foundation.md)
**Related Specifications:**
- [v0.5.1a-project-setup.md](./v0.5.1a-project-setup.md) – Project setup and dependencies
- [v0.5.1b-terminal-models.md](./v0.5.1b-terminal-models.md) – Terminal models and state
- [v0.5.1c-ansi-parser.md](./v0.5.1c-ansi-parser.md) – ANSI escape sequence parsing
- [v0.5.1e-shell-detection.md](./v0.5.1e-shell-detection.md) – Shell detection service (dependency)

---

## Table of Contents

1. [Component Purpose](#1-component-purpose)
2. [Architecture Overview](#2-architecture-overview)
3. [File Structure](#3-file-structure)
4. [ITerminalService Interface](#4-iterminalservice-interface)
5. [Supporting Types](#5-supporting-types)
6. [TerminalService Implementation](#6-terminalservice-implementation)
7. [Session Lifecycle Management](#7-session-lifecycle-management)
8. [PTY Integration](#8-pty-integration)
9. [Event System](#9-event-system)
10. [Thread Safety](#10-thread-safety)
11. [Error Handling](#11-error-handling)
12. [Testing Strategy](#12-testing-strategy)
13. [Integration Points](#13-integration-points)
14. [Implementation Checklist](#14-implementation-checklist)

---

## 1. Component Purpose

The Terminal Service is responsible for:

1. **Session Management** – Creating, tracking, and destroying terminal sessions
2. **PTY Operations** – Spawning pseudo-terminal processes and managing I/O
3. **Input/Output Routing** – Forwarding user input to shells and shell output to buffers
4. **Signal Handling** – Sending terminal signals (SIGINT, SIGTERM, etc.) to processes
5. **Lifecycle Coordination** – Managing session state transitions and cleanup
6. **Cross-Platform Abstraction** – Providing consistent behavior across Windows, macOS, and Linux

### Design Principles

- **Async-First**: All potentially blocking operations are asynchronous
- **Thread-Safe**: Safe for concurrent access from UI and background threads
- **Resource-Managed**: Proper cleanup of PTY processes and resources via IAsyncDisposable
- **Event-Driven**: Notifications via events for loose coupling with consumers
- **Testable**: Interface-based design with injectable dependencies

---

## 2. Architecture Overview

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              Terminal Service                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                         ITerminalService                             │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌────────────┐  │   │
│  │  │   Sessions  │  │ CreateAsync │  │  WriteInput │  │   Events   │  │   │
│  │  │   Property  │  │   Method    │  │   Method    │  │  (5 types) │  │   │
│  │  └─────────────┘  └─────────────┘  └─────────────┘  └────────────┘  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                         │
│                                    ▼                                         │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                         TerminalService                              │   │
│  │  ┌─────────────────────────────────────────────────────────────┐   │   │
│  │  │              ConcurrentDictionary<Guid, Context>             │   │   │
│  │  └─────────────────────────────────────────────────────────────┘   │   │
│  │                                    │                                │   │
│  │  ┌─────────────────────────────────────────────────────────────┐   │   │
│  │  │                  TerminalSessionContext                      │   │   │
│  │  │  ┌────────────┐  ┌────────────┐  ┌────────────────────────┐ │   │   │
│  │  │  │TermSession │  │ IPtyProcess│  │  CancellationTokenSrc  │ │   │   │
│  │  │  └────────────┘  └────────────┘  └────────────────────────┘ │   │   │
│  │  └─────────────────────────────────────────────────────────────┘   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                         │
│                                    ▼                                         │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                           Pty.Net Library                            │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐                  │   │
│  │  │   Windows   │  │    macOS    │  │    Linux    │                  │   │
│  │  │   ConPTY    │  │     PTY     │  │     PTY     │                  │   │
│  │  └─────────────┘  └─────────────┘  └─────────────┘                  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Data Flow

```
User Input → ITerminalService.WriteInputAsync() → IPtyProcess.Writer
                                                         │
                                                         ▼
                                                   Shell Process
                                                         │
                                                         ▼
IPtyProcess.Reader → Output Loop → AnsiParser → TerminalBuffer → OutputReceived Event
```

---

## 3. File Structure

```
src/
├── AIntern.Core/
│   └── Interfaces/
│       └── ITerminalService.cs          # Interface + supporting types
│
└── AIntern.Services/
    └── Terminal/
        └── TerminalService.cs           # PTY-based implementation
```

### File Responsibilities

| File | Purpose | Lines (Est.) |
|------|---------|--------------|
| `ITerminalService.cs` | Service interface, options record, signal enum, event args | ~200 |
| `TerminalService.cs` | Full implementation with PTY management | ~450 |

---

## 4. ITerminalService Interface

### Complete Interface Definition

```csharp
// src/AIntern.Core/Interfaces/ITerminalService.cs

using AIntern.Core.Models;

namespace AIntern.Core.Interfaces;

// ┌─────────────────────────────────────────────────────────────────────────┐
// │ TERMINAL SERVICE INTERFACE (v0.5.1d)                                    │
// │ Core abstraction for terminal session management and PTY operations.   │
// └─────────────────────────────────────────────────────────────────────────┘

/// <summary>
/// Core service interface for terminal session management.
/// Provides PTY-based terminal emulation with cross-platform support.
/// </summary>
/// <remarks>
/// <para>Added in v0.5.1d.</para>
/// <para>
/// This service manages the lifecycle of terminal sessions, including:
/// <list type="bullet">
///   <item>Creating and destroying sessions</item>
///   <item>Routing input to shell processes</item>
///   <item>Parsing and buffering shell output</item>
///   <item>Sending terminal signals</item>
///   <item>Resizing terminal dimensions</item>
/// </list>
/// </para>
/// <para>
/// Implementations must be thread-safe and properly dispose of all
/// PTY resources when the service is disposed.
/// </para>
/// </remarks>
public interface ITerminalService : IAsyncDisposable
{
    // ─────────────────────────────────────────────────────────────────────
    // Properties
    // ─────────────────────────────────────────────────────────────────────

    /// <summary>
    /// Gets all active terminal sessions.
    /// </summary>
    /// <remarks>
    /// Returns a snapshot of current sessions. The collection may change
    /// between calls as sessions are created or closed.
    /// </remarks>
    IReadOnlyList<TerminalSession> Sessions { get; }

    /// <summary>
    /// Gets the currently active (focused) terminal session, if any.
    /// </summary>
    /// <remarks>
    /// Only one session can be active at a time. Returns null if no
    /// sessions exist or none is currently focused.
    /// </remarks>
    TerminalSession? ActiveSession { get; }

    // ─────────────────────────────────────────────────────────────────────
    // Session Lifecycle Methods
    // ─────────────────────────────────────────────────────────────────────

    /// <summary>
    /// Creates a new terminal session with the specified options.
    /// </summary>
    /// <param name="options">Configuration for the new session.</param>
    /// <param name="cancellationToken">Token to cancel the operation.</param>
    /// <returns>The newly created terminal session.</returns>
    /// <exception cref="InvalidOperationException">
    /// Thrown if the shell executable cannot be found or started.
    /// </exception>
    /// <exception cref="OperationCanceledException">
    /// Thrown if the operation is cancelled.
    /// </exception>
    /// <remarks>
    /// <para>
    /// The session starts in the <see cref="TerminalSessionState.Starting"/>
    /// state and transitions to <see cref="TerminalSessionState.Running"/>
    /// once the shell process is successfully spawned.
    /// </para>
    /// <para>
    /// If options is null, default options will be used with auto-detected
    /// shell and default terminal dimensions (80x24).
    /// </para>
    /// </remarks>
    Task<TerminalSession> CreateSessionAsync(
        TerminalSessionOptions? options = null,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Closes an existing terminal session.
    /// </summary>
    /// <param name="sessionId">The ID of the session to close.</param>
    /// <param name="cancellationToken">Token to cancel the operation.</param>
    /// <returns>True if the session was found and closed; false otherwise.</returns>
    /// <remarks>
    /// <para>
    /// This method gracefully terminates the shell process by sending
    /// SIGTERM (or equivalent on Windows), then forcefully kills it
    /// after a timeout if necessary.
    /// </para>
    /// <para>
    /// The session transitions through <see cref="TerminalSessionState.Closing"/>
    /// before being removed from the sessions collection.
    /// </para>
    /// </remarks>
    Task<bool> CloseSessionAsync(
        Guid sessionId,
        CancellationToken cancellationToken = default);

    // ─────────────────────────────────────────────────────────────────────
    // I/O Methods
    // ─────────────────────────────────────────────────────────────────────

    /// <summary>
    /// Writes input data to a terminal session.
    /// </summary>
    /// <param name="sessionId">The target session ID.</param>
    /// <param name="data">The data to write (typically user keystrokes).</param>
    /// <param name="cancellationToken">Token to cancel the operation.</param>
    /// <returns>True if the data was written; false if session not found.</returns>
    /// <remarks>
    /// <para>
    /// The data is written directly to the PTY input stream, which forwards
    /// it to the shell process. This supports both regular text and special
    /// key sequences (e.g., escape codes for arrow keys).
    /// </para>
    /// <para>
    /// Writing to a session that is not in the Running state will return false.
    /// </para>
    /// </remarks>
    Task<bool> WriteInputAsync(
        Guid sessionId,
        string data,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Resizes the terminal dimensions for a session.
    /// </summary>
    /// <param name="sessionId">The target session ID.</param>
    /// <param name="columns">New column count (width in characters).</param>
    /// <param name="rows">New row count (height in characters).</param>
    /// <param name="cancellationToken">Token to cancel the operation.</param>
    /// <returns>True if resized successfully; false if session not found.</returns>
    /// <remarks>
    /// <para>
    /// This sends a SIGWINCH signal to the shell process, informing it of
    /// the new terminal dimensions. Applications running in the terminal
    /// (like vim, htop) will redraw accordingly.
    /// </para>
    /// <para>
    /// The session's <see cref="TerminalSession.Columns"/> and
    /// <see cref="TerminalSession.Rows"/> properties are updated.
    /// </para>
    /// </remarks>
    Task<bool> ResizeAsync(
        Guid sessionId,
        int columns,
        int rows,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Sends a terminal signal to a session.
    /// </summary>
    /// <param name="sessionId">The target session ID.</param>
    /// <param name="signal">The signal to send.</param>
    /// <param name="cancellationToken">Token to cancel the operation.</param>
    /// <returns>True if signal sent; false if session not found.</returns>
    /// <remarks>
    /// <para>
    /// Signals are translated to platform-specific equivalents:
    /// <list type="bullet">
    ///   <item>Interrupt → SIGINT (Ctrl+C)</item>
    ///   <item>Terminate → SIGTERM</item>
    ///   <item>Kill → SIGKILL</item>
    ///   <item>Suspend → SIGTSTP (Ctrl+Z)</item>
    ///   <item>Continue → SIGCONT</item>
    ///   <item>EndOfFile → Writes Ctrl+D to input</item>
    /// </list>
    /// </para>
    /// </remarks>
    Task<bool> SendSignalAsync(
        Guid sessionId,
        TerminalSignal signal,
        CancellationToken cancellationToken = default);

    // ─────────────────────────────────────────────────────────────────────
    // Buffer Access
    // ─────────────────────────────────────────────────────────────────────

    /// <summary>
    /// Gets the terminal buffer for a session.
    /// </summary>
    /// <param name="sessionId">The target session ID.</param>
    /// <returns>The terminal buffer, or null if session not found.</returns>
    /// <remarks>
    /// <para>
    /// The buffer contains all terminal content including scrollback history.
    /// Use this for rendering the terminal display and accessing terminal state.
    /// </para>
    /// <para>
    /// The returned buffer is the live buffer associated with the session.
    /// Changes from shell output will be reflected in subsequent reads.
    /// </para>
    /// </remarks>
    TerminalBuffer? GetBuffer(Guid sessionId);

    // ─────────────────────────────────────────────────────────────────────
    // Convenience Methods
    // ─────────────────────────────────────────────────────────────────────

    /// <summary>
    /// Changes the working directory for a session.
    /// </summary>
    /// <param name="sessionId">The target session ID.</param>
    /// <param name="path">The new working directory path.</param>
    /// <param name="cancellationToken">Token to cancel the operation.</param>
    /// <returns>True if command was sent; false if session not found.</returns>
    /// <remarks>
    /// <para>
    /// This is a convenience method that writes "cd {path}\n" to the session.
    /// The path is properly quoted to handle spaces and special characters.
    /// </para>
    /// <para>
    /// Note: This does not verify that the directory change succeeded.
    /// The shell will output an error if the path is invalid.
    /// </para>
    /// </remarks>
    Task<bool> ChangeDirectoryAsync(
        Guid sessionId,
        string path,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Executes a command in a terminal session.
    /// </summary>
    /// <param name="sessionId">The target session ID.</param>
    /// <param name="command">The command to execute.</param>
    /// <param name="cancellationToken">Token to cancel the operation.</param>
    /// <returns>True if command was sent; false if session not found.</returns>
    /// <remarks>
    /// <para>
    /// This is a convenience method that writes "{command}\n" to the session.
    /// The command is executed exactly as provided without modification.
    /// </para>
    /// <para>
    /// For commands that require elevated privileges, the shell will prompt
    /// for credentials as normal.
    /// </para>
    /// </remarks>
    Task<bool> ExecuteCommandAsync(
        Guid sessionId,
        string command,
        CancellationToken cancellationToken = default);

    // ─────────────────────────────────────────────────────────────────────
    // Events
    // ─────────────────────────────────────────────────────────────────────

    /// <summary>
    /// Raised when output is received from a terminal session.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Output is delivered as parsed terminal content. The event args
    /// contain both the raw output and the session ID.
    /// </para>
    /// <para>
    /// This event may be raised from a background thread. Handlers should
    /// marshal to the UI thread if necessary.
    /// </para>
    /// </remarks>
    event EventHandler<TerminalOutputEventArgs>? OutputReceived;

    /// <summary>
    /// Raised when a new terminal session is created.
    /// </summary>
    event EventHandler<TerminalSessionEventArgs>? SessionCreated;

    /// <summary>
    /// Raised when a terminal session is closed.
    /// </summary>
    /// <remarks>
    /// This is raised after the session has been removed from the
    /// Sessions collection and all resources have been cleaned up.
    /// </remarks>
    event EventHandler<TerminalSessionEventArgs>? SessionClosed;

    /// <summary>
    /// Raised when a session's state changes.
    /// </summary>
    /// <remarks>
    /// State transitions follow this pattern:
    /// Starting → Running → (Exited | Error) → Closing
    /// </remarks>
    event EventHandler<TerminalSessionStateEventArgs>? SessionStateChanged;

    /// <summary>
    /// Raised when the terminal title changes (via escape sequence).
    /// </summary>
    /// <remarks>
    /// Applications can set the terminal title using OSC escape sequences.
    /// This event allows the UI to update tab titles accordingly.
    /// </remarks>
    event EventHandler<TerminalTitleEventArgs>? TitleChanged;
}
```

---

## 5. Supporting Types

### 5.1 TerminalSessionOptions

```csharp
// src/AIntern.Core/Interfaces/ITerminalService.cs (continued)

/// <summary>
/// Options for creating a new terminal session.
/// </summary>
/// <remarks>
/// <para>Added in v0.5.1d.</para>
/// <para>
/// All properties have sensible defaults. Pass null to
/// <see cref="ITerminalService.CreateSessionAsync"/> to use defaults.
/// </para>
/// </remarks>
public sealed record TerminalSessionOptions
{
    /// <summary>
    /// The shell executable path. If null, auto-detects the default shell.
    /// </summary>
    /// <remarks>
    /// Auto-detection uses:
    /// <list type="bullet">
    ///   <item>Windows: %COMSPEC% or cmd.exe</item>
    ///   <item>macOS/Linux: $SHELL or /bin/bash</item>
    /// </list>
    /// </remarks>
    public string? ShellPath { get; init; }

    /// <summary>
    /// Arguments to pass to the shell. If null, uses shell-appropriate defaults.
    /// </summary>
    /// <remarks>
    /// Default arguments:
    /// <list type="bullet">
    ///   <item>PowerShell: -NoLogo</item>
    ///   <item>cmd.exe: (none)</item>
    ///   <item>bash/zsh: --login</item>
    /// </list>
    /// </remarks>
    public string[]? Arguments { get; init; }

    /// <summary>
    /// Initial working directory. If null, uses the current directory.
    /// </summary>
    public string? WorkingDirectory { get; init; }

    /// <summary>
    /// Initial terminal width in columns. Default is 80.
    /// </summary>
    /// <remarks>
    /// Common values: 80 (standard), 120 (wide), 132 (DEC VT).
    /// Must be at least 1.
    /// </remarks>
    public int Columns { get; init; } = 80;

    /// <summary>
    /// Initial terminal height in rows. Default is 24.
    /// </summary>
    /// <remarks>
    /// Common values: 24 (standard), 25 (DOS), 43/50 (EGA/VGA).
    /// Must be at least 1.
    /// </remarks>
    public int Rows { get; init; } = 24;

    /// <summary>
    /// Additional environment variables to set.
    /// </summary>
    /// <remarks>
    /// These are merged with inherited environment variables.
    /// Existing variables with the same name are overwritten.
    /// </remarks>
    public IReadOnlyDictionary<string, string>? Environment { get; init; }

    /// <summary>
    /// User-friendly name for the session (e.g., for tab titles).
    /// If null, uses the shell name.
    /// </summary>
    public string? Name { get; init; }

    /// <summary>
    /// Scrollback buffer size in lines. Default is 10000.
    /// </summary>
    /// <remarks>
    /// Larger values consume more memory but preserve more history.
    /// Set to 0 to disable scrollback (not recommended).
    /// </remarks>
    public int ScrollbackLines { get; init; } = 10000;

    /// <summary>
    /// Creates default options with auto-detected shell.
    /// </summary>
    public static TerminalSessionOptions Default => new();
}
```

### 5.2 TerminalSignal Enum

```csharp
// src/AIntern.Core/Interfaces/ITerminalService.cs (continued)

/// <summary>
/// Terminal signals that can be sent to a session.
/// </summary>
/// <remarks>
/// <para>Added in v0.5.1d.</para>
/// <para>
/// These map to POSIX signals on Unix-like systems and equivalent
/// operations on Windows.
/// </para>
/// </remarks>
public enum TerminalSignal
{
    /// <summary>
    /// Interrupt signal (SIGINT). Equivalent to Ctrl+C.
    /// Typically causes the foreground process to terminate.
    /// </summary>
    Interrupt,

    /// <summary>
    /// Terminate signal (SIGTERM). Requests graceful termination.
    /// Processes should clean up and exit.
    /// </summary>
    Terminate,

    /// <summary>
    /// Kill signal (SIGKILL). Forces immediate termination.
    /// Cannot be caught or ignored by the process.
    /// </summary>
    Kill,

    /// <summary>
    /// Suspend signal (SIGTSTP). Equivalent to Ctrl+Z.
    /// Suspends the foreground process.
    /// </summary>
    Suspend,

    /// <summary>
    /// Continue signal (SIGCONT). Resumes a suspended process.
    /// </summary>
    Continue,

    /// <summary>
    /// End of file. Writes Ctrl+D to input stream.
    /// Signals end of input to the shell.
    /// </summary>
    EndOfFile
}
```

### 5.3 Event Args Classes

```csharp
// src/AIntern.Core/Interfaces/ITerminalService.cs (continued)

/// <summary>
/// Event args for terminal output events.
/// </summary>
/// <remarks>Added in v0.5.1d.</remarks>
public sealed class TerminalOutputEventArgs : EventArgs
{
    /// <summary>
    /// The session that produced the output.
    /// </summary>
    public required Guid SessionId { get; init; }

    /// <summary>
    /// The raw output data received from the PTY.
    /// </summary>
    /// <remarks>
    /// This data has not been parsed and may contain ANSI escape sequences.
    /// For parsed content, access the session's terminal buffer.
    /// </remarks>
    public required string Data { get; init; }
}

/// <summary>
/// Event args for session lifecycle events.
/// </summary>
/// <remarks>Added in v0.5.1d.</remarks>
public sealed class TerminalSessionEventArgs : EventArgs
{
    /// <summary>
    /// The affected session.
    /// </summary>
    public required TerminalSession Session { get; init; }
}

/// <summary>
/// Event args for session state change events.
/// </summary>
/// <remarks>Added in v0.5.1d.</remarks>
public sealed class TerminalSessionStateEventArgs : EventArgs
{
    /// <summary>
    /// The affected session ID.
    /// </summary>
    public required Guid SessionId { get; init; }

    /// <summary>
    /// The previous state.
    /// </summary>
    public required TerminalSessionState OldState { get; init; }

    /// <summary>
    /// The new state.
    /// </summary>
    public required TerminalSessionState NewState { get; init; }

    /// <summary>
    /// Exit code if the session exited, null otherwise.
    /// </summary>
    public int? ExitCode { get; init; }
}

/// <summary>
/// Event args for terminal title change events.
/// </summary>
/// <remarks>Added in v0.5.1d.</remarks>
public sealed class TerminalTitleEventArgs : EventArgs
{
    /// <summary>
    /// The session whose title changed.
    /// </summary>
    public required Guid SessionId { get; init; }

    /// <summary>
    /// The new title.
    /// </summary>
    public required string Title { get; init; }
}
```

---

## 6. TerminalService Implementation

### Complete Implementation

```csharp
// src/AIntern.Services/Terminal/TerminalService.cs

using System.Collections.Concurrent;
using System.Runtime.InteropServices;
using AIntern.Core.Interfaces;
using AIntern.Core.Models;
using Microsoft.Extensions.Logging;
using Pty.Net;

namespace AIntern.Services.Terminal;

// ┌─────────────────────────────────────────────────────────────────────────┐
// │ TERMINAL SERVICE (v0.5.1d)                                              │
// │ PTY-based implementation of ITerminalService.                           │
// └─────────────────────────────────────────────────────────────────────────┘

/// <summary>
/// PTY-based implementation of the terminal service.
/// </summary>
/// <remarks>
/// <para>Added in v0.5.1d.</para>
/// <para>
/// Uses Pty.Net for cross-platform pseudo-terminal support:
/// <list type="bullet">
///   <item>Windows: ConPTY (Windows 10 1809+)</item>
///   <item>macOS/Linux: Native PTY via fork/exec</item>
/// </list>
/// </para>
/// </remarks>
public sealed class TerminalService : ITerminalService
{
    // ─────────────────────────────────────────────────────────────────────
    // Fields
    // ─────────────────────────────────────────────────────────────────────

    private readonly IShellDetectionService _shellDetection;
    private readonly ILogger<TerminalService> _logger;
    private readonly ConcurrentDictionary<Guid, TerminalSessionContext> _sessions = new();
    private readonly SemaphoreSlim _sessionLock = new(1, 1);
    private volatile bool _disposed;

    private Guid _activeSessionId = Guid.Empty;

    // ─────────────────────────────────────────────────────────────────────
    // Constructor
    // ─────────────────────────────────────────────────────────────────────

    /// <summary>
    /// Creates a new terminal service.
    /// </summary>
    /// <param name="shellDetection">Shell detection service.</param>
    /// <param name="logger">Logger instance.</param>
    public TerminalService(
        IShellDetectionService shellDetection,
        ILogger<TerminalService> logger)
    {
        _shellDetection = shellDetection ?? throw new ArgumentNullException(nameof(shellDetection));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    // ─────────────────────────────────────────────────────────────────────
    // ITerminalService Properties
    // ─────────────────────────────────────────────────────────────────────

    /// <inheritdoc />
    public IReadOnlyList<TerminalSession> Sessions
    {
        get
        {
            ThrowIfDisposed();
            return _sessions.Values
                .Select(ctx => ctx.Session)
                .ToList()
                .AsReadOnly();
        }
    }

    /// <inheritdoc />
    public TerminalSession? ActiveSession
    {
        get
        {
            ThrowIfDisposed();
            if (_activeSessionId == Guid.Empty)
                return null;

            return _sessions.TryGetValue(_activeSessionId, out var ctx)
                ? ctx.Session
                : null;
        }
    }

    // ─────────────────────────────────────────────────────────────────────
    // ITerminalService Events
    // ─────────────────────────────────────────────────────────────────────

    /// <inheritdoc />
    public event EventHandler<TerminalOutputEventArgs>? OutputReceived;

    /// <inheritdoc />
    public event EventHandler<TerminalSessionEventArgs>? SessionCreated;

    /// <inheritdoc />
    public event EventHandler<TerminalSessionEventArgs>? SessionClosed;

    /// <inheritdoc />
    public event EventHandler<TerminalSessionStateEventArgs>? SessionStateChanged;

    /// <inheritdoc />
    public event EventHandler<TerminalTitleEventArgs>? TitleChanged;

    // ─────────────────────────────────────────────────────────────────────
    // Session Lifecycle
    // ─────────────────────────────────────────────────────────────────────

    /// <inheritdoc />
    public async Task<TerminalSession> CreateSessionAsync(
        TerminalSessionOptions? options = null,
        CancellationToken cancellationToken = default)
    {
        ThrowIfDisposed();
        options ??= TerminalSessionOptions.Default;

        _logger.LogDebug("Creating new terminal session");

        await _sessionLock.WaitAsync(cancellationToken);
        try
        {
            // Detect shell if not specified
            var shellInfo = await _shellDetection.DetectDefaultShellAsync(cancellationToken);
            var shellPath = options.ShellPath ?? shellInfo.Path;
            var arguments = options.Arguments ?? shellInfo.DefaultArguments;

            _logger.LogDebug("Using shell: {ShellPath} with args: {Arguments}",
                shellPath, string.Join(" ", arguments ?? Array.Empty<string>()));

            // Create session model
            var sessionId = Guid.NewGuid();
            var session = new TerminalSession
            {
                Id = sessionId,
                Name = options.Name ?? Path.GetFileNameWithoutExtension(shellPath),
                ShellPath = shellPath,
                WorkingDirectory = options.WorkingDirectory ?? Environment.CurrentDirectory,
                Columns = Math.Max(1, options.Columns),
                Rows = Math.Max(1, options.Rows),
                State = TerminalSessionState.Starting,
                CreatedAt = DateTimeOffset.UtcNow
            };

            // Prepare environment
            var environment = BuildEnvironment(options.Environment);

            // Create terminal buffer
            var buffer = new TerminalBuffer(
                session.Columns,
                session.Rows,
                options.ScrollbackLines);

            // Create ANSI parser with buffer callbacks
            var parser = new AnsiParser();
            ConfigureParserCallbacks(parser, buffer, sessionId);

            // Spawn PTY process
            var ptyOptions = new PtyOptions
            {
                Name = session.Name,
                App = shellPath,
                CommandLine = arguments ?? Array.Empty<string>(),
                Cwd = session.WorkingDirectory,
                Cols = session.Columns,
                Rows = session.Rows,
                Environment = environment
            };

            var pty = await PtyProvider.SpawnAsync(ptyOptions, cancellationToken);

            // Create cancellation token source for output reading
            var outputCts = new CancellationTokenSource();

            // Create context
            var context = new TerminalSessionContext(
                session,
                pty,
                buffer,
                parser,
                outputCts);

            _sessions[sessionId] = context;

            // Update state to running
            UpdateSessionState(context, TerminalSessionState.Running);

            // Start output reading loop
            _ = ReadOutputLoopAsync(context, outputCts.Token);

            // Set as active if first session
            if (_activeSessionId == Guid.Empty)
            {
                _activeSessionId = sessionId;
            }

            _logger.LogInformation("Terminal session created: {SessionId}", sessionId);
            SessionCreated?.Invoke(this, new TerminalSessionEventArgs { Session = session });

            return session;
        }
        finally
        {
            _sessionLock.Release();
        }
    }

    /// <inheritdoc />
    public async Task<bool> CloseSessionAsync(
        Guid sessionId,
        CancellationToken cancellationToken = default)
    {
        ThrowIfDisposed();

        if (!_sessions.TryGetValue(sessionId, out var context))
        {
            _logger.LogWarning("Attempted to close non-existent session: {SessionId}", sessionId);
            return false;
        }

        _logger.LogDebug("Closing terminal session: {SessionId}", sessionId);

        try
        {
            // Update state
            UpdateSessionState(context, TerminalSessionState.Closing);

            // Cancel output reading
            await context.OutputCts.CancelAsync();

            // Terminate the process
            await TerminateProcessAsync(context.Pty, cancellationToken);

            // Remove from collection
            _sessions.TryRemove(sessionId, out _);

            // Update active session if needed
            if (_activeSessionId == sessionId)
            {
                _activeSessionId = _sessions.Keys.FirstOrDefault();
            }

            // Dispose context
            context.Dispose();

            _logger.LogInformation("Terminal session closed: {SessionId}", sessionId);
            SessionClosed?.Invoke(this, new TerminalSessionEventArgs { Session = context.Session });

            return true;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error closing terminal session: {SessionId}", sessionId);
            throw;
        }
    }

    // ─────────────────────────────────────────────────────────────────────
    // I/O Operations
    // ─────────────────────────────────────────────────────────────────────

    /// <inheritdoc />
    public async Task<bool> WriteInputAsync(
        Guid sessionId,
        string data,
        CancellationToken cancellationToken = default)
    {
        ThrowIfDisposed();

        if (!_sessions.TryGetValue(sessionId, out var context))
        {
            return false;
        }

        if (context.Session.State != TerminalSessionState.Running)
        {
            _logger.LogDebug("Cannot write to session not in Running state: {SessionId}", sessionId);
            return false;
        }

        try
        {
            var bytes = System.Text.Encoding.UTF8.GetBytes(data);
            await context.Pty.WriterStream.WriteAsync(bytes, cancellationToken);
            await context.Pty.WriterStream.FlushAsync(cancellationToken);
            return true;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error writing to terminal session: {SessionId}", sessionId);
            return false;
        }
    }

    /// <inheritdoc />
    public async Task<bool> ResizeAsync(
        Guid sessionId,
        int columns,
        int rows,
        CancellationToken cancellationToken = default)
    {
        ThrowIfDisposed();

        if (!_sessions.TryGetValue(sessionId, out var context))
        {
            return false;
        }

        if (columns < 1 || rows < 1)
        {
            _logger.LogWarning("Invalid resize dimensions: {Columns}x{Rows}", columns, rows);
            return false;
        }

        try
        {
            context.Pty.Resize(columns, rows);

            // Update session model
            context.Session = context.Session with
            {
                Columns = columns,
                Rows = rows
            };

            // Resize buffer
            context.Buffer.Resize(columns, rows);

            _logger.LogDebug("Terminal resized to {Columns}x{Rows}: {SessionId}",
                columns, rows, sessionId);

            return true;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error resizing terminal: {SessionId}", sessionId);
            return false;
        }
    }

    /// <inheritdoc />
    public async Task<bool> SendSignalAsync(
        Guid sessionId,
        TerminalSignal signal,
        CancellationToken cancellationToken = default)
    {
        ThrowIfDisposed();

        if (!_sessions.TryGetValue(sessionId, out var context))
        {
            return false;
        }

        try
        {
            switch (signal)
            {
                case TerminalSignal.Interrupt:
                    // Send Ctrl+C
                    await WriteInputAsync(sessionId, "\x03", cancellationToken);
                    break;

                case TerminalSignal.Terminate:
                    context.Pty.Kill();
                    break;

                case TerminalSignal.Kill:
                    context.Pty.Kill();
                    break;

                case TerminalSignal.Suspend:
                    // Send Ctrl+Z
                    await WriteInputAsync(sessionId, "\x1a", cancellationToken);
                    break;

                case TerminalSignal.Continue:
                    // Platform-specific; best effort via shell command
                    await WriteInputAsync(sessionId, "fg\n", cancellationToken);
                    break;

                case TerminalSignal.EndOfFile:
                    // Send Ctrl+D
                    await WriteInputAsync(sessionId, "\x04", cancellationToken);
                    break;

                default:
                    _logger.LogWarning("Unknown signal: {Signal}", signal);
                    return false;
            }

            _logger.LogDebug("Signal {Signal} sent to session: {SessionId}", signal, sessionId);
            return true;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error sending signal to terminal: {SessionId}", sessionId);
            return false;
        }
    }

    // ─────────────────────────────────────────────────────────────────────
    // Buffer Access
    // ─────────────────────────────────────────────────────────────────────

    /// <inheritdoc />
    public TerminalBuffer? GetBuffer(Guid sessionId)
    {
        ThrowIfDisposed();
        return _sessions.TryGetValue(sessionId, out var context)
            ? context.Buffer
            : null;
    }

    // ─────────────────────────────────────────────────────────────────────
    // Convenience Methods
    // ─────────────────────────────────────────────────────────────────────

    /// <inheritdoc />
    public async Task<bool> ChangeDirectoryAsync(
        Guid sessionId,
        string path,
        CancellationToken cancellationToken = default)
    {
        ThrowIfDisposed();

        // Quote path to handle spaces
        var quotedPath = path.Contains(' ') ? $"\"{path}\"" : path;
        var command = $"cd {quotedPath}\n";

        return await WriteInputAsync(sessionId, command, cancellationToken);
    }

    /// <inheritdoc />
    public async Task<bool> ExecuteCommandAsync(
        Guid sessionId,
        string command,
        CancellationToken cancellationToken = default)
    {
        ThrowIfDisposed();

        var commandWithNewline = command.EndsWith('\n') ? command : command + "\n";
        return await WriteInputAsync(sessionId, commandWithNewline, cancellationToken);
    }

    // ─────────────────────────────────────────────────────────────────────
    // IAsyncDisposable
    // ─────────────────────────────────────────────────────────────────────

    /// <inheritdoc />
    public async ValueTask DisposeAsync()
    {
        if (_disposed)
            return;

        _disposed = true;
        _logger.LogDebug("Disposing terminal service");

        // Close all sessions
        var sessionIds = _sessions.Keys.ToList();
        foreach (var sessionId in sessionIds)
        {
            try
            {
                await CloseSessionAsync(sessionId);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error closing session during disposal: {SessionId}", sessionId);
            }
        }

        _sessionLock.Dispose();
        _logger.LogInformation("Terminal service disposed");
    }

    // ─────────────────────────────────────────────────────────────────────
    // Private Methods
    // ─────────────────────────────────────────────────────────────────────

    private void ThrowIfDisposed()
    {
        if (_disposed)
        {
            throw new ObjectDisposedException(nameof(TerminalService));
        }
    }

    private Dictionary<string, string> BuildEnvironment(
        IReadOnlyDictionary<string, string>? additionalEnv)
    {
        var env = new Dictionary<string, string>();

        // Inherit current environment
        foreach (var entry in Environment.GetEnvironmentVariables())
        {
            if (entry is System.Collections.DictionaryEntry de &&
                de.Key is string key &&
                de.Value is string value)
            {
                env[key] = value;
            }
        }

        // Set terminal-specific variables
        env["TERM"] = "xterm-256color";
        env["COLORTERM"] = "truecolor";

        // Ensure proper locale
        if (!env.ContainsKey("LANG"))
        {
            env["LANG"] = "en_US.UTF-8";
        }

        // Merge additional environment
        if (additionalEnv != null)
        {
            foreach (var (key, value) in additionalEnv)
            {
                env[key] = value;
            }
        }

        return env;
    }

    private void ConfigureParserCallbacks(
        AnsiParser parser,
        TerminalBuffer buffer,
        Guid sessionId)
    {
        parser.OnPrint += text => buffer.Write(text);
        parser.OnExecute += code => HandleControlCode(buffer, code);
        parser.OnCsiDispatch += (parameters, intermediates, final) =>
            HandleCsiSequence(buffer, parameters, intermediates, final);
        parser.OnOscDispatch += (command, data) =>
            HandleOscSequence(sessionId, command, data);
        parser.OnEscDispatch += (intermediates, final) =>
            HandleEscSequence(buffer, intermediates, final);
    }

    private void HandleControlCode(TerminalBuffer buffer, byte code)
    {
        switch (code)
        {
            case 0x07: // BEL
                // Could trigger bell notification
                break;
            case 0x08: // BS
                buffer.Backspace();
                break;
            case 0x09: // HT
                buffer.Tab();
                break;
            case 0x0A: // LF
                buffer.LineFeed();
                break;
            case 0x0D: // CR
                buffer.CarriageReturn();
                break;
        }
    }

    private void HandleCsiSequence(
        TerminalBuffer buffer,
        int[] parameters,
        byte[] intermediates,
        byte final)
    {
        // Delegate to buffer's CSI handler
        buffer.HandleCsiSequence(parameters, intermediates, final);
    }

    private void HandleOscSequence(Guid sessionId, int command, string data)
    {
        switch (command)
        {
            case 0: // Set icon name and window title
            case 2: // Set window title
                TitleChanged?.Invoke(this, new TerminalTitleEventArgs
                {
                    SessionId = sessionId,
                    Title = data
                });
                break;
        }
    }

    private void HandleEscSequence(
        TerminalBuffer buffer,
        byte[] intermediates,
        byte final)
    {
        // Delegate to buffer's ESC handler
        buffer.HandleEscSequence(intermediates, final);
    }

    private async Task ReadOutputLoopAsync(
        TerminalSessionContext context,
        CancellationToken cancellationToken)
    {
        var buffer = new byte[4096];
        var sessionId = context.Session.Id;

        try
        {
            while (!cancellationToken.IsCancellationRequested)
            {
                var bytesRead = await context.Pty.ReaderStream.ReadAsync(
                    buffer, cancellationToken);

                if (bytesRead == 0)
                {
                    // End of stream - process exited
                    _logger.LogDebug("PTY stream closed for session: {SessionId}", sessionId);
                    break;
                }

                var data = System.Text.Encoding.UTF8.GetString(buffer, 0, bytesRead);

                // Parse through ANSI parser (updates buffer via callbacks)
                context.Parser.Parse(data);

                // Notify listeners
                OutputReceived?.Invoke(this, new TerminalOutputEventArgs
                {
                    SessionId = sessionId,
                    Data = data
                });
            }
        }
        catch (OperationCanceledException)
        {
            // Expected when session is closed
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error reading terminal output: {SessionId}", sessionId);
            UpdateSessionState(context, TerminalSessionState.Error);
        }

        // Check exit code
        if (context.Pty.ExitCode.HasValue)
        {
            var exitCode = context.Pty.ExitCode.Value;
            _logger.LogDebug("Terminal process exited with code {ExitCode}: {SessionId}",
                exitCode, sessionId);

            UpdateSessionState(context, TerminalSessionState.Exited, exitCode);
        }
    }

    private void UpdateSessionState(
        TerminalSessionContext context,
        TerminalSessionState newState,
        int? exitCode = null)
    {
        var oldState = context.Session.State;
        if (oldState == newState)
            return;

        context.Session = context.Session with
        {
            State = newState,
            ExitCode = exitCode
        };

        SessionStateChanged?.Invoke(this, new TerminalSessionStateEventArgs
        {
            SessionId = context.Session.Id,
            OldState = oldState,
            NewState = newState,
            ExitCode = exitCode
        });
    }

    private async Task TerminateProcessAsync(
        IPtyConnection pty,
        CancellationToken cancellationToken)
    {
        if (pty.ExitCode.HasValue)
            return;

        try
        {
            // Try graceful termination first
            pty.Kill();

            // Wait for process to exit
            using var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(TimeSpan.FromSeconds(5));

            try
            {
                await pty.WaitForExitAsync(cts.Token);
            }
            catch (OperationCanceledException)
            {
                // Force kill if graceful termination times out
                _logger.LogWarning("Process did not exit gracefully, forcing termination");
                pty.Kill();
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error terminating PTY process");
        }
    }

    // ─────────────────────────────────────────────────────────────────────
    // Nested Types
    // ─────────────────────────────────────────────────────────────────────

    /// <summary>
    /// Internal context for a terminal session, holding all related resources.
    /// </summary>
    private sealed class TerminalSessionContext : IDisposable
    {
        public TerminalSession Session { get; set; }
        public IPtyConnection Pty { get; }
        public TerminalBuffer Buffer { get; }
        public AnsiParser Parser { get; }
        public CancellationTokenSource OutputCts { get; }

        public TerminalSessionContext(
            TerminalSession session,
            IPtyConnection pty,
            TerminalBuffer buffer,
            AnsiParser parser,
            CancellationTokenSource outputCts)
        {
            Session = session;
            Pty = pty;
            Buffer = buffer;
            Parser = parser;
            OutputCts = outputCts;
        }

        public void Dispose()
        {
            OutputCts.Dispose();
            Pty.Dispose();
        }
    }
}
```

---

## 7. Session Lifecycle Management

### State Machine

```
┌─────────────┐
│  Starting   │ ← CreateSessionAsync() called
└──────┬──────┘
       │ PTY spawned successfully
       ▼
┌─────────────┐
│   Running   │ ← Normal operation
└──────┬──────┘
       │
       ├───────────────────────┬───────────────────────┐
       │ Process exited        │ Error occurred        │ CloseSessionAsync()
       ▼                       ▼                       ▼
┌─────────────┐         ┌─────────────┐         ┌─────────────┐
│   Exited    │         │    Error    │         │   Closing   │
└──────┬──────┘         └──────┬──────┘         └──────┬──────┘
       │                       │                       │
       └───────────────────────┴───────────────────────┘
                               │
                               ▼
                        Session removed from
                        _sessions dictionary
```

### State Transition Rules

| Current State | Valid Transitions | Trigger |
|--------------|-------------------|---------|
| Starting | Running, Error | PTY spawn success/failure |
| Running | Exited, Error, Closing | Process exit, error, close request |
| Exited | Closing | Close request |
| Error | Closing | Close request |
| Closing | (removed) | Cleanup complete |

### Cleanup Sequence

1. **CloseSessionAsync called**
2. State transitions to `Closing`
3. Output reading loop cancelled via `CancellationTokenSource`
4. Process termination:
   - Send SIGTERM (or Windows equivalent)
   - Wait up to 5 seconds for graceful exit
   - Force kill if timeout exceeded
5. Session removed from `_sessions` dictionary
6. Context disposed (releases PTY and CTS)
7. `SessionClosed` event raised

---

## 8. PTY Integration

### Pty.Net Configuration

The service uses `Pty.Net` for cross-platform PTY support with the following configuration:

```csharp
var ptyOptions = new PtyOptions
{
    Name = session.Name,              // Process name for display
    App = shellPath,                  // Shell executable path
    CommandLine = arguments,          // Shell arguments
    Cwd = session.WorkingDirectory,   // Working directory
    Cols = session.Columns,           // Terminal width
    Rows = session.Rows,              // Terminal height
    Environment = environment         // Environment variables
};

var pty = await PtyProvider.SpawnAsync(ptyOptions, cancellationToken);
```

### Platform Behavior

| Platform | PTY Implementation | Notes |
|----------|-------------------|-------|
| Windows 10+ | ConPTY | Requires Windows 10 1809 or later |
| macOS | Native PTY | Uses `forkpty()` |
| Linux | Native PTY | Uses `forkpty()` |

### Environment Variables

The service sets these terminal environment variables:

| Variable | Value | Purpose |
|----------|-------|---------|
| `TERM` | `xterm-256color` | Terminal type for capability detection |
| `COLORTERM` | `truecolor` | Indicates 24-bit color support |
| `LANG` | `en_US.UTF-8` (if unset) | Locale for Unicode support |

---

## 9. Event System

### Event Descriptions

| Event | When Raised | Thread |
|-------|------------|--------|
| `OutputReceived` | New data from shell | Background |
| `SessionCreated` | After session fully initialized | Caller |
| `SessionClosed` | After session cleanup complete | Caller |
| `SessionStateChanged` | State transition | Varies |
| `TitleChanged` | OSC title escape sequence | Background |

### Thread Safety for Event Handlers

Event handlers may be called from background threads (especially `OutputReceived` and `TitleChanged`). UI consumers must marshal to the UI thread:

```csharp
// In Avalonia ViewModel
_terminalService.OutputReceived += (sender, args) =>
{
    Dispatcher.UIThread.Post(() =>
    {
        // Update UI here
    });
};
```

### Event Ordering Guarantees

1. `SessionCreated` always fires before any `OutputReceived` for that session
2. `SessionStateChanged` reflects actual state at time of firing
3. `SessionClosed` is always the last event for a session

---

## 10. Thread Safety

### Concurrent Access Patterns

The service is designed for thread-safe access from multiple threads:

| Component | Thread Safety Mechanism |
|-----------|------------------------|
| `_sessions` | `ConcurrentDictionary<Guid, Context>` |
| `_sessionLock` | `SemaphoreSlim` for session creation |
| `_disposed` | `volatile bool` |
| Session state | Updated via `context.Session = ...` |

### Lock Ordering

To prevent deadlocks:
1. `_sessionLock` is only held during `CreateSessionAsync`
2. No locks are held when raising events
3. Individual session operations don't require cross-session locks

### Race Condition Mitigations

| Scenario | Mitigation |
|----------|-----------|
| Write during close | State check before write |
| Double close | `TryRemove` returns false for second call |
| Event after dispose | `ThrowIfDisposed()` checks |

---

## 11. Error Handling

### Exception Strategy

| Operation | Behavior |
|-----------|----------|
| CreateSessionAsync | Throws on failure (shell not found, PTY spawn failure) |
| CloseSessionAsync | Returns false if session not found, throws on cleanup error |
| WriteInputAsync | Returns false on failure, logs error |
| ResizeAsync | Returns false on failure, logs error |
| SendSignalAsync | Returns false on failure, logs error |

### Error States

Sessions transition to `Error` state when:
- Output reading encounters an unrecoverable error
- PTY stream closes unexpectedly without exit code

### Logging

All operations are logged at appropriate levels:
- **Debug**: Normal operations (session create/close, resize, signal)
- **Information**: Significant events (service disposal, session lifecycle)
- **Warning**: Non-critical issues (unknown signals, invalid dimensions)
- **Error**: Failures (PTY errors, cleanup failures)

---

## 12. Testing Strategy

### Unit Tests

```csharp
// tests/AIntern.Services.Tests/Terminal/TerminalServiceTests.cs

public class TerminalServiceTests
{
    // Session Lifecycle Tests
    [Fact]
    public async Task CreateSessionAsync_WithDefaultOptions_CreatesRunningSession();

    [Fact]
    public async Task CreateSessionAsync_WithCustomOptions_UsesProvidedValues();

    [Fact]
    public async Task CloseSessionAsync_ExistingSession_ReturnsTrue();

    [Fact]
    public async Task CloseSessionAsync_NonExistentSession_ReturnsFalse();

    [Fact]
    public async Task Sessions_ReturnsActiveSessionsList();

    [Fact]
    public async Task ActiveSession_FirstSession_BecomesActive();

    // I/O Tests
    [Fact]
    public async Task WriteInputAsync_ValidSession_WritesToPty();

    [Fact]
    public async Task WriteInputAsync_ClosedSession_ReturnsFalse();

    [Fact]
    public async Task ResizeAsync_ValidDimensions_UpdatesSession();

    [Fact]
    public async Task ResizeAsync_InvalidDimensions_ReturnsFalse();

    // Signal Tests
    [Fact]
    public async Task SendSignalAsync_Interrupt_SendsCtrlC();

    [Fact]
    public async Task SendSignalAsync_EndOfFile_SendsCtrlD();

    // Event Tests
    [Fact]
    public async Task CreateSessionAsync_RaisesSessionCreatedEvent();

    [Fact]
    public async Task CloseSessionAsync_RaisesSessionClosedEvent();

    [Fact]
    public async Task OutputReceived_RaisedOnPtyOutput();

    // Disposal Tests
    [Fact]
    public async Task DisposeAsync_ClosesAllSessions();

    [Fact]
    public async Task OperationsAfterDispose_ThrowObjectDisposedException();

    // Buffer Tests
    [Fact]
    public async Task GetBuffer_ExistingSession_ReturnsBuffer();

    [Fact]
    public async Task GetBuffer_NonExistentSession_ReturnsNull();
}
```

### Integration Tests

```csharp
public class TerminalServiceIntegrationTests
{
    [Fact]
    [Trait("Category", "Integration")]
    public async Task CreateSession_SpawnsActualShell();

    [Fact]
    [Trait("Category", "Integration")]
    public async Task ExecuteCommand_ProducesOutput();

    [Fact]
    [Trait("Category", "Integration")]
    public async Task Resize_NotifiesShell();
}
```

### Mock Dependencies

```csharp
public class MockShellDetectionService : IShellDetectionService
{
    public Task<ShellInfo> DetectDefaultShellAsync(CancellationToken ct = default)
    {
        return Task.FromResult(new ShellInfo
        {
            Path = RuntimeInformation.IsOSPlatform(OSPlatform.Windows)
                ? "cmd.exe"
                : "/bin/bash",
            ShellType = ShellType.Bash,
            DefaultArguments = Array.Empty<string>()
        });
    }
}
```

---

## 13. Integration Points

### Dependency on IShellDetectionService (v0.5.1e)

The TerminalService depends on `IShellDetectionService` for auto-detecting the user's default shell. This service is defined in v0.5.1e.

**Interface Contract Expected:**

```csharp
public interface IShellDetectionService
{
    Task<ShellInfo> DetectDefaultShellAsync(CancellationToken cancellationToken = default);
    Task<IReadOnlyList<ShellInfo>> GetAvailableShellsAsync(CancellationToken cancellationToken = default);
}

public record ShellInfo
{
    public required string Path { get; init; }
    public required ShellType ShellType { get; init; }
    public string[]? DefaultArguments { get; init; }
    public string? Version { get; init; }
}
```

### Integration with AnsiParser (v0.5.1c)

The parser is configured with callbacks that update the terminal buffer:

```csharp
parser.OnPrint += text => buffer.Write(text);
parser.OnExecute += code => HandleControlCode(buffer, code);
parser.OnCsiDispatch += (params, inter, final) => HandleCsiSequence(buffer, params, inter, final);
parser.OnOscDispatch += (cmd, data) => HandleOscSequence(sessionId, cmd, data);
parser.OnEscDispatch += (inter, final) => HandleEscSequence(buffer, inter, final);
```

### Integration with TerminalBuffer (v0.5.1b)

The buffer receives parsed commands and maintains terminal state:

```csharp
// Buffer methods called by service
buffer.Write(text);           // Print characters
buffer.Backspace();           // BS control code
buffer.Tab();                 // HT control code
buffer.LineFeed();            // LF control code
buffer.CarriageReturn();      // CR control code
buffer.HandleCsiSequence(...); // CSI sequences
buffer.HandleEscSequence(...); // ESC sequences
buffer.Resize(cols, rows);    // Dimension changes
```

### DI Registration

```csharp
// In AIntern.App/ServiceConfiguration.cs

services.AddSingleton<ITerminalService, TerminalService>();
```

---

## 14. Implementation Checklist

### Files to Create

- [ ] `src/AIntern.Core/Interfaces/ITerminalService.cs`
  - [ ] ITerminalService interface
  - [ ] TerminalSessionOptions record
  - [ ] TerminalSignal enum
  - [ ] TerminalOutputEventArgs class
  - [ ] TerminalSessionEventArgs class
  - [ ] TerminalSessionStateEventArgs class
  - [ ] TerminalTitleEventArgs class

- [ ] `src/AIntern.Services/Terminal/TerminalService.cs`
  - [ ] TerminalService class
  - [ ] TerminalSessionContext nested class
  - [ ] All interface method implementations
  - [ ] Event raising logic
  - [ ] Output reading loop
  - [ ] Process termination logic

### Tests to Create

- [ ] `tests/AIntern.Services.Tests/Terminal/TerminalServiceTests.cs`
  - [ ] Session lifecycle tests
  - [ ] I/O operation tests
  - [ ] Signal handling tests
  - [ ] Event tests
  - [ ] Disposal tests

### Dependencies Required

- [x] Pty.Net package (added in v0.5.1a)
- [ ] IShellDetectionService (v0.5.1e)
- [ ] AnsiParser (v0.5.1c)
- [ ] TerminalBuffer, TerminalSession (v0.5.1b)

### Verification Steps

1. Build solution and verify no compilation errors
2. Run unit tests and verify all pass
3. Manual testing:
   - Create terminal session
   - Type commands and verify output
   - Test resize behavior
   - Test signal sending (Ctrl+C)
   - Close session and verify cleanup

---

## Version History

| Version | Date | Changes |
|---------|------|---------|
| v0.5.1d | TBD | Initial specification |

---

## References

- [Pty.Net Documentation](https://github.com/microsoft/Pty.Net)
- [Windows ConPTY](https://docs.microsoft.com/en-us/windows/console/creating-a-pseudoconsole-session)
- [POSIX PTY](https://man7.org/linux/man-pages/man7/pty.7.html)
- [v0.5.0-integrated-terminal.md](./v0.5.0-integrated-terminal.md) – Parent architecture
- [v0.5.1-terminal-foundation.md](./v0.5.1-terminal-foundation.md) – Version scope
