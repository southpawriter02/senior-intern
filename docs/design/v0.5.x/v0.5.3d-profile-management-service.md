# Design Specification: AIntern v0.5.3d "Profile Management Service"

## Overview

**Version**: v0.5.3d
**Parent**: v0.5.3 Shell Integration
**Focus**: CRUD operations for profiles, persistence, default profile handling, built-in profile generation

### Purpose

This sub-version creates a comprehensive profile management service that enables:
1. CRUD operations for shell profiles (Create, Read, Update, Delete)
2. Persistent storage of profiles to disk (JSON format)
3. Default profile selection and management
4. Automatic built-in profile generation from detected shells
5. Profile import/export functionality
6. Effective settings resolution (profile overrides + app defaults)

### Dependencies

**From v0.5.3a (Shell Detection)**:
- `IShellDetectionService` - Discovers available shells, validates paths
- `ShellInfo` - Shell metadata for built-in profile generation

**From v0.5.3c (Shell Profile Models)**:
- `ShellProfile` - Profile model with Clone() method
- `ShellProfileDefaults` - Effective settings container
- `ShellType`, `TerminalCursorStyle`, `TerminalBellStyle`, `ProfileCloseOnExit`

**From Existing Codebase**:
- `ISettingsService` - App settings persistence
- `AppSettings` - Contains DefaultShellProfileId

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                v0.5.3d Profile Management Service Architecture                │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                        Interface Layer                                   │ │
│  │  src/AIntern.Core/Interfaces/                                           │ │
│  ├─────────────────────────────────────────────────────────────────────────┤ │
│  │  IShellProfileService                                                    │ │
│  │  ├── Events:                                                            │ │
│  │  │   └── ProfilesChanged: EventHandler<ProfilesChangedEventArgs>        │ │
│  │  ├── Read Operations:                                                   │ │
│  │  │   ├── GetAllProfilesAsync() → IReadOnlyList<ShellProfile>            │ │
│  │  │   ├── GetVisibleProfilesAsync() → IReadOnlyList<ShellProfile>        │ │
│  │  │   ├── GetProfileAsync(id) → ShellProfile?                            │ │
│  │  │   └── GetDefaultProfileAsync() → ShellProfile                        │ │
│  │  ├── Write Operations:                                                  │ │
│  │  │   ├── CreateProfileAsync(profile) → ShellProfile                     │ │
│  │  │   ├── UpdateProfileAsync(profile) → void                             │ │
│  │  │   ├── DeleteProfileAsync(id) → void                                  │ │
│  │  │   ├── SetDefaultProfileAsync(id) → void                              │ │
│  │  │   └── DuplicateProfileAsync(id) → ShellProfile                       │ │
│  │  ├── Bulk Operations:                                                   │ │
│  │  │   ├── ResetToDefaultsAsync() → void                                  │ │
│  │  │   ├── ImportProfilesAsync(json) → int                                │ │
│  │  │   └── ExportProfilesAsync(ids?) → string                             │ │
│  │  └── Utility:                                                           │ │
│  │      └── GetEffectiveSettings(profile) → ShellProfileDefaults           │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                        Event Models                                      │ │
│  │  src/AIntern.Core/Models/Terminal/                                      │ │
│  ├─────────────────────────────────────────────────────────────────────────┤ │
│  │  ProfilesChangedEventArgs              ProfileChangeType (enum)         │ │
│  │  ├── ChangeType: ProfileChangeType     ├── Added                        │ │
│  │  ├── ProfileId: Guid?                  ├── Updated                      │ │
│  │  └── Profile: ShellProfile?            ├── Deleted                      │ │
│  │                                         ├── DefaultChanged              │ │
│  │                                         └── Reset                        │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                     Implementation Layer                                 │ │
│  │  src/AIntern.Services/Terminal/                                         │ │
│  ├─────────────────────────────────────────────────────────────────────────┤ │
│  │  ShellProfileService                                                     │ │
│  │  ├── Dependencies:                                                      │ │
│  │  │   ├── IShellDetectionService                                         │ │
│  │  │   ├── ISettingsService                                               │ │
│  │  │   └── ILogger<ShellProfileService>                                   │ │
│  │  ├── State:                                                             │ │
│  │  │   ├── _profiles: List<ShellProfile>                                  │ │
│  │  │   ├── _profilesPath: string (JSON file location)                    │ │
│  │  │   ├── _lock: SemaphoreSlim (thread safety)                          │ │
│  │  │   └── _initialized: bool (lazy initialization)                      │ │
│  │  └── Lifecycle:                                                         │ │
│  │      ├── EnsureInitializedAsync() - Lazy load                          │ │
│  │      ├── LoadProfilesAsync() - Read from disk                          │ │
│  │      ├── SaveProfilesAsync() - Write to disk                           │ │
│  │      └── GenerateBuiltInProfilesAsync() - Auto-detect shells           │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Profile Persistence

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                         Profile Storage Location                              │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Windows:   %APPDATA%\AIntern\shell-profiles.json                           │
│  macOS:     ~/Library/Application Support/AIntern/shell-profiles.json       │
│  Linux:     ~/.config/AIntern/shell-profiles.json                           │
│                                                                              │
│  Resolution: Environment.SpecialFolder.ApplicationData + "AIntern"           │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────────────────────┐
│                         Profile Initialization Flow                           │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────┐     ┌──────────────────┐     ┌──────────────────────┐  │
│  │ First API Call  │────▶│ EnsureInitialized│────▶│  LoadProfilesAsync   │  │
│  └─────────────────┘     └──────────────────┘     └──────────┬───────────┘  │
│                                                               │              │
│                          ┌────────────────────────────────────┘              │
│                          ▼                                                   │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  File Exists?                                                          │  │
│  │  ├── YES: Deserialize JSON → _profiles                                │  │
│  │  └── NO:  _profiles = empty list                                      │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                          │                                                   │
│                          ▼                                                   │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  GenerateBuiltInProfilesAsync()                                        │  │
│  │  ├── Call IShellDetectionService.GetAvailableShellsAsync()            │  │
│  │  ├── For each ShellInfo not already in _profiles:                     │  │
│  │  │   └── Create ShellProfile with IsBuiltIn = true                    │  │
│  │  └── Ensure at least one profile is marked IsDefault                  │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Default Profile Resolution

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                      Default Profile Resolution Order                         │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  GetDefaultProfileAsync() resolves in this priority:                         │
│                                                                              │
│  1. AppSettings.DefaultShellProfileId (if set and profile exists)           │
│     ↓ (fallback)                                                            │
│  2. First profile with IsDefault = true                                      │
│     ↓ (fallback)                                                            │
│  3. First profile in the list                                                │
│                                                                              │
│  This ensures a default is always returned, never null.                      │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Profile Validation Rules

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                          Profile Validation Rules                             │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  CreateProfileAsync() Validation:                                            │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  ✓ ShellPath must not be empty                                        │  │
│  │  ✓ ShellPath must pass IShellDetectionService.ValidateShellPath()    │  │
│  │  ✓ If ShellType == Unknown, auto-detect via DetectShellType()        │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                                                              │
│  UpdateProfileAsync() Validation:                                            │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  ✓ Profile with matching ID must exist                                │  │
│  │  ✗ Built-in profiles (IsBuiltIn = true) cannot be modified           │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                                                              │
│  DeleteProfileAsync() Validation:                                            │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  ✗ Built-in profiles cannot be deleted                                │  │
│  │  ✓ If deleted profile was default, clear AppSettings.DefaultShellId  │  │
│  │  ✓ Non-existent profile IDs are silently ignored                     │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Thread Safety

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                          Thread Safety Strategy                               │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  SemaphoreSlim _lock = new(1, 1)                                             │
│                                                                              │
│  Operations requiring lock:                                                  │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  • CreateProfileAsync    (modifies _profiles, writes to disk)         │  │
│  │  • UpdateProfileAsync    (modifies _profiles, writes to disk)         │  │
│  │  • DeleteProfileAsync    (modifies _profiles, writes to disk)         │  │
│  │  • SetDefaultProfileAsync (modifies _profiles, writes to disk)        │  │
│  │  • ResetToDefaultsAsync  (replaces _profiles, writes to disk)         │  │
│  │  • ImportProfilesAsync   (modifies _profiles, writes to disk)         │  │
│  │  • EnsureInitializedAsync (double-checked locking)                    │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                                                              │
│  Read operations (no lock after initialization):                             │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  • GetAllProfilesAsync      → Returns AsReadOnly()                    │  │
│  │  • GetVisibleProfilesAsync  → Returns filtered AsReadOnly()           │  │
│  │  • GetProfileAsync          → Returns FirstOrDefault()                │  │
│  │  • GetDefaultProfileAsync   → Read-only resolution                    │  │
│  │  • ExportProfilesAsync      → Serializes existing profiles            │  │
│  │  • GetEffectiveSettings     → Computes from profile + settings        │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Specifications

### 1. ProfileChangeType.cs

**Location**: `src/AIntern.Core/Models/Terminal/ProfileChangeType.cs`

```csharp
namespace AIntern.Core.Models.Terminal;

/// <summary>
/// Type of profile change event.
/// </summary>
public enum ProfileChangeType
{
    /// <summary>Profile was created.</summary>
    Added,

    /// <summary>Profile was modified.</summary>
    Updated,

    /// <summary>Profile was deleted.</summary>
    Deleted,

    /// <summary>Default profile selection changed.</summary>
    DefaultChanged,

    /// <summary>All profiles were reset to defaults.</summary>
    Reset
}
```

### 2. ProfilesChangedEventArgs.cs

**Location**: `src/AIntern.Core/Models/Terminal/ProfilesChangedEventArgs.cs`

```csharp
namespace AIntern.Core.Models.Terminal;

/// <summary>
/// Event arguments for profile changes.
/// </summary>
public sealed class ProfilesChangedEventArgs : EventArgs
{
    /// <summary>Type of change that occurred.</summary>
    public ProfileChangeType ChangeType { get; init; }

    /// <summary>ID of the affected profile (null for Reset).</summary>
    public Guid? ProfileId { get; init; }

    /// <summary>The profile after the change (null for Deleted/Reset).</summary>
    public ShellProfile? Profile { get; init; }
}
```

### 3. IShellProfileService.cs

**Location**: `src/AIntern.Core/Interfaces/IShellProfileService.cs`

```csharp
namespace AIntern.Core.Interfaces;

using AIntern.Core.Models.Terminal;

/// <summary>
/// Service for managing shell profiles with persistence.
/// </summary>
public interface IShellProfileService
{
    /// <summary>Raised when profiles are modified.</summary>
    event EventHandler<ProfilesChangedEventArgs>? ProfilesChanged;

    // === Read Operations ===

    /// <summary>Get all profiles (built-in and custom).</summary>
    Task<IReadOnlyList<ShellProfile>> GetAllProfilesAsync(CancellationToken ct = default);

    /// <summary>Get visible profiles, sorted by SortOrder then Name.</summary>
    Task<IReadOnlyList<ShellProfile>> GetVisibleProfilesAsync(CancellationToken ct = default);

    /// <summary>Get a profile by ID.</summary>
    Task<ShellProfile?> GetProfileAsync(Guid id, CancellationToken ct = default);

    /// <summary>Get the default profile (never null).</summary>
    Task<ShellProfile> GetDefaultProfileAsync(CancellationToken ct = default);

    // === Write Operations ===

    /// <summary>Create a new profile.</summary>
    Task<ShellProfile> CreateProfileAsync(ShellProfile profile, CancellationToken ct = default);

    /// <summary>Update an existing profile (not built-in).</summary>
    Task UpdateProfileAsync(ShellProfile profile, CancellationToken ct = default);

    /// <summary>Delete a profile (not built-in).</summary>
    Task DeleteProfileAsync(Guid id, CancellationToken ct = default);

    /// <summary>Set a profile as the default.</summary>
    Task SetDefaultProfileAsync(Guid id, CancellationToken ct = default);

    /// <summary>Duplicate a profile using Clone().</summary>
    Task<ShellProfile> DuplicateProfileAsync(Guid id, CancellationToken ct = default);

    // === Bulk Operations ===

    /// <summary>Reset all profiles to auto-detected defaults.</summary>
    Task ResetToDefaultsAsync(CancellationToken ct = default);

    /// <summary>Import profiles from JSON, returns count imported.</summary>
    Task<int> ImportProfilesAsync(string json, CancellationToken ct = default);

    /// <summary>Export profiles to JSON. If null, exports non-built-in.</summary>
    Task<string> ExportProfilesAsync(IEnumerable<Guid>? profileIds = null, CancellationToken ct = default);

    // === Utility ===

    /// <summary>Get effective settings (profile overrides + app defaults).</summary>
    ShellProfileDefaults GetEffectiveSettings(ShellProfile profile);
}
```

### 4. ShellProfileService.cs

**Location**: `src/AIntern.Services/Terminal/ShellProfileService.cs`

```csharp
namespace AIntern.Services.Terminal;

using System.Text.Json;
using Microsoft.Extensions.Logging;
using AIntern.Core.Interfaces;
using AIntern.Core.Models.Terminal;

/// <summary>
/// Manages shell profiles with JSON persistence.
/// </summary>
public sealed class ShellProfileService : IShellProfileService
{
    private readonly IShellDetectionService _shellDetection;
    private readonly ISettingsService _settingsService;
    private readonly ILogger<ShellProfileService> _logger;
    private readonly string _profilesPath;
    private readonly SemaphoreSlim _lock = new(1, 1);
    private List<ShellProfile>? _profiles;
    private bool _initialized;

    public event EventHandler<ProfilesChangedEventArgs>? ProfilesChanged;

    public ShellProfileService(
        IShellDetectionService shellDetection,
        ISettingsService settingsService,
        ILogger<ShellProfileService> logger)
    {
        _shellDetection = shellDetection;
        _settingsService = settingsService;
        _logger = logger;

        var appDataPath = Path.Combine(
            Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData),
            "AIntern");
        Directory.CreateDirectory(appDataPath);
        _profilesPath = Path.Combine(appDataPath, "shell-profiles.json");
    }

    // === Read Operations ===

    public async Task<IReadOnlyList<ShellProfile>> GetAllProfilesAsync(CancellationToken ct = default)
    {
        await EnsureInitializedAsync(ct);
        return _profiles!.AsReadOnly();
    }

    public async Task<IReadOnlyList<ShellProfile>> GetVisibleProfilesAsync(CancellationToken ct = default)
    {
        await EnsureInitializedAsync(ct);
        return _profiles!
            .Where(p => !p.IsHidden)
            .OrderBy(p => p.SortOrder)
            .ThenBy(p => p.Name)
            .ToList()
            .AsReadOnly();
    }

    public async Task<ShellProfile?> GetProfileAsync(Guid id, CancellationToken ct = default)
    {
        await EnsureInitializedAsync(ct);
        return _profiles!.FirstOrDefault(p => p.Id == id);
    }

    public async Task<ShellProfile> GetDefaultProfileAsync(CancellationToken ct = default)
    {
        await EnsureInitializedAsync(ct);
        var settings = await _settingsService.GetSettingsAsync();

        // 1. Try configured default
        if (settings.DefaultShellProfileId.HasValue)
        {
            var configured = _profiles!.FirstOrDefault(p => p.Id == settings.DefaultShellProfileId.Value);
            if (configured != null) return configured;
        }

        // 2. Try profile marked as default
        var defaultProfile = _profiles!.FirstOrDefault(p => p.IsDefault);
        if (defaultProfile != null) return defaultProfile;

        // 3. Return first available
        return _profiles!.First();
    }

    // === Write Operations ===

    public async Task<ShellProfile> CreateProfileAsync(ShellProfile profile, CancellationToken ct = default)
    {
        await EnsureInitializedAsync(ct);
        await _lock.WaitAsync(ct);
        try
        {
            if (string.IsNullOrWhiteSpace(profile.ShellPath))
                throw new ArgumentException("Shell path is required", nameof(profile));

            if (!_shellDetection.ValidateShellPath(profile.ShellPath))
                throw new ArgumentException($"Invalid shell path: {profile.ShellPath}", nameof(profile));

            if (profile.ShellType == ShellType.Unknown)
                profile.ShellType = _shellDetection.DetectShellType(profile.ShellPath);

            profile.ModifiedAt = DateTime.UtcNow;
            _profiles!.Add(profile);
            await SaveProfilesAsync(ct);

            _logger.LogInformation("Created profile: {Name} ({Id})", profile.Name, profile.Id);
            ProfilesChanged?.Invoke(this, new ProfilesChangedEventArgs
            {
                ChangeType = ProfileChangeType.Added,
                ProfileId = profile.Id,
                Profile = profile
            });

            return profile;
        }
        finally { _lock.Release(); }
    }

    public async Task UpdateProfileAsync(ShellProfile profile, CancellationToken ct = default)
    {
        await EnsureInitializedAsync(ct);
        await _lock.WaitAsync(ct);
        try
        {
            var existing = _profiles!.FirstOrDefault(p => p.Id == profile.Id)
                ?? throw new InvalidOperationException($"Profile not found: {profile.Id}");

            if (existing.IsBuiltIn)
                throw new InvalidOperationException("Cannot modify built-in profile");

            var index = _profiles!.IndexOf(existing);
            profile.ModifiedAt = DateTime.UtcNow;
            _profiles[index] = profile;
            await SaveProfilesAsync(ct);

            _logger.LogInformation("Updated profile: {Name} ({Id})", profile.Name, profile.Id);
            ProfilesChanged?.Invoke(this, new ProfilesChangedEventArgs
            {
                ChangeType = ProfileChangeType.Updated,
                ProfileId = profile.Id,
                Profile = profile
            });
        }
        finally { _lock.Release(); }
    }

    public async Task DeleteProfileAsync(Guid id, CancellationToken ct = default)
    {
        await EnsureInitializedAsync(ct);
        await _lock.WaitAsync(ct);
        try
        {
            var profile = _profiles!.FirstOrDefault(p => p.Id == id);
            if (profile == null) return;

            if (profile.IsBuiltIn)
                throw new InvalidOperationException("Cannot delete built-in profile");

            _profiles.Remove(profile);

            var settings = await _settingsService.GetSettingsAsync();
            if (settings.DefaultShellProfileId == id)
            {
                settings.DefaultShellProfileId = null;
                await _settingsService.SaveSettingsAsync(settings);
            }

            await SaveProfilesAsync(ct);

            _logger.LogInformation("Deleted profile: {Id}", id);
            ProfilesChanged?.Invoke(this, new ProfilesChangedEventArgs
            {
                ChangeType = ProfileChangeType.Deleted,
                ProfileId = id
            });
        }
        finally { _lock.Release(); }
    }

    public async Task SetDefaultProfileAsync(Guid id, CancellationToken ct = default)
    {
        await EnsureInitializedAsync(ct);
        await _lock.WaitAsync(ct);
        try
        {
            var profile = _profiles!.FirstOrDefault(p => p.Id == id)
                ?? throw new InvalidOperationException($"Profile not found: {id}");

            foreach (var p in _profiles.Where(p => p.IsDefault))
                p.IsDefault = false;

            profile.IsDefault = true;

            var settings = await _settingsService.GetSettingsAsync();
            settings.DefaultShellProfileId = id;
            await _settingsService.SaveSettingsAsync(settings);
            await SaveProfilesAsync(ct);

            _logger.LogInformation("Set default profile: {Name} ({Id})", profile.Name, id);
            ProfilesChanged?.Invoke(this, new ProfilesChangedEventArgs
            {
                ChangeType = ProfileChangeType.DefaultChanged,
                ProfileId = id,
                Profile = profile
            });
        }
        finally { _lock.Release(); }
    }

    public async Task<ShellProfile> DuplicateProfileAsync(Guid id, CancellationToken ct = default)
    {
        var source = await GetProfileAsync(id, ct)
            ?? throw new InvalidOperationException($"Profile not found: {id}");
        return await CreateProfileAsync(source.Clone(), ct);
    }

    // === Bulk Operations ===

    public async Task ResetToDefaultsAsync(CancellationToken ct = default)
    {
        await _lock.WaitAsync(ct);
        try
        {
            _profiles = new List<ShellProfile>();
            await GenerateBuiltInProfilesAsync(ct);
            await SaveProfilesAsync(ct);

            _logger.LogInformation("Reset profiles to defaults");
            ProfilesChanged?.Invoke(this, new ProfilesChangedEventArgs { ChangeType = ProfileChangeType.Reset });
        }
        finally { _lock.Release(); }
    }

    public async Task<int> ImportProfilesAsync(string json, CancellationToken ct = default)
    {
        var imported = JsonSerializer.Deserialize<List<ShellProfile>>(json);
        if (imported == null || imported.Count == 0) return 0;

        await EnsureInitializedAsync(ct);
        await _lock.WaitAsync(ct);
        try
        {
            var count = 0;
            foreach (var profile in imported)
            {
                var newProfile = new ShellProfile
                {
                    Name = profile.Name,
                    ShellPath = profile.ShellPath,
                    ShellType = profile.ShellType,
                    StartingDirectory = profile.StartingDirectory,
                    Arguments = profile.Arguments,
                    Environment = new Dictionary<string, string>(profile.Environment),
                    FontFamily = profile.FontFamily,
                    FontSize = profile.FontSize,
                    ThemeName = profile.ThemeName,
                    CursorStyle = profile.CursorStyle,
                    CursorBlink = profile.CursorBlink,
                    TabTitleFormat = profile.TabTitleFormat,
                    StartupCommand = profile.StartupCommand,
                    CloseOnExit = profile.CloseOnExit,
                    BellStyle = profile.BellStyle,
                    ScrollbackLines = profile.ScrollbackLines,
                    IsBuiltIn = false
                };

                if (_shellDetection.ValidateShellPath(newProfile.ShellPath))
                {
                    _profiles!.Add(newProfile);
                    count++;
                }
            }

            await SaveProfilesAsync(ct);
            _logger.LogInformation("Imported {Count} profiles", count);
            return count;
        }
        finally { _lock.Release(); }
    }

    public async Task<string> ExportProfilesAsync(IEnumerable<Guid>? profileIds = null, CancellationToken ct = default)
    {
        await EnsureInitializedAsync(ct);

        var toExport = profileIds == null
            ? _profiles!.Where(p => !p.IsBuiltIn).ToList()
            : _profiles!.Where(p => profileIds.Contains(p.Id)).ToList();

        return JsonSerializer.Serialize(toExport, new JsonSerializerOptions { WriteIndented = true });
    }

    public ShellProfileDefaults GetEffectiveSettings(ShellProfile profile)
    {
        var settings = _settingsService.GetSettingsAsync().GetAwaiter().GetResult();
        return new ShellProfileDefaults
        {
            FontFamily = profile.FontFamily ?? settings.TerminalFontFamily,
            FontSize = profile.FontSize ?? settings.TerminalFontSize,
            ThemeName = profile.ThemeName ?? settings.TerminalTheme,
            CursorStyle = profile.CursorStyle ?? settings.TerminalCursorStyle,
            CursorBlink = profile.CursorBlink ?? settings.TerminalCursorBlink,
            ScrollbackLines = profile.ScrollbackLines ?? settings.TerminalScrollbackLines,
            BellStyle = profile.BellStyle,
            CloseOnExit = profile.CloseOnExit
        };
    }

    // === Private Methods ===

    private async Task EnsureInitializedAsync(CancellationToken ct)
    {
        if (_initialized) return;
        await _lock.WaitAsync(ct);
        try
        {
            if (_initialized) return;
            await LoadProfilesAsync(ct);
            _initialized = true;
        }
        finally { _lock.Release(); }
    }

    private async Task LoadProfilesAsync(CancellationToken ct)
    {
        if (File.Exists(_profilesPath))
        {
            try
            {
                var json = await File.ReadAllTextAsync(_profilesPath, ct);
                _profiles = JsonSerializer.Deserialize<List<ShellProfile>>(json) ?? new();
                _logger.LogDebug("Loaded {Count} profiles from disk", _profiles.Count);
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Failed to load profiles, regenerating");
                _profiles = new List<ShellProfile>();
            }
        }
        else
        {
            _profiles = new List<ShellProfile>();
        }

        await GenerateBuiltInProfilesAsync(ct);
    }

    private async Task GenerateBuiltInProfilesAsync(CancellationToken ct)
    {
        var shells = await _shellDetection.GetAvailableShellsAsync(ct);
        var existingPaths = _profiles!.Where(p => p.IsBuiltIn)
            .Select(p => p.ShellPath)
            .ToHashSet(StringComparer.OrdinalIgnoreCase);

        foreach (var shell in shells.Where(s => !existingPaths.Contains(s.Path)))
        {
            _profiles.Add(new ShellProfile
            {
                Name = shell.Name,
                ShellPath = shell.Path,
                ShellType = shell.Type,
                IsDefault = shell.IsDefault,
                IsBuiltIn = true,
                Arguments = shell.DefaultArguments,
                IconPath = shell.IconPath,
                SortOrder = shell.IsDefault ? 0 : 100
            });
            _logger.LogDebug("Generated built-in profile: {Name}", shell.Name);
        }

        if (!_profiles.Any(p => p.IsDefault) && _profiles.Count > 0)
            _profiles[0].IsDefault = true;
    }

    private async Task SaveProfilesAsync(CancellationToken ct)
    {
        var json = JsonSerializer.Serialize(_profiles, new JsonSerializerOptions { WriteIndented = true });
        await File.WriteAllTextAsync(_profilesPath, json, ct);
        _logger.LogDebug("Saved {Count} profiles to disk", _profiles!.Count);
    }
}
```

---

## File Summary

| File | Location | Purpose |
|------|----------|---------|
| `ProfileChangeType.cs` | `src/AIntern.Core/Models/Terminal/` | Change type enumeration |
| `ProfilesChangedEventArgs.cs` | `src/AIntern.Core/Models/Terminal/` | Event arguments |
| `IShellProfileService.cs` | `src/AIntern.Core/Interfaces/` | Service interface |
| `ShellProfileService.cs` | `src/AIntern.Services/Terminal/` | Service implementation |

### Files to Modify

| File | Changes |
|------|---------|
| `src/AIntern.Services/DependencyInjection.cs` | Register `IShellProfileService` as singleton |

---

## Unit Test Plan

| Test | Description |
|------|-------------|
| `GetAllProfilesAsync_ReturnsAllProfiles` | Includes built-in and custom |
| `GetVisibleProfilesAsync_ExcludesHidden` | Filters IsHidden = true |
| `GetVisibleProfilesAsync_SortsBySortOrderThenName` | Correct ordering |
| `GetDefaultProfileAsync_ReturnsConfiguredDefault` | Priority 1: AppSettings.DefaultShellProfileId |
| `GetDefaultProfileAsync_FallsBackToIsDefault` | Priority 2: IsDefault flag |
| `GetDefaultProfileAsync_FallsBackToFirst` | Priority 3: First in list |
| `CreateProfileAsync_ValidatesShellPath` | Throws for invalid path |
| `CreateProfileAsync_AutoDetectsShellType` | Unknown → detected |
| `CreateProfileAsync_RaisesProfilesChanged` | Event with Added type |
| `UpdateProfileAsync_ThrowsForBuiltIn` | Cannot modify IsBuiltIn = true |
| `UpdateProfileAsync_UpdatesModifiedAt` | Timestamp updated |
| `DeleteProfileAsync_ThrowsForBuiltIn` | Cannot delete IsBuiltIn = true |
| `DeleteProfileAsync_ClearsDefaultIfDeleted` | Updates AppSettings |
| `SetDefaultProfileAsync_ClearsOtherDefaults` | Only one IsDefault |
| `SetDefaultProfileAsync_UpdatesAppSettings` | Persists DefaultShellProfileId |
| `DuplicateProfileAsync_UsesClone` | All properties copied |
| `ResetToDefaultsAsync_RegeneratesBuiltIn` | Fresh profiles from detection |
| `ImportProfilesAsync_GeneratesNewIds` | No ID conflicts |
| `ImportProfilesAsync_ValidatesShellPaths` | Skips invalid paths |
| `ExportProfilesAsync_ExcludesBuiltInByDefault` | Only custom profiles |
| `GetEffectiveSettings_MergesWithAppSettings` | Null → app default |
| `Persistence_SurvivesRestart` | Load matches saved state |

**Total Tests**: 22

---

## Verification

```bash
# Verify compilation
dotnet build src/AIntern.Services

# Run unit tests
dotnet test --filter "ShellProfileService"

# Check profile file location
ls ~/Library/Application\ Support/AIntern/shell-profiles.json  # macOS
```

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | Profiles persist across application restarts |
| AC-2 | Built-in profiles are auto-generated from detected shells |
| AC-3 | Custom profiles can be created, updated, and deleted |
| AC-4 | Default profile can be set and persisted in AppSettings |
| AC-5 | Profile duplication creates proper copy via Clone() |
| AC-6 | Import/export produces valid JSON |
| AC-7 | Built-in profiles cannot be modified or deleted |
| AC-8 | Profile validation rejects invalid shell paths |
| AC-9 | ProfilesChanged event fires for all modifications |
| AC-10 | GetEffectiveSettings correctly merges profile + app defaults |

---

## Changelog Entry

```markdown
## v0.5.3d - Profile Management Service

### Added
- `ProfileChangeType` enumeration (Added, Updated, Deleted, DefaultChanged, Reset)
- `ProfilesChangedEventArgs` for profile modification events
- `IShellProfileService` interface with:
  - Read: GetAllProfilesAsync, GetVisibleProfilesAsync, GetProfileAsync, GetDefaultProfileAsync
  - Write: CreateProfileAsync, UpdateProfileAsync, DeleteProfileAsync, SetDefaultProfileAsync, DuplicateProfileAsync
  - Bulk: ResetToDefaultsAsync, ImportProfilesAsync, ExportProfilesAsync
  - Utility: GetEffectiveSettings

- `ShellProfileService` implementation with:
  - JSON persistence to %APPDATA%/AIntern/shell-profiles.json
  - Thread-safe operations via SemaphoreSlim
  - Lazy initialization with double-checked locking
  - Auto-generation of built-in profiles from detected shells
  - Default profile resolution (Settings → IsDefault → First)
  - Shell path validation on create/import
  - Auto-detection of ShellType if Unknown
  - ProfilesChanged events for all modifications
```

---

## Timeline Estimate

| Version | Estimated Effort |
|---------|------------------|
| v0.5.3d | 0.75 day |
