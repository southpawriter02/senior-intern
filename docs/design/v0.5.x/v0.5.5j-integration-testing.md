# Design Specification: AIntern v0.5.5j "Integration Testing"

## Overview

**Version**: v0.5.5j
**Parent**: v0.5.5 Polish & Integration
**Focus**: Comprehensive integration tests for all terminal functionality

### Purpose

This sub-version creates comprehensive integration tests:
1. Terminal search tests (plain text, regex, navigation)
2. Keyboard shortcuts tests (bindings, conflicts, updates)
3. Terminal settings tests (defaults, themes, validation)
4. Terminal history tests (CRUD, search, cleanup)
5. Cross-platform tests (fonts, paths, shell detection)
6. Performance benchmarks (search, rendering)
7. Test mocks and utilities
8. Coverage requirements enforcement

### Dependencies

**All v0.5.5 Sub-versions**:
- v0.5.5a: Search models
- v0.5.5b: Search service
- v0.5.5c: Search UI
- v0.5.5d: Keyboard shortcuts
- v0.5.5e: Settings models
- v0.5.5f: Settings panel
- v0.5.5g: Profile editor
- v0.5.5h: Status bar
- v0.5.5i: History management

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                    v0.5.5j Integration Testing Architecture                   │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                       Test Project Structure                             │ │
│  │  tests/AIntern.Tests.Integration/                                       │ │
│  ├─────────────────────────────────────────────────────────────────────────┤ │
│  │                                                                          │ │
│  │  Terminal/                                                               │ │
│  │  ├── TerminalSearchTests.cs                                             │ │
│  │  │   ├── Search_PlainText_FindsAllMatches                               │ │
│  │  │   ├── Search_CaseSensitive_OnlyMatchesExact                          │ │
│  │  │   ├── Search_Regex_MatchesPattern                                    │ │
│  │  │   ├── Search_InvalidRegex_ReturnsError                               │ │
│  │  │   └── NavigateNext_WrapsAround                                       │ │
│  │  │                                                                       │ │
│  │  ├── KeyboardShortcutTests.cs                                           │ │
│  │  │   ├── TryGetAction_CtrlBacktick_ReturnsToggleTerminal                │ │
│  │  │   ├── UpdateBinding_UpdatesSuccessfully                              │ │
│  │  │   ├── UpdateBinding_Conflict_ReturnsFalse                            │ │
│  │  │   └── GetAllBindings_ReturnsAllDefaultBindings                       │ │
│  │  │                                                                       │ │
│  │  ├── TerminalSettingsTests.cs                                           │ │
│  │  │   ├── TerminalSettings_DefaultValues_AreReasonable                   │ │
│  │  │   └── TerminalTheme_GetAnsiColor_ReturnsCorrectColors                │ │
│  │  │                                                                       │ │
│  │  ├── TerminalHistoryTests.cs                                            │ │
│  │  │   ├── AddCommand_StoresInDatabase                                    │ │
│  │  │   ├── SearchHistory_FindsMatchingCommands                            │ │
│  │  │   └── ClearHistoryOlderThan_RemovesOldEntries                        │ │
│  │  │                                                                       │ │
│  │  └── CrossPlatformTerminalTests.cs                                      │ │
│  │      ├── DefaultFont_Windows_IsCascadiaOrConsolas                       │ │
│  │      ├── DefaultFont_MacOS_IsSFMonoOrMenlo                              │ │
│  │      └── DefaultFont_Linux_IsUbuntuMonoOrDejaVu                         │ │
│  │                                                                          │ │
│  │  Mocks/                                                                  │ │
│  │  ├── MockTerminalBuffer.cs                                              │ │
│  │  ├── MockSettingsService.cs                                             │ │
│  │  └── TestAppDbContext.cs                                                │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                      Performance Test Project                            │ │
│  │  tests/AIntern.Tests.Performance/                                       │ │
│  ├─────────────────────────────────────────────────────────────────────────┤ │
│  │                                                                          │ │
│  │  TerminalSearchBenchmarks.cs                                             │ │
│  │  ├── Search_PlainText_100kLines                                         │ │
│  │  ├── Search_Regex_100kLines                                             │ │
│  │  └── Search_CaseSensitive_100kLines                                     │ │
│  │                                                                          │ │
│  │  TerminalRenderingBenchmarks.cs                                          │ │
│  │  ├── Render_FullScreen_60fps                                            │ │
│  │  └── Render_WithHighlights_60fps                                        │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Test Coverage Matrix

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                         Test Coverage Requirements                            │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Component                        │ Target │ Focus Areas                     │
│  ─────────────────────────────────┼────────┼───────────────────────────────  │
│  TerminalSearchService            │  90%   │ Regex, cancellation, edge cases │
│  KeyboardShortcutService          │  85%   │ Conflicts, persistence, lookup  │
│  TerminalHistoryService           │  85%   │ CRUD, search, export, cleanup   │
│  TerminalSettingsViewModel        │  80%   │ Validation, preview, save       │
│  ShellProfileEditorViewModel      │  75%   │ Path validation, detection      │
│  TerminalStatusBarViewModel       │  80%   │ Session tracking, updates       │
│  TerminalSearchBarViewModel       │  80%   │ Debouncing, navigation          │
│  FontService                      │  75%   │ Font detection, fallbacks       │
│  TerminalSettings                 │  90%   │ Defaults, validation, clone     │
│  TerminalTheme                    │  90%   │ Color mapping, built-ins        │
│                                                                              │
│  Overall Integration Target: 85%                                             │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Specifications

### 1. TerminalSearchTests.cs

**Location**: `tests/AIntern.Tests.Integration/Terminal/TerminalSearchTests.cs`

```csharp
namespace AIntern.Tests.Integration.Terminal;

using NUnit.Framework;
using Microsoft.Extensions.Logging.Abstractions;
using AIntern.Core.Models.Terminal;
using AIntern.Services.Terminal;
using AIntern.Tests.Integration.Mocks;

/// <summary>
/// Integration tests for terminal search functionality.
/// Tests search service with mock buffer across various scenarios.
/// </summary>
[TestFixture]
public class TerminalSearchTests
{
    private TerminalSearchService _searchService;
    private MockTerminalBuffer _buffer;

    [SetUp]
    public void SetUp()
    {
        _searchService = new TerminalSearchService(
            NullLogger<TerminalSearchService>.Instance);
        _buffer = new MockTerminalBuffer();
    }

    // ========== Plain Text Search ==========

    [Test]
    public async Task Search_PlainText_FindsAllMatches()
    {
        // Arrange
        _buffer.AddLines(
            "Hello World",
            "hello again",
            "HELLO there"
        );

        // Act
        var state = await _searchService.SearchAsync(
            _buffer,
            "hello",
            new TerminalSearchOptions { DefaultCaseSensitive = false });

        // Assert
        Assert.That(state.Results, Has.Count.EqualTo(3));
        Assert.That(state.TotalCount, Is.EqualTo(3));
        Assert.That(state.ErrorMessage, Is.Null);
    }

    [Test]
    public async Task Search_PlainText_MultipleMatchesPerLine()
    {
        // Arrange
        _buffer.AddLines("hello hello hello");

        // Act
        var state = await _searchService.SearchAsync(
            _buffer,
            "hello",
            new TerminalSearchOptions());

        // Assert
        Assert.That(state.Results, Has.Count.EqualTo(3));
        Assert.That(state.Results[0].LineIndex, Is.EqualTo(0));
        Assert.That(state.Results[1].LineIndex, Is.EqualTo(0));
        Assert.That(state.Results[2].LineIndex, Is.EqualTo(0));
    }

    [Test]
    public async Task Search_EmptyQuery_ReturnsEmptyResults()
    {
        // Arrange
        _buffer.AddLines("some content");

        // Act
        var state = await _searchService.SearchAsync(
            _buffer,
            "",
            new TerminalSearchOptions());

        // Assert
        Assert.That(state.Results, Is.Empty);
        Assert.That(state.Query, Is.Empty);
    }

    [Test]
    public async Task Search_NoMatches_ReturnsEmptyResults()
    {
        // Arrange
        _buffer.AddLines("apple", "banana", "cherry");

        // Act
        var state = await _searchService.SearchAsync(
            _buffer,
            "grape",
            new TerminalSearchOptions());

        // Assert
        Assert.That(state.Results, Is.Empty);
        Assert.That(state.TotalCount, Is.EqualTo(0));
    }

    // ========== Case Sensitivity ==========

    [Test]
    public async Task Search_CaseSensitive_OnlyMatchesExact()
    {
        // Arrange
        _buffer.AddLines("Hello", "hello", "HELLO");

        // Act
        var state = await _searchService.SearchAsync(
            _buffer,
            "hello",
            new TerminalSearchOptions { DefaultCaseSensitive = true });

        // Assert
        Assert.That(state.Results, Has.Count.EqualTo(1));
        Assert.That(state.Results[0].LineIndex, Is.EqualTo(1));
    }

    [Test]
    public async Task Search_CaseInsensitive_MatchesAll()
    {
        // Arrange
        _buffer.AddLines("Error", "ERROR", "error", "ErRoR");

        // Act
        var state = await _searchService.SearchAsync(
            _buffer,
            "error",
            new TerminalSearchOptions { DefaultCaseSensitive = false });

        // Assert
        Assert.That(state.Results, Has.Count.EqualTo(4));
    }

    // ========== Regex Search ==========

    [Test]
    public async Task Search_Regex_MatchesPattern()
    {
        // Arrange
        _buffer.AddLines(
            "Error: file not found",
            "Warning: deprecated API",
            "Error: connection failed",
            "Info: processing complete"
        );

        // Act
        var state = await _searchService.SearchAsync(
            _buffer,
            @"Error:.*",
            new TerminalSearchOptions { DefaultUseRegex = true });

        // Assert
        Assert.That(state.Results, Has.Count.EqualTo(2));
    }

    [Test]
    public async Task Search_Regex_CapturesGroups()
    {
        // Arrange
        _buffer.AddLines(
            "[2024-01-01] Error 404",
            "[2024-01-02] Error 500"
        );

        // Act
        var state = await _searchService.SearchAsync(
            _buffer,
            @"Error (\d+)",
            new TerminalSearchOptions { DefaultUseRegex = true });

        // Assert
        Assert.That(state.Results, Has.Count.EqualTo(2));
    }

    [Test]
    public async Task Search_InvalidRegex_ReturnsError()
    {
        // Arrange
        _buffer.AddLines("test");

        // Act
        var state = await _searchService.SearchAsync(
            _buffer,
            "[invalid",
            new TerminalSearchOptions { DefaultUseRegex = true });

        // Assert
        Assert.That(state.ErrorMessage, Is.Not.Null);
        Assert.That(state.ErrorMessage, Does.Contain("Invalid"));
        Assert.That(state.Results, Is.Empty);
    }

    // ========== Navigation ==========

    [Test]
    public void NavigateNext_WrapsAround()
    {
        // Arrange
        var state = new TerminalSearchState
        {
            Results = new[]
            {
                new TerminalSearchResult { LineIndex = 0 },
                new TerminalSearchResult { LineIndex = 1 },
                new TerminalSearchResult { LineIndex = 2 }
            },
            CurrentResultIndex = 2,
            WrapAround = true
        };

        // Act
        var newState = _searchService.NavigateNext(state);

        // Assert
        Assert.That(newState.CurrentResultIndex, Is.EqualTo(0));
    }

    [Test]
    public void NavigatePrevious_WrapsAround()
    {
        // Arrange
        var state = new TerminalSearchState
        {
            Results = new[]
            {
                new TerminalSearchResult { LineIndex = 0 },
                new TerminalSearchResult { LineIndex = 1 },
                new TerminalSearchResult { LineIndex = 2 }
            },
            CurrentResultIndex = 0,
            WrapAround = true
        };

        // Act
        var newState = _searchService.NavigatePrevious(state);

        // Assert
        Assert.That(newState.CurrentResultIndex, Is.EqualTo(2));
    }

    [Test]
    public void NavigateNext_NoWrap_StaysAtEnd()
    {
        // Arrange
        var state = new TerminalSearchState
        {
            Results = new[]
            {
                new TerminalSearchResult { LineIndex = 0 },
                new TerminalSearchResult { LineIndex = 1 }
            },
            CurrentResultIndex = 1,
            WrapAround = false
        };

        // Act
        var newState = _searchService.NavigateNext(state);

        // Assert
        Assert.That(newState.CurrentResultIndex, Is.EqualTo(1));
    }

    // ========== Cancellation ==========

    [Test]
    public async Task Search_Cancellation_StopsEarly()
    {
        // Arrange
        var largeBuffer = new MockTerminalBuffer();
        for (int i = 0; i < 10000; i++)
            largeBuffer.AddLine($"Line {i}");

        using var cts = new CancellationTokenSource();
        cts.CancelAfter(10); // Cancel after 10ms

        // Act
        var state = await _searchService.SearchAsync(
            largeBuffer,
            "Line",
            new TerminalSearchOptions(),
            cts.Token);

        // Assert - should have partial or no results due to cancellation
        Assert.That(state.Results.Count, Is.LessThan(10000));
    }

    // ========== Large Buffer ==========

    [Test]
    public async Task Search_LargeBuffer_CompletesInReasonableTime()
    {
        // Arrange
        var largeBuffer = new MockTerminalBuffer();
        for (int i = 0; i < 50000; i++)
            largeBuffer.AddLine($"Log entry {i}: Some content here");

        var sw = System.Diagnostics.Stopwatch.StartNew();

        // Act
        var state = await _searchService.SearchAsync(
            largeBuffer,
            "entry 25000",
            new TerminalSearchOptions());

        sw.Stop();

        // Assert
        Assert.That(state.Results, Has.Count.EqualTo(1));
        Assert.That(sw.ElapsedMilliseconds, Is.LessThan(5000), "Search took too long");
    }
}
```

### 2. KeyboardShortcutTests.cs

**Location**: `tests/AIntern.Tests.Integration/Terminal/KeyboardShortcutTests.cs`

```csharp
namespace AIntern.Tests.Integration.Terminal;

using NUnit.Framework;
using Avalonia.Input;
using AIntern.Core.Models.Terminal;
using AIntern.Services;
using AIntern.Tests.Integration.Mocks;

/// <summary>
/// Integration tests for keyboard shortcut service.
/// </summary>
[TestFixture]
public class KeyboardShortcutTests
{
    private KeyboardShortcutService _shortcutService;
    private MockSettingsService _settingsService;

    [SetUp]
    public void SetUp()
    {
        _settingsService = new MockSettingsService();
        _shortcutService = new KeyboardShortcutService(_settingsService);
    }

    // ========== Default Bindings ==========

    [Test]
    public void TryGetAction_CtrlBacktick_ReturnsToggleTerminal()
    {
        // Act
        var found = _shortcutService.TryGetAction(
            Key.OemTilde,
            KeyModifiers.Control,
            out var action);

        // Assert
        Assert.That(found, Is.True);
        Assert.That(action, Is.EqualTo(TerminalShortcutAction.ToggleTerminal));
    }

    [Test]
    public void TryGetAction_CtrlF_ReturnsOpenSearch()
    {
        // Act
        var found = _shortcutService.TryGetAction(
            Key.F,
            KeyModifiers.Control,
            out var action);

        // Assert
        Assert.That(found, Is.True);
        Assert.That(action, Is.EqualTo(TerminalShortcutAction.OpenSearch));
    }

    [Test]
    public void TryGetAction_CtrlC_ReturnsCopy()
    {
        // Act
        var found = _shortcutService.TryGetAction(
            Key.C,
            KeyModifiers.Control,
            out var action);

        // Assert
        Assert.That(found, Is.True);
        Assert.That(action, Is.EqualTo(TerminalShortcutAction.Copy));
    }

    [Test]
    public void TryGetAction_UnboundKey_ReturnsFalse()
    {
        // Act
        var found = _shortcutService.TryGetAction(
            Key.Q,
            KeyModifiers.Control | KeyModifiers.Alt | KeyModifiers.Shift,
            out var action);

        // Assert
        Assert.That(found, Is.False);
        Assert.That(action, Is.EqualTo(default(TerminalShortcutAction)));
    }

    [Test]
    public void GetAllBindings_ReturnsAllDefaultBindings()
    {
        // Act
        var bindings = _shortcutService.GetAllBindings();

        // Assert
        Assert.That(bindings, Has.Count.GreaterThan(20));
        Assert.That(bindings.Select(b => b.Action),
            Does.Contain(TerminalShortcutAction.ToggleTerminal));
        Assert.That(bindings.Select(b => b.Action),
            Does.Contain(TerminalShortcutAction.NewTerminal));
        Assert.That(bindings.Select(b => b.Action),
            Does.Contain(TerminalShortcutAction.Copy));
        Assert.That(bindings.Select(b => b.Action),
            Does.Contain(TerminalShortcutAction.Paste));
    }

    // ========== Binding Updates ==========

    [Test]
    public void UpdateBinding_UpdatesSuccessfully()
    {
        // Act
        var updated = _shortcutService.UpdateBinding(
            TerminalShortcutAction.ToggleTerminal,
            Key.T,
            KeyModifiers.Control | KeyModifiers.Alt);

        // Assert
        Assert.That(updated, Is.True);

        var found = _shortcutService.TryGetAction(
            Key.T,
            KeyModifiers.Control | KeyModifiers.Alt,
            out var action);
        Assert.That(found, Is.True);
        Assert.That(action, Is.EqualTo(TerminalShortcutAction.ToggleTerminal));
    }

    [Test]
    public void UpdateBinding_OldBindingNoLongerWorks()
    {
        // Arrange
        _shortcutService.UpdateBinding(
            TerminalShortcutAction.ToggleTerminal,
            Key.T,
            KeyModifiers.Control | KeyModifiers.Alt);

        // Act
        var found = _shortcutService.TryGetAction(
            Key.OemTilde,
            KeyModifiers.Control,
            out _);

        // Assert
        Assert.That(found, Is.False);
    }

    [Test]
    public void UpdateBinding_Conflict_ReturnsFalse()
    {
        // Arrange - Ctrl+F is already OpenSearch

        // Act
        var updated = _shortcutService.UpdateBinding(
            TerminalShortcutAction.NewTerminal,
            Key.F,
            KeyModifiers.Control);

        // Assert
        Assert.That(updated, Is.False);
    }

    [Test]
    public void GetConflict_ReturnsConflictingBinding()
    {
        // Act
        var conflict = _shortcutService.GetConflict(
            Key.F,
            KeyModifiers.Control);

        // Assert
        Assert.That(conflict, Is.Not.Null);
        Assert.That(conflict!.Action, Is.EqualTo(TerminalShortcutAction.OpenSearch));
    }

    // ========== Reset ==========

    [Test]
    public void ResetBinding_RestoresDefault()
    {
        // Arrange
        _shortcutService.UpdateBinding(
            TerminalShortcutAction.ToggleTerminal,
            Key.T,
            KeyModifiers.Control);

        // Act
        _shortcutService.ResetBinding(TerminalShortcutAction.ToggleTerminal);

        // Assert
        var found = _shortcutService.TryGetAction(
            Key.OemTilde,
            KeyModifiers.Control,
            out var action);
        Assert.That(found, Is.True);
        Assert.That(action, Is.EqualTo(TerminalShortcutAction.ToggleTerminal));
    }

    [Test]
    public void ResetAllBindings_RestoresAllDefaults()
    {
        // Arrange
        _shortcutService.UpdateBinding(TerminalShortcutAction.ToggleTerminal, Key.A, KeyModifiers.Control);
        _shortcutService.UpdateBinding(TerminalShortcutAction.NewTerminal, Key.B, KeyModifiers.Control);

        // Act
        _shortcutService.ResetAllBindings();

        // Assert
        var toggleFound = _shortcutService.TryGetAction(Key.OemTilde, KeyModifiers.Control, out _);
        Assert.That(toggleFound, Is.True);
    }

    // ========== Categories ==========

    [Test]
    public void GetByCategory_ReturnsOnlyCategoryBindings()
    {
        // Act
        var inputBindings = _shortcutService.GetByCategory("Input");

        // Assert
        Assert.That(inputBindings, Is.Not.Empty);
        Assert.That(inputBindings.All(b => b.Category == "Input"), Is.True);
    }

    // ========== Persistence ==========

    [Test]
    public void UpdateBinding_PersistsToSettings()
    {
        // Act
        _shortcutService.UpdateBinding(
            TerminalShortcutAction.ToggleTerminal,
            Key.T,
            KeyModifiers.Control);

        // Assert
        Assert.That(_settingsService.WasSaveCalled, Is.True);
    }
}
```

### 3. TerminalSettingsTests.cs

**Location**: `tests/AIntern.Tests.Integration/Terminal/TerminalSettingsTests.cs`

```csharp
namespace AIntern.Tests.Integration.Terminal;

using NUnit.Framework;
using AIntern.Core.Models.Terminal;

/// <summary>
/// Integration tests for terminal settings and themes.
/// </summary>
[TestFixture]
public class TerminalSettingsTests
{
    // ========== Default Values ==========

    [Test]
    public void TerminalSettings_DefaultValues_AreReasonable()
    {
        // Act
        var settings = new TerminalSettings();

        // Assert
        Assert.That(settings.FontSize, Is.InRange(10, 20));
        Assert.That(settings.LineHeight, Is.InRange(1.0, 2.0));
        Assert.That(settings.ScrollbackLines, Is.GreaterThan(1000));
        Assert.That(settings.CursorStyle, Is.EqualTo(TerminalCursorStyle.Block));
        Assert.That(settings.CursorBlink, Is.True);
        Assert.That(settings.FontFamily, Is.Not.Empty);
    }

    [Test]
    public void TerminalSettings_DefaultThemeName_IsDefaultDark()
    {
        // Act
        var settings = new TerminalSettings();

        // Assert
        Assert.That(settings.ThemeName, Is.EqualTo("Default Dark"));
    }

    // ========== Validation ==========

    [Test]
    public void TerminalSettings_Validate_ValidSettings_ReturnsEmpty()
    {
        // Act
        var settings = new TerminalSettings();
        var errors = settings.Validate();

        // Assert
        Assert.That(errors, Is.Empty);
    }

    [Test]
    public void TerminalSettings_Validate_InvalidFontSize_ReturnsError()
    {
        // Arrange
        var settings = new TerminalSettings { FontSize = 5 };

        // Act
        var errors = settings.Validate();

        // Assert
        Assert.That(errors, Has.Count.GreaterThan(0));
        Assert.That(errors.Any(e => e.Contains("FontSize")), Is.True);
    }

    [Test]
    public void TerminalSettings_Validate_InvalidScrollback_ReturnsError()
    {
        // Arrange
        var settings = new TerminalSettings { ScrollbackLines = -100 };

        // Act
        var errors = settings.Validate();

        // Assert
        Assert.That(errors, Has.Count.GreaterThan(0));
    }

    // ========== Clone ==========

    [Test]
    public void TerminalSettings_Clone_CreatesDeepCopy()
    {
        // Arrange
        var original = new TerminalSettings
        {
            FontSize = 16,
            ThemeName = "Dracula",
            CursorStyle = TerminalCursorStyle.Underline
        };

        // Act
        var clone = original.Clone();
        clone.FontSize = 20;
        clone.ThemeName = "Monokai";

        // Assert
        Assert.That(original.FontSize, Is.EqualTo(16));
        Assert.That(original.ThemeName, Is.EqualTo("Dracula"));
    }

    // ========== Theme Tests ==========

    [Test]
    public void TerminalTheme_GetAnsiColor_ReturnsCorrectColors()
    {
        // Arrange
        var theme = TerminalTheme.DefaultDark;

        // Act & Assert
        Assert.That(theme.GetAnsiColor(0), Is.EqualTo(theme.Black));
        Assert.That(theme.GetAnsiColor(1), Is.EqualTo(theme.Red));
        Assert.That(theme.GetAnsiColor(2), Is.EqualTo(theme.Green));
        Assert.That(theme.GetAnsiColor(7), Is.EqualTo(theme.White));
        Assert.That(theme.GetAnsiColor(8), Is.EqualTo(theme.BrightBlack));
        Assert.That(theme.GetAnsiColor(15), Is.EqualTo(theme.BrightWhite));
    }

    [Test]
    public void TerminalTheme_GetAnsiColor_InvalidIndex_ReturnsWhite()
    {
        // Arrange
        var theme = TerminalTheme.DefaultDark;

        // Act
        var color = theme.GetAnsiColor(100);

        // Assert
        Assert.That(color, Is.EqualTo(theme.White));
    }

    [Test]
    public void TerminalTheme_BuiltInThemes_HasExpectedThemes()
    {
        // Act
        var themes = TerminalTheme.BuiltInThemes;

        // Assert
        Assert.That(themes, Has.Count.GreaterThanOrEqualTo(4));
        Assert.That(themes.Select(t => t.Name), Does.Contain("Default Dark"));
        Assert.That(themes.Select(t => t.Name), Does.Contain("Default Light"));
        Assert.That(themes.Select(t => t.Name), Does.Contain("Dracula"));
        Assert.That(themes.Select(t => t.Name), Does.Contain("Monokai"));
    }

    [Test]
    public void TerminalTheme_Clone_CreatesDeepCopy()
    {
        // Arrange
        var original = TerminalTheme.Dracula;

        // Act
        var clone = original.Clone();
        clone.Name = "Modified";

        // Assert
        Assert.That(original.Name, Is.EqualTo("Dracula"));
    }

    // ========== Cursor Styles ==========

    [Test]
    public void TerminalCursorStyle_HasExpectedValues()
    {
        // Assert
        Assert.That(Enum.GetValues<TerminalCursorStyle>(), Does.Contain(TerminalCursorStyle.Block));
        Assert.That(Enum.GetValues<TerminalCursorStyle>(), Does.Contain(TerminalCursorStyle.Underline));
        Assert.That(Enum.GetValues<TerminalCursorStyle>(), Does.Contain(TerminalCursorStyle.Bar));
    }

    // ========== Bell Styles ==========

    [Test]
    public void TerminalBellStyle_HasExpectedValues()
    {
        // Assert
        Assert.That(Enum.GetValues<TerminalBellStyle>(), Does.Contain(TerminalBellStyle.None));
        Assert.That(Enum.GetValues<TerminalBellStyle>(), Does.Contain(TerminalBellStyle.Audio));
        Assert.That(Enum.GetValues<TerminalBellStyle>(), Does.Contain(TerminalBellStyle.Visual));
        Assert.That(Enum.GetValues<TerminalBellStyle>(), Does.Contain(TerminalBellStyle.Both));
    }
}
```

### 4. TerminalHistoryTests.cs

**Location**: `tests/AIntern.Tests.Integration/Terminal/TerminalHistoryTests.cs`

```csharp
namespace AIntern.Tests.Integration.Terminal;

using NUnit.Framework;
using Microsoft.Extensions.Logging.Abstractions;
using AIntern.Core.Models.Terminal;
using AIntern.Services.Terminal;
using AIntern.Tests.Integration.Mocks;

/// <summary>
/// Integration tests for terminal history service.
/// </summary>
[TestFixture]
public class TerminalHistoryTests
{
    private TerminalHistoryService _historyService;
    private TestAppDbContext _dbContext;

    [SetUp]
    public void SetUp()
    {
        _dbContext = new TestAppDbContext();
        _historyService = new TerminalHistoryService(
            _dbContext,
            NullLogger<TerminalHistoryService>.Instance);
    }

    [TearDown]
    public void TearDown()
    {
        _dbContext.Dispose();
    }

    // ========== Add Command ==========

    [Test]
    public async Task AddCommand_StoresInDatabase()
    {
        // Arrange
        var entry = new TerminalHistoryEntry
        {
            Command = "ls -la",
            WorkingDirectory = "/home/user"
        };

        // Act
        await _historyService.AddCommandAsync("session1", entry);

        // Assert
        var history = await _historyService.GetRecentCommandsAsync(10);
        Assert.That(history, Has.Count.EqualTo(1));
        Assert.That(history[0].Command, Is.EqualTo("ls -la"));
        Assert.That(history[0].WorkingDirectory, Is.EqualTo("/home/user"));
    }

    [Test]
    public async Task AddCommand_EmptyCommand_NotStored()
    {
        // Arrange
        var entry = new TerminalHistoryEntry { Command = "" };

        // Act
        await _historyService.AddCommandAsync("session1", entry);

        // Assert
        var history = await _historyService.GetRecentCommandsAsync(10);
        Assert.That(history, Is.Empty);
    }

    [Test]
    public async Task AddCommand_WithMetadata_StoresAll()
    {
        // Arrange
        var entry = new TerminalHistoryEntry
        {
            Command = "npm install",
            ExitCode = 0,
            Duration = TimeSpan.FromSeconds(5.5),
            ProfileId = "profile-123"
        };

        // Act
        await _historyService.AddCommandAsync("session1", entry);

        // Assert
        var history = await _historyService.GetRecentCommandsAsync(10);
        Assert.That(history[0].ExitCode, Is.EqualTo(0));
        Assert.That(history[0].Duration?.TotalSeconds, Is.EqualTo(5.5).Within(0.1));
        Assert.That(history[0].ProfileId, Is.EqualTo("profile-123"));
    }

    // ========== Get Recent ==========

    [Test]
    public async Task GetRecentCommands_ReturnsNewestFirst()
    {
        // Arrange
        await _historyService.AddCommandAsync("s1", new TerminalHistoryEntry
        {
            Command = "first",
            ExecutedAt = DateTime.UtcNow.AddMinutes(-10)
        });
        await _historyService.AddCommandAsync("s1", new TerminalHistoryEntry
        {
            Command = "second",
            ExecutedAt = DateTime.UtcNow.AddMinutes(-5)
        });
        await _historyService.AddCommandAsync("s1", new TerminalHistoryEntry
        {
            Command = "third",
            ExecutedAt = DateTime.UtcNow
        });

        // Act
        var history = await _historyService.GetRecentCommandsAsync(10);

        // Assert
        Assert.That(history[0].Command, Is.EqualTo("third"));
        Assert.That(history[1].Command, Is.EqualTo("second"));
        Assert.That(history[2].Command, Is.EqualTo("first"));
    }

    [Test]
    public async Task GetRecentCommands_RespectsCount()
    {
        // Arrange
        for (int i = 0; i < 50; i++)
        {
            await _historyService.AddCommandAsync("s1", new TerminalHistoryEntry
            {
                Command = $"command {i}"
            });
        }

        // Act
        var history = await _historyService.GetRecentCommandsAsync(10);

        // Assert
        Assert.That(history, Has.Count.EqualTo(10));
    }

    // ========== Search ==========

    [Test]
    public async Task SearchHistory_FindsMatchingCommands()
    {
        // Arrange
        await _historyService.AddCommandAsync("s1", new TerminalHistoryEntry { Command = "git status" });
        await _historyService.AddCommandAsync("s1", new TerminalHistoryEntry { Command = "git commit" });
        await _historyService.AddCommandAsync("s1", new TerminalHistoryEntry { Command = "npm install" });

        // Act
        var results = await _historyService.SearchHistoryAsync("git");

        // Assert
        Assert.That(results, Has.Count.EqualTo(2));
        Assert.That(results.All(r => r.Command.Contains("git")), Is.True);
    }

    [Test]
    public async Task SearchHistory_CaseInsensitive()
    {
        // Arrange
        await _historyService.AddCommandAsync("s1", new TerminalHistoryEntry { Command = "Git Status" });
        await _historyService.AddCommandAsync("s1", new TerminalHistoryEntry { Command = "GIT COMMIT" });

        // Act
        var results = await _historyService.SearchHistoryAsync("git");

        // Assert
        Assert.That(results, Has.Count.EqualTo(2));
    }

    [Test]
    public async Task SearchHistory_EmptyQuery_ReturnsEmpty()
    {
        // Arrange
        await _historyService.AddCommandAsync("s1", new TerminalHistoryEntry { Command = "test" });

        // Act
        var results = await _historyService.SearchHistoryAsync("");

        // Assert
        Assert.That(results, Is.Empty);
    }

    // ========== Clear ==========

    [Test]
    public async Task ClearAllHistory_DeletesEverything()
    {
        // Arrange
        await _historyService.AddCommandAsync("s1", new TerminalHistoryEntry { Command = "cmd1" });
        await _historyService.AddCommandAsync("s1", new TerminalHistoryEntry { Command = "cmd2" });

        // Act
        await _historyService.ClearAllHistoryAsync();

        // Assert
        var history = await _historyService.GetRecentCommandsAsync(10);
        Assert.That(history, Is.Empty);
    }

    [Test]
    public async Task ClearHistoryOlderThan_RemovesOldEntries()
    {
        // Arrange
        await _historyService.AddCommandAsync("s1", new TerminalHistoryEntry
        {
            Command = "old command",
            ExecutedAt = DateTime.UtcNow.AddDays(-30)
        });
        await _historyService.AddCommandAsync("s1", new TerminalHistoryEntry
        {
            Command = "new command",
            ExecutedAt = DateTime.UtcNow
        });

        // Act
        await _historyService.ClearHistoryOlderThanAsync(DateTime.UtcNow.AddDays(-7));

        // Assert
        var history = await _historyService.GetRecentCommandsAsync(10);
        Assert.That(history, Has.Count.EqualTo(1));
        Assert.That(history[0].Command, Is.EqualTo("new command"));
    }

    // ========== Export ==========

    [Test]
    public async Task ExportHistory_Json_CreatesValidFile()
    {
        // Arrange
        await _historyService.AddCommandAsync("s1", new TerminalHistoryEntry { Command = "test" });
        var filePath = Path.GetTempFileName();

        try
        {
            // Act
            await _historyService.ExportHistoryAsync(filePath, HistoryExportFormat.Json);

            // Assert
            var content = await File.ReadAllTextAsync(filePath);
            Assert.That(content, Does.StartWith("["));
            Assert.That(content, Does.Contain("test"));
        }
        finally
        {
            File.Delete(filePath);
        }
    }

    [Test]
    public async Task ExportHistory_Csv_CreatesValidFile()
    {
        // Arrange
        await _historyService.AddCommandAsync("s1", new TerminalHistoryEntry { Command = "test" });
        var filePath = Path.GetTempFileName();

        try
        {
            // Act
            await _historyService.ExportHistoryAsync(filePath, HistoryExportFormat.Csv);

            // Assert
            var lines = await File.ReadAllLinesAsync(filePath);
            Assert.That(lines[0], Does.Contain("Command"));
            Assert.That(lines[1], Does.Contain("test"));
        }
        finally
        {
            File.Delete(filePath);
        }
    }

    // ========== Session History ==========

    [Test]
    public async Task GetSessionHistory_ReturnsOnlySessionCommands()
    {
        // Arrange
        await _historyService.AddCommandAsync("session1", new TerminalHistoryEntry { Command = "cmd1" });
        await _historyService.AddCommandAsync("session2", new TerminalHistoryEntry { Command = "cmd2" });
        await _historyService.AddCommandAsync("session1", new TerminalHistoryEntry { Command = "cmd3" });

        // Act
        var history = await _historyService.GetSessionHistoryAsync("session1");

        // Assert
        Assert.That(history, Has.Count.EqualTo(2));
        Assert.That(history.Select(h => h.Command), Does.Contain("cmd1"));
        Assert.That(history.Select(h => h.Command), Does.Contain("cmd3"));
        Assert.That(history.Select(h => h.Command), Does.Not.Contain("cmd2"));
    }
}
```

### 5. CrossPlatformTerminalTests.cs

**Location**: `tests/AIntern.Tests.Integration/Terminal/CrossPlatformTerminalTests.cs`

```csharp
namespace AIntern.Tests.Integration.Terminal;

using NUnit.Framework;
using AIntern.Core.Models.Terminal;

/// <summary>
/// Cross-platform integration tests for terminal functionality.
/// Uses conditional test execution based on platform.
/// </summary>
[TestFixture]
public class CrossPlatformTerminalTests
{
    // ========== Font Defaults ==========

    [Test]
    [Platform("Win")]
    public void DefaultFont_Windows_IsCascadiaOrConsolas()
    {
        // Act
        var settings = new TerminalSettings();

        // Assert
        Assert.That(settings.FontFamily,
            Does.Contain("Cascadia").Or.Contain("Consolas"));
    }

    [Test]
    [Platform("MacOsX")]
    public void DefaultFont_MacOS_IsSFMonoOrMenlo()
    {
        // Act
        var settings = new TerminalSettings();

        // Assert
        Assert.That(settings.FontFamily,
            Does.Contain("SF Mono").Or.Contain("Menlo").Or.Contain("Monaco"));
    }

    [Test]
    [Platform("Linux")]
    public void DefaultFont_Linux_IsUbuntuMonoOrDejaVu()
    {
        // Act
        var settings = new TerminalSettings();

        // Assert
        Assert.That(settings.FontFamily,
            Does.Contain("Ubuntu Mono").Or.Contain("DejaVu").Or.Contain("Liberation Mono"));
    }

    // ========== Path Handling ==========

    [Test]
    [Platform("Win")]
    public void PathSeparator_Windows_IsBackslash()
    {
        // Assert
        Assert.That(Path.DirectorySeparatorChar, Is.EqualTo('\\'));
    }

    [Test]
    [Platform("MacOsX,Linux")]
    public void PathSeparator_Unix_IsForwardSlash()
    {
        // Assert
        Assert.That(Path.DirectorySeparatorChar, Is.EqualTo('/'));
    }

    // ========== Home Directory ==========

    [Test]
    public void HomeDirectory_IsNotEmpty()
    {
        // Act
        var home = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);

        // Assert
        Assert.That(home, Is.Not.Empty);
        Assert.That(Directory.Exists(home), Is.True);
    }

    // ========== Keyboard Modifier Display ==========

    [Test]
    [Platform("MacOsX")]
    public void KeyBinding_DisplayString_MacOS_UsesSymbols()
    {
        // Arrange
        var binding = new KeyBinding
        {
            Key = Avalonia.Input.Key.C,
            Modifiers = Avalonia.Input.KeyModifiers.Meta
        };

        // Act
        var display = binding.DisplayString;

        // Assert
        Assert.That(display, Does.Contain("⌘"));
    }

    [Test]
    [Platform("Win,Linux")]
    public void KeyBinding_DisplayString_NonMac_UsesCtrl()
    {
        // Arrange
        var binding = new KeyBinding
        {
            Key = Avalonia.Input.Key.C,
            Modifiers = Avalonia.Input.KeyModifiers.Control
        };

        // Act
        var display = binding.DisplayString;

        // Assert
        Assert.That(display, Does.Contain("Ctrl"));
    }
}
```

### 6. MockTerminalBuffer.cs

**Location**: `tests/AIntern.Tests.Integration/Mocks/MockTerminalBuffer.cs`

```csharp
namespace AIntern.Tests.Integration.Mocks;

using AIntern.Core.Interfaces;
using AIntern.Core.Models.Terminal;

/// <summary>
/// Mock terminal buffer for testing search functionality.
/// </summary>
public class MockTerminalBuffer : ITerminalBuffer
{
    private readonly List<string> _lines = new();

    public int LineCount => _lines.Count;
    public int ColumnCount => 80;
    public int ScrollbackLines => _lines.Count;

    public void AddLine(string line)
    {
        _lines.Add(line);
    }

    public void AddLines(params string[] lines)
    {
        _lines.AddRange(lines);
    }

    public string GetLine(int lineIndex)
    {
        if (lineIndex < 0 || lineIndex >= _lines.Count)
            return string.Empty;
        return _lines[lineIndex];
    }

    public IEnumerable<string> GetLines(int startLine, int count)
    {
        return _lines.Skip(startLine).Take(count);
    }

    public void Clear()
    {
        _lines.Clear();
    }

    public string GetText(int startLine, int startColumn, int endLine, int endColumn)
    {
        // Simplified implementation
        if (startLine == endLine)
        {
            var line = GetLine(startLine);
            return line.Substring(startColumn, Math.Min(endColumn - startColumn, line.Length - startColumn));
        }
        
        var result = new System.Text.StringBuilder();
        for (int i = startLine; i <= endLine && i < _lines.Count; i++)
        {
            result.AppendLine(_lines[i]);
        }
        return result.ToString();
    }
}
```

### 7. MockSettingsService.cs

**Location**: `tests/AIntern.Tests.Integration/Mocks/MockSettingsService.cs`

```csharp
namespace AIntern.Tests.Integration.Mocks;

using AIntern.Core.Interfaces;
using AIntern.Core.Models;

/// <summary>
/// Mock settings service for testing.
/// </summary>
public class MockSettingsService : ISettingsService
{
    public AppSettings CurrentSettings { get; } = new();
    public bool WasSaveCalled { get; private set; }

    public void SaveSettings()
    {
        WasSaveCalled = true;
    }

    public void ReloadSettings()
    {
        // No-op for tests
    }

    public event EventHandler<AppSettings>? SettingsChanged;

    public void RaiseSettingsChanged()
    {
        SettingsChanged?.Invoke(this, CurrentSettings);
    }
}
```

### 8. TestAppDbContext.cs

**Location**: `tests/AIntern.Tests.Integration/Mocks/TestAppDbContext.cs`

```csharp
namespace AIntern.Tests.Integration.Mocks;

using Microsoft.EntityFrameworkCore;
using AIntern.Data;
using AIntern.Data.Entities;

/// <summary>
/// In-memory database context for testing.
/// </summary>
public class TestAppDbContext : IAppDbContext, IDisposable
{
    private readonly DbContext _context;

    public TestAppDbContext()
    {
        var options = new DbContextOptionsBuilder<TestDbContext>()
            .UseInMemoryDatabase(databaseName: Guid.NewGuid().ToString())
            .Options;

        _context = new TestDbContext(options);
        _context.Database.EnsureCreated();
    }

    public DbSet<TerminalHistoryEntity> TerminalHistory =>
        _context.Set<TerminalHistoryEntity>();

    public Task<int> SaveChangesAsync(CancellationToken cancellationToken = default)
    {
        return _context.SaveChangesAsync(cancellationToken);
    }

    public void Dispose()
    {
        _context.Dispose();
    }

    private class TestDbContext : DbContext
    {
        public TestDbContext(DbContextOptions options) : base(options) { }

        public DbSet<TerminalHistoryEntity> TerminalHistory { get; set; } = null!;
    }
}
```

### 9. TerminalSearchBenchmarks.cs

**Location**: `tests/AIntern.Tests.Performance/TerminalSearchBenchmarks.cs`

```csharp
namespace AIntern.Tests.Performance;

using BenchmarkDotNet.Attributes;
using Microsoft.Extensions.Logging.Abstractions;
using AIntern.Core.Models.Terminal;
using AIntern.Services.Terminal;
using AIntern.Tests.Integration.Mocks;

/// <summary>
/// Performance benchmarks for terminal search operations.
/// </summary>
[MemoryDiagnoser]
[SimpleJob(launchCount: 1, warmupCount: 3, iterationCount: 5)]
public class TerminalSearchBenchmarks
{
    private TerminalSearchService _searchService = null!;
    private MockTerminalBuffer _smallBuffer = null!;
    private MockTerminalBuffer _mediumBuffer = null!;
    private MockTerminalBuffer _largeBuffer = null!;

    [GlobalSetup]
    public void Setup()
    {
        _searchService = new TerminalSearchService(
            NullLogger<TerminalSearchService>.Instance);

        _smallBuffer = CreateBuffer(1000);
        _mediumBuffer = CreateBuffer(10000);
        _largeBuffer = CreateBuffer(100000);
    }

    private static MockTerminalBuffer CreateBuffer(int lineCount)
    {
        var buffer = new MockTerminalBuffer();
        for (int i = 0; i < lineCount; i++)
        {
            var hasError = i % 100 == 0;
            buffer.AddLine(
                $"[{DateTime.Now:HH:mm:ss}] Log line {i}: " +
                $"Some content here{(hasError ? " ERROR[123]" : "")}");
        }
        return buffer;
    }

    // ========== Plain Text Search ==========

    [Benchmark]
    public async Task Search_PlainText_1kLines()
    {
        await _searchService.SearchAsync(
            _smallBuffer,
            "error",
            new TerminalSearchOptions());
    }

    [Benchmark]
    public async Task Search_PlainText_10kLines()
    {
        await _searchService.SearchAsync(
            _mediumBuffer,
            "error",
            new TerminalSearchOptions());
    }

    [Benchmark]
    public async Task Search_PlainText_100kLines()
    {
        await _searchService.SearchAsync(
            _largeBuffer,
            "error",
            new TerminalSearchOptions());
    }

    // ========== Regex Search ==========

    [Benchmark]
    public async Task Search_Regex_10kLines()
    {
        await _searchService.SearchAsync(
            _mediumBuffer,
            @"ERROR\[\d+\]",
            new TerminalSearchOptions { DefaultUseRegex = true });
    }

    [Benchmark]
    public async Task Search_Regex_100kLines()
    {
        await _searchService.SearchAsync(
            _largeBuffer,
            @"ERROR\[\d+\]",
            new TerminalSearchOptions { DefaultUseRegex = true });
    }

    // ========== Case Sensitive ==========

    [Benchmark]
    public async Task Search_CaseSensitive_100kLines()
    {
        await _searchService.SearchAsync(
            _largeBuffer,
            "ERROR",
            new TerminalSearchOptions { DefaultCaseSensitive = true });
    }
}
```

---

## File Summary

### Files to Create

| File | Location | Purpose |
|------|----------|---------|
| `TerminalSearchTests.cs` | `Tests.Integration/Terminal/` | Search tests |
| `KeyboardShortcutTests.cs` | `Tests.Integration/Terminal/` | Shortcut tests |
| `TerminalSettingsTests.cs` | `Tests.Integration/Terminal/` | Settings tests |
| `TerminalHistoryTests.cs` | `Tests.Integration/Terminal/` | History tests |
| `CrossPlatformTerminalTests.cs` | `Tests.Integration/Terminal/` | Platform tests |
| `MockTerminalBuffer.cs` | `Tests.Integration/Mocks/` | Buffer mock |
| `MockSettingsService.cs` | `Tests.Integration/Mocks/` | Settings mock |
| `TestAppDbContext.cs` | `Tests.Integration/Mocks/` | DB mock |
| `TerminalSearchBenchmarks.cs` | `Tests.Performance/` | Benchmarks |

---

## Test Count Summary

| Test Class | Test Count |
|------------|------------|
| TerminalSearchTests | 14 |
| KeyboardShortcutTests | 12 |
| TerminalSettingsTests | 12 |
| TerminalHistoryTests | 13 |
| CrossPlatformTerminalTests | 7 |
| **Total Integration Tests** | **58** |
| **Total Benchmarks** | **6** |

---

## Verification

```bash
# Build test projects
dotnet build tests/AIntern.Tests.Integration
dotnet build tests/AIntern.Tests.Performance

# Run all integration tests
dotnet test tests/AIntern.Tests.Integration --logger "console;verbosity=normal"

# Run specific test class
dotnet test --filter "FullyQualifiedName~TerminalSearchTests"

# Run with coverage
dotnet test tests/AIntern.Tests.Integration \
  --collect:"XPlat Code Coverage" \
  --results-directory ./coverage

# Generate coverage report
reportgenerator -reports:./coverage/**/coverage.cobertura.xml \
  -targetdir:./coverage/report -reporttypes:Html

# Run performance benchmarks
cd tests/AIntern.Tests.Performance
dotnet run -c Release
```

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | All TerminalSearchTests pass |
| AC-2 | All KeyboardShortcutTests pass |
| AC-3 | All TerminalSettingsTests pass |
| AC-4 | All TerminalHistoryTests pass |
| AC-5 | All CrossPlatformTests pass on target OS |
| AC-6 | TerminalSearchService coverage ≥ 90% |
| AC-7 | KeyboardShortcutService coverage ≥ 85% |
| AC-8 | TerminalHistoryService coverage ≥ 85% |
| AC-9 | Overall integration coverage ≥ 85% |
| AC-10 | Search 100k lines < 5 seconds |
| AC-11 | No test depends on real file system state |
| AC-12 | All tests isolated (no shared state) |

---

## Changelog Entry

```markdown
## v0.5.5j - Integration Testing

### Added
- `TerminalSearchTests` (14 tests):
  - Plain text and regex search
  - Case sensitivity
  - Navigation wrap-around
  - Cancellation handling
  - Large buffer performance

- `KeyboardShortcutTests` (12 tests):
  - Default bindings
  - Binding updates and conflicts
  - Reset functionality
  - Persistence verification

- `TerminalSettingsTests` (12 tests):
  - Default values validation
  - Theme color mapping
  - Clone deep copy
  - Validation error detection

- `TerminalHistoryTests` (13 tests):
  - CRUD operations
  - Search functionality
  - Clear and cleanup
  - Export formats

- `CrossPlatformTerminalTests` (7 tests):
  - Platform-specific font defaults
  - Path separator handling
  - Keyboard display strings

- Test Mocks:
  - `MockTerminalBuffer`
  - `MockSettingsService`
  - `TestAppDbContext` (in-memory)

- Performance Benchmarks:
  - Search benchmarks (1k, 10k, 100k lines)
  - Regex vs plain text comparison

### Coverage
- TerminalSearchService: 90%+
- KeyboardShortcutService: 85%+
- TerminalHistoryService: 85%+
- Overall: 85%+
```

---

## Timeline Estimate

| Version | Estimated Effort |
|---------|------------------|
| v0.5.5j | 1.5 days |
