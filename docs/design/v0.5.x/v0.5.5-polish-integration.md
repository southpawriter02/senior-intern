# Design Specification: AIntern v0.5.5 "Polish & Integration"

## Executive Summary

This document provides a comprehensive design specification for v0.5.5, the final phase of the integrated terminal feature for The Senior Intern. This sub-version delivers the polish and integration layer that transforms the terminal from a functional component into a fully-featured, user-friendly experience. Key deliverables include terminal search functionality with regex support, comprehensive keyboard shortcuts, a terminal settings panel for customization, shell profile editing UI, status bar integration, history management, and end-to-end integration testing.

### v0.5.5 Scope (from v0.5.0 Design Document)
- Terminal search functionality with case-sensitive and regex options
- Comprehensive keyboard shortcut system covering all terminal operations
- Terminal settings panel for appearance and behavior customization
- Shell profile editor UI for managing shell configurations
- Status bar terminal integration showing active session info
- Terminal history management and persistence
- End-to-end integration testing across all terminal features

---

## Sub-Part Breakdown

| Part | Name | Focus |
|------|------|-------|
| v0.5.5a | Terminal Search Models | Search result models, search state, match highlighting |
| v0.5.5b | Terminal Search Service | Search implementation, regex support, result navigation |
| v0.5.5c | Terminal Search UI | Search bar component, keyboard navigation, visual feedback |
| v0.5.5d | Keyboard Shortcuts System | Shortcut registry, action mapping, platform-specific bindings |
| v0.5.5e | Terminal Settings Models | Settings definitions, persistence, defaults |
| v0.5.5f | Terminal Settings Panel | Settings UI, live preview, validation |
| v0.5.5g | Shell Profile Editor | Profile CRUD UI, validation, import/export |
| v0.5.5h | Status Bar Integration | Terminal status display, quick actions, notifications |
| v0.5.5i | History Management | Command history, session history, persistence |
| v0.5.5j | Integration Testing | E2E tests, cross-platform tests, performance benchmarks |

---

## v0.5.5a: Terminal Search Models

### Objective
Define the data models for terminal search functionality, including search results, search state management, and match highlighting configuration.

### TerminalSearchResult Model

```csharp
namespace SeniorIntern.Core.Models.Terminal;

/// <summary>
/// Represents a single search result within the terminal buffer
/// </summary>
public sealed class TerminalSearchResult
{
    /// <summary>
    /// The line index in the terminal buffer (0-based, including scrollback)
    /// </summary>
    public int LineIndex { get; init; }

    /// <summary>
    /// The starting column of the match (0-based)
    /// </summary>
    public int StartColumn { get; init; }

    /// <summary>
    /// The length of the matched text
    /// </summary>
    public int Length { get; init; }

    /// <summary>
    /// The actual matched text content
    /// </summary>
    public string MatchedText { get; init; } = string.Empty;

    /// <summary>
    /// The full line content for context display
    /// </summary>
    public string LineContent { get; init; } = string.Empty;

    /// <summary>
    /// Whether this result is the currently selected/focused result
    /// </summary>
    public bool IsCurrent { get; set; }

    /// <summary>
    /// Ending column (exclusive) for rendering convenience
    /// </summary>
    public int EndColumn => StartColumn + Length;
}
```

### TerminalSearchState Model

```csharp
namespace SeniorIntern.Core.Models.Terminal;

/// <summary>
/// Maintains the current state of terminal search
/// </summary>
public sealed class TerminalSearchState
{
    /// <summary>
    /// The current search query
    /// </summary>
    public string Query { get; set; } = string.Empty;

    /// <summary>
    /// Whether the search should be case-sensitive
    /// </summary>
    public bool CaseSensitive { get; set; }

    /// <summary>
    /// Whether to interpret the query as a regular expression
    /// </summary>
    public bool UseRegex { get; set; }

    /// <summary>
    /// Whether to wrap around when navigating past the last/first result
    /// </summary>
    public bool WrapAround { get; set; } = true;

    /// <summary>
    /// Whether to search in scrollback buffer or only visible content
    /// </summary>
    public bool IncludeScrollback { get; set; } = true;

    /// <summary>
    /// All found search results
    /// </summary>
    public IReadOnlyList<TerminalSearchResult> Results { get; set; } = Array.Empty<TerminalSearchResult>();

    /// <summary>
    /// Index of the currently selected result (-1 if none)
    /// </summary>
    public int CurrentResultIndex { get; set; } = -1;

    /// <summary>
    /// Whether a search is currently in progress
    /// </summary>
    public bool IsSearching { get; set; }

    /// <summary>
    /// Error message if regex is invalid
    /// </summary>
    public string? ErrorMessage { get; set; }

    /// <summary>
    /// Gets the currently selected result, if any
    /// </summary>
    public TerminalSearchResult? CurrentResult =>
        CurrentResultIndex >= 0 && CurrentResultIndex < Results.Count
            ? Results[CurrentResultIndex]
            : null;

    /// <summary>
    /// Whether there are any results
    /// </summary>
    public bool HasResults => Results.Count > 0;

    /// <summary>
    /// Human-readable results summary (e.g., "3 of 15")
    /// </summary>
    public string ResultsSummary =>
        HasResults
            ? $"{CurrentResultIndex + 1} of {Results.Count}"
            : Results.Count == 0 && !string.IsNullOrEmpty(Query)
                ? "No results"
                : string.Empty;
}
```

### TerminalSearchOptions Model

```csharp
namespace SeniorIntern.Core.Models.Terminal;

/// <summary>
/// Options for configuring terminal search behavior
/// </summary>
public sealed class TerminalSearchOptions
{
    /// <summary>
    /// Maximum number of results to return (0 = unlimited)
    /// </summary>
    public int MaxResults { get; set; } = 10000;

    /// <summary>
    /// Debounce delay for incremental search (milliseconds)
    /// </summary>
    public int DebounceDelayMs { get; set; } = 150;

    /// <summary>
    /// Minimum query length before search starts
    /// </summary>
    public int MinQueryLength { get; set; } = 1;

    /// <summary>
    /// Default case sensitivity setting
    /// </summary>
    public bool DefaultCaseSensitive { get; set; } = false;

    /// <summary>
    /// Default regex mode setting
    /// </summary>
    public bool DefaultUseRegex { get; set; } = false;
}
```

### SearchHighlightStyle Model

```csharp
namespace SeniorIntern.Core.Models.Terminal;

/// <summary>
/// Visual styling for search result highlights
/// </summary>
public sealed class SearchHighlightStyle
{
    /// <summary>
    /// Background color for matched text (hex)
    /// </summary>
    public string MatchBackground { get; set; } = "#FFFF00";

    /// <summary>
    /// Foreground color for matched text (hex)
    /// </summary>
    public string MatchForeground { get; set; } = "#000000";

    /// <summary>
    /// Background color for the currently focused match (hex)
    /// </summary>
    public string CurrentMatchBackground { get; set; } = "#FF8C00";

    /// <summary>
    /// Foreground color for the currently focused match (hex)
    /// </summary>
    public string CurrentMatchForeground { get; set; } = "#000000";

    /// <summary>
    /// Border color for the currently focused match (hex)
    /// </summary>
    public string CurrentMatchBorder { get; set; } = "#FF4500";

    /// <summary>
    /// Opacity for non-current matches (0.0-1.0)
    /// </summary>
    public double MatchOpacity { get; set; } = 0.7;
}
```

### Files to Create (v0.5.5a)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Models/Terminal/TerminalSearchResult.cs` | Search result model |
| `src/SeniorIntern.Core/Models/Terminal/TerminalSearchState.cs` | Search state model |
| `src/SeniorIntern.Core/Models/Terminal/TerminalSearchOptions.cs` | Search options |
| `src/SeniorIntern.Core/Models/Terminal/SearchHighlightStyle.cs` | Highlight styling |

### Implementation Notes
- All models should be immutable where possible using `init` accessors
- Consider using records for simpler models
- Include XML documentation for all public members
- Ensure proper null handling for optional properties

---

## v0.5.5b: Terminal Search Service

### Objective
Implement the terminal search service that provides efficient text search within the terminal buffer, supporting plain text and regex patterns with incremental search capabilities.

### ITerminalSearchService Interface

```csharp
namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Service for searching within terminal content
/// </summary>
public interface ITerminalSearchService
{
    /// <summary>
    /// Search for a pattern in the terminal buffer
    /// </summary>
    /// <param name="buffer">The terminal buffer to search</param>
    /// <param name="query">The search query</param>
    /// <param name="options">Search options</param>
    /// <param name="ct">Cancellation token</param>
    /// <returns>Search results</returns>
    Task<TerminalSearchState> SearchAsync(
        ITerminalBuffer buffer,
        string query,
        TerminalSearchOptions options,
        CancellationToken ct = default);

    /// <summary>
    /// Navigate to the next search result
    /// </summary>
    /// <param name="state">Current search state</param>
    /// <returns>Updated search state with new current index</returns>
    TerminalSearchState NavigateNext(TerminalSearchState state);

    /// <summary>
    /// Navigate to the previous search result
    /// </summary>
    /// <param name="state">Current search state</param>
    /// <returns>Updated search state with new current index</returns>
    TerminalSearchState NavigatePrevious(TerminalSearchState state);

    /// <summary>
    /// Navigate to a specific result by index
    /// </summary>
    /// <param name="state">Current search state</param>
    /// <param name="index">Target result index</param>
    /// <returns>Updated search state</returns>
    TerminalSearchState NavigateToIndex(TerminalSearchState state, int index);

    /// <summary>
    /// Clear the current search state
    /// </summary>
    /// <returns>Empty search state</returns>
    TerminalSearchState ClearSearch();

    /// <summary>
    /// Validate a regex pattern
    /// </summary>
    /// <param name="pattern">The regex pattern to validate</param>
    /// <returns>Error message if invalid, null if valid</returns>
    string? ValidateRegexPattern(string pattern);
}
```

### TerminalSearchService Implementation

```csharp
namespace SeniorIntern.Services;

using System.Text.RegularExpressions;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models.Terminal;

/// <summary>
/// Service for searching within terminal content
/// </summary>
public sealed class TerminalSearchService : ITerminalSearchService
{
    private readonly ILogger<TerminalSearchService> _logger;

    public TerminalSearchService(ILogger<TerminalSearchService> logger)
    {
        _logger = logger;
    }

    public async Task<TerminalSearchState> SearchAsync(
        ITerminalBuffer buffer,
        string query,
        TerminalSearchOptions options,
        CancellationToken ct = default)
    {
        if (string.IsNullOrEmpty(query) || query.Length < options.MinQueryLength)
        {
            return new TerminalSearchState { Query = query };
        }

        var state = new TerminalSearchState
        {
            Query = query,
            CaseSensitive = options.DefaultCaseSensitive,
            UseRegex = options.DefaultUseRegex,
            IsSearching = true
        };

        try
        {
            // Validate regex if needed
            if (state.UseRegex)
            {
                var error = ValidateRegexPattern(query);
                if (error != null)
                {
                    return state with { ErrorMessage = error, IsSearching = false };
                }
            }

            var results = await Task.Run(() =>
                PerformSearch(buffer, query, state.CaseSensitive, state.UseRegex, options.MaxResults),
                ct);

            return state with
            {
                Results = results,
                CurrentResultIndex = results.Count > 0 ? 0 : -1,
                IsSearching = false
            };
        }
        catch (OperationCanceledException)
        {
            throw;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Search failed for query: {Query}", query);
            return state with { ErrorMessage = ex.Message, IsSearching = false };
        }
    }

    private List<TerminalSearchResult> PerformSearch(
        ITerminalBuffer buffer,
        string query,
        bool caseSensitive,
        bool useRegex,
        int maxResults)
    {
        var results = new List<TerminalSearchResult>();
        var comparison = caseSensitive
            ? StringComparison.Ordinal
            : StringComparison.OrdinalIgnoreCase;

        Regex? regex = null;
        if (useRegex)
        {
            var options = caseSensitive ? RegexOptions.None : RegexOptions.IgnoreCase;
            options |= RegexOptions.Compiled;
            regex = new Regex(query, options, TimeSpan.FromSeconds(5));
        }

        int lineCount = buffer.TotalLineCount;

        for (int lineIndex = 0; lineIndex < lineCount && results.Count < maxResults; lineIndex++)
        {
            var lineContent = buffer.GetLine(lineIndex);
            if (string.IsNullOrEmpty(lineContent)) continue;

            if (useRegex && regex != null)
            {
                var matches = regex.Matches(lineContent);
                foreach (Match match in matches)
                {
                    if (results.Count >= maxResults) break;

                    results.Add(new TerminalSearchResult
                    {
                        LineIndex = lineIndex,
                        StartColumn = match.Index,
                        Length = match.Length,
                        MatchedText = match.Value,
                        LineContent = lineContent
                    });
                }
            }
            else
            {
                int startIndex = 0;
                int index;

                while ((index = lineContent.IndexOf(query, startIndex, comparison)) >= 0)
                {
                    if (results.Count >= maxResults) break;

                    results.Add(new TerminalSearchResult
                    {
                        LineIndex = lineIndex,
                        StartColumn = index,
                        Length = query.Length,
                        MatchedText = lineContent.Substring(index, query.Length),
                        LineContent = lineContent
                    });

                    startIndex = index + 1;
                }
            }
        }

        return results;
    }

    public TerminalSearchState NavigateNext(TerminalSearchState state)
    {
        if (!state.HasResults) return state;

        var newIndex = state.CurrentResultIndex + 1;
        if (newIndex >= state.Results.Count)
        {
            newIndex = state.WrapAround ? 0 : state.Results.Count - 1;
        }

        return state with { CurrentResultIndex = newIndex };
    }

    public TerminalSearchState NavigatePrevious(TerminalSearchState state)
    {
        if (!state.HasResults) return state;

        var newIndex = state.CurrentResultIndex - 1;
        if (newIndex < 0)
        {
            newIndex = state.WrapAround ? state.Results.Count - 1 : 0;
        }

        return state with { CurrentResultIndex = newIndex };
    }

    public TerminalSearchState NavigateToIndex(TerminalSearchState state, int index)
    {
        if (!state.HasResults) return state;

        var clampedIndex = Math.Clamp(index, 0, state.Results.Count - 1);
        return state with { CurrentResultIndex = clampedIndex };
    }

    public TerminalSearchState ClearSearch()
    {
        return new TerminalSearchState();
    }

    public string? ValidateRegexPattern(string pattern)
    {
        try
        {
            _ = new Regex(pattern, RegexOptions.None, TimeSpan.FromSeconds(1));
            return null;
        }
        catch (ArgumentException ex)
        {
            return $"Invalid regex: {ex.Message}";
        }
        catch (RegexMatchTimeoutException)
        {
            return "Regex pattern is too complex";
        }
    }
}
```

### ITerminalBuffer Extension for Search

```csharp
namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Extension to ITerminalBuffer for search support
/// </summary>
public partial interface ITerminalBuffer
{
    /// <summary>
    /// Total number of lines including scrollback
    /// </summary>
    int TotalLineCount { get; }

    /// <summary>
    /// Get the text content of a specific line
    /// </summary>
    /// <param name="lineIndex">Line index (0-based, including scrollback)</param>
    /// <returns>Line text content</returns>
    string GetLine(int lineIndex);

    /// <summary>
    /// Get a range of lines as text
    /// </summary>
    /// <param name="startLine">Starting line index</param>
    /// <param name="count">Number of lines to retrieve</param>
    /// <returns>Line contents</returns>
    IEnumerable<string> GetLines(int startLine, int count);
}
```

### Files to Create (v0.5.5b)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/ITerminalSearchService.cs` | Search service interface |
| `src/SeniorIntern.Services/Terminal/TerminalSearchService.cs` | Search implementation |

### Files to Modify (v0.5.5b)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/ITerminalBuffer.cs` | Add search-related methods |
| `src/SeniorIntern.Services/ServiceCollectionExtensions.cs` | Register search service |

### Implementation Notes
- Use `Regex` with timeout to prevent catastrophic backtracking
- Implement incremental search with debouncing in the ViewModel layer
- Consider caching results when buffer hasn't changed
- Search should run on a background thread to avoid blocking UI
- Support cancellation for long-running searches

---

## v0.5.5c: Terminal Search UI

### Objective
Create the terminal search bar UI component with keyboard navigation, visual feedback for results, and integration with the terminal panel.

### TerminalSearchBarViewModel

```csharp
namespace SeniorIntern.Desktop.ViewModels;

using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models.Terminal;

/// <summary>
/// ViewModel for the terminal search bar
/// </summary>
public partial class TerminalSearchBarViewModel : ViewModelBase
{
    private readonly ITerminalSearchService _searchService;
    private readonly ITerminalBuffer _buffer;
    private CancellationTokenSource? _searchCts;
    private readonly Timer _debounceTimer;

    [ObservableProperty]
    private string _searchQuery = string.Empty;

    [ObservableProperty]
    private bool _isSearchVisible;

    [ObservableProperty]
    private bool _caseSensitive;

    [ObservableProperty]
    private bool _useRegex;

    [ObservableProperty]
    private TerminalSearchState _searchState = new();

    [ObservableProperty]
    private bool _isSearching;

    [ObservableProperty]
    private string _searchResultsText = string.Empty;

    [ObservableProperty]
    private string? _errorMessage;

    public TerminalSearchBarViewModel(
        ITerminalSearchService searchService,
        ITerminalBuffer buffer)
    {
        _searchService = searchService;
        _buffer = buffer;
        _debounceTimer = new Timer(OnDebounceTimerElapsed, null, Timeout.Infinite, Timeout.Infinite);
    }

    partial void OnSearchQueryChanged(string value)
    {
        // Reset debounce timer
        _debounceTimer.Change(150, Timeout.Infinite);
    }

    partial void OnCaseSensitiveChanged(bool value) => TriggerSearch();
    partial void OnUseRegexChanged(bool value) => TriggerSearch();

    private void OnDebounceTimerElapsed(object? state)
    {
        Dispatcher.UIThread.Post(() => TriggerSearch());
    }

    private async void TriggerSearch()
    {
        // Cancel any pending search
        _searchCts?.Cancel();
        _searchCts = new CancellationTokenSource();

        try
        {
            var options = new TerminalSearchOptions
            {
                DefaultCaseSensitive = CaseSensitive,
                DefaultUseRegex = UseRegex
            };

            IsSearching = true;
            ErrorMessage = null;

            SearchState = await _searchService.SearchAsync(
                _buffer,
                SearchQuery,
                options,
                _searchCts.Token);

            UpdateResultsText();
            ErrorMessage = SearchState.ErrorMessage;

            // Notify parent to scroll to result
            if (SearchState.CurrentResult != null)
            {
                ScrollToResultRequested?.Invoke(this, SearchState.CurrentResult);
            }
        }
        catch (OperationCanceledException)
        {
            // Search was cancelled, ignore
        }
        finally
        {
            IsSearching = false;
        }
    }

    private void UpdateResultsText()
    {
        SearchResultsText = SearchState.ResultsSummary;
    }

    [RelayCommand]
    private void NextSearchResult()
    {
        SearchState = _searchService.NavigateNext(SearchState);
        UpdateResultsText();

        if (SearchState.CurrentResult != null)
        {
            ScrollToResultRequested?.Invoke(this, SearchState.CurrentResult);
        }
    }

    [RelayCommand]
    private void PreviousSearchResult()
    {
        SearchState = _searchService.NavigatePrevious(SearchState);
        UpdateResultsText();

        if (SearchState.CurrentResult != null)
        {
            ScrollToResultRequested?.Invoke(this, SearchState.CurrentResult);
        }
    }

    [RelayCommand]
    private void CloseSearch()
    {
        IsSearchVisible = false;
        SearchQuery = string.Empty;
        SearchState = _searchService.ClearSearch();
        UpdateResultsText();

        SearchClosed?.Invoke(this, EventArgs.Empty);
    }

    [RelayCommand]
    private void ToggleCaseSensitive()
    {
        CaseSensitive = !CaseSensitive;
    }

    [RelayCommand]
    private void ToggleRegex()
    {
        UseRegex = !UseRegex;
    }

    public void OpenSearch()
    {
        IsSearchVisible = true;
        SearchOpened?.Invoke(this, EventArgs.Empty);
    }

    /// <summary>
    /// Event raised when the terminal should scroll to a search result
    /// </summary>
    public event EventHandler<TerminalSearchResult>? ScrollToResultRequested;

    /// <summary>
    /// Event raised when search is opened
    /// </summary>
    public event EventHandler? SearchOpened;

    /// <summary>
    /// Event raised when search is closed
    /// </summary>
    public event EventHandler? SearchClosed;
}
```

### TerminalSearchBar.axaml

```xml
<!-- src/SeniorIntern.Desktop/Views/TerminalSearchBar.axaml -->
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:vm="using:SeniorIntern.Desktop.ViewModels"
             x:Class="SeniorIntern.Desktop.Views.TerminalSearchBar"
             x:DataType="vm:TerminalSearchBarViewModel">

    <UserControl.Styles>
        <Style Selector="Border.terminal-search-bar">
            <Setter Property="Background" Value="{DynamicResource SurfaceColor}" />
            <Setter Property="BorderBrush" Value="{DynamicResource BorderColor}" />
            <Setter Property="BorderThickness" Value="1" />
            <Setter Property="CornerRadius" Value="4" />
            <Setter Property="Padding" Value="8" />
            <Setter Property="BoxShadow" Value="0 2 8 0 #40000000" />
        </Style>

        <Style Selector="ToggleButton.search-option">
            <Setter Property="Background" Value="Transparent" />
            <Setter Property="Padding" Value="4" />
            <Setter Property="Width" Value="28" />
            <Setter Property="Height" Value="28" />
        </Style>

        <Style Selector="ToggleButton.search-option:checked">
            <Setter Property="Background" Value="{DynamicResource AccentColorLight}" />
        </Style>

        <Style Selector="TextBox.search-input">
            <Setter Property="MinWidth" Value="200" />
        </Style>

        <Style Selector="TextBlock.error-text">
            <Setter Property="Foreground" Value="{DynamicResource ErrorColor}" />
            <Setter Property="FontSize" Value="11" />
        </Style>
    </UserControl.Styles>

    <Border Classes="terminal-search-bar"
            IsVisible="{Binding IsSearchVisible}"
            HorizontalAlignment="Right"
            VerticalAlignment="Top"
            Margin="16">

        <StackPanel Spacing="4">
            <Grid ColumnDefinitions="*, Auto, Auto, Auto, Auto, Auto, Auto, Auto"
                  RowDefinitions="Auto">

                <!-- Search Input -->
                <TextBox x:Name="SearchTextBox"
                         Classes="search-input"
                         Text="{Binding SearchQuery}"
                         Watermark="Search in terminal..."
                         KeyDown="OnSearchKeyDown">
                    <TextBox.InnerRightContent>
                        <StackPanel Orientation="Horizontal" Spacing="2" Margin="4,0">
                            <!-- Loading Indicator -->
                            <PathIcon Data="{StaticResource SpinnerIcon}"
                                      Width="14" Height="14"
                                      IsVisible="{Binding IsSearching}"
                                      Classes="spinning" />
                        </StackPanel>
                    </TextBox.InnerRightContent>
                </TextBox>

                <!-- Results Counter -->
                <TextBlock Grid.Column="1"
                           Text="{Binding SearchResultsText}"
                           VerticalAlignment="Center"
                           Margin="8,0"
                           MinWidth="60"
                           Foreground="{DynamicResource TextMuted}" />

                <!-- Case Sensitive Toggle -->
                <ToggleButton Grid.Column="2"
                              Classes="search-option"
                              IsChecked="{Binding CaseSensitive}"
                              ToolTip.Tip="Match Case (Alt+C)">
                    <TextBlock Text="Aa" FontSize="12" FontWeight="SemiBold" />
                </ToggleButton>

                <!-- Regex Toggle -->
                <ToggleButton Grid.Column="3"
                              Classes="search-option"
                              IsChecked="{Binding UseRegex}"
                              ToolTip.Tip="Use Regular Expression (Alt+R)">
                    <TextBlock Text=".*" FontSize="12" FontFamily="Consolas, monospace" />
                </ToggleButton>

                <!-- Previous Result -->
                <Button Grid.Column="4"
                        Classes="icon-button"
                        Command="{Binding PreviousSearchResultCommand}"
                        IsEnabled="{Binding SearchState.HasResults}"
                        ToolTip.Tip="Previous Match (Shift+Enter)">
                    <PathIcon Data="{StaticResource ChevronUpIcon}" Width="14" Height="14" />
                </Button>

                <!-- Next Result -->
                <Button Grid.Column="5"
                        Classes="icon-button"
                        Command="{Binding NextSearchResultCommand}"
                        IsEnabled="{Binding SearchState.HasResults}"
                        ToolTip.Tip="Next Match (Enter)">
                    <PathIcon Data="{StaticResource ChevronDownIcon}" Width="14" Height="14" />
                </Button>

                <!-- Separator -->
                <Border Grid.Column="6"
                        Width="1"
                        Height="20"
                        Background="{DynamicResource BorderColor}"
                        Margin="4,0" />

                <!-- Close -->
                <Button Grid.Column="7"
                        Classes="icon-button"
                        Command="{Binding CloseSearchCommand}"
                        ToolTip.Tip="Close (Escape)">
                    <PathIcon Data="{StaticResource CloseIcon}" Width="14" Height="14" />
                </Button>
            </Grid>

            <!-- Error Message -->
            <TextBlock Classes="error-text"
                       Text="{Binding ErrorMessage}"
                       IsVisible="{Binding ErrorMessage, Converter={x:Static StringConverters.IsNotNullOrEmpty}}"
                       TextWrapping="Wrap"
                       MaxWidth="350" />
        </StackPanel>
    </Border>
</UserControl>
```

### TerminalSearchBar.axaml.cs (Code-Behind)

```csharp
namespace SeniorIntern.Desktop.Views;

using Avalonia.Controls;
using Avalonia.Input;
using Avalonia.Interactivity;
using SeniorIntern.Desktop.ViewModels;

public partial class TerminalSearchBar : UserControl
{
    public TerminalSearchBar()
    {
        InitializeComponent();
    }

    private void OnSearchKeyDown(object? sender, KeyEventArgs e)
    {
        if (DataContext is not TerminalSearchBarViewModel vm) return;

        switch (e.Key)
        {
            case Key.Enter when e.KeyModifiers.HasFlag(KeyModifiers.Shift):
                vm.PreviousSearchResultCommand.Execute(null);
                e.Handled = true;
                break;

            case Key.Enter:
                vm.NextSearchResultCommand.Execute(null);
                e.Handled = true;
                break;

            case Key.Escape:
                vm.CloseSearchCommand.Execute(null);
                e.Handled = true;
                break;

            case Key.C when e.KeyModifiers.HasFlag(KeyModifiers.Alt):
                vm.ToggleCaseSensitiveCommand.Execute(null);
                e.Handled = true;
                break;

            case Key.R when e.KeyModifiers.HasFlag(KeyModifiers.Alt):
                vm.ToggleRegexCommand.Execute(null);
                e.Handled = true;
                break;
        }
    }

    public void FocusSearchInput()
    {
        SearchTextBox.Focus();
        SearchTextBox.SelectAll();
    }
}
```

### Search Result Highlighting in TerminalRenderer

```csharp
// Add to TerminalRenderer.cs

/// <summary>
/// Renders search result highlights on the terminal
/// </summary>
private void RenderSearchHighlights(
    SKCanvas canvas,
    TerminalSearchState searchState,
    int viewportStartLine,
    int viewportEndLine)
{
    if (!searchState.HasResults) return;

    var style = _theme.SearchHighlightStyle;

    using var matchPaint = new SKPaint
    {
        Color = SKColor.Parse(style.MatchBackground).WithAlpha((byte)(255 * style.MatchOpacity)),
        Style = SKPaintStyle.Fill
    };

    using var currentMatchPaint = new SKPaint
    {
        Color = SKColor.Parse(style.CurrentMatchBackground),
        Style = SKPaintStyle.Fill
    };

    using var currentMatchBorderPaint = new SKPaint
    {
        Color = SKColor.Parse(style.CurrentMatchBorder),
        Style = SKPaintStyle.Stroke,
        StrokeWidth = 2
    };

    foreach (var result in searchState.Results)
    {
        // Skip results outside viewport
        if (result.LineIndex < viewportStartLine || result.LineIndex > viewportEndLine)
            continue;

        var isCurrent = result == searchState.CurrentResult;
        var y = (result.LineIndex - viewportStartLine) * _cellHeight;
        var x = result.StartColumn * _cellWidth;
        var width = result.Length * _cellWidth;

        var rect = new SKRect(x, y, x + width, y + _cellHeight);

        // Draw highlight
        canvas.DrawRect(rect, isCurrent ? currentMatchPaint : matchPaint);

        // Draw border for current match
        if (isCurrent)
        {
            canvas.DrawRect(rect, currentMatchBorderPaint);
        }
    }
}
```

### Files to Create (v0.5.5c)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/Views/TerminalSearchBar.axaml` | Search bar UI |
| `src/SeniorIntern.Desktop/Views/TerminalSearchBar.axaml.cs` | Search bar code-behind |
| `src/SeniorIntern.Desktop/ViewModels/TerminalSearchBarViewModel.cs` | Search bar ViewModel |

### Files to Modify (v0.5.5c)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/Controls/TerminalRenderer.cs` | Add search highlight rendering |
| `src/SeniorIntern.Desktop/Views/TerminalPanel.axaml` | Include search bar |
| `src/SeniorIntern.Desktop/ViewModels/TerminalPanelViewModel.cs` | Integrate search VM |

### Implementation Notes
- Focus the search input when opened (Ctrl+F)
- Support keyboard navigation (Enter/Shift+Enter for next/previous)
- Show result count and current position
- Visual indicator for current match
- Scroll terminal to show current result
- Debounce search input to avoid excessive searches

---

## v0.5.5d: Keyboard Shortcuts System

### Objective
Implement a comprehensive keyboard shortcuts system that handles all terminal-related shortcuts with proper key binding registration, platform-specific mappings, and conflict resolution.

### TerminalShortcutAction Enum

```csharp
namespace SeniorIntern.Core.Models.Terminal;

/// <summary>
/// All available terminal keyboard shortcut actions
/// </summary>
public enum TerminalShortcutAction
{
    // Terminal Panel
    ToggleTerminal,
    NewTerminal,
    CloseTerminal,
    PreviousTerminalTab,
    NextTerminalTab,
    SwitchToTerminal1,
    SwitchToTerminal2,
    SwitchToTerminal3,
    SwitchToTerminal4,
    SwitchToTerminal5,
    SwitchToTerminal6,
    SwitchToTerminal7,
    SwitchToTerminal8,
    SwitchToTerminal9,

    // Terminal Input (passed to PTY)
    SendInterrupt,      // Ctrl+C -> SIGINT
    SendSuspend,        // Ctrl+Z -> SIGTSTP
    SendEof,            // Ctrl+D -> EOF
    ClearTerminal,      // Ctrl+L
    ClearLineBefore,    // Ctrl+U
    ClearLineAfter,     // Ctrl+K
    DeleteWordBefore,   // Ctrl+W
    MoveToLineStart,    // Ctrl+A
    MoveToLineEnd,      // Ctrl+E

    // Terminal Search
    OpenSearch,
    CloseSearch,
    NextSearchResult,
    PreviousSearchResult,

    // Terminal Selection
    Copy,
    Paste,
    SelectAll,

    // Terminal Scroll
    ScrollPageUp,
    ScrollPageDown,
    ScrollToTop,
    ScrollToBottom,
    ScrollLineUp,
    ScrollLineDown,

    // Command Blocks
    ExecuteCommand,
    SendToTerminal
}
```

### KeyBinding Model

```csharp
namespace SeniorIntern.Core.Models.Terminal;

/// <summary>
/// Represents a keyboard shortcut binding
/// </summary>
public sealed class KeyBinding
{
    /// <summary>
    /// The action this binding triggers
    /// </summary>
    public TerminalShortcutAction Action { get; init; }

    /// <summary>
    /// Primary key
    /// </summary>
    public Key Key { get; init; }

    /// <summary>
    /// Required modifier keys
    /// </summary>
    public KeyModifiers Modifiers { get; init; }

    /// <summary>
    /// Human-readable description of the shortcut
    /// </summary>
    public string Description { get; init; } = string.Empty;

    /// <summary>
    /// Category for grouping in settings UI
    /// </summary>
    public string Category { get; init; } = string.Empty;

    /// <summary>
    /// Whether this binding can be customized by the user
    /// </summary>
    public bool IsCustomizable { get; init; } = true;

    /// <summary>
    /// Whether this shortcut is intercepted or passed to PTY
    /// </summary>
    public bool PassToPty { get; init; }

    /// <summary>
    /// Formatted shortcut string for display (e.g., "Ctrl+Shift+C")
    /// </summary>
    public string DisplayString => FormatKeyBinding();

    private string FormatKeyBinding()
    {
        var parts = new List<string>();

        if (Modifiers.HasFlag(KeyModifiers.Control))
            parts.Add(OperatingSystem.IsMacOS() ? "⌘" : "Ctrl");
        if (Modifiers.HasFlag(KeyModifiers.Alt))
            parts.Add(OperatingSystem.IsMacOS() ? "⌥" : "Alt");
        if (Modifiers.HasFlag(KeyModifiers.Shift))
            parts.Add(OperatingSystem.IsMacOS() ? "⇧" : "Shift");

        parts.Add(FormatKey(Key));

        return string.Join("+", parts);
    }

    private static string FormatKey(Key key) => key switch
    {
        Key.OemTilde => "`",
        Key.PageUp => "PgUp",
        Key.PageDown => "PgDn",
        _ => key.ToString()
    };
}
```

### IKeyboardShortcutService Interface

```csharp
namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Service for managing and handling keyboard shortcuts
/// </summary>
public interface IKeyboardShortcutService
{
    /// <summary>
    /// Get all registered keyboard bindings
    /// </summary>
    IReadOnlyList<KeyBinding> GetAllBindings();

    /// <summary>
    /// Get bindings for a specific category
    /// </summary>
    IReadOnlyList<KeyBinding> GetBindingsByCategory(string category);

    /// <summary>
    /// Try to match a key event to an action
    /// </summary>
    /// <param name="key">The pressed key</param>
    /// <param name="modifiers">Active modifier keys</param>
    /// <param name="action">The matched action, if any</param>
    /// <returns>True if a binding was matched</returns>
    bool TryGetAction(Key key, KeyModifiers modifiers, out TerminalShortcutAction action);

    /// <summary>
    /// Update a custom key binding
    /// </summary>
    /// <param name="action">The action to rebind</param>
    /// <param name="key">New key</param>
    /// <param name="modifiers">New modifiers</param>
    /// <returns>True if binding was updated</returns>
    bool UpdateBinding(TerminalShortcutAction action, Key key, KeyModifiers modifiers);

    /// <summary>
    /// Reset a binding to its default
    /// </summary>
    void ResetBinding(TerminalShortcutAction action);

    /// <summary>
    /// Reset all bindings to defaults
    /// </summary>
    void ResetAllBindings();

    /// <summary>
    /// Check if a key combination conflicts with existing bindings
    /// </summary>
    bool HasConflict(Key key, KeyModifiers modifiers, TerminalShortcutAction? exclude = null);

    /// <summary>
    /// Get the binding that would conflict
    /// </summary>
    KeyBinding? GetConflictingBinding(Key key, KeyModifiers modifiers, TerminalShortcutAction? exclude = null);
}
```

### KeyboardShortcutService Implementation

```csharp
namespace SeniorIntern.Services;

using Avalonia.Input;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models.Terminal;

/// <summary>
/// Service for managing and handling keyboard shortcuts
/// </summary>
public sealed class KeyboardShortcutService : IKeyboardShortcutService
{
    private readonly Dictionary<(Key, KeyModifiers), KeyBinding> _bindings = new();
    private readonly Dictionary<TerminalShortcutAction, KeyBinding> _defaultBindings = new();
    private readonly ISettingsService _settingsService;

    public KeyboardShortcutService(ISettingsService settingsService)
    {
        _settingsService = settingsService;
        InitializeDefaultBindings();
        LoadCustomBindings();
    }

    private void InitializeDefaultBindings()
    {
        // Terminal Panel
        RegisterDefault(TerminalShortcutAction.ToggleTerminal,
            Key.OemTilde, KeyModifiers.Control, "Toggle Terminal", "Terminal Panel");
        RegisterDefault(TerminalShortcutAction.NewTerminal,
            Key.OemTilde, KeyModifiers.Control | KeyModifiers.Shift, "New Terminal", "Terminal Panel");
        RegisterDefault(TerminalShortcutAction.CloseTerminal,
            Key.W, KeyModifiers.Control | KeyModifiers.Shift, "Close Terminal", "Terminal Panel");
        RegisterDefault(TerminalShortcutAction.PreviousTerminalTab,
            Key.PageUp, KeyModifiers.Control, "Previous Tab", "Terminal Panel");
        RegisterDefault(TerminalShortcutAction.NextTerminalTab,
            Key.PageDown, KeyModifiers.Control, "Next Tab", "Terminal Panel");

        // Terminal tabs 1-9
        for (int i = 1; i <= 9; i++)
        {
            var action = (TerminalShortcutAction)((int)TerminalShortcutAction.SwitchToTerminal1 + i - 1);
            RegisterDefault(action,
                Key.D0 + i, KeyModifiers.Control | KeyModifiers.Shift,
                $"Switch to Terminal {i}", "Terminal Panel");
        }

        // Terminal Input (these are passed to PTY, not intercepted)
        RegisterDefault(TerminalShortcutAction.SendInterrupt,
            Key.C, KeyModifiers.Control, "Interrupt (SIGINT)", "Terminal Input", passToPty: true);
        RegisterDefault(TerminalShortcutAction.SendSuspend,
            Key.Z, KeyModifiers.Control, "Suspend (SIGTSTP)", "Terminal Input", passToPty: true);
        RegisterDefault(TerminalShortcutAction.SendEof,
            Key.D, KeyModifiers.Control, "Send EOF", "Terminal Input", passToPty: true);
        RegisterDefault(TerminalShortcutAction.ClearTerminal,
            Key.L, KeyModifiers.Control, "Clear Terminal", "Terminal Input", passToPty: true);
        RegisterDefault(TerminalShortcutAction.ClearLineBefore,
            Key.U, KeyModifiers.Control, "Clear Line Before Cursor", "Terminal Input", passToPty: true);
        RegisterDefault(TerminalShortcutAction.ClearLineAfter,
            Key.K, KeyModifiers.Control, "Clear Line After Cursor", "Terminal Input", passToPty: true);
        RegisterDefault(TerminalShortcutAction.DeleteWordBefore,
            Key.W, KeyModifiers.Control, "Delete Word Before", "Terminal Input", passToPty: true);
        RegisterDefault(TerminalShortcutAction.MoveToLineStart,
            Key.A, KeyModifiers.Control, "Move to Line Start", "Terminal Input", passToPty: true);
        RegisterDefault(TerminalShortcutAction.MoveToLineEnd,
            Key.E, KeyModifiers.Control, "Move to Line End", "Terminal Input", passToPty: true);

        // Terminal Search
        RegisterDefault(TerminalShortcutAction.OpenSearch,
            Key.F, KeyModifiers.Control, "Open Search", "Terminal Search");
        RegisterDefault(TerminalShortcutAction.CloseSearch,
            Key.Escape, KeyModifiers.None, "Close Search", "Terminal Search");
        RegisterDefault(TerminalShortcutAction.NextSearchResult,
            Key.F3, KeyModifiers.None, "Next Result", "Terminal Search");
        RegisterDefault(TerminalShortcutAction.PreviousSearchResult,
            Key.F3, KeyModifiers.Shift, "Previous Result", "Terminal Search");

        // Terminal Selection
        RegisterDefault(TerminalShortcutAction.Copy,
            Key.C, KeyModifiers.Control | KeyModifiers.Shift, "Copy", "Terminal Selection");
        RegisterDefault(TerminalShortcutAction.Paste,
            Key.V, KeyModifiers.Control | KeyModifiers.Shift, "Paste", "Terminal Selection");
        RegisterDefault(TerminalShortcutAction.SelectAll,
            Key.A, KeyModifiers.Control | KeyModifiers.Shift, "Select All", "Terminal Selection");

        // Terminal Scroll
        RegisterDefault(TerminalShortcutAction.ScrollPageUp,
            Key.PageUp, KeyModifiers.Shift, "Scroll Page Up", "Terminal Scroll");
        RegisterDefault(TerminalShortcutAction.ScrollPageDown,
            Key.PageDown, KeyModifiers.Shift, "Scroll Page Down", "Terminal Scroll");
        RegisterDefault(TerminalShortcutAction.ScrollToTop,
            Key.Home, KeyModifiers.Shift, "Scroll to Top", "Terminal Scroll");
        RegisterDefault(TerminalShortcutAction.ScrollToBottom,
            Key.End, KeyModifiers.Shift, "Scroll to Bottom", "Terminal Scroll");
        RegisterDefault(TerminalShortcutAction.ScrollLineUp,
            Key.Up, KeyModifiers.Control | KeyModifiers.Shift, "Scroll Line Up", "Terminal Scroll");
        RegisterDefault(TerminalShortcutAction.ScrollLineDown,
            Key.Down, KeyModifiers.Control | KeyModifiers.Shift, "Scroll Line Down", "Terminal Scroll");

        // Command Blocks
        RegisterDefault(TerminalShortcutAction.ExecuteCommand,
            Key.Enter, KeyModifiers.Control, "Execute Command", "Command Blocks");
        RegisterDefault(TerminalShortcutAction.SendToTerminal,
            Key.Enter, KeyModifiers.Control | KeyModifiers.Shift, "Send to Terminal", "Command Blocks");
    }

    private void RegisterDefault(
        TerminalShortcutAction action,
        Key key,
        KeyModifiers modifiers,
        string description,
        string category,
        bool passToPty = false)
    {
        var binding = new KeyBinding
        {
            Action = action,
            Key = key,
            Modifiers = modifiers,
            Description = description,
            Category = category,
            PassToPty = passToPty
        };

        _defaultBindings[action] = binding;
        _bindings[(key, modifiers)] = binding;
    }

    private void LoadCustomBindings()
    {
        var customBindings = _settingsService.CurrentSettings.CustomKeyBindings;
        if (customBindings == null) return;

        foreach (var (actionName, keyCombo) in customBindings)
        {
            if (Enum.TryParse<TerminalShortcutAction>(actionName, out var action))
            {
                var parts = keyCombo.Split('+');
                // Parse and update binding...
            }
        }
    }

    public IReadOnlyList<KeyBinding> GetAllBindings() =>
        _bindings.Values.ToList();

    public IReadOnlyList<KeyBinding> GetBindingsByCategory(string category) =>
        _bindings.Values.Where(b => b.Category == category).ToList();

    public bool TryGetAction(Key key, KeyModifiers modifiers, out TerminalShortcutAction action)
    {
        if (_bindings.TryGetValue((key, modifiers), out var binding))
        {
            action = binding.Action;
            return true;
        }

        action = default;
        return false;
    }

    public bool UpdateBinding(TerminalShortcutAction action, Key key, KeyModifiers modifiers)
    {
        if (HasConflict(key, modifiers, action)) return false;

        // Remove old binding
        var oldBinding = _bindings.Values.FirstOrDefault(b => b.Action == action);
        if (oldBinding != null)
        {
            _bindings.Remove((oldBinding.Key, oldBinding.Modifiers));
        }

        // Add new binding
        var defaultBinding = _defaultBindings[action];
        var newBinding = new KeyBinding
        {
            Action = action,
            Key = key,
            Modifiers = modifiers,
            Description = defaultBinding.Description,
            Category = defaultBinding.Category,
            PassToPty = defaultBinding.PassToPty
        };

        _bindings[(key, modifiers)] = newBinding;

        // Save to settings
        SaveCustomBindings();

        return true;
    }

    public void ResetBinding(TerminalShortcutAction action)
    {
        // Remove current binding
        var currentBinding = _bindings.Values.FirstOrDefault(b => b.Action == action);
        if (currentBinding != null)
        {
            _bindings.Remove((currentBinding.Key, currentBinding.Modifiers));
        }

        // Restore default
        var defaultBinding = _defaultBindings[action];
        _bindings[(defaultBinding.Key, defaultBinding.Modifiers)] = defaultBinding;

        SaveCustomBindings();
    }

    public void ResetAllBindings()
    {
        _bindings.Clear();
        foreach (var defaultBinding in _defaultBindings.Values)
        {
            _bindings[(defaultBinding.Key, defaultBinding.Modifiers)] = defaultBinding;
        }

        SaveCustomBindings();
    }

    public bool HasConflict(Key key, KeyModifiers modifiers, TerminalShortcutAction? exclude = null)
    {
        return GetConflictingBinding(key, modifiers, exclude) != null;
    }

    public KeyBinding? GetConflictingBinding(Key key, KeyModifiers modifiers, TerminalShortcutAction? exclude = null)
    {
        if (_bindings.TryGetValue((key, modifiers), out var binding))
        {
            if (exclude == null || binding.Action != exclude)
            {
                return binding;
            }
        }
        return null;
    }

    private void SaveCustomBindings()
    {
        var customBindings = new Dictionary<string, string>();

        foreach (var binding in _bindings.Values)
        {
            var defaultBinding = _defaultBindings[binding.Action];
            if (binding.Key != defaultBinding.Key || binding.Modifiers != defaultBinding.Modifiers)
            {
                customBindings[binding.Action.ToString()] = binding.DisplayString;
            }
        }

        _settingsService.CurrentSettings.CustomKeyBindings = customBindings;
        _settingsService.SaveSettings();
    }
}
```

### Integration with TerminalControl

```csharp
// Add to TerminalControl.axaml.cs

private readonly IKeyboardShortcutService _shortcutService;

protected override void OnKeyDown(KeyEventArgs e)
{
    if (_shortcutService.TryGetAction(e.Key, e.KeyModifiers, out var action))
    {
        var binding = _shortcutService.GetAllBindings()
            .First(b => b.Action == action);

        if (binding.PassToPty)
        {
            // Let the key pass through to PTY
            base.OnKeyDown(e);
            return;
        }

        // Handle the action
        HandleShortcutAction(action);
        e.Handled = true;
        return;
    }

    base.OnKeyDown(e);
}

private void HandleShortcutAction(TerminalShortcutAction action)
{
    switch (action)
    {
        case TerminalShortcutAction.ToggleTerminal:
            ToggleTerminalCommand.Execute(null);
            break;
        case TerminalShortcutAction.NewTerminal:
            NewTerminalCommand.Execute(null);
            break;
        case TerminalShortcutAction.OpenSearch:
            OpenSearchCommand.Execute(null);
            break;
        case TerminalShortcutAction.Copy:
            CopySelectionCommand.Execute(null);
            break;
        case TerminalShortcutAction.Paste:
            PasteCommand.Execute(null);
            break;
        case TerminalShortcutAction.ScrollPageUp:
            ScrollPageUp();
            break;
        // ... handle other actions
    }
}
```

### Files to Create (v0.5.5d)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Models/Terminal/TerminalShortcutAction.cs` | Action enum |
| `src/SeniorIntern.Core/Models/Terminal/KeyBinding.cs` | Key binding model |
| `src/SeniorIntern.Core/Interfaces/IKeyboardShortcutService.cs` | Service interface |
| `src/SeniorIntern.Services/KeyboardShortcutService.cs` | Service implementation |

### Files to Modify (v0.5.5d)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/Controls/TerminalControl.axaml.cs` | Integrate shortcuts |
| `src/SeniorIntern.Core/Models/AppSettings.cs` | Add CustomKeyBindings property |
| `src/SeniorIntern.Services/ServiceCollectionExtensions.cs` | Register service |

### Complete Keyboard Shortcuts Reference

| Category | Shortcut | Action | Description |
|----------|----------|--------|-------------|
| **Terminal Panel** | Ctrl+` | ToggleTerminal | Show/hide terminal panel |
| | Ctrl+Shift+` | NewTerminal | Create new terminal tab |
| | Ctrl+Shift+T | NewTerminal | Create new terminal (alt) |
| | Ctrl+Shift+W | CloseTerminal | Close active terminal |
| | Ctrl+PageUp | PreviousTerminalTab | Switch to previous tab |
| | Ctrl+PageDown | NextTerminalTab | Switch to next tab |
| | Ctrl+Shift+1..9 | SwitchToTerminal1..9 | Switch to terminal 1-9 |
| **Terminal Input** | Ctrl+C | SendInterrupt | Send SIGINT (interrupt) |
| | Ctrl+Z | SendSuspend | Send SIGTSTP (suspend) |
| | Ctrl+D | SendEof | Send EOF |
| | Ctrl+L | ClearTerminal | Clear terminal screen |
| | Ctrl+U | ClearLineBefore | Clear line before cursor |
| | Ctrl+K | ClearLineAfter | Clear line after cursor |
| | Ctrl+W | DeleteWordBefore | Delete word before cursor |
| | Ctrl+A | MoveToLineStart | Move cursor to line start |
| | Ctrl+E | MoveToLineEnd | Move cursor to line end |
| **Terminal Search** | Ctrl+F | OpenSearch | Open search bar |
| | Escape | CloseSearch | Close search bar |
| | Enter | NextSearchResult | Go to next result |
| | Shift+Enter | PreviousSearchResult | Go to previous result |
| | F3 | NextSearchResult | Go to next result |
| | Shift+F3 | PreviousSearchResult | Go to previous result |
| **Terminal Selection** | Ctrl+Shift+C | Copy | Copy selection |
| | Ctrl+Shift+V | Paste | Paste from clipboard |
| | Ctrl+Shift+A | SelectAll | Select all content |
| | Shift+Click | - | Extend selection |
| | Double-click | - | Select word |
| | Triple-click | - | Select line |
| **Terminal Scroll** | Shift+PageUp | ScrollPageUp | Scroll up one page |
| | Shift+PageDown | ScrollPageDown | Scroll down one page |
| | Shift+Home | ScrollToTop | Scroll to top |
| | Shift+End | ScrollToBottom | Scroll to bottom |
| | Ctrl+Shift+Up | ScrollLineUp | Scroll up one line |
| | Ctrl+Shift+Down | ScrollLineDown | Scroll down one line |
| **Command Blocks** | Ctrl+Enter | ExecuteCommand | Execute command |
| | Ctrl+Shift+Enter | SendToTerminal | Send to terminal |

### Implementation Notes
- Platform-specific key mappings (Cmd vs Ctrl on macOS)
- Avoid conflicts with system-wide shortcuts
- Some shortcuts are passed through to the PTY (Ctrl+C, Ctrl+Z, etc.)
- Support for custom key bindings with persistence
- Display formatted shortcuts in tooltips and menus

---

## v0.5.5e: Terminal Settings Models

### Objective
Define the settings models for terminal customization including appearance, behavior, and shell profile preferences with proper persistence.

### TerminalSettings Model

```csharp
namespace SeniorIntern.Core.Models.Terminal;

/// <summary>
/// Terminal-specific settings
/// </summary>
public sealed class TerminalSettings
{
    // Appearance

    /// <summary>
    /// Font family for terminal text
    /// </summary>
    public string FontFamily { get; set; } = GetDefaultMonospaceFont();

    /// <summary>
    /// Font size in points
    /// </summary>
    public double FontSize { get; set; } = 14;

    /// <summary>
    /// Line height multiplier (1.0 = single spacing)
    /// </summary>
    public double LineHeight { get; set; } = 1.2;

    /// <summary>
    /// Letter spacing in pixels
    /// </summary>
    public double LetterSpacing { get; set; } = 0;

    /// <summary>
    /// Terminal color theme name
    /// </summary>
    public string ThemeName { get; set; } = "Default Dark";

    /// <summary>
    /// Cursor style (Block, Underline, Bar)
    /// </summary>
    public TerminalCursorStyle CursorStyle { get; set; } = TerminalCursorStyle.Block;

    /// <summary>
    /// Whether the cursor should blink
    /// </summary>
    public bool CursorBlink { get; set; } = true;

    /// <summary>
    /// Cursor blink rate in milliseconds
    /// </summary>
    public int CursorBlinkRate { get; set; } = 530;

    /// <summary>
    /// Whether to show bold text as bright colors
    /// </summary>
    public bool BoldIsBright { get; set; } = true;

    /// <summary>
    /// Minimum contrast ratio for text (1.0-21.0)
    /// </summary>
    public double MinimumContrastRatio { get; set; } = 4.5;

    // Behavior

    /// <summary>
    /// Number of lines to keep in scrollback buffer
    /// </summary>
    public int ScrollbackLines { get; set; } = 10000;

    /// <summary>
    /// Whether to enable terminal bell
    /// </summary>
    public bool BellEnabled { get; set; } = false;

    /// <summary>
    /// Bell style (Audio, Visual, None)
    /// </summary>
    public TerminalBellStyle BellStyle { get; set; } = TerminalBellStyle.Visual;

    /// <summary>
    /// Whether to copy on selection
    /// </summary>
    public bool CopyOnSelect { get; set; } = false;

    /// <summary>
    /// Whether to scroll to bottom on input
    /// </summary>
    public bool ScrollOnInput { get; set; } = true;

    /// <summary>
    /// Whether to scroll to bottom on new output
    /// </summary>
    public bool ScrollOnOutput { get; set; } = false;

    /// <summary>
    /// Word separators for double-click selection
    /// </summary>
    public string WordSeparators { get; set; } = " ()[]{}',\"`";

    /// <summary>
    /// Whether to enable ligatures
    /// </summary>
    public bool EnableLigatures { get; set; } = true;

    /// <summary>
    /// Whether to sync working directory with workspace
    /// </summary>
    public bool SyncWithWorkspace { get; set; } = true;

    /// <summary>
    /// Whether to confirm before closing terminal with running process
    /// </summary>
    public bool ConfirmOnClose { get; set; } = true;

    // Shell Profiles

    /// <summary>
    /// ID of the default shell profile
    /// </summary>
    public string? DefaultProfileId { get; set; }

    /// <summary>
    /// Custom shell profiles defined by the user
    /// </summary>
    public List<ShellProfile> CustomProfiles { get; set; } = new();

    private static string GetDefaultMonospaceFont()
    {
        if (OperatingSystem.IsWindows())
            return "Cascadia Code, Consolas, Courier New";
        if (OperatingSystem.IsMacOS())
            return "SF Mono, Menlo, Monaco, Courier New";
        return "Ubuntu Mono, DejaVu Sans Mono, Liberation Mono, monospace";
    }
}

/// <summary>
/// Terminal cursor styles
/// </summary>
public enum TerminalCursorStyle
{
    Block,
    Underline,
    Bar
}

/// <summary>
/// Terminal bell styles
/// </summary>
public enum TerminalBellStyle
{
    None,
    Audio,
    Visual,
    Both
}
```

### AppSettings Extension

```csharp
// Add to AppSettings.cs

/// <summary>
/// Terminal-specific settings
/// </summary>
public TerminalSettings Terminal { get; set; } = new();

/// <summary>
/// Custom keyboard bindings (action name -> key combo string)
/// </summary>
public Dictionary<string, string>? CustomKeyBindings { get; set; }
```

### AvailableFonts Service

```csharp
namespace SeniorIntern.Services;

/// <summary>
/// Service for detecting available monospace fonts
/// </summary>
public interface IFontService
{
    /// <summary>
    /// Get list of available monospace fonts on the system
    /// </summary>
    IReadOnlyList<string> GetMonospaceFonts();

    /// <summary>
    /// Check if a font is available
    /// </summary>
    bool IsFontAvailable(string fontFamily);

    /// <summary>
    /// Get the best available font from a comma-separated list
    /// </summary>
    string GetBestAvailableFont(string fontList);
}

public sealed class FontService : IFontService
{
    private readonly Lazy<List<string>> _monospaceFonts;

    public FontService()
    {
        _monospaceFonts = new Lazy<List<string>>(DetectMonospaceFonts);
    }

    public IReadOnlyList<string> GetMonospaceFonts() => _monospaceFonts.Value;

    public bool IsFontAvailable(string fontFamily)
    {
        // Use Avalonia's font manager to check availability
        try
        {
            var typeface = new Typeface(fontFamily);
            return typeface.GlyphTypeface != null;
        }
        catch
        {
            return false;
        }
    }

    public string GetBestAvailableFont(string fontList)
    {
        var fonts = fontList.Split(',')
            .Select(f => f.Trim())
            .ToList();

        foreach (var font in fonts)
        {
            if (IsFontAvailable(font))
                return font;
        }

        return "monospace";
    }

    private List<string> DetectMonospaceFonts()
    {
        var fonts = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

        // Add known monospace fonts
        var knownFonts = new[]
        {
            // Windows
            "Cascadia Code", "Cascadia Mono", "Consolas", "Courier New",
            "Lucida Console", "Source Code Pro", "Fira Code", "JetBrains Mono",

            // macOS
            "SF Mono", "Menlo", "Monaco",

            // Linux
            "Ubuntu Mono", "DejaVu Sans Mono", "Liberation Mono", "Noto Mono",

            // Cross-platform
            "Hack", "Inconsolata", "Roboto Mono", "IBM Plex Mono"
        };

        foreach (var font in knownFonts)
        {
            if (IsFontAvailable(font))
                fonts.Add(font);
        }

        return fonts.OrderBy(f => f).ToList();
    }
}
```

### TerminalTheme Model

```csharp
namespace SeniorIntern.Core.Models.Terminal;

/// <summary>
/// Terminal color theme definition
/// </summary>
public sealed class TerminalTheme
{
    public string Name { get; set; } = "Custom";
    public bool IsBuiltIn { get; set; }

    // Standard ANSI colors (0-7)
    public string Black { get; set; } = "#000000";
    public string Red { get; set; } = "#CC0000";
    public string Green { get; set; } = "#00CC00";
    public string Yellow { get; set; } = "#CCCC00";
    public string Blue { get; set; } = "#0000CC";
    public string Magenta { get; set; } = "#CC00CC";
    public string Cyan { get; set; } = "#00CCCC";
    public string White { get; set; } = "#CCCCCC";

    // Bright ANSI colors (8-15)
    public string BrightBlack { get; set; } = "#666666";
    public string BrightRed { get; set; } = "#FF0000";
    public string BrightGreen { get; set; } = "#00FF00";
    public string BrightYellow { get; set; } = "#FFFF00";
    public string BrightBlue { get; set; } = "#0000FF";
    public string BrightMagenta { get; set; } = "#FF00FF";
    public string BrightCyan { get; set; } = "#00FFFF";
    public string BrightWhite { get; set; } = "#FFFFFF";

    // UI colors
    public string Background { get; set; } = "#1E1E1E";
    public string Foreground { get; set; } = "#D4D4D4";
    public string Cursor { get; set; } = "#FFFFFF";
    public string CursorText { get; set; } = "#000000";
    public string Selection { get; set; } = "#264F78";
    public string SelectionText { get; set; } = "#FFFFFF";

    // Search highlight colors
    public SearchHighlightStyle SearchHighlight { get; set; } = new();

    /// <summary>
    /// Get ANSI color by index (0-15)
    /// </summary>
    public string GetAnsiColor(int index) => index switch
    {
        0 => Black,
        1 => Red,
        2 => Green,
        3 => Yellow,
        4 => Blue,
        5 => Magenta,
        6 => Cyan,
        7 => White,
        8 => BrightBlack,
        9 => BrightRed,
        10 => BrightGreen,
        11 => BrightYellow,
        12 => BrightBlue,
        13 => BrightMagenta,
        14 => BrightCyan,
        15 => BrightWhite,
        _ => Foreground
    };

    public static TerminalTheme DefaultDark => new()
    {
        Name = "Default Dark",
        IsBuiltIn = true,
        Background = "#1E1E1E",
        Foreground = "#D4D4D4",
        // ... other colors
    };

    public static TerminalTheme DefaultLight => new()
    {
        Name = "Default Light",
        IsBuiltIn = true,
        Background = "#FFFFFF",
        Foreground = "#1E1E1E",
        // ... other colors
    };

    public static IReadOnlyList<TerminalTheme> BuiltInThemes => new[]
    {
        DefaultDark,
        DefaultLight,
        // Add more built-in themes: Monokai, Dracula, Solarized, etc.
    };
}
```

### Files to Create (v0.5.5e)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Models/Terminal/TerminalSettings.cs` | Terminal settings model |
| `src/SeniorIntern.Core/Models/Terminal/TerminalCursorStyle.cs` | Cursor style enum |
| `src/SeniorIntern.Core/Models/Terminal/TerminalBellStyle.cs` | Bell style enum |
| `src/SeniorIntern.Core/Models/Terminal/TerminalTheme.cs` | Theme model |
| `src/SeniorIntern.Core/Interfaces/IFontService.cs` | Font service interface |
| `src/SeniorIntern.Services/FontService.cs` | Font service implementation |

### Files to Modify (v0.5.5e)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Core/Models/AppSettings.cs` | Add Terminal and CustomKeyBindings properties |
| `src/SeniorIntern.Services/ServiceCollectionExtensions.cs` | Register FontService |

### Implementation Notes
- Use sensible defaults for all settings
- Platform-specific default fonts
- Support importing/exporting themes
- Validate settings values (e.g., font size range, scrollback limits)

---

## v0.5.5f: Terminal Settings Panel

### Objective
Create the terminal settings panel UI that allows users to customize terminal appearance, behavior, and preferences with live preview.

### TerminalSettingsViewModel

```csharp
namespace SeniorIntern.Desktop.ViewModels;

using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models.Terminal;

/// <summary>
/// ViewModel for terminal settings panel
/// </summary>
public partial class TerminalSettingsViewModel : ViewModelBase
{
    private readonly ISettingsService _settingsService;
    private readonly IFontService _fontService;
    private readonly IShellDetectionService _shellService;

    [ObservableProperty]
    private TerminalSettings _settings;

    [ObservableProperty]
    private ObservableCollection<string> _availableFonts = new();

    [ObservableProperty]
    private ObservableCollection<TerminalTheme> _availableThemes = new();

    [ObservableProperty]
    private ObservableCollection<ShellProfile> _shellProfiles = new();

    [ObservableProperty]
    private ShellProfile? _selectedProfile;

    [ObservableProperty]
    private ShellProfile? _defaultProfile;

    [ObservableProperty]
    private string _selectedFontFamily = string.Empty;

    [ObservableProperty]
    private double _selectedFontSize;

    [ObservableProperty]
    private TerminalTheme? _selectedTheme;

    [ObservableProperty]
    private TerminalCursorStyle _selectedCursorStyle;

    [ObservableProperty]
    private bool _cursorBlink;

    [ObservableProperty]
    private int _scrollbackLines;

    [ObservableProperty]
    private bool _bellEnabled;

    [ObservableProperty]
    private bool _syncWithWorkspace;

    [ObservableProperty]
    private bool _hasUnsavedChanges;

    public IReadOnlyList<TerminalCursorStyle> CursorStyles { get; } =
        Enum.GetValues<TerminalCursorStyle>();

    public TerminalSettingsViewModel(
        ISettingsService settingsService,
        IFontService fontService,
        IShellDetectionService shellService)
    {
        _settingsService = settingsService;
        _fontService = fontService;
        _shellService = shellService;

        _settings = _settingsService.CurrentSettings.Terminal;

        LoadSettings();
    }

    private void LoadSettings()
    {
        // Load available fonts
        AvailableFonts = new ObservableCollection<string>(_fontService.GetMonospaceFonts());

        // Load available themes
        AvailableThemes = new ObservableCollection<TerminalTheme>(TerminalTheme.BuiltInThemes);

        // Load shell profiles
        LoadShellProfiles();

        // Set current values
        SelectedFontFamily = _fontService.GetBestAvailableFont(Settings.FontFamily);
        SelectedFontSize = Settings.FontSize;
        SelectedTheme = AvailableThemes.FirstOrDefault(t => t.Name == Settings.ThemeName);
        SelectedCursorStyle = Settings.CursorStyle;
        CursorBlink = Settings.CursorBlink;
        ScrollbackLines = Settings.ScrollbackLines;
        BellEnabled = Settings.BellEnabled;
        SyncWithWorkspace = Settings.SyncWithWorkspace;

        HasUnsavedChanges = false;
    }

    private async void LoadShellProfiles()
    {
        var detectedShells = await _shellService.GetAvailableShellsAsync();

        // Combine detected shells with custom profiles
        var profiles = detectedShells
            .Select(s => new ShellProfile
            {
                Id = Guid.NewGuid().ToString(),
                Name = s.Name,
                ShellPath = s.Path,
                ShellType = s.Type,
                IsBuiltIn = true
            })
            .Concat(Settings.CustomProfiles)
            .ToList();

        ShellProfiles = new ObservableCollection<ShellProfile>(profiles);

        // Set default profile
        DefaultProfile = ShellProfiles.FirstOrDefault(p => p.Id == Settings.DefaultProfileId)
            ?? ShellProfiles.FirstOrDefault();
    }

    partial void OnSelectedFontFamilyChanged(string value) => MarkDirty();
    partial void OnSelectedFontSizeChanged(double value) => MarkDirty();
    partial void OnSelectedThemeChanged(TerminalTheme? value) => MarkDirty();
    partial void OnSelectedCursorStyleChanged(TerminalCursorStyle value) => MarkDirty();
    partial void OnCursorBlinkChanged(bool value) => MarkDirty();
    partial void OnScrollbackLinesChanged(int value) => MarkDirty();
    partial void OnBellEnabledChanged(bool value) => MarkDirty();
    partial void OnSyncWithWorkspaceChanged(bool value) => MarkDirty();
    partial void OnDefaultProfileChanged(ShellProfile? value) => MarkDirty();

    private void MarkDirty()
    {
        HasUnsavedChanges = true;
        PreviewSettingsChanged?.Invoke(this, GetPreviewSettings());
    }

    private TerminalSettings GetPreviewSettings() => new()
    {
        FontFamily = SelectedFontFamily,
        FontSize = SelectedFontSize,
        ThemeName = SelectedTheme?.Name ?? "Default Dark",
        CursorStyle = SelectedCursorStyle,
        CursorBlink = CursorBlink,
        ScrollbackLines = ScrollbackLines,
        BellEnabled = BellEnabled,
        SyncWithWorkspace = SyncWithWorkspace
    };

    [RelayCommand]
    private void SaveSettings()
    {
        Settings.FontFamily = SelectedFontFamily;
        Settings.FontSize = SelectedFontSize;
        Settings.ThemeName = SelectedTheme?.Name ?? "Default Dark";
        Settings.CursorStyle = SelectedCursorStyle;
        Settings.CursorBlink = CursorBlink;
        Settings.ScrollbackLines = ScrollbackLines;
        Settings.BellEnabled = BellEnabled;
        Settings.SyncWithWorkspace = SyncWithWorkspace;
        Settings.DefaultProfileId = DefaultProfile?.Id;

        _settingsService.SaveSettings();
        HasUnsavedChanges = false;

        SettingsSaved?.Invoke(this, EventArgs.Empty);
    }

    [RelayCommand]
    private void ResetToDefaults()
    {
        Settings = new TerminalSettings();
        LoadSettings();
        MarkDirty();
    }

    [RelayCommand]
    private void DiscardChanges()
    {
        Settings = _settingsService.CurrentSettings.Terminal;
        LoadSettings();
    }

    [RelayCommand]
    private async Task AddProfile()
    {
        var profile = new ShellProfile
        {
            Id = Guid.NewGuid().ToString(),
            Name = "New Profile",
            ShellPath = await _shellService.GetDefaultShellAsync()
        };

        ShellProfiles.Add(profile);
        SelectedProfile = profile;

        ProfileEditRequested?.Invoke(this, profile);
    }

    [RelayCommand]
    private void EditProfile(ShellProfile profile)
    {
        ProfileEditRequested?.Invoke(this, profile);
    }

    [RelayCommand]
    private void DeleteProfile(ShellProfile profile)
    {
        if (profile.IsBuiltIn) return;

        ShellProfiles.Remove(profile);
        Settings.CustomProfiles.Remove(profile);

        if (DefaultProfile == profile)
        {
            DefaultProfile = ShellProfiles.FirstOrDefault();
        }

        MarkDirty();
    }

    /// <summary>
    /// Event raised when settings change for live preview
    /// </summary>
    public event EventHandler<TerminalSettings>? PreviewSettingsChanged;

    /// <summary>
    /// Event raised when settings are saved
    /// </summary>
    public event EventHandler? SettingsSaved;

    /// <summary>
    /// Event raised when profile editing is requested
    /// </summary>
    public event EventHandler<ShellProfile>? ProfileEditRequested;
}
```

### TerminalSettingsPanel.axaml

```xml
<!-- src/SeniorIntern.Desktop/Views/TerminalSettingsPanel.axaml -->
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:vm="using:SeniorIntern.Desktop.ViewModels"
             x:Class="SeniorIntern.Desktop.Views.TerminalSettingsPanel"
             x:DataType="vm:TerminalSettingsViewModel">

    <UserControl.Styles>
        <Style Selector="TextBlock.section-header">
            <Setter Property="FontSize" Value="14" />
            <Setter Property="FontWeight" Value="SemiBold" />
            <Setter Property="Margin" Value="0,0,0,12" />
        </Style>

        <Style Selector="Border.section">
            <Setter Property="Background" Value="{DynamicResource SurfaceColor}" />
            <Setter Property="BorderBrush" Value="{DynamicResource BorderColor}" />
            <Setter Property="BorderThickness" Value="1" />
            <Setter Property="CornerRadius" Value="4" />
            <Setter Property="Padding" Value="16" />
            <Setter Property="Margin" Value="0,0,0,16" />
        </Style>

        <Style Selector="Grid.setting-row">
            <Setter Property="Margin" Value="0,0,0,12" />
        </Style>
    </UserControl.Styles>

    <ScrollViewer HorizontalScrollBarVisibility="Disabled"
                  VerticalScrollBarVisibility="Auto">
        <StackPanel Padding="24" MaxWidth="600">

            <!-- Header -->
            <Grid ColumnDefinitions="*, Auto" Margin="0,0,0,24">
                <TextBlock Text="Terminal Settings" FontSize="20" FontWeight="SemiBold" />
                <StackPanel Grid.Column="1" Orientation="Horizontal" Spacing="8">
                    <Button Content="Reset"
                            Command="{Binding ResetToDefaultsCommand}"
                            Classes="secondary" />
                    <Button Content="Save"
                            Command="{Binding SaveSettingsCommand}"
                            IsEnabled="{Binding HasUnsavedChanges}"
                            Classes="primary" />
                </StackPanel>
            </Grid>

            <!-- Appearance Section -->
            <Border Classes="section">
                <StackPanel>
                    <TextBlock Classes="section-header" Text="Appearance" />

                    <!-- Font Family -->
                    <Grid Classes="setting-row" ColumnDefinitions="150, *">
                        <TextBlock Text="Font Family" VerticalAlignment="Center" />
                        <ComboBox Grid.Column="1"
                                  ItemsSource="{Binding AvailableFonts}"
                                  SelectedItem="{Binding SelectedFontFamily}"
                                  HorizontalAlignment="Stretch" />
                    </Grid>

                    <!-- Font Size -->
                    <Grid Classes="setting-row" ColumnDefinitions="150, *, 50">
                        <TextBlock Text="Font Size" VerticalAlignment="Center" />
                        <Slider Grid.Column="1"
                                Minimum="8" Maximum="24"
                                Value="{Binding SelectedFontSize}"
                                TickFrequency="1"
                                IsSnapToTickEnabled="True" />
                        <TextBlock Grid.Column="2"
                                   Text="{Binding SelectedFontSize, StringFormat={}{0:F0}pt}"
                                   VerticalAlignment="Center"
                                   HorizontalAlignment="Right" />
                    </Grid>

                    <!-- Theme -->
                    <Grid Classes="setting-row" ColumnDefinitions="150, *">
                        <TextBlock Text="Theme" VerticalAlignment="Center" />
                        <ComboBox Grid.Column="1"
                                  ItemsSource="{Binding AvailableThemes}"
                                  SelectedItem="{Binding SelectedTheme}"
                                  DisplayMemberBinding="{Binding Name}"
                                  HorizontalAlignment="Stretch" />
                    </Grid>

                    <!-- Cursor Style -->
                    <Grid Classes="setting-row" ColumnDefinitions="150, *">
                        <TextBlock Text="Cursor Style" VerticalAlignment="Center" />
                        <ComboBox Grid.Column="1"
                                  ItemsSource="{Binding CursorStyles}"
                                  SelectedItem="{Binding SelectedCursorStyle}"
                                  HorizontalAlignment="Stretch" />
                    </Grid>

                    <!-- Cursor Blink -->
                    <CheckBox Content="Blinking cursor"
                              IsChecked="{Binding CursorBlink}"
                              Margin="0,4,0,0" />
                </StackPanel>
            </Border>

            <!-- Behavior Section -->
            <Border Classes="section">
                <StackPanel>
                    <TextBlock Classes="section-header" Text="Behavior" />

                    <!-- Scrollback Lines -->
                    <Grid Classes="setting-row" ColumnDefinitions="150, *, 80">
                        <TextBlock Text="Scrollback Lines" VerticalAlignment="Center" />
                        <Slider Grid.Column="1"
                                Minimum="1000" Maximum="100000"
                                Value="{Binding ScrollbackLines}"
                                TickFrequency="1000" />
                        <TextBlock Grid.Column="2"
                                   Text="{Binding ScrollbackLines, StringFormat={}{0:N0}}"
                                   VerticalAlignment="Center"
                                   HorizontalAlignment="Right" />
                    </Grid>

                    <!-- Bell -->
                    <CheckBox Content="Enable bell sound"
                              IsChecked="{Binding BellEnabled}" />

                    <!-- Sync with Workspace -->
                    <CheckBox Content="Sync terminal directory with workspace"
                              IsChecked="{Binding SyncWithWorkspace}"
                              Margin="0,8,0,0" />
                </StackPanel>
            </Border>

            <!-- Shell Profiles Section -->
            <Border Classes="section">
                <StackPanel>
                    <Grid ColumnDefinitions="*, Auto" Margin="0,0,0,12">
                        <TextBlock Classes="section-header" Text="Shell Profiles" Margin="0" />
                        <Button Grid.Column="1"
                                Content="Add Profile"
                                Command="{Binding AddProfileCommand}"
                                Classes="secondary" />
                    </Grid>

                    <ListBox ItemsSource="{Binding ShellProfiles}"
                             SelectedItem="{Binding SelectedProfile}"
                             MinHeight="120"
                             MaxHeight="200">
                        <ListBox.ItemTemplate>
                            <DataTemplate>
                                <Grid ColumnDefinitions="Auto, *, Auto, Auto">
                                    <!-- Shell Icon -->
                                    <PathIcon Data="{Binding ShellType, Converter={StaticResource ShellTypeToIconConverter}}"
                                              Width="16" Height="16"
                                              Margin="0,0,8,0" />

                                    <!-- Name and Path -->
                                    <StackPanel Grid.Column="1">
                                        <TextBlock Text="{Binding Name}" FontWeight="SemiBold" />
                                        <TextBlock Text="{Binding ShellPath}"
                                                   FontSize="11"
                                                   Foreground="{DynamicResource TextMuted}"
                                                   TextTrimming="CharacterEllipsis" />
                                    </StackPanel>

                                    <!-- Edit Button -->
                                    <Button Grid.Column="2"
                                            Classes="icon-button"
                                            Command="{Binding $parent[UserControl].DataContext.EditProfileCommand}"
                                            CommandParameter="{Binding}"
                                            ToolTip.Tip="Edit Profile">
                                        <PathIcon Data="{StaticResource EditIcon}" Width="14" Height="14" />
                                    </Button>

                                    <!-- Delete Button -->
                                    <Button Grid.Column="3"
                                            Classes="icon-button"
                                            Command="{Binding $parent[UserControl].DataContext.DeleteProfileCommand}"
                                            CommandParameter="{Binding}"
                                            IsVisible="{Binding !IsBuiltIn}"
                                            ToolTip.Tip="Delete Profile">
                                        <PathIcon Data="{StaticResource DeleteIcon}" Width="14" Height="14" />
                                    </Button>
                                </Grid>
                            </DataTemplate>
                        </ListBox.ItemTemplate>
                    </ListBox>

                    <!-- Default Profile -->
                    <Grid Classes="setting-row" ColumnDefinitions="150, *" Margin="0,12,0,0">
                        <TextBlock Text="Default Profile" VerticalAlignment="Center" />
                        <ComboBox Grid.Column="1"
                                  ItemsSource="{Binding ShellProfiles}"
                                  SelectedItem="{Binding DefaultProfile}"
                                  DisplayMemberBinding="{Binding Name}"
                                  HorizontalAlignment="Stretch" />
                    </Grid>
                </StackPanel>
            </Border>

            <!-- Unsaved Changes Warning -->
            <Border Background="{DynamicResource WarningBackgroundColor}"
                    BorderBrush="{DynamicResource WarningBorderColor}"
                    BorderThickness="1"
                    CornerRadius="4"
                    Padding="12"
                    IsVisible="{Binding HasUnsavedChanges}">
                <Grid ColumnDefinitions="Auto, *, Auto">
                    <PathIcon Data="{StaticResource WarningIcon}"
                              Width="16" Height="16"
                              Foreground="{DynamicResource WarningColor}" />
                    <TextBlock Grid.Column="1"
                               Text="You have unsaved changes"
                               Margin="8,0"
                               VerticalAlignment="Center" />
                    <StackPanel Grid.Column="2" Orientation="Horizontal" Spacing="8">
                        <Button Content="Discard"
                                Command="{Binding DiscardChangesCommand}"
                                Classes="secondary" />
                        <Button Content="Save"
                                Command="{Binding SaveSettingsCommand}"
                                Classes="primary" />
                    </StackPanel>
                </Grid>
            </Border>
        </StackPanel>
    </ScrollViewer>
</UserControl>
```

### Files to Create (v0.5.5f)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/Views/TerminalSettingsPanel.axaml` | Settings panel UI |
| `src/SeniorIntern.Desktop/Views/TerminalSettingsPanel.axaml.cs` | Code-behind |
| `src/SeniorIntern.Desktop/ViewModels/TerminalSettingsViewModel.cs` | Settings ViewModel |
| `src/SeniorIntern.Desktop/Converters/ShellTypeToIconConverter.cs` | Shell type icon converter |

### Files to Modify (v0.5.5f)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/Views/SettingsView.axaml` | Add terminal settings tab |
| `src/SeniorIntern.Desktop/ViewModels/SettingsViewModel.cs` | Include terminal settings VM |

### Implementation Notes
- Live preview of appearance changes
- Unsaved changes warning
- Validation of settings values
- Searchable font dropdown (optional enhancement)
- Theme preview swatches

---

## v0.5.5g: Shell Profile Editor

### Objective
Create the shell profile editor dialog for creating and editing shell profile configurations with validation and path browsing.

### ShellProfileEditorViewModel

```csharp
namespace SeniorIntern.Desktop.ViewModels;

using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models.Terminal;

/// <summary>
/// ViewModel for the shell profile editor dialog
/// </summary>
public partial class ShellProfileEditorViewModel : ViewModelBase
{
    private readonly IShellDetectionService _shellService;
    private readonly ShellProfile _originalProfile;
    private readonly bool _isNewProfile;

    [ObservableProperty]
    private string _profileName = string.Empty;

    [ObservableProperty]
    private string _shellPath = string.Empty;

    [ObservableProperty]
    private string _arguments = string.Empty;

    [ObservableProperty]
    private string _workingDirectory = string.Empty;

    [ObservableProperty]
    private string _environmentVariables = string.Empty;

    [ObservableProperty]
    private ShellType _shellType;

    [ObservableProperty]
    private string _icon = string.Empty;

    [ObservableProperty]
    private bool _isLoginShell;

    [ObservableProperty]
    private bool _useConPty = true;

    [ObservableProperty]
    private string? _pathError;

    [ObservableProperty]
    private string? _nameError;

    [ObservableProperty]
    private bool _isValid;

    [ObservableProperty]
    private string? _detectedVersion;

    public IReadOnlyList<ShellType> ShellTypes { get; } = Enum.GetValues<ShellType>();

    public string Title => _isNewProfile ? "New Shell Profile" : "Edit Shell Profile";

    public ShellProfileEditorViewModel(
        IShellDetectionService shellService,
        ShellProfile? profile = null)
    {
        _shellService = shellService;
        _isNewProfile = profile == null;
        _originalProfile = profile ?? new ShellProfile { Id = Guid.NewGuid().ToString() };

        LoadFromProfile(_originalProfile);
        Validate();
    }

    private void LoadFromProfile(ShellProfile profile)
    {
        ProfileName = profile.Name;
        ShellPath = profile.ShellPath;
        Arguments = profile.Arguments ?? string.Empty;
        WorkingDirectory = profile.WorkingDirectory ?? string.Empty;
        EnvironmentVariables = FormatEnvironmentVariables(profile.EnvironmentVariables);
        ShellType = profile.ShellType;
        Icon = profile.Icon ?? string.Empty;
        IsLoginShell = profile.IsLoginShell;
        UseConPty = profile.UseConPty;
    }

    private static string FormatEnvironmentVariables(Dictionary<string, string>? vars)
    {
        if (vars == null || vars.Count == 0) return string.Empty;
        return string.Join("\n", vars.Select(kv => $"{kv.Key}={kv.Value}"));
    }

    private static Dictionary<string, string> ParseEnvironmentVariables(string text)
    {
        var result = new Dictionary<string, string>();
        if (string.IsNullOrWhiteSpace(text)) return result;

        foreach (var line in text.Split('\n', StringSplitOptions.RemoveEmptyEntries))
        {
            var parts = line.Split('=', 2);
            if (parts.Length == 2)
            {
                result[parts[0].Trim()] = parts[1].Trim();
            }
        }

        return result;
    }

    partial void OnProfileNameChanged(string value) => Validate();
    partial void OnShellPathChanged(string value)
    {
        Validate();
        DetectShellType();
        DetectVersion();
    }

    private void Validate()
    {
        NameError = string.IsNullOrWhiteSpace(ProfileName)
            ? "Profile name is required"
            : null;

        PathError = null;
        if (string.IsNullOrWhiteSpace(ShellPath))
        {
            PathError = "Shell path is required";
        }
        else if (!_shellService.ValidateShellPath(ShellPath))
        {
            PathError = "Shell executable not found or not executable";
        }

        IsValid = NameError == null && PathError == null;
    }

    private void DetectShellType()
    {
        if (!string.IsNullOrEmpty(ShellPath))
        {
            ShellType = _shellService.DetectShellType(ShellPath);
        }
    }

    private async void DetectVersion()
    {
        if (string.IsNullOrEmpty(ShellPath))
        {
            DetectedVersion = null;
            return;
        }

        try
        {
            DetectedVersion = await _shellService.GetShellVersionAsync(ShellPath);
        }
        catch
        {
            DetectedVersion = null;
        }
    }

    [RelayCommand]
    private async Task BrowseShellPath()
    {
        var dialog = new OpenFileDialog
        {
            Title = "Select Shell Executable",
            AllowMultiple = false
        };

        if (OperatingSystem.IsWindows())
        {
            dialog.Filters = new List<FileDialogFilter>
            {
                new() { Name = "Executables", Extensions = { "exe", "cmd", "bat" } },
                new() { Name = "All Files", Extensions = { "*" } }
            };
        }

        var result = await dialog.ShowAsync(App.MainWindow);
        if (result?.Length > 0)
        {
            ShellPath = result[0];
        }
    }

    [RelayCommand]
    private async Task BrowseWorkingDirectory()
    {
        var dialog = new OpenFolderDialog
        {
            Title = "Select Working Directory"
        };

        var result = await dialog.ShowAsync(App.MainWindow);
        if (!string.IsNullOrEmpty(result))
        {
            WorkingDirectory = result;
        }
    }

    [RelayCommand]
    private void DetectFromPath()
    {
        var detected = _shellService.FindInPath(Path.GetFileNameWithoutExtension(ShellPath));
        if (detected != null)
        {
            ShellPath = detected;
        }
    }

    public ShellProfile GetProfile()
    {
        return new ShellProfile
        {
            Id = _originalProfile.Id,
            Name = ProfileName,
            ShellPath = ShellPath,
            Arguments = string.IsNullOrWhiteSpace(Arguments) ? null : Arguments,
            WorkingDirectory = string.IsNullOrWhiteSpace(WorkingDirectory) ? null : WorkingDirectory,
            EnvironmentVariables = ParseEnvironmentVariables(EnvironmentVariables),
            ShellType = ShellType,
            Icon = string.IsNullOrWhiteSpace(Icon) ? null : Icon,
            IsLoginShell = IsLoginShell,
            UseConPty = UseConPty,
            IsBuiltIn = false
        };
    }

    /// <summary>
    /// Event raised when the dialog should close with save
    /// </summary>
    public event EventHandler<ShellProfile>? SaveRequested;

    /// <summary>
    /// Event raised when the dialog should close without saving
    /// </summary>
    public event EventHandler? CancelRequested;

    [RelayCommand]
    private void Save()
    {
        if (!IsValid) return;
        SaveRequested?.Invoke(this, GetProfile());
    }

    [RelayCommand]
    private void Cancel()
    {
        CancelRequested?.Invoke(this, EventArgs.Empty);
    }
}
```

### ShellProfileEditor.axaml

```xml
<!-- src/SeniorIntern.Desktop/Views/ShellProfileEditor.axaml -->
<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:vm="using:SeniorIntern.Desktop.ViewModels"
        x:Class="SeniorIntern.Desktop.Views.ShellProfileEditor"
        x:DataType="vm:ShellProfileEditorViewModel"
        Title="{Binding Title}"
        Width="500"
        Height="550"
        WindowStartupLocation="CenterOwner"
        CanResize="False">

    <Window.Styles>
        <Style Selector="TextBlock.field-label">
            <Setter Property="Margin" Value="0,0,0,4" />
        </Style>

        <Style Selector="TextBlock.error-text">
            <Setter Property="Foreground" Value="{DynamicResource ErrorColor}" />
            <Setter Property="FontSize" Value="11" />
            <Setter Property="Margin" Value="0,2,0,0" />
        </Style>

        <Style Selector="StackPanel.field-group">
            <Setter Property="Margin" Value="0,0,0,16" />
        </Style>
    </Window.Styles>

    <Grid RowDefinitions="*, Auto">
        <ScrollViewer Padding="24">
            <StackPanel>

                <!-- Profile Name -->
                <StackPanel Classes="field-group">
                    <TextBlock Classes="field-label" Text="Profile Name" />
                    <TextBox Text="{Binding ProfileName}"
                             Watermark="e.g., My PowerShell Profile" />
                    <TextBlock Classes="error-text"
                               Text="{Binding NameError}"
                               IsVisible="{Binding NameError, Converter={x:Static StringConverters.IsNotNullOrEmpty}}" />
                </StackPanel>

                <!-- Shell Path -->
                <StackPanel Classes="field-group">
                    <TextBlock Classes="field-label" Text="Shell Path" />
                    <Grid ColumnDefinitions="*, Auto">
                        <TextBox Text="{Binding ShellPath}"
                                 Watermark="/bin/bash or C:\Windows\System32\cmd.exe" />
                        <Button Grid.Column="1"
                                Content="Browse..."
                                Command="{Binding BrowseShellPathCommand}"
                                Margin="8,0,0,0" />
                    </Grid>
                    <TextBlock Classes="error-text"
                               Text="{Binding PathError}"
                               IsVisible="{Binding PathError, Converter={x:Static StringConverters.IsNotNullOrEmpty}}" />
                    <TextBlock Text="{Binding DetectedVersion, StringFormat='Version: {0}'}"
                               FontSize="11"
                               Foreground="{DynamicResource TextMuted}"
                               IsVisible="{Binding DetectedVersion, Converter={x:Static StringConverters.IsNotNullOrEmpty}}"
                               Margin="0,2,0,0" />
                </StackPanel>

                <!-- Shell Type -->
                <StackPanel Classes="field-group">
                    <TextBlock Classes="field-label" Text="Shell Type" />
                    <ComboBox ItemsSource="{Binding ShellTypes}"
                              SelectedItem="{Binding ShellType}"
                              HorizontalAlignment="Stretch" />
                </StackPanel>

                <!-- Arguments -->
                <StackPanel Classes="field-group">
                    <TextBlock Classes="field-label" Text="Arguments (optional)" />
                    <TextBox Text="{Binding Arguments}"
                             Watermark="-l --norc" />
                    <TextBlock Text="Command line arguments passed to the shell"
                               FontSize="11"
                               Foreground="{DynamicResource TextMuted}"
                               Margin="0,2,0,0" />
                </StackPanel>

                <!-- Working Directory -->
                <StackPanel Classes="field-group">
                    <TextBlock Classes="field-label" Text="Working Directory (optional)" />
                    <Grid ColumnDefinitions="*, Auto">
                        <TextBox Text="{Binding WorkingDirectory}"
                                 Watermark="Leave empty to use workspace directory" />
                        <Button Grid.Column="1"
                                Content="Browse..."
                                Command="{Binding BrowseWorkingDirectoryCommand}"
                                Margin="8,0,0,0" />
                    </Grid>
                </StackPanel>

                <!-- Environment Variables -->
                <StackPanel Classes="field-group">
                    <TextBlock Classes="field-label" Text="Environment Variables (optional)" />
                    <TextBox Text="{Binding EnvironmentVariables}"
                             AcceptsReturn="True"
                             Height="80"
                             Watermark="KEY=value&#x0a;ANOTHER_KEY=another_value" />
                    <TextBlock Text="One variable per line in KEY=value format"
                               FontSize="11"
                               Foreground="{DynamicResource TextMuted}"
                               Margin="0,2,0,0" />
                </StackPanel>

                <!-- Options -->
                <StackPanel Classes="field-group">
                    <TextBlock Classes="field-label" Text="Options" />
                    <CheckBox Content="Run as login shell"
                              IsChecked="{Binding IsLoginShell}" />
                    <CheckBox Content="Use ConPTY (Windows)"
                              IsChecked="{Binding UseConPty}"
                              IsVisible="{OnPlatform Windows=True, Default=False}"
                              Margin="0,8,0,0" />
                </StackPanel>

            </StackPanel>
        </ScrollViewer>

        <!-- Dialog Buttons -->
        <Border Grid.Row="1"
                BorderBrush="{DynamicResource BorderColor}"
                BorderThickness="0,1,0,0"
                Padding="24,16">
            <Grid ColumnDefinitions="*, Auto, Auto">
                <Button Content="Cancel"
                        Command="{Binding CancelCommand}"
                        HorizontalAlignment="Left" />

                <Button Grid.Column="2"
                        Content="Save"
                        Command="{Binding SaveCommand}"
                        IsEnabled="{Binding IsValid}"
                        Classes="primary" />
            </Grid>
        </Border>
    </Grid>
</Window>
```

### Files to Create (v0.5.5g)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/Views/ShellProfileEditor.axaml` | Profile editor dialog |
| `src/SeniorIntern.Desktop/Views/ShellProfileEditor.axaml.cs` | Code-behind |
| `src/SeniorIntern.Desktop/ViewModels/ShellProfileEditorViewModel.cs` | Profile editor ViewModel |

### Implementation Notes
- Validate shell path exists and is executable
- Auto-detect shell type from executable name
- Show detected version when possible
- Support environment variable configuration
- Platform-specific options (ConPTY on Windows)

---

## v0.5.5h: Status Bar Integration

### Objective
Integrate terminal status information into the application's status bar, showing active terminal info, quick actions, and notifications.

### TerminalStatusBarViewModel

```csharp
namespace SeniorIntern.Desktop.ViewModels;

using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models.Terminal;

/// <summary>
/// ViewModel for terminal status bar section
/// </summary>
public partial class TerminalStatusBarViewModel : ViewModelBase
{
    private readonly ITerminalService _terminalService;

    [ObservableProperty]
    private bool _hasActiveTerminal;

    [ObservableProperty]
    private string _activeShellName = string.Empty;

    [ObservableProperty]
    private string _currentDirectory = string.Empty;

    [ObservableProperty]
    private string _currentDirectoryDisplay = string.Empty;

    [ObservableProperty]
    private bool _isProcessRunning;

    [ObservableProperty]
    private string _runningProcessName = string.Empty;

    [ObservableProperty]
    private int _terminalCount;

    [ObservableProperty]
    private bool _hasNotification;

    [ObservableProperty]
    private string _notificationMessage = string.Empty;

    public TerminalStatusBarViewModel(ITerminalService terminalService)
    {
        _terminalService = terminalService;

        _terminalService.ActiveSessionChanged += OnActiveSessionChanged;
        _terminalService.SessionCreated += OnSessionChanged;
        _terminalService.SessionClosed += OnSessionChanged;
    }

    private void OnActiveSessionChanged(object? sender, TerminalSession? session)
    {
        UpdateFromSession(session);
    }

    private void OnSessionChanged(object? sender, TerminalSession session)
    {
        TerminalCount = _terminalService.Sessions.Count;
    }

    private void UpdateFromSession(TerminalSession? session)
    {
        HasActiveTerminal = session != null;

        if (session == null)
        {
            ActiveShellName = string.Empty;
            CurrentDirectory = string.Empty;
            CurrentDirectoryDisplay = string.Empty;
            IsProcessRunning = false;
            RunningProcessName = string.Empty;
            return;
        }

        ActiveShellName = session.Profile?.Name ?? "Terminal";
        CurrentDirectory = session.CurrentDirectory ?? string.Empty;
        CurrentDirectoryDisplay = ShortenPath(CurrentDirectory);
        IsProcessRunning = session.HasRunningProcess;
        RunningProcessName = session.RunningProcessName ?? string.Empty;
    }

    private static string ShortenPath(string path)
    {
        if (string.IsNullOrEmpty(path)) return string.Empty;

        // Replace home directory with ~
        var home = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
        if (path.StartsWith(home))
        {
            path = "~" + path[home.Length..];
        }

        // Truncate if too long
        const int maxLength = 40;
        if (path.Length > maxLength)
        {
            var parts = path.Split(Path.DirectorySeparatorChar);
            if (parts.Length > 3)
            {
                return $"{parts[0]}/.../{parts[^2]}/{parts[^1]}";
            }
        }

        return path;
    }

    [RelayCommand]
    private void ToggleTerminal()
    {
        _terminalService.ToggleVisibility();
    }

    [RelayCommand]
    private void NewTerminal()
    {
        _terminalService.CreateSessionAsync();
    }

    [RelayCommand]
    private void OpenTerminalSettings()
    {
        TerminalSettingsRequested?.Invoke(this, EventArgs.Empty);
    }

    [RelayCommand]
    private void CopyCurrentDirectory()
    {
        if (!string.IsNullOrEmpty(CurrentDirectory))
        {
            Application.Current?.Clipboard?.SetTextAsync(CurrentDirectory);
            ShowNotification("Path copied to clipboard");
        }
    }

    private void ShowNotification(string message)
    {
        NotificationMessage = message;
        HasNotification = true;

        // Auto-hide after 3 seconds
        _ = Task.Delay(3000).ContinueWith(_ =>
        {
            Dispatcher.UIThread.Post(() =>
            {
                HasNotification = false;
                NotificationMessage = string.Empty;
            });
        });
    }

    public event EventHandler? TerminalSettingsRequested;
}
```

### Status Bar Terminal Section XAML

```xml
<!-- Add to StatusBar in MainWindow.axaml -->
<Border Classes="status-bar-section terminal-status"
        IsVisible="{Binding TerminalStatus.HasActiveTerminal}"
        ToolTip.Tip="{Binding TerminalStatus.CurrentDirectory}">
    <Button Classes="status-bar-button"
            Command="{Binding TerminalStatus.ToggleTerminalCommand}">
        <StackPanel Orientation="Horizontal" Spacing="6">
            <!-- Terminal Icon -->
            <PathIcon Data="{StaticResource TerminalIcon}"
                      Width="14" Height="14" />

            <!-- Shell Name -->
            <TextBlock Text="{Binding TerminalStatus.ActiveShellName}"
                       FontSize="12" />

            <!-- Separator -->
            <TextBlock Text=":"
                       Foreground="{DynamicResource TextMuted}" />

            <!-- Current Directory -->
            <TextBlock Text="{Binding TerminalStatus.CurrentDirectoryDisplay}"
                       FontSize="12"
                       MaxWidth="200"
                       TextTrimming="CharacterEllipsis" />

            <!-- Running Process Indicator -->
            <Border Background="{DynamicResource AccentColor}"
                    CornerRadius="2"
                    Padding="4,1"
                    IsVisible="{Binding TerminalStatus.IsProcessRunning}">
                <TextBlock Text="{Binding TerminalStatus.RunningProcessName}"
                           FontSize="10"
                           Foreground="White" />
            </Border>
        </StackPanel>
    </Button>
</Border>

<!-- Terminal Count Badge -->
<Border Classes="status-bar-section"
        IsVisible="{Binding TerminalStatus.TerminalCount, Converter={StaticResource GreaterThanZeroConverter}}">
    <Button Classes="status-bar-button"
            Command="{Binding TerminalStatus.ToggleTerminalCommand}"
            ToolTip.Tip="Toggle Terminal (Ctrl+`)">
        <StackPanel Orientation="Horizontal" Spacing="4">
            <PathIcon Data="{StaticResource TerminalIcon}"
                      Width="12" Height="12" />
            <TextBlock Text="{Binding TerminalStatus.TerminalCount}"
                       FontSize="11" />
        </StackPanel>
    </Button>
</Border>
```

### Status Bar Layout (ASCII Diagram)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│ Model: llama.gguf │ 📁 myproject │ [🖥️ bash: ~/project] │ ✓ Saved │ T:0.7  │
└─────────────────────────────────────────────────────────────────────────────┘
                                    ↑
                            Terminal Status Section
                            - Shell name (bash)
                            - Current directory (~/ format)
                            - Running process badge (optional)
                            - Click to toggle terminal
```

### Files to Create (v0.5.5h)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/ViewModels/TerminalStatusBarViewModel.cs` | Status bar ViewModel |
| `src/SeniorIntern.Desktop/Views/TerminalStatusBarSection.axaml` | Status bar section UI |

### Files to Modify (v0.5.5h)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/Views/MainWindow.axaml` | Add terminal status section |
| `src/SeniorIntern.Desktop/ViewModels/MainWindowViewModel.cs` | Include terminal status VM |

### Implementation Notes
- Show abbreviated directory path with ~ for home
- Show running process name when applicable
- Click to toggle terminal visibility
- Right-click context menu for additional actions
- Terminal count badge when multiple terminals open

---

## v0.5.5i: History Management

### Objective
Implement terminal command history management with persistence, search, and navigation capabilities.

### TerminalHistory Model

```csharp
namespace SeniorIntern.Core.Models.Terminal;

/// <summary>
/// A single entry in the terminal command history
/// </summary>
public sealed class TerminalHistoryEntry
{
    /// <summary>
    /// Unique identifier for this entry
    /// </summary>
    public string Id { get; init; } = Guid.NewGuid().ToString();

    /// <summary>
    /// The command that was executed
    /// </summary>
    public string Command { get; init; } = string.Empty;

    /// <summary>
    /// When the command was executed
    /// </summary>
    public DateTime ExecutedAt { get; init; } = DateTime.UtcNow;

    /// <summary>
    /// Working directory when the command was executed
    /// </summary>
    public string? WorkingDirectory { get; init; }

    /// <summary>
    /// Exit code of the command (null if not captured)
    /// </summary>
    public int? ExitCode { get; init; }

    /// <summary>
    /// Duration of command execution (null if not captured)
    /// </summary>
    public TimeSpan? Duration { get; init; }

    /// <summary>
    /// Shell profile ID used
    /// </summary>
    public string? ProfileId { get; init; }
}

/// <summary>
/// Session-level history tracking
/// </summary>
public sealed class TerminalSessionHistory
{
    /// <summary>
    /// Session ID this history belongs to
    /// </summary>
    public string SessionId { get; init; } = string.Empty;

    /// <summary>
    /// When the session was started
    /// </summary>
    public DateTime StartedAt { get; init; } = DateTime.UtcNow;

    /// <summary>
    /// When the session was ended (null if still active)
    /// </summary>
    public DateTime? EndedAt { get; set; }

    /// <summary>
    /// Commands executed in this session
    /// </summary>
    public List<TerminalHistoryEntry> Commands { get; init; } = new();
}
```

### ITerminalHistoryService Interface

```csharp
namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Service for managing terminal command history
/// </summary>
public interface ITerminalHistoryService
{
    /// <summary>
    /// Add a command to the history
    /// </summary>
    Task AddCommandAsync(string sessionId, TerminalHistoryEntry entry);

    /// <summary>
    /// Get recent commands across all sessions
    /// </summary>
    /// <param name="count">Maximum number of entries to return</param>
    Task<IReadOnlyList<TerminalHistoryEntry>> GetRecentCommandsAsync(int count = 100);

    /// <summary>
    /// Get commands for a specific session
    /// </summary>
    Task<IReadOnlyList<TerminalHistoryEntry>> GetSessionHistoryAsync(string sessionId);

    /// <summary>
    /// Search command history
    /// </summary>
    /// <param name="query">Search query</param>
    /// <param name="maxResults">Maximum results to return</param>
    Task<IReadOnlyList<TerminalHistoryEntry>> SearchHistoryAsync(string query, int maxResults = 50);

    /// <summary>
    /// Clear all history
    /// </summary>
    Task ClearAllHistoryAsync();

    /// <summary>
    /// Clear history older than a certain date
    /// </summary>
    Task ClearHistoryOlderThanAsync(DateTime cutoffDate);

    /// <summary>
    /// Get session history records
    /// </summary>
    Task<IReadOnlyList<TerminalSessionHistory>> GetSessionRecordsAsync(int count = 20);

    /// <summary>
    /// Export history to a file
    /// </summary>
    Task ExportHistoryAsync(string filePath, HistoryExportFormat format);

    /// <summary>
    /// Get total command count
    /// </summary>
    Task<int> GetTotalCommandCountAsync();
}

/// <summary>
/// Export format for history
/// </summary>
public enum HistoryExportFormat
{
    Json,
    Csv,
    Text
}
```

### TerminalHistoryService Implementation

```csharp
namespace SeniorIntern.Services;

using System.Text.Json;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models.Terminal;
using SeniorIntern.Data;

/// <summary>
/// Service for managing terminal command history
/// </summary>
public sealed class TerminalHistoryService : ITerminalHistoryService
{
    private readonly IAppDbContext _dbContext;
    private readonly ILogger<TerminalHistoryService> _logger;
    private readonly SemaphoreSlim _writeLock = new(1, 1);

    public TerminalHistoryService(
        IAppDbContext dbContext,
        ILogger<TerminalHistoryService> logger)
    {
        _dbContext = dbContext;
        _logger = logger;
    }

    public async Task AddCommandAsync(string sessionId, TerminalHistoryEntry entry)
    {
        await _writeLock.WaitAsync();
        try
        {
            var historyEntity = new TerminalHistoryEntity
            {
                Id = entry.Id,
                SessionId = sessionId,
                Command = entry.Command,
                ExecutedAt = entry.ExecutedAt,
                WorkingDirectory = entry.WorkingDirectory,
                ExitCode = entry.ExitCode,
                DurationMs = entry.Duration?.TotalMilliseconds,
                ProfileId = entry.ProfileId
            };

            _dbContext.TerminalHistory.Add(historyEntity);
            await _dbContext.SaveChangesAsync();
        }
        finally
        {
            _writeLock.Release();
        }
    }

    public async Task<IReadOnlyList<TerminalHistoryEntry>> GetRecentCommandsAsync(int count = 100)
    {
        return await _dbContext.TerminalHistory
            .OrderByDescending(h => h.ExecutedAt)
            .Take(count)
            .Select(h => ToEntry(h))
            .ToListAsync();
    }

    public async Task<IReadOnlyList<TerminalHistoryEntry>> GetSessionHistoryAsync(string sessionId)
    {
        return await _dbContext.TerminalHistory
            .Where(h => h.SessionId == sessionId)
            .OrderBy(h => h.ExecutedAt)
            .Select(h => ToEntry(h))
            .ToListAsync();
    }

    public async Task<IReadOnlyList<TerminalHistoryEntry>> SearchHistoryAsync(
        string query,
        int maxResults = 50)
    {
        if (string.IsNullOrWhiteSpace(query))
            return Array.Empty<TerminalHistoryEntry>();

        return await _dbContext.TerminalHistory
            .Where(h => EF.Functions.Like(h.Command, $"%{query}%"))
            .OrderByDescending(h => h.ExecutedAt)
            .Take(maxResults)
            .Select(h => ToEntry(h))
            .ToListAsync();
    }

    public async Task ClearAllHistoryAsync()
    {
        await _writeLock.WaitAsync();
        try
        {
            await _dbContext.TerminalHistory.ExecuteDeleteAsync();
        }
        finally
        {
            _writeLock.Release();
        }
    }

    public async Task ClearHistoryOlderThanAsync(DateTime cutoffDate)
    {
        await _writeLock.WaitAsync();
        try
        {
            await _dbContext.TerminalHistory
                .Where(h => h.ExecutedAt < cutoffDate)
                .ExecuteDeleteAsync();
        }
        finally
        {
            _writeLock.Release();
        }
    }

    public async Task ExportHistoryAsync(string filePath, HistoryExportFormat format)
    {
        var history = await GetRecentCommandsAsync(10000);

        switch (format)
        {
            case HistoryExportFormat.Json:
                var json = JsonSerializer.Serialize(history, new JsonSerializerOptions
                {
                    WriteIndented = true
                });
                await File.WriteAllTextAsync(filePath, json);
                break;

            case HistoryExportFormat.Csv:
                var csv = "Command,ExecutedAt,WorkingDirectory,ExitCode,Duration\n" +
                    string.Join("\n", history.Select(h =>
                        $"\"{h.Command.Replace("\"", "\"\"")}\",{h.ExecutedAt:O},{h.WorkingDirectory},{h.ExitCode},{h.Duration}"));
                await File.WriteAllTextAsync(filePath, csv);
                break;

            case HistoryExportFormat.Text:
                var text = string.Join("\n", history.Select(h => h.Command));
                await File.WriteAllTextAsync(filePath, text);
                break;
        }
    }

    public async Task<int> GetTotalCommandCountAsync()
    {
        return await _dbContext.TerminalHistory.CountAsync();
    }

    private static TerminalHistoryEntry ToEntry(TerminalHistoryEntity entity) => new()
    {
        Id = entity.Id,
        Command = entity.Command,
        ExecutedAt = entity.ExecutedAt,
        WorkingDirectory = entity.WorkingDirectory,
        ExitCode = entity.ExitCode,
        Duration = entity.DurationMs.HasValue
            ? TimeSpan.FromMilliseconds(entity.DurationMs.Value)
            : null,
        ProfileId = entity.ProfileId
    };
}
```

### Database Entity

```csharp
namespace SeniorIntern.Data.Entities;

/// <summary>
/// Database entity for terminal command history
/// </summary>
public sealed class TerminalHistoryEntity
{
    public string Id { get; set; } = string.Empty;
    public string SessionId { get; set; } = string.Empty;
    public string Command { get; set; } = string.Empty;
    public DateTime ExecutedAt { get; set; }
    public string? WorkingDirectory { get; set; }
    public int? ExitCode { get; set; }
    public double? DurationMs { get; set; }
    public string? ProfileId { get; set; }
}
```

### Files to Create (v0.5.5i)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Models/Terminal/TerminalHistoryEntry.cs` | History entry model |
| `src/SeniorIntern.Core/Models/Terminal/TerminalSessionHistory.cs` | Session history model |
| `src/SeniorIntern.Core/Interfaces/ITerminalHistoryService.cs` | History service interface |
| `src/SeniorIntern.Services/Terminal/TerminalHistoryService.cs` | History service implementation |
| `src/SeniorIntern.Data/Entities/TerminalHistoryEntity.cs` | Database entity |

### Files to Modify (v0.5.5i)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Data/AppDbContext.cs` | Add TerminalHistory DbSet |
| `src/SeniorIntern.Services/ServiceCollectionExtensions.cs` | Register history service |

### Implementation Notes
- Persist history to SQLite database
- Support search with LIKE queries
- Export to multiple formats
- Automatic cleanup of old history (configurable)
- Session-based grouping for history browser

---

## v0.5.5j: Integration Testing

### Objective
Create comprehensive integration tests covering all terminal functionality across platforms.

### Test Categories

```csharp
namespace SeniorIntern.Tests.Integration.Terminal;

/// <summary>
/// Integration tests for terminal search functionality
/// </summary>
[TestFixture]
public class TerminalSearchTests
{
    private ITerminalSearchService _searchService;
    private MockTerminalBuffer _buffer;

    [SetUp]
    public void SetUp()
    {
        _searchService = new TerminalSearchService(NullLogger<TerminalSearchService>.Instance);
        _buffer = new MockTerminalBuffer();
    }

    [Test]
    public async Task Search_PlainText_FindsAllMatches()
    {
        // Arrange
        _buffer.AddLines(
            "Hello World",
            "hello again",
            "HELLO there"
        );

        // Act
        var state = await _searchService.SearchAsync(
            _buffer,
            "hello",
            new TerminalSearchOptions { DefaultCaseSensitive = false });

        // Assert
        Assert.That(state.Results, Has.Count.EqualTo(3));
    }

    [Test]
    public async Task Search_CaseSensitive_OnlyMatchesExact()
    {
        // Arrange
        _buffer.AddLines("Hello", "hello", "HELLO");

        // Act
        var state = await _searchService.SearchAsync(
            _buffer,
            "hello",
            new TerminalSearchOptions { DefaultCaseSensitive = true });

        // Assert
        Assert.That(state.Results, Has.Count.EqualTo(1));
        Assert.That(state.Results[0].LineIndex, Is.EqualTo(1));
    }

    [Test]
    public async Task Search_Regex_MatchesPattern()
    {
        // Arrange
        _buffer.AddLines(
            "Error: file not found",
            "Warning: deprecated API",
            "Error: connection failed"
        );

        // Act
        var state = await _searchService.SearchAsync(
            _buffer,
            "Error:.*",
            new TerminalSearchOptions { DefaultUseRegex = true });

        // Assert
        Assert.That(state.Results, Has.Count.EqualTo(2));
    }

    [Test]
    public async Task Search_InvalidRegex_ReturnsError()
    {
        // Arrange
        _buffer.AddLines("test");

        // Act
        var state = await _searchService.SearchAsync(
            _buffer,
            "[invalid",
            new TerminalSearchOptions { DefaultUseRegex = true });

        // Assert
        Assert.That(state.ErrorMessage, Is.Not.Null);
        Assert.That(state.Results, Is.Empty);
    }

    [Test]
    public void NavigateNext_WrapsAround()
    {
        // Arrange
        var state = new TerminalSearchState
        {
            Results = new[]
            {
                new TerminalSearchResult { LineIndex = 0 },
                new TerminalSearchResult { LineIndex = 1 },
                new TerminalSearchResult { LineIndex = 2 }
            },
            CurrentResultIndex = 2,
            WrapAround = true
        };

        // Act
        var newState = _searchService.NavigateNext(state);

        // Assert
        Assert.That(newState.CurrentResultIndex, Is.EqualTo(0));
    }
}

/// <summary>
/// Integration tests for keyboard shortcuts
/// </summary>
[TestFixture]
public class KeyboardShortcutTests
{
    private IKeyboardShortcutService _shortcutService;

    [SetUp]
    public void SetUp()
    {
        var settingsService = new MockSettingsService();
        _shortcutService = new KeyboardShortcutService(settingsService);
    }

    [Test]
    public void TryGetAction_CtrlBacktick_ReturnsToggleTerminal()
    {
        // Act
        var found = _shortcutService.TryGetAction(
            Key.OemTilde,
            KeyModifiers.Control,
            out var action);

        // Assert
        Assert.That(found, Is.True);
        Assert.That(action, Is.EqualTo(TerminalShortcutAction.ToggleTerminal));
    }

    [Test]
    public void UpdateBinding_UpdatesSuccessfully()
    {
        // Act
        var updated = _shortcutService.UpdateBinding(
            TerminalShortcutAction.ToggleTerminal,
            Key.T,
            KeyModifiers.Control | KeyModifiers.Alt);

        // Assert
        Assert.That(updated, Is.True);

        var found = _shortcutService.TryGetAction(
            Key.T,
            KeyModifiers.Control | KeyModifiers.Alt,
            out var action);
        Assert.That(found, Is.True);
        Assert.That(action, Is.EqualTo(TerminalShortcutAction.ToggleTerminal));
    }

    [Test]
    public void UpdateBinding_Conflict_ReturnsFalse()
    {
        // Arrange - Ctrl+F is already OpenSearch

        // Act
        var updated = _shortcutService.UpdateBinding(
            TerminalShortcutAction.NewTerminal,
            Key.F,
            KeyModifiers.Control);

        // Assert
        Assert.That(updated, Is.False);
    }

    [Test]
    public void GetAllBindings_ReturnsAllDefaultBindings()
    {
        // Act
        var bindings = _shortcutService.GetAllBindings();

        // Assert
        Assert.That(bindings, Has.Count.GreaterThan(20));
        Assert.That(bindings.Select(b => b.Action),
            Does.Contain(TerminalShortcutAction.ToggleTerminal));
    }
}

/// <summary>
/// Integration tests for terminal settings
/// </summary>
[TestFixture]
public class TerminalSettingsTests
{
    [Test]
    public void TerminalSettings_DefaultValues_AreReasonable()
    {
        // Act
        var settings = new TerminalSettings();

        // Assert
        Assert.That(settings.FontSize, Is.InRange(10, 20));
        Assert.That(settings.ScrollbackLines, Is.GreaterThan(1000));
        Assert.That(settings.CursorStyle, Is.EqualTo(TerminalCursorStyle.Block));
    }

    [Test]
    public void TerminalTheme_GetAnsiColor_ReturnsCorrectColors()
    {
        // Arrange
        var theme = TerminalTheme.DefaultDark;

        // Act & Assert
        Assert.That(theme.GetAnsiColor(0), Is.EqualTo(theme.Black));
        Assert.That(theme.GetAnsiColor(1), Is.EqualTo(theme.Red));
        Assert.That(theme.GetAnsiColor(8), Is.EqualTo(theme.BrightBlack));
        Assert.That(theme.GetAnsiColor(15), Is.EqualTo(theme.BrightWhite));
    }
}

/// <summary>
/// Integration tests for terminal history
/// </summary>
[TestFixture]
public class TerminalHistoryTests
{
    private ITerminalHistoryService _historyService;
    private TestAppDbContext _dbContext;

    [SetUp]
    public void SetUp()
    {
        _dbContext = new TestAppDbContext();
        _historyService = new TerminalHistoryService(
            _dbContext,
            NullLogger<TerminalHistoryService>.Instance);
    }

    [TearDown]
    public void TearDown()
    {
        _dbContext.Dispose();
    }

    [Test]
    public async Task AddCommand_StoresInDatabase()
    {
        // Arrange
        var entry = new TerminalHistoryEntry
        {
            Command = "ls -la",
            WorkingDirectory = "/home/user"
        };

        // Act
        await _historyService.AddCommandAsync("session1", entry);

        // Assert
        var history = await _historyService.GetRecentCommandsAsync(10);
        Assert.That(history, Has.Count.EqualTo(1));
        Assert.That(history[0].Command, Is.EqualTo("ls -la"));
    }

    [Test]
    public async Task SearchHistory_FindsMatchingCommands()
    {
        // Arrange
        await _historyService.AddCommandAsync("s1", new TerminalHistoryEntry { Command = "git status" });
        await _historyService.AddCommandAsync("s1", new TerminalHistoryEntry { Command = "git commit" });
        await _historyService.AddCommandAsync("s1", new TerminalHistoryEntry { Command = "npm install" });

        // Act
        var results = await _historyService.SearchHistoryAsync("git");

        // Assert
        Assert.That(results, Has.Count.EqualTo(2));
    }

    [Test]
    public async Task ClearHistoryOlderThan_RemovesOldEntries()
    {
        // Arrange
        await _historyService.AddCommandAsync("s1", new TerminalHistoryEntry
        {
            Command = "old command",
            ExecutedAt = DateTime.UtcNow.AddDays(-30)
        });
        await _historyService.AddCommandAsync("s1", new TerminalHistoryEntry
        {
            Command = "new command",
            ExecutedAt = DateTime.UtcNow
        });

        // Act
        await _historyService.ClearHistoryOlderThanAsync(DateTime.UtcNow.AddDays(-7));

        // Assert
        var history = await _historyService.GetRecentCommandsAsync(10);
        Assert.That(history, Has.Count.EqualTo(1));
        Assert.That(history[0].Command, Is.EqualTo("new command"));
    }
}

/// <summary>
/// Cross-platform integration tests
/// </summary>
[TestFixture]
public class CrossPlatformTerminalTests
{
    [Test]
    [Platform("Win")]
    public void DefaultFont_Windows_IsCascadiaOrConsolas()
    {
        var settings = new TerminalSettings();
        Assert.That(settings.FontFamily, Does.Contain("Cascadia").Or.Contains("Consolas"));
    }

    [Test]
    [Platform("MacOsX")]
    public void DefaultFont_MacOS_IsSFMonoOrMenlo()
    {
        var settings = new TerminalSettings();
        Assert.That(settings.FontFamily, Does.Contain("SF Mono").Or.Contains("Menlo"));
    }

    [Test]
    [Platform("Linux")]
    public void DefaultFont_Linux_IsUbuntuMonoOrDejaVu()
    {
        var settings = new TerminalSettings();
        Assert.That(settings.FontFamily, Does.Contain("Ubuntu Mono").Or.Contains("DejaVu"));
    }
}
```

### Performance Benchmarks

```csharp
namespace SeniorIntern.Tests.Performance;

using BenchmarkDotNet.Attributes;

[MemoryDiagnoser]
public class TerminalSearchBenchmarks
{
    private ITerminalSearchService _searchService;
    private ITerminalBuffer _largeBuffer;

    [GlobalSetup]
    public void Setup()
    {
        _searchService = new TerminalSearchService(NullLogger<TerminalSearchService>.Instance);
        _largeBuffer = CreateLargeBuffer(100000); // 100k lines
    }

    [Benchmark]
    public async Task Search_PlainText_100kLines()
    {
        await _searchService.SearchAsync(
            _largeBuffer,
            "error",
            new TerminalSearchOptions());
    }

    [Benchmark]
    public async Task Search_Regex_100kLines()
    {
        await _searchService.SearchAsync(
            _largeBuffer,
            "ERROR\\[\\d+\\]",
            new TerminalSearchOptions { DefaultUseRegex = true });
    }

    private static ITerminalBuffer CreateLargeBuffer(int lineCount)
    {
        var buffer = new MockTerminalBuffer();
        for (int i = 0; i < lineCount; i++)
        {
            buffer.AddLine($"[{DateTime.Now:HH:mm:ss}] Log line {i}: Some content here{(i % 100 == 0 ? " ERROR[123]" : "")}");
        }
        return buffer;
    }
}
```

### Test Coverage Requirements

| Component | Minimum Coverage | Focus Areas |
|-----------|-----------------|-------------|
| TerminalSearchService | 90% | Edge cases, regex patterns, cancellation |
| KeyboardShortcutService | 85% | Conflict detection, persistence |
| TerminalSettingsViewModel | 80% | Validation, live preview |
| TerminalHistoryService | 85% | CRUD operations, search |
| ShellProfileEditor | 75% | Validation, path detection |

### Files to Create (v0.5.5j)

| File | Purpose |
|------|---------|
| `tests/SeniorIntern.Tests.Integration/Terminal/TerminalSearchTests.cs` | Search tests |
| `tests/SeniorIntern.Tests.Integration/Terminal/KeyboardShortcutTests.cs` | Shortcut tests |
| `tests/SeniorIntern.Tests.Integration/Terminal/TerminalSettingsTests.cs` | Settings tests |
| `tests/SeniorIntern.Tests.Integration/Terminal/TerminalHistoryTests.cs` | History tests |
| `tests/SeniorIntern.Tests.Integration/Terminal/CrossPlatformTerminalTests.cs` | Platform tests |
| `tests/SeniorIntern.Tests.Performance/TerminalSearchBenchmarks.cs` | Performance benchmarks |
| `tests/SeniorIntern.Tests.Integration/Mocks/MockTerminalBuffer.cs` | Test mock |
| `tests/SeniorIntern.Tests.Integration/Mocks/MockSettingsService.cs` | Test mock |

### Implementation Notes
- Use xUnit or NUnit for integration tests
- BenchmarkDotNet for performance testing
- Platform-specific tests with conditional attributes
- In-memory SQLite for database tests
- Test timeouts for async operations

---

## Summary

### Files to Create (Complete v0.5.5)

| Sub-Part | File Count | Key Files |
|----------|------------|-----------|
| v0.5.5a | 4 | TerminalSearchResult.cs, TerminalSearchState.cs |
| v0.5.5b | 2 | ITerminalSearchService.cs, TerminalSearchService.cs |
| v0.5.5c | 3 | TerminalSearchBar.axaml, TerminalSearchBarViewModel.cs |
| v0.5.5d | 4 | TerminalShortcutAction.cs, KeyBinding.cs, KeyboardShortcutService.cs |
| v0.5.5e | 6 | TerminalSettings.cs, TerminalTheme.cs, FontService.cs |
| v0.5.5f | 4 | TerminalSettingsPanel.axaml, TerminalSettingsViewModel.cs |
| v0.5.5g | 3 | ShellProfileEditor.axaml, ShellProfileEditorViewModel.cs |
| v0.5.5h | 2 | TerminalStatusBarViewModel.cs, TerminalStatusBarSection.axaml |
| v0.5.5i | 5 | TerminalHistoryEntry.cs, ITerminalHistoryService.cs, TerminalHistoryService.cs |
| v0.5.5j | 8 | Various test files and mocks |
| **Total** | **41** | |

### Files to Modify (Complete v0.5.5)

| File | Sub-Parts Affecting |
|------|-------------------|
| `src/SeniorIntern.Core/Interfaces/ITerminalBuffer.cs` | v0.5.5b |
| `src/SeniorIntern.Core/Models/AppSettings.cs` | v0.5.5d, v0.5.5e |
| `src/SeniorIntern.Desktop/Controls/TerminalControl.axaml.cs` | v0.5.5d |
| `src/SeniorIntern.Desktop/Controls/TerminalRenderer.cs` | v0.5.5c |
| `src/SeniorIntern.Desktop/Views/TerminalPanel.axaml` | v0.5.5c |
| `src/SeniorIntern.Desktop/ViewModels/TerminalPanelViewModel.cs` | v0.5.5c |
| `src/SeniorIntern.Desktop/Views/SettingsView.axaml` | v0.5.5f |
| `src/SeniorIntern.Desktop/Views/MainWindow.axaml` | v0.5.5h |
| `src/SeniorIntern.Desktop/ViewModels/MainWindowViewModel.cs` | v0.5.5h |
| `src/SeniorIntern.Data/AppDbContext.cs` | v0.5.5i |
| `src/SeniorIntern.Services/ServiceCollectionExtensions.cs` | v0.5.5b, v0.5.5d, v0.5.5e, v0.5.5i |

### Dependencies

| Sub-Part | Depends On |
|----------|------------|
| v0.5.5a | None (models only) |
| v0.5.5b | v0.5.5a |
| v0.5.5c | v0.5.5a, v0.5.5b |
| v0.5.5d | None |
| v0.5.5e | None (models only) |
| v0.5.5f | v0.5.5e |
| v0.5.5g | v0.5.3 (Shell profiles) |
| v0.5.5h | v0.5.2 (Terminal service) |
| v0.5.5i | None |
| v0.5.5j | All above |

### Recommended Implementation Order

1. **v0.5.5a** - Search models (foundation)
2. **v0.5.5e** - Settings models (foundation)
3. **v0.5.5d** - Keyboard shortcuts (independent)
4. **v0.5.5b** - Search service (depends on a)
5. **v0.5.5i** - History management (independent)
6. **v0.5.5c** - Search UI (depends on a, b)
7. **v0.5.5f** - Settings panel (depends on e)
8. **v0.5.5g** - Profile editor (depends on v0.5.3)
9. **v0.5.5h** - Status bar (depends on v0.5.2)
10. **v0.5.5j** - Integration tests (depends on all)

---

## Acceptance Criteria

### v0.5.5 Complete
- [ ] Terminal search works with plain text and regex patterns
- [ ] Search highlights results in terminal with current result indicator
- [ ] All keyboard shortcuts are functional and documented
- [ ] Keyboard shortcuts can be customized and persist
- [ ] Terminal settings panel allows customization of appearance
- [ ] Terminal settings panel allows customization of behavior
- [ ] Shell profiles can be created, edited, and deleted
- [ ] Status bar shows active terminal information
- [ ] Status bar provides quick actions (toggle, new terminal)
- [ ] Command history is persisted and searchable
- [ ] History can be exported in multiple formats
- [ ] All tests pass on Windows, macOS, and Linux
- [ ] Performance benchmarks meet targets (search < 100ms for 100k lines)

---

## References

- [v0.5.0 Integrated Terminal Design](v0.5.0-integrated-terminal.md)
- [v0.5.3 Shell Integration Design](v0.5.3-shell-integration.md)
- [v0.5.4 Command Integration Design](v0.5.4-command-integration.md)
- [Avalonia UI Documentation](https://docs.avaloniaui.net/)
- [CommunityToolkit.Mvvm Documentation](https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/)
- [xterm.js Search Implementation](https://github.com/xtermjs/xterm.js/tree/master/addons/xterm-addon-search)
- [Windows Terminal Settings](https://docs.microsoft.com/en-us/windows/terminal/customize-settings/startup)
