# Design Specification: AIntern v0.5.4c "Command Execution Service"

## Overview

**Version**: v0.5.4c
**Parent**: v0.5.4 Command Integration
**Focus**: Terminal execution, clipboard integration, status tracking, session management

### Purpose

This sub-version creates a service that executes commands in terminal sessions:
1. Copy command text to system clipboard
2. Send command to terminal without executing (user presses Enter)
3. Execute command in terminal (sends command + Enter key)
4. Execute multiple commands sequentially with stop-on-error option
5. Cancel running command (sends Ctrl+C / SIGINT)
6. Track command execution status with event notifications
7. Create or reuse terminal sessions based on shell type preferences

### Dependencies

**From v0.5.4a (Command Block Models)**:
- `CommandBlock` - Command to execute
- `CommandBlockStatus` - Status tracking
- `TerminalOutputCapture` - Captured output container

**From v0.5.4d (Output Capture - forward reference)**:
- `IOutputCaptureService` - Output capture coordination

**From v0.5.3d (Profile Management)**:
- `IShellProfileService` - Profile lookup for session creation

**From v0.5.1 (Terminal Foundation)**:
- `ITerminalService` - Terminal session management

**From Avalonia**:
- `IClipboard` - System clipboard access

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                  v0.5.4c Command Execution Service Architecture               │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                        Interface Layer                                   │ │
│  │  src/AIntern.Core/Interfaces/                                           │ │
│  ├─────────────────────────────────────────────────────────────────────────┤ │
│  │  ICommandExecutionService                                                │ │
│  │  ├── Events:                                                            │ │
│  │  │   └── StatusChanged: EventHandler<CommandStatusChangedEventArgs>     │ │
│  │  ├── Clipboard:                                                         │ │
│  │  │   └── CopyToClipboardAsync(command)                                  │ │
│  │  ├── Terminal:                                                          │ │
│  │  │   ├── SendToTerminalAsync(command, sessionId?)                       │ │
│  │  │   ├── ExecuteAsync(command, sessionId?, captureOutput?)              │ │
│  │  │   ├── ExecuteAllAsync(commands, sessionId?, stopOnError?, capture?)  │ │
│  │  │   └── CancelExecutionAsync(sessionId)                                │ │
│  │  ├── Status:                                                            │ │
│  │  │   └── GetStatus(commandId) → CommandBlockStatus                      │ │
│  │  └── Session:                                                           │ │
│  │      └── EnsureTerminalSessionAsync(shell?, workingDir?)                │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                     Model Layer                                          │ │
│  │  src/AIntern.Core/Models/Terminal/                                      │ │
│  ├─────────────────────────────────────────────────────────────────────────┤ │
│  │                                                                          │ │
│  │  CommandExecutionResult                 CommandStatusChangedEventArgs   │ │
│  │  ├── CommandId: Guid                    ├── CommandId: Guid             │ │
│  │  ├── Status: CommandBlockStatus         ├── OldStatus: CommandBlockStatus │
│  │  ├── SessionId: Guid                    ├── NewStatus: CommandBlockStatus │
│  │  ├── ExecutedAt: DateTime               └── SessionId: Guid?            │ │
│  │  ├── Duration: TimeSpan?                                                │ │
│  │  ├── OutputCapture: TerminalOutputCapture?                              │ │
│  │  └── ErrorMessage: string?                                              │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                     Implementation Layer                                 │ │
│  │  src/AIntern.Services/Terminal/                                         │ │
│  ├─────────────────────────────────────────────────────────────────────────┤ │
│  │  CommandExecutionService : ICommandExecutionService                      │ │
│  │  ├── Dependencies:                                                      │ │
│  │  │   ├── ITerminalService                                               │ │
│  │  │   ├── IShellProfileService                                           │ │
│  │  │   ├── IOutputCaptureService                                          │ │
│  │  │   ├── IClipboard                                                     │ │
│  │  │   └── ILogger<CommandExecutionService>                               │ │
│  │  ├── State:                                                             │ │
│  │  │   └── _commandStatuses: ConcurrentDictionary<Guid, CommandBlockStatus>│ │
│  │  └── Methods:                                                           │ │
│  │      ├── CopyToClipboardAsync()                                         │ │
│  │      ├── SendToTerminalAsync()                                          │ │
│  │      ├── ExecuteAsync()                                                 │ │
│  │      ├── ExecuteAllAsync()                                              │ │
│  │      ├── CancelExecutionAsync()                                         │ │
│  │      ├── EnsureTerminalSessionAsync()                                   │ │
│  │      ├── FindProfileForShellTypeAsync()                                 │ │
│  │      ├── GetNewlineForSession()                                         │ │
│  │      └── UpdateStatus()                                                 │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Execution Flow

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                       Command Execution Flow                                  │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  User Action: Click "Run" button on CommandBlock                             │
│                                                                              │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  ExecuteAsync(command, targetSessionId?, captureOutput?)              │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                           │                                                  │
│                           ▼                                                  │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  STEP 1: Ensure Terminal Session                                      │  │
│  │  ─────────────────────────────────────────────────────────────────────│  │
│  │  Call EnsureTerminalSessionAsync(command.DetectedShellType,           │  │
│  │                                   command.WorkingDirectory)           │  │
│  │  • If activeSession matches → reuse it                                │  │
│  │  • Else → create new session from profile                            │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                           │                                                  │
│                           ▼                                                  │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  STEP 2: Update Status → Executing                                    │  │
│  │  ─────────────────────────────────────────────────────────────────────│  │
│  │  UpdateStatus(command.Id, CommandBlockStatus.Executing)               │  │
│  │  → Raises StatusChanged event                                         │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                           │                                                  │
│                           ▼                                                  │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  STEP 3: Start Output Capture (if requested)                          │  │
│  │  ─────────────────────────────────────────────────────────────────────│  │
│  │  If captureOutput:                                                    │  │
│  │    _outputCapture.StartCapture(sessionId, command.Command)            │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                           │                                                  │
│                           ▼                                                  │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  STEP 4: Send Command to Terminal                                     │  │
│  │  ─────────────────────────────────────────────────────────────────────│  │
│  │  commandWithNewline = command.Command.TrimEnd() + "\r"                │  │
│  │  await _terminalService.WriteInputAsync(sessionId, commandWithNewline)│  │
│  │                                                                        │  │
│  │  command.ExecutedAt = DateTime.UtcNow                                 │  │
│  │  command.ExecutedInSessionId = sessionId                              │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                           │                                                  │
│                           ▼                                                  │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  STEP 5: Wait & Capture Output (if requested)                         │  │
│  │  ─────────────────────────────────────────────────────────────────────│  │
│  │  If captureOutput:                                                    │  │
│  │    await Task.Delay(500) // Allow command to start                   │  │
│  │    capture = await _outputCapture.StopCaptureAsync(sessionId)        │  │
│  │    command.OutputCaptureId = capture?.Id                              │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                           │                                                  │
│                           ▼                                                  │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  STEP 6: Update Status → Executed/Failed                              │  │
│  │  ─────────────────────────────────────────────────────────────────────│  │
│  │  On success: UpdateStatus(command.Id, CommandBlockStatus.Executed)    │  │
│  │  On cancel:  UpdateStatus(command.Id, CommandBlockStatus.Cancelled)   │  │
│  │  On error:   UpdateStatus(command.Id, CommandBlockStatus.Failed)      │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                           │                                                  │
│                           ▼                                                  │
│  Return: CommandExecutionResult                                              │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Session Management

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                    EnsureTerminalSessionAsync Logic                           │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Input: preferredShell (ShellType?), workingDirectory (string?)              │
│                                                                              │
│             ┌─────────────────────────────┐                                  │
│             │  Get ActiveSession          │                                  │
│             └──────────────┬──────────────┘                                  │
│                            │                                                  │
│                    activeSession != null?                                    │
│                     /              \                                         │
│                   YES               NO                                       │
│                   /                   \                                      │
│        ┌─────────────────────┐   ┌─────────────────────────────┐            │
│        │ Shell type matches? │   │ Create new session          │            │
│        │ (preferredShell is  │   │ ─────────────────────────── │            │
│        │  null OR equals     │   │ profile = FindProfileFor    │            │
│        │  activeSession.Type)│   │          ShellType() OR     │            │
│        └──────────┬──────────┘   │          GetDefaultProfile()│            │
│                   │               │                             │            │
│              matches?             │ session = CreateSession(    │            │
│               /    \              │   ShellPath, Arguments,     │            │
│             YES     NO            │   WorkingDirectory,         │            │
│             /         \           │   Environment, Name)        │            │
│    ┌────────────┐  ┌────────────┐│                             │            │
│    │ Return     │  │ Create new ││                             │            │
│    │ activeId   │  │ session    │└─────────────────────────────┘            │
│    └────────────┘  └────────────┘         │                                 │
│                                           │                                  │
│                                           ▼                                  │
│                                    Return session.Id                         │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Multi-Command Execution

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                    ExecuteAllAsync Sequential Execution                       │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Input: commands[], targetSessionId?, stopOnError, captureOutput             │
│                                                                              │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  For each command in commands:                                        │  │
│  │  ─────────────────────────────────────────────────────────────────────│  │
│  │                                                                        │  │
│  │    ┌─────────────────────────────────────────────────────────────┐    │  │
│  │    │  Check cancellation token                                    │    │  │
│  │    └─────────────────────────────────────────────────────────────┘    │  │
│  │                            │                                           │  │
│  │                            ▼                                           │  │
│  │    ┌─────────────────────────────────────────────────────────────┐    │  │
│  │    │  result = ExecuteAsync(command, sessionId, captureOutput)   │    │  │
│  │    │  → Uses same sessionId for all commands                     │    │  │
│  │    └─────────────────────────────────────────────────────────────┘    │  │
│  │                            │                                           │  │
│  │                            ▼                                           │  │
│  │    ┌─────────────────────────────────────────────────────────────┐    │  │
│  │    │  results.Add(result)                                        │    │  │
│  │    │  sessionId = result.SessionId (reuse for next command)      │    │  │
│  │    └─────────────────────────────────────────────────────────────┘    │  │
│  │                            │                                           │  │
│  │                            ▼                                           │  │
│  │    ┌─────────────────────────────────────────────────────────────┐    │  │
│  │    │  If stopOnError AND result.Status == Failed:                │    │  │
│  │    │    → BREAK (stop executing remaining commands)              │    │  │
│  │    └─────────────────────────────────────────────────────────────┘    │  │
│  │                            │                                           │  │
│  │                            ▼                                           │  │
│  │    ┌─────────────────────────────────────────────────────────────┐    │  │
│  │    │  await Task.Delay(100ms) // Small pause between commands    │    │  │
│  │    └─────────────────────────────────────────────────────────────┘    │  │
│  │                                                                        │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                                                              │
│  Return: results[] (CommandExecutionResult for each executed command)        │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Specifications

### 1. CommandStatusChangedEventArgs.cs

**Location**: `src/AIntern.Core/Models/Terminal/CommandStatusChangedEventArgs.cs`

```csharp
namespace AIntern.Core.Models.Terminal;

/// <summary>
/// Event args for command status change notifications.
/// </summary>
public sealed class CommandStatusChangedEventArgs : EventArgs
{
    /// <summary>ID of the command whose status changed.</summary>
    public Guid CommandId { get; init; }

    /// <summary>Previous status of the command.</summary>
    public CommandBlockStatus OldStatus { get; init; }

    /// <summary>New status of the command.</summary>
    public CommandBlockStatus NewStatus { get; init; }

    /// <summary>ID of the terminal session (if applicable).</summary>
    public Guid? SessionId { get; init; }

    /// <summary>Timestamp of the status change.</summary>
    public DateTime Timestamp { get; init; } = DateTime.UtcNow;
}
```

### 2. CommandExecutionResult.cs

**Location**: `src/AIntern.Core/Models/Terminal/CommandExecutionResult.cs`

```csharp
namespace AIntern.Core.Models.Terminal;

/// <summary>
/// Result of executing a command in the terminal.
/// </summary>
public sealed class CommandExecutionResult
{
    /// <summary>ID of the command that was executed.</summary>
    public Guid CommandId { get; init; }

    /// <summary>Final status of the command.</summary>
    public CommandBlockStatus Status { get; init; }

    /// <summary>ID of the terminal session used.</summary>
    public Guid SessionId { get; init; }

    /// <summary>When execution started.</summary>
    public DateTime ExecutedAt { get; init; }

    /// <summary>How long the execution took.</summary>
    public TimeSpan? Duration { get; init; }

    /// <summary>Captured output (if capture was requested).</summary>
    public TerminalOutputCapture? OutputCapture { get; init; }

    /// <summary>Error message if execution failed.</summary>
    public string? ErrorMessage { get; init; }

    // === Computed Properties ===

    /// <summary>Whether execution completed successfully.</summary>
    public bool IsSuccess => Status == CommandBlockStatus.Executed;

    /// <summary>Whether execution failed.</summary>
    public bool IsFailed => Status == CommandBlockStatus.Failed;

    /// <summary>Whether execution was cancelled.</summary>
    public bool IsCancelled => Status == CommandBlockStatus.Cancelled;

    /// <summary>Whether output was captured.</summary>
    public bool HasOutput => OutputCapture != null;
}
```

### 3. ICommandExecutionService.cs

**Location**: `src/AIntern.Core/Interfaces/ICommandExecutionService.cs`

```csharp
namespace AIntern.Core.Interfaces;

using AIntern.Core.Models.Terminal;

/// <summary>
/// Service for executing commands in terminal sessions.
/// </summary>
public interface ICommandExecutionService
{
    /// <summary>
    /// Event raised when a command's execution status changes.
    /// </summary>
    event EventHandler<CommandStatusChangedEventArgs>? StatusChanged;

    /// <summary>
    /// Copy command text to the system clipboard.
    /// </summary>
    /// <param name="command">The command to copy.</param>
    /// <param name="ct">Cancellation token.</param>
    Task CopyToClipboardAsync(CommandBlock command, CancellationToken ct = default);

    /// <summary>
    /// Send command text to terminal without executing (user must press Enter).
    /// </summary>
    /// <param name="command">The command to send.</param>
    /// <param name="targetSessionId">Specific session to target, or null for active/new.</param>
    /// <param name="ct">Cancellation token.</param>
    Task SendToTerminalAsync(
        CommandBlock command,
        Guid? targetSessionId = null,
        CancellationToken ct = default);

    /// <summary>
    /// Execute command in terminal (sends command + Enter key).
    /// </summary>
    /// <param name="command">The command to execute.</param>
    /// <param name="targetSessionId">Specific session to target, or null for active/new.</param>
    /// <param name="captureOutput">Whether to capture command output.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>Execution result with status and optional captured output.</returns>
    Task<CommandExecutionResult> ExecuteAsync(
        CommandBlock command,
        Guid? targetSessionId = null,
        bool captureOutput = false,
        CancellationToken ct = default);

    /// <summary>
    /// Execute multiple commands sequentially in the same terminal session.
    /// </summary>
    /// <param name="commands">Commands to execute in order.</param>
    /// <param name="targetSessionId">Specific session to target, or null for active/new.</param>
    /// <param name="stopOnError">Stop executing if a command fails.</param>
    /// <param name="captureOutput">Whether to capture output from each command.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>Results for each executed command.</returns>
    Task<IReadOnlyList<CommandExecutionResult>> ExecuteAllAsync(
        IEnumerable<CommandBlock> commands,
        Guid? targetSessionId = null,
        bool stopOnError = true,
        bool captureOutput = false,
        CancellationToken ct = default);

    /// <summary>
    /// Cancel a running command by sending Ctrl+C (SIGINT) to the terminal.
    /// </summary>
    /// <param name="sessionId">The session to send the interrupt signal to.</param>
    /// <param name="ct">Cancellation token.</param>
    Task CancelExecutionAsync(Guid sessionId, CancellationToken ct = default);

    /// <summary>
    /// Get the current execution status of a command.
    /// </summary>
    /// <param name="commandId">The command ID.</param>
    /// <returns>Current status, or Pending if unknown.</returns>
    CommandBlockStatus GetStatus(Guid commandId);

    /// <summary>
    /// Ensure a terminal session exists, creating one if needed.
    /// </summary>
    /// <param name="preferredShell">Preferred shell type, or null for default.</param>
    /// <param name="workingDirectory">Working directory for new sessions.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>Session ID of existing or newly created session.</returns>
    Task<Guid> EnsureTerminalSessionAsync(
        ShellType? preferredShell = null,
        string? workingDirectory = null,
        CancellationToken ct = default);
}
```

### 4. CommandExecutionService.cs

**Location**: `src/AIntern.Services/Terminal/CommandExecutionService.cs`

```csharp
namespace AIntern.Services.Terminal;

using System.Collections.Concurrent;
using Avalonia.Input.Platform;
using Microsoft.Extensions.Logging;
using AIntern.Core.Interfaces;
using AIntern.Core.Models.Terminal;

/// <summary>
/// Handles command execution in terminal sessions.
/// </summary>
public sealed class CommandExecutionService : ICommandExecutionService
{
    private readonly ITerminalService _terminalService;
    private readonly IShellProfileService _profileService;
    private readonly IOutputCaptureService _outputCapture;
    private readonly IClipboard _clipboard;
    private readonly ILogger<CommandExecutionService> _logger;

    private readonly ConcurrentDictionary<Guid, CommandBlockStatus> _commandStatuses = new();

    public event EventHandler<CommandStatusChangedEventArgs>? StatusChanged;

    public CommandExecutionService(
        ITerminalService terminalService,
        IShellProfileService profileService,
        IOutputCaptureService outputCapture,
        IClipboard clipboard,
        ILogger<CommandExecutionService> logger)
    {
        _terminalService = terminalService;
        _profileService = profileService;
        _outputCapture = outputCapture;
        _clipboard = clipboard;
        _logger = logger;
    }

    // === Clipboard Operations ===

    public async Task CopyToClipboardAsync(CommandBlock command, CancellationToken ct = default)
    {
        ct.ThrowIfCancellationRequested();

        await _clipboard.SetTextAsync(command.Command);
        UpdateStatus(command.Id, CommandBlockStatus.Copied);

        _logger.LogDebug("Copied command {Id} to clipboard: {Preview}",
            command.Id, command.ToDisplaySummary());
    }

    // === Terminal Operations ===

    public async Task SendToTerminalAsync(
        CommandBlock command,
        Guid? targetSessionId = null,
        CancellationToken ct = default)
    {
        var sessionId = targetSessionId ?? await EnsureTerminalSessionAsync(
            command.DetectedShellType,
            command.WorkingDirectory,
            ct);

        // Send command text WITHOUT newline - user must press Enter
        await _terminalService.WriteInputAsync(sessionId, command.Command, ct);

        command.MarkSentToTerminal(sessionId);
        UpdateStatus(command.Id, CommandBlockStatus.SentToTerminal);

        _logger.LogDebug("Sent command {Id} to terminal session {Session}",
            command.Id, sessionId);
    }

    public async Task<CommandExecutionResult> ExecuteAsync(
        CommandBlock command,
        Guid? targetSessionId = null,
        bool captureOutput = false,
        CancellationToken ct = default)
    {
        var sessionId = targetSessionId ?? await EnsureTerminalSessionAsync(
            command.DetectedShellType,
            command.WorkingDirectory,
            ct);

        var startTime = DateTime.UtcNow;
        TerminalOutputCapture? capture = null;

        try
        {
            // Update status to Executing
            command.MarkExecuting(sessionId);
            UpdateStatus(command.Id, CommandBlockStatus.Executing);

            // Start output capture if requested
            if (captureOutput)
            {
                _outputCapture.StartCapture(sessionId, command.Command);
            }

            // Send command WITH newline (Enter key)
            var commandWithNewline = command.Command.TrimEnd() + GetNewlineForSession(sessionId);
            await _terminalService.WriteInputAsync(sessionId, commandWithNewline, ct);

            _logger.LogDebug("Executing command {Id} in session {Session}",
                command.Id, sessionId);

            // Wait for command to process
            // Note: A more sophisticated implementation would use OSC 133 shell integration
            // to detect command completion. For now, we use a simple delay.
            if (captureOutput)
            {
                await Task.Delay(500, ct); // Allow command output to accumulate
                capture = await _outputCapture.StopCaptureAsync(sessionId, ct);
                command.OutputCaptureId = capture?.Id;
            }

            // Mark as executed
            command.MarkCompleted(exitCode: 0, capture?.Id);
            UpdateStatus(command.Id, CommandBlockStatus.Executed);

            return new CommandExecutionResult
            {
                CommandId = command.Id,
                Status = CommandBlockStatus.Executed,
                SessionId = sessionId,
                ExecutedAt = startTime,
                OutputCapture = capture,
                Duration = DateTime.UtcNow - startTime
            };
        }
        catch (OperationCanceledException)
        {
            _logger.LogInformation("Command {Id} execution was cancelled", command.Id);

            command.MarkCancelled();
            UpdateStatus(command.Id, CommandBlockStatus.Cancelled);

            // Try to stop capture even on cancellation
            if (captureOutput)
            {
                capture = await _outputCapture.StopCaptureAsync(sessionId, CancellationToken.None);
            }

            return new CommandExecutionResult
            {
                CommandId = command.Id,
                Status = CommandBlockStatus.Cancelled,
                SessionId = sessionId,
                ExecutedAt = startTime,
                OutputCapture = capture,
                Duration = DateTime.UtcNow - startTime
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to execute command {Id}", command.Id);

            command.MarkCompleted(exitCode: -1);
            UpdateStatus(command.Id, CommandBlockStatus.Failed);

            // Try to stop capture even on error
            if (captureOutput)
            {
                capture = await _outputCapture.StopCaptureAsync(sessionId, CancellationToken.None);
            }

            return new CommandExecutionResult
            {
                CommandId = command.Id,
                Status = CommandBlockStatus.Failed,
                SessionId = sessionId,
                ExecutedAt = startTime,
                OutputCapture = capture,
                ErrorMessage = ex.Message,
                Duration = DateTime.UtcNow - startTime
            };
        }
    }

    public async Task<IReadOnlyList<CommandExecutionResult>> ExecuteAllAsync(
        IEnumerable<CommandBlock> commands,
        Guid? targetSessionId = null,
        bool stopOnError = true,
        bool captureOutput = false,
        CancellationToken ct = default)
    {
        var results = new List<CommandExecutionResult>();
        Guid? sessionId = targetSessionId;

        foreach (var command in commands)
        {
            ct.ThrowIfCancellationRequested();

            var result = await ExecuteAsync(command, sessionId, captureOutput, ct);
            results.Add(result);

            // Reuse the same session for subsequent commands
            sessionId = result.SessionId;

            // Stop on error if requested
            if (stopOnError && result.Status == CommandBlockStatus.Failed)
            {
                _logger.LogWarning("Stopping execution due to failed command {Id}", command.Id);
                break;
            }

            // Small delay between commands to allow terminal to stabilize
            await Task.Delay(100, ct);
        }

        _logger.LogDebug("Executed {Executed}/{Total} commands",
            results.Count, results.Count); // Could track skipped count

        return results.AsReadOnly();
    }

    public async Task CancelExecutionAsync(Guid sessionId, CancellationToken ct = default)
    {
        await _terminalService.SendSignalAsync(sessionId, TerminalSignal.Interrupt, ct);
        _logger.LogDebug("Sent interrupt signal (Ctrl+C) to session {Session}", sessionId);
    }

    // === Status Operations ===

    public CommandBlockStatus GetStatus(Guid commandId)
    {
        return _commandStatuses.GetValueOrDefault(commandId, CommandBlockStatus.Pending);
    }

    // === Session Management ===

    public async Task<Guid> EnsureTerminalSessionAsync(
        ShellType? preferredShell = null,
        string? workingDirectory = null,
        CancellationToken ct = default)
    {
        // Try to reuse active session if compatible
        var activeSession = _terminalService.ActiveSession;
        if (activeSession != null)
        {
            // Check if shell type matches (or no preference specified)
            var shellMatches = preferredShell == null ||
                               activeSession.ShellType == preferredShell;

            if (shellMatches)
            {
                _logger.LogDebug("Reusing active session {Session} for shell {Shell}",
                    activeSession.Id, activeSession.ShellType);
                return activeSession.Id;
            }
        }

        // Create new session with appropriate profile
        var profile = preferredShell.HasValue
            ? await FindProfileForShellTypeAsync(preferredShell.Value, ct)
            : await _profileService.GetDefaultProfileAsync(ct);

        var session = await _terminalService.CreateSessionAsync(new TerminalSessionOptions
        {
            ShellPath = profile.ShellPath,
            Arguments = profile.Arguments,
            WorkingDirectory = workingDirectory ?? profile.StartingDirectory,
            Environment = profile.Environment,
            Name = profile.Name
        }, ct);

        _logger.LogInformation("Created new terminal session {Session} with profile {Profile}",
            session.Id, profile.Name);

        return session.Id;
    }

    // === Private Helpers ===

    private async Task<ShellProfile> FindProfileForShellTypeAsync(
        ShellType shellType,
        CancellationToken ct)
    {
        var profiles = await _profileService.GetAllProfilesAsync(ct);
        var matchingProfile = profiles.FirstOrDefault(p => p.ShellType == shellType);

        if (matchingProfile != null)
        {
            return matchingProfile;
        }

        _logger.LogDebug("No profile found for {ShellType}, using default", shellType);
        return await _profileService.GetDefaultProfileAsync(ct);
    }

    private string GetNewlineForSession(Guid sessionId)
    {
        // Most terminals expect carriage return (\r) for Enter key
        // This could be made session/shell-specific if needed
        return "\r";
    }

    private void UpdateStatus(Guid commandId, CommandBlockStatus newStatus)
    {
        var oldStatus = _commandStatuses.GetValueOrDefault(commandId, CommandBlockStatus.Pending);
        _commandStatuses[commandId] = newStatus;

        var eventArgs = new CommandStatusChangedEventArgs
        {
            CommandId = commandId,
            OldStatus = oldStatus,
            NewStatus = newStatus
        };

        StatusChanged?.Invoke(this, eventArgs);

        _logger.LogDebug("Command {Id} status changed: {Old} → {New}",
            commandId, oldStatus, newStatus);
    }
}
```

---

## File Summary

| File | Location | Purpose |
|------|----------|---------|
| `CommandStatusChangedEventArgs.cs` | `src/AIntern.Core/Models/Terminal/` | Status change event args |
| `CommandExecutionResult.cs` | `src/AIntern.Core/Models/Terminal/` | Execution result model |
| `ICommandExecutionService.cs` | `src/AIntern.Core/Interfaces/` | Execution service interface |
| `CommandExecutionService.cs` | `src/AIntern.Services/Terminal/` | Full implementation |

### Files to Modify

| File | Changes |
|------|---------|
| `src/AIntern.Services/DependencyInjection.cs` | Register ICommandExecutionService as singleton |

---

## Unit Test Plan

| Test | Description |
|------|-------------|
| `CopyToClipboard_SetsClipboardText` | Clipboard receives command text |
| `CopyToClipboard_UpdatesStatusToCopied` | Status → Copied |
| `CopyToClipboard_RaisesStatusChangedEvent` | Event fired |
| `SendToTerminal_WritesToSession` | WriteInputAsync called |
| `SendToTerminal_NoNewline` | Command sent without \r |
| `SendToTerminal_UpdatesStatus` | Status → SentToTerminal |
| `SendToTerminal_CreatesSessionIfNeeded` | EnsureTerminalSession called |
| `ExecuteAsync_SendsCommandWithNewline` | Command + \r sent |
| `ExecuteAsync_UpdatesStatusExecuting` | Status → Executing during run |
| `ExecuteAsync_UpdatesStatusExecuted` | Status → Executed on success |
| `ExecuteAsync_UpdatesStatusFailed` | Status → Failed on exception |
| `ExecuteAsync_UpdatesStatusCancelled` | Status → Cancelled on cancel |
| `ExecuteAsync_StartsOutputCapture` | StartCapture called if requested |
| `ExecuteAsync_StopsOutputCapture` | StopCaptureAsync called |
| `ExecuteAsync_AttachesCaptureToResult` | OutputCapture in result |
| `ExecuteAsync_SetsDuration` | Duration populated |
| `ExecuteAllAsync_ExecutesInOrder` | Commands run sequentially |
| `ExecuteAllAsync_ReusesSameSession` | Same sessionId for all |
| `ExecuteAllAsync_StopsOnError` | Stops when stopOnError=true |
| `ExecuteAllAsync_ContinuesOnError` | Continues when stopOnError=false |
| `ExecuteAllAsync_DelaysBetweenCommands` | 100ms pause between |
| `CancelExecution_SendsInterruptSignal` | SIGINT sent to session |
| `GetStatus_ReturnsCurrentStatus` | Tracking works |
| `GetStatus_ReturnsPendingForUnknown` | Default is Pending |
| `EnsureSession_ReusesActiveIfCompatible` | No new session created |
| `EnsureSession_CreatesNewIfShellMismatch` | New session for different shell |
| `EnsureSession_UsesDefaultProfile` | Falls back to default |
| `EnsureSession_FindsProfileForShellType` | Matches shell type to profile |

**Total Tests**: 28

---

## Verification

```bash
# Verify compilation
dotnet build src/AIntern.Services

# Run unit tests
dotnet test --filter "CommandExecution"

# Verify DI registration
dotnet build src/AIntern.Desktop
```

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | Commands can be copied to system clipboard |
| AC-2 | Commands can be sent to terminal without executing |
| AC-3 | Commands can be executed with Enter key |
| AC-4 | Multiple commands execute sequentially in same session |
| AC-5 | Execution can be cancelled with SIGINT |
| AC-6 | Status changes are tracked and events raised |
| AC-7 | Sessions are created on-demand when needed |
| AC-8 | Active session is reused when shell type matches |
| AC-9 | Shell type preferences are respected |
| AC-10 | Output capture integrates with execution |
| AC-11 | Errors are caught and result in Failed status |

---

## Changelog Entry

```markdown
## v0.5.4c - Command Execution Service

### Added
- `CommandStatusChangedEventArgs` for status change notifications:
  - CommandId, OldStatus, NewStatus, SessionId, Timestamp

- `CommandExecutionResult` model with:
  - CommandId, Status, SessionId, ExecutedAt, Duration
  - OutputCapture, ErrorMessage
  - IsSuccess, IsFailed, IsCancelled helpers

- `ICommandExecutionService` interface with:
  - StatusChanged event
  - CopyToClipboardAsync() - Copy to system clipboard
  - SendToTerminalAsync() - Send without executing
  - ExecuteAsync() - Execute with Enter key
  - ExecuteAllAsync() - Sequential multi-command execution
  - CancelExecutionAsync() - Send Ctrl+C interrupt
  - GetStatus() - Query command status
  - EnsureTerminalSessionAsync() - Session management

- `CommandExecutionService` implementation with:
  - ConcurrentDictionary for status tracking
  - Active session reuse logic
  - Shell type profile matching
  - Output capture coordination
  - Proper cancellation handling
  - Error handling with Failed status
```

---

## Timeline Estimate

| Version | Estimated Effort |
|---------|------------------|
| v0.5.4c | 0.75 day |
