# Design Specification: AIntern v0.5.1 "Terminal Foundation"

## Executive Summary

This document provides a comprehensive design specification for v0.5.1, which establishes the core terminal infrastructure for AIntern. This sub-version implements cross-platform pseudo-terminal (PTY) integration using Pty.Net, builds the ANSI/VT100 escape sequence parser, and creates the terminal buffer management system. This foundational layer enables all subsequent terminal features in v0.5.x.

### v0.5.1 Scope (from v0.5.0 Design Document)
- Cross-platform PTY integration using Pty.Net
- Basic terminal rendering with ANSI escape sequence support
- Terminal session lifecycle management
- Terminal buffer with scrollback support

---

## Sub-Part Breakdown

| Part | Name | Focus |
|------|------|-------|
| v0.5.1a | Project Setup & Dependencies | Add Pty.Net package, create terminal-related folders, configure project references |
| v0.5.1b | Terminal Models | Define TerminalSession, TerminalBuffer, TerminalCell, TerminalAttributes, and related types |
| v0.5.1c | ANSI Parser | Implement VT100/ANSI escape sequence parser with SGR, cursor, and screen control support |
| v0.5.1d | Terminal Service | Create ITerminalService interface and Pty.Net-based implementation |
| v0.5.1e | Shell Detection | Cross-platform shell detection and environment configuration |
| v0.5.1f | Integration & Testing | DI registration, unit tests, and integration verification |

---

## v0.5.1a: Project Setup & Dependencies

### Objective
Add the Pty.Net NuGet package for cross-platform PTY support, create the necessary folder structure for terminal-related code, and update project references.

### New NuGet Packages

| Package | Version | Project | Purpose |
|---------|---------|---------|---------|
| Pty.Net | 1.0.0 | Services | Cross-platform pseudo-terminal library |
| System.IO.Pipelines | 8.0.0 | Services | High-performance stream handling |

### Directory.Packages.props Update

Add new packages to central package management:

```xml
<!-- Terminal Support -->
<PackageVersion Include="Pty.Net" Version="1.0.0" />
<PackageVersion Include="System.IO.Pipelines" Version="8.0.0" />
```

### SeniorIntern.Services.csproj Update

```xml
<ItemGroup>
  <!-- Terminal Support -->
  <PackageReference Include="Pty.Net" />
  <PackageReference Include="System.IO.Pipelines" />
</ItemGroup>
```

### New Folder Structure

```
src/SeniorIntern.Core/
├── Models/
│   └── Terminal/
│       ├── TerminalSession.cs
│       ├── TerminalBuffer.cs
│       ├── TerminalCell.cs
│       ├── TerminalAttributes.cs
│       ├── TerminalColor.cs
│       ├── TerminalSize.cs
│       └── TerminalSelection.cs
├── Terminal/
│   ├── AnsiParser.cs
│   └── AnsiParserState.cs
└── Interfaces/
    └── ITerminalService.cs

src/SeniorIntern.Services/
└── Terminal/
    ├── TerminalService.cs
    └── ShellDetectionService.cs
```

### v0.5.1a Files to Create

| File | Purpose |
|------|---------|
| (directories only) | Create folder structure for terminal code |

### v0.5.1a Files to Modify

| File | Changes |
|------|---------|
| `Directory.Packages.props` | Add Pty.Net and System.IO.Pipelines packages |
| `src/SeniorIntern.Services/SeniorIntern.Services.csproj` | Add package references |

### v0.5.1a Verification

```bash
# Verify packages restore
dotnet restore src/SeniorIntern.Services

# Verify solution builds
dotnet build SeniorIntern.sln
```

---

## v0.5.1b: Terminal Models

### Objective
Define all terminal-related model classes including session management, screen buffer, cells, colors, and attributes. These models provide the data structures for the entire terminal subsystem.

### TerminalSize Record

```csharp
namespace SeniorIntern.Core.Models.Terminal;

/// <summary>
/// Represents terminal dimensions in columns and rows
/// </summary>
public readonly record struct TerminalSize(int Columns, int Rows)
{
    /// <summary>
    /// Default terminal size (80x24)
    /// </summary>
    public static TerminalSize Default => new(80, 24);

    /// <summary>
    /// Wide terminal size (120x30)
    /// </summary>
    public static TerminalSize Wide => new(120, 30);

    /// <summary>
    /// Compact terminal size (80x12)
    /// </summary>
    public static TerminalSize Compact => new(80, 12);

    /// <summary>
    /// Validates that dimensions are positive
    /// </summary>
    public bool IsValid => Columns > 0 && Rows > 0;

    /// <summary>
    /// Total number of cells in the terminal
    /// </summary>
    public int TotalCells => Columns * Rows;

    public override string ToString() => $"{Columns}x{Rows}";
}
```

### TerminalColor Struct

```csharp
namespace SeniorIntern.Core.Models.Terminal;

/// <summary>
/// Represents a terminal color with support for default, palette (256), and true color (24-bit)
/// </summary>
public readonly struct TerminalColor : IEquatable<TerminalColor>
{
    /// <summary>
    /// Red component (0-255)
    /// </summary>
    public byte R { get; init; }

    /// <summary>
    /// Green component (0-255)
    /// </summary>
    public byte G { get; init; }

    /// <summary>
    /// Blue component (0-255)
    /// </summary>
    public byte B { get; init; }

    /// <summary>
    /// Whether this represents the terminal's default color
    /// </summary>
    public bool IsDefault { get; init; }

    /// <summary>
    /// Palette index for 256-color mode (0-255, or null for RGB/default)
    /// </summary>
    public byte? PaletteIndex { get; init; }

    /// <summary>
    /// The default terminal foreground/background color
    /// </summary>
    public static TerminalColor Default => new() { IsDefault = true };

    /// <summary>
    /// Create from RGB values
    /// </summary>
    public static TerminalColor FromRgb(byte r, byte g, byte b) =>
        new() { R = r, G = g, B = b };

    /// <summary>
    /// Create from a 256-color palette index
    /// </summary>
    public static TerminalColor FromPalette(byte index) =>
        new() { PaletteIndex = index, R = 0, G = 0, B = 0 };

    /// <summary>
    /// Standard ANSI colors (indices 0-7)
    /// </summary>
    public static TerminalColor Black => FromPalette(0);
    public static TerminalColor Red => FromPalette(1);
    public static TerminalColor Green => FromPalette(2);
    public static TerminalColor Yellow => FromPalette(3);
    public static TerminalColor Blue => FromPalette(4);
    public static TerminalColor Magenta => FromPalette(5);
    public static TerminalColor Cyan => FromPalette(6);
    public static TerminalColor White => FromPalette(7);

    /// <summary>
    /// Bright ANSI colors (indices 8-15)
    /// </summary>
    public static TerminalColor BrightBlack => FromPalette(8);
    public static TerminalColor BrightRed => FromPalette(9);
    public static TerminalColor BrightGreen => FromPalette(10);
    public static TerminalColor BrightYellow => FromPalette(11);
    public static TerminalColor BrightBlue => FromPalette(12);
    public static TerminalColor BrightMagenta => FromPalette(13);
    public static TerminalColor BrightCyan => FromPalette(14);
    public static TerminalColor BrightWhite => FromPalette(15);

    public bool Equals(TerminalColor other) =>
        IsDefault == other.IsDefault &&
        PaletteIndex == other.PaletteIndex &&
        R == other.R && G == other.G && B == other.B;

    public override bool Equals(object? obj) =>
        obj is TerminalColor other && Equals(other);

    public override int GetHashCode() =>
        HashCode.Combine(IsDefault, PaletteIndex, R, G, B);

    public static bool operator ==(TerminalColor left, TerminalColor right) =>
        left.Equals(right);

    public static bool operator !=(TerminalColor left, TerminalColor right) =>
        !left.Equals(right);
}
```

### TerminalAttributes Struct

```csharp
namespace SeniorIntern.Core.Models.Terminal;

/// <summary>
/// Represents text styling attributes for a terminal cell
/// </summary>
public readonly struct TerminalAttributes : IEquatable<TerminalAttributes>
{
    /// <summary>
    /// Foreground (text) color
    /// </summary>
    public TerminalColor Foreground { get; init; }

    /// <summary>
    /// Background color
    /// </summary>
    public TerminalColor Background { get; init; }

    /// <summary>
    /// Bold/bright text
    /// </summary>
    public bool Bold { get; init; }

    /// <summary>
    /// Dim/faint text
    /// </summary>
    public bool Dim { get; init; }

    /// <summary>
    /// Italic text
    /// </summary>
    public bool Italic { get; init; }

    /// <summary>
    /// Underlined text
    /// </summary>
    public bool Underline { get; init; }

    /// <summary>
    /// Blinking text (may be ignored by renderer)
    /// </summary>
    public bool Blink { get; init; }

    /// <summary>
    /// Inverse/reverse video (swap foreground/background)
    /// </summary>
    public bool Inverse { get; init; }

    /// <summary>
    /// Hidden/invisible text
    /// </summary>
    public bool Hidden { get; init; }

    /// <summary>
    /// Strikethrough text
    /// </summary>
    public bool Strikethrough { get; init; }

    /// <summary>
    /// Default terminal attributes
    /// </summary>
    public static TerminalAttributes Default => new()
    {
        Foreground = TerminalColor.Default,
        Background = TerminalColor.Default
    };

    /// <summary>
    /// Create a copy with modifications
    /// </summary>
    public TerminalAttributes With(
        TerminalColor? foreground = null,
        TerminalColor? background = null,
        bool? bold = null,
        bool? dim = null,
        bool? italic = null,
        bool? underline = null,
        bool? blink = null,
        bool? inverse = null,
        bool? hidden = null,
        bool? strikethrough = null)
    {
        return new TerminalAttributes
        {
            Foreground = foreground ?? Foreground,
            Background = background ?? Background,
            Bold = bold ?? Bold,
            Dim = dim ?? Dim,
            Italic = italic ?? Italic,
            Underline = underline ?? Underline,
            Blink = blink ?? Blink,
            Inverse = inverse ?? Inverse,
            Hidden = hidden ?? Hidden,
            Strikethrough = strikethrough ?? Strikethrough
        };
    }

    public bool Equals(TerminalAttributes other) =>
        Foreground == other.Foreground &&
        Background == other.Background &&
        Bold == other.Bold &&
        Dim == other.Dim &&
        Italic == other.Italic &&
        Underline == other.Underline &&
        Blink == other.Blink &&
        Inverse == other.Inverse &&
        Hidden == other.Hidden &&
        Strikethrough == other.Strikethrough;

    public override bool Equals(object? obj) =>
        obj is TerminalAttributes other && Equals(other);

    public override int GetHashCode()
    {
        var hash = new HashCode();
        hash.Add(Foreground);
        hash.Add(Background);
        hash.Add(Bold);
        hash.Add(Dim);
        hash.Add(Italic);
        hash.Add(Underline);
        hash.Add(Blink);
        hash.Add(Inverse);
        hash.Add(Hidden);
        hash.Add(Strikethrough);
        return hash.ToHashCode();
    }

    public static bool operator ==(TerminalAttributes left, TerminalAttributes right) =>
        left.Equals(right);

    public static bool operator !=(TerminalAttributes left, TerminalAttributes right) =>
        !left.Equals(right);
}
```

### TerminalCell Struct

```csharp
namespace SeniorIntern.Core.Models.Terminal;

/// <summary>
/// Represents a single cell in the terminal buffer
/// </summary>
public struct TerminalCell : IEquatable<TerminalCell>
{
    /// <summary>
    /// The character displayed in this cell (uses Rune for Unicode support)
    /// </summary>
    public Rune Character { get; set; }

    /// <summary>
    /// The display attributes for this cell
    /// </summary>
    public TerminalAttributes Attributes { get; set; }

    /// <summary>
    /// Width of this character in cells (1 for most, 2 for wide/CJK characters)
    /// </summary>
    public int Width { get; set; }

    /// <summary>
    /// Whether this cell is the continuation of a wide character
    /// </summary>
    public bool IsContinuation { get; set; }

    /// <summary>
    /// An empty cell with default attributes
    /// </summary>
    public static TerminalCell Empty => new()
    {
        Character = new Rune(' '),
        Attributes = TerminalAttributes.Default,
        Width = 1,
        IsContinuation = false
    };

    /// <summary>
    /// Create a cell with a character and default attributes
    /// </summary>
    public static TerminalCell FromChar(char c) => new()
    {
        Character = new Rune(c),
        Attributes = TerminalAttributes.Default,
        Width = 1,
        IsContinuation = false
    };

    /// <summary>
    /// Create a cell with a character and specific attributes
    /// </summary>
    public static TerminalCell FromChar(char c, TerminalAttributes attributes) => new()
    {
        Character = new Rune(c),
        Attributes = attributes,
        Width = 1,
        IsContinuation = false
    };

    /// <summary>
    /// Check if this cell displays as blank
    /// </summary>
    public readonly bool IsBlank =>
        Character.Value == ' ' || Character.Value == 0 || IsContinuation;

    public readonly bool Equals(TerminalCell other) =>
        Character == other.Character &&
        Attributes == other.Attributes &&
        Width == other.Width &&
        IsContinuation == other.IsContinuation;

    public override readonly bool Equals(object? obj) =>
        obj is TerminalCell other && Equals(other);

    public override readonly int GetHashCode() =>
        HashCode.Combine(Character, Attributes, Width, IsContinuation);

    public static bool operator ==(TerminalCell left, TerminalCell right) =>
        left.Equals(right);

    public static bool operator !=(TerminalCell left, TerminalCell right) =>
        !left.Equals(right);
}
```

### TerminalLine Class

```csharp
namespace SeniorIntern.Core.Models.Terminal;

/// <summary>
/// Represents a single line in the terminal buffer
/// </summary>
public sealed class TerminalLine
{
    private readonly TerminalCell[] _cells;

    /// <summary>
    /// Number of columns in this line
    /// </summary>
    public int Length => _cells.Length;

    /// <summary>
    /// Whether this line is wrapped from the previous line
    /// </summary>
    public bool IsWrapped { get; set; }

    /// <summary>
    /// Whether this line has been modified since last render
    /// </summary>
    public bool IsDirty { get; set; } = true;

    /// <summary>
    /// Timestamp when this line was last modified
    /// </summary>
    public DateTime LastModified { get; private set; } = DateTime.UtcNow;

    public TerminalLine(int columns)
    {
        _cells = new TerminalCell[columns];
        Clear();
    }

    /// <summary>
    /// Get the cell at the specified column
    /// </summary>
    public ref TerminalCell this[int column]
    {
        get
        {
            if (column < 0 || column >= _cells.Length)
                throw new ArgumentOutOfRangeException(nameof(column));
            return ref _cells[column];
        }
    }

    /// <summary>
    /// Get all cells as a span
    /// </summary>
    public Span<TerminalCell> Cells => _cells.AsSpan();

    /// <summary>
    /// Get all cells as a read-only span
    /// </summary>
    public ReadOnlySpan<TerminalCell> ReadOnlyCells => _cells.AsSpan();

    /// <summary>
    /// Clear all cells to empty
    /// </summary>
    public void Clear()
    {
        Array.Fill(_cells, TerminalCell.Empty);
        MarkDirty();
    }

    /// <summary>
    /// Clear cells from start to end (inclusive)
    /// </summary>
    public void Clear(int start, int end)
    {
        start = Math.Max(0, start);
        end = Math.Min(_cells.Length - 1, end);

        for (int i = start; i <= end; i++)
            _cells[i] = TerminalCell.Empty;

        MarkDirty();
    }

    /// <summary>
    /// Set a cell at the specified column
    /// </summary>
    public void SetCell(int column, TerminalCell cell)
    {
        if (column >= 0 && column < _cells.Length)
        {
            _cells[column] = cell;
            MarkDirty();
        }
    }

    /// <summary>
    /// Copy cells from another line
    /// </summary>
    public void CopyFrom(TerminalLine source)
    {
        var copyLength = Math.Min(_cells.Length, source._cells.Length);
        Array.Copy(source._cells, _cells, copyLength);
        IsWrapped = source.IsWrapped;
        MarkDirty();
    }

    /// <summary>
    /// Resize the line to new column count
    /// </summary>
    public void Resize(int newColumns)
    {
        if (newColumns == _cells.Length)
            return;

        var newCells = new TerminalCell[newColumns];
        var copyLength = Math.Min(_cells.Length, newColumns);
        Array.Copy(_cells, newCells, copyLength);

        // Fill new cells with empty
        for (int i = copyLength; i < newColumns; i++)
            newCells[i] = TerminalCell.Empty;

        // Note: We can't resize _cells directly since it's readonly
        // This method should create a new TerminalLine instead
        // Keeping for API compatibility - caller should handle resize
        MarkDirty();
    }

    /// <summary>
    /// Get the text content of this line
    /// </summary>
    public string GetText()
    {
        var sb = new StringBuilder(_cells.Length);
        foreach (var cell in _cells)
        {
            if (!cell.IsContinuation)
                sb.Append(cell.Character.ToString());
        }
        return sb.ToString().TrimEnd();
    }

    /// <summary>
    /// Mark this line as modified
    /// </summary>
    public void MarkDirty()
    {
        IsDirty = true;
        LastModified = DateTime.UtcNow;
    }

    /// <summary>
    /// Mark this line as rendered (clean)
    /// </summary>
    public void MarkClean()
    {
        IsDirty = false;
    }
}
```

### TerminalSelection Record

```csharp
namespace SeniorIntern.Core.Models.Terminal;

/// <summary>
/// Represents a text selection in the terminal
/// </summary>
public sealed record TerminalSelection
{
    /// <summary>
    /// Starting line (0-indexed from top of scrollback)
    /// </summary>
    public int StartLine { get; init; }

    /// <summary>
    /// Starting column within the line
    /// </summary>
    public int StartColumn { get; init; }

    /// <summary>
    /// Ending line (0-indexed from top of scrollback)
    /// </summary>
    public int EndLine { get; init; }

    /// <summary>
    /// Ending column within the line
    /// </summary>
    public int EndColumn { get; init; }

    /// <summary>
    /// Whether this is a block/rectangle selection (vs line selection)
    /// </summary>
    public bool IsBlock { get; init; }

    /// <summary>
    /// Get the normalized selection (start always before end)
    /// </summary>
    public TerminalSelection Normalized
    {
        get
        {
            var startBefore = StartLine < EndLine ||
                (StartLine == EndLine && StartColumn <= EndColumn);

            return startBefore ? this : new TerminalSelection
            {
                StartLine = EndLine,
                StartColumn = EndColumn,
                EndLine = StartLine,
                EndColumn = StartColumn,
                IsBlock = IsBlock
            };
        }
    }

    /// <summary>
    /// Check if a cell is within this selection
    /// </summary>
    public bool Contains(int line, int column)
    {
        var norm = Normalized;

        if (IsBlock)
        {
            return line >= norm.StartLine && line <= norm.EndLine &&
                   column >= Math.Min(norm.StartColumn, norm.EndColumn) &&
                   column <= Math.Max(norm.StartColumn, norm.EndColumn);
        }

        if (line < norm.StartLine || line > norm.EndLine)
            return false;

        if (line == norm.StartLine && line == norm.EndLine)
            return column >= norm.StartColumn && column <= norm.EndColumn;

        if (line == norm.StartLine)
            return column >= norm.StartColumn;

        if (line == norm.EndLine)
            return column <= norm.EndColumn;

        return true;
    }

    /// <summary>
    /// Check if the selection is empty
    /// </summary>
    public bool IsEmpty =>
        StartLine == EndLine && StartColumn == EndColumn;
}
```

### TerminalSessionState Enum

```csharp
namespace SeniorIntern.Core.Models.Terminal;

/// <summary>
/// Represents the lifecycle state of a terminal session
/// </summary>
public enum TerminalSessionState
{
    /// <summary>
    /// Session is being created/initialized
    /// </summary>
    Starting,

    /// <summary>
    /// Session is running and accepting input
    /// </summary>
    Running,

    /// <summary>
    /// Session process has exited normally or abnormally
    /// </summary>
    Exited,

    /// <summary>
    /// Session encountered an error
    /// </summary>
    Error,

    /// <summary>
    /// Session is being closed/disposed
    /// </summary>
    Closing
}
```

### TerminalSession Class

```csharp
namespace SeniorIntern.Core.Models.Terminal;

/// <summary>
/// Represents an active terminal session with a PTY process
/// </summary>
public sealed class TerminalSession : IAsyncDisposable
{
    /// <summary>
    /// Unique identifier for this session
    /// </summary>
    public Guid Id { get; init; } = Guid.NewGuid();

    /// <summary>
    /// Display name for the session (shown in tab)
    /// </summary>
    public string Name { get; set; } = "Terminal";

    /// <summary>
    /// Path to the shell executable
    /// </summary>
    public string ShellPath { get; init; } = string.Empty;

    /// <summary>
    /// Current working directory
    /// </summary>
    public string WorkingDirectory { get; set; } = string.Empty;

    /// <summary>
    /// Current session state
    /// </summary>
    public TerminalSessionState State { get; set; } = TerminalSessionState.Starting;

    /// <summary>
    /// When the session was created
    /// </summary>
    public DateTime CreatedAt { get; init; } = DateTime.UtcNow;

    /// <summary>
    /// When the session was closed (null if still running)
    /// </summary>
    public DateTime? ClosedAt { get; set; }

    /// <summary>
    /// Environment variables for this session
    /// </summary>
    public Dictionary<string, string> Environment { get; init; } = new();

    /// <summary>
    /// Current terminal dimensions
    /// </summary>
    public TerminalSize Size { get; set; } = TerminalSize.Default;

    /// <summary>
    /// Process exit code (null if still running or not applicable)
    /// </summary>
    public int? ExitCode { get; set; }

    /// <summary>
    /// Associated workspace ID for directory synchronization
    /// </summary>
    public Guid? WorkspaceId { get; set; }

    /// <summary>
    /// Optional title set by the shell (via escape sequence)
    /// </summary>
    public string? Title { get; set; }

    /// <summary>
    /// Whether the session is interactive (has PTY) vs non-interactive
    /// </summary>
    public bool IsInteractive { get; init; } = true;

    /// <summary>
    /// Disposal callback (set by TerminalService)
    /// </summary>
    internal Func<ValueTask>? OnDisposeAsync { get; set; }

    public async ValueTask DisposeAsync()
    {
        if (OnDisposeAsync != null)
            await OnDisposeAsync();
    }

    public override string ToString() =>
        $"TerminalSession({Id:N8}, {Name}, {State})";
}
```

### TerminalBuffer Class

```csharp
namespace SeniorIntern.Core.Models.Terminal;

/// <summary>
/// Manages the terminal screen buffer with scrollback support
/// </summary>
public sealed class TerminalBuffer
{
    private readonly List<TerminalLine> _lines = new();
    private readonly int _maxScrollback;
    private readonly object _lock = new();

    /// <summary>
    /// Number of columns in the terminal
    /// </summary>
    public int Columns { get; private set; }

    /// <summary>
    /// Number of rows in the visible terminal area
    /// </summary>
    public int Rows { get; private set; }

    /// <summary>
    /// Current cursor X position (0-indexed column)
    /// </summary>
    public int CursorX { get; set; }

    /// <summary>
    /// Current cursor Y position (0-indexed row, relative to screen top)
    /// </summary>
    public int CursorY { get; set; }

    /// <summary>
    /// Whether the cursor should be visible
    /// </summary>
    public bool CursorVisible { get; set; } = true;

    /// <summary>
    /// Current scroll offset (0 = at bottom/live, positive = scrolled up)
    /// </summary>
    public int ScrollOffset { get; set; }

    /// <summary>
    /// Total number of lines (screen + scrollback)
    /// </summary>
    public int TotalLines
    {
        get { lock (_lock) { return _lines.Count; } }
    }

    /// <summary>
    /// Number of scrollback lines (above visible area)
    /// </summary>
    public int ScrollbackLines => Math.Max(0, TotalLines - Rows);

    /// <summary>
    /// Current text attributes for new characters
    /// </summary>
    public TerminalAttributes CurrentAttributes { get; set; } = TerminalAttributes.Default;

    /// <summary>
    /// Saved cursor position (for DECSC/DECRC)
    /// </summary>
    public (int X, int Y) SavedCursor { get; set; }

    /// <summary>
    /// Saved attributes (for DECSC/DECRC)
    /// </summary>
    public TerminalAttributes SavedAttributes { get; set; } = TerminalAttributes.Default;

    /// <summary>
    /// Top margin for scrolling region (0-indexed)
    /// </summary>
    public int ScrollRegionTop { get; set; }

    /// <summary>
    /// Bottom margin for scrolling region (0-indexed, exclusive)
    /// </summary>
    public int ScrollRegionBottom { get; set; }

    /// <summary>
    /// Whether origin mode is enabled (cursor relative to scroll region)
    /// </summary>
    public bool OriginMode { get; set; }

    /// <summary>
    /// Whether auto-wrap mode is enabled
    /// </summary>
    public bool AutoWrapMode { get; set; } = true;

    /// <summary>
    /// Event raised when buffer content changes
    /// </summary>
    public event EventHandler? ContentChanged;

    public TerminalBuffer(int columns, int rows, int maxScrollback = 10000)
    {
        if (columns <= 0) throw new ArgumentOutOfRangeException(nameof(columns));
        if (rows <= 0) throw new ArgumentOutOfRangeException(nameof(rows));
        if (maxScrollback < 0) throw new ArgumentOutOfRangeException(nameof(maxScrollback));

        Columns = columns;
        Rows = rows;
        _maxScrollback = maxScrollback;
        ScrollRegionBottom = rows;

        InitializeLines();
    }

    private void InitializeLines()
    {
        lock (_lock)
        {
            _lines.Clear();
            for (int i = 0; i < Rows; i++)
                _lines.Add(new TerminalLine(Columns));
        }
    }

    /// <summary>
    /// Resize the terminal buffer
    /// </summary>
    public void Resize(int columns, int rows)
    {
        if (columns <= 0 || rows <= 0)
            return;

        lock (_lock)
        {
            var oldColumns = Columns;
            var oldRows = Rows;

            Columns = columns;
            Rows = rows;
            ScrollRegionBottom = rows;

            // Resize existing lines
            foreach (var line in _lines)
            {
                // Lines need to be recreated with new size
                // This is handled by creating new lines if needed
            }

            // Add or remove lines to match new row count
            while (_lines.Count < rows)
                _lines.Add(new TerminalLine(columns));

            // Trim scrollback if needed
            TrimScrollback();

            // Adjust cursor position
            CursorX = Math.Min(CursorX, columns - 1);
            CursorY = Math.Min(CursorY, rows - 1);

            OnContentChanged();
        }
    }

    /// <summary>
    /// Write a character at the current cursor position
    /// </summary>
    public void WriteChar(char c)
    {
        WriteChar(new Rune(c));
    }

    /// <summary>
    /// Write a Unicode rune at the current cursor position
    /// </summary>
    public void WriteChar(Rune rune)
    {
        lock (_lock)
        {
            // Handle auto-wrap
            if (CursorX >= Columns)
            {
                if (AutoWrapMode)
                {
                    CursorX = 0;
                    LineFeed();
                }
                else
                {
                    CursorX = Columns - 1;
                }
            }

            var lineIndex = GetAbsoluteLineIndex(CursorY);
            if (lineIndex >= 0 && lineIndex < _lines.Count)
            {
                var line = _lines[lineIndex];
                if (CursorX < Columns)
                {
                    line.SetCell(CursorX, new TerminalCell
                    {
                        Character = rune,
                        Attributes = CurrentAttributes,
                        Width = 1,
                        IsContinuation = false
                    });
                    CursorX++;
                }
            }

            OnContentChanged();
        }
    }

    /// <summary>
    /// Write a string at the current cursor position
    /// </summary>
    public void WriteString(string text)
    {
        foreach (var rune in text.EnumerateRunes())
            WriteChar(rune);
    }

    /// <summary>
    /// Perform a line feed (move cursor down, scroll if needed)
    /// </summary>
    public void LineFeed()
    {
        lock (_lock)
        {
            if (CursorY >= ScrollRegionBottom - 1)
            {
                // At bottom of scroll region, scroll up
                ScrollUp(1);
            }
            else if (CursorY < Rows - 1)
            {
                CursorY++;
            }
            OnContentChanged();
        }
    }

    /// <summary>
    /// Perform a carriage return (move cursor to column 0)
    /// </summary>
    public void CarriageReturn()
    {
        CursorX = 0;
    }

    /// <summary>
    /// Move cursor to next tab stop
    /// </summary>
    public void Tab()
    {
        CursorX = ((CursorX / 8) + 1) * 8;
        if (CursorX >= Columns)
            CursorX = Columns - 1;
    }

    /// <summary>
    /// Backspace (move cursor left one position)
    /// </summary>
    public void Backspace()
    {
        if (CursorX > 0)
            CursorX--;
    }

    /// <summary>
    /// Scroll the buffer up by n lines
    /// </summary>
    public void ScrollUp(int lines = 1)
    {
        lock (_lock)
        {
            for (int i = 0; i < lines; i++)
            {
                // Move top line of scroll region to scrollback
                if (ScrollRegionTop == 0)
                {
                    // Normal scroll - line goes to scrollback
                    _lines.Insert(GetAbsoluteLineIndex(ScrollRegionBottom), new TerminalLine(Columns));
                }
                else
                {
                    // Scroll region - remove top, add at bottom
                    var topIndex = GetAbsoluteLineIndex(ScrollRegionTop);
                    _lines.RemoveAt(topIndex);
                    _lines.Insert(GetAbsoluteLineIndex(ScrollRegionBottom - 1), new TerminalLine(Columns));
                }
            }

            TrimScrollback();
            OnContentChanged();
        }
    }

    /// <summary>
    /// Scroll the buffer down by n lines
    /// </summary>
    public void ScrollDown(int lines = 1)
    {
        lock (_lock)
        {
            for (int i = 0; i < lines; i++)
            {
                var bottomIndex = GetAbsoluteLineIndex(ScrollRegionBottom - 1);
                _lines.RemoveAt(bottomIndex);
                _lines.Insert(GetAbsoluteLineIndex(ScrollRegionTop), new TerminalLine(Columns));
            }
            OnContentChanged();
        }
    }

    /// <summary>
    /// Clear the entire screen
    /// </summary>
    public void Clear()
    {
        lock (_lock)
        {
            for (int i = 0; i < Rows; i++)
            {
                var lineIndex = GetAbsoluteLineIndex(i);
                if (lineIndex >= 0 && lineIndex < _lines.Count)
                    _lines[lineIndex].Clear();
            }
            OnContentChanged();
        }
    }

    /// <summary>
    /// Clear from cursor to end of screen
    /// </summary>
    public void ClearToEnd()
    {
        lock (_lock)
        {
            // Clear rest of current line
            ClearLineToEnd();

            // Clear all lines below
            for (int i = CursorY + 1; i < Rows; i++)
            {
                var lineIndex = GetAbsoluteLineIndex(i);
                if (lineIndex >= 0 && lineIndex < _lines.Count)
                    _lines[lineIndex].Clear();
            }
            OnContentChanged();
        }
    }

    /// <summary>
    /// Clear from start of screen to cursor
    /// </summary>
    public void ClearToBeginning()
    {
        lock (_lock)
        {
            // Clear all lines above
            for (int i = 0; i < CursorY; i++)
            {
                var lineIndex = GetAbsoluteLineIndex(i);
                if (lineIndex >= 0 && lineIndex < _lines.Count)
                    _lines[lineIndex].Clear();
            }

            // Clear start of current line
            ClearLineToBeginning();
            OnContentChanged();
        }
    }

    /// <summary>
    /// Clear the current line
    /// </summary>
    public void ClearLine()
    {
        lock (_lock)
        {
            var lineIndex = GetAbsoluteLineIndex(CursorY);
            if (lineIndex >= 0 && lineIndex < _lines.Count)
                _lines[lineIndex].Clear();
            OnContentChanged();
        }
    }

    /// <summary>
    /// Clear from cursor to end of line
    /// </summary>
    public void ClearLineToEnd()
    {
        lock (_lock)
        {
            var lineIndex = GetAbsoluteLineIndex(CursorY);
            if (lineIndex >= 0 && lineIndex < _lines.Count)
                _lines[lineIndex].Clear(CursorX, Columns - 1);
            OnContentChanged();
        }
    }

    /// <summary>
    /// Clear from start of line to cursor
    /// </summary>
    public void ClearLineToBeginning()
    {
        lock (_lock)
        {
            var lineIndex = GetAbsoluteLineIndex(CursorY);
            if (lineIndex >= 0 && lineIndex < _lines.Count)
                _lines[lineIndex].Clear(0, CursorX);
            OnContentChanged();
        }
    }

    /// <summary>
    /// Set cursor position (1-indexed, as per VT100)
    /// </summary>
    public void SetCursorPosition(int row, int column)
    {
        // Convert from 1-indexed to 0-indexed
        CursorY = Math.Clamp(row - 1, 0, Rows - 1);
        CursorX = Math.Clamp(column - 1, 0, Columns - 1);

        if (OriginMode)
        {
            CursorY = Math.Clamp(CursorY + ScrollRegionTop, ScrollRegionTop, ScrollRegionBottom - 1);
        }
    }

    /// <summary>
    /// Move cursor up by n rows
    /// </summary>
    public void CursorUp(int n = 1)
    {
        CursorY = Math.Max(ScrollRegionTop, CursorY - n);
    }

    /// <summary>
    /// Move cursor down by n rows
    /// </summary>
    public void CursorDown(int n = 1)
    {
        CursorY = Math.Min(ScrollRegionBottom - 1, CursorY + n);
    }

    /// <summary>
    /// Move cursor right by n columns
    /// </summary>
    public void CursorForward(int n = 1)
    {
        CursorX = Math.Min(Columns - 1, CursorX + n);
    }

    /// <summary>
    /// Move cursor left by n columns
    /// </summary>
    public void CursorBack(int n = 1)
    {
        CursorX = Math.Max(0, CursorX - n);
    }

    /// <summary>
    /// Save cursor position and attributes
    /// </summary>
    public void SaveCursor()
    {
        SavedCursor = (CursorX, CursorY);
        SavedAttributes = CurrentAttributes;
    }

    /// <summary>
    /// Restore cursor position and attributes
    /// </summary>
    public void RestoreCursor()
    {
        (CursorX, CursorY) = SavedCursor;
        CurrentAttributes = SavedAttributes;
    }

    /// <summary>
    /// Set the scrolling region
    /// </summary>
    public void SetScrollRegion(int top, int bottom)
    {
        ScrollRegionTop = Math.Clamp(top - 1, 0, Rows - 1);
        ScrollRegionBottom = Math.Clamp(bottom, 1, Rows);

        if (ScrollRegionTop >= ScrollRegionBottom)
        {
            ScrollRegionTop = 0;
            ScrollRegionBottom = Rows;
        }

        // Move cursor to home position
        CursorX = 0;
        CursorY = OriginMode ? ScrollRegionTop : 0;
    }

    /// <summary>
    /// Insert n blank lines at cursor position
    /// </summary>
    public void InsertLines(int n = 1)
    {
        lock (_lock)
        {
            if (CursorY < ScrollRegionTop || CursorY >= ScrollRegionBottom)
                return;

            for (int i = 0; i < n; i++)
            {
                var bottomIndex = GetAbsoluteLineIndex(ScrollRegionBottom - 1);
                if (bottomIndex < _lines.Count)
                    _lines.RemoveAt(bottomIndex);

                _lines.Insert(GetAbsoluteLineIndex(CursorY), new TerminalLine(Columns));
            }
            OnContentChanged();
        }
    }

    /// <summary>
    /// Delete n lines at cursor position
    /// </summary>
    public void DeleteLines(int n = 1)
    {
        lock (_lock)
        {
            if (CursorY < ScrollRegionTop || CursorY >= ScrollRegionBottom)
                return;

            for (int i = 0; i < n; i++)
            {
                var cursorIndex = GetAbsoluteLineIndex(CursorY);
                if (cursorIndex < _lines.Count)
                    _lines.RemoveAt(cursorIndex);

                _lines.Insert(GetAbsoluteLineIndex(ScrollRegionBottom - 1), new TerminalLine(Columns));
            }
            OnContentChanged();
        }
    }

    /// <summary>
    /// Insert n blank characters at cursor position
    /// </summary>
    public void InsertChars(int n = 1)
    {
        lock (_lock)
        {
            var lineIndex = GetAbsoluteLineIndex(CursorY);
            if (lineIndex < 0 || lineIndex >= _lines.Count)
                return;

            var line = _lines[lineIndex];
            // Shift characters right
            for (int i = Columns - 1; i >= CursorX + n; i--)
            {
                if (i - n >= 0)
                    line[i] = line[i - n];
            }

            // Clear inserted positions
            for (int i = CursorX; i < CursorX + n && i < Columns; i++)
                line[i] = TerminalCell.Empty;

            OnContentChanged();
        }
    }

    /// <summary>
    /// Delete n characters at cursor position
    /// </summary>
    public void DeleteChars(int n = 1)
    {
        lock (_lock)
        {
            var lineIndex = GetAbsoluteLineIndex(CursorY);
            if (lineIndex < 0 || lineIndex >= _lines.Count)
                return;

            var line = _lines[lineIndex];
            // Shift characters left
            for (int i = CursorX; i < Columns - n; i++)
            {
                if (i + n < Columns)
                    line[i] = line[i + n];
            }

            // Clear end
            for (int i = Columns - n; i < Columns; i++)
                line[i] = TerminalCell.Empty;

            OnContentChanged();
        }
    }

    /// <summary>
    /// Get a line by screen row (0-indexed)
    /// </summary>
    public TerminalLine? GetLine(int screenRow)
    {
        lock (_lock)
        {
            var index = GetAbsoluteLineIndex(screenRow);
            return index >= 0 && index < _lines.Count ? _lines[index] : null;
        }
    }

    /// <summary>
    /// Get visible lines for rendering
    /// </summary>
    public IReadOnlyList<TerminalLine> GetVisibleLines()
    {
        lock (_lock)
        {
            var result = new List<TerminalLine>(Rows);
            var startIndex = _lines.Count - Rows - ScrollOffset;

            for (int i = 0; i < Rows; i++)
            {
                var index = startIndex + i;
                if (index >= 0 && index < _lines.Count)
                    result.Add(_lines[index]);
                else
                    result.Add(new TerminalLine(Columns));
            }

            return result;
        }
    }

    /// <summary>
    /// Get selected text
    /// </summary>
    public string GetSelectedText(TerminalSelection selection)
    {
        lock (_lock)
        {
            var norm = selection.Normalized;
            var sb = new StringBuilder();

            for (int lineNum = norm.StartLine; lineNum <= norm.EndLine && lineNum < _lines.Count; lineNum++)
            {
                if (lineNum < 0)
                    continue;

                var line = _lines[lineNum];
                var startCol = lineNum == norm.StartLine ? norm.StartColumn : 0;
                var endCol = lineNum == norm.EndLine ? norm.EndColumn : Columns - 1;

                if (selection.IsBlock)
                {
                    startCol = Math.Min(norm.StartColumn, norm.EndColumn);
                    endCol = Math.Max(norm.StartColumn, norm.EndColumn);
                }

                for (int col = startCol; col <= endCol && col < Columns; col++)
                {
                    if (!line[col].IsContinuation)
                        sb.Append(line[col].Character.ToString());
                }

                if (!selection.IsBlock && lineNum < norm.EndLine && !line.IsWrapped)
                    sb.AppendLine();
            }

            return sb.ToString();
        }
    }

    /// <summary>
    /// Get all text content
    /// </summary>
    public string GetAllText()
    {
        lock (_lock)
        {
            var sb = new StringBuilder();
            foreach (var line in _lines)
            {
                sb.AppendLine(line.GetText());
            }
            return sb.ToString();
        }
    }

    /// <summary>
    /// Reset buffer to initial state
    /// </summary>
    public void Reset()
    {
        lock (_lock)
        {
            CursorX = 0;
            CursorY = 0;
            CursorVisible = true;
            ScrollOffset = 0;
            CurrentAttributes = TerminalAttributes.Default;
            SavedCursor = (0, 0);
            SavedAttributes = TerminalAttributes.Default;
            ScrollRegionTop = 0;
            ScrollRegionBottom = Rows;
            OriginMode = false;
            AutoWrapMode = true;
            InitializeLines();
            OnContentChanged();
        }
    }

    private int GetAbsoluteLineIndex(int screenRow)
    {
        // Convert screen row to absolute index in _lines
        return _lines.Count - Rows + screenRow - ScrollOffset;
    }

    private void TrimScrollback()
    {
        while (_lines.Count > Rows + _maxScrollback)
            _lines.RemoveAt(0);
    }

    private void OnContentChanged()
    {
        ContentChanged?.Invoke(this, EventArgs.Empty);
    }
}
```

### v0.5.1b Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Models/Terminal/TerminalSize.cs` | Terminal dimensions record |
| `src/SeniorIntern.Core/Models/Terminal/TerminalColor.cs` | Color representation |
| `src/SeniorIntern.Core/Models/Terminal/TerminalAttributes.cs` | Text styling attributes |
| `src/SeniorIntern.Core/Models/Terminal/TerminalCell.cs` | Single cell in buffer |
| `src/SeniorIntern.Core/Models/Terminal/TerminalLine.cs` | Line of cells |
| `src/SeniorIntern.Core/Models/Terminal/TerminalSelection.cs` | Text selection |
| `src/SeniorIntern.Core/Models/Terminal/TerminalSessionState.cs` | Session state enum |
| `src/SeniorIntern.Core/Models/Terminal/TerminalSession.cs` | Session model |
| `src/SeniorIntern.Core/Models/Terminal/TerminalBuffer.cs` | Screen buffer management |

### v0.5.1b Verification

```bash
# Verify Core project builds with new models
dotnet build src/SeniorIntern.Core
```

---

## v0.5.1c: ANSI Parser

### Objective
Implement a robust VT100/ANSI escape sequence parser that processes terminal output and updates the buffer accordingly. The parser handles CSI sequences, SGR (color/style), cursor control, and screen manipulation.

### AnsiParserState Enum

```csharp
namespace SeniorIntern.Core.Terminal;

/// <summary>
/// State machine states for ANSI escape sequence parsing
/// </summary>
public enum AnsiParserState
{
    /// <summary>
    /// Normal character processing
    /// </summary>
    Ground,

    /// <summary>
    /// Received ESC (0x1B), waiting for next byte
    /// </summary>
    Escape,

    /// <summary>
    /// Received ESC followed by intermediate byte
    /// </summary>
    EscapeIntermediate,

    /// <summary>
    /// Control Sequence Introducer (ESC [)
    /// </summary>
    CsiEntry,

    /// <summary>
    /// Collecting CSI parameters
    /// </summary>
    CsiParam,

    /// <summary>
    /// CSI intermediate bytes
    /// </summary>
    CsiIntermediate,

    /// <summary>
    /// Operating System Command (ESC ])
    /// </summary>
    OscString,

    /// <summary>
    /// Device Control String (ESC P)
    /// </summary>
    DcsEntry,

    /// <summary>
    /// DCS collecting parameters
    /// </summary>
    DcsParam,

    /// <summary>
    /// DCS intermediate bytes
    /// </summary>
    DcsIntermediate,

    /// <summary>
    /// DCS passthrough
    /// </summary>
    DcsPassthrough,

    /// <summary>
    /// SOS/PM/APC string
    /// </summary>
    SosPmApcString
}
```

### AnsiParser Class

```csharp
namespace SeniorIntern.Core.Terminal;

using SeniorIntern.Core.Models.Terminal;

/// <summary>
/// Parses VT100/ANSI escape sequences and updates a terminal buffer
/// </summary>
public sealed class AnsiParser
{
    private readonly TerminalBuffer _buffer;
    private AnsiParserState _state = AnsiParserState.Ground;
    private readonly List<int> _params = new();
    private readonly StringBuilder _intermediates = new();
    private readonly StringBuilder _oscString = new();
    private int _currentParam;
    private bool _paramStarted;

    /// <summary>
    /// Event raised when a bell character is received
    /// </summary>
    public event Action? Bell;

    /// <summary>
    /// Event raised when the terminal title changes (via OSC)
    /// </summary>
    public event Action<string>? TitleChanged;

    /// <summary>
    /// Event raised when the working directory changes (via OSC 7)
    /// </summary>
    public event Action<string>? WorkingDirectoryChanged;

    /// <summary>
    /// Event raised when a hyperlink is detected (via OSC 8)
    /// </summary>
    public event Action<string?, string>? HyperlinkDetected;

    public AnsiParser(TerminalBuffer buffer)
    {
        _buffer = buffer ?? throw new ArgumentNullException(nameof(buffer));
    }

    /// <summary>
    /// Parse a sequence of bytes
    /// </summary>
    public void Parse(ReadOnlySpan<byte> data)
    {
        foreach (var b in data)
        {
            ProcessByte(b);
        }
    }

    /// <summary>
    /// Parse a string (converted to UTF-8 bytes)
    /// </summary>
    public void Parse(string text)
    {
        Parse(Encoding.UTF8.GetBytes(text));
    }

    private void ProcessByte(byte b)
    {
        // Handle C0 control characters in any state
        if (b < 0x20)
        {
            if (ProcessC0Control(b))
                return;
        }

        switch (_state)
        {
            case AnsiParserState.Ground:
                ProcessGround(b);
                break;

            case AnsiParserState.Escape:
                ProcessEscape(b);
                break;

            case AnsiParserState.EscapeIntermediate:
                ProcessEscapeIntermediate(b);
                break;

            case AnsiParserState.CsiEntry:
            case AnsiParserState.CsiParam:
                ProcessCsi(b);
                break;

            case AnsiParserState.CsiIntermediate:
                ProcessCsiIntermediate(b);
                break;

            case AnsiParserState.OscString:
                ProcessOsc(b);
                break;

            case AnsiParserState.DcsEntry:
            case AnsiParserState.DcsParam:
            case AnsiParserState.DcsIntermediate:
            case AnsiParserState.DcsPassthrough:
                ProcessDcs(b);
                break;

            case AnsiParserState.SosPmApcString:
                ProcessSosPmApc(b);
                break;
        }
    }

    private bool ProcessC0Control(byte b)
    {
        switch (b)
        {
            case 0x00: // NUL - ignore
                return true;

            case 0x07: // BEL
                if (_state == AnsiParserState.OscString)
                {
                    // BEL terminates OSC
                    ExecuteOsc();
                    _state = AnsiParserState.Ground;
                }
                else
                {
                    Bell?.Invoke();
                }
                return true;

            case 0x08: // BS - Backspace
                _buffer.Backspace();
                return true;

            case 0x09: // HT - Tab
                _buffer.Tab();
                return true;

            case 0x0A: // LF - Line Feed
            case 0x0B: // VT - Vertical Tab
            case 0x0C: // FF - Form Feed
                _buffer.LineFeed();
                return true;

            case 0x0D: // CR - Carriage Return
                _buffer.CarriageReturn();
                return true;

            case 0x0E: // SO - Shift Out (ignore)
            case 0x0F: // SI - Shift In (ignore)
                return true;

            case 0x1B: // ESC
                _state = AnsiParserState.Escape;
                _intermediates.Clear();
                return true;

            case 0x18: // CAN
            case 0x1A: // SUB
                // Cancel escape sequence
                _state = AnsiParserState.Ground;
                return true;
        }

        return false;
    }

    private void ProcessGround(byte b)
    {
        if (b >= 0x20 && b < 0x7F)
        {
            // Printable ASCII
            _buffer.WriteChar((char)b);
        }
        else if (b >= 0x80)
        {
            // UTF-8 continuation - for simplicity, write as-is
            // A proper implementation would collect UTF-8 sequences
            _buffer.WriteChar((char)b);
        }
    }

    private void ProcessEscape(byte b)
    {
        switch (b)
        {
            case (byte)'[': // CSI
                _state = AnsiParserState.CsiEntry;
                ResetCsiParser();
                break;

            case (byte)']': // OSC
                _state = AnsiParserState.OscString;
                _oscString.Clear();
                break;

            case (byte)'P': // DCS
                _state = AnsiParserState.DcsEntry;
                ResetCsiParser();
                break;

            case (byte)'X': // SOS
            case (byte)'^': // PM
            case (byte)'_': // APC
                _state = AnsiParserState.SosPmApcString;
                break;

            case (byte)'\\': // ST (String Terminator)
                _state = AnsiParserState.Ground;
                break;

            case (byte)'7': // DECSC - Save Cursor
                _buffer.SaveCursor();
                _state = AnsiParserState.Ground;
                break;

            case (byte)'8': // DECRC - Restore Cursor
                _buffer.RestoreCursor();
                _state = AnsiParserState.Ground;
                break;

            case (byte)'D': // IND - Index (line feed)
                _buffer.LineFeed();
                _state = AnsiParserState.Ground;
                break;

            case (byte)'E': // NEL - Next Line
                _buffer.CarriageReturn();
                _buffer.LineFeed();
                _state = AnsiParserState.Ground;
                break;

            case (byte)'H': // HTS - Horizontal Tab Set (ignore for now)
                _state = AnsiParserState.Ground;
                break;

            case (byte)'M': // RI - Reverse Index
                _buffer.ScrollDown(1);
                _state = AnsiParserState.Ground;
                break;

            case (byte)'c': // RIS - Full Reset
                _buffer.Reset();
                _state = AnsiParserState.Ground;
                break;

            case >= 0x20 and <= 0x2F: // Intermediate
                _intermediates.Append((char)b);
                _state = AnsiParserState.EscapeIntermediate;
                break;

            default:
                // Unknown escape sequence, ignore
                _state = AnsiParserState.Ground;
                break;
        }
    }

    private void ProcessEscapeIntermediate(byte b)
    {
        if (b >= 0x20 && b <= 0x2F)
        {
            _intermediates.Append((char)b);
        }
        else if (b >= 0x30 && b <= 0x7E)
        {
            // Final byte - execute escape sequence
            ExecuteEscapeSequence((char)b);
            _state = AnsiParserState.Ground;
        }
        else
        {
            _state = AnsiParserState.Ground;
        }
    }

    private void ExecuteEscapeSequence(char final)
    {
        var intermediate = _intermediates.ToString();

        // Handle common sequences like ESC ( B (ASCII charset)
        // Most can be ignored for basic terminal emulation
    }

    private void ProcessCsi(byte b)
    {
        if (b >= 0x30 && b <= 0x39) // Digit
        {
            _currentParam = _currentParam * 10 + (b - 0x30);
            _paramStarted = true;
            _state = AnsiParserState.CsiParam;
        }
        else if (b == 0x3B) // Semicolon - parameter separator
        {
            _params.Add(_paramStarted ? _currentParam : 0);
            _currentParam = 0;
            _paramStarted = false;
            _state = AnsiParserState.CsiParam;
        }
        else if (b >= 0x3C && b <= 0x3F) // Private parameter prefix (<=>?)
        {
            _intermediates.Append((char)b);
            _state = AnsiParserState.CsiParam;
        }
        else if (b >= 0x20 && b <= 0x2F) // Intermediate
        {
            if (_paramStarted)
            {
                _params.Add(_currentParam);
                _currentParam = 0;
                _paramStarted = false;
            }
            _intermediates.Append((char)b);
            _state = AnsiParserState.CsiIntermediate;
        }
        else if (b >= 0x40 && b <= 0x7E) // Final byte
        {
            if (_paramStarted)
            {
                _params.Add(_currentParam);
            }
            ExecuteCsi((char)b);
            _state = AnsiParserState.Ground;
        }
        else
        {
            // Invalid, return to ground
            _state = AnsiParserState.Ground;
        }
    }

    private void ProcessCsiIntermediate(byte b)
    {
        if (b >= 0x20 && b <= 0x2F)
        {
            _intermediates.Append((char)b);
        }
        else if (b >= 0x40 && b <= 0x7E)
        {
            ExecuteCsi((char)b);
            _state = AnsiParserState.Ground;
        }
        else
        {
            _state = AnsiParserState.Ground;
        }
    }

    private void ResetCsiParser()
    {
        _params.Clear();
        _intermediates.Clear();
        _currentParam = 0;
        _paramStarted = false;
    }

    private int GetParam(int index, int defaultValue = 0)
    {
        return index < _params.Count ? (_params[index] == 0 ? defaultValue : _params[index]) : defaultValue;
    }

    private void ExecuteCsi(char final)
    {
        var privatePrefix = _intermediates.Length > 0 ? _intermediates[0] : '\0';

        switch (final)
        {
            case 'A': // CUU - Cursor Up
                _buffer.CursorUp(GetParam(0, 1));
                break;

            case 'B': // CUD - Cursor Down
                _buffer.CursorDown(GetParam(0, 1));
                break;

            case 'C': // CUF - Cursor Forward
                _buffer.CursorForward(GetParam(0, 1));
                break;

            case 'D': // CUB - Cursor Back
                _buffer.CursorBack(GetParam(0, 1));
                break;

            case 'E': // CNL - Cursor Next Line
                _buffer.CursorDown(GetParam(0, 1));
                _buffer.CarriageReturn();
                break;

            case 'F': // CPL - Cursor Previous Line
                _buffer.CursorUp(GetParam(0, 1));
                _buffer.CarriageReturn();
                break;

            case 'G': // CHA - Cursor Horizontal Absolute
                _buffer.CursorX = Math.Clamp(GetParam(0, 1) - 1, 0, _buffer.Columns - 1);
                break;

            case 'H': // CUP - Cursor Position
            case 'f': // HVP - Horizontal Vertical Position
                _buffer.SetCursorPosition(GetParam(0, 1), GetParam(1, 1));
                break;

            case 'J': // ED - Erase in Display
                switch (GetParam(0, 0))
                {
                    case 0: _buffer.ClearToEnd(); break;
                    case 1: _buffer.ClearToBeginning(); break;
                    case 2: _buffer.Clear(); break;
                    case 3: _buffer.Reset(); break; // Clear scrollback too
                }
                break;

            case 'K': // EL - Erase in Line
                switch (GetParam(0, 0))
                {
                    case 0: _buffer.ClearLineToEnd(); break;
                    case 1: _buffer.ClearLineToBeginning(); break;
                    case 2: _buffer.ClearLine(); break;
                }
                break;

            case 'L': // IL - Insert Lines
                _buffer.InsertLines(GetParam(0, 1));
                break;

            case 'M': // DL - Delete Lines
                _buffer.DeleteLines(GetParam(0, 1));
                break;

            case 'P': // DCH - Delete Characters
                _buffer.DeleteChars(GetParam(0, 1));
                break;

            case 'S': // SU - Scroll Up
                _buffer.ScrollUp(GetParam(0, 1));
                break;

            case 'T': // SD - Scroll Down
                _buffer.ScrollDown(GetParam(0, 1));
                break;

            case 'X': // ECH - Erase Characters
                var count = GetParam(0, 1);
                for (int i = 0; i < count && _buffer.CursorX + i < _buffer.Columns; i++)
                {
                    var line = _buffer.GetLine(_buffer.CursorY);
                    if (line != null)
                        line[_buffer.CursorX + i] = TerminalCell.Empty;
                }
                break;

            case '@': // ICH - Insert Characters
                _buffer.InsertChars(GetParam(0, 1));
                break;

            case 'd': // VPA - Vertical Position Absolute
                _buffer.CursorY = Math.Clamp(GetParam(0, 1) - 1, 0, _buffer.Rows - 1);
                break;

            case 'm': // SGR - Select Graphic Rendition
                ExecuteSgr();
                break;

            case 'n': // DSR - Device Status Report
                // Would need to write response to PTY input
                // For now, ignore
                break;

            case 'r': // DECSTBM - Set Top and Bottom Margins
                _buffer.SetScrollRegion(GetParam(0, 1), GetParam(1, _buffer.Rows));
                break;

            case 's': // Save cursor (SCO)
                _buffer.SaveCursor();
                break;

            case 'u': // Restore cursor (SCO)
                _buffer.RestoreCursor();
                break;

            case 'h': // SM/DECSET - Set Mode
                if (privatePrefix == '?')
                    ExecuteDecSet(true);
                break;

            case 'l': // RM/DECRST - Reset Mode
                if (privatePrefix == '?')
                    ExecuteDecSet(false);
                break;

            case 'c': // DA - Device Attributes
                // Would need to send response - ignore for now
                break;

            case 't': // Window manipulation (xterm)
                // Ignore
                break;
        }
    }

    private void ExecuteSgr()
    {
        if (_params.Count == 0)
        {
            _buffer.CurrentAttributes = TerminalAttributes.Default;
            return;
        }

        for (int i = 0; i < _params.Count; i++)
        {
            var p = _params[i];

            switch (p)
            {
                case 0: // Reset
                    _buffer.CurrentAttributes = TerminalAttributes.Default;
                    break;

                case 1: // Bold
                    _buffer.CurrentAttributes = _buffer.CurrentAttributes.With(bold: true);
                    break;

                case 2: // Dim
                    _buffer.CurrentAttributes = _buffer.CurrentAttributes.With(dim: true);
                    break;

                case 3: // Italic
                    _buffer.CurrentAttributes = _buffer.CurrentAttributes.With(italic: true);
                    break;

                case 4: // Underline
                    _buffer.CurrentAttributes = _buffer.CurrentAttributes.With(underline: true);
                    break;

                case 5: // Slow blink
                case 6: // Rapid blink
                    _buffer.CurrentAttributes = _buffer.CurrentAttributes.With(blink: true);
                    break;

                case 7: // Inverse
                    _buffer.CurrentAttributes = _buffer.CurrentAttributes.With(inverse: true);
                    break;

                case 8: // Hidden
                    _buffer.CurrentAttributes = _buffer.CurrentAttributes.With(hidden: true);
                    break;

                case 9: // Strikethrough
                    _buffer.CurrentAttributes = _buffer.CurrentAttributes.With(strikethrough: true);
                    break;

                case 21: // Double underline (treat as underline)
                    _buffer.CurrentAttributes = _buffer.CurrentAttributes.With(underline: true);
                    break;

                case 22: // Normal intensity (not bold/dim)
                    _buffer.CurrentAttributes = _buffer.CurrentAttributes.With(bold: false, dim: false);
                    break;

                case 23: // Not italic
                    _buffer.CurrentAttributes = _buffer.CurrentAttributes.With(italic: false);
                    break;

                case 24: // Not underlined
                    _buffer.CurrentAttributes = _buffer.CurrentAttributes.With(underline: false);
                    break;

                case 25: // Not blinking
                    _buffer.CurrentAttributes = _buffer.CurrentAttributes.With(blink: false);
                    break;

                case 27: // Not inverse
                    _buffer.CurrentAttributes = _buffer.CurrentAttributes.With(inverse: false);
                    break;

                case 28: // Not hidden
                    _buffer.CurrentAttributes = _buffer.CurrentAttributes.With(hidden: false);
                    break;

                case 29: // Not strikethrough
                    _buffer.CurrentAttributes = _buffer.CurrentAttributes.With(strikethrough: false);
                    break;

                // Standard foreground colors (30-37)
                case >= 30 and <= 37:
                    _buffer.CurrentAttributes = _buffer.CurrentAttributes.With(
                        foreground: TerminalColor.FromPalette((byte)(p - 30)));
                    break;

                case 38: // Extended foreground color
                    i = ProcessExtendedColor(i, true);
                    break;

                case 39: // Default foreground
                    _buffer.CurrentAttributes = _buffer.CurrentAttributes.With(
                        foreground: TerminalColor.Default);
                    break;

                // Standard background colors (40-47)
                case >= 40 and <= 47:
                    _buffer.CurrentAttributes = _buffer.CurrentAttributes.With(
                        background: TerminalColor.FromPalette((byte)(p - 40)));
                    break;

                case 48: // Extended background color
                    i = ProcessExtendedColor(i, false);
                    break;

                case 49: // Default background
                    _buffer.CurrentAttributes = _buffer.CurrentAttributes.With(
                        background: TerminalColor.Default);
                    break;

                // Bright foreground colors (90-97)
                case >= 90 and <= 97:
                    _buffer.CurrentAttributes = _buffer.CurrentAttributes.With(
                        foreground: TerminalColor.FromPalette((byte)(p - 90 + 8)));
                    break;

                // Bright background colors (100-107)
                case >= 100 and <= 107:
                    _buffer.CurrentAttributes = _buffer.CurrentAttributes.With(
                        background: TerminalColor.FromPalette((byte)(p - 100 + 8)));
                    break;
            }
        }
    }

    private int ProcessExtendedColor(int index, bool isForeground)
    {
        // Need at least 2 more parameters
        if (index + 1 >= _params.Count)
            return index;

        var mode = _params[index + 1];

        if (mode == 5 && index + 2 < _params.Count)
        {
            // 256-color mode: 38;5;n or 48;5;n
            var colorIndex = (byte)Math.Clamp(_params[index + 2], 0, 255);
            var color = TerminalColor.FromPalette(colorIndex);

            if (isForeground)
                _buffer.CurrentAttributes = _buffer.CurrentAttributes.With(foreground: color);
            else
                _buffer.CurrentAttributes = _buffer.CurrentAttributes.With(background: color);

            return index + 2;
        }
        else if (mode == 2 && index + 4 < _params.Count)
        {
            // True color mode: 38;2;r;g;b or 48;2;r;g;b
            var r = (byte)Math.Clamp(_params[index + 2], 0, 255);
            var g = (byte)Math.Clamp(_params[index + 3], 0, 255);
            var b = (byte)Math.Clamp(_params[index + 4], 0, 255);
            var color = TerminalColor.FromRgb(r, g, b);

            if (isForeground)
                _buffer.CurrentAttributes = _buffer.CurrentAttributes.With(foreground: color);
            else
                _buffer.CurrentAttributes = _buffer.CurrentAttributes.With(background: color);

            return index + 4;
        }

        return index;
    }

    private void ExecuteDecSet(bool enable)
    {
        foreach (var p in _params)
        {
            switch (p)
            {
                case 1: // DECCKM - Cursor Keys Mode
                    // Application vs Normal cursor keys - handled by input, not buffer
                    break;

                case 6: // DECOM - Origin Mode
                    _buffer.OriginMode = enable;
                    if (enable)
                    {
                        _buffer.CursorX = 0;
                        _buffer.CursorY = _buffer.ScrollRegionTop;
                    }
                    break;

                case 7: // DECAWM - Auto-wrap Mode
                    _buffer.AutoWrapMode = enable;
                    break;

                case 25: // DECTCEM - Text Cursor Enable Mode
                    _buffer.CursorVisible = enable;
                    break;

                case 47: // Alternate screen buffer (old)
                case 1047: // Alternate screen buffer
                case 1049: // Alternate screen buffer + save cursor
                    // Would need alternate buffer support
                    // For now, just clear if switching to alternate
                    if (enable)
                        _buffer.Clear();
                    break;

                case 2004: // Bracketed paste mode
                    // Handled by input system, not buffer
                    break;
            }
        }
    }

    private void ProcessOsc(byte b)
    {
        if (b == 0x07) // BEL terminates OSC
        {
            ExecuteOsc();
            _state = AnsiParserState.Ground;
        }
        else if (b == 0x1B) // Could be ST (ESC \)
        {
            // Wait for backslash
            // For simplicity, just accept ESC as terminator
            ExecuteOsc();
            _state = AnsiParserState.Escape;
        }
        else if (b >= 0x20)
        {
            _oscString.Append((char)b);
        }
    }

    private void ExecuteOsc()
    {
        var osc = _oscString.ToString();
        var semicolonIndex = osc.IndexOf(';');

        if (semicolonIndex < 0)
            return;

        var command = osc[..semicolonIndex];
        var argument = osc[(semicolonIndex + 1)..];

        switch (command)
        {
            case "0": // Set icon name and window title
            case "1": // Set icon name
            case "2": // Set window title
                TitleChanged?.Invoke(argument);
                break;

            case "7": // Set working directory
                // Format: file://hostname/path
                if (argument.StartsWith("file://"))
                {
                    var pathStart = argument.IndexOf('/', 7);
                    if (pathStart >= 0)
                    {
                        var path = Uri.UnescapeDataString(argument[pathStart..]);
                        WorkingDirectoryChanged?.Invoke(path);
                    }
                }
                break;

            case "8": // Hyperlink
                // Format: 8;params;uri (to start) or 8;; (to end)
                var parts = argument.Split(';', 2);
                if (parts.Length >= 2)
                {
                    var uri = parts[1];
                    if (string.IsNullOrEmpty(uri))
                        HyperlinkDetected?.Invoke(null, string.Empty);
                    else
                        HyperlinkDetected?.Invoke(parts[0], uri);
                }
                break;
        }
    }

    private void ProcessDcs(byte b)
    {
        // Simplified DCS handling - just wait for ST
        if (b == 0x1B)
        {
            // Start of ST?
        }
        else if (b == 0x9C || (b == '\\' && _state == AnsiParserState.DcsPassthrough))
        {
            _state = AnsiParserState.Ground;
        }
    }

    private void ProcessSosPmApc(byte b)
    {
        // Wait for ST (String Terminator)
        if (b == 0x1B || b == 0x9C)
        {
            _state = AnsiParserState.Ground;
        }
    }
}
```

### v0.5.1c Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Terminal/AnsiParserState.cs` | Parser state enum |
| `src/SeniorIntern.Core/Terminal/AnsiParser.cs` | ANSI escape sequence parser |

### v0.5.1c Verification

```bash
# Verify Core project builds
dotnet build src/SeniorIntern.Core
```

---

## v0.5.1d: Terminal Service

### Objective
Create the `ITerminalService` interface and implement it using Pty.Net for cross-platform pseudo-terminal support. The service manages terminal session lifecycle, PTY communication, and coordinates with the parser.

### ITerminalService Interface

```csharp
namespace SeniorIntern.Core.Interfaces;

using SeniorIntern.Core.Models.Terminal;

/// <summary>
/// Service for managing terminal sessions
/// </summary>
public interface ITerminalService : IAsyncDisposable
{
    /// <summary>
    /// Currently active terminal sessions
    /// </summary>
    IReadOnlyList<TerminalSession> Sessions { get; }

    /// <summary>
    /// Currently active (focused) session
    /// </summary>
    TerminalSession? ActiveSession { get; set; }

    /// <summary>
    /// Create a new terminal session
    /// </summary>
    /// <param name="options">Session configuration options</param>
    /// <param name="ct">Cancellation token</param>
    /// <returns>The created session</returns>
    Task<TerminalSession> CreateSessionAsync(
        TerminalSessionOptions? options = null,
        CancellationToken ct = default);

    /// <summary>
    /// Close a terminal session
    /// </summary>
    /// <param name="sessionId">ID of session to close</param>
    /// <param name="ct">Cancellation token</param>
    Task CloseSessionAsync(Guid sessionId, CancellationToken ct = default);

    /// <summary>
    /// Write text input to a session (user keystrokes)
    /// </summary>
    /// <param name="sessionId">Target session ID</param>
    /// <param name="input">Text to write</param>
    /// <param name="ct">Cancellation token</param>
    Task WriteInputAsync(Guid sessionId, string input, CancellationToken ct = default);

    /// <summary>
    /// Write raw bytes to a session
    /// </summary>
    /// <param name="sessionId">Target session ID</param>
    /// <param name="data">Bytes to write</param>
    /// <param name="ct">Cancellation token</param>
    Task WriteInputAsync(Guid sessionId, ReadOnlyMemory<byte> data, CancellationToken ct = default);

    /// <summary>
    /// Resize a terminal session
    /// </summary>
    /// <param name="sessionId">Target session ID</param>
    /// <param name="size">New terminal size</param>
    /// <param name="ct">Cancellation token</param>
    Task ResizeAsync(Guid sessionId, TerminalSize size, CancellationToken ct = default);

    /// <summary>
    /// Send a signal to the terminal process
    /// </summary>
    /// <param name="sessionId">Target session ID</param>
    /// <param name="signal">Signal to send</param>
    /// <param name="ct">Cancellation token</param>
    Task SendSignalAsync(Guid sessionId, TerminalSignal signal, CancellationToken ct = default);

    /// <summary>
    /// Get the terminal buffer for a session
    /// </summary>
    /// <param name="sessionId">Target session ID</param>
    /// <returns>The terminal buffer</returns>
    TerminalBuffer GetBuffer(Guid sessionId);

    /// <summary>
    /// Change the working directory in a session
    /// </summary>
    /// <param name="sessionId">Target session ID</param>
    /// <param name="path">New working directory path</param>
    /// <param name="ct">Cancellation token</param>
    Task ChangeDirectoryAsync(Guid sessionId, string path, CancellationToken ct = default);

    /// <summary>
    /// Execute a command in the terminal
    /// </summary>
    /// <param name="sessionId">Target session ID</param>
    /// <param name="command">Command to execute</param>
    /// <param name="ct">Cancellation token</param>
    Task ExecuteCommandAsync(Guid sessionId, string command, CancellationToken ct = default);

    /// <summary>
    /// Raised when output is received from a session
    /// </summary>
    event EventHandler<TerminalOutputEventArgs>? OutputReceived;

    /// <summary>
    /// Raised when a new session is created
    /// </summary>
    event EventHandler<TerminalSessionEventArgs>? SessionCreated;

    /// <summary>
    /// Raised when a session is closed
    /// </summary>
    event EventHandler<TerminalSessionEventArgs>? SessionClosed;

    /// <summary>
    /// Raised when a session's state changes
    /// </summary>
    event EventHandler<TerminalSessionStateEventArgs>? SessionStateChanged;

    /// <summary>
    /// Raised when the terminal title changes
    /// </summary>
    event EventHandler<TerminalTitleEventArgs>? TitleChanged;
}

/// <summary>
/// Options for creating a terminal session
/// </summary>
public sealed record TerminalSessionOptions
{
    /// <summary>
    /// Path to shell executable (null = auto-detect)
    /// </summary>
    public string? ShellPath { get; init; }

    /// <summary>
    /// Initial working directory (null = user home)
    /// </summary>
    public string? WorkingDirectory { get; init; }

    /// <summary>
    /// Additional environment variables
    /// </summary>
    public Dictionary<string, string>? Environment { get; init; }

    /// <summary>
    /// Initial terminal size
    /// </summary>
    public TerminalSize? Size { get; init; }

    /// <summary>
    /// Associated workspace ID
    /// </summary>
    public Guid? WorkspaceId { get; init; }

    /// <summary>
    /// Display name for the session
    /// </summary>
    public string? Name { get; init; }

    /// <summary>
    /// Arguments to pass to the shell
    /// </summary>
    public string[]? ShellArgs { get; init; }
}

/// <summary>
/// Terminal signals that can be sent to a process
/// </summary>
public enum TerminalSignal
{
    /// <summary>
    /// Interrupt (Ctrl+C / SIGINT)
    /// </summary>
    Interrupt,

    /// <summary>
    /// Terminate (SIGTERM)
    /// </summary>
    Terminate,

    /// <summary>
    /// Kill (SIGKILL)
    /// </summary>
    Kill,

    /// <summary>
    /// Suspend (Ctrl+Z / SIGTSTP)
    /// </summary>
    Suspend,

    /// <summary>
    /// Continue (SIGCONT)
    /// </summary>
    Continue,

    /// <summary>
    /// End of file (Ctrl+D / EOF)
    /// </summary>
    EndOfFile
}

/// <summary>
/// Event args for terminal output
/// </summary>
public sealed class TerminalOutputEventArgs : EventArgs
{
    public required Guid SessionId { get; init; }
    public required ReadOnlyMemory<byte> Data { get; init; }
}

/// <summary>
/// Event args for session events
/// </summary>
public sealed class TerminalSessionEventArgs : EventArgs
{
    public required TerminalSession Session { get; init; }
}

/// <summary>
/// Event args for session state changes
/// </summary>
public sealed class TerminalSessionStateEventArgs : EventArgs
{
    public required TerminalSession Session { get; init; }
    public required TerminalSessionState OldState { get; init; }
    public required TerminalSessionState NewState { get; init; }
}

/// <summary>
/// Event args for title changes
/// </summary>
public sealed class TerminalTitleEventArgs : EventArgs
{
    public required Guid SessionId { get; init; }
    public required string Title { get; init; }
}
```

### TerminalService Implementation

```csharp
namespace SeniorIntern.Services.Terminal;

using System.Collections.Concurrent;
using System.Text;
using Microsoft.Extensions.Logging;
using Pty.Net;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models.Terminal;
using SeniorIntern.Core.Terminal;

/// <summary>
/// Terminal service implementation using Pty.Net
/// </summary>
public sealed class TerminalService : ITerminalService
{
    private readonly IShellDetectionService _shellDetection;
    private readonly ILogger<TerminalService> _logger;
    private readonly ConcurrentDictionary<Guid, TerminalSessionContext> _sessions = new();
    private TerminalSession? _activeSession;
    private bool _disposed;

    public IReadOnlyList<TerminalSession> Sessions =>
        _sessions.Values.Select(c => c.Session).ToList();

    public TerminalSession? ActiveSession
    {
        get => _activeSession;
        set
        {
            if (value != null && !_sessions.ContainsKey(value.Id))
                throw new ArgumentException("Session not found", nameof(value));
            _activeSession = value;
        }
    }

    public event EventHandler<TerminalOutputEventArgs>? OutputReceived;
    public event EventHandler<TerminalSessionEventArgs>? SessionCreated;
    public event EventHandler<TerminalSessionEventArgs>? SessionClosed;
    public event EventHandler<TerminalSessionStateEventArgs>? SessionStateChanged;
    public event EventHandler<TerminalTitleEventArgs>? TitleChanged;

    public TerminalService(
        IShellDetectionService shellDetection,
        ILogger<TerminalService> logger)
    {
        _shellDetection = shellDetection;
        _logger = logger;
    }

    public async Task<TerminalSession> CreateSessionAsync(
        TerminalSessionOptions? options = null,
        CancellationToken ct = default)
    {
        ThrowIfDisposed();
        options ??= new TerminalSessionOptions();

        var shellPath = options.ShellPath ?? await _shellDetection.GetDefaultShellAsync(ct);
        var workingDirectory = options.WorkingDirectory
            ?? Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
        var size = options.Size ?? TerminalSize.Default;

        _logger.LogInformation(
            "Creating terminal session with shell {Shell} in {Directory}",
            shellPath, workingDirectory);

        var session = new TerminalSession
        {
            Name = options.Name ?? GetShellDisplayName(shellPath),
            ShellPath = shellPath,
            WorkingDirectory = workingDirectory,
            Size = size,
            WorkspaceId = options.WorkspaceId,
            Environment = options.Environment ?? new Dictionary<string, string>()
        };

        // Build environment
        var environment = BuildEnvironment(options.Environment);

        // Create PTY options
        var ptyOptions = new PtyOptions
        {
            Name = session.Name,
            Cols = size.Columns,
            Rows = size.Rows,
            Cwd = workingDirectory,
            App = shellPath,
            CommandLine = options.ShellArgs ?? Array.Empty<string>(),
            Environment = environment,
            VerbatimCommandLine = false
        };

        // Spawn PTY
        IPtyConnection pty;
        try
        {
            pty = await PtyProvider.SpawnAsync(ptyOptions, ct);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to spawn PTY for shell {Shell}", shellPath);
            session.State = TerminalSessionState.Error;
            throw new InvalidOperationException($"Failed to create terminal: {ex.Message}", ex);
        }

        // Create buffer and parser
        var buffer = new TerminalBuffer(size.Columns, size.Rows);
        var parser = new AnsiParser(buffer);

        // Hook up parser events
        parser.TitleChanged += title =>
        {
            session.Title = title;
            session.Name = title;
            TitleChanged?.Invoke(this, new TerminalTitleEventArgs
            {
                SessionId = session.Id,
                Title = title
            });
        };

        parser.WorkingDirectoryChanged += dir =>
        {
            session.WorkingDirectory = dir;
        };

        parser.Bell += () =>
        {
            _logger.LogDebug("Bell received in session {SessionId}", session.Id);
        };

        // Create context
        var context = new TerminalSessionContext
        {
            Session = session,
            Pty = pty,
            Buffer = buffer,
            Parser = parser
        };

        // Set up disposal callback
        session.OnDisposeAsync = async () =>
        {
            await CloseSessionAsync(session.Id);
        };

        // Start reading output
        context.ReadTask = ReadOutputAsync(context);

        // Register session
        _sessions[session.Id] = context;
        UpdateSessionState(context, TerminalSessionState.Running);

        // Set as active if first session
        _activeSession ??= session;

        _logger.LogInformation("Created terminal session {SessionId}", session.Id);

        SessionCreated?.Invoke(this, new TerminalSessionEventArgs { Session = session });

        return session;
    }

    public async Task CloseSessionAsync(Guid sessionId, CancellationToken ct = default)
    {
        ThrowIfDisposed();

        if (!_sessions.TryRemove(sessionId, out var context))
            return;

        _logger.LogInformation("Closing terminal session {SessionId}", sessionId);

        // Update state
        UpdateSessionState(context, TerminalSessionState.Closing);

        // Cancel read task
        await context.Cts.CancelAsync();

        try
        {
            // Wait for read task to complete
            await context.ReadTask.WaitAsync(TimeSpan.FromSeconds(2), ct);
        }
        catch (TimeoutException)
        {
            _logger.LogWarning("Read task did not complete in time for session {SessionId}", sessionId);
        }
        catch (OperationCanceledException)
        {
            // Expected
        }

        // Dispose PTY
        try
        {
            context.Pty.Dispose();
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Error disposing PTY for session {SessionId}", sessionId);
        }

        // Update session state
        context.Session.ClosedAt = DateTime.UtcNow;
        context.Session.State = TerminalSessionState.Exited;

        // Clear active session if it was this one
        if (_activeSession?.Id == sessionId)
            _activeSession = Sessions.FirstOrDefault();

        // Dispose context
        context.Cts.Dispose();

        SessionClosed?.Invoke(this, new TerminalSessionEventArgs { Session = context.Session });
    }

    public async Task WriteInputAsync(Guid sessionId, string input, CancellationToken ct = default)
    {
        ThrowIfDisposed();

        if (!_sessions.TryGetValue(sessionId, out var context))
            throw new InvalidOperationException($"Session {sessionId} not found");

        if (context.Session.State != TerminalSessionState.Running)
            throw new InvalidOperationException($"Session {sessionId} is not running");

        var bytes = Encoding.UTF8.GetBytes(input);
        await context.Pty.WriterStream.WriteAsync(bytes, ct);
        await context.Pty.WriterStream.FlushAsync(ct);
    }

    public async Task WriteInputAsync(Guid sessionId, ReadOnlyMemory<byte> data, CancellationToken ct = default)
    {
        ThrowIfDisposed();

        if (!_sessions.TryGetValue(sessionId, out var context))
            throw new InvalidOperationException($"Session {sessionId} not found");

        if (context.Session.State != TerminalSessionState.Running)
            throw new InvalidOperationException($"Session {sessionId} is not running");

        await context.Pty.WriterStream.WriteAsync(data, ct);
        await context.Pty.WriterStream.FlushAsync(ct);
    }

    public Task ResizeAsync(Guid sessionId, TerminalSize size, CancellationToken ct = default)
    {
        ThrowIfDisposed();

        if (!_sessions.TryGetValue(sessionId, out var context))
            throw new InvalidOperationException($"Session {sessionId} not found");

        if (!size.IsValid)
            throw new ArgumentException("Invalid terminal size", nameof(size));

        _logger.LogDebug("Resizing session {SessionId} to {Size}", sessionId, size);

        // Resize PTY
        context.Pty.Resize(size.Columns, size.Rows);

        // Resize buffer
        context.Buffer.Resize(size.Columns, size.Rows);

        // Update session
        context.Session.Size = size;

        return Task.CompletedTask;
    }

    public async Task SendSignalAsync(Guid sessionId, TerminalSignal signal, CancellationToken ct = default)
    {
        ThrowIfDisposed();

        if (!_sessions.TryGetValue(sessionId, out var context))
            throw new InvalidOperationException($"Session {sessionId} not found");

        _logger.LogDebug("Sending signal {Signal} to session {SessionId}", signal, sessionId);

        // Send control character for supported signals
        var controlChar = signal switch
        {
            TerminalSignal.Interrupt => "\x03",  // Ctrl+C
            TerminalSignal.Suspend => "\x1A",    // Ctrl+Z
            TerminalSignal.EndOfFile => "\x04",  // Ctrl+D
            _ => null
        };

        if (controlChar != null)
        {
            await WriteInputAsync(sessionId, controlChar, ct);
        }
        else
        {
            _logger.LogWarning("Signal {Signal} not supported via PTY", signal);
        }
    }

    public TerminalBuffer GetBuffer(Guid sessionId)
    {
        ThrowIfDisposed();

        if (!_sessions.TryGetValue(sessionId, out var context))
            throw new InvalidOperationException($"Session {sessionId} not found");

        return context.Buffer;
    }

    public async Task ChangeDirectoryAsync(Guid sessionId, string path, CancellationToken ct = default)
    {
        ThrowIfDisposed();

        if (!_sessions.TryGetValue(sessionId, out var context))
            throw new InvalidOperationException($"Session {sessionId} not found");

        // Escape path for shell
        var escapedPath = path.Contains(' ') ? $"\"{path}\"" : path;
        var command = $"cd {escapedPath}\r";

        await WriteInputAsync(sessionId, command, ct);

        // Update session working directory (may be updated by OSC 7 later)
        context.Session.WorkingDirectory = path;
    }

    public async Task ExecuteCommandAsync(Guid sessionId, string command, CancellationToken ct = default)
    {
        ThrowIfDisposed();

        if (!_sessions.TryGetValue(sessionId, out var context))
            throw new InvalidOperationException($"Session {sessionId} not found");

        // Append newline if not present
        var fullCommand = command.EndsWith('\r') || command.EndsWith('\n')
            ? command
            : command + "\r";

        await WriteInputAsync(sessionId, fullCommand, ct);
    }

    private async Task ReadOutputAsync(TerminalSessionContext context)
    {
        var buffer = new byte[8192];
        var ct = context.Cts.Token;

        _logger.LogDebug("Starting output read loop for session {SessionId}", context.Session.Id);

        try
        {
            while (!ct.IsCancellationRequested)
            {
                var bytesRead = await context.Pty.ReaderStream.ReadAsync(buffer, ct);

                if (bytesRead == 0)
                {
                    _logger.LogDebug("PTY stream ended for session {SessionId}", context.Session.Id);
                    break;
                }

                // Parse output
                var data = buffer.AsMemory(0, bytesRead);
                context.Parser.Parse(data.Span);

                // Notify listeners
                OutputReceived?.Invoke(this, new TerminalOutputEventArgs
                {
                    SessionId = context.Session.Id,
                    Data = data
                });
            }
        }
        catch (OperationCanceledException)
        {
            // Expected on close
            _logger.LogDebug("Output read cancelled for session {SessionId}", context.Session.Id);
        }
        catch (IOException ex)
        {
            _logger.LogDebug(ex, "IO error reading from PTY for session {SessionId}", context.Session.Id);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error reading output for session {SessionId}", context.Session.Id);
            UpdateSessionState(context, TerminalSessionState.Error);
        }
        finally
        {
            // Session ended - get exit code if available
            try
            {
                context.Session.ExitCode = context.Pty.ExitCode;
            }
            catch
            {
                // Exit code may not be available
            }

            if (context.Session.State == TerminalSessionState.Running)
            {
                UpdateSessionState(context, TerminalSessionState.Exited);
                context.Session.ClosedAt = DateTime.UtcNow;

                SessionClosed?.Invoke(this, new TerminalSessionEventArgs
                {
                    Session = context.Session
                });
            }
        }
    }

    private void UpdateSessionState(TerminalSessionContext context, TerminalSessionState newState)
    {
        var oldState = context.Session.State;
        if (oldState == newState)
            return;

        context.Session.State = newState;

        SessionStateChanged?.Invoke(this, new TerminalSessionStateEventArgs
        {
            Session = context.Session,
            OldState = oldState,
            NewState = newState
        });
    }

    private Dictionary<string, string> BuildEnvironment(Dictionary<string, string>? custom)
    {
        var env = new Dictionary<string, string>();

        // Copy current environment
        foreach (System.Collections.DictionaryEntry entry in Environment.GetEnvironmentVariables())
        {
            if (entry.Key is string key && entry.Value is string value)
                env[key] = value;
        }

        // Set TERM for proper escape sequence support
        env["TERM"] = "xterm-256color";
        env["COLORTERM"] = "truecolor";

        // Set LANG for UTF-8 support if not set
        if (!env.ContainsKey("LANG"))
            env["LANG"] = "en_US.UTF-8";

        // Add custom environment variables
        if (custom != null)
        {
            foreach (var (key, value) in custom)
                env[key] = value;
        }

        return env;
    }

    private static string GetShellDisplayName(string shellPath)
    {
        var fileName = Path.GetFileNameWithoutExtension(shellPath);
        return fileName switch
        {
            "bash" => "Bash",
            "zsh" => "Zsh",
            "fish" => "Fish",
            "pwsh" or "powershell" => "PowerShell",
            "cmd" => "Command Prompt",
            "nu" => "Nushell",
            _ => fileName
        };
    }

    private void ThrowIfDisposed()
    {
        if (_disposed)
            throw new ObjectDisposedException(nameof(TerminalService));
    }

    public async ValueTask DisposeAsync()
    {
        if (_disposed)
            return;

        _disposed = true;
        _logger.LogInformation("Disposing terminal service");

        // Close all sessions
        foreach (var sessionId in _sessions.Keys.ToList())
        {
            try
            {
                await CloseSessionAsync(sessionId);
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Error closing session {SessionId} during disposal", sessionId);
            }
        }

        _sessions.Clear();
    }

    /// <summary>
    /// Internal context for managing a terminal session
    /// </summary>
    private sealed class TerminalSessionContext
    {
        public required TerminalSession Session { get; init; }
        public required IPtyConnection Pty { get; init; }
        public required TerminalBuffer Buffer { get; init; }
        public required AnsiParser Parser { get; init; }
        public CancellationTokenSource Cts { get; } = new();
        public Task ReadTask { get; set; } = Task.CompletedTask;
    }
}
```

### v0.5.1d Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/ITerminalService.cs` | Terminal service interface and related types |
| `src/SeniorIntern.Services/Terminal/TerminalService.cs` | PTY-based terminal service implementation |

### v0.5.1d Verification

```bash
# Verify Services project builds
dotnet build src/SeniorIntern.Services
```

---

## v0.5.1e: Shell Detection

### Objective
Implement cross-platform shell detection to automatically find and use the appropriate default shell on Windows, macOS, and Linux.

### IShellDetectionService Interface

```csharp
namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Service for detecting available shells on the system
/// </summary>
public interface IShellDetectionService
{
    /// <summary>
    /// Get the default shell for the current platform
    /// </summary>
    Task<string> GetDefaultShellAsync(CancellationToken ct = default);

    /// <summary>
    /// Get all available shells on the system
    /// </summary>
    Task<IReadOnlyList<ShellInfo>> GetAvailableShellsAsync(CancellationToken ct = default);

    /// <summary>
    /// Check if a shell is available at the specified path
    /// </summary>
    Task<bool> IsShellAvailableAsync(string path, CancellationToken ct = default);
}

/// <summary>
/// Information about an available shell
/// </summary>
public sealed record ShellInfo
{
    /// <summary>
    /// Display name for the shell
    /// </summary>
    public required string Name { get; init; }

    /// <summary>
    /// Full path to the shell executable
    /// </summary>
    public required string Path { get; init; }

    /// <summary>
    /// Shell type identifier
    /// </summary>
    public required ShellType Type { get; init; }

    /// <summary>
    /// Version string if available
    /// </summary>
    public string? Version { get; init; }

    /// <summary>
    /// Whether this is the system default shell
    /// </summary>
    public bool IsDefault { get; init; }
}

/// <summary>
/// Known shell types
/// </summary>
public enum ShellType
{
    Unknown,
    Bash,
    Zsh,
    Fish,
    PowerShell,
    Cmd,
    Nushell,
    Sh
}
```

### ShellDetectionService Implementation

```csharp
namespace SeniorIntern.Services.Terminal;

using System.Diagnostics;
using System.Runtime.InteropServices;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;

/// <summary>
/// Cross-platform shell detection service
/// </summary>
public sealed class ShellDetectionService : IShellDetectionService
{
    private readonly ILogger<ShellDetectionService> _logger;
    private IReadOnlyList<ShellInfo>? _cachedShells;

    public ShellDetectionService(ILogger<ShellDetectionService> logger)
    {
        _logger = logger;
    }

    public async Task<string> GetDefaultShellAsync(CancellationToken ct = default)
    {
        string? defaultShell = null;

        if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
        {
            defaultShell = await GetWindowsDefaultShellAsync(ct);
        }
        else if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
        {
            defaultShell = await GetMacDefaultShellAsync(ct);
        }
        else if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
        {
            defaultShell = await GetLinuxDefaultShellAsync(ct);
        }

        if (string.IsNullOrEmpty(defaultShell))
        {
            _logger.LogWarning("Could not detect default shell, falling back to platform default");
            defaultShell = GetFallbackShell();
        }

        _logger.LogInformation("Default shell detected: {Shell}", defaultShell);
        return defaultShell;
    }

    public async Task<IReadOnlyList<ShellInfo>> GetAvailableShellsAsync(CancellationToken ct = default)
    {
        if (_cachedShells != null)
            return _cachedShells;

        var shells = new List<ShellInfo>();
        var defaultShell = await GetDefaultShellAsync(ct);

        if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
        {
            await AddWindowsShellsAsync(shells, defaultShell, ct);
        }
        else
        {
            await AddUnixShellsAsync(shells, defaultShell, ct);
        }

        _cachedShells = shells;
        return shells;
    }

    public async Task<bool> IsShellAvailableAsync(string path, CancellationToken ct = default)
    {
        try
        {
            if (!File.Exists(path))
                return false;

            // Try to execute --version to verify it's a working shell
            using var process = new Process
            {
                StartInfo = new ProcessStartInfo
                {
                    FileName = path,
                    Arguments = "--version",
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    UseShellExecute = false,
                    CreateNoWindow = true
                }
            };

            process.Start();
            await process.WaitForExitAsync(ct).WaitAsync(TimeSpan.FromSeconds(5), ct);
            return true;
        }
        catch
        {
            return false;
        }
    }

    private async Task<string?> GetWindowsDefaultShellAsync(CancellationToken ct)
    {
        // Check for PowerShell Core first
        var pwshPath = FindExecutable("pwsh");
        if (pwshPath != null && await IsShellAvailableAsync(pwshPath, ct))
            return pwshPath;

        // Fall back to Windows PowerShell
        var windowsPowerShell = Path.Combine(
            Environment.GetFolderPath(Environment.SpecialFolder.System),
            "WindowsPowerShell", "v1.0", "powershell.exe");

        if (File.Exists(windowsPowerShell))
            return windowsPowerShell;

        // Ultimate fallback to cmd.exe
        var cmdPath = Path.Combine(
            Environment.GetFolderPath(Environment.SpecialFolder.System),
            "cmd.exe");

        return File.Exists(cmdPath) ? cmdPath : null;
    }

    private async Task<string?> GetMacDefaultShellAsync(CancellationToken ct)
    {
        // Try to get SHELL environment variable
        var shell = Environment.GetEnvironmentVariable("SHELL");
        if (!string.IsNullOrEmpty(shell) && await IsShellAvailableAsync(shell, ct))
            return shell;

        // Try dscl to get user's shell
        try
        {
            using var process = new Process
            {
                StartInfo = new ProcessStartInfo
                {
                    FileName = "dscl",
                    Arguments = $". -read /Users/{Environment.UserName} UserShell",
                    RedirectStandardOutput = true,
                    UseShellExecute = false,
                    CreateNoWindow = true
                }
            };

            process.Start();
            var output = await process.StandardOutput.ReadToEndAsync(ct);
            await process.WaitForExitAsync(ct);

            // Output is like "UserShell: /bin/zsh"
            var parts = output.Split(':', 2);
            if (parts.Length == 2)
            {
                shell = parts[1].Trim();
                if (await IsShellAvailableAsync(shell, ct))
                    return shell;
            }
        }
        catch (Exception ex)
        {
            _logger.LogDebug(ex, "Failed to get shell from dscl");
        }

        // macOS defaults to zsh since Catalina
        return "/bin/zsh";
    }

    private async Task<string?> GetLinuxDefaultShellAsync(CancellationToken ct)
    {
        // Try SHELL environment variable
        var shell = Environment.GetEnvironmentVariable("SHELL");
        if (!string.IsNullOrEmpty(shell) && await IsShellAvailableAsync(shell, ct))
            return shell;

        // Try to read from /etc/passwd
        try
        {
            var passwd = await File.ReadAllTextAsync("/etc/passwd", ct);
            var username = Environment.UserName;
            var lines = passwd.Split('\n');

            foreach (var line in lines)
            {
                if (line.StartsWith(username + ":"))
                {
                    var parts = line.Split(':');
                    if (parts.Length >= 7)
                    {
                        shell = parts[6].Trim();
                        if (await IsShellAvailableAsync(shell, ct))
                            return shell;
                    }
                }
            }
        }
        catch (Exception ex)
        {
            _logger.LogDebug(ex, "Failed to get shell from /etc/passwd");
        }

        // Fall back to bash
        return "/bin/bash";
    }

    private async Task AddWindowsShellsAsync(
        List<ShellInfo> shells,
        string defaultShell,
        CancellationToken ct)
    {
        // PowerShell Core
        var pwshPath = FindExecutable("pwsh");
        if (pwshPath != null && await IsShellAvailableAsync(pwshPath, ct))
        {
            shells.Add(new ShellInfo
            {
                Name = "PowerShell",
                Path = pwshPath,
                Type = ShellType.PowerShell,
                IsDefault = pwshPath == defaultShell,
                Version = await GetVersionAsync(pwshPath, "--version", ct)
            });
        }

        // Windows PowerShell
        var windowsPowerShell = Path.Combine(
            Environment.GetFolderPath(Environment.SpecialFolder.System),
            "WindowsPowerShell", "v1.0", "powershell.exe");

        if (File.Exists(windowsPowerShell))
        {
            shells.Add(new ShellInfo
            {
                Name = "Windows PowerShell",
                Path = windowsPowerShell,
                Type = ShellType.PowerShell,
                IsDefault = windowsPowerShell == defaultShell
            });
        }

        // Command Prompt
        var cmdPath = Path.Combine(
            Environment.GetFolderPath(Environment.SpecialFolder.System),
            "cmd.exe");

        if (File.Exists(cmdPath))
        {
            shells.Add(new ShellInfo
            {
                Name = "Command Prompt",
                Path = cmdPath,
                Type = ShellType.Cmd,
                IsDefault = cmdPath == defaultShell
            });
        }

        // Git Bash
        var gitBashPaths = new[]
        {
            @"C:\Program Files\Git\bin\bash.exe",
            @"C:\Program Files (x86)\Git\bin\bash.exe",
            Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),
                "Programs", "Git", "bin", "bash.exe")
        };

        foreach (var gitBash in gitBashPaths)
        {
            if (File.Exists(gitBash))
            {
                shells.Add(new ShellInfo
                {
                    Name = "Git Bash",
                    Path = gitBash,
                    Type = ShellType.Bash,
                    IsDefault = gitBash == defaultShell
                });
                break;
            }
        }

        // WSL Bash (if available)
        var wslPath = Path.Combine(
            Environment.GetFolderPath(Environment.SpecialFolder.System),
            "wsl.exe");

        if (File.Exists(wslPath))
        {
            shells.Add(new ShellInfo
            {
                Name = "WSL",
                Path = wslPath,
                Type = ShellType.Bash,
                IsDefault = wslPath == defaultShell
            });
        }

        // Nushell
        var nuPath = FindExecutable("nu");
        if (nuPath != null && await IsShellAvailableAsync(nuPath, ct))
        {
            shells.Add(new ShellInfo
            {
                Name = "Nushell",
                Path = nuPath,
                Type = ShellType.Nushell,
                IsDefault = nuPath == defaultShell,
                Version = await GetVersionAsync(nuPath, "--version", ct)
            });
        }
    }

    private async Task AddUnixShellsAsync(
        List<ShellInfo> shells,
        string defaultShell,
        CancellationToken ct)
    {
        var shellPaths = new (string Name, string Path, ShellType Type)[]
        {
            ("Bash", "/bin/bash", ShellType.Bash),
            ("Zsh", "/bin/zsh", ShellType.Zsh),
            ("Zsh", "/usr/bin/zsh", ShellType.Zsh),
            ("Fish", "/usr/bin/fish", ShellType.Fish),
            ("Fish", "/usr/local/bin/fish", ShellType.Fish),
            ("Fish", "/opt/homebrew/bin/fish", ShellType.Fish),
            ("Sh", "/bin/sh", ShellType.Sh),
            ("Nushell", "/usr/bin/nu", ShellType.Nushell),
            ("Nushell", "/usr/local/bin/nu", ShellType.Nushell),
            ("Nushell", "/opt/homebrew/bin/nu", ShellType.Nushell),
        };

        var addedPaths = new HashSet<string>();

        foreach (var (name, path, type) in shellPaths)
        {
            if (addedPaths.Contains(path))
                continue;

            if (await IsShellAvailableAsync(path, ct))
            {
                addedPaths.Add(path);
                shells.Add(new ShellInfo
                {
                    Name = name,
                    Path = path,
                    Type = type,
                    IsDefault = path == defaultShell,
                    Version = await GetVersionAsync(path, "--version", ct)
                });
            }
        }

        // Check for PowerShell Core
        var pwshPaths = new[] { "/usr/bin/pwsh", "/usr/local/bin/pwsh", "/opt/homebrew/bin/pwsh" };
        foreach (var pwshPath in pwshPaths)
        {
            if (await IsShellAvailableAsync(pwshPath, ct))
            {
                shells.Add(new ShellInfo
                {
                    Name = "PowerShell",
                    Path = pwshPath,
                    Type = ShellType.PowerShell,
                    IsDefault = pwshPath == defaultShell,
                    Version = await GetVersionAsync(pwshPath, "--version", ct)
                });
                break;
            }
        }
    }

    private static string GetFallbackShell()
    {
        if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
            return Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.System), "cmd.exe");

        return "/bin/sh";
    }

    private static string? FindExecutable(string name)
    {
        var pathEnv = Environment.GetEnvironmentVariable("PATH");
        if (string.IsNullOrEmpty(pathEnv))
            return null;

        var paths = pathEnv.Split(Path.PathSeparator);

        foreach (var path in paths)
        {
            var fullPath = RuntimeInformation.IsOSPlatform(OSPlatform.Windows)
                ? Path.Combine(path, name + ".exe")
                : Path.Combine(path, name);

            if (File.Exists(fullPath))
                return fullPath;
        }

        return null;
    }

    private async Task<string?> GetVersionAsync(string path, string args, CancellationToken ct)
    {
        try
        {
            using var process = new Process
            {
                StartInfo = new ProcessStartInfo
                {
                    FileName = path,
                    Arguments = args,
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    UseShellExecute = false,
                    CreateNoWindow = true
                }
            };

            process.Start();
            var output = await process.StandardOutput.ReadLineAsync(ct);
            await process.WaitForExitAsync(ct).WaitAsync(TimeSpan.FromSeconds(2), ct);

            return output?.Trim();
        }
        catch
        {
            return null;
        }
    }
}
```

### v0.5.1e Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/IShellDetectionService.cs` | Shell detection interface and types |
| `src/SeniorIntern.Services/Terminal/ShellDetectionService.cs` | Cross-platform shell detection |

### v0.5.1e Verification

```bash
# Verify builds
dotnet build src/SeniorIntern.Services
```

---

## v0.5.1f: Integration & Testing

### Objective
Register terminal services with dependency injection, create unit tests for the ANSI parser and buffer, and verify integration with a simple test harness.

### Service Registration Extensions

```csharp
namespace SeniorIntern.Services.Terminal;

using Microsoft.Extensions.DependencyInjection;
using SeniorIntern.Core.Interfaces;

/// <summary>
/// Extension methods for registering terminal services
/// </summary>
public static class TerminalServiceExtensions
{
    /// <summary>
    /// Add terminal services to the service collection
    /// </summary>
    public static IServiceCollection AddTerminalServices(this IServiceCollection services)
    {
        services.AddSingleton<IShellDetectionService, ShellDetectionService>();
        services.AddSingleton<ITerminalService, TerminalService>();

        return services;
    }
}
```

### Unit Tests: AnsiParserTests

```csharp
namespace SeniorIntern.Core.Tests.Terminal;

using SeniorIntern.Core.Models.Terminal;
using SeniorIntern.Core.Terminal;
using Xunit;

public class AnsiParserTests
{
    private readonly TerminalBuffer _buffer;
    private readonly AnsiParser _parser;

    public AnsiParserTests()
    {
        _buffer = new TerminalBuffer(80, 24);
        _parser = new AnsiParser(_buffer);
    }

    [Fact]
    public void Parse_PlainText_WritesToBuffer()
    {
        _parser.Parse("Hello, World!");

        var line = _buffer.GetLine(0);
        Assert.NotNull(line);
        Assert.Equal("Hello, World!", line.GetText());
    }

    [Fact]
    public void Parse_NewLine_AdvancesCursor()
    {
        _parser.Parse("Line 1\nLine 2");

        Assert.Equal(1, _buffer.CursorY);
    }

    [Fact]
    public void Parse_CarriageReturn_ResetsCursorX()
    {
        _parser.Parse("Hello\rWorld");

        var line = _buffer.GetLine(0);
        Assert.NotNull(line);
        Assert.Equal("World", line.GetText());
    }

    [Fact]
    public void Parse_CursorUp_MovesCursor()
    {
        _buffer.CursorY = 5;
        _parser.Parse("\x1B[2A"); // Move up 2

        Assert.Equal(3, _buffer.CursorY);
    }

    [Fact]
    public void Parse_CursorDown_MovesCursor()
    {
        _buffer.CursorY = 0;
        _parser.Parse("\x1B[3B"); // Move down 3

        Assert.Equal(3, _buffer.CursorY);
    }

    [Fact]
    public void Parse_CursorPosition_SetsCursor()
    {
        _parser.Parse("\x1B[5;10H"); // Row 5, Column 10

        Assert.Equal(4, _buffer.CursorY); // 0-indexed
        Assert.Equal(9, _buffer.CursorX); // 0-indexed
    }

    [Fact]
    public void Parse_SgrReset_ResetsAttributes()
    {
        _buffer.CurrentAttributes = _buffer.CurrentAttributes.With(bold: true);
        _parser.Parse("\x1B[0m");

        Assert.Equal(TerminalAttributes.Default, _buffer.CurrentAttributes);
    }

    [Fact]
    public void Parse_SgrBold_SetsBold()
    {
        _parser.Parse("\x1B[1m");

        Assert.True(_buffer.CurrentAttributes.Bold);
    }

    [Fact]
    public void Parse_SgrForegroundColor_SetsColor()
    {
        _parser.Parse("\x1B[31m"); // Red

        Assert.Equal(TerminalColor.FromPalette(1), _buffer.CurrentAttributes.Foreground);
    }

    [Fact]
    public void Parse_Sgr256Color_SetsColor()
    {
        _parser.Parse("\x1B[38;5;196m"); // Bright red from 256 palette

        Assert.Equal(TerminalColor.FromPalette(196), _buffer.CurrentAttributes.Foreground);
    }

    [Fact]
    public void Parse_SgrTrueColor_SetsColor()
    {
        _parser.Parse("\x1B[38;2;255;128;64m"); // RGB

        Assert.Equal(TerminalColor.FromRgb(255, 128, 64), _buffer.CurrentAttributes.Foreground);
    }

    [Fact]
    public void Parse_EraseDisplay_ClearsScreen()
    {
        _parser.Parse("Some text");
        _parser.Parse("\x1B[2J"); // Clear entire screen

        var line = _buffer.GetLine(0);
        Assert.NotNull(line);
        Assert.True(string.IsNullOrWhiteSpace(line.GetText()));
    }

    [Fact]
    public void Parse_EraseLine_ClearsLine()
    {
        _parser.Parse("Hello, World!");
        _buffer.CursorX = 5;
        _parser.Parse("\x1B[K"); // Clear to end of line

        var line = _buffer.GetLine(0);
        Assert.NotNull(line);
        Assert.Equal("Hello", line.GetText());
    }

    [Fact]
    public void Parse_SaveRestoreCursor_WorksCorrectly()
    {
        _buffer.CursorX = 10;
        _buffer.CursorY = 5;
        _parser.Parse("\x1B7"); // Save cursor

        _buffer.CursorX = 0;
        _buffer.CursorY = 0;
        _parser.Parse("\x1B8"); // Restore cursor

        Assert.Equal(10, _buffer.CursorX);
        Assert.Equal(5, _buffer.CursorY);
    }

    [Fact]
    public void Parse_OscTitle_RaisesEvent()
    {
        string? receivedTitle = null;
        _parser.TitleChanged += title => receivedTitle = title;

        _parser.Parse("\x1B]0;My Terminal\x07");

        Assert.Equal("My Terminal", receivedTitle);
    }

    [Fact]
    public void Parse_Bell_RaisesEvent()
    {
        var bellReceived = false;
        _parser.Bell += () => bellReceived = true;

        _parser.Parse("\x07");

        Assert.True(bellReceived);
    }

    [Fact]
    public void Parse_Tab_MovesCursorToNextTabStop()
    {
        _buffer.CursorX = 3;
        _parser.Parse("\t");

        Assert.Equal(8, _buffer.CursorX);
    }

    [Fact]
    public void Parse_Backspace_MovesCursorBack()
    {
        _buffer.CursorX = 5;
        _parser.Parse("\x08");

        Assert.Equal(4, _buffer.CursorX);
    }
}
```

### Unit Tests: TerminalBufferTests

```csharp
namespace SeniorIntern.Core.Tests.Terminal;

using SeniorIntern.Core.Models.Terminal;
using Xunit;

public class TerminalBufferTests
{
    [Fact]
    public void Constructor_InitializesCorrectly()
    {
        var buffer = new TerminalBuffer(80, 24);

        Assert.Equal(80, buffer.Columns);
        Assert.Equal(24, buffer.Rows);
        Assert.Equal(0, buffer.CursorX);
        Assert.Equal(0, buffer.CursorY);
        Assert.True(buffer.CursorVisible);
    }

    [Fact]
    public void WriteChar_WritesToCurrentPosition()
    {
        var buffer = new TerminalBuffer(80, 24);
        buffer.WriteChar('A');

        var line = buffer.GetLine(0);
        Assert.NotNull(line);
        Assert.Equal('A', (char)line[0].Character.Value);
        Assert.Equal(1, buffer.CursorX);
    }

    [Fact]
    public void WriteChar_AdvancesCursor()
    {
        var buffer = new TerminalBuffer(80, 24);
        buffer.WriteString("Hello");

        Assert.Equal(5, buffer.CursorX);
    }

    [Fact]
    public void WriteChar_AtEndOfLine_Wraps()
    {
        var buffer = new TerminalBuffer(5, 24);
        buffer.WriteString("Hello!");

        Assert.Equal(1, buffer.CursorX);
        Assert.Equal(1, buffer.CursorY);
    }

    [Fact]
    public void LineFeed_MovesCursorDown()
    {
        var buffer = new TerminalBuffer(80, 24);
        buffer.LineFeed();

        Assert.Equal(1, buffer.CursorY);
    }

    [Fact]
    public void LineFeed_AtBottom_Scrolls()
    {
        var buffer = new TerminalBuffer(80, 3);
        buffer.WriteString("Line 1");
        buffer.LineFeed();
        buffer.WriteString("Line 2");
        buffer.LineFeed();
        buffer.WriteString("Line 3");
        buffer.LineFeed();
        buffer.WriteString("Line 4");

        // Line 1 should have scrolled off
        var firstVisibleLine = buffer.GetLine(0);
        Assert.NotNull(firstVisibleLine);
        Assert.Equal("Line 2", firstVisibleLine.GetText());
    }

    [Fact]
    public void CarriageReturn_ResetsCursorX()
    {
        var buffer = new TerminalBuffer(80, 24);
        buffer.CursorX = 10;
        buffer.CarriageReturn();

        Assert.Equal(0, buffer.CursorX);
    }

    [Fact]
    public void Clear_ClearsAllLines()
    {
        var buffer = new TerminalBuffer(80, 24);
        buffer.WriteString("Hello");
        buffer.Clear();

        var line = buffer.GetLine(0);
        Assert.NotNull(line);
        Assert.True(string.IsNullOrWhiteSpace(line.GetText()));
    }

    [Fact]
    public void ClearLine_ClearsCurrentLine()
    {
        var buffer = new TerminalBuffer(80, 24);
        buffer.WriteString("Hello");
        buffer.ClearLine();

        var line = buffer.GetLine(0);
        Assert.NotNull(line);
        Assert.True(string.IsNullOrWhiteSpace(line.GetText()));
    }

    [Fact]
    public void ClearLineToEnd_ClearsFromCursor()
    {
        var buffer = new TerminalBuffer(80, 24);
        buffer.WriteString("Hello World");
        buffer.CursorX = 5;
        buffer.ClearLineToEnd();

        var line = buffer.GetLine(0);
        Assert.NotNull(line);
        Assert.Equal("Hello", line.GetText());
    }

    [Fact]
    public void Resize_AdjustsBuffer()
    {
        var buffer = new TerminalBuffer(80, 24);
        buffer.Resize(120, 30);

        Assert.Equal(120, buffer.Columns);
        Assert.Equal(30, buffer.Rows);
    }

    [Fact]
    public void SetCursorPosition_ClampsToBounds()
    {
        var buffer = new TerminalBuffer(80, 24);
        buffer.SetCursorPosition(100, 200); // Way out of bounds

        Assert.Equal(23, buffer.CursorY); // Clamped to Rows - 1
        Assert.Equal(79, buffer.CursorX); // Clamped to Columns - 1
    }

    [Fact]
    public void SaveRestoreCursor_WorksCorrectly()
    {
        var buffer = new TerminalBuffer(80, 24);
        buffer.CursorX = 10;
        buffer.CursorY = 5;
        buffer.CurrentAttributes = buffer.CurrentAttributes.With(bold: true);

        buffer.SaveCursor();

        buffer.CursorX = 0;
        buffer.CursorY = 0;
        buffer.CurrentAttributes = TerminalAttributes.Default;

        buffer.RestoreCursor();

        Assert.Equal(10, buffer.CursorX);
        Assert.Equal(5, buffer.CursorY);
        Assert.True(buffer.CurrentAttributes.Bold);
    }

    [Fact]
    public void GetSelectedText_ReturnsCorrectText()
    {
        var buffer = new TerminalBuffer(80, 24);
        buffer.WriteString("Hello World");

        var selection = new TerminalSelection
        {
            StartLine = buffer.TotalLines - 1,
            StartColumn = 0,
            EndLine = buffer.TotalLines - 1,
            EndColumn = 4
        };

        var text = buffer.GetSelectedText(selection);
        Assert.Equal("Hello", text);
    }

    [Fact]
    public void ScrollRegion_LimitsScrolling()
    {
        var buffer = new TerminalBuffer(80, 10);
        buffer.SetScrollRegion(3, 7); // Lines 3-7 (1-indexed)

        Assert.Equal(2, buffer.ScrollRegionTop); // 0-indexed
        Assert.Equal(7, buffer.ScrollRegionBottom);
    }
}
```

### v0.5.1f Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Services/Terminal/TerminalServiceExtensions.cs` | DI registration |
| `tests/SeniorIntern.Core.Tests/Terminal/AnsiParserTests.cs` | Parser unit tests |
| `tests/SeniorIntern.Core.Tests/Terminal/TerminalBufferTests.cs` | Buffer unit tests |

### v0.5.1f Files to Modify

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/App.axaml.cs` | Register terminal services |

### App.axaml.cs Integration

```csharp
// In App.axaml.cs service registration
services.AddTerminalServices();
```

### v0.5.1f Verification

```bash
# Run unit tests
dotnet test tests/SeniorIntern.Core.Tests

# Verify full solution builds
dotnet build SeniorIntern.sln

# Run the app and verify no startup errors
dotnet run --project src/SeniorIntern.Desktop
```

---

## Files Summary

### Files to Create (Total: 15)

| Part | File | Purpose |
|------|------|---------|
| v0.5.1b | `src/SeniorIntern.Core/Models/Terminal/TerminalSize.cs` | Terminal dimensions |
| v0.5.1b | `src/SeniorIntern.Core/Models/Terminal/TerminalColor.cs` | Color representation |
| v0.5.1b | `src/SeniorIntern.Core/Models/Terminal/TerminalAttributes.cs` | Text styling |
| v0.5.1b | `src/SeniorIntern.Core/Models/Terminal/TerminalCell.cs` | Single buffer cell |
| v0.5.1b | `src/SeniorIntern.Core/Models/Terminal/TerminalLine.cs` | Line of cells |
| v0.5.1b | `src/SeniorIntern.Core/Models/Terminal/TerminalSelection.cs` | Text selection |
| v0.5.1b | `src/SeniorIntern.Core/Models/Terminal/TerminalSessionState.cs` | Session state enum |
| v0.5.1b | `src/SeniorIntern.Core/Models/Terminal/TerminalSession.cs` | Session model |
| v0.5.1b | `src/SeniorIntern.Core/Models/Terminal/TerminalBuffer.cs` | Screen buffer |
| v0.5.1c | `src/SeniorIntern.Core/Terminal/AnsiParserState.cs` | Parser states |
| v0.5.1c | `src/SeniorIntern.Core/Terminal/AnsiParser.cs` | ANSI parser |
| v0.5.1d | `src/SeniorIntern.Core/Interfaces/ITerminalService.cs` | Service interface |
| v0.5.1d | `src/SeniorIntern.Services/Terminal/TerminalService.cs` | PTY implementation |
| v0.5.1e | `src/SeniorIntern.Core/Interfaces/IShellDetectionService.cs` | Shell detection interface |
| v0.5.1e | `src/SeniorIntern.Services/Terminal/ShellDetectionService.cs` | Shell detection |
| v0.5.1f | `src/SeniorIntern.Services/Terminal/TerminalServiceExtensions.cs` | DI registration |
| v0.5.1f | `tests/SeniorIntern.Core.Tests/Terminal/AnsiParserTests.cs` | Parser tests |
| v0.5.1f | `tests/SeniorIntern.Core.Tests/Terminal/TerminalBufferTests.cs` | Buffer tests |

### Files to Modify (Total: 3)

| Part | File | Changes |
|------|------|---------|
| v0.5.1a | `Directory.Packages.props` | Add Pty.Net package |
| v0.5.1a | `src/SeniorIntern.Services/SeniorIntern.Services.csproj` | Add package reference |
| v0.5.1f | `src/SeniorIntern.Desktop/App.axaml.cs` | Register terminal services |

---

## Testing Strategy

### Unit Tests
- ANSI parser: escape sequences, SGR attributes, cursor movement
- Terminal buffer: write operations, scrolling, clear operations
- Terminal models: serialization, equality, validation

### Integration Tests
- PTY creation on each platform
- Shell detection accuracy
- Session lifecycle (create, write, read, close)
- Resize handling

### Manual Testing
- Visual verification of ANSI color rendering
- Shell interaction responsiveness
- Cross-platform behavior consistency

---

## Acceptance Criteria

### v0.5.1a
- [ ] Pty.Net package added to solution
- [ ] Solution builds successfully
- [ ] Folder structure created

### v0.5.1b
- [ ] All terminal model classes compile
- [ ] TerminalBuffer supports basic operations
- [ ] TerminalCell supports Unicode characters
- [ ] TerminalColor supports default, palette, and RGB modes

### v0.5.1c
- [ ] AnsiParser handles printable ASCII
- [ ] AnsiParser processes CSI sequences
- [ ] AnsiParser supports SGR (colors and styles)
- [ ] AnsiParser handles cursor movement
- [ ] AnsiParser processes OSC for title changes

### v0.5.1d
- [ ] TerminalService creates PTY sessions
- [ ] Input can be written to sessions
- [ ] Output is received and parsed
- [ ] Sessions can be resized
- [ ] Sessions can be closed properly

### v0.5.1e
- [ ] Default shell detected on Windows
- [ ] Default shell detected on macOS
- [ ] Default shell detected on Linux
- [ ] Available shells enumerated correctly

### v0.5.1f
- [ ] Services registered in DI container
- [ ] Unit tests pass
- [ ] Application starts without errors

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Pty.Net compatibility issues | Medium | High | Test on all platforms early |
| ANSI escape sequences not fully supported | Medium | Medium | Focus on common sequences first |
| Performance issues with large output | Low | Medium | Use efficient buffer operations |
| Shell detection fails on some systems | Low | Low | Provide fallback shells |
| Memory leaks from improper disposal | Low | High | Implement IAsyncDisposable correctly |

---

## Dependencies

### External
- Pty.Net NuGet package
- System.IO.Pipelines NuGet package

### Internal
- SeniorIntern.Core (models, interfaces)
- SeniorIntern.Services (implementation)

---

## Future Considerations

Features deferred to later sub-versions:
- Terminal UI rendering (v0.5.2)
- Tab management (v0.5.2)
- Shell profiles (v0.5.3)
- Working directory sync with workspace (v0.5.3)
- Copy-to-terminal integration (v0.5.4)
- Command history and search (v0.5.5)
