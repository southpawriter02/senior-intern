# Design Specification: AIntern v0.5.5b "Terminal Search Service"

## Overview

**Version**: v0.5.5b
**Parent**: v0.5.5 Polish & Integration
**Focus**: Search implementation with regex support and result navigation

### Purpose

This sub-version implements the terminal search service:
1. Define `ITerminalSearchService` interface with search and navigation methods
2. Implement `TerminalSearchService` with efficient buffer searching
3. Support both plain text and regex pattern matching
4. Provide result navigation with wrap-around support
5. Validate regex patterns before execution
6. Support cancellation for long-running searches
7. Add buffer access methods for line retrieval

### Dependencies

**From v0.5.5a (Terminal Search Models)**:
- `TerminalSearchResult` - Individual match
- `TerminalSearchState` - Search state container
- `TerminalSearchOptions` - Configuration options

**From v0.5.1 (Terminal Foundation)**:
- `TerminalBuffer` - Buffer content access
- `ITerminalBuffer` interface (extended)

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                v0.5.5b Terminal Search Service Architecture                   │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                     Interface Layer                                      │ │
│  │  src/AIntern.Core/Interfaces/                                           │ │
│  ├─────────────────────────────────────────────────────────────────────────┤ │
│  │                                                                          │ │
│  │  ITerminalSearchService                                                  │ │
│  │  ├── SearchAsync(buffer, query, state, options, ct)                     │ │
│  │  │     → TerminalSearchState                                            │ │
│  │  ├── NavigateNext(state) → TerminalSearchState                          │ │
│  │  ├── NavigatePrevious(state) → TerminalSearchState                      │ │
│  │  ├── NavigateToIndex(state, index) → TerminalSearchState                │ │
│  │  ├── ClearSearch() → TerminalSearchState                                │ │
│  │  └── ValidateRegexPattern(pattern) → string?                            │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                     Service Layer                                        │ │
│  │  src/AIntern.Services/Terminal/                                         │ │
│  ├─────────────────────────────────────────────────────────────────────────┤ │
│  │                                                                          │ │
│  │  TerminalSearchService : ITerminalSearchService                          │ │
│  │  ├── Constructor(ILogger<TerminalSearchService>)                        │ │
│  │  │                                                                       │ │
│  │  ├── Search Implementation:                                             │ │
│  │  │   ├── Validate query length (MinQueryLength)                         │ │
│  │  │   ├── Validate regex pattern if UseRegex                             │ │
│  │  │   ├── Run search on background thread                                │ │
│  │  │   ├── Support cancellation token                                     │ │
│  │  │   └── Return state with results or error                             │ │
│  │  │                                                                       │ │
│  │  ├── PerformSearch() - Core search logic:                               │ │
│  │  │   ├── Iterate buffer lines                                           │ │
│  │  │   ├── Plain text: StringComparison matching                          │ │
│  │  │   ├── Regex: Regex.Matches with timeout                              │ │
│  │  │   ├── Limit results to MaxResults                                    │ │
│  │  │   └── Build TerminalSearchResult for each match                      │ │
│  │  │                                                                       │ │
│  │  └── Navigation:                                                        │ │
│  │      ├── NavigateNext: index + 1, wrap if needed                        │ │
│  │      ├── NavigatePrevious: index - 1, wrap if needed                    │ │
│  │      └── NavigateToIndex: clamp to valid range                          │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │               ITerminalBuffer Extension (for search)                     │ │
│  │  src/AIntern.Core/Interfaces/ITerminalBuffer.cs                         │ │
│  ├─────────────────────────────────────────────────────────────────────────┤ │
│  │                                                                          │ │
│  │  Additional Members:                                                     │ │
│  │  ├── TotalLineCount: int (scrollback + visible)                         │ │
│  │  ├── GetLine(lineIndex) → string                                        │ │
│  │  └── GetLines(startLine, count) → IEnumerable<string>                   │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Search Flow

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                          Search Execution Flow                                │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  SearchAsync(buffer, query, state, options, ct) called                       │
│           │                                                                  │
│           ▼                                                                  │
│  ┌────────────────────────────────────────────────────────────────────────┐ │
│  │  1. Validate Query                                                      │ │
│  │  ├── If null/empty or < MinQueryLength                                 │ │
│  │  │     → Return empty state with query                                 │ │
│  │  └── Create initial state with IsSearching = true                      │ │
│  └──────────────────────────┬─────────────────────────────────────────────┘ │
│                             │                                                │
│                             ▼                                                │
│  ┌────────────────────────────────────────────────────────────────────────┐ │
│  │  2. Validate Regex (if UseRegex)                                        │ │
│  │  ├── Call ValidateRegexPattern(query)                                  │ │
│  │  ├── If error != null                                                  │ │
│  │  │     → Return state with { ErrorMessage = error }                    │ │
│  │  └── Continue if valid                                                 │ │
│  └──────────────────────────┬─────────────────────────────────────────────┘ │
│                             │                                                │
│                             ▼                                                │
│  ┌────────────────────────────────────────────────────────────────────────┐ │
│  │  3. Execute Search on Background Thread                                 │ │
│  │  ├── Task.Run(() => PerformSearch(...), ct)                            │ │
│  │  ├── Check cancellation token periodically                             │ │
│  │  └── Throw if cancelled                                                │ │
│  └──────────────────────────┬─────────────────────────────────────────────┘ │
│                             │                                                │
│                             ▼                                                │
│  ┌────────────────────────────────────────────────────────────────────────┐ │
│  │  4. PerformSearch()                                                     │ │
│  │  ├── Iterate lines: 0 to buffer.TotalLineCount                         │ │
│  │  ├── For each line:                                                    │ │
│  │  │   ├── If Regex: use Regex.Matches(lineContent)                     │ │
│  │  │   │   ├── Create result for each Match                             │ │
│  │  │   │   └── Check MaxResults limit                                   │ │
│  │  │   └── If Plain: use IndexOf with StringComparison                  │ │
│  │  │       ├── Loop to find all occurrences                             │ │
│  │  │       └── Check MaxResults limit                                   │ │
│  │  └── Return List<TerminalSearchResult>                                 │ │
│  └──────────────────────────┬─────────────────────────────────────────────┘ │
│                             │                                                │
│                             ▼                                                │
│  ┌────────────────────────────────────────────────────────────────────────┐ │
│  │  5. Build Result State                                                  │ │
│  │  ├── results = (from PerformSearch)                                    │ │
│  │  ├── CurrentResultIndex = results.Count > 0 ? 0 : -1                   │ │
│  │  ├── IsSearching = false                                               │ │
│  │  └── Return state with { Results = results }                           │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│                             │                                                │
│                             ▼                                                │
│  ┌────────────────────────────────────────────────────────────────────────┐ │
│  │  Exception Handling:                                                    │ │
│  │  ├── OperationCanceledException → rethrow                              │ │
│  │  └── Other exceptions → Return state with { ErrorMessage = ex.Msg }   │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Navigation Logic

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                        Navigation State Machine                               │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Results: [R0, R1, R2, R3, R4]  (5 results)                                  │
│  WrapAround: true                                                            │
│                                                                              │
│  ┌────────────────────────────────────────────────────────────────────────┐ │
│  │  NavigateNext()                                                         │ │
│  │                                                                          │ │
│  │       CurrentIndex    →    NewIndex                                     │ │
│  │       ─────────────────────────────                                     │ │
│  │           0           →       1                                         │ │
│  │           1           →       2                                         │ │
│  │           2           →       3                                         │ │
│  │           3           →       4                                         │ │
│  │           4           →       0  (wrap)  ──┐                            │ │
│  │                                            │                            │ │
│  │                  ┌─────────────────────────┘                            │ │
│  │                  │ If WrapAround = false                                │ │
│  │                  ▼                                                       │ │
│  │           4           →       4  (stay at end)                          │ │
│  │                                                                          │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  ┌────────────────────────────────────────────────────────────────────────┐ │
│  │  NavigatePrevious()                                                     │ │
│  │                                                                          │ │
│  │       CurrentIndex    →    NewIndex                                     │ │
│  │       ─────────────────────────────                                     │ │
│  │           4           →       3                                         │ │
│  │           3           →       2                                         │ │
│  │           2           →       1                                         │ │
│  │           1           →       0                                         │ │
│  │           0           →       4  (wrap)  ──┐                            │ │
│  │                                            │                            │ │
│  │                  ┌─────────────────────────┘                            │ │
│  │                  │ If WrapAround = false                                │ │
│  │                  ▼                                                       │ │
│  │           0           →       0  (stay at start)                        │ │
│  │                                                                          │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  ┌────────────────────────────────────────────────────────────────────────┐ │
│  │  NavigateToIndex(index)                                                 │ │
│  │                                                                          │ │
│  │       Input Index    →    Clamped Index                                 │ │
│  │       ─────────────────────────────────                                 │ │
│  │          -5          →       0  (min clamp)                             │ │
│  │           0          →       0                                          │ │
│  │           2          →       2                                          │ │
│  │           4          →       4                                          │ │
│  │          10          →       4  (max clamp)                             │ │
│  │                                                                          │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Specifications

### 1. ITerminalSearchService.cs

**Location**: `src/AIntern.Core/Interfaces/ITerminalSearchService.cs`

```csharp
namespace AIntern.Core.Interfaces;

using AIntern.Core.Models.Terminal;

/// <summary>
/// Service for searching within terminal buffer content.
/// Supports plain text and regex patterns with result navigation.
/// </summary>
public interface ITerminalSearchService
{
    /// <summary>
    /// Search for a pattern in the terminal buffer.
    /// </summary>
    /// <param name="buffer">The terminal buffer to search.</param>
    /// <param name="query">The search query (plain text or regex).</param>
    /// <param name="state">Current search state with options.</param>
    /// <param name="options">Search configuration options.</param>
    /// <param name="ct">Cancellation token for long-running searches.</param>
    /// <returns>Updated search state with results.</returns>
    Task<TerminalSearchState> SearchAsync(
        ITerminalBuffer buffer,
        string query,
        TerminalSearchState state,
        TerminalSearchOptions options,
        CancellationToken ct = default);

    /// <summary>
    /// Perform incremental search with debouncing support.
    /// </summary>
    /// <param name="buffer">The terminal buffer to search.</param>
    /// <param name="query">The search query.</param>
    /// <param name="options">Search configuration options.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>New search state with results.</returns>
    Task<TerminalSearchState> IncrementalSearchAsync(
        ITerminalBuffer buffer,
        string query,
        TerminalSearchOptions options,
        CancellationToken ct = default);

    /// <summary>
    /// Navigate to the next search result.
    /// </summary>
    /// <param name="state">Current search state.</param>
    /// <returns>Updated state with new current index.</returns>
    TerminalSearchState NavigateNext(TerminalSearchState state);

    /// <summary>
    /// Navigate to the previous search result.
    /// </summary>
    /// <param name="state">Current search state.</param>
    /// <returns>Updated state with new current index.</returns>
    TerminalSearchState NavigatePrevious(TerminalSearchState state);

    /// <summary>
    /// Navigate to a specific result by index.
    /// </summary>
    /// <param name="state">Current search state.</param>
    /// <param name="index">Target result index (will be clamped to valid range).</param>
    /// <returns>Updated state with new current index.</returns>
    TerminalSearchState NavigateToIndex(TerminalSearchState state, int index);

    /// <summary>
    /// Navigate to the result nearest to a specific line.
    /// </summary>
    /// <param name="state">Current search state.</param>
    /// <param name="lineIndex">Target line index.</param>
    /// <param name="direction">Search direction for nearest result.</param>
    /// <returns>Updated state with current index set to nearest result.</returns>
    TerminalSearchState NavigateToLine(
        TerminalSearchState state, 
        int lineIndex,
        SearchDirection direction = SearchDirection.Forward);

    /// <summary>
    /// Clear the current search state.
    /// </summary>
    /// <returns>Empty search state.</returns>
    TerminalSearchState ClearSearch();

    /// <summary>
    /// Validate a regular expression pattern.
    /// </summary>
    /// <param name="pattern">The regex pattern to validate.</param>
    /// <returns>Error message if invalid, null if valid.</returns>
    string? ValidateRegexPattern(string pattern);

    /// <summary>
    /// Get highlight positions for visible results (for rendering).
    /// </summary>
    /// <param name="state">Current search state.</param>
    /// <param name="firstVisibleLine">First visible line index.</param>
    /// <param name="visibleLineCount">Number of visible lines.</param>
    /// <returns>Results within the visible viewport.</returns>
    IReadOnlyList<TerminalSearchResult> GetVisibleResults(
        TerminalSearchState state,
        int firstVisibleLine,
        int visibleLineCount);
}
```

### 2. TerminalSearchService.cs

**Location**: `src/AIntern.Services/Terminal/TerminalSearchService.cs`

```csharp
namespace AIntern.Services.Terminal;

using System.Text.RegularExpressions;
using Microsoft.Extensions.Logging;
using AIntern.Core.Interfaces;
using AIntern.Core.Models.Terminal;

/// <summary>
/// Service for searching within terminal buffer content.
/// </summary>
public sealed class TerminalSearchService : ITerminalSearchService
{
    private readonly ILogger<TerminalSearchService> _logger;

    public TerminalSearchService(ILogger<TerminalSearchService> logger)
    {
        _logger = logger;
    }

    /// <inheritdoc />
    public async Task<TerminalSearchState> SearchAsync(
        ITerminalBuffer buffer,
        string query,
        TerminalSearchState state,
        TerminalSearchOptions options,
        CancellationToken ct = default)
    {
        ArgumentNullException.ThrowIfNull(buffer);
        ArgumentNullException.ThrowIfNull(state);
        ArgumentNullException.ThrowIfNull(options);

        // Check minimum query length
        if (string.IsNullOrEmpty(query) || query.Length < options.MinQueryLength)
        {
            _logger.LogDebug(
                "Query too short: {Length} < {MinLength}", 
                query?.Length ?? 0, 
                options.MinQueryLength);
            
            return state with 
            { 
                Query = query ?? string.Empty,
                Results = Array.Empty<TerminalSearchResult>(),
                CurrentResultIndex = -1,
                IsSearching = false
            };
        }

        // Update state to searching
        var searchingState = state with
        {
            Query = query,
            IsSearching = true,
            ErrorMessage = null
        };

        try
        {
            // Validate regex if needed
            if (state.UseRegex)
            {
                var error = ValidateRegexPattern(query);
                if (error != null)
                {
                    _logger.LogWarning("Invalid regex pattern: {Pattern}, Error: {Error}", query, error);
                    return searchingState with 
                    { 
                        ErrorMessage = error, 
                        IsSearching = false 
                    };
                }
            }

            // Perform search on background thread
            var results = await Task.Run(
                () => PerformSearch(
                    buffer, 
                    query, 
                    state.CaseSensitive, 
                    state.UseRegex,
                    state.IncludeScrollback,
                    options.MaxResults,
                    options.RegexTimeoutMs,
                    ct),
                ct);

            _logger.LogDebug(
                "Search completed: Query=\"{Query}\", Results={Count}", 
                query, 
                results.Count);

            return searchingState with
            {
                Results = results,
                CurrentResultIndex = results.Count > 0 ? 0 : -1,
                IsSearching = false
            };
        }
        catch (OperationCanceledException)
        {
            _logger.LogDebug("Search cancelled for query: {Query}", query);
            throw;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Search failed for query: {Query}", query);
            return searchingState with 
            { 
                ErrorMessage = ex.Message, 
                IsSearching = false 
            };
        }
    }

    /// <inheritdoc />
    public async Task<TerminalSearchState> IncrementalSearchAsync(
        ITerminalBuffer buffer,
        string query,
        TerminalSearchOptions options,
        CancellationToken ct = default)
    {
        var state = new TerminalSearchState
        {
            Query = query,
            CaseSensitive = options.DefaultCaseSensitive,
            UseRegex = options.DefaultUseRegex,
            WrapAround = options.DefaultWrapAround,
            IncludeScrollback = options.DefaultIncludeScrollback
        };

        return await SearchAsync(buffer, query, state, options, ct);
    }

    private List<TerminalSearchResult> PerformSearch(
        ITerminalBuffer buffer,
        string query,
        bool caseSensitive,
        bool useRegex,
        bool includeScrollback,
        int maxResults,
        int regexTimeoutMs,
        CancellationToken ct)
    {
        var results = new List<TerminalSearchResult>();
        
        var comparison = caseSensitive
            ? StringComparison.Ordinal
            : StringComparison.OrdinalIgnoreCase;

        Regex? regex = null;
        if (useRegex)
        {
            var regexOptions = caseSensitive 
                ? RegexOptions.None 
                : RegexOptions.IgnoreCase;
            regexOptions |= RegexOptions.Compiled;
            
            regex = new Regex(query, regexOptions, TimeSpan.FromMilliseconds(regexTimeoutMs));
        }

        // Determine line range
        int startLine = includeScrollback ? 0 : buffer.FirstVisibleLine;
        int endLine = buffer.TotalLineCount;

        for (int lineIndex = startLine; lineIndex < endLine; lineIndex++)
        {
            // Check cancellation periodically (every 100 lines)
            if (lineIndex % 100 == 0)
            {
                ct.ThrowIfCancellationRequested();
            }

            // Stop if we've hit max results
            if (results.Count >= maxResults)
            {
                _logger.LogDebug("Reached max results limit: {MaxResults}", maxResults);
                break;
            }

            var lineContent = buffer.GetLine(lineIndex);
            if (string.IsNullOrEmpty(lineContent))
                continue;

            if (useRegex && regex != null)
            {
                SearchLineWithRegex(
                    regex, 
                    lineContent, 
                    lineIndex, 
                    results, 
                    maxResults);
            }
            else
            {
                SearchLineWithText(
                    query, 
                    lineContent, 
                    lineIndex, 
                    comparison, 
                    results, 
                    maxResults);
            }
        }

        return results;
    }

    private void SearchLineWithRegex(
        Regex regex,
        string lineContent,
        int lineIndex,
        List<TerminalSearchResult> results,
        int maxResults)
    {
        try
        {
            var matches = regex.Matches(lineContent);
            
            foreach (Match match in matches)
            {
                if (results.Count >= maxResults)
                    break;

                results.Add(new TerminalSearchResult
                {
                    LineIndex = lineIndex,
                    StartColumn = match.Index,
                    Length = match.Length,
                    MatchedText = match.Value,
                    LineContent = lineContent
                });
            }
        }
        catch (RegexMatchTimeoutException ex)
        {
            _logger.LogWarning(
                ex,
                "Regex timeout on line {LineIndex}", 
                lineIndex);
            // Continue with other lines
        }
    }

    private void SearchLineWithText(
        string query,
        string lineContent,
        int lineIndex,
        StringComparison comparison,
        List<TerminalSearchResult> results,
        int maxResults)
    {
        int startIndex = 0;
        int index;

        while ((index = lineContent.IndexOf(query, startIndex, comparison)) >= 0)
        {
            if (results.Count >= maxResults)
                break;

            results.Add(new TerminalSearchResult
            {
                LineIndex = lineIndex,
                StartColumn = index,
                Length = query.Length,
                MatchedText = lineContent.Substring(index, query.Length),
                LineContent = lineContent
            });

            // Move past this match to find next
            startIndex = index + 1;
        }
    }

    /// <inheritdoc />
    public TerminalSearchState NavigateNext(TerminalSearchState state)
    {
        ArgumentNullException.ThrowIfNull(state);
        
        if (!state.HasResults)
        {
            return state;
        }

        var newIndex = state.CurrentResultIndex + 1;
        
        if (newIndex >= state.Results.Count)
        {
            newIndex = state.WrapAround ? 0 : state.Results.Count - 1;
        }

        _logger.LogDebug(
            "Navigate next: {OldIndex} → {NewIndex}", 
            state.CurrentResultIndex, 
            newIndex);

        return state with { CurrentResultIndex = newIndex };
    }

    /// <inheritdoc />
    public TerminalSearchState NavigatePrevious(TerminalSearchState state)
    {
        ArgumentNullException.ThrowIfNull(state);
        
        if (!state.HasResults)
        {
            return state;
        }

        var newIndex = state.CurrentResultIndex - 1;
        
        if (newIndex < 0)
        {
            newIndex = state.WrapAround ? state.Results.Count - 1 : 0;
        }

        _logger.LogDebug(
            "Navigate previous: {OldIndex} → {NewIndex}", 
            state.CurrentResultIndex, 
            newIndex);

        return state with { CurrentResultIndex = newIndex };
    }

    /// <inheritdoc />
    public TerminalSearchState NavigateToIndex(TerminalSearchState state, int index)
    {
        ArgumentNullException.ThrowIfNull(state);
        
        if (!state.HasResults)
        {
            return state;
        }

        var clampedIndex = Math.Clamp(index, 0, state.Results.Count - 1);

        _logger.LogDebug(
            "Navigate to index: {Requested} → {Clamped}", 
            index, 
            clampedIndex);

        return state with { CurrentResultIndex = clampedIndex };
    }

    /// <inheritdoc />
    public TerminalSearchState NavigateToLine(
        TerminalSearchState state, 
        int lineIndex,
        SearchDirection direction = SearchDirection.Forward)
    {
        ArgumentNullException.ThrowIfNull(state);
        
        if (!state.HasResults)
        {
            return state;
        }

        // Find nearest result to the target line
        var nearestIndex = state.FindNearestResultIndex(lineIndex, direction);

        if (nearestIndex >= 0)
        {
            return state with { CurrentResultIndex = nearestIndex };
        }

        return state;
    }

    /// <inheritdoc />
    public TerminalSearchState ClearSearch()
    {
        _logger.LogDebug("Search cleared");
        return TerminalSearchState.Empty;
    }

    /// <inheritdoc />
    public string? ValidateRegexPattern(string pattern)
    {
        if (string.IsNullOrEmpty(pattern))
        {
            return null;
        }

        try
        {
            // Try to create the regex with a short timeout
            _ = new Regex(pattern, RegexOptions.None, TimeSpan.FromSeconds(1));
            return null;
        }
        catch (ArgumentException ex)
        {
            return $"Invalid regex: {ex.Message}";
        }
        catch (RegexMatchTimeoutException)
        {
            return "Regex pattern is too complex";
        }
    }

    /// <inheritdoc />
    public IReadOnlyList<TerminalSearchResult> GetVisibleResults(
        TerminalSearchState state,
        int firstVisibleLine,
        int visibleLineCount)
    {
        ArgumentNullException.ThrowIfNull(state);

        if (!state.HasResults)
        {
            return Array.Empty<TerminalSearchResult>();
        }

        var lastVisibleLine = firstVisibleLine + visibleLineCount;

        return state.Results
            .Where(r => r.LineIndex >= firstVisibleLine && r.LineIndex < lastVisibleLine)
            .ToList();
    }
}
```

### 3. ITerminalBuffer Extensions

**Location**: `src/AIntern.Core/Interfaces/ITerminalBuffer.cs` (additions)

```csharp
namespace AIntern.Core.Interfaces;

/// <summary>
/// Interface for terminal buffer content access.
/// Extended to support search functionality.
/// </summary>
public partial interface ITerminalBuffer
{
    // === Existing members... ===

    // === Search Support Extensions ===

    /// <summary>
    /// Gets the total number of lines including scrollback.
    /// </summary>
    int TotalLineCount { get; }

    /// <summary>
    /// Gets the index of the first visible line (for viewport-only search).
    /// </summary>
    int FirstVisibleLine { get; }

    /// <summary>
    /// Gets the number of visible lines in the viewport.
    /// </summary>
    int VisibleLineCount { get; }

    /// <summary>
    /// Gets the text content of a specific line.
    /// </summary>
    /// <param name="lineIndex">Line index (0-based, including scrollback).</param>
    /// <returns>Line text content, or empty string if index out of range.</returns>
    string GetLine(int lineIndex);

    /// <summary>
    /// Gets a range of lines as text.
    /// </summary>
    /// <param name="startLine">Starting line index.</param>
    /// <param name="count">Number of lines to retrieve.</param>
    /// <returns>Line contents.</returns>
    IEnumerable<string> GetLines(int startLine, int count);

    /// <summary>
    /// Gets all buffer content as a single string.
    /// </summary>
    /// <param name="includeScrollback">Whether to include scrollback buffer.</param>
    /// <returns>Buffer content.</returns>
    string GetAllText(bool includeScrollback = true);
}
```

### 4. TerminalBuffer Search Extensions Implementation

**Location**: `src/AIntern.Services/Terminal/TerminalBuffer.cs` (additions)

```csharp
// Add to existing TerminalBuffer class

/// <inheritdoc />
public int TotalLineCount => _scrollbackBuffer.Count + _visibleBuffer.Count;

/// <inheritdoc />
public int FirstVisibleLine => _scrollbackBuffer.Count;

/// <inheritdoc />
public int VisibleLineCount => _visibleBuffer.Count;

/// <inheritdoc />
public string GetLine(int lineIndex)
{
    if (lineIndex < 0 || lineIndex >= TotalLineCount)
    {
        return string.Empty;
    }

    // Check if in scrollback or visible buffer
    if (lineIndex < _scrollbackBuffer.Count)
    {
        return _scrollbackBuffer[lineIndex].GetText();
    }
    else
    {
        var visibleIndex = lineIndex - _scrollbackBuffer.Count;
        return _visibleBuffer[visibleIndex].GetText();
    }
}

/// <inheritdoc />
public IEnumerable<string> GetLines(int startLine, int count)
{
    var endLine = Math.Min(startLine + count, TotalLineCount);
    
    for (int i = startLine; i < endLine; i++)
    {
        yield return GetLine(i);
    }
}

/// <inheritdoc />
public string GetAllText(bool includeScrollback = true)
{
    var sb = new StringBuilder();
    
    int startLine = includeScrollback ? 0 : FirstVisibleLine;
    
    for (int i = startLine; i < TotalLineCount; i++)
    {
        if (i > startLine)
        {
            sb.AppendLine();
        }
        sb.Append(GetLine(i));
    }
    
    return sb.ToString();
}
```

---

## File Summary

| File | Location | Purpose |
|------|----------|---------|
| `ITerminalSearchService.cs` | `src/AIntern.Core/Interfaces/` | Search service interface |
| `TerminalSearchService.cs` | `src/AIntern.Services/Terminal/` | Search implementation |

### Files to Modify

| File | Changes |
|------|---------|
| `src/AIntern.Core/Interfaces/ITerminalBuffer.cs` | Add TotalLineCount, GetLine, GetLines |
| `src/AIntern.Services/Terminal/TerminalBuffer.cs` | Implement search access methods |
| `src/AIntern.Services/DependencyInjection.cs` | Register ITerminalSearchService |

---

## Unit Test Plan

| Test | Description |
|------|-------------|
| `SearchAsync_EmptyQuery_ReturnsEmptyState` | Short query handling |
| `SearchAsync_QueryTooShort_ReturnsEmptyState` | MinQueryLength check |
| `SearchAsync_PlainText_FindsAllMatches` | Basic text search |
| `SearchAsync_CaseSensitive_MatchesExact` | Case-sensitive mode |
| `SearchAsync_CaseInsensitive_MatchesAny` | Case-insensitive mode |
| `SearchAsync_Regex_FindsPatternMatches` | Regex mode |
| `SearchAsync_InvalidRegex_ReturnsError` | Regex validation |
| `SearchAsync_RegexTimeout_HandlesGracefully` | Timeout handling |
| `SearchAsync_MaxResults_LimitsOutput` | Result limiting |
| `SearchAsync_Cancellation_ThrowsOperationCanceled` | Cancel support |
| `SearchAsync_EmptyBuffer_ReturnsEmptyResults` | Empty buffer |
| `SearchAsync_MultipleMatchesPerLine_FindsAll` | Multiple per line |
| `NavigateNext_WrapsAround_ToFirstResult` | Wrap forward |
| `NavigateNext_NoWrap_StaysAtEnd` | No wrap forward |
| `NavigatePrevious_WrapsAround_ToLastResult` | Wrap backward |
| `NavigatePrevious_NoWrap_StaysAtStart` | No wrap backward |
| `NavigateToIndex_ClampsToValidRange` | Index clamping |
| `NavigateToLine_FindsNearestForward` | Forward nearest |
| `NavigateToLine_FindsNearestBackward` | Backward nearest |
| `ClearSearch_ReturnsEmptyState` | Clear operation |
| `ValidateRegexPattern_Valid_ReturnsNull` | Valid regex |
| `ValidateRegexPattern_Invalid_ReturnsError` | Invalid regex |
| `GetVisibleResults_FiltersToViewport` | Viewport filtering |
| `IncrementalSearch_UsesDefaultOptions` | Incremental mode |
| `PerformSearch_ChecksCancellationPeriodically` | Cancelability |

**Total Tests**: 25

---

## Verification

```bash
# Build the projects
dotnet build src/AIntern.Core
dotnet build src/AIntern.Services

# Run unit tests
dotnet test --filter "TerminalSearch"

# Verify DI registration
grep -n "ITerminalSearchService" src/AIntern.Services/DependencyInjection.cs
```

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | Plain text search finds all occurrences |
| AC-2 | Case-sensitive mode matches exact case only |
| AC-3 | Case-insensitive mode matches any case |
| AC-4 | Regex mode supports standard patterns |
| AC-5 | Invalid regex returns error message |
| AC-6 | Regex timeout prevents catastrophic backtracking |
| AC-7 | MaxResults limits output correctly |
| AC-8 | Search runs on background thread |
| AC-9 | Cancellation token stops long searches |
| AC-10 | NavigateNext wraps when WrapAround is true |
| AC-11 | NavigatePrevious wraps when WrapAround is true |
| AC-12 | GetVisibleResults filters to viewport |
| AC-13 | Buffer GetLine returns correct content |

---

## Changelog Entry

```markdown
## v0.5.5b - Terminal Search Service

### Added
- `ITerminalSearchService` interface:
  - SearchAsync with buffer, query, state, options, cancellation
  - IncrementalSearchAsync for debounced search
  - NavigateNext, NavigatePrevious, NavigateToIndex, NavigateToLine
  - ClearSearch for state reset
  - ValidateRegexPattern for pattern validation
  - GetVisibleResults for viewport filtering

- `TerminalSearchService` implementation:
  - Background thread search execution
  - Plain text search with StringComparison
  - Regex search with compiled patterns and timeout
  - Cancellation support with periodic checks
  - MaxResults limiting
  - Comprehensive logging

### Extended
- `ITerminalBuffer` with search support methods:
  - TotalLineCount property
  - FirstVisibleLine property
  - VisibleLineCount property
  - GetLine(lineIndex) method
  - GetLines(startLine, count) method
  - GetAllText(includeScrollback) method
```

---

## Timeline Estimate

| Version | Estimated Effort |
|---------|------------------|
| v0.5.5b | 0.75 day |
