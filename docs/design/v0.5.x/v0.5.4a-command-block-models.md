# Design Specification: AIntern v0.5.4a "Command Block Models"

## Overview

**Version**: v0.5.4a
**Parent**: v0.5.4 Command Integration
**Focus**: Core data models for command extraction, execution tracking, and output capture

### Purpose

This sub-version defines the foundational models for command integration:
1. `CommandBlock` - Represents an executable command extracted from AI responses
2. `CommandBlockStatus` - Tracks command execution state (Pending → Executing → Executed)
3. `TerminalOutputCapture` - Stores captured terminal output for AI context
4. `OutputCaptureMode` - Defines how output is captured (buffer, selection, last command)
5. `CommandExtractionResult` - Container for extraction results and warnings
6. `TextRange` - Represents character positions in source text

### Dependencies

**From v0.5.3a (Shell Detection)**:
- `ShellType` - Used to associate commands with their target shell

**From Existing Codebase**:
- `System.Text.Json` - JSON serialization for persistence

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                    v0.5.4a Command Block Models Architecture                  │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                        Model Layer                                       │ │
│  │  src/AIntern.Core/Models/Terminal/                                      │ │
│  ├─────────────────────────────────────────────────────────────────────────┤ │
│  │                                                                          │ │
│  │  CommandBlock                           CommandBlockStatus (enum)       │ │
│  │  ┌─────────────────────────────────┐    ├── Pending                     │ │
│  │  │ Identity                        │    ├── Copied                      │ │
│  │  │ ├── Id: Guid                    │    ├── SentToTerminal              │ │
│  │  │ ├── MessageId: Guid             │    ├── Executing                   │ │
│  │  │ └── SequenceNumber: int         │    ├── Executed                    │ │
│  │  ├─────────────────────────────────┤    ├── Failed                      │ │
│  │  │ Content                         │    └── Cancelled                   │ │
│  │  │ ├── Command: string             │                                    │ │
│  │  │ ├── Language: string?           │                                    │ │
│  │  │ ├── Description: string?        │                                    │ │
│  │  │ └── WorkingDirectory: string?   │                                    │ │
│  │  ├─────────────────────────────────┤                                    │ │
│  │  │ Detection                       │                                    │ │
│  │  │ ├── DetectedShellType: ShellType?                                   │ │
│  │  │ ├── ConfidenceScore: float      │                                    │ │
│  │  │ ├── IsPotentiallyDangerous: bool│                                    │ │
│  │  │ └── DangerWarning: string?      │                                    │ │
│  │  ├─────────────────────────────────┤                                    │ │
│  │  │ Execution                       │                                    │ │
│  │  │ ├── Status: CommandBlockStatus  │                                    │ │
│  │  │ ├── ExecutedAt: DateTime?       │                                    │ │
│  │  │ ├── ExecutedInSessionId: Guid?  │                                    │ │
│  │  │ └── OutputCaptureId: Guid?      │                                    │ │
│  │  ├─────────────────────────────────┤                                    │ │
│  │  │ Source Mapping                  │                                    │ │
│  │  │ ├── SourceRange: TextRange      │                                    │ │
│  │  │ └── ExtractedAt: DateTime       │                                    │ │
│  │  ├─────────────────────────────────┤                                    │ │
│  │  │ Computed                        │                                    │ │
│  │  │ ├── IsMultiLine: bool           │                                    │ │
│  │  │ └── LineCount: int              │                                    │ │
│  │  └─────────────────────────────────┘                                    │ │
│  │                                                                          │ │
│  │  TerminalOutputCapture              OutputCaptureMode (enum)            │ │
│  │  ┌─────────────────────────────────┐ ├── FullBuffer                     │ │
│  │  │ Identity                        │ ├── LastCommand                    │ │
│  │  │ ├── Id: Guid                    │ ├── Selection                      │ │
│  │  │ ├── SessionId: Guid             │ ├── LastNLines                     │ │
│  │  │ ├── SessionName: string?        │ └── Manual                         │ │
│  │  │ └── CommandBlockId: Guid?       │                                    │ │
│  │  ├─────────────────────────────────┤                                    │ │
│  │  │ Content                         │                                    │ │
│  │  │ ├── Command: string?            │                                    │ │
│  │  │ ├── Output: string              │                                    │ │
│  │  │ ├── IsTruncated: bool           │                                    │ │
│  │  │ ├── OriginalLength: int         │                                    │ │
│  │  │ └── ExitCode: int?              │                                    │ │
│  │  ├─────────────────────────────────┤                                    │ │
│  │  │ Timing                          │                                    │ │
│  │  │ ├── StartedAt: DateTime         │                                    │ │
│  │  │ ├── CompletedAt: DateTime       │                                    │ │
│  │  │ └── Duration: TimeSpan          │                                    │ │
│  │  ├─────────────────────────────────┤                                    │ │
│  │  │ Context                         │                                    │ │
│  │  │ ├── WorkingDirectory: string?   │                                    │ │
│  │  │ ├── CaptureMode: OutputCaptureMode                                  │ │
│  │  │ └── EstimatedTokens: int        │                                    │ │
│  │  ├─────────────────────────────────┤                                    │ │
│  │  │ Methods                         │                                    │ │
│  │  │ └── ToContextString(): string   │                                    │ │
│  │  └─────────────────────────────────┘                                    │ │
│  │                                                                          │ │
│  │  CommandExtractionResult            TextRange (record struct)           │ │
│  │  ┌─────────────────────────────────┐ ├── Start: int                     │ │
│  │  │ ├── Commands: IReadOnlyList     │ ├── End: int                       │ │
│  │  │ ├── Warnings: IReadOnlyList     │ └── Length: int (computed)         │ │
│  │  │ ├── HasCommands: bool           │                                    │ │
│  │  │ ├── CommandCount: int           │                                    │ │
│  │  │ └── DangerousCommandCount: int  │                                    │ │
│  │  └─────────────────────────────────┘                                    │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Execution State Machine

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                      CommandBlockStatus State Transitions                     │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│                          ┌─────────────┐                                     │
│                          │   Pending   │ ← Initial state                     │
│                          └──────┬──────┘                                     │
│                                 │                                            │
│                    ┌────────────┼────────────┐                               │
│                    ▼            ▼            ▼                               │
│             ┌──────────┐  ┌───────────────┐  ┌─────────────┐                │
│             │  Copied  │  │ SentToTerminal│  │  Executing  │                │
│             └──────────┘  └───────┬───────┘  └──────┬──────┘                │
│                   │               │                  │                       │
│                   │               ▼                  │                       │
│                   │      ┌─────────────┐             │                       │
│                   └─────▶│  Executing  │◀────────────┘                       │
│                          └──────┬──────┘                                     │
│                                 │                                            │
│                    ┌────────────┼────────────┐                               │
│                    ▼            ▼            ▼                               │
│             ┌──────────┐  ┌──────────┐  ┌───────────┐                       │
│             │ Executed │  │  Failed  │  │ Cancelled │                       │
│             │ (exit=0) │  │ (exit≠0) │  │ (user)    │                       │
│             └──────────┘  └──────────┘  └───────────┘                       │
│                                                                              │
│  Legend:                                                                     │
│  • Pending → Copied:          User clicked "Copy" button                    │
│  • Pending → SentToTerminal:  User clicked "Send to Terminal" button        │
│  • Pending → Executing:       User clicked "Run" button (direct execution)  │
│  • SentToTerminal → Executing: User pressed Enter in terminal               │
│  • Copied → Executing:        User pasted and ran command                   │
│  • Executing → Executed:      Command completed with exit code 0            │
│  • Executing → Failed:        Command completed with non-zero exit code     │
│  • Executing → Cancelled:     User terminated the command                   │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Output Capture Flow

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                      Terminal Output Capture Flow                             │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  OutputCaptureMode determines what terminal content to capture:              │
│                                                                              │
│  ┌────────────────────┬────────────────────────────────────────────────────┐ │
│  │ Mode               │ Behavior                                           │ │
│  ├────────────────────┼────────────────────────────────────────────────────┤ │
│  │ FullBuffer         │ Capture entire visible scrollback buffer.          │ │
│  │                    │ Use for: "Show me all terminal output"             │ │
│  │                    │ Token impact: High (may need truncation)           │ │
│  ├────────────────────┼────────────────────────────────────────────────────┤ │
│  │ LastCommand        │ Capture output from most recent command only.      │ │
│  │                    │ Uses shell integration (OSC 133) or prompt         │ │
│  │                    │ detection to identify command boundaries.          │ │
│  │                    │ Use for: "Why did this command fail?"              │ │
│  │                    │ Token impact: Low to Medium                        │ │
│  ├────────────────────┼────────────────────────────────────────────────────┤ │
│  │ Selection          │ Capture user-selected text in terminal.            │ │
│  │                    │ Use for: "Explain this error message"              │ │
│  │                    │ Token impact: Varies                               │ │
│  ├────────────────────┼────────────────────────────────────────────────────┤ │
│  │ LastNLines         │ Capture last N lines of output.                    │ │
│  │                    │ Use for: "What happened recently?"                 │ │
│  │                    │ Token impact: Configurable                         │ │
│  ├────────────────────┼────────────────────────────────────────────────────┤ │
│  │ Manual             │ Capture between explicit start/end markers.        │ │
│  │                    │ Use for: Precise output boundaries                 │ │
│  │                    │ Token impact: Varies                               │ │
│  └────────────────────┴────────────────────────────────────────────────────┘ │
│                                                                              │
│  Truncation Strategy (when output exceeds token budget):                     │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  1. Keep first 20% of output (context/setup)                          │  │
│  │  2. Insert "[... N lines/chars truncated ...]"                        │  │
│  │  3. Keep last 60% of output (most recent/relevant)                    │  │
│  │  4. Preserve exit code and timing information                         │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Specifications

### 1. TextRange.cs

**Location**: `src/AIntern.Core/Models/Terminal/TextRange.cs`

```csharp
namespace AIntern.Core.Models.Terminal;

/// <summary>
/// Represents a character range within text content.
/// </summary>
/// <param name="Start">Starting character index (0-based, inclusive).</param>
/// <param name="End">Ending character index (0-based, exclusive).</param>
public readonly record struct TextRange(int Start, int End)
{
    /// <summary>
    /// Number of characters in this range.
    /// </summary>
    public int Length => End - Start;

    /// <summary>
    /// Whether this range is valid (non-negative length, non-negative indices).
    /// </summary>
    public bool IsValid => Start >= 0 && End >= Start;

    /// <summary>
    /// Extract the text content covered by this range.
    /// </summary>
    /// <param name="source">Source text to extract from.</param>
    /// <returns>Substring within this range, or empty if out of bounds.</returns>
    public string Extract(string source)
    {
        if (!IsValid || Start >= source.Length)
            return string.Empty;

        var actualEnd = Math.Min(End, source.Length);
        return source[Start..actualEnd];
    }

    /// <summary>
    /// Check if this range contains a specific index.
    /// </summary>
    public bool Contains(int index) => index >= Start && index < End;

    /// <summary>
    /// Check if this range overlaps with another range.
    /// </summary>
    public bool Overlaps(TextRange other) =>
        Start < other.End && End > other.Start;

    /// <summary>
    /// Return a new range offset by the specified amount.
    /// </summary>
    public TextRange Offset(int offset) => new(Start + offset, End + offset);

    public override string ToString() => $"[{Start}..{End}]";
}
```

### 2. CommandBlockStatus.cs

**Location**: `src/AIntern.Core/Models/Terminal/CommandBlockStatus.cs`

```csharp
namespace AIntern.Core.Models.Terminal;

/// <summary>
/// Execution status of a command block.
/// </summary>
public enum CommandBlockStatus
{
    /// <summary>Command has not been interacted with.</summary>
    Pending,

    /// <summary>Command was copied to clipboard.</summary>
    Copied,

    /// <summary>Command was sent to terminal input (awaiting Enter).</summary>
    SentToTerminal,

    /// <summary>Command is currently executing in the terminal.</summary>
    Executing,

    /// <summary>Command executed successfully (exit code 0).</summary>
    Executed,

    /// <summary>Command execution failed (non-zero exit code).</summary>
    Failed,

    /// <summary>Command execution was cancelled by user.</summary>
    Cancelled
}

/// <summary>
/// Extension methods for CommandBlockStatus.
/// </summary>
public static class CommandBlockStatusExtensions
{
    /// <summary>
    /// Check if the status represents a terminal state (no further transitions expected).
    /// </summary>
    public static bool IsTerminal(this CommandBlockStatus status) =>
        status is CommandBlockStatus.Executed
               or CommandBlockStatus.Failed
               or CommandBlockStatus.Cancelled;

    /// <summary>
    /// Check if the command has been executed or attempted.
    /// </summary>
    public static bool WasAttempted(this CommandBlockStatus status) =>
        status is CommandBlockStatus.Executing
               or CommandBlockStatus.Executed
               or CommandBlockStatus.Failed
               or CommandBlockStatus.Cancelled;

    /// <summary>
    /// Get a user-friendly display string.
    /// </summary>
    public static string ToDisplayString(this CommandBlockStatus status) => status switch
    {
        CommandBlockStatus.Pending => "Ready",
        CommandBlockStatus.Copied => "Copied",
        CommandBlockStatus.SentToTerminal => "In Terminal",
        CommandBlockStatus.Executing => "Running...",
        CommandBlockStatus.Executed => "Completed",
        CommandBlockStatus.Failed => "Failed",
        CommandBlockStatus.Cancelled => "Cancelled",
        _ => status.ToString()
    };

    /// <summary>
    /// Get the appropriate icon for this status.
    /// </summary>
    public static string ToIconName(this CommandBlockStatus status) => status switch
    {
        CommandBlockStatus.Pending => "PlayIcon",
        CommandBlockStatus.Copied => "ClipboardIcon",
        CommandBlockStatus.SentToTerminal => "TerminalIcon",
        CommandBlockStatus.Executing => "SpinnerIcon",
        CommandBlockStatus.Executed => "CheckIcon",
        CommandBlockStatus.Failed => "ErrorIcon",
        CommandBlockStatus.Cancelled => "CancelIcon",
        _ => "PlayIcon"
    };
}
```

### 3. OutputCaptureMode.cs

**Location**: `src/AIntern.Core/Models/Terminal/OutputCaptureMode.cs`

```csharp
namespace AIntern.Core.Models.Terminal;

/// <summary>
/// Mode of terminal output capture.
/// </summary>
public enum OutputCaptureMode
{
    /// <summary>Capture entire visible scrollback buffer.</summary>
    FullBuffer,

    /// <summary>Capture output from the most recent command only.</summary>
    LastCommand,

    /// <summary>Capture user-selected text only.</summary>
    Selection,

    /// <summary>Capture last N lines of output.</summary>
    LastNLines,

    /// <summary>Manual capture with explicit start/end markers.</summary>
    Manual
}

/// <summary>
/// Extension methods for OutputCaptureMode.
/// </summary>
public static class OutputCaptureModeExtensions
{
    /// <summary>
    /// Get a description suitable for UI display.
    /// </summary>
    public static string ToDescription(this OutputCaptureMode mode) => mode switch
    {
        OutputCaptureMode.FullBuffer => "Entire terminal buffer",
        OutputCaptureMode.LastCommand => "Last command output",
        OutputCaptureMode.Selection => "Selected text",
        OutputCaptureMode.LastNLines => "Last N lines",
        OutputCaptureMode.Manual => "Manual selection",
        _ => mode.ToString()
    };

    /// <summary>
    /// Get the default maximum characters for this mode.
    /// </summary>
    public static int GetDefaultMaxCharacters(this OutputCaptureMode mode) => mode switch
    {
        OutputCaptureMode.FullBuffer => 50000,
        OutputCaptureMode.LastCommand => 20000,
        OutputCaptureMode.Selection => 10000,
        OutputCaptureMode.LastNLines => 10000,
        OutputCaptureMode.Manual => 50000,
        _ => 20000
    };
}
```

### 4. CommandBlock.cs

**Location**: `src/AIntern.Core/Models/Terminal/CommandBlock.cs`

```csharp
namespace AIntern.Core.Models.Terminal;

using System.Text.Json.Serialization;

/// <summary>
/// Represents an executable command extracted from an AI response.
/// </summary>
public sealed class CommandBlock
{
    // === Identity ===

    /// <summary>Unique identifier for this command block.</summary>
    public Guid Id { get; init; } = Guid.NewGuid();

    /// <summary>ID of the message containing this command.</summary>
    public Guid MessageId { get; init; }

    /// <summary>Position of this command within the message (0-based).</summary>
    public int SequenceNumber { get; init; }

    // === Content ===

    /// <summary>The command text to execute.</summary>
    public string Command { get; init; } = string.Empty;

    /// <summary>Language/shell identifier from the code fence (bash, powershell, etc.).</summary>
    public string? Language { get; init; }

    /// <summary>Description of what the command does (extracted from surrounding text).</summary>
    public string? Description { get; init; }

    /// <summary>Suggested working directory for this command (if mentioned in context).</summary>
    public string? WorkingDirectory { get; init; }

    // === Detection ===

    /// <summary>Detected shell type based on language.</summary>
    public ShellType? DetectedShellType { get; init; }

    /// <summary>Confidence score for command detection (0.0 to 1.0).</summary>
    public float ConfidenceScore { get; init; } = 1.0f;

    /// <summary>Whether this command appears to be dangerous (rm -rf, format, etc.).</summary>
    public bool IsPotentiallyDangerous { get; init; }

    /// <summary>Warning message if command is potentially dangerous.</summary>
    public string? DangerWarning { get; init; }

    // === Execution ===

    /// <summary>Current execution status.</summary>
    public CommandBlockStatus Status { get; set; } = CommandBlockStatus.Pending;

    /// <summary>Timestamp when this command was last executed (if any).</summary>
    public DateTime? ExecutedAt { get; set; }

    /// <summary>ID of the terminal session where this was executed.</summary>
    public Guid? ExecutedInSessionId { get; set; }

    /// <summary>Associated output capture (if output was captured).</summary>
    public Guid? OutputCaptureId { get; set; }

    // === Source Mapping ===

    /// <summary>Character range in the original message content.</summary>
    public TextRange SourceRange { get; init; }

    /// <summary>Timestamp when this command was extracted.</summary>
    public DateTime ExtractedAt { get; init; } = DateTime.UtcNow;

    // === Computed Properties ===

    /// <summary>Whether this command spans multiple lines.</summary>
    [JsonIgnore]
    public bool IsMultiLine => Command.Contains('\n');

    /// <summary>Number of lines in the command.</summary>
    [JsonIgnore]
    public int LineCount => Command.Split('\n').Length;

    /// <summary>Just the first line for display in compact views.</summary>
    [JsonIgnore]
    public string FirstLine => Command.Split('\n')[0];

    /// <summary>Whether the command has completed (succeeded, failed, or cancelled).</summary>
    [JsonIgnore]
    public bool IsCompleted => Status.IsTerminal();

    /// <summary>Whether the command can be run (not currently running or completed).</summary>
    [JsonIgnore]
    public bool CanRun => Status is CommandBlockStatus.Pending
                               or CommandBlockStatus.Copied
                               or CommandBlockStatus.SentToTerminal;

    // === Methods ===

    /// <summary>
    /// Create a display-friendly summary of this command.
    /// </summary>
    public string ToDisplaySummary()
    {
        var summary = LineCount > 1
            ? $"{FirstLine} (+{LineCount - 1} more lines)"
            : Command;

        if (summary.Length > 60)
            summary = summary[..57] + "...";

        return summary;
    }

    /// <summary>
    /// Mark this command as copied to clipboard.
    /// </summary>
    public void MarkCopied()
    {
        if (Status == CommandBlockStatus.Pending)
            Status = CommandBlockStatus.Copied;
    }

    /// <summary>
    /// Mark this command as sent to terminal.
    /// </summary>
    public void MarkSentToTerminal(Guid sessionId)
    {
        Status = CommandBlockStatus.SentToTerminal;
        ExecutedInSessionId = sessionId;
    }

    /// <summary>
    /// Mark this command as currently executing.
    /// </summary>
    public void MarkExecuting(Guid sessionId)
    {
        Status = CommandBlockStatus.Executing;
        ExecutedInSessionId = sessionId;
        ExecutedAt = DateTime.UtcNow;
    }

    /// <summary>
    /// Mark this command as completed with the given exit code.
    /// </summary>
    public void MarkCompleted(int exitCode, Guid? outputCaptureId = null)
    {
        Status = exitCode == 0
            ? CommandBlockStatus.Executed
            : CommandBlockStatus.Failed;
        OutputCaptureId = outputCaptureId;
    }

    /// <summary>
    /// Mark this command as cancelled.
    /// </summary>
    public void MarkCancelled()
    {
        Status = CommandBlockStatus.Cancelled;
    }
}
```

### 5. TerminalOutputCapture.cs

**Location**: `src/AIntern.Core/Models/Terminal/TerminalOutputCapture.cs`

```csharp
namespace AIntern.Core.Models.Terminal;

using System.Text;
using System.Text.Json.Serialization;

/// <summary>
/// Captured output from a terminal session for AI context.
/// </summary>
public sealed class TerminalOutputCapture
{
    // === Identity ===

    /// <summary>Unique identifier for this capture.</summary>
    public Guid Id { get; init; } = Guid.NewGuid();

    /// <summary>ID of the terminal session this was captured from.</summary>
    public Guid SessionId { get; init; }

    /// <summary>Name of the terminal session.</summary>
    public string? SessionName { get; init; }

    /// <summary>ID of the CommandBlock that triggered this capture (if any).</summary>
    public Guid? CommandBlockId { get; init; }

    // === Content ===

    /// <summary>The command that was executed (if known).</summary>
    public string? Command { get; init; }

    /// <summary>Captured output text.</summary>
    public string Output { get; init; } = string.Empty;

    /// <summary>Whether the output was truncated.</summary>
    public bool IsTruncated { get; init; }

    /// <summary>Original output length before truncation.</summary>
    public int OriginalLength { get; init; }

    /// <summary>Exit code of the command (if available).</summary>
    public int? ExitCode { get; init; }

    // === Timing ===

    /// <summary>When the capture started.</summary>
    public DateTime StartedAt { get; init; }

    /// <summary>When the capture completed.</summary>
    public DateTime CompletedAt { get; init; }

    /// <summary>Duration of the capture.</summary>
    [JsonIgnore]
    public TimeSpan Duration => CompletedAt - StartedAt;

    // === Context ===

    /// <summary>Working directory at time of capture.</summary>
    public string? WorkingDirectory { get; init; }

    /// <summary>Capture mode used.</summary>
    public OutputCaptureMode CaptureMode { get; init; }

    // === Computed Properties ===

    /// <summary>Estimated token count for LLM context (~4 chars per token).</summary>
    [JsonIgnore]
    public int EstimatedTokens => (Output.Length + (Command?.Length ?? 0) + 50) / 4;

    /// <summary>Whether the command succeeded (exit code 0 or unknown).</summary>
    [JsonIgnore]
    public bool IsSuccess => !ExitCode.HasValue || ExitCode.Value == 0;

    /// <summary>Number of lines in the output.</summary>
    [JsonIgnore]
    public int LineCount => Output.Split('\n').Length;

    // === Methods ===

    /// <summary>
    /// Format the capture for inclusion in AI context.
    /// </summary>
    public string ToContextString()
    {
        var sb = new StringBuilder();

        sb.AppendLine("```terminal");

        if (!string.IsNullOrEmpty(WorkingDirectory))
        {
            sb.AppendLine($"# Directory: {WorkingDirectory}");
        }

        if (!string.IsNullOrEmpty(Command))
        {
            sb.AppendLine($"$ {Command}");
        }

        sb.AppendLine(Output);

        if (ExitCode.HasValue)
        {
            sb.AppendLine($"# Exit code: {ExitCode.Value}");
        }

        if (IsTruncated)
        {
            sb.AppendLine($"# (Output truncated from {OriginalLength:N0} characters)");
        }

        sb.AppendLine("```");

        return sb.ToString();
    }

    /// <summary>
    /// Create a compact summary for display.
    /// </summary>
    public string ToSummary()
    {
        var lines = Output.Split('\n');
        var preview = lines.Length > 3
            ? $"{lines[0]}\n{lines[1]}\n... ({lines.Length - 2} more lines)"
            : Output;

        if (preview.Length > 200)
            preview = preview[..197] + "...";

        return preview;
    }

    /// <summary>
    /// Truncate output to fit within a character limit.
    /// </summary>
    /// <param name="maxCharacters">Maximum characters to keep.</param>
    /// <returns>New TerminalOutputCapture with truncated output.</returns>
    public TerminalOutputCapture Truncate(int maxCharacters)
    {
        if (Output.Length <= maxCharacters)
            return this;

        // Keep first 20% and last 60%, with ellipsis in middle
        var firstPart = (int)(maxCharacters * 0.2);
        var lastPart = (int)(maxCharacters * 0.6);
        var ellipsis = $"\n\n[... {Output.Length - firstPart - lastPart:N0} characters truncated ...]\n\n";

        var truncated = Output[..firstPart] + ellipsis + Output[^lastPart..];

        return new TerminalOutputCapture
        {
            Id = Id,
            SessionId = SessionId,
            SessionName = SessionName,
            CommandBlockId = CommandBlockId,
            Command = Command,
            Output = truncated,
            IsTruncated = true,
            OriginalLength = Output.Length,
            ExitCode = ExitCode,
            StartedAt = StartedAt,
            CompletedAt = CompletedAt,
            WorkingDirectory = WorkingDirectory,
            CaptureMode = CaptureMode
        };
    }
}
```

### 6. CommandExtractionResult.cs

**Location**: `src/AIntern.Core/Models/Terminal/CommandExtractionResult.cs`

```csharp
namespace AIntern.Core.Models.Terminal;

/// <summary>
/// Result of extracting commands from a message.
/// </summary>
public sealed class CommandExtractionResult
{
    /// <summary>Extracted command blocks, ordered by sequence number.</summary>
    public IReadOnlyList<CommandBlock> Commands { get; init; } = Array.Empty<CommandBlock>();

    /// <summary>Warnings generated during extraction.</summary>
    public IReadOnlyList<string> Warnings { get; init; } = Array.Empty<string>();

    // === Computed Properties ===

    /// <summary>Whether any commands were found.</summary>
    public bool HasCommands => Commands.Count > 0;

    /// <summary>Total number of commands found.</summary>
    public int CommandCount => Commands.Count;

    /// <summary>Number of potentially dangerous commands.</summary>
    public int DangerousCommandCount => Commands.Count(c => c.IsPotentiallyDangerous);

    /// <summary>Whether any dangerous commands were detected.</summary>
    public bool HasDangerousCommands => DangerousCommandCount > 0;

    /// <summary>Whether there are warnings to display.</summary>
    public bool HasWarnings => Warnings.Count > 0;

    /// <summary>All unique shell types detected in commands.</summary>
    public IEnumerable<ShellType> DetectedShellTypes =>
        Commands
            .Where(c => c.DetectedShellType.HasValue)
            .Select(c => c.DetectedShellType!.Value)
            .Distinct();

    // === Factory Methods ===

    /// <summary>
    /// Create an empty result (no commands found).
    /// </summary>
    public static CommandExtractionResult Empty { get; } = new();

    /// <summary>
    /// Create a result with a single command.
    /// </summary>
    public static CommandExtractionResult Single(CommandBlock command) =>
        new() { Commands = new[] { command } };
}
```

---

## File Summary

| File | Location | Purpose |
|------|----------|---------|
| `TextRange.cs` | `src/AIntern.Core/Models/Terminal/` | Text character range struct |
| `CommandBlockStatus.cs` | `src/AIntern.Core/Models/Terminal/` | Execution status enum + extensions |
| `OutputCaptureMode.cs` | `src/AIntern.Core/Models/Terminal/` | Capture mode enum + extensions |
| `CommandBlock.cs` | `src/AIntern.Core/Models/Terminal/` | Main command block model |
| `TerminalOutputCapture.cs` | `src/AIntern.Core/Models/Terminal/` | Output capture model |
| `CommandExtractionResult.cs` | `src/AIntern.Core/Models/Terminal/` | Extraction result container |

---

## Unit Test Plan

| Test | Description |
|------|-------------|
| `TextRange_Length_CalculatesCorrectly` | End - Start = Length |
| `TextRange_IsValid_RejectsNegativeStart` | Start < 0 is invalid |
| `TextRange_IsValid_RejectsEndBeforeStart` | End < Start is invalid |
| `TextRange_Extract_ReturnsSubstring` | Extracts correct text |
| `TextRange_Extract_ClampsToLength` | Handles out-of-bounds End |
| `TextRange_Contains_ChecksRangeCorrectly` | Index inside/outside |
| `TextRange_Overlaps_DetectsOverlap` | Two overlapping ranges |
| `CommandBlockStatus_IsTerminal_IdentifiesFinalStates` | Executed, Failed, Cancelled |
| `CommandBlockStatus_WasAttempted_ExcludesPending` | Only running/complete |
| `CommandBlockStatus_ToDisplayString_ReturnsUserFriendly` | Human-readable text |
| `CommandBlock_IsMultiLine_DetectsNewlines` | Contains \n |
| `CommandBlock_LineCount_CountsLines` | Split on \n |
| `CommandBlock_CanRun_AllowsNonExecuting` | Pending, Copied, SentToTerminal |
| `CommandBlock_MarkCompleted_SetsStatus` | Exit 0 → Executed |
| `CommandBlock_MarkCompleted_SetsFailedOnNonZero` | Exit ≠0 → Failed |
| `CommandBlock_ToDisplaySummary_TruncatesLong` | 60+ char truncation |
| `TerminalOutputCapture_EstimatedTokens_Calculates` | (chars + 50) / 4 |
| `TerminalOutputCapture_ToContextString_FormatsCorrectly` | Markdown code block |
| `TerminalOutputCapture_Truncate_KeepsFirstAndLast` | 20%/60% preservation |
| `TerminalOutputCapture_Duration_CalculatesSpan` | CompletedAt - StartedAt |
| `CommandExtractionResult_HasCommands_DetectsEmpty` | Empty → false |
| `CommandExtractionResult_DangerousCommandCount_CountsCorrectly` | Filters IsPotentiallyDangerous |
| `CommandExtractionResult_DetectedShellTypes_ReturnsDistinct` | No duplicates |

**Total Tests**: 23

---

## Verification

```bash
# Verify models compile
dotnet build src/AIntern.Core

# Run unit tests
dotnet test --filter "CommandBlock"
dotnet test --filter "TerminalOutputCapture"
dotnet test --filter "TextRange"

# Verify JSON serialization
dotnet test --filter "Serialization"
```

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | All models compile without errors |
| AC-2 | TextRange correctly calculates Length |
| AC-3 | TextRange.Extract returns correct substring |
| AC-4 | CommandBlockStatus.IsTerminal identifies final states |
| AC-5 | CommandBlock.Status transitions work correctly |
| AC-6 | CommandBlock.MarkCompleted sets appropriate status |
| AC-7 | TerminalOutputCapture.ToContextString produces markdown |
| AC-8 | TerminalOutputCapture.Truncate preserves first/last portions |
| AC-9 | EstimatedTokens calculation is reasonable |
| AC-10 | All models serialize/deserialize with System.Text.Json |
| AC-11 | CommandExtractionResult aggregates correctly |

---

## Changelog Entry

```markdown
## v0.5.4a - Command Block Models

### Added
- `TextRange` record struct with:
  - Start, End, Length properties
  - Extract(), Contains(), Overlaps() methods
  - IsValid validation

- `CommandBlockStatus` enumeration with:
  - States: Pending, Copied, SentToTerminal, Executing, Executed, Failed, Cancelled
  - Extension methods: IsTerminal(), WasAttempted(), ToDisplayString(), ToIconName()

- `OutputCaptureMode` enumeration with:
  - Modes: FullBuffer, LastCommand, Selection, LastNLines, Manual
  - Extension methods: ToDescription(), GetDefaultMaxCharacters()

- `CommandBlock` model with:
  - Identity: Id, MessageId, SequenceNumber
  - Content: Command, Language, Description, WorkingDirectory
  - Detection: DetectedShellType, ConfidenceScore, IsPotentiallyDangerous, DangerWarning
  - Execution: Status, ExecutedAt, ExecutedInSessionId, OutputCaptureId
  - Source mapping: SourceRange (TextRange), ExtractedAt
  - Computed: IsMultiLine, LineCount, FirstLine, IsCompleted, CanRun
  - Methods: MarkCopied(), MarkSentToTerminal(), MarkExecuting(), MarkCompleted(), MarkCancelled()

- `TerminalOutputCapture` model with:
  - Identity: Id, SessionId, SessionName, CommandBlockId
  - Content: Command, Output, IsTruncated, OriginalLength, ExitCode
  - Timing: StartedAt, CompletedAt, Duration
  - Context: WorkingDirectory, CaptureMode
  - Computed: EstimatedTokens, IsSuccess, LineCount
  - Methods: ToContextString(), ToSummary(), Truncate()

- `CommandExtractionResult` container with:
  - Commands, Warnings collections
  - Computed: HasCommands, CommandCount, DangerousCommandCount, DetectedShellTypes
```

---

## Timeline Estimate

| Version | Estimated Effort |
|---------|------------------|
| v0.5.4a | 0.5 day |
