# Design Specification: AIntern v0.5.4 "Command Integration"

## Executive Summary

This document provides a comprehensive design specification for v0.5.4, which enables seamless integration between AI-generated commands and the integrated terminal. This sub-version implements command extraction from chat messages, "Copy to Terminal" / "Run" actions, terminal output capture for AI context, and command execution tracking. This layer connects the conversational AI interface with the terminal subsystem, enabling users to execute AI suggestions with a single click and share terminal output for debugging assistance.

### v0.5.4 Scope (from v0.5.0 Design Document)
- Copy-to-terminal functionality for AI-generated commands
- Command extraction from chat messages (fenced code blocks + heuristics)
- Output capture for including terminal results in AI context
- Command execution status tracking
- Shell-aware command handling

---

## Sub-Part Breakdown

| Part | Name | Focus |
|------|------|-------|
| v0.5.4a | Command Block Models | CommandBlock, CommandBlockStatus, TerminalOutputCapture models |
| v0.5.4b | Command Extractor Service | Parse commands from markdown, language detection, shell matching |
| v0.5.4c | Command Execution Service | Send to terminal, execute, track status, capture output |
| v0.5.4d | Output Capture System | Capture terminal output, associate with commands, truncation |
| v0.5.4e | Command Block ViewModel | UI logic for copy/send/run actions, status display |
| v0.5.4f | Command Block UI | XAML control for rendering commands in chat |
| v0.5.4g | Terminal Context Attachment | Attach terminal output to chat context, token management |
| v0.5.4h | Chat Integration | Message parsing, context bar updates, keyboard shortcuts |

---

## v0.5.4a: Command Block Models

### Objective
Define the core data models for representing executable commands extracted from AI responses, their execution status, and captured terminal output.

### CommandBlock Model

```csharp
namespace SeniorIntern.Core.Models.Terminal;

/// <summary>
/// Represents an executable command extracted from an AI response
/// </summary>
public sealed class CommandBlock
{
    /// <summary>
    /// Unique identifier for this command block
    /// </summary>
    public Guid Id { get; init; } = Guid.NewGuid();

    /// <summary>
    /// The command text to execute
    /// </summary>
    public string Command { get; init; } = string.Empty;

    /// <summary>
    /// Language/shell identifier from the code fence (bash, powershell, etc.)
    /// </summary>
    public string? Language { get; init; }

    /// <summary>
    /// Detected shell type based on language
    /// </summary>
    public ShellType? DetectedShellType { get; init; }

    /// <summary>
    /// Suggested working directory for this command (if mentioned in context)
    /// </summary>
    public string? WorkingDirectory { get; init; }

    /// <summary>
    /// Description of what the command does (extracted from surrounding text)
    /// </summary>
    public string? Description { get; init; }

    /// <summary>
    /// ID of the message containing this command
    /// </summary>
    public Guid MessageId { get; init; }

    /// <summary>
    /// Position of this command within the message (0-based)
    /// </summary>
    public int SequenceNumber { get; init; }

    /// <summary>
    /// Current execution status
    /// </summary>
    public CommandBlockStatus Status { get; set; } = CommandBlockStatus.Pending;

    /// <summary>
    /// Character range in the original message content
    /// </summary>
    public TextRange SourceRange { get; init; }

    /// <summary>
    /// Whether this command spans multiple lines
    /// </summary>
    public bool IsMultiLine => Command.Contains('\n');

    /// <summary>
    /// Number of lines in the command
    /// </summary>
    public int LineCount => Command.Split('\n').Length;

    /// <summary>
    /// Timestamp when this command was extracted
    /// </summary>
    public DateTime ExtractedAt { get; init; } = DateTime.UtcNow;

    /// <summary>
    /// Timestamp when this command was last executed (if any)
    /// </summary>
    public DateTime? ExecutedAt { get; set; }

    /// <summary>
    /// ID of the terminal session where this was executed
    /// </summary>
    public Guid? ExecutedInSessionId { get; set; }

    /// <summary>
    /// Associated output capture (if output was captured)
    /// </summary>
    public Guid? OutputCaptureId { get; set; }

    /// <summary>
    /// Whether this command appears to be dangerous (rm -rf, format, etc.)
    /// </summary>
    public bool IsPotentiallyDangerous { get; init; }

    /// <summary>
    /// Warning message if command is potentially dangerous
    /// </summary>
    public string? DangerWarning { get; init; }

    /// <summary>
    /// Confidence score for command detection (0.0 to 1.0)
    /// </summary>
    public float ConfidenceScore { get; init; } = 1.0f;
}

/// <summary>
/// Text range within a message
/// </summary>
public readonly record struct TextRange(int Start, int End)
{
    public int Length => End - Start;
}
```

### CommandBlockStatus Enumeration

```csharp
namespace SeniorIntern.Core.Models.Terminal;

/// <summary>
/// Status of a command block in the execution workflow
/// </summary>
public enum CommandBlockStatus
{
    /// <summary>
    /// Command has not been interacted with
    /// </summary>
    Pending,

    /// <summary>
    /// Command was copied to clipboard
    /// </summary>
    Copied,

    /// <summary>
    /// Command was sent to terminal (but not executed)
    /// </summary>
    SentToTerminal,

    /// <summary>
    /// Command is currently executing
    /// </summary>
    Executing,

    /// <summary>
    /// Command executed successfully (exit code 0 or no exit code available)
    /// </summary>
    Executed,

    /// <summary>
    /// Command execution failed (non-zero exit code)
    /// </summary>
    Failed,

    /// <summary>
    /// Command execution was cancelled
    /// </summary>
    Cancelled
}
```

### TerminalOutputCapture Model

```csharp
namespace SeniorIntern.Core.Models.Terminal;

/// <summary>
/// Captured output from a terminal session for AI context
/// </summary>
public sealed class TerminalOutputCapture
{
    /// <summary>
    /// Unique identifier for this capture
    /// </summary>
    public Guid Id { get; init; } = Guid.NewGuid();

    /// <summary>
    /// ID of the terminal session this was captured from
    /// </summary>
    public Guid SessionId { get; init; }

    /// <summary>
    /// Name of the terminal session
    /// </summary>
    public string? SessionName { get; init; }

    /// <summary>
    /// The command that was executed (if known)
    /// </summary>
    public string? Command { get; init; }

    /// <summary>
    /// ID of the CommandBlock that triggered this capture (if any)
    /// </summary>
    public Guid? CommandBlockId { get; init; }

    /// <summary>
    /// Captured output text
    /// </summary>
    public string Output { get; init; } = string.Empty;

    /// <summary>
    /// Whether the output was truncated
    /// </summary>
    public bool IsTruncated { get; init; }

    /// <summary>
    /// Original output length before truncation
    /// </summary>
    public int OriginalLength { get; init; }

    /// <summary>
    /// Exit code of the command (if available)
    /// </summary>
    public int? ExitCode { get; init; }

    /// <summary>
    /// When the capture started
    /// </summary>
    public DateTime StartedAt { get; init; }

    /// <summary>
    /// When the capture completed
    /// </summary>
    public DateTime CompletedAt { get; init; }

    /// <summary>
    /// Duration of the capture
    /// </summary>
    public TimeSpan Duration => CompletedAt - StartedAt;

    /// <summary>
    /// Working directory at time of capture
    /// </summary>
    public string? WorkingDirectory { get; init; }

    /// <summary>
    /// Capture mode used
    /// </summary>
    public OutputCaptureMode CaptureMode { get; init; }

    /// <summary>
    /// Estimated token count for LLM context
    /// </summary>
    public int EstimatedTokens => (Output.Length + (Command?.Length ?? 0)) / 4;

    /// <summary>
    /// Format the capture for inclusion in AI context
    /// </summary>
    public string ToContextString()
    {
        var sb = new StringBuilder();

        if (!string.IsNullOrEmpty(WorkingDirectory))
        {
            sb.AppendLine($"Directory: {WorkingDirectory}");
        }

        if (!string.IsNullOrEmpty(Command))
        {
            sb.AppendLine($"$ {Command}");
        }

        sb.AppendLine(Output);

        if (ExitCode.HasValue)
        {
            sb.AppendLine($"Exit code: {ExitCode.Value}");
        }

        if (IsTruncated)
        {
            sb.AppendLine($"(Output truncated from {OriginalLength} characters)");
        }

        return sb.ToString();
    }
}

/// <summary>
/// Mode of output capture
/// </summary>
public enum OutputCaptureMode
{
    /// <summary>
    /// Capture entire visible buffer
    /// </summary>
    FullBuffer,

    /// <summary>
    /// Capture from last command prompt
    /// </summary>
    LastCommand,

    /// <summary>
    /// Capture selected text only
    /// </summary>
    Selection,

    /// <summary>
    /// Capture last N lines
    /// </summary>
    LastNLines,

    /// <summary>
    /// Manual capture with markers
    /// </summary>
    Manual
}
```

### CommandExtractionResult Model

```csharp
namespace SeniorIntern.Core.Models.Terminal;

/// <summary>
/// Result of extracting commands from a message
/// </summary>
public sealed class CommandExtractionResult
{
    /// <summary>
    /// Extracted command blocks
    /// </summary>
    public IReadOnlyList<CommandBlock> Commands { get; init; } = Array.Empty<CommandBlock>();

    /// <summary>
    /// Whether any commands were found
    /// </summary>
    public bool HasCommands => Commands.Count > 0;

    /// <summary>
    /// Total number of commands found
    /// </summary>
    public int CommandCount => Commands.Count;

    /// <summary>
    /// Number of potentially dangerous commands
    /// </summary>
    public int DangerousCommandCount => Commands.Count(c => c.IsPotentiallyDangerous);

    /// <summary>
    /// Any warnings generated during extraction
    /// </summary>
    public IReadOnlyList<string> Warnings { get; init; } = Array.Empty<string>();
}
```

### v0.5.4a Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Models/Terminal/CommandBlock.cs` | Command block model |
| `src/SeniorIntern.Core/Models/Terminal/CommandBlockStatus.cs` | Status enumeration |
| `src/SeniorIntern.Core/Models/Terminal/TerminalOutputCapture.cs` | Output capture model |
| `src/SeniorIntern.Core/Models/Terminal/OutputCaptureMode.cs` | Capture mode enum |
| `src/SeniorIntern.Core/Models/Terminal/CommandExtractionResult.cs` | Extraction result |
| `src/SeniorIntern.Core/Models/Terminal/TextRange.cs` | Text range struct |

### v0.5.4a Verification

```bash
# Verify models compile
dotnet build src/SeniorIntern.Core

# Verify serialization
dotnet test --filter "CommandBlockSerialization"
```

### v0.5.4a Acceptance Criteria

- [ ] All models compile without errors
- [ ] Models serialize/deserialize correctly with System.Text.Json
- [ ] TextRange correctly calculates Length
- [ ] TerminalOutputCapture.ToContextString() produces valid output
- [ ] EstimatedTokens calculation is reasonable

---

## v0.5.4b: Command Extractor Service

### Objective
Create a service that parses AI responses to identify executable commands, detect their shell type, extract descriptions, and flag potentially dangerous operations.

### ICommandExtractorService Interface

```csharp
namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Service for extracting executable commands from AI responses
/// </summary>
public interface ICommandExtractorService
{
    /// <summary>
    /// Extract all command blocks from message content
    /// </summary>
    /// <param name="content">The message content to parse</param>
    /// <param name="messageId">ID of the source message</param>
    /// <returns>Extraction result with commands and warnings</returns>
    CommandExtractionResult ExtractCommands(string content, Guid messageId);

    /// <summary>
    /// Determine if a code block represents a shell command
    /// </summary>
    /// <param name="language">Language identifier from code fence</param>
    /// <param name="content">Content of the code block</param>
    /// <returns>True if this appears to be an executable command</returns>
    bool IsShellCommand(string? language, string content);

    /// <summary>
    /// Get the appropriate shell type for a language identifier
    /// </summary>
    /// <param name="language">Language identifier (bash, powershell, etc.)</param>
    /// <returns>Shell type or null if not a shell language</returns>
    ShellType? GetShellTypeForLanguage(string? language);

    /// <summary>
    /// Check if a command is potentially dangerous
    /// </summary>
    /// <param name="command">The command to check</param>
    /// <returns>Tuple of (isDangerous, warningMessage)</returns>
    (bool IsDangerous, string? Warning) CheckCommandSafety(string command);

    /// <summary>
    /// Extract a description for a command from surrounding context
    /// </summary>
    /// <param name="content">Full message content</param>
    /// <param name="commandPosition">Position of the command in content</param>
    /// <returns>Description or null</returns>
    string? ExtractDescription(string content, int commandPosition);
}
```

### CommandExtractorService Implementation

```csharp
namespace SeniorIntern.Services.Terminal;

using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models.Terminal;
using System.Text.RegularExpressions;

/// <summary>
/// Extracts executable commands from AI-generated content
/// </summary>
public sealed partial class CommandExtractorService : ICommandExtractorService
{
    private readonly ILogger<CommandExtractorService> _logger;

    // Language identifiers that indicate shell commands
    private static readonly HashSet<string> ShellLanguages = new(StringComparer.OrdinalIgnoreCase)
    {
        // Unix shells
        "bash", "sh", "shell", "zsh", "fish", "ksh", "csh", "tcsh",
        // Windows shells
        "powershell", "pwsh", "ps1", "ps",
        "cmd", "batch", "bat", "dos",
        // Generic
        "console", "terminal", "command", "cli"
    };

    // Common executable commands that indicate shell usage
    private static readonly HashSet<string> CommonCommands = new(StringComparer.OrdinalIgnoreCase)
    {
        // Package managers
        "npm", "yarn", "pnpm", "npx", "bun",
        "pip", "pip3", "pipx", "poetry", "conda",
        "gem", "bundle", "bundler",
        "cargo", "rustup",
        "go", "gofmt",
        "dotnet", "nuget",
        "composer", "php",
        "brew", "apt", "apt-get", "yum", "dnf", "pacman", "apk", "zypper",
        "choco", "scoop", "winget",

        // Version control
        "git", "gh", "hub", "svn", "hg",

        // Containers & orchestration
        "docker", "docker-compose", "podman",
        "kubectl", "helm", "minikube", "kind",
        "terraform", "pulumi", "ansible",

        // Build tools
        "make", "cmake", "ninja", "meson",
        "gradle", "mvn", "maven", "ant",
        "msbuild", "xcodebuild",

        // File operations
        "cd", "ls", "dir", "mkdir", "rm", "cp", "mv", "cat", "less", "more",
        "touch", "chmod", "chown", "ln", "find", "grep", "sed", "awk",
        "tar", "zip", "unzip", "gzip", "gunzip",

        // Network
        "curl", "wget", "ssh", "scp", "rsync", "ping", "nc", "netcat",
        "http", "https",

        // Misc utilities
        "echo", "printf", "export", "set", "env", "source",
        "sudo", "su", "doas",
        "systemctl", "service", "launchctl",
        "code", "vim", "nano", "emacs",
        "python", "python3", "node", "ruby", "perl"
    };

    // Dangerous command patterns
    private static readonly (Regex Pattern, string Warning)[] DangerousPatterns =
    {
        (RmRfPattern(), "This command recursively deletes files. Verify the path carefully."),
        (FormatPattern(), "This command formats a disk. This is destructive."),
        (DdPattern(), "dd can overwrite disk data. Verify source and destination."),
        (ChmodRecursivePattern(), "Recursive permission changes can affect many files."),
        (SudoRmPattern(), "Elevated deletion command. Be very careful."),
        (DropDatabasePattern(), "This will delete a database permanently."),
        (TruncatePattern(), "This truncates/empties files."),
        (MkfsPattern(), "This creates a filesystem, erasing existing data."),
        (KillAllPattern(), "This terminates multiple processes."),
        (RebootPattern(), "This will restart the system."),
        (ForkBombPattern(), "This appears to be a fork bomb. Do not run."),
        (CurlPipeShPattern(), "Piping curl to shell can be dangerous. Review the script first."),
    };

    [GeneratedRegex(@"\brm\s+(-[rf]+\s+)*(/|~|\$HOME|\.\.)", RegexOptions.IgnoreCase)]
    private static partial Regex RmRfPattern();

    [GeneratedRegex(@"\bformat\s+[a-z]:", RegexOptions.IgnoreCase)]
    private static partial Regex FormatPattern();

    [GeneratedRegex(@"\bdd\s+.*\bof=", RegexOptions.IgnoreCase)]
    private static partial Regex DdPattern();

    [GeneratedRegex(@"\bchmod\s+-[Rr]", RegexOptions.IgnoreCase)]
    private static partial Regex ChmodRecursivePattern();

    [GeneratedRegex(@"\bsudo\s+rm\b", RegexOptions.IgnoreCase)]
    private static partial Regex SudoRmPattern();

    [GeneratedRegex(@"\bDROP\s+(DATABASE|TABLE|SCHEMA)\b", RegexOptions.IgnoreCase)]
    private static partial Regex DropDatabasePattern();

    [GeneratedRegex(@">\s*/dev/null|>\s*\$\(|truncate\s+-s\s*0", RegexOptions.IgnoreCase)]
    private static partial Regex TruncatePattern();

    [GeneratedRegex(@"\bmkfs\.", RegexOptions.IgnoreCase)]
    private static partial Regex MkfsPattern();

    [GeneratedRegex(@"\bkillall\b|\bpkill\b", RegexOptions.IgnoreCase)]
    private static partial Regex KillAllPattern();

    [GeneratedRegex(@"\b(reboot|shutdown|halt|poweroff)\b", RegexOptions.IgnoreCase)]
    private static partial Regex RebootPattern();

    [GeneratedRegex(@":\(\)\s*\{\s*:\|:&\s*\};:", RegexOptions.None)]
    private static partial Regex ForkBombPattern();

    [GeneratedRegex(@"curl\s+.*\|\s*(ba)?sh", RegexOptions.IgnoreCase)]
    private static partial Regex CurlPipeShPattern();

    // Regex for fenced code blocks: ```language\ncontent```
    [GeneratedRegex(@"```(?<lang>\w+)?\r?\n(?<content>[\s\S]*?)```", RegexOptions.Compiled)]
    private static partial Regex FencedCodeBlockPattern();

    // Regex for inline code that looks like commands
    [GeneratedRegex(@"`(?<cmd>[^`\n]+)`", RegexOptions.Compiled)]
    private static partial Regex InlineCodePattern();

    // Command indicator phrases
    private static readonly string[] CommandIndicators =
    {
        "run the following",
        "execute the command",
        "run this command",
        "use this command",
        "try running",
        "you can run",
        "enter the command",
        "type the following",
        "run the command",
        "execute this",
        "use the command",
        "in your terminal",
        "from the command line",
        "in the shell"
    };

    public CommandExtractorService(ILogger<CommandExtractorService> logger)
    {
        _logger = logger;
    }

    public CommandExtractionResult ExtractCommands(string content, Guid messageId)
    {
        if (string.IsNullOrWhiteSpace(content))
        {
            return new CommandExtractionResult();
        }

        var commands = new List<CommandBlock>();
        var warnings = new List<string>();
        var sequenceNumber = 0;

        // 1. Extract from fenced code blocks
        var fencedMatches = FencedCodeBlockPattern().Matches(content);
        foreach (Match match in fencedMatches)
        {
            var language = match.Groups["lang"].Value;
            var blockContent = match.Groups["content"].Value.Trim();

            if (IsShellCommand(language, blockContent))
            {
                var (isDangerous, warning) = CheckCommandSafety(blockContent);
                var description = ExtractDescription(content, match.Index);

                commands.Add(new CommandBlock
                {
                    Command = blockContent,
                    Language = string.IsNullOrEmpty(language) ? null : language,
                    DetectedShellType = GetShellTypeForLanguage(language),
                    MessageId = messageId,
                    SequenceNumber = sequenceNumber++,
                    Description = description,
                    SourceRange = new TextRange(match.Index, match.Index + match.Length),
                    IsPotentiallyDangerous = isDangerous,
                    DangerWarning = warning,
                    ConfidenceScore = string.IsNullOrEmpty(language) ? 0.7f : 0.95f
                });

                if (isDangerous)
                {
                    warnings.Add($"Command {sequenceNumber} may be dangerous: {warning}");
                }
            }
        }

        // 2. Extract inline commands following indicator phrases
        var lines = content.Split('\n');
        for (int i = 0; i < lines.Length; i++)
        {
            var line = lines[i];
            var lowerLine = line.ToLowerInvariant();

            if (CommandIndicators.Any(ind => lowerLine.Contains(ind)))
            {
                // Check next line(s) for inline code
                for (int j = i + 1; j < Math.Min(i + 3, lines.Length); j++)
                {
                    var nextLine = lines[j].Trim();
                    var inlineMatch = InlineCodePattern().Match(nextLine);

                    if (inlineMatch.Success)
                    {
                        var cmd = inlineMatch.Groups["cmd"].Value;

                        // Only add if it looks like a command and isn't already captured
                        if (IsLikelyCommand(cmd) && !commands.Any(c => c.Command == cmd))
                        {
                            var (isDangerous, warning) = CheckCommandSafety(cmd);

                            commands.Add(new CommandBlock
                            {
                                Command = cmd,
                                DetectedShellType = InferShellType(cmd),
                                MessageId = messageId,
                                SequenceNumber = sequenceNumber++,
                                Description = line.Trim(),
                                SourceRange = new TextRange(
                                    content.IndexOf(nextLine),
                                    content.IndexOf(nextLine) + nextLine.Length),
                                IsPotentiallyDangerous = isDangerous,
                                DangerWarning = warning,
                                ConfidenceScore = 0.6f // Lower confidence for inline
                            });
                        }
                        break;
                    }
                }
            }
        }

        _logger.LogDebug("Extracted {Count} commands from message {MessageId}",
            commands.Count, messageId);

        return new CommandExtractionResult
        {
            Commands = commands.AsReadOnly(),
            Warnings = warnings.AsReadOnly()
        };
    }

    public bool IsShellCommand(string? language, string content)
    {
        // If language is specified and is a shell language, it's a command
        if (!string.IsNullOrEmpty(language) && ShellLanguages.Contains(language))
        {
            return true;
        }

        // For unlabeled or unknown language blocks, use heuristics
        if (string.IsNullOrEmpty(language))
        {
            return IsLikelyCommand(content);
        }

        return false;
    }

    private bool IsLikelyCommand(string content)
    {
        if (string.IsNullOrWhiteSpace(content))
            return false;

        var lines = content.Split('\n', StringSplitOptions.RemoveEmptyEntries);
        if (lines.Length == 0)
            return false;

        // Commands are typically short (1-5 lines)
        if (lines.Length > 10)
            return false;

        var firstLine = lines[0].Trim();

        // Check for shell prompt prefixes
        if (firstLine.StartsWith("$ ") ||
            firstLine.StartsWith("> ") ||
            firstLine.StartsWith("PS>") ||
            firstLine.StartsWith("PS C:\\") ||
            firstLine.StartsWith("# ") && !firstLine.StartsWith("# ")) // Comment vs root prompt
        {
            return true;
        }

        // Check if first word is a known command
        var firstWord = firstLine.Split(' ', StringSplitOptions.RemoveEmptyEntries)
            .FirstOrDefault()?
            .TrimStart('.', '/', '\\') ?? "";

        // Remove path if present
        if (firstWord.Contains('/') || firstWord.Contains('\\'))
        {
            firstWord = Path.GetFileName(firstWord);
        }

        return CommonCommands.Contains(firstWord);
    }

    public ShellType? GetShellTypeForLanguage(string? language)
    {
        if (string.IsNullOrEmpty(language))
            return null;

        return language.ToLowerInvariant() switch
        {
            "bash" or "sh" or "shell" => ShellType.Bash,
            "zsh" => ShellType.Zsh,
            "fish" => ShellType.Fish,
            "powershell" or "pwsh" or "ps1" or "ps" => ShellType.PowerShell,
            "cmd" or "batch" or "bat" or "dos" => ShellType.Cmd,
            "ksh" => ShellType.Ksh,
            "tcsh" or "csh" => ShellType.Tcsh,
            "console" or "terminal" or "command" or "cli" => null, // Generic, no specific type
            _ => null
        };
    }

    private ShellType? InferShellType(string command)
    {
        // Try to infer shell type from command content
        if (command.Contains("$env:") || command.Contains("Get-") || command.Contains("Set-"))
            return ShellType.PowerShell;

        if (command.Contains("%") && command.Contains("%")) // %VAR%
            return ShellType.Cmd;

        if (command.StartsWith("set ") && !command.Contains("="))
            return ShellType.Fish;

        // Default to bash-like for Unix commands
        return null;
    }

    public (bool IsDangerous, string? Warning) CheckCommandSafety(string command)
    {
        foreach (var (pattern, warning) in DangerousPatterns)
        {
            if (pattern.IsMatch(command))
            {
                _logger.LogWarning("Dangerous command detected: {Warning}", warning);
                return (true, warning);
            }
        }

        return (false, null);
    }

    public string? ExtractDescription(string content, int commandPosition)
    {
        // Look for description in the lines immediately before the command
        var beforeContent = content[..commandPosition];
        var lines = beforeContent.Split('\n');

        // Check last 1-3 non-empty lines before command
        for (int i = lines.Length - 1; i >= Math.Max(0, lines.Length - 4); i--)
        {
            var line = lines[i].Trim();

            // Skip empty lines
            if (string.IsNullOrEmpty(line))
                continue;

            // Skip if it's another code block
            if (line.StartsWith("```"))
                break;

            // Skip markdown headers for description but could use them
            if (line.StartsWith("#"))
            {
                // Use header as description
                return line.TrimStart('#', ' ');
            }

            // Check if line contains command indicator
            var lowerLine = line.ToLowerInvariant();
            if (CommandIndicators.Any(ind => lowerLine.Contains(ind)))
            {
                return line;
            }

            // Use the line if it ends with a colon (typical description pattern)
            if (line.EndsWith(":"))
            {
                return line.TrimEnd(':');
            }

            // If we find a non-empty line that looks like a sentence, use it
            if (line.Length > 10 && char.IsUpper(line[0]))
            {
                return line;
            }
        }

        return null;
    }
}
```

### v0.5.4b Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/ICommandExtractorService.cs` | Extractor service interface |
| `src/SeniorIntern.Services/Terminal/CommandExtractorService.cs` | Extractor implementation |

### v0.5.4b Files to Modify

| File | Changes |
|------|---------|
| `src/SeniorIntern.Services/DependencyInjection.cs` | Register ICommandExtractorService |

### v0.5.4b Verification

```bash
# Run extractor tests
dotnet test --filter "CommandExtractor"
```

### v0.5.4b Acceptance Criteria

- [ ] Fenced code blocks with shell languages are extracted
- [ ] Unlabeled code blocks are detected via heuristics
- [ ] Inline commands following indicators are extracted
- [ ] Shell types are correctly detected from language tags
- [ ] Dangerous commands are flagged with warnings
- [ ] Descriptions are extracted from context
- [ ] Confidence scores reflect extraction certainty

---

## v0.5.4c: Command Execution Service

### Objective
Create a service that handles sending commands to the terminal, executing them, tracking execution status, and coordinating with the output capture system.

### ICommandExecutionService Interface

```csharp
namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Service for executing commands in the terminal
/// </summary>
public interface ICommandExecutionService
{
    /// <summary>
    /// Event raised when command status changes
    /// </summary>
    event EventHandler<CommandStatusChangedEventArgs>? StatusChanged;

    /// <summary>
    /// Copy command text to system clipboard
    /// </summary>
    Task CopyToClipboardAsync(CommandBlock command, CancellationToken ct = default);

    /// <summary>
    /// Send command to terminal without executing (no Enter key)
    /// </summary>
    Task SendToTerminalAsync(
        CommandBlock command,
        Guid? targetSessionId = null,
        CancellationToken ct = default);

    /// <summary>
    /// Execute command in terminal (sends command + Enter)
    /// </summary>
    Task<CommandExecutionResult> ExecuteAsync(
        CommandBlock command,
        Guid? targetSessionId = null,
        bool captureOutput = false,
        CancellationToken ct = default);

    /// <summary>
    /// Execute multiple commands sequentially
    /// </summary>
    Task<IReadOnlyList<CommandExecutionResult>> ExecuteAllAsync(
        IEnumerable<CommandBlock> commands,
        Guid? targetSessionId = null,
        bool stopOnError = true,
        bool captureOutput = false,
        CancellationToken ct = default);

    /// <summary>
    /// Cancel a running command (sends Ctrl+C)
    /// </summary>
    Task CancelExecutionAsync(Guid sessionId, CancellationToken ct = default);

    /// <summary>
    /// Get the current status of a command
    /// </summary>
    CommandBlockStatus GetStatus(Guid commandId);

    /// <summary>
    /// Ensure a suitable terminal session exists, creating one if needed
    /// </summary>
    Task<Guid> EnsureTerminalSessionAsync(
        ShellType? preferredShell = null,
        string? workingDirectory = null,
        CancellationToken ct = default);
}

/// <summary>
/// Result of command execution
/// </summary>
public sealed class CommandExecutionResult
{
    public Guid CommandId { get; init; }
    public CommandBlockStatus Status { get; init; }
    public Guid SessionId { get; init; }
    public DateTime ExecutedAt { get; init; }
    public TerminalOutputCapture? OutputCapture { get; init; }
    public string? ErrorMessage { get; init; }
    public TimeSpan? Duration { get; init; }
}

/// <summary>
/// Event args for command status changes
/// </summary>
public sealed class CommandStatusChangedEventArgs : EventArgs
{
    public Guid CommandId { get; init; }
    public CommandBlockStatus OldStatus { get; init; }
    public CommandBlockStatus NewStatus { get; init; }
    public Guid? SessionId { get; init; }
}
```

### CommandExecutionService Implementation

```csharp
namespace SeniorIntern.Services.Terminal;

using Avalonia.Input.Platform;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models.Terminal;
using System.Collections.Concurrent;

/// <summary>
/// Handles command execution in terminal sessions
/// </summary>
public sealed class CommandExecutionService : ICommandExecutionService
{
    private readonly ITerminalService _terminalService;
    private readonly IShellProfileService _profileService;
    private readonly IOutputCaptureService _outputCapture;
    private readonly IClipboard _clipboard;
    private readonly ILogger<CommandExecutionService> _logger;

    private readonly ConcurrentDictionary<Guid, CommandBlockStatus> _commandStatuses = new();

    public event EventHandler<CommandStatusChangedEventArgs>? StatusChanged;

    public CommandExecutionService(
        ITerminalService terminalService,
        IShellProfileService profileService,
        IOutputCaptureService outputCapture,
        IClipboard clipboard,
        ILogger<CommandExecutionService> logger)
    {
        _terminalService = terminalService;
        _profileService = profileService;
        _outputCapture = outputCapture;
        _clipboard = clipboard;
        _logger = logger;
    }

    public async Task CopyToClipboardAsync(CommandBlock command, CancellationToken ct = default)
    {
        await _clipboard.SetTextAsync(command.Command);
        UpdateStatus(command.Id, CommandBlockStatus.Copied);

        _logger.LogDebug("Copied command {Id} to clipboard", command.Id);
    }

    public async Task SendToTerminalAsync(
        CommandBlock command,
        Guid? targetSessionId = null,
        CancellationToken ct = default)
    {
        var sessionId = targetSessionId ?? await EnsureTerminalSessionAsync(
            command.DetectedShellType,
            command.WorkingDirectory,
            ct);

        // Send command text without newline (user must press Enter)
        await _terminalService.WriteInputAsync(sessionId, command.Command, ct);

        UpdateStatus(command.Id, CommandBlockStatus.SentToTerminal);
        command.ExecutedInSessionId = sessionId;

        _logger.LogDebug("Sent command {Id} to terminal session {Session}",
            command.Id, sessionId);
    }

    public async Task<CommandExecutionResult> ExecuteAsync(
        CommandBlock command,
        Guid? targetSessionId = null,
        bool captureOutput = false,
        CancellationToken ct = default)
    {
        var sessionId = targetSessionId ?? await EnsureTerminalSessionAsync(
            command.DetectedShellType,
            command.WorkingDirectory,
            ct);

        var startTime = DateTime.UtcNow;
        UpdateStatus(command.Id, CommandBlockStatus.Executing);

        TerminalOutputCapture? capture = null;

        try
        {
            // Start output capture if requested
            if (captureOutput)
            {
                _outputCapture.StartCapture(sessionId, command.Command);
            }

            // Send command with Enter key
            var commandWithNewline = command.Command.TrimEnd() + GetNewlineForSession(sessionId);
            await _terminalService.WriteInputAsync(sessionId, commandWithNewline, ct);

            command.ExecutedAt = DateTime.UtcNow;
            command.ExecutedInSessionId = sessionId;

            // Wait a bit for command to process (basic approach)
            // In a real implementation, we'd use shell integration markers (OSC 133)
            if (captureOutput)
            {
                await Task.Delay(500, ct); // Allow command to start
                capture = await _outputCapture.StopCaptureAsync(sessionId, ct);
                command.OutputCaptureId = capture?.Id;
            }

            UpdateStatus(command.Id, CommandBlockStatus.Executed);

            return new CommandExecutionResult
            {
                CommandId = command.Id,
                Status = CommandBlockStatus.Executed,
                SessionId = sessionId,
                ExecutedAt = startTime,
                OutputCapture = capture,
                Duration = DateTime.UtcNow - startTime
            };
        }
        catch (OperationCanceledException)
        {
            UpdateStatus(command.Id, CommandBlockStatus.Cancelled);

            if (captureOutput)
            {
                capture = await _outputCapture.StopCaptureAsync(sessionId, CancellationToken.None);
            }

            return new CommandExecutionResult
            {
                CommandId = command.Id,
                Status = CommandBlockStatus.Cancelled,
                SessionId = sessionId,
                ExecutedAt = startTime,
                OutputCapture = capture,
                Duration = DateTime.UtcNow - startTime
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to execute command {Id}", command.Id);
            UpdateStatus(command.Id, CommandBlockStatus.Failed);

            if (captureOutput)
            {
                capture = await _outputCapture.StopCaptureAsync(sessionId, CancellationToken.None);
            }

            return new CommandExecutionResult
            {
                CommandId = command.Id,
                Status = CommandBlockStatus.Failed,
                SessionId = sessionId,
                ExecutedAt = startTime,
                OutputCapture = capture,
                ErrorMessage = ex.Message,
                Duration = DateTime.UtcNow - startTime
            };
        }
    }

    public async Task<IReadOnlyList<CommandExecutionResult>> ExecuteAllAsync(
        IEnumerable<CommandBlock> commands,
        Guid? targetSessionId = null,
        bool stopOnError = true,
        bool captureOutput = false,
        CancellationToken ct = default)
    {
        var results = new List<CommandExecutionResult>();
        Guid? sessionId = targetSessionId;

        foreach (var command in commands)
        {
            ct.ThrowIfCancellationRequested();

            var result = await ExecuteAsync(command, sessionId, captureOutput, ct);
            results.Add(result);

            // Use same session for subsequent commands
            sessionId = result.SessionId;

            if (stopOnError && result.Status == CommandBlockStatus.Failed)
            {
                _logger.LogWarning("Stopping execution due to failed command {Id}", command.Id);
                break;
            }

            // Small delay between commands
            await Task.Delay(100, ct);
        }

        return results.AsReadOnly();
    }

    public async Task CancelExecutionAsync(Guid sessionId, CancellationToken ct = default)
    {
        await _terminalService.SendSignalAsync(sessionId, TerminalSignal.Interrupt, ct);
        _logger.LogDebug("Sent interrupt signal to session {Session}", sessionId);
    }

    public CommandBlockStatus GetStatus(Guid commandId)
    {
        return _commandStatuses.GetValueOrDefault(commandId, CommandBlockStatus.Pending);
    }

    public async Task<Guid> EnsureTerminalSessionAsync(
        ShellType? preferredShell = null,
        string? workingDirectory = null,
        CancellationToken ct = default)
    {
        // Try to use active session if compatible
        var activeSession = _terminalService.ActiveSession;
        if (activeSession != null)
        {
            // Check if shell type matches (if specified)
            if (preferredShell == null || activeSession.ShellType == preferredShell)
            {
                // Change directory if needed
                if (!string.IsNullOrEmpty(workingDirectory) &&
                    activeSession.WorkingDirectory != workingDirectory)
                {
                    // Directory change is handled by caller if needed
                }

                return activeSession.Id;
            }
        }

        // Create new session
        var profile = preferredShell.HasValue
            ? await FindProfileForShellTypeAsync(preferredShell.Value, ct)
            : await _profileService.GetDefaultProfileAsync(ct);

        var session = await _terminalService.CreateSessionAsync(new TerminalSessionOptions
        {
            ShellPath = profile.ShellPath,
            Arguments = profile.Arguments,
            WorkingDirectory = workingDirectory ?? profile.StartingDirectory,
            Environment = profile.Environment,
            Name = profile.Name
        }, ct);

        return session.Id;
    }

    private async Task<ShellProfile> FindProfileForShellTypeAsync(ShellType shellType, CancellationToken ct)
    {
        var profiles = await _profileService.GetAllProfilesAsync(ct);
        var matchingProfile = profiles.FirstOrDefault(p => p.ShellType == shellType);

        return matchingProfile ?? await _profileService.GetDefaultProfileAsync(ct);
    }

    private string GetNewlineForSession(Guid sessionId)
    {
        // Most terminals use \r for Enter
        // Could be made session-specific if needed
        return "\r";
    }

    private void UpdateStatus(Guid commandId, CommandBlockStatus newStatus)
    {
        var oldStatus = _commandStatuses.GetValueOrDefault(commandId, CommandBlockStatus.Pending);
        _commandStatuses[commandId] = newStatus;

        StatusChanged?.Invoke(this, new CommandStatusChangedEventArgs
        {
            CommandId = commandId,
            OldStatus = oldStatus,
            NewStatus = newStatus
        });
    }
}
```

### v0.5.4c Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/ICommandExecutionService.cs` | Execution service interface |
| `src/SeniorIntern.Core/Models/Terminal/CommandExecutionResult.cs` | Execution result model |
| `src/SeniorIntern.Core/Models/Terminal/CommandStatusChangedEventArgs.cs` | Event args |
| `src/SeniorIntern.Services/Terminal/CommandExecutionService.cs` | Execution implementation |

### v0.5.4c Files to Modify

| File | Changes |
|------|---------|
| `src/SeniorIntern.Services/DependencyInjection.cs` | Register ICommandExecutionService |

### v0.5.4c Verification

```bash
# Run execution tests
dotnet test --filter "CommandExecution"
```

### v0.5.4c Acceptance Criteria

- [ ] Commands can be copied to clipboard
- [ ] Commands can be sent to terminal without executing
- [ ] Commands can be executed with Enter key
- [ ] Multiple commands can be executed sequentially
- [ ] Execution can be cancelled with Ctrl+C
- [ ] Status changes are tracked and events raised
- [ ] Sessions are created on-demand when needed
- [ ] Shell type preferences are respected

---

## v0.5.4d: Output Capture System

### Objective
Create a system for capturing terminal output that can be attached to AI conversations for context, with support for different capture modes and intelligent truncation.

### IOutputCaptureService Interface

```csharp
namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Service for capturing terminal output
/// </summary>
public interface IOutputCaptureService
{
    /// <summary>
    /// Start capturing output from a session
    /// </summary>
    void StartCapture(Guid sessionId, string? commandContext = null);

    /// <summary>
    /// Stop capturing and return the captured output
    /// </summary>
    Task<TerminalOutputCapture?> StopCaptureAsync(Guid sessionId, CancellationToken ct = default);

    /// <summary>
    /// Capture the current visible buffer
    /// </summary>
    Task<TerminalOutputCapture> CaptureBufferAsync(
        Guid sessionId,
        OutputCaptureMode mode = OutputCaptureMode.FullBuffer,
        int? lineCount = null,
        CancellationToken ct = default);

    /// <summary>
    /// Capture selected text from terminal
    /// </summary>
    Task<TerminalOutputCapture?> CaptureSelectionAsync(
        Guid sessionId,
        CancellationToken ct = default);

    /// <summary>
    /// Get recent captures for a session
    /// </summary>
    IReadOnlyList<TerminalOutputCapture> GetRecentCaptures(Guid sessionId, int count = 10);

    /// <summary>
    /// Get a specific capture by ID
    /// </summary>
    TerminalOutputCapture? GetCapture(Guid captureId);

    /// <summary>
    /// Configure capture settings
    /// </summary>
    void Configure(OutputCaptureSettings settings);
}

/// <summary>
/// Settings for output capture
/// </summary>
public sealed class OutputCaptureSettings
{
    /// <summary>
    /// Maximum characters to capture before truncation
    /// </summary>
    public int MaxCaptureLength { get; set; } = 8000;

    /// <summary>
    /// Maximum lines to capture
    /// </summary>
    public int MaxCaptureLines { get; set; } = 500;

    /// <summary>
    /// How to truncate when limits exceeded
    /// </summary>
    public TruncationMode TruncationMode { get; set; } = TruncationMode.KeepEnd;

    /// <summary>
    /// Whether to strip ANSI escape sequences
    /// </summary>
    public bool StripAnsiSequences { get; set; } = true;

    /// <summary>
    /// Whether to normalize line endings
    /// </summary>
    public bool NormalizeLineEndings { get; set; } = true;

    /// <summary>
    /// Number of recent captures to keep per session
    /// </summary>
    public int CaptureHistorySize { get; set; } = 20;
}

/// <summary>
/// How to truncate captured output
/// </summary>
public enum TruncationMode
{
    /// <summary>
    /// Keep the beginning, truncate the end
    /// </summary>
    KeepStart,

    /// <summary>
    /// Keep the end, truncate the beginning
    /// </summary>
    KeepEnd,

    /// <summary>
    /// Keep both start and end, truncate middle
    /// </summary>
    KeepBoth
}
```

### OutputCaptureService Implementation

```csharp
namespace SeniorIntern.Services.Terminal;

using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models.Terminal;
using System.Collections.Concurrent;
using System.Text;
using System.Text.RegularExpressions;

/// <summary>
/// Captures terminal output for AI context
/// </summary>
public sealed partial class OutputCaptureService : IOutputCaptureService
{
    private readonly ITerminalService _terminalService;
    private readonly ILogger<OutputCaptureService> _logger;

    private readonly ConcurrentDictionary<Guid, CaptureContext> _activeCaptures = new();
    private readonly ConcurrentDictionary<Guid, TerminalOutputCapture> _captureHistory = new();
    private readonly ConcurrentDictionary<Guid, Queue<Guid>> _sessionCaptureHistory = new();

    private OutputCaptureSettings _settings = new();

    // Regex to strip ANSI escape sequences
    [GeneratedRegex(@"\x1B\[[0-9;]*[a-zA-Z]|\x1B\].*?(?:\x07|\x1B\\)")]
    private static partial Regex AnsiEscapePattern();

    public OutputCaptureService(
        ITerminalService terminalService,
        ILogger<OutputCaptureService> logger)
    {
        _terminalService = terminalService;
        _logger = logger;

        // Subscribe to terminal output
        _terminalService.OutputReceived += OnOutputReceived;
    }

    public void Configure(OutputCaptureSettings settings)
    {
        _settings = settings;
    }

    public void StartCapture(Guid sessionId, string? commandContext = null)
    {
        var context = new CaptureContext
        {
            SessionId = sessionId,
            CommandContext = commandContext,
            StartedAt = DateTime.UtcNow,
            Buffer = new StringBuilder()
        };

        _activeCaptures[sessionId] = context;
        _logger.LogDebug("Started capture for session {Session}", sessionId);
    }

    private void OnOutputReceived(object? sender, TerminalOutputEventArgs e)
    {
        if (_activeCaptures.TryGetValue(e.SessionId, out var context))
        {
            context.Buffer.Append(e.Data);
        }
    }

    public Task<TerminalOutputCapture?> StopCaptureAsync(Guid sessionId, CancellationToken ct = default)
    {
        if (!_activeCaptures.TryRemove(sessionId, out var context))
        {
            return Task.FromResult<TerminalOutputCapture?>(null);
        }

        var output = context.Buffer.ToString();
        output = ProcessOutput(output);

        var capture = CreateCapture(
            sessionId,
            context.CommandContext,
            output,
            context.StartedAt,
            OutputCaptureMode.LastCommand);

        AddToCaptureHistory(sessionId, capture);

        _logger.LogDebug("Stopped capture for session {Session}, captured {Length} chars",
            sessionId, capture.Output.Length);

        return Task.FromResult<TerminalOutputCapture?>(capture);
    }

    public async Task<TerminalOutputCapture> CaptureBufferAsync(
        Guid sessionId,
        OutputCaptureMode mode = OutputCaptureMode.FullBuffer,
        int? lineCount = null,
        CancellationToken ct = default)
    {
        var buffer = _terminalService.GetBuffer(sessionId);
        var session = _terminalService.GetSession(sessionId);

        string output;
        switch (mode)
        {
            case OutputCaptureMode.FullBuffer:
                output = buffer.GetText();
                break;

            case OutputCaptureMode.LastNLines:
                var lines = lineCount ?? 50;
                output = buffer.GetLastLines(lines);
                break;

            case OutputCaptureMode.Selection:
                output = buffer.GetSelectedText() ?? string.Empty;
                break;

            default:
                output = buffer.GetText();
                break;
        }

        output = ProcessOutput(output);

        var capture = CreateCapture(
            sessionId,
            null,
            output,
            DateTime.UtcNow,
            mode,
            session?.WorkingDirectory);

        AddToCaptureHistory(sessionId, capture);

        return capture;
    }

    public async Task<TerminalOutputCapture?> CaptureSelectionAsync(
        Guid sessionId,
        CancellationToken ct = default)
    {
        var buffer = _terminalService.GetBuffer(sessionId);
        var selectedText = buffer.GetSelectedText();

        if (string.IsNullOrEmpty(selectedText))
        {
            return null;
        }

        var output = ProcessOutput(selectedText);
        var session = _terminalService.GetSession(sessionId);

        var capture = CreateCapture(
            sessionId,
            null,
            output,
            DateTime.UtcNow,
            OutputCaptureMode.Selection,
            session?.WorkingDirectory);

        AddToCaptureHistory(sessionId, capture);

        return capture;
    }

    public IReadOnlyList<TerminalOutputCapture> GetRecentCaptures(Guid sessionId, int count = 10)
    {
        if (!_sessionCaptureHistory.TryGetValue(sessionId, out var queue))
        {
            return Array.Empty<TerminalOutputCapture>();
        }

        return queue
            .Take(count)
            .Select(id => _captureHistory.GetValueOrDefault(id))
            .Where(c => c != null)
            .Cast<TerminalOutputCapture>()
            .ToList()
            .AsReadOnly();
    }

    public TerminalOutputCapture? GetCapture(Guid captureId)
    {
        return _captureHistory.GetValueOrDefault(captureId);
    }

    private string ProcessOutput(string output)
    {
        if (string.IsNullOrEmpty(output))
            return string.Empty;

        // Strip ANSI sequences if configured
        if (_settings.StripAnsiSequences)
        {
            output = AnsiEscapePattern().Replace(output, "");
        }

        // Normalize line endings if configured
        if (_settings.NormalizeLineEndings)
        {
            output = output.Replace("\r\n", "\n").Replace("\r", "\n");
        }

        // Truncate if needed
        output = TruncateOutput(output);

        return output.Trim();
    }

    private string TruncateOutput(string output)
    {
        var originalLength = output.Length;
        var isTruncated = false;

        // Check line limit
        var lines = output.Split('\n');
        if (lines.Length > _settings.MaxCaptureLines)
        {
            isTruncated = true;
            lines = _settings.TruncationMode switch
            {
                TruncationMode.KeepStart => lines.Take(_settings.MaxCaptureLines).ToArray(),
                TruncationMode.KeepEnd => lines.Skip(lines.Length - _settings.MaxCaptureLines).ToArray(),
                TruncationMode.KeepBoth => KeepBothEnds(lines, _settings.MaxCaptureLines),
                _ => lines.Take(_settings.MaxCaptureLines).ToArray()
            };
            output = string.Join('\n', lines);
        }

        // Check character limit
        if (output.Length > _settings.MaxCaptureLength)
        {
            isTruncated = true;
            output = _settings.TruncationMode switch
            {
                TruncationMode.KeepStart =>
                    output[.._settings.MaxCaptureLength] + "\n...(truncated)",
                TruncationMode.KeepEnd =>
                    "...(truncated)\n" + output[^_settings.MaxCaptureLength..],
                TruncationMode.KeepBoth =>
                    output[..(_settings.MaxCaptureLength / 2)] +
                    "\n...(truncated)...\n" +
                    output[^(_settings.MaxCaptureLength / 2)..],
                _ => output[.._settings.MaxCaptureLength] + "\n...(truncated)"
            };
        }

        return output;
    }

    private static string[] KeepBothEnds(string[] lines, int maxLines)
    {
        var keepCount = maxLines / 2;
        var start = lines.Take(keepCount);
        var end = lines.Skip(lines.Length - keepCount);
        return start.Concat(new[] { "...(truncated)..." }).Concat(end).ToArray();
    }

    private TerminalOutputCapture CreateCapture(
        Guid sessionId,
        string? command,
        string output,
        DateTime startedAt,
        OutputCaptureMode mode,
        string? workingDirectory = null)
    {
        var session = _terminalService.GetSession(sessionId);

        return new TerminalOutputCapture
        {
            SessionId = sessionId,
            SessionName = session?.Name,
            Command = command,
            Output = output,
            IsTruncated = output.Contains("(truncated)"),
            OriginalLength = output.Length,
            StartedAt = startedAt,
            CompletedAt = DateTime.UtcNow,
            WorkingDirectory = workingDirectory ?? session?.WorkingDirectory,
            CaptureMode = mode
        };
    }

    private void AddToCaptureHistory(Guid sessionId, TerminalOutputCapture capture)
    {
        _captureHistory[capture.Id] = capture;

        var queue = _sessionCaptureHistory.GetOrAdd(sessionId, _ => new Queue<Guid>());
        queue.Enqueue(capture.Id);

        // Trim old captures
        while (queue.Count > _settings.CaptureHistorySize)
        {
            if (queue.TryDequeue(out var oldId))
            {
                _captureHistory.TryRemove(oldId, out _);
            }
        }
    }

    private sealed class CaptureContext
    {
        public Guid SessionId { get; init; }
        public string? CommandContext { get; init; }
        public DateTime StartedAt { get; init; }
        public StringBuilder Buffer { get; init; } = new();
    }
}
```

### v0.5.4d Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/IOutputCaptureService.cs` | Capture service interface |
| `src/SeniorIntern.Core/Models/Terminal/OutputCaptureSettings.cs` | Capture settings |
| `src/SeniorIntern.Core/Models/Terminal/TruncationMode.cs` | Truncation mode enum |
| `src/SeniorIntern.Services/Terminal/OutputCaptureService.cs` | Capture implementation |

### v0.5.4d Files to Modify

| File | Changes |
|------|---------|
| `src/SeniorIntern.Services/DependencyInjection.cs` | Register IOutputCaptureService |
| `src/SeniorIntern.Core/Models/Terminal/TerminalBuffer.cs` | Add GetLastLines, GetSelectedText methods |

### v0.5.4d Verification

```bash
# Run capture tests
dotnet test --filter "OutputCapture"
```

### v0.5.4d Acceptance Criteria

- [ ] Output can be captured from active sessions
- [ ] Full buffer capture works
- [ ] Last N lines capture works
- [ ] Selection capture works
- [ ] ANSI sequences are stripped
- [ ] Output is truncated when exceeding limits
- [ ] Truncation modes work correctly (start, end, both)
- [ ] Capture history is maintained and pruned

---

## v0.5.4e: Command Block ViewModel

### Objective
Create the ViewModel layer for command blocks that handles user interactions (copy, send, run), status display, and coordination with execution services.

### CommandBlockViewModel

```csharp
namespace SeniorIntern.Desktop.ViewModels;

using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models.Terminal;

/// <summary>
/// ViewModel for an individual command block in chat
/// </summary>
public partial class CommandBlockViewModel : ViewModelBase
{
    private readonly ICommandExecutionService _executionService;
    private readonly ITerminalService _terminalService;

    [ObservableProperty]
    private CommandBlock _command = null!;

    [ObservableProperty]
    private CommandBlockStatus _status = CommandBlockStatus.Pending;

    [ObservableProperty]
    private bool _isExecuting;

    [ObservableProperty]
    private string? _statusMessage;

    [ObservableProperty]
    private bool _showDangerWarning;

    [ObservableProperty]
    private bool _dangerConfirmed;

    /// <summary>
    /// Display text for the command
    /// </summary>
    public string CommandText => Command.Command;

    /// <summary>
    /// Short preview of the command (first line)
    /// </summary>
    public string CommandPreview
    {
        get
        {
            var firstLine = Command.Command.Split('\n').FirstOrDefault() ?? string.Empty;
            return firstLine.Length > 60 ? firstLine[..57] + "..." : firstLine;
        }
    }

    /// <summary>
    /// Description from context
    /// </summary>
    public string? Description => Command.Description;

    /// <summary>
    /// Language badge text
    /// </summary>
    public string? LanguageBadge => Command.Language?.ToUpperInvariant();

    /// <summary>
    /// Whether this is a multi-line command
    /// </summary>
    public bool IsMultiLine => Command.IsMultiLine;

    /// <summary>
    /// Number of lines for display
    /// </summary>
    public int LineCount => Command.LineCount;

    /// <summary>
    /// Whether command is potentially dangerous
    /// </summary>
    public bool IsDangerous => Command.IsPotentiallyDangerous;

    /// <summary>
    /// Danger warning text
    /// </summary>
    public string? DangerWarning => Command.DangerWarning;

    /// <summary>
    /// Status display text
    /// </summary>
    public string StatusText => Status switch
    {
        CommandBlockStatus.Pending => "",
        CommandBlockStatus.Copied => "Copied",
        CommandBlockStatus.SentToTerminal => "Sent",
        CommandBlockStatus.Executing => "Running...",
        CommandBlockStatus.Executed => "Executed",
        CommandBlockStatus.Failed => "Failed",
        CommandBlockStatus.Cancelled => "Cancelled",
        _ => ""
    };

    /// <summary>
    /// Whether to show status badge
    /// </summary>
    public bool ShowStatus => Status != CommandBlockStatus.Pending;

    /// <summary>
    /// CSS-like class for status styling
    /// </summary>
    public string StatusClass => Status switch
    {
        CommandBlockStatus.Executed => "success",
        CommandBlockStatus.Failed => "error",
        CommandBlockStatus.Cancelled => "warning",
        CommandBlockStatus.Executing => "running",
        _ => ""
    };

    /// <summary>
    /// Whether there's an active terminal to send to
    /// </summary>
    public bool HasActiveTerminal => _terminalService.ActiveSession != null;

    public CommandBlockViewModel(
        ICommandExecutionService executionService,
        ITerminalService terminalService)
    {
        _executionService = executionService;
        _terminalService = terminalService;

        // Subscribe to status changes
        _executionService.StatusChanged += OnStatusChanged;
        _terminalService.SessionStateChanged += (_, _) => OnPropertyChanged(nameof(HasActiveTerminal));
    }

    private void OnStatusChanged(object? sender, CommandStatusChangedEventArgs e)
    {
        if (e.CommandId == Command.Id)
        {
            Status = e.NewStatus;
            IsExecuting = e.NewStatus == CommandBlockStatus.Executing;
        }
    }

    [RelayCommand]
    private async Task CopyAsync()
    {
        await _executionService.CopyToClipboardAsync(Command);
        StatusMessage = "Copied to clipboard";
        await ClearStatusMessageAfterDelay();
    }

    [RelayCommand]
    private async Task SendToTerminalAsync()
    {
        if (IsDangerous && !DangerConfirmed)
        {
            ShowDangerWarning = true;
            return;
        }

        try
        {
            await _executionService.SendToTerminalAsync(Command);
            StatusMessage = "Sent to terminal";
            await ClearStatusMessageAfterDelay();
        }
        catch (Exception ex)
        {
            StatusMessage = $"Failed: {ex.Message}";
        }
    }

    [RelayCommand]
    private async Task ExecuteAsync()
    {
        if (IsDangerous && !DangerConfirmed)
        {
            ShowDangerWarning = true;
            return;
        }

        try
        {
            IsExecuting = true;
            var result = await _executionService.ExecuteAsync(Command, captureOutput: true);

            StatusMessage = result.Status == CommandBlockStatus.Executed
                ? "Executed successfully"
                : $"Execution {result.Status.ToString().ToLower()}";
        }
        catch (Exception ex)
        {
            StatusMessage = $"Failed: {ex.Message}";
        }
        finally
        {
            IsExecuting = false;
        }
    }

    [RelayCommand]
    private void ConfirmDanger()
    {
        DangerConfirmed = true;
        ShowDangerWarning = false;
    }

    [RelayCommand]
    private void CancelDanger()
    {
        ShowDangerWarning = false;
    }

    [RelayCommand]
    private void ExpandCommand()
    {
        // Toggle expanded view for multi-line commands
        // Handled by the view
    }

    private async Task ClearStatusMessageAfterDelay()
    {
        await Task.Delay(2000);
        StatusMessage = null;
    }

    partial void OnCommandChanged(CommandBlock value)
    {
        Status = value.Status;
        OnPropertyChanged(nameof(CommandText));
        OnPropertyChanged(nameof(CommandPreview));
        OnPropertyChanged(nameof(Description));
        OnPropertyChanged(nameof(LanguageBadge));
        OnPropertyChanged(nameof(IsMultiLine));
        OnPropertyChanged(nameof(LineCount));
        OnPropertyChanged(nameof(IsDangerous));
        OnPropertyChanged(nameof(DangerWarning));
    }

    partial void OnStatusChanged(CommandBlockStatus value)
    {
        OnPropertyChanged(nameof(StatusText));
        OnPropertyChanged(nameof(ShowStatus));
        OnPropertyChanged(nameof(StatusClass));
    }
}
```

### CommandBlockViewModelFactory

```csharp
namespace SeniorIntern.Desktop.ViewModels;

/// <summary>
/// Factory for creating CommandBlockViewModels
/// </summary>
public sealed class CommandBlockViewModelFactory
{
    private readonly ICommandExecutionService _executionService;
    private readonly ITerminalService _terminalService;

    public CommandBlockViewModelFactory(
        ICommandExecutionService executionService,
        ITerminalService terminalService)
    {
        _executionService = executionService;
        _terminalService = terminalService;
    }

    public CommandBlockViewModel Create(CommandBlock command)
    {
        return new CommandBlockViewModel(_executionService, _terminalService)
        {
            Command = command
        };
    }

    public IEnumerable<CommandBlockViewModel> CreateRange(IEnumerable<CommandBlock> commands)
    {
        return commands.Select(Create);
    }
}
```

### v0.5.4e Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/ViewModels/CommandBlockViewModel.cs` | Command block ViewModel |
| `src/SeniorIntern.Desktop/ViewModels/CommandBlockViewModelFactory.cs` | Factory for ViewModels |

### v0.5.4e Files to Modify

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/DependencyInjection.cs` | Register factory |

### v0.5.4e Verification

```bash
# Run ViewModel tests
dotnet test --filter "CommandBlockViewModel"
```

### v0.5.4e Acceptance Criteria

- [ ] Copy command updates status
- [ ] Send to terminal works with active session
- [ ] Execute runs command and captures output
- [ ] Dangerous commands show warning
- [ ] Danger confirmation flow works
- [ ] Status updates reflect in UI
- [ ] Multi-line commands can be expanded

---

## v0.5.4f: Command Block UI

### Objective
Create the Avalonia XAML control for rendering command blocks in chat messages with action buttons, status indicators, and danger warnings.

### CommandBlockControl.axaml

```xml
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:vm="using:SeniorIntern.Desktop.ViewModels"
             x:Class="SeniorIntern.Desktop.Controls.CommandBlockControl"
             x:DataType="vm:CommandBlockViewModel">

    <UserControl.Styles>
        <Style Selector="Border.command-block">
            <Setter Property="Background" Value="{DynamicResource CommandBlockBackground}" />
            <Setter Property="BorderBrush" Value="{DynamicResource CommandBlockBorder}" />
            <Setter Property="BorderThickness" Value="1" />
            <Setter Property="CornerRadius" Value="6" />
            <Setter Property="Padding" Value="0" />
            <Setter Property="Margin" Value="0,8" />
        </Style>

        <Style Selector="Border.command-block.dangerous">
            <Setter Property="BorderBrush" Value="{DynamicResource DangerBrush}" />
            <Setter Property="BorderThickness" Value="2" />
        </Style>

        <Style Selector="Border.command-content">
            <Setter Property="Background" Value="{DynamicResource CodeBlockBackground}" />
            <Setter Property="Padding" Value="12,8" />
        </Style>

        <Style Selector="Border.status-badge">
            <Setter Property="Background" Value="{DynamicResource StatusBadgeBackground}" />
            <Setter Property="CornerRadius" Value="4" />
            <Setter Property="Padding" Value="6,2" />
        </Style>

        <Style Selector="Border.status-badge.success">
            <Setter Property="Background" Value="{DynamicResource SuccessBrush}" />
        </Style>

        <Style Selector="Border.status-badge.error">
            <Setter Property="Background" Value="{DynamicResource ErrorBrush}" />
        </Style>

        <Style Selector="Border.status-badge.running">
            <Setter Property="Background" Value="{DynamicResource AccentBrush}" />
        </Style>

        <Style Selector="Border.danger-warning">
            <Setter Property="Background" Value="{DynamicResource DangerBackgroundBrush}" />
            <Setter Property="BorderBrush" Value="{DynamicResource DangerBrush}" />
            <Setter Property="BorderThickness" Value="1" />
            <Setter Property="CornerRadius" Value="4" />
            <Setter Property="Padding" Value="12,8" />
            <Setter Property="Margin" Value="0,8,0,0" />
        </Style>

        <Style Selector="Button.command-action">
            <Setter Property="Padding" Value="8,4" />
            <Setter Property="MinWidth" Value="0" />
            <Setter Property="Background" Value="Transparent" />
        </Style>

        <Style Selector="Button.command-action:pointerover">
            <Setter Property="Background" Value="{DynamicResource HoverBrush}" />
        </Style>

        <Style Selector="Button.run-button">
            <Setter Property="Background" Value="{DynamicResource AccentBrush}" />
            <Setter Property="Foreground" Value="White" />
        </Style>
    </UserControl.Styles>

    <Border Classes="command-block"
            Classes.dangerous="{Binding IsDangerous}">
        <Grid RowDefinitions="Auto,Auto,Auto,Auto">
            <!-- Header: Description + Language Badge + Status -->
            <Grid Grid.Row="0"
                  ColumnDefinitions="*,Auto,Auto"
                  Margin="12,8"
                  IsVisible="{Binding Description, Converter={x:Static StringConverters.IsNotNullOrEmpty}}">

                <!-- Description -->
                <TextBlock Grid.Column="0"
                           Text="{Binding Description}"
                           FontSize="12"
                           Foreground="{DynamicResource TextMuted}"
                           TextWrapping="Wrap" />

                <!-- Language Badge -->
                <Border Grid.Column="1"
                        IsVisible="{Binding LanguageBadge, Converter={x:Static StringConverters.IsNotNullOrEmpty}}"
                        Background="{DynamicResource BadgeBackground}"
                        CornerRadius="3"
                        Padding="6,2"
                        Margin="8,0">
                    <TextBlock Text="{Binding LanguageBadge}"
                               FontSize="10"
                               FontWeight="SemiBold"
                               Foreground="{DynamicResource BadgeForeground}" />
                </Border>

                <!-- Status Badge -->
                <Border Grid.Column="2"
                        Classes="status-badge"
                        Classes.success="{Binding StatusClass, Converter={StaticResource EqualityConverter}, ConverterParameter=success}"
                        Classes.error="{Binding StatusClass, Converter={StaticResource EqualityConverter}, ConverterParameter=error}"
                        Classes.running="{Binding StatusClass, Converter={StaticResource EqualityConverter}, ConverterParameter=running}"
                        IsVisible="{Binding ShowStatus}">
                    <TextBlock Text="{Binding StatusText}"
                               FontSize="10"
                               Foreground="White" />
                </Border>
            </Grid>

            <!-- Command Content -->
            <Border Grid.Row="1" Classes="command-content">
                <Grid ColumnDefinitions="Auto,*">
                    <!-- Prompt Symbol -->
                    <TextBlock Grid.Column="0"
                               Text="$"
                               FontFamily="{StaticResource MonospaceFont}"
                               Foreground="{DynamicResource TerminalPromptColor}"
                               Margin="0,0,8,0"
                               VerticalAlignment="Top" />

                    <!-- Command Text -->
                    <SelectableTextBlock Grid.Column="1"
                                         Text="{Binding CommandText}"
                                         FontFamily="{StaticResource MonospaceFont}"
                                         FontSize="13"
                                         TextWrapping="Wrap"
                                         Foreground="{DynamicResource CodeForeground}" />
                </Grid>
            </Border>

            <!-- Action Buttons -->
            <StackPanel Grid.Row="2"
                        Orientation="Horizontal"
                        Spacing="4"
                        Margin="12,8">

                <!-- Copy Button -->
                <Button Classes="command-action"
                        Command="{Binding CopyCommand}"
                        ToolTip.Tip="Copy to clipboard">
                    <StackPanel Orientation="Horizontal" Spacing="4">
                        <PathIcon Data="{StaticResource CopyIcon}"
                                  Width="14" Height="14" />
                        <TextBlock Text="Copy" FontSize="12" />
                    </StackPanel>
                </Button>

                <!-- Send to Terminal Button -->
                <Button Classes="command-action"
                        Command="{Binding SendToTerminalCommand}"
                        ToolTip.Tip="Send to terminal (doesn't execute)"
                        IsEnabled="{Binding HasActiveTerminal}">
                    <StackPanel Orientation="Horizontal" Spacing="4">
                        <PathIcon Data="{StaticResource TerminalIcon}"
                                  Width="14" Height="14" />
                        <TextBlock Text="Send" FontSize="12" />
                    </StackPanel>
                </Button>

                <!-- Separator -->
                <Border Width="1"
                        Height="16"
                        Background="{DynamicResource BorderBrush}"
                        Margin="4,0" />

                <!-- Run Button -->
                <Button Classes="command-action run-button"
                        Command="{Binding ExecuteCommand}"
                        IsEnabled="{Binding !IsExecuting}"
                        ToolTip.Tip="Execute in terminal">
                    <StackPanel Orientation="Horizontal" Spacing="4">
                        <PathIcon Data="{StaticResource PlayIcon}"
                                  Width="14" Height="14"
                                  IsVisible="{Binding !IsExecuting}" />
                        <!-- Loading spinner when executing -->
                        <PathIcon Data="{StaticResource SpinnerIcon}"
                                  Width="14" Height="14"
                                  IsVisible="{Binding IsExecuting}"
                                  Classes="spinning" />
                        <TextBlock Text="{Binding IsExecuting, Converter={StaticResource BoolToTextConverter}, ConverterParameter=Running...|Run}"
                                   FontSize="12" />
                    </StackPanel>
                </Button>

                <!-- Status Message (transient) -->
                <TextBlock Text="{Binding StatusMessage}"
                           IsVisible="{Binding StatusMessage, Converter={x:Static StringConverters.IsNotNullOrEmpty}}"
                           FontSize="11"
                           Foreground="{DynamicResource TextMuted}"
                           VerticalAlignment="Center"
                           Margin="8,0,0,0" />
            </StackPanel>

            <!-- Danger Warning Panel -->
            <Border Grid.Row="3"
                    Classes="danger-warning"
                    IsVisible="{Binding ShowDangerWarning}">
                <StackPanel Spacing="8">
                    <StackPanel Orientation="Horizontal" Spacing="8">
                        <PathIcon Data="{StaticResource WarningIcon}"
                                  Width="16" Height="16"
                                  Foreground="{DynamicResource DangerBrush}" />
                        <TextBlock Text="Warning: Potentially Dangerous Command"
                                   FontWeight="SemiBold"
                                   Foreground="{DynamicResource DangerBrush}" />
                    </StackPanel>

                    <TextBlock Text="{Binding DangerWarning}"
                               TextWrapping="Wrap"
                               FontSize="12" />

                    <StackPanel Orientation="Horizontal" Spacing="8" Margin="0,4,0,0">
                        <Button Content="Cancel"
                                Command="{Binding CancelDangerCommand}"
                                Padding="12,4" />
                        <Button Content="I understand, proceed"
                                Command="{Binding ConfirmDangerCommand}"
                                Background="{DynamicResource DangerBrush}"
                                Foreground="White"
                                Padding="12,4" />
                    </StackPanel>
                </StackPanel>
            </Border>
        </Grid>
    </Border>
</UserControl>
```

### CommandBlockControl.axaml.cs

```csharp
namespace SeniorIntern.Desktop.Controls;

using Avalonia.Controls;

public partial class CommandBlockControl : UserControl
{
    public CommandBlockControl()
    {
        InitializeComponent();
    }
}
```

### Theme Additions (Dark.axaml)

```xml
<!-- Command Block Colors -->
<Color x:Key="CommandBlockBackgroundColor">#1E1E2E</Color>
<Color x:Key="CommandBlockBorderColor">#313244</Color>
<Color x:Key="CodeBlockBackgroundColor">#11111B</Color>
<Color x:Key="TerminalPromptColorValue">#89B4FA</Color>
<Color x:Key="CodeForegroundColor">#CDD6F4</Color>
<Color x:Key="BadgeBackgroundColor">#45475A</Color>
<Color x:Key="BadgeForegroundColor">#BAC2DE</Color>
<Color x:Key="DangerColorValue">#F38BA8</Color>
<Color x:Key="DangerBackgroundColorValue">#F38BA820</Color>
<Color x:Key="StatusBadgeBackgroundColor">#585B70</Color>
<Color x:Key="SuccessColorValue">#A6E3A1</Color>

<SolidColorBrush x:Key="CommandBlockBackground" Color="{StaticResource CommandBlockBackgroundColor}" />
<SolidColorBrush x:Key="CommandBlockBorder" Color="{StaticResource CommandBlockBorderColor}" />
<SolidColorBrush x:Key="CodeBlockBackground" Color="{StaticResource CodeBlockBackgroundColor}" />
<SolidColorBrush x:Key="TerminalPromptColor" Color="{StaticResource TerminalPromptColorValue}" />
<SolidColorBrush x:Key="CodeForeground" Color="{StaticResource CodeForegroundColor}" />
<SolidColorBrush x:Key="BadgeBackground" Color="{StaticResource BadgeBackgroundColor}" />
<SolidColorBrush x:Key="BadgeForeground" Color="{StaticResource BadgeForegroundColor}" />
<SolidColorBrush x:Key="DangerBrush" Color="{StaticResource DangerColorValue}" />
<SolidColorBrush x:Key="DangerBackgroundBrush" Color="{StaticResource DangerBackgroundColorValue}" />
<SolidColorBrush x:Key="StatusBadgeBackground" Color="{StaticResource StatusBadgeBackgroundColor}" />
<SolidColorBrush x:Key="SuccessBrush" Color="{StaticResource SuccessColorValue}" />
<SolidColorBrush x:Key="ErrorBrush" Color="{StaticResource DangerColorValue}" />
```

### v0.5.4f Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/Controls/CommandBlockControl.axaml` | Command block UI |
| `src/SeniorIntern.Desktop/Controls/CommandBlockControl.axaml.cs` | Code-behind |

### v0.5.4f Files to Modify

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/Themes/Dark.axaml` | Add command block colors |
| `src/SeniorIntern.Desktop/Themes/Light.axaml` | Add command block colors (light variants) |
| `src/SeniorIntern.Desktop/Assets/Icons.axaml` | Add PlayIcon, WarningIcon, SpinnerIcon |

### v0.5.4f Verification

```bash
# Build and visually test
dotnet build src/SeniorIntern.Desktop
dotnet run --project src/SeniorIntern.Desktop
```

### v0.5.4f Acceptance Criteria

- [ ] Command blocks render with proper styling
- [ ] Action buttons are visible and functional
- [ ] Status badges display correctly
- [ ] Danger warning shows for dangerous commands
- [ ] Confirmation flow works
- [ ] Loading spinner shows during execution
- [ ] Dark and light themes both look correct

---

## v0.5.4g: Terminal Context Attachment

### Objective
Enable users to attach terminal output to chat context for AI assistance with debugging, error diagnosis, and command help.

### TerminalContextViewModel

```csharp
namespace SeniorIntern.Desktop.ViewModels;

using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models.Terminal;

/// <summary>
/// ViewModel for terminal context attached to chat
/// </summary>
public partial class TerminalContextViewModel : ViewModelBase
{
    private readonly IOutputCaptureService _captureService;
    private readonly ITerminalService _terminalService;

    [ObservableProperty]
    private TerminalOutputCapture? _capture;

    [ObservableProperty]
    private bool _isExpanded;

    /// <summary>
    /// Display name for the context pill
    /// </summary>
    public string DisplayName => Capture?.SessionName ?? "Terminal Output";

    /// <summary>
    /// Preview of the captured output
    /// </summary>
    public string Preview
    {
        get
        {
            if (Capture == null)
                return string.Empty;

            var preview = Capture.Output;
            if (preview.Length > 100)
            {
                preview = preview[..97] + "...";
            }
            return preview.Replace('\n', ' ');
        }
    }

    /// <summary>
    /// Estimated token count
    /// </summary>
    public int EstimatedTokens => Capture?.EstimatedTokens ?? 0;

    /// <summary>
    /// Whether the capture was truncated
    /// </summary>
    public bool IsTruncated => Capture?.IsTruncated ?? false;

    /// <summary>
    /// Working directory at capture time
    /// </summary>
    public string? WorkingDirectory => Capture?.WorkingDirectory;

    /// <summary>
    /// Command that was run (if any)
    /// </summary>
    public string? Command => Capture?.Command;

    /// <summary>
    /// Formatted context string for AI
    /// </summary>
    public string ContextString => Capture?.ToContextString() ?? string.Empty;

    public TerminalContextViewModel(
        IOutputCaptureService captureService,
        ITerminalService terminalService)
    {
        _captureService = captureService;
        _terminalService = terminalService;
    }

    [RelayCommand]
    private void ToggleExpand()
    {
        IsExpanded = !IsExpanded;
    }

    [RelayCommand]
    private async Task RefreshAsync()
    {
        if (Capture == null)
            return;

        // Re-capture from same session
        var newCapture = await _captureService.CaptureBufferAsync(
            Capture.SessionId,
            Capture.CaptureMode);

        Capture = newCapture;
    }

    partial void OnCaptureChanged(TerminalOutputCapture? value)
    {
        OnPropertyChanged(nameof(DisplayName));
        OnPropertyChanged(nameof(Preview));
        OnPropertyChanged(nameof(EstimatedTokens));
        OnPropertyChanged(nameof(IsTruncated));
        OnPropertyChanged(nameof(WorkingDirectory));
        OnPropertyChanged(nameof(Command));
        OnPropertyChanged(nameof(ContextString));
    }
}
```

### ChatViewModel Terminal Context Extensions

```csharp
// Additions to ChatViewModel.cs

public partial class ChatViewModel : ViewModelBase
{
    private readonly IOutputCaptureService _outputCaptureService;
    private readonly ITerminalService _terminalService;

    // ... existing fields ...

    [ObservableProperty]
    private TerminalContextViewModel? _attachedTerminalContext;

    [ObservableProperty]
    private bool _hasActiveTerminal;

    /// <summary>
    /// Whether terminal output is attached
    /// </summary>
    public bool HasTerminalContext => AttachedTerminalContext?.Capture != null;

    [RelayCommand(CanExecute = nameof(HasActiveTerminal))]
    private async Task AttachTerminalOutputAsync()
    {
        var activeSession = _terminalService.ActiveSession;
        if (activeSession == null)
            return;

        var capture = await _outputCaptureService.CaptureBufferAsync(
            activeSession.Id,
            OutputCaptureMode.FullBuffer);

        AttachedTerminalContext = new TerminalContextViewModel(_outputCaptureService, _terminalService)
        {
            Capture = capture
        };

        OnPropertyChanged(nameof(HasTerminalContext));
    }

    [RelayCommand]
    private async Task AttachLastCommandOutputAsync()
    {
        var activeSession = _terminalService.ActiveSession;
        if (activeSession == null)
            return;

        var capture = await _outputCaptureService.CaptureBufferAsync(
            activeSession.Id,
            OutputCaptureMode.LastNLines,
            lineCount: 50);

        AttachedTerminalContext = new TerminalContextViewModel(_outputCaptureService, _terminalService)
        {
            Capture = capture
        };

        OnPropertyChanged(nameof(HasTerminalContext));
    }

    [RelayCommand]
    private async Task AttachSelectionAsync()
    {
        var activeSession = _terminalService.ActiveSession;
        if (activeSession == null)
            return;

        var capture = await _outputCaptureService.CaptureSelectionAsync(activeSession.Id);
        if (capture == null)
            return;

        AttachedTerminalContext = new TerminalContextViewModel(_outputCaptureService, _terminalService)
        {
            Capture = capture
        };

        OnPropertyChanged(nameof(HasTerminalContext));
    }

    [RelayCommand]
    private void ClearTerminalContext()
    {
        AttachedTerminalContext = null;
        OnPropertyChanged(nameof(HasTerminalContext));
    }

    /// <summary>
    /// Build context string including terminal output
    /// </summary>
    private string BuildContextPrompt()
    {
        var sb = new StringBuilder();

        // Existing file contexts
        foreach (var ctx in AttachedContexts)
        {
            sb.AppendLine($"--- File: {ctx.FileName} ---");
            sb.AppendLine(ctx.Content);
            sb.AppendLine();
        }

        // Terminal context
        if (AttachedTerminalContext?.Capture != null)
        {
            sb.AppendLine("--- Terminal Output ---");
            sb.AppendLine(AttachedTerminalContext.ContextString);
            sb.AppendLine();
        }

        return sb.ToString();
    }

    private void UpdateHasActiveTerminal()
    {
        HasActiveTerminal = _terminalService.ActiveSession != null;
    }
}
```

### v0.5.4g Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/ViewModels/TerminalContextViewModel.cs` | Terminal context ViewModel |

### v0.5.4g Files to Modify

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/ViewModels/ChatViewModel.cs` | Add terminal context attachment |

### v0.5.4g Verification

```bash
# Run ViewModel tests
dotnet test --filter "TerminalContext"
```

### v0.5.4g Acceptance Criteria

- [ ] Terminal output can be captured and attached
- [ ] Full buffer capture works
- [ ] Last N lines capture works
- [ ] Selection capture works
- [ ] Context is included in AI prompts
- [ ] Token count is displayed
- [ ] Truncation indicator shows when relevant
- [ ] Context can be cleared

---

## v0.5.4h: Chat Integration

### Objective
Integrate command extraction into the chat message flow, update the context bar with terminal attachment UI, and add keyboard shortcuts for common operations.

### ChatMessageViewModel Updates

```csharp
// Additions to ChatMessageViewModel.cs

public partial class ChatMessageViewModel : ViewModelBase
{
    private readonly ICommandExtractorService _commandExtractor;
    private readonly CommandBlockViewModelFactory _commandBlockFactory;

    // ... existing fields ...

    [ObservableProperty]
    private ObservableCollection<CommandBlockViewModel> _commandBlocks = new();

    /// <summary>
    /// Whether this message contains executable commands
    /// </summary>
    public bool HasCommands => CommandBlocks.Count > 0;

    /// <summary>
    /// Number of commands in the message
    /// </summary>
    public int CommandCount => CommandBlocks.Count;

    /// <summary>
    /// Number of dangerous commands
    /// </summary>
    public int DangerousCommandCount => CommandBlocks.Count(c => c.IsDangerous);

    /// <summary>
    /// Extract commands when content changes
    /// </summary>
    partial void OnContentChanged(string? value)
    {
        if (Role != MessageRole.Assistant || string.IsNullOrEmpty(value))
        {
            CommandBlocks.Clear();
            return;
        }

        ExtractCommands(value);
    }

    private void ExtractCommands(string content)
    {
        var result = _commandExtractor.ExtractCommands(content, Id);

        CommandBlocks.Clear();
        foreach (var cmd in result.Commands)
        {
            CommandBlocks.Add(_commandBlockFactory.Create(cmd));
        }

        OnPropertyChanged(nameof(HasCommands));
        OnPropertyChanged(nameof(CommandCount));
        OnPropertyChanged(nameof(DangerousCommandCount));
    }

    /// <summary>
    /// Execute all commands in sequence
    /// </summary>
    [RelayCommand]
    private async Task ExecuteAllCommandsAsync()
    {
        foreach (var block in CommandBlocks)
        {
            await block.ExecuteCommand.ExecuteAsync(null);

            // Stop if one fails
            if (block.Status == CommandBlockStatus.Failed)
                break;
        }
    }

    /// <summary>
    /// Copy all commands to clipboard
    /// </summary>
    [RelayCommand]
    private async Task CopyAllCommandsAsync()
    {
        var allCommands = string.Join("\n", CommandBlocks.Select(b => b.CommandText));
        await Clipboard.SetTextAsync(allCommands);
    }
}
```

### ChatContextBar Updates

```xml
<!-- Additions to ChatView.axaml for context bar -->

<!-- Terminal Context Pill -->
<Border Classes="context-pill"
        IsVisible="{Binding HasTerminalContext}"
        Margin="0,0,4,4"
        ToolTip.Tip="{Binding AttachedTerminalContext.Preview}">
    <Grid ColumnDefinitions="Auto,*,Auto,Auto">
        <PathIcon Grid.Column="0"
                  Data="{StaticResource TerminalIcon}"
                  Width="12" Height="12"
                  Margin="0,0,6,0" />

        <TextBlock Grid.Column="1"
                   Text="{Binding AttachedTerminalContext.DisplayName}"
                   FontSize="12"
                   VerticalAlignment="Center" />

        <TextBlock Grid.Column="2"
                   Text="{Binding AttachedTerminalContext.EstimatedTokens, StringFormat='~{0} tokens'}"
                   FontSize="10"
                   Foreground="{DynamicResource TextMuted}"
                   VerticalAlignment="Center"
                   Margin="8,0" />

        <Button Grid.Column="3"
                Command="{Binding ClearTerminalContextCommand}"
                Classes="pill-close"
                ToolTip.Tip="Remove terminal context">
            <PathIcon Data="{StaticResource CloseIcon}" Width="8" Height="8" />
        </Button>
    </Grid>
</Border>

<!-- Terminal Attachment Menu Button -->
<Button ToolTip.Tip="Attach terminal output"
        IsEnabled="{Binding HasActiveTerminal}">
    <Button.Flyout>
        <MenuFlyout Placement="TopEdgeAlignedLeft">
            <MenuItem Header="Attach Full Output"
                      Command="{Binding AttachTerminalOutputCommand}">
                <MenuItem.Icon>
                    <PathIcon Data="{StaticResource TerminalIcon}" />
                </MenuItem.Icon>
            </MenuItem>
            <MenuItem Header="Attach Last Command"
                      Command="{Binding AttachLastCommandOutputCommand}">
                <MenuItem.Icon>
                    <PathIcon Data="{StaticResource CommandIcon}" />
                </MenuItem.Icon>
            </MenuItem>
            <MenuItem Header="Attach Selection"
                      Command="{Binding AttachSelectionCommand}">
                <MenuItem.Icon>
                    <PathIcon Data="{StaticResource SelectionIcon}" />
                </MenuItem.Icon>
            </MenuItem>
        </MenuFlyout>
    </Button.Flyout>
    <PathIcon Data="{StaticResource TerminalIcon}" Width="14" Height="14" />
</Button>
```

### Keyboard Shortcuts

```csharp
// Additions to MainWindow.axaml.cs for keyboard shortcuts

private void InitializeKeyboardShortcuts()
{
    KeyBindings.Add(new KeyBinding
    {
        Gesture = new KeyGesture(Key.T, KeyModifiers.Control | KeyModifiers.Shift),
        Command = new RelayCommand(() => AttachTerminalOutput())
    });

    KeyBindings.Add(new KeyBinding
    {
        Gesture = new KeyGesture(Key.Enter, KeyModifiers.Control | KeyModifiers.Shift),
        Command = new RelayCommand(() => ExecuteSelectedCommand())
    });
}
```

### v0.5.4h Files to Modify

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/ViewModels/ChatMessageViewModel.cs` | Add command extraction |
| `src/SeniorIntern.Desktop/Views/ChatView.axaml` | Add terminal context UI |
| `src/SeniorIntern.Desktop/Views/MainWindow.axaml.cs` | Add keyboard shortcuts |
| `src/SeniorIntern.Desktop/Views/ChatMessageView.axaml` | Render command blocks |

### v0.5.4h Verification

```bash
# Build and test
dotnet build src/SeniorIntern.Desktop
dotnet run --project src/SeniorIntern.Desktop
```

### v0.5.4h Acceptance Criteria

- [ ] Commands are extracted from assistant messages
- [ ] Command blocks render in chat
- [ ] Context bar shows terminal attachment
- [ ] Attachment menu works
- [ ] Keyboard shortcuts function
- [ ] Execute all commands works
- [ ] Copy all commands works

---

## Testing Strategy

### Unit Tests

| Test Class | Coverage |
|------------|----------|
| `CommandBlockTests` | Model properties, serialization |
| `CommandExtractorServiceTests` | Extraction patterns, shell detection, danger checks |
| `CommandExecutionServiceTests` | Copy, send, execute workflows |
| `OutputCaptureServiceTests` | Capture modes, truncation, ANSI stripping |
| `CommandBlockViewModelTests` | UI logic, status updates |

### Integration Tests

| Test Class | Coverage |
|------------|----------|
| `CommandIntegrationTests` | Full flow from extraction to execution |
| `TerminalContextIntegrationTests` | Capture and attachment flow |

### Test Data

```csharp
public static class CommandTestData
{
    public static string MessageWithBashCommand = """
        To install the dependencies, run:

        ```bash
        npm install
        ```

        This will install all required packages.
        """;

    public static string MessageWithMultipleCommands = """
        First, build the project:

        ```bash
        dotnet build
        ```

        Then run the tests:

        ```bash
        dotnet test
        ```
        """;

    public static string MessageWithDangerousCommand = """
        To clean up, you can run:

        ```bash
        rm -rf node_modules/
        ```

        This will remove all dependencies.
        """;

    public static string MessageWithPowerShell = """
        On Windows, use PowerShell:

        ```powershell
        Get-ChildItem -Recurse | Where-Object { $_.Extension -eq ".log" }
        ```
        """;

    public static string MessageWithInlineCommand = """
        Run the following command: `npm start`

        This will start the development server.
        """;
}
```

---

## Files Summary

### Files to Create (v0.5.4)

| Part | File | Purpose |
|------|------|---------|
| a | `src/SeniorIntern.Core/Models/Terminal/CommandBlock.cs` | Command block model |
| a | `src/SeniorIntern.Core/Models/Terminal/CommandBlockStatus.cs` | Status enum |
| a | `src/SeniorIntern.Core/Models/Terminal/TerminalOutputCapture.cs` | Output capture model |
| a | `src/SeniorIntern.Core/Models/Terminal/OutputCaptureMode.cs` | Capture mode enum |
| a | `src/SeniorIntern.Core/Models/Terminal/CommandExtractionResult.cs` | Extraction result |
| a | `src/SeniorIntern.Core/Models/Terminal/TextRange.cs` | Text range struct |
| b | `src/SeniorIntern.Core/Interfaces/ICommandExtractorService.cs` | Extractor interface |
| b | `src/SeniorIntern.Services/Terminal/CommandExtractorService.cs` | Extractor implementation |
| c | `src/SeniorIntern.Core/Interfaces/ICommandExecutionService.cs` | Execution interface |
| c | `src/SeniorIntern.Core/Models/Terminal/CommandExecutionResult.cs` | Execution result |
| c | `src/SeniorIntern.Core/Models/Terminal/CommandStatusChangedEventArgs.cs` | Event args |
| c | `src/SeniorIntern.Services/Terminal/CommandExecutionService.cs` | Execution implementation |
| d | `src/SeniorIntern.Core/Interfaces/IOutputCaptureService.cs` | Capture interface |
| d | `src/SeniorIntern.Core/Models/Terminal/OutputCaptureSettings.cs` | Capture settings |
| d | `src/SeniorIntern.Core/Models/Terminal/TruncationMode.cs` | Truncation enum |
| d | `src/SeniorIntern.Services/Terminal/OutputCaptureService.cs` | Capture implementation |
| e | `src/SeniorIntern.Desktop/ViewModels/CommandBlockViewModel.cs` | Command VM |
| e | `src/SeniorIntern.Desktop/ViewModels/CommandBlockViewModelFactory.cs` | VM factory |
| f | `src/SeniorIntern.Desktop/Controls/CommandBlockControl.axaml` | Command UI |
| f | `src/SeniorIntern.Desktop/Controls/CommandBlockControl.axaml.cs` | Code-behind |
| g | `src/SeniorIntern.Desktop/ViewModels/TerminalContextViewModel.cs` | Context VM |

**Total: 21 files to create**

### Files to Modify (v0.5.4)

| Part | File | Changes |
|------|------|---------|
| b | `src/SeniorIntern.Services/DependencyInjection.cs` | Register ICommandExtractorService |
| c | `src/SeniorIntern.Services/DependencyInjection.cs` | Register ICommandExecutionService |
| d | `src/SeniorIntern.Services/DependencyInjection.cs` | Register IOutputCaptureService |
| d | `src/SeniorIntern.Core/Models/Terminal/TerminalBuffer.cs` | Add GetLastLines, GetSelectedText |
| e | `src/SeniorIntern.Desktop/DependencyInjection.cs` | Register factory |
| f | `src/SeniorIntern.Desktop/Themes/Dark.axaml` | Add command block colors |
| f | `src/SeniorIntern.Desktop/Themes/Light.axaml` | Add command block colors |
| f | `src/SeniorIntern.Desktop/Assets/Icons.axaml` | Add icons |
| g | `src/SeniorIntern.Desktop/ViewModels/ChatViewModel.cs` | Add terminal context |
| h | `src/SeniorIntern.Desktop/ViewModels/ChatMessageViewModel.cs` | Add command extraction |
| h | `src/SeniorIntern.Desktop/Views/ChatView.axaml` | Add terminal context UI |
| h | `src/SeniorIntern.Desktop/Views/MainWindow.axaml.cs` | Add shortcuts |
| h | `src/SeniorIntern.Desktop/Views/ChatMessageView.axaml` | Render commands |

**Total: 13 files to modify**

---

## Dependencies

### Internal Dependencies

| v0.5.4 Part | Depends On |
|-------------|------------|
| v0.5.4b | v0.5.4a (CommandBlock model), v0.5.3 (ShellType) |
| v0.5.4c | v0.5.4a, v0.5.4b, v0.5.1 (ITerminalService), v0.5.3 (IShellProfileService) |
| v0.5.4d | v0.5.4a, v0.5.1 (ITerminalService, TerminalBuffer) |
| v0.5.4e | v0.5.4a, v0.5.4c |
| v0.5.4f | v0.5.4e |
| v0.5.4g | v0.5.4d |
| v0.5.4h | v0.5.4b, v0.5.4e, v0.5.4f, v0.5.4g |

### External Dependencies

- v0.5.1 (Terminal Foundation)
- v0.5.2 (Terminal UI)
- v0.5.3 (Shell Integration)
- v0.4.1 (Code Block Extraction - for patterns)

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| False positive command detection | Medium | Low | Confidence scoring, user can ignore |
| Dangerous command bypassed | Low | High | Multiple pattern checks, confirmation required |
| Output capture too large | Medium | Medium | Configurable limits, smart truncation |
| Command execution timing issues | Medium | Medium | Shell integration markers (OSC 133) |
| Cross-platform shell differences | Medium | Medium | Shell-specific configurations |

---

## Acceptance Criteria

### v0.5.4 Complete

- [ ] Commands are extracted from AI messages automatically
- [ ] Fenced code blocks with shell languages are detected
- [ ] Heuristic detection works for unlabeled blocks
- [ ] Dangerous commands are flagged and require confirmation
- [ ] Commands can be copied, sent, or executed
- [ ] Command status is tracked and displayed
- [ ] Terminal output can be captured and attached to context
- [ ] Multiple capture modes work (full, last N, selection)
- [ ] Output is properly truncated when too large
- [ ] Context is included in AI prompts
- [ ] Command blocks render properly in chat
- [ ] Keyboard shortcuts work
- [ ] Dark and light themes supported
- [ ] All unit tests pass
- [ ] Integration tests pass
