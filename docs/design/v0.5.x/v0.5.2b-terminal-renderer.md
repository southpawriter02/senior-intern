# Design Specification: AIntern v0.5.2b "Terminal Renderer"

## Overview

**Version**: v0.5.2b
**Parent**: v0.5.2 Terminal UI
**Focus**: SkiaSharp-based terminal buffer rendering with font metrics and cell drawing

### Purpose

This sub-version creates the core rendering infrastructure for the terminal UI:
1. `TerminalFontMetrics` class for font measurement and coordinate calculations
2. `TerminalRenderer` Avalonia control for rendering the terminal buffer using SkiaSharp
3. `TerminalRenderOperation` nested class implementing `ICustomDrawOperation` for hardware-accelerated rendering

### Dependencies

**From v0.5.1b (Terminal Models)**:
- `TerminalBuffer` - The buffer containing terminal lines and cells
- `TerminalLine` - A single line of terminal cells
- `TerminalCell` - Individual character cell with attributes
- `TerminalColor` - Color representation (default, palette, RGB modes)
- `TerminalAttributes` - Text styling flags (bold, dim, underline, etc.)
- `TerminalSelection` - Selection range for text highlighting

**From v0.5.2a (Theme & Styles)**:
- `TerminalTheme` - Color theme with 256-color palette support
- `CursorStyle` - Cursor appearance enum (Block, Underline, Bar)

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                      v0.5.2b Terminal Renderer Architecture                   │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                        Font Metrics Layer                                │ │
│  │  src/AIntern.Desktop/Controls/Terminal/                                 │ │
│  ├─────────────────────────────────────────────────────────────────────────┤ │
│  │                                                                          │ │
│  │  ┌────────────────────────────────────────────────────────────────────┐ │ │
│  │  │                      TerminalFontMetrics                            │ │ │
│  │  │  ┌─────────────────────────────────────────────────────────────┐   │ │ │
│  │  │  │  Private Fields:                                             │   │ │ │
│  │  │  │  ├── _typeface: SKTypeface?                                  │   │ │ │
│  │  │  │  └── _measurePaint: SKPaint?                                 │   │ │ │
│  │  │  └─────────────────────────────────────────────────────────────┘   │ │ │
│  │  │  ┌─────────────────────────────────────────────────────────────┐   │ │ │
│  │  │  │  Properties:                                                 │   │ │ │
│  │  │  │  ├── Typeface: SKTypeface (readonly)                        │   │ │ │
│  │  │  │  ├── FontSize: float                                        │   │ │ │
│  │  │  │  ├── CharWidth: float                                       │   │ │ │
│  │  │  │  ├── LineHeight: float                                      │   │ │ │
│  │  │  │  ├── Baseline: float                                        │   │ │ │
│  │  │  │  ├── Ascent: float                                          │   │ │ │
│  │  │  │  ├── Descent: float                                         │   │ │ │
│  │  │  │  └── IsValid: bool                                          │   │ │ │
│  │  │  └─────────────────────────────────────────────────────────────┘   │ │ │
│  │  │  ┌─────────────────────────────────────────────────────────────┐   │ │ │
│  │  │  │  Methods:                                                    │   │ │ │
│  │  │  │  ├── Update(fontFamily, fontSize)                           │   │ │ │
│  │  │  │  ├── CalculateTerminalSize(width, height) → (cols, rows)    │   │ │ │
│  │  │  │  ├── PixelToCell(x, y) → (column, row)                      │   │ │ │
│  │  │  │  ├── CellToPixel(column, row) → (x, y)                      │   │ │ │
│  │  │  │  ├── CreateTextPaint(bold, italic) → SKPaint                │   │ │ │
│  │  │  │  └── Dispose()                                               │   │ │ │
│  │  │  └─────────────────────────────────────────────────────────────┘   │ │ │
│  │  │                                                                      │ │ │
│  │  │  Implements: IDisposable                                            │ │ │
│  │  └────────────────────────────────────────────────────────────────────┘ │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                        Renderer Control Layer                            │ │
│  │  src/AIntern.Desktop/Controls/Terminal/                                 │ │
│  ├─────────────────────────────────────────────────────────────────────────┤ │
│  │                                                                          │ │
│  │  ┌────────────────────────────────────────────────────────────────────┐ │ │
│  │  │                       TerminalRenderer                              │ │ │
│  │  │  Extends: Avalonia.Controls.Control                                 │ │ │
│  │  │  ┌─────────────────────────────────────────────────────────────┐   │ │ │
│  │  │  │  Private Fields:                                             │   │ │ │
│  │  │  │  ├── _buffer: TerminalBuffer?                               │   │ │ │
│  │  │  │  ├── _theme: TerminalTheme                                  │   │ │ │
│  │  │  │  ├── _fontMetrics: TerminalFontMetrics                      │   │ │ │
│  │  │  │  ├── _selection: TerminalSelection?                         │   │ │ │
│  │  │  │  └── _cursorVisible: bool                                   │   │ │ │
│  │  │  └─────────────────────────────────────────────────────────────┘   │ │ │
│  │  │  ┌─────────────────────────────────────────────────────────────┐   │ │ │
│  │  │  │  Styled Properties:                                          │   │ │ │
│  │  │  │  ├── FontFamily: string (default: "Cascadia Mono")          │   │ │ │
│  │  │  │  └── FontSize: double (default: 14.0)                       │   │ │ │
│  │  │  └─────────────────────────────────────────────────────────────┘   │ │ │
│  │  │  ┌─────────────────────────────────────────────────────────────┐   │ │ │
│  │  │  │  Public Properties:                                          │   │ │ │
│  │  │  │  ├── Metrics: TerminalFontMetrics (readonly)                │   │ │ │
│  │  │  │  ├── Selection: TerminalSelection? (invalidates on set)     │   │ │ │
│  │  │  │  └── CursorVisible: bool (invalidates on change)            │   │ │ │
│  │  │  └─────────────────────────────────────────────────────────────┘   │ │ │
│  │  │  ┌─────────────────────────────────────────────────────────────┐   │ │ │
│  │  │  │  Methods:                                                    │   │ │ │
│  │  │  │  ├── SetBuffer(buffer) - Subscribe to ContentChanged       │   │ │ │
│  │  │  │  ├── SetTheme(theme) - Apply color theme                    │   │ │ │
│  │  │  │  ├── Render(context) - Dispatch TerminalRenderOperation     │   │ │ │
│  │  │  │  └── IsFocused (computed property)                          │   │ │ │
│  │  │  └─────────────────────────────────────────────────────────────┘   │ │ │
│  │  │  ┌─────────────────────────────────────────────────────────────┐   │ │ │
│  │  │  │  Overrides:                                                  │   │ │ │
│  │  │  │  ├── OnPropertyChanged() - Update metrics on font change   │   │ │ │
│  │  │  │  └── OnLoaded() - Initialize font metrics                   │   │ │ │
│  │  │  └─────────────────────────────────────────────────────────────┘   │ │ │
│  │  └────────────────────────────────────────────────────────────────────┘ │ │
│  │                                                                          │ │
│  │  ┌────────────────────────────────────────────────────────────────────┐ │ │
│  │  │                    TerminalRenderOperation                          │ │ │
│  │  │  Nested in: TerminalRenderer (private sealed class)                │ │ │
│  │  │  Implements: ICustomDrawOperation                                   │ │ │
│  │  │  ┌─────────────────────────────────────────────────────────────┐   │ │ │
│  │  │  │  Constructor Parameters:                                     │   │ │ │
│  │  │  │  ├── bounds: Rect                                           │   │ │ │
│  │  │  │  ├── buffer: TerminalBuffer                                 │   │ │ │
│  │  │  │  ├── theme: TerminalTheme                                   │   │ │ │
│  │  │  │  ├── metrics: TerminalFontMetrics                           │   │ │ │
│  │  │  │  ├── selection: TerminalSelection?                          │   │ │ │
│  │  │  │  ├── showCursor: bool                                       │   │ │ │
│  │  │  │  └── isFocused: bool                                        │   │ │ │
│  │  │  └─────────────────────────────────────────────────────────────┘   │ │ │
│  │  │  ┌─────────────────────────────────────────────────────────────┐   │ │ │
│  │  │  │  Rendering Methods:                                          │   │ │ │
│  │  │  │  ├── Render(context) - Entry point via ISkiaSharpApiLease   │   │ │ │
│  │  │  │  ├── RenderTerminal(canvas) - Main rendering loop           │   │ │ │
│  │  │  │  ├── DrawCursor(canvas, charWidth, lineHeight)              │   │ │ │
│  │  │  │  ├── ResolveColor(color, isForeground) → SKColor            │   │ │ │
│  │  │  │  └── ToSKColor(color) → SKColor (static helper)             │   │ │ │
│  │  │  └─────────────────────────────────────────────────────────────┘   │ │ │
│  │  └────────────────────────────────────────────────────────────────────┘ │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                        Rendering Pipeline                                │ │
│  ├─────────────────────────────────────────────────────────────────────────┤ │
│  │                                                                          │ │
│  │  ┌───────────────┐    ┌─────────────────┐    ┌─────────────────────┐   │ │
│  │  │ Buffer.Content│───►│ InvalidateVisual│───►│    Render()         │   │ │
│  │  │    Changed    │    │    (UI Thread)   │    │                     │   │ │
│  │  └───────────────┘    └─────────────────┘    └──────────┬──────────┘   │ │
│  │                                                          │              │ │
│  │                                                          ▼              │ │
│  │  ┌─────────────────────────────────────────────────────────────────┐   │ │
│  │  │               TerminalRenderOperation.Render()                   │   │ │
│  │  │  ┌───────────────────────────────────────────────────────────┐  │   │ │
│  │  │  │  1. Get ISkiaSharpApiLeaseFeature from context            │  │   │ │
│  │  │  │  2. Lease the SkiaSharp API                                │  │   │ │
│  │  │  │  3. Get SKCanvas from lease                                │  │   │ │
│  │  │  │  4. Call RenderTerminal(canvas)                            │  │   │ │
│  │  │  └───────────────────────────────────────────────────────────┘  │   │ │
│  │  └─────────────────────────────────────────────────────────────────┘   │ │
│  │                                                                          │ │
│  │  ┌─────────────────────────────────────────────────────────────────┐   │ │
│  │  │                  RenderTerminal() Flow                           │   │ │
│  │  │  ┌───────────────────────────────────────────────────────────┐  │   │ │
│  │  │  │  1. Clear canvas with theme background color              │  │   │ │
│  │  │  │  2. Get visible lines from buffer                          │  │   │ │
│  │  │  │  3. For each line:                                         │  │   │ │
│  │  │  │     ├── For each cell in line:                            │  │   │ │
│  │  │  │     │   ├── Skip continuation cells                       │  │   │ │
│  │  │  │     │   ├── Draw cell background (if needed)              │  │   │ │
│  │  │  │     │   ├── Draw character (if visible)                   │  │   │ │
│  │  │  │     │   ├── Draw underline (if attribute set)             │  │   │ │
│  │  │  │     │   └── Draw strikethrough (if attribute set)         │  │   │ │
│  │  │  │     └── Advance y position                                │  │   │ │
│  │  │  │  4. Draw cursor (if visible and not scrolled)             │  │   │ │
│  │  │  └───────────────────────────────────────────────────────────┘  │   │ │
│  │  └─────────────────────────────────────────────────────────────────┘   │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Font Metrics System

The `TerminalFontMetrics` class handles all font-related calculations for proper terminal rendering:

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                           Font Metrics Calculations                           │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  Character Cell Dimensions                                               │ │
│  │  ┌───────────────────────────────────────────────────────────────────┐  │ │
│  │  │                                                                    │  │ │
│  │  │   ◄────────── CharWidth ──────────►                               │  │ │
│  │  │   ┌────────────────────────────────┐  ▲                           │  │ │
│  │  │   │                                │  │                           │  │ │
│  │  │   │          Ascent                │  │ Ascent                    │  │ │
│  │  │   │                                │  │                           │  │ │
│  │  │   ├────────────────────────────────┤  ▼  ─── Baseline ───        │  │ │
│  │  │   │          Descent               │  ▲                           │  │ │
│  │  │   │                                │  │ Descent                   │  │ │
│  │  │   └────────────────────────────────┘  ▼                           │  │ │
│  │  │   │          Leading               │     (optional spacing)       │  │ │
│  │  │   └────────────────────────────────┘                              │  │ │
│  │  │                                                                    │  │ │
│  │  │   LineHeight = Ascent + Descent + (Leading or 2px default)        │  │ │
│  │  └───────────────────────────────────────────────────────────────────┘  │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  Font Fallback Chain                                                     │ │
│  │  ┌───────────────────────────────────────────────────────────────────┐  │ │
│  │  │  1. Requested font family (e.g., "Cascadia Mono")                 │  │ │
│  │  │  2. "Consolas" (Windows fallback)                                 │  │ │
│  │  │  3. "Monaco" (macOS fallback)                                     │  │ │
│  │  │  4. "Courier New" (cross-platform fallback)                       │  │ │
│  │  │  5. SKTypeface.Default (system default)                           │  │ │
│  │  └───────────────────────────────────────────────────────────────────┘  │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  Coordinate Conversion                                                   │ │
│  │  ┌───────────────────────────────────────────────────────────────────┐  │ │
│  │  │  PixelToCell(x, y):                                               │  │ │
│  │  │    column = floor(x / CharWidth)                                  │  │ │
│  │  │    row = floor(y / LineHeight)                                    │  │ │
│  │  │                                                                    │  │ │
│  │  │  CellToPixel(column, row):                                        │  │ │
│  │  │    x = column * CharWidth                                         │  │ │
│  │  │    y = row * LineHeight                                           │  │ │
│  │  │                                                                    │  │ │
│  │  │  CalculateTerminalSize(width, height):                            │  │ │
│  │  │    columns = max(1, floor(width / CharWidth))                     │  │ │
│  │  │    rows = max(1, floor(height / LineHeight))                      │  │ │
│  │  │    Default fallback: (80, 24) if metrics invalid                  │  │ │
│  │  └───────────────────────────────────────────────────────────────────┘  │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Cell Rendering Details

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                           Cell Rendering Process                              │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  Background Rendering                                                    │ │
│  │  ┌───────────────────────────────────────────────────────────────────┐  │ │
│  │  │  Condition: Draw background when any of these are true:           │  │ │
│  │  │  ├── attrs.Background is not default                              │  │ │
│  │  │  ├── attrs.Inverse is true                                        │  │ │
│  │  │  └── cell is selected                                             │  │ │
│  │  │                                                                    │  │ │
│  │  │  Color Resolution Priority:                                       │  │ │
│  │  │  1. If selected → theme.Selection with SelectionAlpha             │  │ │
│  │  │  2. If inverse → Resolved foreground color as background          │  │ │
│  │  │  3. Otherwise → Resolved background color                         │  │ │
│  │  │                                                                    │  │ │
│  │  │  Rectangle: (x, y, CharWidth × cell.Width, LineHeight)            │  │ │
│  │  └───────────────────────────────────────────────────────────────────┘  │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  Character Rendering                                                     │ │
│  │  ┌───────────────────────────────────────────────────────────────────┐  │ │
│  │  │  Skip rendering when:                                             │  │ │
│  │  │  ├── Character is space (' ')                                     │  │ │
│  │  │  ├── Character is null (0)                                        │  │ │
│  │  │  └── attrs.Hidden is true                                         │  │ │
│  │  │                                                                    │  │ │
│  │  │  Color Resolution:                                                │  │ │
│  │  │  ├── If inverse → Background color as foreground                  │  │ │
│  │  │  └── Otherwise → Resolved foreground color                        │  │ │
│  │  │                                                                    │  │ │
│  │  │  Text Attributes Applied:                                         │  │ │
│  │  │  ├── Bold → SKPaint.FakeBoldText = true                          │  │ │
│  │  │  └── Dim → Color alpha reduced to 128 (50%)                       │  │ │
│  │  │                                                                    │  │ │
│  │  │  Position: (x, y + Baseline)                                      │  │ │
│  │  └───────────────────────────────────────────────────────────────────┘  │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  Text Decorations                                                        │ │
│  │  ┌───────────────────────────────────────────────────────────────────┐  │ │
│  │  │  Underline (if attrs.Underline):                                  │  │ │
│  │  │  ├── Y position: y + LineHeight - 2                               │  │ │
│  │  │  └── Line: (x, underlineY) to (x + CharWidth, underlineY)        │  │ │
│  │  │                                                                    │  │ │
│  │  │  Strikethrough (if attrs.Strikethrough):                          │  │ │
│  │  │  ├── Y position: y + LineHeight / 2                               │  │ │
│  │  │  └── Line: (x, strikeY) to (x + CharWidth, strikeY)              │  │ │
│  │  └───────────────────────────────────────────────────────────────────┘  │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  Wide Character Support                                                  │ │
│  │  ┌───────────────────────────────────────────────────────────────────┐  │ │
│  │  │  Wide characters (CJK, emoji) occupy 2 cells in terminal grid:   │  │ │
│  │  │                                                                    │  │ │
│  │  │  ┌──────────────────┬──────────────────┐                          │  │ │
│  │  │  │   Primary Cell   │ Continuation Cell │                          │  │ │
│  │  │  │   (Width = 2)    │ (IsContinuation)  │                          │  │ │
│  │  │  │      中          │        ×         │                          │  │ │
│  │  │  └──────────────────┴──────────────────┘                          │  │ │
│  │  │                                                                    │  │ │
│  │  │  Rendering Logic:                                                 │  │ │
│  │  │  ├── Check cell.IsContinuation → skip rendering                  │  │ │
│  │  │  ├── Use cell.Width for background rectangle width               │  │ │
│  │  │  └── Advance x by CharWidth × cell.Width                         │  │ │
│  │  └───────────────────────────────────────────────────────────────────┘  │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Cursor Rendering

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                             Cursor Rendering                                  │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  Cursor Visibility Conditions                                            │ │
│  │  ┌───────────────────────────────────────────────────────────────────┐  │ │
│  │  │  Cursor is drawn when ALL conditions are true:                    │  │ │
│  │  │  ├── _showCursor (combined from CursorVisible && buffer.Visible)  │  │ │
│  │  │  └── buffer.ScrollOffset == 0 (not scrolled back in history)     │  │ │
│  │  └───────────────────────────────────────────────────────────────────┘  │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  Cursor Styles                                                           │ │
│  │  ┌───────────────────────────────────────────────────────────────────┐  │ │
│  │  │                                                                    │  │ │
│  │  │  CursorStyle.Block                                                │  │ │
│  │  │  ┌────────────────────┐                                           │  │ │
│  │  │  │████████████████████│  Rectangle: full cell                     │  │ │
│  │  │  │████████████████████│  (x, y, CharWidth, LineHeight)            │  │ │
│  │  │  │████████████████████│                                           │  │ │
│  │  │  └────────────────────┘  Character drawn in inverse when focused  │  │ │
│  │  │                                                                    │  │ │
│  │  │  CursorStyle.Underline                                            │  │ │
│  │  │  ┌────────────────────┐                                           │  │ │
│  │  │  │                    │  Rectangle: bottom of cell                │  │ │
│  │  │  │                    │  (x, y + LineHeight - 2, CharWidth, 2)    │  │ │
│  │  │  │████████████████████│                                           │  │ │
│  │  │  └────────────────────┘                                           │  │ │
│  │  │                                                                    │  │ │
│  │  │  CursorStyle.Bar                                                  │  │ │
│  │  │  ┌────────────────────┐                                           │  │ │
│  │  │  │██                  │  Rectangle: left edge of cell             │  │ │
│  │  │  │██                  │  (x, y, 2, LineHeight)                    │  │ │
│  │  │  │██                  │                                           │  │ │
│  │  │  └────────────────────┘                                           │  │ │
│  │  │                                                                    │  │ │
│  │  └───────────────────────────────────────────────────────────────────┘  │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  Focus State Rendering                                                   │ │
│  │  ┌───────────────────────────────────────────────────────────────────┐  │ │
│  │  │  When focused (isFocused = true):                                 │  │ │
│  │  │  ├── SKPaintStyle.Fill (solid cursor)                            │  │ │
│  │  │  └── Block cursor: draw character underneath in inverse color    │  │ │
│  │  │                                                                    │  │ │
│  │  │  When unfocused (isFocused = false):                              │  │ │
│  │  │  ├── SKPaintStyle.Stroke (outline only)                          │  │ │
│  │  │  └── StrokeWidth = 1                                              │  │ │
│  │  └───────────────────────────────────────────────────────────────────┘  │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## SkiaSharp Integration

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                    Avalonia-SkiaSharp Integration                             │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  ICustomDrawOperation Interface                                          │ │
│  │  ┌───────────────────────────────────────────────────────────────────┐  │ │
│  │  │  Required Members:                                                │  │ │
│  │  │  ├── Rect Bounds { get; }                                         │  │ │
│  │  │  │   Returns the bounding rectangle of the drawing operation      │  │ │
│  │  │  │                                                                 │  │ │
│  │  │  ├── bool HitTest(Point p)                                        │  │ │
│  │  │  │   Returns true if point is within bounds (for input handling)  │  │ │
│  │  │  │                                                                 │  │ │
│  │  │  ├── bool Equals(ICustomDrawOperation? other)                     │  │ │
│  │  │  │   Return false to always re-render (terminal content changes) │  │ │
│  │  │  │                                                                 │  │ │
│  │  │  ├── void Render(ImmediateDrawingContext context)                 │  │ │
│  │  │  │   Entry point for SkiaSharp rendering                          │  │ │
│  │  │  │                                                                 │  │ │
│  │  │  └── void Dispose()                                                │  │ │
│  │  │      Cleanup (empty for this implementation)                       │  │ │
│  │  └───────────────────────────────────────────────────────────────────┘  │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  ISkiaSharpApiLeaseFeature Usage                                         │ │
│  │  ┌───────────────────────────────────────────────────────────────────┐  │ │
│  │  │  public void Render(ImmediateDrawingContext context)              │  │ │
│  │  │  {                                                                 │  │ │
│  │  │      // 1. Try to get the SkiaSharp feature                       │  │ │
│  │  │      var leaseFeature = context.TryGetFeature                     │  │ │
│  │  │          <ISkiaSharpApiLeaseFeature>();                           │  │ │
│  │  │                                                                    │  │ │
│  │  │      if (leaseFeature == null)                                    │  │ │
│  │  │          return;  // SkiaSharp not available                      │  │ │
│  │  │                                                                    │  │ │
│  │  │      // 2. Lease the API (disposable)                             │  │ │
│  │  │      using var lease = leaseFeature.Lease();                      │  │ │
│  │  │                                                                    │  │ │
│  │  │      // 3. Get the canvas                                         │  │ │
│  │  │      var canvas = lease.SkCanvas;                                 │  │ │
│  │  │                                                                    │  │ │
│  │  │      // 4. Perform rendering                                      │  │ │
│  │  │      RenderTerminal(canvas);                                      │  │ │
│  │  │  }                                                                 │  │ │
│  │  └───────────────────────────────────────────────────────────────────┘  │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  Required Using Directives                                               │ │
│  │  ┌───────────────────────────────────────────────────────────────────┐  │ │
│  │  │  using Avalonia.Platform;                                         │  │ │
│  │  │  using Avalonia.Rendering.SceneGraph;  // ICustomDrawOperation    │  │ │
│  │  │  using Avalonia.Skia;                  // ISkiaSharpApiLeaseFeature│ │ │
│  │  │  using SkiaSharp;                      // SKCanvas, SKPaint, etc. │  │ │
│  │  └───────────────────────────────────────────────────────────────────┘  │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Specifications

### 1. TerminalFontMetrics.cs

**Location**: `src/AIntern.Desktop/Controls/Terminal/TerminalFontMetrics.cs`
**Type**: `sealed class`
**Implements**: `IDisposable`
**Purpose**: Manage font measurement and coordinate conversion for terminal rendering

```csharp
namespace AIntern.Desktop.Controls.Terminal;

using SkiaSharp;

/// <summary>
/// Manages font metrics for terminal rendering.
/// Handles font loading, measurement, and coordinate conversion
/// between pixel positions and terminal cell coordinates.
/// </summary>
public sealed class TerminalFontMetrics : IDisposable
{
    private SKTypeface? _typeface;
    private SKPaint? _measurePaint;

    /// <summary>
    /// The loaded typeface for text rendering.
    /// Returns SKTypeface.Default if no typeface is loaded.
    /// </summary>
    public SKTypeface Typeface => _typeface ?? SKTypeface.Default;

    /// <summary>
    /// Font size in points.
    /// </summary>
    public float FontSize { get; private set; }

    /// <summary>
    /// Width of a single character cell in pixels.
    /// Measured using the 'M' character (em-width) for monospace fonts.
    /// </summary>
    public float CharWidth { get; private set; }

    /// <summary>
    /// Height of a line in pixels (ascent + descent + leading).
    /// </summary>
    public float LineHeight { get; private set; }

    /// <summary>
    /// Distance from top of cell to text baseline in pixels.
    /// Used for positioning text within cells.
    /// </summary>
    public float Baseline { get; private set; }

    /// <summary>
    /// Font ascent (distance from baseline to top of character) in pixels.
    /// </summary>
    public float Ascent { get; private set; }

    /// <summary>
    /// Font descent (distance from baseline to bottom of character) in pixels.
    /// </summary>
    public float Descent { get; private set; }

    /// <summary>
    /// Whether the metrics have been calculated and are valid for rendering.
    /// </summary>
    public bool IsValid => _typeface != null && CharWidth > 0;

    /// <summary>
    /// Updates the font and recalculates all metrics.
    /// </summary>
    /// <param name="fontFamily">The font family name to load.</param>
    /// <param name="fontSize">The font size in points.</param>
    /// <remarks>
    /// If the requested font family is not found, falls back through:
    /// Consolas → Monaco → Courier New → System Default
    /// </remarks>
    public void Update(string fontFamily, float fontSize)
    {
        FontSize = fontSize;

        // Try to load the requested font family
        _typeface?.Dispose();
        _typeface = SKTypeface.FromFamilyName(fontFamily, SKFontStyle.Normal);

        // Fall back to a monospace font if not found
        if (_typeface == null || _typeface.FamilyName != fontFamily)
        {
            _typeface?.Dispose();
            _typeface = SKTypeface.FromFamilyName("Consolas", SKFontStyle.Normal)
                ?? SKTypeface.FromFamilyName("Monaco", SKFontStyle.Normal)
                ?? SKTypeface.FromFamilyName("Courier New", SKFontStyle.Normal)
                ?? SKTypeface.Default;
        }

        CalculateMetrics();
    }

    /// <summary>
    /// Calculates font metrics using the current typeface and font size.
    /// </summary>
    private void CalculateMetrics()
    {
        _measurePaint?.Dispose();
        _measurePaint = new SKPaint
        {
            Typeface = _typeface,
            TextSize = FontSize,
            IsAntialias = true
        };

        // Measure character width using 'M' (em-width) for monospace
        CharWidth = _measurePaint.MeasureText("M");

        // Get font metrics
        var metrics = _measurePaint.FontMetrics;
        Ascent = -metrics.Ascent;
        Descent = metrics.Descent;
        LineHeight = Ascent + Descent + (metrics.Leading > 0 ? metrics.Leading : 2);
        Baseline = Ascent;
    }

    /// <summary>
    /// Calculates the terminal size in columns and rows for given pixel dimensions.
    /// </summary>
    /// <param name="width">Available width in pixels.</param>
    /// <param name="height">Available height in pixels.</param>
    /// <returns>A tuple of (columns, rows) for the terminal grid.</returns>
    /// <remarks>
    /// Returns (80, 24) as default if metrics are invalid or dimensions are non-positive.
    /// </remarks>
    public (int Columns, int Rows) CalculateTerminalSize(double width, double height)
    {
        if (!IsValid || width <= 0 || height <= 0)
            return (80, 24);

        var cols = Math.Max(1, (int)(width / CharWidth));
        var rows = Math.Max(1, (int)(height / LineHeight));

        return (cols, rows);
    }

    /// <summary>
    /// Converts pixel coordinates to terminal cell coordinates.
    /// </summary>
    /// <param name="x">X position in pixels.</param>
    /// <param name="y">Y position in pixels.</param>
    /// <returns>A tuple of (column, row) in the terminal grid.</returns>
    /// <remarks>
    /// Used for mouse input handling to determine which cell was clicked.
    /// Returns (0, 0) if metrics are invalid.
    /// </remarks>
    public (int Column, int Row) PixelToCell(double x, double y)
    {
        if (!IsValid)
            return (0, 0);

        var col = Math.Max(0, (int)(x / CharWidth));
        var row = Math.Max(0, (int)(y / LineHeight));

        return (col, row);
    }

    /// <summary>
    /// Converts terminal cell coordinates to pixel position.
    /// </summary>
    /// <param name="column">Column index in the terminal grid.</param>
    /// <param name="row">Row index in the terminal grid.</param>
    /// <returns>A tuple of (x, y) pixel coordinates for the top-left of the cell.</returns>
    public (float X, float Y) CellToPixel(int column, int row)
    {
        return (column * CharWidth, row * LineHeight);
    }

    /// <summary>
    /// Creates an SKPaint configured for rendering text with the specified attributes.
    /// </summary>
    /// <param name="bold">Whether to use bold font style.</param>
    /// <param name="italic">Whether to use italic font style.</param>
    /// <returns>A new SKPaint instance configured for text rendering.</returns>
    /// <remarks>
    /// The caller is responsible for disposing the returned SKPaint.
    /// </remarks>
    public SKPaint CreateTextPaint(bool bold = false, bool italic = false)
    {
        var style = SKFontStyle.Normal;

        if (bold && italic)
            style = SKFontStyle.BoldItalic;
        else if (bold)
            style = SKFontStyle.Bold;
        else if (italic)
            style = SKFontStyle.Italic;

        var typeface = _typeface;
        if (style != SKFontStyle.Normal)
        {
            typeface = SKTypeface.FromFamilyName(_typeface?.FamilyName ?? "monospace", style);
        }

        return new SKPaint
        {
            Typeface = typeface,
            TextSize = FontSize,
            IsAntialias = true
        };
    }

    /// <summary>
    /// Disposes of the font resources.
    /// </summary>
    public void Dispose()
    {
        _measurePaint?.Dispose();
        _typeface?.Dispose();
    }
}
```

---

### 2. TerminalRenderer.cs

**Location**: `src/AIntern.Desktop/Controls/Terminal/TerminalRenderer.cs`
**Type**: `class`
**Extends**: `Avalonia.Controls.Control`
**Purpose**: SkiaSharp-based Avalonia control for rendering the terminal buffer

```csharp
namespace AIntern.Desktop.Controls.Terminal;

using Avalonia;
using Avalonia.Controls;
using Avalonia.Media;
using Avalonia.Platform;
using Avalonia.Rendering.SceneGraph;
using Avalonia.Skia;
using AIntern.Core.Models.Terminal;
using SkiaSharp;

/// <summary>
/// SkiaSharp-based terminal buffer renderer.
/// Renders terminal cells, text attributes, cursor, and selection highlighting
/// using hardware-accelerated graphics through the Avalonia SkiaSharp backend.
/// </summary>
public class TerminalRenderer : Control
{
    private TerminalBuffer? _buffer;
    private TerminalTheme _theme = TerminalTheme.Dark;
    private readonly TerminalFontMetrics _fontMetrics = new();
    private TerminalSelection? _selection;
    private bool _cursorVisible = true;

    /// <summary>
    /// Styled property for the terminal font family.
    /// </summary>
    public static readonly StyledProperty<string> FontFamilyProperty =
        AvaloniaProperty.Register<TerminalRenderer, string>(nameof(FontFamily), "Cascadia Mono");

    /// <summary>
    /// Styled property for the terminal font size.
    /// </summary>
    public static readonly StyledProperty<double> FontSizeProperty =
        AvaloniaProperty.Register<TerminalRenderer, double>(nameof(FontSize), 14.0);

    /// <summary>
    /// Gets or sets the font family for terminal text.
    /// </summary>
    public string FontFamily
    {
        get => GetValue(FontFamilyProperty);
        set => SetValue(FontFamilyProperty, value);
    }

    /// <summary>
    /// Gets or sets the font size for terminal text.
    /// </summary>
    public double FontSize
    {
        get => GetValue(FontSizeProperty);
        set => SetValue(FontSizeProperty, value);
    }

    /// <summary>
    /// Gets the font metrics for calculating terminal dimensions.
    /// Used by parent controls to determine terminal size in cells.
    /// </summary>
    public TerminalFontMetrics Metrics => _fontMetrics;

    /// <summary>
    /// Gets or sets the current text selection.
    /// Setting this property invalidates the visual and triggers a re-render.
    /// </summary>
    public TerminalSelection? Selection
    {
        get => _selection;
        set
        {
            _selection = value;
            InvalidateVisual();
        }
    }

    /// <summary>
    /// Gets or sets whether the cursor should be visible.
    /// Used for cursor blink animation.
    /// </summary>
    public bool CursorVisible
    {
        get => _cursorVisible;
        set
        {
            if (_cursorVisible != value)
            {
                _cursorVisible = value;
                InvalidateVisual();
            }
        }
    }

    static TerminalRenderer()
    {
        AffectsRender<TerminalRenderer>(FontFamilyProperty, FontSizeProperty);
    }

    /// <summary>
    /// Initializes a new instance of the TerminalRenderer control.
    /// </summary>
    public TerminalRenderer()
    {
        ClipToBounds = true;
    }

    /// <inheritdoc />
    protected override void OnPropertyChanged(AvaloniaPropertyChangedEventArgs change)
    {
        base.OnPropertyChanged(change);

        if (change.Property == FontFamilyProperty || change.Property == FontSizeProperty)
        {
            _fontMetrics.Update(FontFamily, (float)FontSize);
            InvalidateVisual();
        }
    }

    /// <inheritdoc />
    protected override void OnLoaded(RoutedEventArgs e)
    {
        base.OnLoaded(e);
        _fontMetrics.Update(FontFamily, (float)FontSize);
    }

    /// <summary>
    /// Sets the terminal buffer to render.
    /// Subscribes to the buffer's ContentChanged event for automatic re-rendering.
    /// </summary>
    /// <param name="buffer">The terminal buffer to render.</param>
    public void SetBuffer(TerminalBuffer buffer)
    {
        if (_buffer != null)
        {
            _buffer.ContentChanged -= OnBufferContentChanged;
        }

        _buffer = buffer;

        if (_buffer != null)
        {
            _buffer.ContentChanged += OnBufferContentChanged;
        }

        InvalidateVisual();
    }

    /// <summary>
    /// Sets the color theme for rendering.
    /// </summary>
    /// <param name="theme">The terminal theme to use.</param>
    public void SetTheme(TerminalTheme theme)
    {
        _theme = theme;
        InvalidateVisual();
    }

    /// <summary>
    /// Handles buffer content changes by marshaling to the UI thread and invalidating.
    /// </summary>
    private void OnBufferContentChanged(object? sender, EventArgs e)
    {
        // Marshal to UI thread and invalidate
        Avalonia.Threading.Dispatcher.UIThread.Post(InvalidateVisual);
    }

    /// <inheritdoc />
    public override void Render(DrawingContext context)
    {
        base.Render(context);

        if (_buffer == null || !_fontMetrics.IsValid)
            return;

        // Use custom drawing operation for SkiaSharp
        context.Custom(new TerminalRenderOperation(
            new Rect(0, 0, Bounds.Width, Bounds.Height),
            _buffer,
            _theme,
            _fontMetrics,
            _selection,
            _cursorVisible && _buffer.CursorVisible,
            IsFocused));
    }

    /// <summary>
    /// Determines if the terminal has input focus.
    /// Checks both direct focus and focus on parent TerminalControl.
    /// </summary>
    private bool IsFocused =>
        TopLevel.GetTopLevel(this)?.FocusManager?.GetFocusedElement() == this
        || TopLevel.GetTopLevel(this)?.FocusManager?.GetFocusedElement()?.FindAncestorOfType<TerminalControl>() != null;

    /// <summary>
    /// Custom drawing operation for SkiaSharp rendering.
    /// Implements ICustomDrawOperation to access the SkiaSharp canvas directly.
    /// </summary>
    private sealed class TerminalRenderOperation : ICustomDrawOperation
    {
        private readonly Rect _bounds;
        private readonly TerminalBuffer _buffer;
        private readonly TerminalTheme _theme;
        private readonly TerminalFontMetrics _metrics;
        private readonly TerminalSelection? _selection;
        private readonly bool _showCursor;
        private readonly bool _isFocused;

        /// <summary>
        /// Creates a new terminal render operation.
        /// </summary>
        public TerminalRenderOperation(
            Rect bounds,
            TerminalBuffer buffer,
            TerminalTheme theme,
            TerminalFontMetrics metrics,
            TerminalSelection? selection,
            bool showCursor,
            bool isFocused)
        {
            _bounds = bounds;
            _buffer = buffer;
            _theme = theme;
            _metrics = metrics;
            _selection = selection;
            _showCursor = showCursor;
            _isFocused = isFocused;
        }

        /// <inheritdoc />
        public Rect Bounds => _bounds;

        /// <inheritdoc />
        public bool HitTest(Point p) => _bounds.Contains(p);

        /// <inheritdoc />
        public bool Equals(ICustomDrawOperation? other) => false;

        /// <inheritdoc />
        public void Dispose() { }

        /// <inheritdoc />
        public void Render(ImmediateDrawingContext context)
        {
            var leaseFeature = context.TryGetFeature<ISkiaSharpApiLeaseFeature>();
            if (leaseFeature == null)
                return;

            using var lease = leaseFeature.Lease();
            var canvas = lease.SkCanvas;

            RenderTerminal(canvas);
        }

        /// <summary>
        /// Renders the terminal content to the SkiaSharp canvas.
        /// </summary>
        private void RenderTerminal(SKCanvas canvas)
        {
            // Clear with background color
            var bgColor = ToSKColor(_theme.Background);
            canvas.Clear(bgColor);

            var lines = _buffer.GetVisibleLines();
            var charWidth = _metrics.CharWidth;
            var lineHeight = _metrics.LineHeight;
            var baseline = _metrics.Baseline;

            using var textPaint = new SKPaint
            {
                Typeface = _metrics.Typeface,
                TextSize = _metrics.FontSize,
                IsAntialias = true
            };

            using var bgPaint = new SKPaint { Style = SKPaintStyle.Fill };
            using var selectionPaint = new SKPaint
            {
                Color = ToSKColor(_theme.Selection).WithAlpha(_theme.SelectionAlpha),
                Style = SKPaintStyle.Fill
            };

            float y = 0;
            var lineIndex = _buffer.TotalLines - _buffer.Rows - _buffer.ScrollOffset;

            foreach (var line in lines)
            {
                float x = 0;

                for (int col = 0; col < line.Length && col < _buffer.Columns; col++)
                {
                    ref readonly var cell = ref line.ReadOnlyCells[col];

                    // Skip continuation cells (second cell of wide characters)
                    if (cell.IsContinuation)
                    {
                        x += charWidth;
                        continue;
                    }

                    var attrs = cell.Attributes;
                    var isSelected = _selection?.Contains(lineIndex, col) ?? false;

                    // Draw cell background
                    var hasBg = !attrs.Background.IsDefault || attrs.Inverse || isSelected;
                    if (hasBg)
                    {
                        SKColor cellBg;
                        if (isSelected)
                        {
                            cellBg = ToSKColor(_theme.Selection).WithAlpha(_theme.SelectionAlpha);
                        }
                        else if (attrs.Inverse)
                        {
                            cellBg = ResolveColor(attrs.Foreground, true);
                        }
                        else
                        {
                            cellBg = ResolveColor(attrs.Background, false);
                        }

                        bgPaint.Color = cellBg;
                        canvas.DrawRect(x, y, charWidth * cell.Width, lineHeight, bgPaint);
                    }

                    // Draw character
                    var charValue = cell.Character.Value;
                    if (charValue != ' ' && charValue != 0 && !attrs.Hidden)
                    {
                        var fgColor = attrs.Inverse
                            ? ResolveColor(attrs.Background, false)
                            : ResolveColor(attrs.Foreground, true);

                        textPaint.Color = fgColor;
                        textPaint.FakeBoldText = attrs.Bold;

                        // Handle dim attribute
                        if (attrs.Dim)
                        {
                            textPaint.Color = fgColor.WithAlpha(128);
                        }

                        canvas.DrawText(
                            cell.Character.ToString(),
                            x,
                            y + baseline,
                            textPaint);

                        // Draw underline
                        if (attrs.Underline)
                        {
                            var underlineY = y + lineHeight - 2;
                            canvas.DrawLine(x, underlineY, x + charWidth, underlineY, textPaint);
                        }

                        // Draw strikethrough
                        if (attrs.Strikethrough)
                        {
                            var strikeY = y + lineHeight / 2;
                            canvas.DrawLine(x, strikeY, x + charWidth, strikeY, textPaint);
                        }
                    }

                    x += charWidth * cell.Width;
                }

                y += lineHeight;
                lineIndex++;
            }

            // Draw cursor
            if (_showCursor && _buffer.ScrollOffset == 0)
            {
                DrawCursor(canvas, charWidth, lineHeight);
            }
        }

        /// <summary>
        /// Draws the terminal cursor at the current position.
        /// </summary>
        private void DrawCursor(SKCanvas canvas, float charWidth, float lineHeight)
        {
            var cursorX = _buffer.CursorX * charWidth;
            var cursorY = _buffer.CursorY * lineHeight;

            using var cursorPaint = new SKPaint
            {
                Color = ToSKColor(_theme.Cursor),
                Style = _isFocused ? SKPaintStyle.Fill : SKPaintStyle.Stroke,
                StrokeWidth = 1
            };

            switch (_theme.CursorStyle)
            {
                case CursorStyle.Block:
                    canvas.DrawRect(cursorX, cursorY, charWidth, lineHeight, cursorPaint);

                    // Draw character under cursor in inverse if focused
                    if (_isFocused)
                    {
                        var line = _buffer.GetLine(_buffer.CursorY);
                        if (line != null && _buffer.CursorX < line.Length)
                        {
                            var cell = line[_buffer.CursorX];
                            if (cell.Character.Value != ' ' && cell.Character.Value != 0)
                            {
                                using var textPaint = new SKPaint
                                {
                                    Typeface = _metrics.Typeface,
                                    TextSize = _metrics.FontSize,
                                    Color = ToSKColor(_theme.Background),
                                    IsAntialias = true
                                };
                                canvas.DrawText(
                                    cell.Character.ToString(),
                                    cursorX,
                                    cursorY + _metrics.Baseline,
                                    textPaint);
                            }
                        }
                    }
                    break;

                case CursorStyle.Underline:
                    canvas.DrawRect(cursorX, cursorY + lineHeight - 2, charWidth, 2, cursorPaint);
                    break;

                case CursorStyle.Bar:
                    canvas.DrawRect(cursorX, cursorY, 2, lineHeight, cursorPaint);
                    break;
            }
        }

        /// <summary>
        /// Resolves a terminal color to an SKColor using the theme.
        /// </summary>
        private SKColor ResolveColor(TerminalColor color, bool isForeground)
        {
            var resolved = _theme.ResolveColor(color, isForeground);
            return ToSKColor(resolved);
        }

        /// <summary>
        /// Converts a TerminalColor to an SKColor.
        /// </summary>
        private static SKColor ToSKColor(TerminalColor color) =>
            new(color.R, color.G, color.B);
    }
}
```

---

## File Summary

### Files to Create

| File | Location | Purpose |
|------|----------|---------|
| `TerminalFontMetrics.cs` | `src/AIntern.Desktop/Controls/Terminal/` | Font measurement and coordinate conversion utilities |
| `TerminalRenderer.cs` | `src/AIntern.Desktop/Controls/Terminal/` | SkiaSharp-based terminal rendering control |

### Directory Structure

```
src/AIntern.Desktop/
└── Controls/
    └── Terminal/
        ├── TerminalFontMetrics.cs   (NEW - v0.5.2b)
        └── TerminalRenderer.cs      (NEW - v0.5.2b)
```

---

## Usage Example

### Basic Integration

```csharp
// Create and configure renderer
var renderer = new TerminalRenderer
{
    FontFamily = "Cascadia Mono",
    FontSize = 14
};

// Set the terminal buffer
renderer.SetBuffer(terminalBuffer);

// Apply a theme
renderer.SetTheme(TerminalTheme.Dark);

// Use metrics for sizing
var (cols, rows) = renderer.Metrics.CalculateTerminalSize(
    availableWidth,
    availableHeight);

// Handle selection changes
renderer.Selection = new TerminalSelection(startRow, startCol, endRow, endCol);

// Control cursor visibility for blink
renderer.CursorVisible = !renderer.CursorVisible; // Toggle for blink
```

### In XAML

```xml
<local:TerminalRenderer
    x:Name="terminalRenderer"
    FontFamily="Cascadia Mono"
    FontSize="14" />
```

---

## Verification Steps

### 1. Build Verification

```bash
# Verify Desktop project builds with renderer
dotnet build src/AIntern.Desktop
```

### 2. Unit Test Suggestions

```csharp
// Test font metrics calculation
[Fact]
public void TerminalFontMetrics_CalculateTerminalSize_ReturnsValidDimensions()
{
    var metrics = new TerminalFontMetrics();
    metrics.Update("Consolas", 14f);

    var (cols, rows) = metrics.CalculateTerminalSize(800, 600);

    Assert.True(cols > 0);
    Assert.True(rows > 0);
}

[Fact]
public void TerminalFontMetrics_PixelToCell_ConvertsCorrectly()
{
    var metrics = new TerminalFontMetrics();
    metrics.Update("Consolas", 14f);

    var (x, y) = metrics.CellToPixel(10, 5);
    var (col, row) = metrics.PixelToCell(x, y);

    Assert.Equal(10, col);
    Assert.Equal(5, row);
}

[Fact]
public void TerminalFontMetrics_InvalidInput_ReturnsDefaults()
{
    var metrics = new TerminalFontMetrics();
    // Not initialized

    var (cols, rows) = metrics.CalculateTerminalSize(800, 600);

    Assert.Equal(80, cols);
    Assert.Equal(24, rows);
}
```

---

## Integration Notes

### Usage in v0.5.2c (Terminal Control)

The `TerminalRenderer` will be wrapped by `TerminalControl` which adds:
- Keyboard input handling
- Mouse interaction and text selection
- Clipboard operations (copy/paste)
- Cursor blink timer management
- Scroll bar integration

### Event Flow

```
TerminalBuffer.ContentChanged
        │
        ▼
OnBufferContentChanged()
        │
        ▼
Dispatcher.UIThread.Post(InvalidateVisual)
        │
        ▼
Render(DrawingContext)
        │
        ▼
TerminalRenderOperation.Render()
        │
        ▼
SkiaSharp canvas operations
```

### Performance Considerations

1. **Font Caching**: `TerminalFontMetrics` caches the typeface and measurement paint to avoid recreation on each render
2. **Thread Safety**: Buffer changes are marshaled to UI thread via `Dispatcher.UIThread.Post`
3. **Incremental Updates**: Future optimization could implement dirty region tracking for partial redraws
4. **Object Pooling**: SKPaint objects are created once per render pass and reused for all cells

---

## Changelog Entry

```markdown
## v0.5.2b - Terminal Renderer

### Added
- `TerminalFontMetrics` class for font measurement and coordinate conversion
  - Font loading with cross-platform fallback chain (Consolas → Monaco → Courier New)
  - Character width and line height calculation
  - Pixel-to-cell and cell-to-pixel coordinate conversion
  - Terminal size calculation from pixel dimensions
  - Bold/italic text paint creation
- `TerminalRenderer` Avalonia control for SkiaSharp-based rendering
  - Styled properties: FontFamily, FontSize
  - Buffer subscription with ContentChanged event handling
  - Theme application support
  - Selection highlighting with configurable alpha
  - Cursor visibility control for blink animation
- `TerminalRenderOperation` implementing ICustomDrawOperation
  - ISkiaSharpApiLeaseFeature integration for hardware-accelerated rendering
  - Cell background rendering with inverse and selection support
  - Character rendering with bold, dim, underline, and strikethrough attributes
  - Wide character (CJK) support via cell.Width and IsContinuation
  - Cursor rendering with Block, Underline, and Bar styles
  - Focused/unfocused cursor appearance (solid vs outline)

### Files Created
- `src/AIntern.Desktop/Controls/Terminal/TerminalFontMetrics.cs`
- `src/AIntern.Desktop/Controls/Terminal/TerminalRenderer.cs`
```
