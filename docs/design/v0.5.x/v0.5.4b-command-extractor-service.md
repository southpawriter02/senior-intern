# Design Specification: AIntern v0.5.4b "Command Extractor Service"

## Overview

**Version**: v0.5.4b
**Parent**: v0.5.4 Command Integration
**Focus**: Parsing markdown for commands, language detection, shell matching, dangerous command detection

### Purpose

This sub-version creates a service that extracts executable commands from AI responses:
1. Parse fenced code blocks with shell language identifiers (```bash, ```powershell, etc.)
2. Detect commands in unlabeled code blocks via heuristics
3. Extract inline commands following indicator phrases ("run the following...")
4. Map language tags to `ShellType` enumeration
5. Detect and flag potentially dangerous commands with warnings
6. Extract command descriptions from surrounding context
7. Assign confidence scores based on extraction certainty

### Dependencies

**From v0.5.4a (Command Block Models)**:
- `CommandBlock` - Target model for extracted commands
- `CommandBlockStatus` - Initial status assignment
- `CommandExtractionResult` - Result container
- `TextRange` - Source position tracking

**From v0.5.3a (Shell Detection)**:
- `ShellType` - Shell type enumeration

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                  v0.5.4b Command Extractor Service Architecture               │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                        Interface Layer                                   │ │
│  │  src/AIntern.Core/Interfaces/                                           │ │
│  ├─────────────────────────────────────────────────────────────────────────┤ │
│  │  ICommandExtractorService                                                │ │
│  │  ├── Extraction:                                                        │ │
│  │  │   └── ExtractCommands(content, messageId) → CommandExtractionResult  │ │
│  │  ├── Detection:                                                         │ │
│  │  │   ├── IsShellCommand(language, content) → bool                       │ │
│  │  │   └── GetShellTypeForLanguage(language) → ShellType?                 │ │
│  │  ├── Safety:                                                            │ │
│  │  │   └── CheckCommandSafety(command) → (isDangerous, warning)           │ │
│  │  └── Context:                                                           │ │
│  │      └── ExtractDescription(content, position) → string?                │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                     Implementation Layer                                 │ │
│  │  src/AIntern.Services/Terminal/                                         │ │
│  ├─────────────────────────────────────────────────────────────────────────┤ │
│  │  CommandExtractorService : ICommandExtractorService                      │ │
│  │  ├── Dependencies:                                                      │ │
│  │  │   └── ILogger<CommandExtractorService>                               │ │
│  │  ├── Static Data:                                                       │ │
│  │  │   ├── ShellLanguages: HashSet<string> (30+ identifiers)             │ │
│  │  │   ├── CommonCommands: HashSet<string> (60+ commands)                │ │
│  │  │   ├── DangerousPatterns: (Regex, Warning)[] (12 patterns)           │ │
│  │  │   └── CommandIndicators: string[] (14 phrases)                      │ │
│  │  ├── Regex Patterns (source-generated):                                 │ │
│  │  │   ├── FencedCodeBlockPattern: ```lang\ncontent```                   │ │
│  │  │   ├── InlineCodePattern: `command`                                  │ │
│  │  │   └── DangerousPatterns: rm -rf, sudo, dd, etc.                     │ │
│  │  └── Extraction Logic:                                                  │ │
│  │      ├── 1. Extract fenced code blocks                                  │ │
│  │      ├── 2. Filter by shell language or heuristics                     │ │
│  │      ├── 3. Extract inline commands near indicators                    │ │
│  │      ├── 4. Check each command for dangers                             │ │
│  │      └── 5. Assign confidence scores                                   │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Extraction Pipeline

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                      Command Extraction Pipeline                              │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Input: AI Response Message Content (Markdown)                               │
│                                                                              │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  STEP 1: Extract Fenced Code Blocks                                   │  │
│  │  ──────────────────────────────────────────────────────────────────── │  │
│  │  Regex: ```(?<lang>\w+)?\r?\n(?<content>[\s\S]*?)```                  │  │
│  │                                                                        │  │
│  │  For each match:                                                       │  │
│  │  ├── Extract language identifier (may be null)                        │  │
│  │  ├── Extract code content                                              │  │
│  │  └── Record source range (start, end positions)                       │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                           │                                                  │
│                           ▼                                                  │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  STEP 2: Filter for Shell Commands                                    │  │
│  │  ──────────────────────────────────────────────────────────────────── │  │
│  │  IsShellCommand(language, content):                                   │  │
│  │  ├── IF language ∈ ShellLanguages → TRUE (confidence: 0.95)          │  │
│  │  ├── ELIF language is null/unknown:                                   │  │
│  │  │   └── Run IsLikelyCommand(content) heuristics                     │  │
│  │  └── ELSE → FALSE                                                     │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                           │                                                  │
│                           ▼                                                  │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  STEP 3: Extract Inline Commands                                      │  │
│  │  ──────────────────────────────────────────────────────────────────── │  │
│  │  For each line in content:                                            │  │
│  │  ├── Check if line contains CommandIndicator phrase                  │  │
│  │  ├── If YES, scan next 1-3 lines for inline code: `command`          │  │
│  │  ├── Validate with IsLikelyCommand()                                  │  │
│  │  └── Add if not already captured (confidence: 0.6)                   │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                           │                                                  │
│                           ▼                                                  │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  STEP 4: Safety Check                                                 │  │
│  │  ──────────────────────────────────────────────────────────────────── │  │
│  │  For each extracted command:                                          │  │
│  │  ├── Run CheckCommandSafety(command)                                  │  │
│  │  ├── Match against DangerousPatterns                                  │  │
│  │  └── Set IsPotentiallyDangerous + DangerWarning                      │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                           │                                                  │
│                           ▼                                                  │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  STEP 5: Context Extraction                                           │  │
│  │  ──────────────────────────────────────────────────────────────────── │  │
│  │  For each command:                                                    │  │
│  │  ├── ExtractDescription(content, commandPosition)                     │  │
│  │  ├── Look for: markdown headers, indicator phrases, colon-endings   │  │
│  │  └── Assign to CommandBlock.Description                              │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                           │                                                  │
│                           ▼                                                  │
│  Output: CommandExtractionResult { Commands, Warnings }                      │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Heuristic Detection

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                    IsLikelyCommand() Heuristics                               │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  RULE 1: Shell Prompt Prefixes                                        │  │
│  │  ───────────────────────────────────────────────────────────────────  │  │
│  │  Detected patterns:                                                   │  │
│  │  • "$ command"        → Unix shell prompt                             │  │
│  │  • "> command"        → Generic prompt                                │  │
│  │  • "PS> command"      → PowerShell prompt                             │  │
│  │  • "PS C:\> command"  → PowerShell with path                          │  │
│  │  • "# command"        → Root/admin prompt (not markdown heading)     │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                                                              │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  RULE 2: Known Command Prefix                                         │  │
│  │  ───────────────────────────────────────────────────────────────────  │  │
│  │  First word (after stripping ./ /path/) matches CommonCommands set   │  │
│  │                                                                        │  │
│  │  Categories:                                                           │  │
│  │  • Package managers: npm, pip, cargo, brew, apt, choco, etc.         │  │
│  │  • Version control: git, gh, svn                                      │  │
│  │  • Containers: docker, kubectl, helm                                  │  │
│  │  • Build tools: make, cmake, gradle, msbuild                          │  │
│  │  • File operations: cd, ls, mkdir, rm, cp, mv                         │  │
│  │  • Network: curl, wget, ssh                                           │  │
│  │  • Languages: python, node, dotnet                                    │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                                                              │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  RULE 3: Line Count Filter                                            │  │
│  │  ───────────────────────────────────────────────────────────────────  │  │
│  │  • Commands typically: 1-10 lines                                     │  │
│  │  • Code blocks > 10 lines: likely source code, not commands          │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Shell Language Mapping

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                       Language to ShellType Mapping                           │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌────────────────────────────┬────────────────────────────────────────────┐ │
│  │ ShellType                  │ Language Identifiers                       │ │
│  ├────────────────────────────┼────────────────────────────────────────────┤ │
│  │ ShellType.Bash             │ bash, sh, shell                            │ │
│  │ ShellType.Zsh              │ zsh                                        │ │
│  │ ShellType.Fish             │ fish                                       │ │
│  │ ShellType.PowerShell       │ powershell, pwsh, ps1, ps                  │ │
│  │ ShellType.Cmd              │ cmd, batch, bat, dos                       │ │
│  │ ShellType.Ksh              │ ksh                                        │ │
│  │ ShellType.Tcsh             │ tcsh, csh                                  │ │
│  │ null (any shell)           │ console, terminal, command, cli            │ │
│  └────────────────────────────┴────────────────────────────────────────────┘ │
│                                                                              │
│  ShellType Inference (from command content):                                 │
│  ┌────────────────────────────┬────────────────────────────────────────────┐ │
│  │ Pattern                    │ Inferred ShellType                         │ │
│  ├────────────────────────────┼────────────────────────────────────────────┤ │
│  │ Contains "$env:" or "Get-" │ ShellType.PowerShell                       │ │
│  │ Contains "%VAR%"           │ ShellType.Cmd                              │ │
│  │ Starts with "set " (fish)  │ ShellType.Fish                             │ │
│  │ Otherwise                  │ null (platform default)                    │ │
│  └────────────────────────────┴────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Dangerous Command Detection

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                       Dangerous Command Patterns                              │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌────────────────────────────┬────────────────────────────────────────────┐ │
│  │ Pattern                    │ Warning Message                            │ │
│  ├────────────────────────────┼────────────────────────────────────────────┤ │
│  │ rm -rf /|~|$HOME|..       │ "Recursively deletes files. Verify path." │ │
│  │ format [drive]:           │ "Formats a disk. This is destructive."    │ │
│  │ dd ... of=                │ "Can overwrite disk data. Verify source." │ │
│  │ chmod -R                  │ "Recursive permissions affect many files."│ │
│  │ sudo rm                   │ "Elevated deletion. Be very careful."     │ │
│  │ DROP DATABASE|TABLE|SCHEMA│ "Deletes database permanently."           │ │
│  │ > /dev/null | truncate -s0│ "Truncates/empties files."                │ │
│  │ mkfs.*                    │ "Creates filesystem, erasing data."       │ │
│  │ killall | pkill           │ "Terminates multiple processes."          │ │
│  │ reboot|shutdown|halt      │ "Will restart/shutdown the system."       │ │
│  │ :(){:|:&};:               │ "Fork bomb. Do NOT run."                  │ │
│  │ curl ... | (ba)sh         │ "Piping curl to shell is dangerous."      │ │
│  └────────────────────────────┴────────────────────────────────────────────┘ │
│                                                                              │
│  All patterns use source-generated regex ([GeneratedRegex]) for performance.│
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Command Indicators

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                      Command Indicator Phrases                                │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  These phrases in text suggest the following content is a command:           │
│                                                                              │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  • "run the following"         • "execute the command"               │  │
│  │  • "run this command"          • "use this command"                  │  │
│  │  • "try running"               • "you can run"                       │  │
│  │  • "enter the command"         • "type the following"                │  │
│  │  • "run the command"           • "execute this"                      │  │
│  │  • "use the command"           • "in your terminal"                  │  │
│  │  • "from the command line"     • "in the shell"                      │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                                                              │
│  When detected, scan next 1-3 lines for inline code (`command`) to extract. │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Confidence Score Assignment

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                       Confidence Score Guidelines                             │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────┬───────────────────────────────────┐ │
│  │ Extraction Context                  │ Confidence Score                  │ │
│  ├─────────────────────────────────────┼───────────────────────────────────┤ │
│  │ Fenced block + shell language tag   │ 0.95                              │ │
│  │ Fenced block + generic tag (cli)    │ 0.85                              │ │
│  │ Fenced block, no language + heuristic │ 0.70                            │ │
│  │ Inline code after indicator phrase  │ 0.60                              │ │
│  │ Inline code without context         │ 0.40 (usually filtered)          │ │
│  └─────────────────────────────────────┴───────────────────────────────────┘ │
│                                                                              │
│  Usage in UI:                                                                │
│  • ≥ 0.80: Show "Run" button prominently                                    │
│  • 0.60-0.79: Show "Run" button with caution indicator                      │
│  • < 0.60: Show "Copy" button only (may not be executable)                  │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Specifications

### 1. ICommandExtractorService.cs

**Location**: `src/AIntern.Core/Interfaces/ICommandExtractorService.cs`

```csharp
namespace AIntern.Core.Interfaces;

using AIntern.Core.Models.Terminal;

/// <summary>
/// Service for extracting executable commands from AI responses.
/// </summary>
public interface ICommandExtractorService
{
    /// <summary>
    /// Extract all command blocks from message content.
    /// </summary>
    /// <param name="content">The message content to parse (markdown).</param>
    /// <param name="messageId">ID of the source message.</param>
    /// <returns>Extraction result containing commands and any warnings.</returns>
    CommandExtractionResult ExtractCommands(string content, Guid messageId);

    /// <summary>
    /// Determine if a code block represents a shell command.
    /// </summary>
    /// <param name="language">Language identifier from code fence (may be null).</param>
    /// <param name="content">Content of the code block.</param>
    /// <returns>True if this appears to be an executable shell command.</returns>
    bool IsShellCommand(string? language, string content);

    /// <summary>
    /// Get the appropriate ShellType for a language identifier.
    /// </summary>
    /// <param name="language">Language identifier (bash, powershell, etc.).</param>
    /// <returns>ShellType if language maps to a shell, null otherwise.</returns>
    ShellType? GetShellTypeForLanguage(string? language);

    /// <summary>
    /// Check if a command is potentially dangerous.
    /// </summary>
    /// <param name="command">The command text to check.</param>
    /// <returns>Tuple indicating if dangerous and a warning message.</returns>
    (bool IsDangerous, string? Warning) CheckCommandSafety(string command);

    /// <summary>
    /// Extract a description for a command from surrounding context.
    /// </summary>
    /// <param name="content">Full message content.</param>
    /// <param name="commandPosition">Position of the command in content.</param>
    /// <returns>Description text or null if none found.</returns>
    string? ExtractDescription(string content, int commandPosition);
}
```

### 2. CommandExtractorService.cs

**Location**: `src/AIntern.Services/Terminal/CommandExtractorService.cs`

```csharp
namespace AIntern.Services.Terminal;

using System.Text.RegularExpressions;
using Microsoft.Extensions.Logging;
using AIntern.Core.Interfaces;
using AIntern.Core.Models.Terminal;

/// <summary>
/// Extracts executable commands from AI-generated markdown content.
/// </summary>
public sealed partial class CommandExtractorService : ICommandExtractorService
{
    private readonly ILogger<CommandExtractorService> _logger;

    // === Shell Language Identifiers ===

    private static readonly HashSet<string> ShellLanguages = new(StringComparer.OrdinalIgnoreCase)
    {
        // Unix shells
        "bash", "sh", "shell", "zsh", "fish", "ksh", "csh", "tcsh",
        // Windows shells
        "powershell", "pwsh", "ps1", "ps",
        "cmd", "batch", "bat", "dos",
        // Generic terminal identifiers
        "console", "terminal", "command", "cli"
    };

    // === Common Executable Commands ===

    private static readonly HashSet<string> CommonCommands = new(StringComparer.OrdinalIgnoreCase)
    {
        // Package managers
        "npm", "yarn", "pnpm", "npx", "bun",
        "pip", "pip3", "pipx", "poetry", "conda",
        "gem", "bundle", "bundler",
        "cargo", "rustup",
        "go", "gofmt",
        "dotnet", "nuget",
        "composer", "php",
        "brew", "apt", "apt-get", "yum", "dnf", "pacman", "apk", "zypper",
        "choco", "scoop", "winget",

        // Version control
        "git", "gh", "hub", "svn", "hg",

        // Containers & orchestration
        "docker", "docker-compose", "podman",
        "kubectl", "helm", "minikube", "kind",
        "terraform", "pulumi", "ansible",

        // Build tools
        "make", "cmake", "ninja", "meson",
        "gradle", "mvn", "maven", "ant",
        "msbuild", "xcodebuild",

        // File operations
        "cd", "ls", "dir", "mkdir", "rm", "cp", "mv", "cat", "less", "more",
        "touch", "chmod", "chown", "ln", "find", "grep", "sed", "awk",
        "tar", "zip", "unzip", "gzip", "gunzip",

        // Network
        "curl", "wget", "ssh", "scp", "rsync", "ping", "nc", "netcat",
        "http", "https",

        // Misc utilities
        "echo", "printf", "export", "set", "env", "source",
        "sudo", "su", "doas",
        "systemctl", "service", "launchctl",
        "code", "vim", "nano", "emacs",
        "python", "python3", "node", "ruby", "perl"
    };

    // === Dangerous Command Patterns ===

    private static readonly (Regex Pattern, string Warning)[] DangerousPatterns =
    {
        (RmRfPattern(), "This command recursively deletes files. Verify the path carefully."),
        (FormatPattern(), "This command formats a disk. This is destructive."),
        (DdPattern(), "dd can overwrite disk data. Verify source and destination."),
        (ChmodRecursivePattern(), "Recursive permission changes can affect many files."),
        (SudoRmPattern(), "Elevated deletion command. Be very careful."),
        (DropDatabasePattern(), "This will delete a database permanently."),
        (TruncatePattern(), "This truncates/empties files."),
        (MkfsPattern(), "This creates a filesystem, erasing existing data."),
        (KillAllPattern(), "This terminates multiple processes."),
        (RebootPattern(), "This will restart or shutdown the system."),
        (ForkBombPattern(), "This appears to be a fork bomb. Do NOT run."),
        (CurlPipeShPattern(), "Piping curl to shell can be dangerous. Review the script first.")
    };

    [GeneratedRegex(@"\brm\s+(-[rf]+\s+)*(/|~|\$HOME|\.\.)", RegexOptions.IgnoreCase)]
    private static partial Regex RmRfPattern();

    [GeneratedRegex(@"\bformat\s+[a-z]:", RegexOptions.IgnoreCase)]
    private static partial Regex FormatPattern();

    [GeneratedRegex(@"\bdd\s+.*\bof=", RegexOptions.IgnoreCase)]
    private static partial Regex DdPattern();

    [GeneratedRegex(@"\bchmod\s+-[Rr]", RegexOptions.IgnoreCase)]
    private static partial Regex ChmodRecursivePattern();

    [GeneratedRegex(@"\bsudo\s+rm\b", RegexOptions.IgnoreCase)]
    private static partial Regex SudoRmPattern();

    [GeneratedRegex(@"\bDROP\s+(DATABASE|TABLE|SCHEMA)\b", RegexOptions.IgnoreCase)]
    private static partial Regex DropDatabasePattern();

    [GeneratedRegex(@">\s*/dev/null|>\s*\$\(|truncate\s+-s\s*0", RegexOptions.IgnoreCase)]
    private static partial Regex TruncatePattern();

    [GeneratedRegex(@"\bmkfs\.", RegexOptions.IgnoreCase)]
    private static partial Regex MkfsPattern();

    [GeneratedRegex(@"\bkillall\b|\bpkill\b", RegexOptions.IgnoreCase)]
    private static partial Regex KillAllPattern();

    [GeneratedRegex(@"\b(reboot|shutdown|halt|poweroff)\b", RegexOptions.IgnoreCase)]
    private static partial Regex RebootPattern();

    [GeneratedRegex(@":\(\)\s*\{\s*:\|:&\s*\};:", RegexOptions.None)]
    private static partial Regex ForkBombPattern();

    [GeneratedRegex(@"curl\s+.*\|\s*(ba)?sh", RegexOptions.IgnoreCase)]
    private static partial Regex CurlPipeShPattern();

    // === Content Parsing Patterns ===

    [GeneratedRegex(@"```(?<lang>\w+)?\r?\n(?<content>[\s\S]*?)```", RegexOptions.Compiled)]
    private static partial Regex FencedCodeBlockPattern();

    [GeneratedRegex(@"`(?<cmd>[^`\n]+)`", RegexOptions.Compiled)]
    private static partial Regex InlineCodePattern();

    // === Command Indicator Phrases ===

    private static readonly string[] CommandIndicators =
    {
        "run the following",
        "execute the command",
        "run this command",
        "use this command",
        "try running",
        "you can run",
        "enter the command",
        "type the following",
        "run the command",
        "execute this",
        "use the command",
        "in your terminal",
        "from the command line",
        "in the shell"
    };

    public CommandExtractorService(ILogger<CommandExtractorService> logger)
    {
        _logger = logger;
    }

    // === Main Extraction ===

    public CommandExtractionResult ExtractCommands(string content, Guid messageId)
    {
        if (string.IsNullOrWhiteSpace(content))
        {
            return CommandExtractionResult.Empty;
        }

        var commands = new List<CommandBlock>();
        var warnings = new List<string>();
        var sequenceNumber = 0;

        // Step 1: Extract from fenced code blocks
        var fencedMatches = FencedCodeBlockPattern().Matches(content);
        foreach (Match match in fencedMatches)
        {
            var language = match.Groups["lang"].Value;
            var blockContent = match.Groups["content"].Value.Trim();

            if (IsShellCommand(language, blockContent))
            {
                var (isDangerous, warning) = CheckCommandSafety(blockContent);
                var description = ExtractDescription(content, match.Index);
                var confidenceScore = CalculateConfidenceScore(language, blockContent);

                commands.Add(new CommandBlock
                {
                    Command = blockContent,
                    Language = string.IsNullOrEmpty(language) ? null : language,
                    DetectedShellType = GetShellTypeForLanguage(language) ?? InferShellType(blockContent),
                    MessageId = messageId,
                    SequenceNumber = sequenceNumber++,
                    Description = description,
                    SourceRange = new TextRange(match.Index, match.Index + match.Length),
                    IsPotentiallyDangerous = isDangerous,
                    DangerWarning = warning,
                    ConfidenceScore = confidenceScore
                });

                if (isDangerous && warning != null)
                {
                    warnings.Add($"Command {sequenceNumber}: {warning}");
                }
            }
        }

        // Step 2: Extract inline commands following indicator phrases
        ExtractInlineCommands(content, messageId, commands, warnings, ref sequenceNumber);

        _logger.LogDebug("Extracted {Count} commands from message {MessageId}",
            commands.Count, messageId);

        return new CommandExtractionResult
        {
            Commands = commands.AsReadOnly(),
            Warnings = warnings.AsReadOnly()
        };
    }

    private void ExtractInlineCommands(
        string content,
        Guid messageId,
        List<CommandBlock> commands,
        List<string> warnings,
        ref int sequenceNumber)
    {
        var lines = content.Split('\n');
        var existingCommands = commands.Select(c => c.Command).ToHashSet();

        for (int i = 0; i < lines.Length; i++)
        {
            var line = lines[i];
            var lowerLine = line.ToLowerInvariant();

            // Check if line contains a command indicator
            if (!CommandIndicators.Any(ind => lowerLine.Contains(ind)))
                continue;

            // Scan next 1-3 lines for inline code
            for (int j = i + 1; j < Math.Min(i + 4, lines.Length); j++)
            {
                var nextLine = lines[j].Trim();
                var inlineMatch = InlineCodePattern().Match(nextLine);

                if (!inlineMatch.Success)
                    continue;

                var cmd = inlineMatch.Groups["cmd"].Value;

                // Skip if already captured or doesn't look like a command
                if (existingCommands.Contains(cmd) || !IsLikelyCommand(cmd))
                    continue;

                var (isDangerous, warning) = CheckCommandSafety(cmd);
                var startIndex = content.IndexOf(nextLine, StringComparison.Ordinal);

                commands.Add(new CommandBlock
                {
                    Command = cmd,
                    DetectedShellType = InferShellType(cmd),
                    MessageId = messageId,
                    SequenceNumber = sequenceNumber++,
                    Description = line.Trim(),
                    SourceRange = new TextRange(startIndex, startIndex + nextLine.Length),
                    IsPotentiallyDangerous = isDangerous,
                    DangerWarning = warning,
                    ConfidenceScore = 0.6f // Lower confidence for inline
                });

                existingCommands.Add(cmd);

                if (isDangerous && warning != null)
                {
                    warnings.Add($"Command {sequenceNumber}: {warning}");
                }

                break; // Only capture first inline code after indicator
            }
        }
    }

    // === Detection Methods ===

    public bool IsShellCommand(string? language, string content)
    {
        // Explicit shell language tag
        if (!string.IsNullOrEmpty(language) && ShellLanguages.Contains(language))
        {
            return true;
        }

        // For unlabeled or unknown language blocks, use heuristics
        if (string.IsNullOrEmpty(language))
        {
            return IsLikelyCommand(content);
        }

        return false;
    }

    private bool IsLikelyCommand(string content)
    {
        if (string.IsNullOrWhiteSpace(content))
            return false;

        var lines = content.Split('\n', StringSplitOptions.RemoveEmptyEntries);
        if (lines.Length == 0)
            return false;

        // Commands are typically short (1-10 lines)
        if (lines.Length > 10)
            return false;

        var firstLine = lines[0].Trim();

        // Check for shell prompt prefixes
        if (firstLine.StartsWith("$ ") ||
            firstLine.StartsWith("> ") ||
            firstLine.StartsWith("PS>") ||
            firstLine.StartsWith("PS C:\\"))
        {
            return true;
        }

        // Special handling for # - it's a root prompt only if followed by space and command
        if (firstLine.StartsWith("# ") && firstLine.Length > 2 && !char.IsWhiteSpace(firstLine[2]))
        {
            return true;
        }

        // Check if first word is a known command
        var firstWord = firstLine.Split(' ', StringSplitOptions.RemoveEmptyEntries)
            .FirstOrDefault()?
            .TrimStart('.', '/', '\\') ?? "";

        // Remove path if present
        if (firstWord.Contains('/') || firstWord.Contains('\\'))
        {
            firstWord = Path.GetFileName(firstWord);
        }

        return CommonCommands.Contains(firstWord);
    }

    // === Shell Type Detection ===

    public ShellType? GetShellTypeForLanguage(string? language)
    {
        if (string.IsNullOrEmpty(language))
            return null;

        return language.ToLowerInvariant() switch
        {
            "bash" or "sh" or "shell" => ShellType.Bash,
            "zsh" => ShellType.Zsh,
            "fish" => ShellType.Fish,
            "powershell" or "pwsh" or "ps1" or "ps" => ShellType.PowerShell,
            "cmd" or "batch" or "bat" or "dos" => ShellType.Cmd,
            "ksh" => ShellType.Ksh,
            "tcsh" or "csh" => ShellType.Tcsh,
            "console" or "terminal" or "command" or "cli" => null, // Generic
            _ => null
        };
    }

    private ShellType? InferShellType(string command)
    {
        // Infer shell type from command content patterns
        if (command.Contains("$env:") || command.Contains("Get-") || command.Contains("Set-"))
            return ShellType.PowerShell;

        // Check for cmd.exe variable syntax: %VAR%
        if (command.Contains('%') && command.IndexOf('%') != command.LastIndexOf('%'))
            return ShellType.Cmd;

        // Fish-specific syntax
        if (command.StartsWith("set ") && !command.Contains('='))
            return ShellType.Fish;

        // Default: no specific shell (use platform default)
        return null;
    }

    // === Safety Checking ===

    public (bool IsDangerous, string? Warning) CheckCommandSafety(string command)
    {
        foreach (var (pattern, warning) in DangerousPatterns)
        {
            if (pattern.IsMatch(command))
            {
                _logger.LogWarning("Dangerous command pattern detected: {Warning}", warning);
                return (true, warning);
            }
        }

        return (false, null);
    }

    // === Context Extraction ===

    public string? ExtractDescription(string content, int commandPosition)
    {
        if (commandPosition <= 0)
            return null;

        var beforeContent = content[..commandPosition];
        var lines = beforeContent.Split('\n');

        // Check last 1-4 non-empty lines before command
        for (int i = lines.Length - 1; i >= Math.Max(0, lines.Length - 4); i--)
        {
            var line = lines[i].Trim();

            // Skip empty lines
            if (string.IsNullOrEmpty(line))
                continue;

            // Stop if we hit another code block
            if (line.StartsWith("```"))
                break;

            // Use markdown header as description
            if (line.StartsWith('#'))
            {
                return line.TrimStart('#', ' ');
            }

            // Check for command indicator phrase
            var lowerLine = line.ToLowerInvariant();
            if (CommandIndicators.Any(ind => lowerLine.Contains(ind)))
            {
                return line;
            }

            // Use line ending with colon as description
            if (line.EndsWith(':'))
            {
                return line.TrimEnd(':');
            }

            // Use sentence-like line as description
            if (line.Length > 10 && char.IsUpper(line[0]))
            {
                return line;
            }
        }

        return null;
    }

    // === Confidence Scoring ===

    private float CalculateConfidenceScore(string? language, string content)
    {
        // Explicit shell language tag = high confidence
        if (!string.IsNullOrEmpty(language))
        {
            if (ShellLanguages.Contains(language))
            {
                // Generic terms slightly lower confidence
                return language.ToLowerInvariant() switch
                {
                    "console" or "terminal" or "command" or "cli" => 0.85f,
                    _ => 0.95f
                };
            }
        }

        // No language but passes heuristics
        if (IsLikelyCommand(content))
        {
            return 0.70f;
        }

        // Default low confidence
        return 0.40f;
    }
}
```

---

## File Summary

| File | Location | Purpose |
|------|----------|---------|
| `ICommandExtractorService.cs` | `src/AIntern.Core/Interfaces/` | Extractor service interface |
| `CommandExtractorService.cs` | `src/AIntern.Services/Terminal/` | Full extraction implementation |

### Files to Modify

| File | Changes |
|------|---------|
| `src/AIntern.Services/DependencyInjection.cs` | Register ICommandExtractorService as singleton |

---

## Unit Test Plan

| Test | Description |
|------|-------------|
| `ExtractCommands_FencedBash_ExtractsCommand` | ```bash code``` extracted |
| `ExtractCommands_FencedPowerShell_DetectsShellType` | ShellType.PowerShell set |
| `ExtractCommands_FencedNoLanguage_UsesHeuristics` | Unlabeled block detected |
| `ExtractCommands_FencedCSharp_NotExtracted` | Non-shell language ignored |
| `ExtractCommands_InlineAfterIndicator_Extracted` | `command` after "run this" |
| `ExtractCommands_InlineWithoutIndicator_NotExtracted` | Random inline code ignored |
| `ExtractCommands_MultipleCommands_ReturnsAll` | Multiple blocks extracted |
| `ExtractCommands_SequenceNumbers_Ordered` | 0, 1, 2... sequence |
| `IsShellCommand_BashLanguage_ReturnsTrue` | "bash" recognized |
| `IsShellCommand_UnknownLanguage_ReturnsFalse` | "python" rejected |
| `IsShellCommand_NullLanguage_UsesHeuristics` | Fallback to heuristics |
| `IsLikelyCommand_ShellPrompt_ReturnsTrue` | "$ npm install" detected |
| `IsLikelyCommand_KnownCommand_ReturnsTrue` | "git status" detected |
| `IsLikelyCommand_TooManyLines_ReturnsFalse` | 15+ lines rejected |
| `GetShellTypeForLanguage_Bash_ReturnsBash` | Correct mapping |
| `GetShellTypeForLanguage_Generic_ReturnsNull` | "cli" → null |
| `InferShellType_PowerShellSyntax_DetectsPowerShell` | "$env:" detected |
| `InferShellType_CmdSyntax_DetectsCmd` | "%PATH%" detected |
| `CheckCommandSafety_RmRf_DetectsDangerous` | rm -rf flagged |
| `CheckCommandSafety_SafeCommand_NotDangerous` | ls -la safe |
| `CheckCommandSafety_ForkBomb_DetectsDangerous` | Fork bomb flagged |
| `CheckCommandSafety_CurlPipeShell_DetectsDangerous` | curl | sh flagged |
| `ExtractDescription_HeaderBefore_ReturnsHeader` | # Step 1 → "Step 1" |
| `ExtractDescription_ColonLine_ReturnsText` | "Install deps:" → "Install deps" |
| `ConfidenceScore_BashTag_Returns095` | High confidence |
| `ConfidenceScore_NoLanguage_Returns070` | Medium confidence |
| `ConfidenceScore_InlineCode_Returns060` | Lower confidence |

**Total Tests**: 27

---

## Verification

```bash
# Verify compilation
dotnet build src/AIntern.Services

# Run unit tests
dotnet test --filter "CommandExtractor"

# Verify DI registration
dotnet build src/AIntern.Desktop
```

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | Fenced code blocks with shell languages (bash, powershell, etc.) are extracted |
| AC-2 | Unlabeled fenced code blocks detected via heuristics |
| AC-3 | Inline commands following indicator phrases extracted |
| AC-4 | Shell types correctly mapped from language tags |
| AC-5 | Shell types inferred from command content patterns |
| AC-6 | Dangerous commands flagged with appropriate warnings |
| AC-7 | All 12 dangerous patterns detected correctly |
| AC-8 | Command descriptions extracted from preceding context |
| AC-9 | Confidence scores assigned based on extraction method |
| AC-10 | Sequence numbers assigned in order of appearance |
| AC-11 | Source ranges correctly identify command positions |

---

## Changelog Entry

```markdown
## v0.5.4b - Command Extractor Service

### Added
- `ICommandExtractorService` interface with:
  - ExtractCommands() - Main extraction from markdown content
  - IsShellCommand() - Shell command detection
  - GetShellTypeForLanguage() - Language to ShellType mapping
  - CheckCommandSafety() - Dangerous command detection
  - ExtractDescription() - Context-based description extraction

- `CommandExtractorService` implementation with:
  - Fenced code block extraction via regex
  - Shell language identification (30+ identifiers)
  - Heuristic command detection (60+ known commands)
  - Shell prompt detection ($ > PS> patterns)
  - Inline command extraction after indicator phrases
  - 12 dangerous command patterns with warnings
  - 14 command indicator phrases
  - Confidence score assignment (0.40 - 0.95)
  - Source-generated regex for performance

### Shell Languages Supported
- Unix: bash, sh, zsh, fish, ksh, tcsh, csh
- Windows: powershell, pwsh, cmd, batch
- Generic: console, terminal, cli

### Dangerous Patterns Detected
- rm -rf (recursive delete)
- format (disk format)
- dd of= (disk overwrite)
- sudo rm (elevated delete)
- DROP DATABASE/TABLE
- mkfs (filesystem creation)
- killall/pkill (process termination)
- reboot/shutdown
- fork bombs
- curl | sh (piped scripts)
```

---

## Timeline Estimate

| Version | Estimated Effort |
|---------|------------------|
| v0.5.4b | 0.75 day |
