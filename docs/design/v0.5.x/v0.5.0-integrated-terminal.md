# Design Specification: AIntern v0.5.0 "The Integrated Terminal"

## Executive Summary

This document provides a comprehensive design specification for v0.5.0, which brings a fully-featured integrated terminal to AIntern. This phase embeds a cross-platform terminal emulator into the application, synchronizes it with the workspace file explorer, and enables seamless command execution from AI-generated suggestions. This is a foundational feature for the upcoming v0.6.0 agentic capabilities.

### v0.5.0 Scope (from ROADMAP.md)
- Embed **XtermSharp** or similar terminal emulator into the bottom panel
- **Synchronize** the terminal's working directory with the File Explorer
- **"Copy to Terminal"** button: AI-generated commands can be sent to the shell with one click

---

## Sub-Version Breakdown

| Version | Name | Focus |
|---------|------|-------|
| v0.5.1 | Terminal Foundation | Cross-platform PTY integration, basic terminal rendering |
| v0.5.2 | Terminal UI | Panel integration, tabs, resize handling, theming |
| v0.5.3 | Shell Integration | Shell detection, profile management, working directory sync |
| v0.5.4 | Command Integration | Copy to terminal, command extraction, output capture |
| v0.5.5 | Polish & Integration | History, search, keyboard shortcuts, settings |

---

## Technology Selection

### Terminal Emulation Options Analysis

| Library | Platform | Pros | Cons |
|---------|----------|------|------|
| **Pty.Net + Custom Renderer** | Cross-platform | Full control, lightweight | More work to implement |
| **XtermSharp** | macOS/Linux | VT100 compliant, Avalonia port exists | Limited Windows support |
| **Windows Terminal (conpty)** | Windows | Native experience | Windows-only |
| **AvaloniaTerminal** | Cross-platform | Avalonia-native | Less mature |

### Recommended Approach: Pty.Net + Custom Terminal Control

For maximum cross-platform compatibility, we'll use:
- **Pty.Net**: Cross-platform pseudo-terminal library (wraps WinPTY on Windows, native PTY on Unix)
- **Custom AvaloniaTerminalControl**: Avalonia-native terminal renderer with VT100/ANSI escape sequence parsing
- **CliWrap** (optional): For simple command execution without full PTY

This approach gives us:
- Full control over rendering and theming
- Consistent behavior across Windows, macOS, and Linux
- Integration with Avalonia's rendering pipeline
- Future extensibility for v0.6.0 tool execution

---

## v0.5.1: Terminal Foundation

### Objective
Establish the core terminal infrastructure with cross-platform PTY integration and basic terminal rendering with ANSI escape sequence support.

### New NuGet Packages

| Package | Version | Project | Purpose |
|---------|---------|---------|---------|
| Pty.Net | 1.0.0 | Services | Cross-platform PTY |
| System.IO.Pipelines | 8.0.0 | Services | Efficient stream handling |

### Core Terminal Models

#### TerminalSession Model

```csharp
namespace SeniorIntern.Core.Models;

public sealed class TerminalSession : IAsyncDisposable
{
    public Guid Id { get; init; } = Guid.NewGuid();
    public string Name { get; set; } = "Terminal";
    public string ShellPath { get; init; } = string.Empty;
    public string WorkingDirectory { get; set; } = string.Empty;
    public TerminalSessionState State { get; set; } = TerminalSessionState.Starting;
    public DateTime CreatedAt { get; init; } = DateTime.UtcNow;
    public DateTime? ClosedAt { get; set; }

    /// <summary>
    /// Environment variables for this session
    /// </summary>
    public Dictionary<string, string> Environment { get; init; } = new();

    /// <summary>
    /// Terminal dimensions
    /// </summary>
    public TerminalSize Size { get; set; } = new(80, 24);

    /// <summary>
    /// Exit code if session has ended
    /// </summary>
    public int? ExitCode { get; set; }

    /// <summary>
    /// Associated workspace ID (for directory sync)
    /// </summary>
    public Guid? WorkspaceId { get; set; }

    public ValueTask DisposeAsync();
}

public enum TerminalSessionState
{
    Starting,
    Running,
    Exited,
    Error
}

public record TerminalSize(int Columns, int Rows)
{
    public static TerminalSize Default => new(80, 24);
    public static TerminalSize Wide => new(120, 30);
}
```

#### TerminalBuffer Model

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Represents the terminal's screen buffer with scrollback
/// </summary>
public sealed class TerminalBuffer
{
    private readonly List<TerminalLine> _lines = new();
    private readonly int _maxScrollback;

    public int Columns { get; private set; }
    public int Rows { get; private set; }
    public int CursorX { get; set; }
    public int CursorY { get; set; }
    public bool CursorVisible { get; set; } = true;

    /// <summary>
    /// Current scroll position (0 = bottom/live)
    /// </summary>
    public int ScrollOffset { get; set; }

    /// <summary>
    /// Total lines including scrollback
    /// </summary>
    public int TotalLines => _lines.Count;

    /// <summary>
    /// Current terminal attributes (colors, styles)
    /// </summary>
    public TerminalAttributes CurrentAttributes { get; set; } = new();

    public TerminalBuffer(int columns, int rows, int maxScrollback = 10000)
    {
        Columns = columns;
        Rows = rows;
        _maxScrollback = maxScrollback;
        Clear();
    }

    public void Resize(int columns, int rows);
    public void Write(char c);
    public void WriteLine(string text);
    public void Clear();
    public void ClearLine(int lineIndex);
    public void ScrollUp(int lines = 1);
    public void ScrollDown(int lines = 1);
    public TerminalLine GetLine(int index);
    public IEnumerable<TerminalLine> GetVisibleLines();
    public string GetText(TerminalSelection? selection = null);
}

public sealed class TerminalLine
{
    public List<TerminalCell> Cells { get; } = new();
    public bool IsWrapped { get; set; }
    public DateTime Timestamp { get; init; } = DateTime.UtcNow;
}

public struct TerminalCell
{
    public char Character { get; set; }
    public TerminalAttributes Attributes { get; set; }

    public static TerminalCell Empty => new() { Character = ' ', Attributes = new() };
}

public struct TerminalAttributes
{
    public TerminalColor Foreground { get; set; }
    public TerminalColor Background { get; set; }
    public bool Bold { get; set; }
    public bool Italic { get; set; }
    public bool Underline { get; set; }
    public bool Strikethrough { get; set; }
    public bool Inverse { get; set; }
    public bool Hidden { get; set; }
    public bool Blink { get; set; }

    public static TerminalAttributes Default => new()
    {
        Foreground = TerminalColor.Default,
        Background = TerminalColor.Default
    };
}

public struct TerminalColor
{
    public byte R { get; set; }
    public byte G { get; set; }
    public byte B { get; set; }
    public bool IsDefault { get; set; }
    public int? PaletteIndex { get; set; } // For 256-color mode

    public static TerminalColor Default => new() { IsDefault = true };
    public static TerminalColor FromRgb(byte r, byte g, byte b) => new() { R = r, G = g, B = b };
    public static TerminalColor FromPalette(int index) => new() { PaletteIndex = index };
}

public record TerminalSelection(
    int StartLine,
    int StartColumn,
    int EndLine,
    int EndColumn
);
```

### ANSI Escape Sequence Parser

```csharp
namespace SeniorIntern.Core.Terminal;

/// <summary>
/// Parses VT100/ANSI escape sequences from terminal output
/// </summary>
public sealed class AnsiParser
{
    private readonly TerminalBuffer _buffer;
    private ParserState _state = ParserState.Ground;
    private readonly StringBuilder _escapeSequence = new();
    private readonly List<int> _parameters = new();

    public AnsiParser(TerminalBuffer buffer)
    {
        _buffer = buffer;
    }

    public void Parse(ReadOnlySpan<byte> data)
    {
        foreach (var b in data)
        {
            ProcessByte(b);
        }
    }

    private void ProcessByte(byte b)
    {
        switch (_state)
        {
            case ParserState.Ground:
                ProcessGroundState(b);
                break;
            case ParserState.Escape:
                ProcessEscapeState(b);
                break;
            case ParserState.Csi:
                ProcessCsiState(b);
                break;
            case ParserState.Osc:
                ProcessOscState(b);
                break;
            // ... other states
        }
    }

    private void ProcessGroundState(byte b)
    {
        switch (b)
        {
            case 0x1B: // ESC
                _state = ParserState.Escape;
                _escapeSequence.Clear();
                break;
            case 0x07: // BEL
                OnBell();
                break;
            case 0x08: // BS (Backspace)
                _buffer.CursorX = Math.Max(0, _buffer.CursorX - 1);
                break;
            case 0x09: // HT (Tab)
                _buffer.CursorX = ((_buffer.CursorX / 8) + 1) * 8;
                break;
            case 0x0A: // LF (Line Feed)
                LineFeed();
                break;
            case 0x0D: // CR (Carriage Return)
                _buffer.CursorX = 0;
                break;
            default:
                if (b >= 0x20) // Printable
                {
                    _buffer.Write((char)b);
                }
                break;
        }
    }

    private void ProcessCsiState(byte b)
    {
        if (b >= 0x30 && b <= 0x3F) // Parameter bytes
        {
            _escapeSequence.Append((char)b);
        }
        else if (b >= 0x40 && b <= 0x7E) // Final byte
        {
            ParseCsiParameters();
            ExecuteCsiCommand((char)b);
            _state = ParserState.Ground;
        }
    }

    private void ExecuteCsiCommand(char command)
    {
        switch (command)
        {
            case 'A': // Cursor Up
                _buffer.CursorY = Math.Max(0, _buffer.CursorY - GetParam(0, 1));
                break;
            case 'B': // Cursor Down
                _buffer.CursorY = Math.Min(_buffer.Rows - 1, _buffer.CursorY + GetParam(0, 1));
                break;
            case 'C': // Cursor Forward
                _buffer.CursorX = Math.Min(_buffer.Columns - 1, _buffer.CursorX + GetParam(0, 1));
                break;
            case 'D': // Cursor Back
                _buffer.CursorX = Math.Max(0, _buffer.CursorX - GetParam(0, 1));
                break;
            case 'H': // Cursor Position
            case 'f':
                _buffer.CursorY = Math.Max(0, GetParam(0, 1) - 1);
                _buffer.CursorX = Math.Max(0, GetParam(1, 1) - 1);
                break;
            case 'J': // Erase in Display
                EraseInDisplay(GetParam(0, 0));
                break;
            case 'K': // Erase in Line
                EraseInLine(GetParam(0, 0));
                break;
            case 'm': // SGR (Select Graphic Rendition)
                ProcessSgr();
                break;
            case 'r': // Set Scrolling Region
                SetScrollRegion(GetParam(0, 1), GetParam(1, _buffer.Rows));
                break;
            // ... more commands
        }
    }

    private void ProcessSgr()
    {
        if (_parameters.Count == 0)
        {
            _buffer.CurrentAttributes = TerminalAttributes.Default;
            return;
        }

        for (int i = 0; i < _parameters.Count; i++)
        {
            var param = _parameters[i];
            switch (param)
            {
                case 0: // Reset
                    _buffer.CurrentAttributes = TerminalAttributes.Default;
                    break;
                case 1: // Bold
                    _buffer.CurrentAttributes = _buffer.CurrentAttributes with { Bold = true };
                    break;
                case 3: // Italic
                    _buffer.CurrentAttributes = _buffer.CurrentAttributes with { Italic = true };
                    break;
                case 4: // Underline
                    _buffer.CurrentAttributes = _buffer.CurrentAttributes with { Underline = true };
                    break;
                case 7: // Inverse
                    _buffer.CurrentAttributes = _buffer.CurrentAttributes with { Inverse = true };
                    break;
                case 22: // Normal intensity
                    _buffer.CurrentAttributes = _buffer.CurrentAttributes with { Bold = false };
                    break;
                case 30..37: // Standard foreground colors
                    _buffer.CurrentAttributes = _buffer.CurrentAttributes with
                    {
                        Foreground = GetStandardColor(param - 30)
                    };
                    break;
                case 38: // Extended foreground color
                    i = ProcessExtendedColor(i, true);
                    break;
                case 39: // Default foreground
                    _buffer.CurrentAttributes = _buffer.CurrentAttributes with
                    {
                        Foreground = TerminalColor.Default
                    };
                    break;
                case 40..47: // Standard background colors
                    _buffer.CurrentAttributes = _buffer.CurrentAttributes with
                    {
                        Background = GetStandardColor(param - 40)
                    };
                    break;
                case 48: // Extended background color
                    i = ProcessExtendedColor(i, false);
                    break;
                case 49: // Default background
                    _buffer.CurrentAttributes = _buffer.CurrentAttributes with
                    {
                        Background = TerminalColor.Default
                    };
                    break;
                case 90..97: // Bright foreground colors
                    _buffer.CurrentAttributes = _buffer.CurrentAttributes with
                    {
                        Foreground = GetBrightColor(param - 90)
                    };
                    break;
                case 100..107: // Bright background colors
                    _buffer.CurrentAttributes = _buffer.CurrentAttributes with
                    {
                        Background = GetBrightColor(param - 100)
                    };
                    break;
            }
        }
    }

    public event Action? Bell;
    public event Action<string>? TitleChanged;
    public event Action<string>? WorkingDirectoryChanged;

    private void OnBell() => Bell?.Invoke();
}

public enum ParserState
{
    Ground,
    Escape,
    EscapeIntermediate,
    Csi,
    CsiParam,
    CsiIntermediate,
    Osc,
    OscString,
    Dcs,
    SosPmApc
}
```

### ITerminalService Interface

```csharp
namespace SeniorIntern.Core.Interfaces;

public interface ITerminalService
{
    /// <summary>
    /// Currently active terminal sessions
    /// </summary>
    IReadOnlyList<TerminalSession> Sessions { get; }

    /// <summary>
    /// Active (focused) session
    /// </summary>
    TerminalSession? ActiveSession { get; set; }

    /// <summary>
    /// Create a new terminal session
    /// </summary>
    Task<TerminalSession> CreateSessionAsync(
        TerminalSessionOptions? options = null,
        CancellationToken ct = default);

    /// <summary>
    /// Close a terminal session
    /// </summary>
    Task CloseSessionAsync(Guid sessionId, CancellationToken ct = default);

    /// <summary>
    /// Write input to a session (user keystrokes)
    /// </summary>
    Task WriteInputAsync(Guid sessionId, string input, CancellationToken ct = default);

    /// <summary>
    /// Write input bytes to a session
    /// </summary>
    Task WriteInputAsync(Guid sessionId, ReadOnlyMemory<byte> data, CancellationToken ct = default);

    /// <summary>
    /// Resize a terminal session
    /// </summary>
    Task ResizeAsync(Guid sessionId, TerminalSize size, CancellationToken ct = default);

    /// <summary>
    /// Send a signal to the terminal process
    /// </summary>
    Task SendSignalAsync(Guid sessionId, TerminalSignal signal, CancellationToken ct = default);

    /// <summary>
    /// Get the terminal buffer for rendering
    /// </summary>
    TerminalBuffer GetBuffer(Guid sessionId);

    /// <summary>
    /// Change working directory
    /// </summary>
    Task ChangeDirectoryAsync(Guid sessionId, string path, CancellationToken ct = default);

    /// <summary>
    /// Execute a command and optionally wait for completion
    /// </summary>
    Task<CommandResult?> ExecuteCommandAsync(
        Guid sessionId,
        string command,
        bool waitForCompletion = false,
        CancellationToken ct = default);

    /// <summary>
    /// Events
    /// </summary>
    event EventHandler<TerminalOutputEventArgs>? OutputReceived;
    event EventHandler<TerminalSessionEventArgs>? SessionCreated;
    event EventHandler<TerminalSessionEventArgs>? SessionClosed;
    event EventHandler<TerminalSessionEventArgs>? SessionStateChanged;
}

public record TerminalSessionOptions(
    string? ShellPath = null,
    string? WorkingDirectory = null,
    Dictionary<string, string>? Environment = null,
    TerminalSize? Size = null,
    Guid? WorkspaceId = null,
    string? Name = null
);

public enum TerminalSignal
{
    Interrupt,  // Ctrl+C (SIGINT)
    Terminate,  // SIGTERM
    Kill,       // SIGKILL
    Suspend,    // Ctrl+Z (SIGTSTP)
    Continue    // SIGCONT
}

public sealed class TerminalOutputEventArgs : EventArgs
{
    public Guid SessionId { get; init; }
    public ReadOnlyMemory<byte> Data { get; init; }
}

public sealed class TerminalSessionEventArgs : EventArgs
{
    public TerminalSession Session { get; init; } = null!;
}

public sealed class CommandResult
{
    public int ExitCode { get; init; }
    public string Output { get; init; } = string.Empty;
    public string Error { get; init; } = string.Empty;
    public TimeSpan Duration { get; init; }
    public bool TimedOut { get; init; }
}
```

### TerminalService Implementation (Pty.Net)

```csharp
namespace SeniorIntern.Services;

using Pty.Net;

public sealed class TerminalService : ITerminalService, IAsyncDisposable
{
    private readonly IShellDetectionService _shellDetection;
    private readonly ConcurrentDictionary<Guid, TerminalSessionContext> _sessions = new();

    private sealed class TerminalSessionContext : IAsyncDisposable
    {
        public TerminalSession Session { get; init; } = null!;
        public IPtyConnection Pty { get; init; } = null!;
        public TerminalBuffer Buffer { get; init; } = null!;
        public AnsiParser Parser { get; init; } = null!;
        public CancellationTokenSource Cts { get; } = new();
        public Task ReadTask { get; set; } = Task.CompletedTask;

        public async ValueTask DisposeAsync()
        {
            Cts.Cancel();
            try { await ReadTask; } catch { }
            Cts.Dispose();
            Pty.Dispose();
        }
    }

    public async Task<TerminalSession> CreateSessionAsync(
        TerminalSessionOptions? options = null,
        CancellationToken ct = default)
    {
        options ??= new TerminalSessionOptions();

        var shellPath = options.ShellPath ?? await _shellDetection.GetDefaultShellAsync();
        var workingDirectory = options.WorkingDirectory
            ?? Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
        var size = options.Size ?? TerminalSize.Default;

        var session = new TerminalSession
        {
            Name = options.Name ?? GetShellDisplayName(shellPath),
            ShellPath = shellPath,
            WorkingDirectory = workingDirectory,
            Size = size,
            WorkspaceId = options.WorkspaceId,
            Environment = options.Environment ?? new()
        };

        // Create PTY
        var ptyOptions = new PtyOptions
        {
            Name = session.Name,
            Cols = size.Columns,
            Rows = size.Rows,
            Cwd = workingDirectory,
            App = shellPath,
            Environment = BuildEnvironment(options.Environment)
        };

        var pty = await PtyProvider.SpawnAsync(ptyOptions, ct);

        var buffer = new TerminalBuffer(size.Columns, size.Rows);
        var parser = new AnsiParser(buffer);

        // Set up event handlers
        parser.TitleChanged += title => session.Name = title;
        parser.WorkingDirectoryChanged += dir => session.WorkingDirectory = dir;

        var context = new TerminalSessionContext
        {
            Session = session,
            Pty = pty,
            Buffer = buffer,
            Parser = parser
        };

        // Start reading output
        context.ReadTask = ReadOutputAsync(context);

        _sessions[session.Id] = context;
        session.State = TerminalSessionState.Running;

        SessionCreated?.Invoke(this, new TerminalSessionEventArgs { Session = session });

        return session;
    }

    private async Task ReadOutputAsync(TerminalSessionContext context)
    {
        var buffer = new byte[4096];

        try
        {
            while (!context.Cts.Token.IsCancellationRequested)
            {
                var bytesRead = await context.Pty.ReaderStream.ReadAsync(
                    buffer, context.Cts.Token);

                if (bytesRead == 0)
                    break;

                var data = buffer.AsMemory(0, bytesRead);

                // Parse ANSI sequences
                context.Parser.Parse(data.Span);

                // Notify listeners
                OutputReceived?.Invoke(this, new TerminalOutputEventArgs
                {
                    SessionId = context.Session.Id,
                    Data = data
                });
            }
        }
        catch (OperationCanceledException)
        {
            // Expected on close
        }
        catch (Exception ex)
        {
            context.Session.State = TerminalSessionState.Error;
            // Log error
        }
        finally
        {
            context.Session.State = TerminalSessionState.Exited;
            context.Session.ExitCode = context.Pty.ExitCode;
            context.Session.ClosedAt = DateTime.UtcNow;

            SessionClosed?.Invoke(this, new TerminalSessionEventArgs
            {
                Session = context.Session
            });
        }
    }

    public async Task WriteInputAsync(Guid sessionId, string input, CancellationToken ct = default)
    {
        if (!_sessions.TryGetValue(sessionId, out var context))
            throw new InvalidOperationException($"Session {sessionId} not found");

        var bytes = Encoding.UTF8.GetBytes(input);
        await context.Pty.WriterStream.WriteAsync(bytes, ct);
        await context.Pty.WriterStream.FlushAsync(ct);
    }

    public async Task ResizeAsync(Guid sessionId, TerminalSize size, CancellationToken ct = default)
    {
        if (!_sessions.TryGetValue(sessionId, out var context))
            throw new InvalidOperationException($"Session {sessionId} not found");

        context.Pty.Resize(size.Columns, size.Rows);
        context.Buffer.Resize(size.Columns, size.Rows);
        context.Session.Size = size;
    }

    public async Task SendSignalAsync(Guid sessionId, TerminalSignal signal, CancellationToken ct = default)
    {
        if (!_sessions.TryGetValue(sessionId, out var context))
            throw new InvalidOperationException($"Session {sessionId} not found");

        // Write control character
        var controlChar = signal switch
        {
            TerminalSignal.Interrupt => "\x03",  // Ctrl+C
            TerminalSignal.Suspend => "\x1A",    // Ctrl+Z
            _ => throw new NotSupportedException($"Signal {signal} not supported via PTY")
        };

        await WriteInputAsync(sessionId, controlChar, ct);
    }

    public TerminalBuffer GetBuffer(Guid sessionId)
    {
        return _sessions.TryGetValue(sessionId, out var context)
            ? context.Buffer
            : throw new InvalidOperationException($"Session {sessionId} not found");
    }

    private Dictionary<string, string> BuildEnvironment(Dictionary<string, string>? custom)
    {
        var env = new Dictionary<string, string>(Environment.GetEnvironmentVariables()
            .Cast<DictionaryEntry>()
            .ToDictionary(e => e.Key.ToString()!, e => e.Value?.ToString() ?? ""));

        // Set TERM for proper escape sequence support
        env["TERM"] = "xterm-256color";
        env["COLORTERM"] = "truecolor";

        // Add custom environment
        if (custom != null)
        {
            foreach (var (key, value) in custom)
            {
                env[key] = value;
            }
        }

        return env;
    }

    public event EventHandler<TerminalOutputEventArgs>? OutputReceived;
    public event EventHandler<TerminalSessionEventArgs>? SessionCreated;
    public event EventHandler<TerminalSessionEventArgs>? SessionClosed;
    public event EventHandler<TerminalSessionEventArgs>? SessionStateChanged;

    public async ValueTask DisposeAsync()
    {
        foreach (var context in _sessions.Values)
        {
            await context.DisposeAsync();
        }
        _sessions.Clear();
    }
}
```

### Files to Create (v0.5.1)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Models/TerminalSession.cs` | Session model |
| `src/SeniorIntern.Core/Models/TerminalBuffer.cs` | Buffer/screen model |
| `src/SeniorIntern.Core/Models/TerminalTypes.cs` | Cell, Color, Attributes |
| `src/SeniorIntern.Core/Terminal/AnsiParser.cs` | ANSI escape parser |
| `src/SeniorIntern.Core/Interfaces/ITerminalService.cs` | Service interface |
| `src/SeniorIntern.Services/TerminalService.cs` | PTY-based implementation |

### Files to Modify (v0.5.1)

| File | Changes |
|------|---------|
| `Directory.Packages.props` | Add Pty.Net package |
| `src/SeniorIntern.Services/SeniorIntern.Services.csproj` | Reference Pty.Net |

### Testing Strategy (v0.5.1)
- Unit tests for ANSI parser (escape sequences)
- Unit tests for terminal buffer operations
- Integration tests for PTY creation
- Cross-platform PTY tests (Windows/macOS/Linux)

---

## v0.5.2: Terminal UI

### Objective
Create the Avalonia terminal control with proper rendering, resize handling, selection support, and integration into the main window layout.

### Terminal Control Architecture

```
TerminalPanel (Container)
├── TerminalTabBar
│   ├── TerminalTab[0..n]
│   └── NewTabButton
├── TerminalView (Active Tab Content)
│   ├── TerminalRenderer (Canvas)
│   ├── TerminalCaret (Animated cursor)
│   └── TerminalSelection (Overlay)
└── TerminalScrollBar
```

### TerminalControl (Main Control)

```csharp
namespace SeniorIntern.Desktop.Controls;

public partial class TerminalControl : UserControl
{
    private readonly TerminalBuffer _buffer;
    private readonly ITerminalService _terminalService;
    private Guid _sessionId;

    // Rendering
    private SKTypeface? _typeface;
    private float _charWidth;
    private float _charHeight;
    private float _lineHeight;

    // Selection
    private TerminalSelection? _selection;
    private bool _isSelecting;
    private Point _selectionStart;

    // Scrolling
    private int _scrollOffset;

    public static readonly StyledProperty<string> FontFamilyProperty =
        AvaloniaProperty.Register<TerminalControl, string>(nameof(FontFamily), "Cascadia Mono");

    public static readonly StyledProperty<double> FontSizeProperty =
        AvaloniaProperty.Register<TerminalControl, double>(nameof(FontSize), 14.0);

    public TerminalControl()
    {
        InitializeComponent();

        Focusable = true;
        ClipToBounds = true;

        // Set up input handling
        KeyDown += OnKeyDown;
        TextInput += OnTextInput;
        PointerPressed += OnPointerPressed;
        PointerMoved += OnPointerMoved;
        PointerReleased += OnPointerReleased;
        PointerWheelChanged += OnPointerWheelChanged;

        // Handle resize
        PropertyChanged += (s, e) =>
        {
            if (e.Property == BoundsProperty)
                OnSizeChanged();
        };
    }

    public async Task AttachSessionAsync(Guid sessionId)
    {
        _sessionId = sessionId;
        _buffer = _terminalService.GetBuffer(sessionId);

        // Subscribe to output
        _terminalService.OutputReceived += OnOutputReceived;

        // Sync size
        await SyncSizeAsync();

        InvalidateVisual();
    }

    private void OnOutputReceived(object? sender, TerminalOutputEventArgs e)
    {
        if (e.SessionId != _sessionId)
            return;

        // Re-render on UI thread
        Dispatcher.UIThread.Post(() => InvalidateVisual());
    }

    private async void OnSizeChanged()
    {
        await SyncSizeAsync();
    }

    private async Task SyncSizeAsync()
    {
        if (_sessionId == Guid.Empty || _charWidth == 0 || _charHeight == 0)
            return;

        var cols = (int)(Bounds.Width / _charWidth);
        var rows = (int)(Bounds.Height / _lineHeight);

        if (cols > 0 && rows > 0)
        {
            await _terminalService.ResizeAsync(_sessionId, new TerminalSize(cols, rows));
        }
    }

    protected override void OnKeyDown(KeyEventArgs e)
    {
        base.OnKeyDown(e);

        // Handle special keys
        var sequence = GetKeySequence(e);
        if (sequence != null)
        {
            _ = _terminalService.WriteInputAsync(_sessionId, sequence);
            e.Handled = true;
        }
    }

    private string? GetKeySequence(KeyEventArgs e)
    {
        var ctrl = e.KeyModifiers.HasFlag(KeyModifiers.Control);
        var alt = e.KeyModifiers.HasFlag(KeyModifiers.Alt);
        var shift = e.KeyModifiers.HasFlag(KeyModifiers.Shift);

        return e.Key switch
        {
            Key.Enter => "\r",
            Key.Escape => "\x1B",
            Key.Tab => shift ? "\x1B[Z" : "\t",
            Key.Back => "\x7F",
            Key.Delete => "\x1B[3~",
            Key.Up => "\x1B[A",
            Key.Down => "\x1B[B",
            Key.Right => "\x1B[C",
            Key.Left => "\x1B[D",
            Key.Home => "\x1B[H",
            Key.End => "\x1B[F",
            Key.PageUp => "\x1B[5~",
            Key.PageDown => "\x1B[6~",
            Key.Insert => "\x1B[2~",
            Key.F1 => "\x1BOP",
            Key.F2 => "\x1BOQ",
            Key.F3 => "\x1BOR",
            Key.F4 => "\x1BOS",
            Key.F5 => "\x1B[15~",
            Key.F6 => "\x1B[17~",
            Key.F7 => "\x1B[18~",
            Key.F8 => "\x1B[19~",
            Key.F9 => "\x1B[20~",
            Key.F10 => "\x1B[21~",
            Key.F11 => "\x1B[23~",
            Key.F12 => "\x1B[24~",

            // Ctrl+Key combinations
            Key.C when ctrl => "\x03", // SIGINT
            Key.Z when ctrl => "\x1A", // SIGTSTP
            Key.D when ctrl => "\x04", // EOF
            Key.L when ctrl => "\x0C", // Clear

            // Ctrl+Letter (A-Z = 1-26)
            var k when ctrl && k >= Key.A && k <= Key.Z =>
                ((char)(k - Key.A + 1)).ToString(),

            _ => null
        };
    }

    protected override void OnTextInput(TextInputEventArgs e)
    {
        base.OnTextInput(e);

        if (!string.IsNullOrEmpty(e.Text))
        {
            _ = _terminalService.WriteInputAsync(_sessionId, e.Text);
            e.Handled = true;
        }
    }

    // Copy/Paste
    public async Task CopySelectionAsync()
    {
        if (_selection == null) return;

        var text = _buffer.GetText(_selection);
        if (!string.IsNullOrEmpty(text))
        {
            await Application.Current!.Clipboard!.SetTextAsync(text);
        }
    }

    public async Task PasteAsync()
    {
        var text = await Application.Current!.Clipboard!.GetTextAsync();
        if (!string.IsNullOrEmpty(text))
        {
            // Sanitize for terminal (convert newlines)
            text = text.Replace("\r\n", "\r").Replace("\n", "\r");
            await _terminalService.WriteInputAsync(_sessionId, text);
        }
    }
}
```

### TerminalRenderer (SkiaSharp Rendering)

```csharp
namespace SeniorIntern.Desktop.Controls;

public class TerminalRenderer : Control
{
    private TerminalBuffer? _buffer;
    private TerminalTheme _theme = TerminalTheme.Default;

    // Font metrics
    private SKTypeface _typeface = SKTypeface.FromFamilyName("Cascadia Mono");
    private float _fontSize = 14f;
    private float _charWidth;
    private float _lineHeight;
    private float _baseline;

    public void SetBuffer(TerminalBuffer buffer)
    {
        _buffer = buffer;
    }

    public void SetTheme(TerminalTheme theme)
    {
        _theme = theme;
        InvalidateVisual();
    }

    protected override void OnLoaded(RoutedEventArgs e)
    {
        base.OnLoaded(e);
        CalculateFontMetrics();
    }

    private void CalculateFontMetrics()
    {
        using var paint = new SKPaint
        {
            Typeface = _typeface,
            TextSize = _fontSize
        };

        var metrics = paint.FontMetrics;
        _charWidth = paint.MeasureText("M");
        _lineHeight = metrics.Descent - metrics.Ascent + metrics.Leading;
        _baseline = -metrics.Ascent;
    }

    public override void Render(DrawingContext context)
    {
        if (_buffer == null) return;

        // Get SkiaSharp context
        var skiaContext = context as ISkiaDrawingContextImpl;
        if (skiaContext?.SkCanvas == null) return;

        var canvas = skiaContext.SkCanvas;

        // Draw background
        canvas.Clear(_theme.GetSKColor(TerminalThemeColor.Background));

        using var textPaint = new SKPaint
        {
            Typeface = _typeface,
            TextSize = _fontSize,
            IsAntialias = true
        };

        using var bgPaint = new SKPaint();

        var visibleLines = _buffer.GetVisibleLines();
        float y = 0;

        foreach (var line in visibleLines)
        {
            float x = 0;

            foreach (var cell in line.Cells)
            {
                // Draw cell background if not default
                if (!cell.Attributes.Background.IsDefault || cell.Attributes.Inverse)
                {
                    var bgColor = cell.Attributes.Inverse
                        ? GetForegroundColor(cell.Attributes)
                        : GetBackgroundColor(cell.Attributes);

                    bgPaint.Color = bgColor;
                    canvas.DrawRect(x, y, _charWidth, _lineHeight, bgPaint);
                }

                // Draw character
                if (cell.Character != ' ' && cell.Character != '\0')
                {
                    var fgColor = cell.Attributes.Inverse
                        ? GetBackgroundColor(cell.Attributes)
                        : GetForegroundColor(cell.Attributes);

                    textPaint.Color = fgColor;
                    textPaint.FakeBoldText = cell.Attributes.Bold;

                    // Underline
                    if (cell.Attributes.Underline)
                    {
                        canvas.DrawLine(x, y + _lineHeight - 2, x + _charWidth, y + _lineHeight - 2, textPaint);
                    }

                    // Strikethrough
                    if (cell.Attributes.Strikethrough)
                    {
                        canvas.DrawLine(x, y + _lineHeight / 2, x + _charWidth, y + _lineHeight / 2, textPaint);
                    }

                    canvas.DrawText(cell.Character.ToString(), x, y + _baseline, textPaint);
                }

                x += _charWidth;
            }

            y += _lineHeight;
        }

        // Draw cursor
        if (_buffer.CursorVisible)
        {
            var cursorX = _buffer.CursorX * _charWidth;
            var cursorY = _buffer.CursorY * _lineHeight;

            using var cursorPaint = new SKPaint
            {
                Color = _theme.GetSKColor(TerminalThemeColor.Cursor),
                Style = IsFocused ? SKPaintStyle.Fill : SKPaintStyle.Stroke,
                StrokeWidth = 1
            };

            canvas.DrawRect(cursorX, cursorY, _charWidth, _lineHeight, cursorPaint);
        }

        // Draw selection overlay
        if (_selection != null)
        {
            using var selectionPaint = new SKPaint
            {
                Color = _theme.GetSKColor(TerminalThemeColor.Selection),
                Style = SKPaintStyle.Fill
            };

            DrawSelection(canvas, selectionPaint);
        }
    }

    private SKColor GetForegroundColor(TerminalAttributes attrs)
    {
        if (attrs.Foreground.IsDefault)
            return _theme.GetSKColor(TerminalThemeColor.Foreground);

        if (attrs.Foreground.PaletteIndex.HasValue)
            return _theme.GetPaletteColor(attrs.Foreground.PaletteIndex.Value);

        return new SKColor(attrs.Foreground.R, attrs.Foreground.G, attrs.Foreground.B);
    }

    private SKColor GetBackgroundColor(TerminalAttributes attrs)
    {
        if (attrs.Background.IsDefault)
            return _theme.GetSKColor(TerminalThemeColor.Background);

        if (attrs.Background.PaletteIndex.HasValue)
            return _theme.GetPaletteColor(attrs.Background.PaletteIndex.Value);

        return new SKColor(attrs.Background.R, attrs.Background.G, attrs.Background.B);
    }

    private bool IsFocused => TopLevel.GetTopLevel(this)?.FocusManager?.GetFocusedElement() == this;
}
```

### Terminal Theme

```csharp
namespace SeniorIntern.Core.Models;

public sealed class TerminalTheme
{
    public string Name { get; init; } = "Default";

    // Standard colors
    public TerminalColor Background { get; init; }
    public TerminalColor Foreground { get; init; }
    public TerminalColor Cursor { get; init; }
    public TerminalColor Selection { get; init; }

    // 16-color palette (standard ANSI)
    public TerminalColor[] Palette { get; init; } = new TerminalColor[16];

    public static TerminalTheme Default => new()
    {
        Name = "Dark",
        Background = TerminalColor.FromRgb(30, 30, 30),
        Foreground = TerminalColor.FromRgb(204, 204, 204),
        Cursor = TerminalColor.FromRgb(204, 204, 204),
        Selection = TerminalColor.FromRgb(68, 68, 68),
        Palette = new[]
        {
            TerminalColor.FromRgb(0, 0, 0),       // 0: Black
            TerminalColor.FromRgb(205, 49, 49),   // 1: Red
            TerminalColor.FromRgb(13, 188, 121),  // 2: Green
            TerminalColor.FromRgb(229, 229, 16),  // 3: Yellow
            TerminalColor.FromRgb(36, 114, 200),  // 4: Blue
            TerminalColor.FromRgb(188, 63, 188),  // 5: Magenta
            TerminalColor.FromRgb(17, 168, 205),  // 6: Cyan
            TerminalColor.FromRgb(229, 229, 229), // 7: White
            TerminalColor.FromRgb(102, 102, 102), // 8: Bright Black
            TerminalColor.FromRgb(241, 76, 76),   // 9: Bright Red
            TerminalColor.FromRgb(35, 209, 139),  // 10: Bright Green
            TerminalColor.FromRgb(245, 245, 67),  // 11: Bright Yellow
            TerminalColor.FromRgb(59, 142, 234),  // 12: Bright Blue
            TerminalColor.FromRgb(214, 112, 214), // 13: Bright Magenta
            TerminalColor.FromRgb(41, 184, 219),  // 14: Bright Cyan
            TerminalColor.FromRgb(255, 255, 255), // 15: Bright White
        }
    };

    public SKColor GetSKColor(TerminalThemeColor color) => color switch
    {
        TerminalThemeColor.Background => ToSKColor(Background),
        TerminalThemeColor.Foreground => ToSKColor(Foreground),
        TerminalThemeColor.Cursor => ToSKColor(Cursor),
        TerminalThemeColor.Selection => ToSKColor(Selection).WithAlpha(80),
        _ => SKColors.White
    };

    public SKColor GetPaletteColor(int index)
    {
        if (index < 16)
            return ToSKColor(Palette[index]);

        // 256-color mode: 16-231 are color cube, 232-255 are grayscale
        if (index < 232)
        {
            // 6x6x6 color cube
            index -= 16;
            int r = (index / 36) * 51;
            int g = ((index / 6) % 6) * 51;
            int b = (index % 6) * 51;
            return new SKColor((byte)r, (byte)g, (byte)b);
        }
        else
        {
            // Grayscale
            int gray = (index - 232) * 10 + 8;
            return new SKColor((byte)gray, (byte)gray, (byte)gray);
        }
    }

    private static SKColor ToSKColor(TerminalColor c) =>
        new SKColor(c.R, c.G, c.B);
}

public enum TerminalThemeColor
{
    Background,
    Foreground,
    Cursor,
    Selection
}
```

### Terminal Panel Layout

```xml
<!-- TerminalPanel.axaml -->
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:local="using:SeniorIntern.Desktop.Controls"
             x:Class="SeniorIntern.Desktop.Views.TerminalPanel"
             x:DataType="vm:TerminalPanelViewModel">

    <Grid RowDefinitions="Auto, *">
        <!-- Tab Bar -->
        <Border Grid.Row="0" Classes="terminal-tab-bar"
                Background="{DynamicResource TerminalTabBarBackground}">
            <Grid ColumnDefinitions="*, Auto, Auto">
                <!-- Tabs -->
                <ItemsControl ItemsSource="{Binding Sessions}">
                    <ItemsControl.ItemsPanel>
                        <ItemsPanelTemplate>
                            <StackPanel Orientation="Horizontal" />
                        </ItemsPanelTemplate>
                    </ItemsControl.ItemsPanel>
                    <ItemsControl.ItemTemplate>
                        <DataTemplate>
                            <Button Classes="terminal-tab"
                                    Classes.active="{Binding IsActive}"
                                    Command="{Binding $parent[UserControl].DataContext.ActivateSessionCommand}"
                                    CommandParameter="{Binding}">
                                <Grid ColumnDefinitions="Auto, *, Auto">
                                    <PathIcon Data="{StaticResource TerminalIcon}"
                                              Width="14" Height="14" />
                                    <TextBlock Grid.Column="1" Text="{Binding Name}"
                                               Margin="6,0" MaxWidth="150"
                                               TextTrimming="CharacterEllipsis" />
                                    <Button Grid.Column="2" Classes="tab-close"
                                            Command="{Binding $parent[UserControl].DataContext.CloseSessionCommand}"
                                            CommandParameter="{Binding}"
                                            ToolTip.Tip="Close terminal">
                                        <PathIcon Data="{StaticResource CloseIcon}"
                                                  Width="10" Height="10" />
                                    </Button>
                                </Grid>
                            </Button>
                        </DataTemplate>
                    </ItemsControl.ItemTemplate>
                </ItemsControl>

                <!-- New Tab Button -->
                <Button Grid.Column="1" Classes="new-tab-button"
                        Command="{Binding NewSessionCommand}"
                        ToolTip.Tip="New terminal (Ctrl+Shift+`)">
                    <PathIcon Data="{StaticResource AddIcon}" Width="14" Height="14" />
                </Button>

                <!-- Panel Actions -->
                <StackPanel Grid.Column="2" Orientation="Horizontal" Spacing="4">
                    <Button Classes="icon-button"
                            Command="{Binding MaximizeCommand}"
                            ToolTip.Tip="Maximize terminal">
                        <PathIcon Data="{StaticResource MaximizeIcon}" Width="14" Height="14" />
                    </Button>
                    <Button Classes="icon-button"
                            Command="{Binding HidePanelCommand}"
                            ToolTip.Tip="Hide terminal (Ctrl+`)">
                        <PathIcon Data="{StaticResource ChevronDownIcon}" Width="14" Height="14" />
                    </Button>
                </StackPanel>
            </Grid>
        </Border>

        <!-- Terminal Content -->
        <local:TerminalControl Grid.Row="1"
                               x:Name="TerminalView"
                               FontFamily="{Binding Settings.TerminalFontFamily}"
                               FontSize="{Binding Settings.TerminalFontSize}" />
    </Grid>
</UserControl>
```

### Main Window Integration

```xml
<!-- MainWindow.axaml additions -->
<Grid RowDefinitions="*, Auto, Auto">
    <!-- Main Content (Editor + Chat) -->
    <Grid Grid.Row="0" ... />

    <!-- Terminal Resize Handle -->
    <GridSplitter Grid.Row="1"
                  Height="4"
                  Background="Transparent"
                  IsVisible="{Binding IsTerminalVisible}"
                  ResizeDirection="Rows" />

    <!-- Terminal Panel -->
    <local:TerminalPanel Grid.Row="2"
                         Height="{Binding TerminalHeight}"
                         MinHeight="100"
                         MaxHeight="500"
                         IsVisible="{Binding IsTerminalVisible}" />
</Grid>
```

### Files to Create (v0.5.2)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/Controls/TerminalControl.axaml` | Main terminal control |
| `src/SeniorIntern.Desktop/Controls/TerminalControl.axaml.cs` | Terminal control code |
| `src/SeniorIntern.Desktop/Controls/TerminalRenderer.cs` | SkiaSharp rendering |
| `src/SeniorIntern.Desktop/Views/TerminalPanel.axaml` | Terminal panel with tabs |
| `src/SeniorIntern.Desktop/ViewModels/TerminalPanelViewModel.cs` | Panel ViewModel |
| `src/SeniorIntern.Desktop/ViewModels/TerminalSessionViewModel.cs` | Session ViewModel |
| `src/SeniorIntern.Core/Models/TerminalTheme.cs` | Theme model |

### Files to Modify (v0.5.2)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/Views/MainWindow.axaml` | Add terminal panel |
| `src/SeniorIntern.Desktop/ViewModels/MainWindowViewModel.cs` | Add terminal state |
| `src/SeniorIntern.Desktop/Themes/Dark.axaml` | Add terminal styles |

### Testing Strategy (v0.5.2)
- Visual tests for rendering accuracy
- Resize behavior tests
- Selection and copy/paste tests
- Keyboard input tests
- Multi-tab functionality tests

---

## v0.5.3: Shell Integration

### Objective
Implement shell detection, profile management, working directory synchronization with the file explorer, and shell-specific features.

### IShellDetectionService Interface

```csharp
namespace SeniorIntern.Core.Interfaces;

public interface IShellDetectionService
{
    /// <summary>
    /// Get the user's default shell
    /// </summary>
    Task<string> GetDefaultShellAsync();

    /// <summary>
    /// Get all available shells on the system
    /// </summary>
    Task<IReadOnlyList<ShellInfo>> GetAvailableShellsAsync();

    /// <summary>
    /// Detect shell type from path
    /// </summary>
    ShellType DetectShellType(string shellPath);

    /// <summary>
    /// Get shell-specific configuration
    /// </summary>
    ShellConfiguration GetConfiguration(ShellType shellType);
}

public sealed class ShellInfo
{
    public string Name { get; init; } = string.Empty;
    public string Path { get; init; } = string.Empty;
    public ShellType Type { get; init; }
    public string? Version { get; init; }
    public bool IsDefault { get; init; }
}

public enum ShellType
{
    Unknown,
    Bash,
    Zsh,
    Fish,
    PowerShell,
    Cmd,
    Sh,
    Tcsh,
    Ksh,
    Nushell
}

public sealed class ShellConfiguration
{
    public ShellType Type { get; init; }
    public string ClearCommand { get; init; } = "clear";
    public string ChangeDirectoryCommand { get; init; } = "cd";
    public string PrintWorkingDirectoryCommand { get; init; } = "pwd";
    public string HistoryCommand { get; init; } = "history";
    public string? CwdEscapeSequence { get; init; } // OSC 7 support
    public bool SupportsOsc7 { get; init; }
    public string[] ProfileFiles { get; init; } = Array.Empty<string>();
}
```

### ShellDetectionService Implementation

```csharp
namespace SeniorIntern.Services;

public sealed class ShellDetectionService : IShellDetectionService
{
    public async Task<string> GetDefaultShellAsync()
    {
        if (OperatingSystem.IsWindows())
        {
            // Check for PowerShell Core first, then Windows PowerShell, then cmd
            var pwshPath = await FindExecutableAsync("pwsh");
            if (pwshPath != null) return pwshPath;

            var powershellPath = Path.Combine(
                Environment.GetFolderPath(Environment.SpecialFolder.System),
                "WindowsPowerShell", "v1.0", "powershell.exe");
            if (File.Exists(powershellPath)) return powershellPath;

            return Path.Combine(
                Environment.GetFolderPath(Environment.SpecialFolder.System),
                "cmd.exe");
        }
        else
        {
            // Unix: Use SHELL environment variable
            var shell = Environment.GetEnvironmentVariable("SHELL");
            if (!string.IsNullOrEmpty(shell) && File.Exists(shell))
                return shell;

            // Fallback to /bin/bash or /bin/sh
            if (File.Exists("/bin/bash")) return "/bin/bash";
            if (File.Exists("/bin/sh")) return "/bin/sh";

            throw new InvalidOperationException("No shell found");
        }
    }

    public async Task<IReadOnlyList<ShellInfo>> GetAvailableShellsAsync()
    {
        var shells = new List<ShellInfo>();
        var defaultShell = await GetDefaultShellAsync();

        if (OperatingSystem.IsWindows())
        {
            // PowerShell Core
            var pwshPath = await FindExecutableAsync("pwsh");
            if (pwshPath != null)
            {
                shells.Add(new ShellInfo
                {
                    Name = "PowerShell",
                    Path = pwshPath,
                    Type = ShellType.PowerShell,
                    IsDefault = pwshPath == defaultShell
                });
            }

            // Windows PowerShell
            var powershellPath = Path.Combine(
                Environment.GetFolderPath(Environment.SpecialFolder.System),
                "WindowsPowerShell", "v1.0", "powershell.exe");
            if (File.Exists(powershellPath) && powershellPath != pwshPath)
            {
                shells.Add(new ShellInfo
                {
                    Name = "Windows PowerShell",
                    Path = powershellPath,
                    Type = ShellType.PowerShell,
                    IsDefault = powershellPath == defaultShell
                });
            }

            // Command Prompt
            var cmdPath = Path.Combine(
                Environment.GetFolderPath(Environment.SpecialFolder.System),
                "cmd.exe");
            if (File.Exists(cmdPath))
            {
                shells.Add(new ShellInfo
                {
                    Name = "Command Prompt",
                    Path = cmdPath,
                    Type = ShellType.Cmd,
                    IsDefault = cmdPath == defaultShell
                });
            }

            // Git Bash
            var gitBashPaths = new[]
            {
                @"C:\Program Files\Git\bin\bash.exe",
                @"C:\Program Files (x86)\Git\bin\bash.exe"
            };
            foreach (var path in gitBashPaths)
            {
                if (File.Exists(path))
                {
                    shells.Add(new ShellInfo
                    {
                        Name = "Git Bash",
                        Path = path,
                        Type = ShellType.Bash,
                        IsDefault = path == defaultShell
                    });
                    break;
                }
            }

            // WSL
            var wslPath = await FindExecutableAsync("wsl");
            if (wslPath != null)
            {
                shells.Add(new ShellInfo
                {
                    Name = "WSL",
                    Path = wslPath,
                    Type = ShellType.Bash,
                    IsDefault = false
                });
            }
        }
        else
        {
            // Read /etc/shells on Unix
            var etcShells = "/etc/shells";
            if (File.Exists(etcShells))
            {
                var shellPaths = await File.ReadAllLinesAsync(etcShells);
                foreach (var path in shellPaths)
                {
                    var trimmed = path.Trim();
                    if (string.IsNullOrEmpty(trimmed) || trimmed.StartsWith('#'))
                        continue;

                    if (File.Exists(trimmed))
                    {
                        var type = DetectShellType(trimmed);
                        shells.Add(new ShellInfo
                        {
                            Name = GetShellDisplayName(trimmed, type),
                            Path = trimmed,
                            Type = type,
                            IsDefault = trimmed == defaultShell
                        });
                    }
                }
            }
        }

        return shells;
    }

    public ShellType DetectShellType(string shellPath)
    {
        var fileName = Path.GetFileNameWithoutExtension(shellPath).ToLowerInvariant();

        return fileName switch
        {
            "bash" => ShellType.Bash,
            "zsh" => ShellType.Zsh,
            "fish" => ShellType.Fish,
            "pwsh" or "powershell" => ShellType.PowerShell,
            "cmd" => ShellType.Cmd,
            "sh" => ShellType.Sh,
            "tcsh" => ShellType.Tcsh,
            "ksh" => ShellType.Ksh,
            "nu" or "nushell" => ShellType.Nushell,
            _ => ShellType.Unknown
        };
    }

    public ShellConfiguration GetConfiguration(ShellType shellType)
    {
        return shellType switch
        {
            ShellType.Bash => new ShellConfiguration
            {
                Type = ShellType.Bash,
                ClearCommand = "clear",
                ChangeDirectoryCommand = "cd",
                PrintWorkingDirectoryCommand = "pwd",
                HistoryCommand = "history",
                SupportsOsc7 = true,
                ProfileFiles = new[] { "~/.bashrc", "~/.bash_profile", "~/.profile" }
            },
            ShellType.Zsh => new ShellConfiguration
            {
                Type = ShellType.Zsh,
                ClearCommand = "clear",
                ChangeDirectoryCommand = "cd",
                PrintWorkingDirectoryCommand = "pwd",
                HistoryCommand = "history",
                SupportsOsc7 = true,
                ProfileFiles = new[] { "~/.zshrc", "~/.zprofile" }
            },
            ShellType.Fish => new ShellConfiguration
            {
                Type = ShellType.Fish,
                ClearCommand = "clear",
                ChangeDirectoryCommand = "cd",
                PrintWorkingDirectoryCommand = "pwd",
                HistoryCommand = "history",
                SupportsOsc7 = true,
                ProfileFiles = new[] { "~/.config/fish/config.fish" }
            },
            ShellType.PowerShell => new ShellConfiguration
            {
                Type = ShellType.PowerShell,
                ClearCommand = "cls",
                ChangeDirectoryCommand = "Set-Location",
                PrintWorkingDirectoryCommand = "Get-Location",
                HistoryCommand = "Get-History",
                SupportsOsc7 = false,
                ProfileFiles = new[]
                {
                    "$PROFILE",
                    "$HOME\\Documents\\PowerShell\\Microsoft.PowerShell_profile.ps1"
                }
            },
            ShellType.Cmd => new ShellConfiguration
            {
                Type = ShellType.Cmd,
                ClearCommand = "cls",
                ChangeDirectoryCommand = "cd /d",
                PrintWorkingDirectoryCommand = "cd",
                HistoryCommand = "doskey /history",
                SupportsOsc7 = false,
                ProfileFiles = Array.Empty<string>()
            },
            _ => new ShellConfiguration
            {
                Type = shellType,
                ClearCommand = "clear",
                ChangeDirectoryCommand = "cd",
                PrintWorkingDirectoryCommand = "pwd",
                HistoryCommand = "history",
                SupportsOsc7 = false,
                ProfileFiles = Array.Empty<string>()
            }
        };
    }

    private async Task<string?> FindExecutableAsync(string name)
    {
        // Search PATH
        var pathVar = Environment.GetEnvironmentVariable("PATH") ?? "";
        var paths = pathVar.Split(Path.PathSeparator);

        foreach (var path in paths)
        {
            var exeName = OperatingSystem.IsWindows() ? $"{name}.exe" : name;
            var fullPath = Path.Combine(path, exeName);

            if (File.Exists(fullPath))
                return fullPath;
        }

        return null;
    }

    private string GetShellDisplayName(string path, ShellType type)
    {
        return type switch
        {
            ShellType.Bash => "Bash",
            ShellType.Zsh => "Zsh",
            ShellType.Fish => "Fish",
            ShellType.PowerShell => path.Contains("pwsh") ? "PowerShell" : "Windows PowerShell",
            ShellType.Cmd => "Command Prompt",
            ShellType.Sh => "sh",
            ShellType.Tcsh => "tcsh",
            ShellType.Ksh => "ksh",
            ShellType.Nushell => "Nushell",
            _ => Path.GetFileName(path)
        };
    }
}
```

### Shell Profile Model

```csharp
namespace SeniorIntern.Core.Models;

public sealed class ShellProfile
{
    public Guid Id { get; init; } = Guid.NewGuid();
    public string Name { get; set; } = "Default";
    public string ShellPath { get; set; } = string.Empty;
    public ShellType ShellType { get; set; }
    public string? StartingDirectory { get; set; }
    public string? Arguments { get; set; }
    public Dictionary<string, string> Environment { get; set; } = new();
    public bool IsDefault { get; set; }
    public string? IconPath { get; set; }

    // Appearance
    public string? FontFamily { get; set; }
    public double? FontSize { get; set; }
    public string? ThemeName { get; set; }
}
```

### Working Directory Synchronization

```csharp
namespace SeniorIntern.Desktop.ViewModels;

public partial class TerminalPanelViewModel : ViewModelBase
{
    private readonly ITerminalService _terminalService;
    private readonly IWorkspaceService _workspaceService;

    // When workspace changes, sync terminal directory
    public TerminalPanelViewModel(
        ITerminalService terminalService,
        IWorkspaceService workspaceService)
    {
        _terminalService = terminalService;
        _workspaceService = workspaceService;

        // Subscribe to workspace changes
        _workspaceService.WorkspaceChanged += OnWorkspaceChanged;
    }

    private async void OnWorkspaceChanged(object? sender, WorkspaceChangedEventArgs e)
    {
        if (e.CurrentWorkspace == null)
            return;

        // Option 1: Sync all terminals
        if (Settings.SyncAllTerminalsWithWorkspace)
        {
            foreach (var session in _terminalService.Sessions)
            {
                if (session.WorkspaceId == e.CurrentWorkspace.Id)
                {
                    await _terminalService.ChangeDirectoryAsync(
                        session.Id,
                        e.CurrentWorkspace.RootPath);
                }
            }
        }
        // Option 2: Only sync active terminal
        else if (Settings.SyncActiveTerminalWithWorkspace)
        {
            var activeSession = _terminalService.ActiveSession;
            if (activeSession != null)
            {
                await _terminalService.ChangeDirectoryAsync(
                    activeSession.Id,
                    e.CurrentWorkspace.RootPath);
            }
        }
    }

    [RelayCommand]
    private async Task SyncWithWorkspaceAsync()
    {
        var workspace = _workspaceService.CurrentWorkspace;
        var activeSession = _terminalService.ActiveSession;

        if (workspace != null && activeSession != null)
        {
            await _terminalService.ChangeDirectoryAsync(
                activeSession.Id,
                workspace.RootPath);
        }
    }

    [RelayCommand]
    private async Task OpenTerminalHereAsync(string path)
    {
        // Create new terminal at specific directory
        await _terminalService.CreateSessionAsync(new TerminalSessionOptions
        {
            WorkingDirectory = path,
            WorkspaceId = _workspaceService.CurrentWorkspace?.Id
        });
    }
}
```

### File Explorer Integration

```xml
<!-- FileExplorerView.axaml context menu additions -->
<MenuItem Header="Open in Integrated Terminal"
          Command="{Binding OpenTerminalHereCommand}"
          CommandParameter="{Binding SelectedItem.Path}"
          IsVisible="{Binding SelectedItem.IsDirectory}">
    <MenuItem.Icon>
        <PathIcon Data="{StaticResource TerminalIcon}" />
    </MenuItem.Icon>
</MenuItem>
```

### Terminal Settings

```csharp
public sealed class AppSettings
{
    // ... existing properties ...

    // Terminal settings (v0.5.0)
    public string TerminalFontFamily { get; set; } = "Cascadia Mono, Consolas, monospace";
    public double TerminalFontSize { get; set; } = 14;
    public int TerminalScrollbackLines { get; set; } = 10000;
    public bool TerminalBellEnabled { get; set; } = true;
    public bool SyncActiveTerminalWithWorkspace { get; set; } = true;
    public bool SyncAllTerminalsWithWorkspace { get; set; } = false;
    public Guid? DefaultShellProfileId { get; set; }
    public string TerminalTheme { get; set; } = "Dark";
    public bool TerminalCursorBlink { get; set; } = true;
    public TerminalCursorStyle TerminalCursorStyle { get; set; } = TerminalCursorStyle.Block;
    public double TerminalPanelHeight { get; set; } = 300;
}

public enum TerminalCursorStyle
{
    Block,
    Underline,
    Bar
}
```

### Files to Create (v0.5.3)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/IShellDetectionService.cs` | Shell detection interface |
| `src/SeniorIntern.Services/ShellDetectionService.cs` | Shell detection implementation |
| `src/SeniorIntern.Core/Models/ShellProfile.cs` | Shell profile model |
| `src/SeniorIntern.Desktop/ViewModels/ShellSelectorViewModel.cs` | Shell selector VM |
| `src/SeniorIntern.Desktop/Views/ShellSelectorDialog.axaml` | Shell selector UI |

### Files to Modify (v0.5.3)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Core/Models/AppSettings.cs` | Add terminal settings |
| `src/SeniorIntern.Desktop/ViewModels/TerminalPanelViewModel.cs` | Add workspace sync |
| `src/SeniorIntern.Desktop/Views/FileExplorerView.axaml` | Add "Open in Terminal" |

### Testing Strategy (v0.5.3)
- Shell detection tests per platform
- Directory synchronization tests
- Profile management tests
- Shell-specific command tests

---

## v0.5.4: Command Integration

### Objective
Enable seamless integration between AI-generated commands and the terminal, including copy-to-terminal functionality, command extraction from chat, and output capture for context.

### Command Detection in Chat

```csharp
namespace SeniorIntern.Core.Models;

public sealed class CommandBlock
{
    public Guid Id { get; init; } = Guid.NewGuid();
    public string Command { get; init; } = string.Empty;
    public string? Language { get; init; } // bash, powershell, cmd, etc.
    public string? WorkingDirectory { get; init; }
    public string? Description { get; init; }
    public Guid MessageId { get; init; }
    public int SequenceNumber { get; init; }
    public CommandBlockStatus Status { get; set; } = CommandBlockStatus.Pending;
}

public enum CommandBlockStatus
{
    Pending,
    Copied,
    Executed,
    Failed
}
```

### ICommandExtractorService Interface

```csharp
namespace SeniorIntern.Core.Interfaces;

public interface ICommandExtractorService
{
    /// <summary>
    /// Extract command blocks from a message
    /// </summary>
    IReadOnlyList<CommandBlock> ExtractCommands(string content, Guid messageId);

    /// <summary>
    /// Determine if a code block is a shell command
    /// </summary>
    bool IsShellCommand(string language, string content);

    /// <summary>
    /// Get the appropriate shell type for a command language
    /// </summary>
    ShellType? GetShellTypeForLanguage(string language);
}
```

### CommandExtractorService Implementation

```csharp
namespace SeniorIntern.Services;

public sealed class CommandExtractorService : ICommandExtractorService
{
    private static readonly HashSet<string> ShellLanguages = new(StringComparer.OrdinalIgnoreCase)
    {
        "bash", "sh", "shell", "zsh", "fish",
        "powershell", "pwsh", "ps1",
        "cmd", "batch", "bat",
        "console", "terminal"
    };

    private static readonly Regex CommandBlockPattern = new(
        @"```(?<lang>\w+)?\n(?<content>[\s\S]*?)```",
        RegexOptions.Compiled | RegexOptions.Multiline);

    private static readonly Regex InlineCommandPattern = new(
        @"`(?<cmd>[^`]+)`",
        RegexOptions.Compiled);

    public IReadOnlyList<CommandBlock> ExtractCommands(string content, Guid messageId)
    {
        var commands = new List<CommandBlock>();
        var sequence = 0;

        // Extract fenced code blocks
        var matches = CommandBlockPattern.Matches(content);
        foreach (Match match in matches)
        {
            var lang = match.Groups["lang"].Value;
            var commandContent = match.Groups["content"].Value.Trim();

            if (IsShellCommand(lang, commandContent))
            {
                commands.Add(new CommandBlock
                {
                    Command = commandContent,
                    Language = lang,
                    MessageId = messageId,
                    SequenceNumber = sequence++,
                    Description = ExtractDescription(content, match.Index)
                });
            }
        }

        // Also detect common command patterns in context
        // e.g., "Run the following command:" followed by inline code
        var lines = content.Split('\n');
        for (int i = 0; i < lines.Length; i++)
        {
            var line = lines[i];
            if (ContainsCommandIndicator(line))
            {
                // Check next line for inline command
                if (i + 1 < lines.Length)
                {
                    var nextLine = lines[i + 1].Trim();
                    var inlineMatch = InlineCommandPattern.Match(nextLine);
                    if (inlineMatch.Success && IsLikelyCommand(inlineMatch.Groups["cmd"].Value))
                    {
                        commands.Add(new CommandBlock
                        {
                            Command = inlineMatch.Groups["cmd"].Value,
                            MessageId = messageId,
                            SequenceNumber = sequence++,
                            Description = line.Trim()
                        });
                    }
                }
            }
        }

        return commands;
    }

    public bool IsShellCommand(string language, string content)
    {
        if (ShellLanguages.Contains(language))
            return true;

        // Heuristics for unlabeled code blocks
        if (string.IsNullOrEmpty(language))
        {
            return IsLikelyCommand(content);
        }

        return false;
    }

    private bool IsLikelyCommand(string content)
    {
        var lines = content.Split('\n', StringSplitOptions.RemoveEmptyEntries);
        if (lines.Length == 0) return false;

        // Single line or few lines
        if (lines.Length > 5) return false;

        var firstLine = lines[0].Trim();

        // Common command prefixes
        if (firstLine.StartsWith("$") || firstLine.StartsWith(">") ||
            firstLine.StartsWith("PS>") || firstLine.StartsWith("#"))
            return true;

        // Common commands
        var commonCommands = new[]
        {
            "npm", "yarn", "pnpm", "npx",
            "dotnet", "nuget",
            "git", "gh",
            "docker", "docker-compose",
            "kubectl", "helm",
            "pip", "python", "python3",
            "cargo", "rustc",
            "go", "make", "cmake",
            "cd", "ls", "dir", "mkdir", "rm", "cp", "mv",
            "cat", "echo", "grep", "find",
            "curl", "wget",
            "brew", "apt", "apt-get", "yum", "pacman"
        };

        var firstWord = firstLine.Split(' ', StringSplitOptions.RemoveEmptyEntries).FirstOrDefault() ?? "";
        return commonCommands.Any(cmd => firstWord.Equals(cmd, StringComparison.OrdinalIgnoreCase));
    }

    private bool ContainsCommandIndicator(string line)
    {
        var indicators = new[]
        {
            "run the following",
            "execute the command",
            "run this command",
            "use this command",
            "try running",
            "you can run",
            "enter the command"
        };

        var lowerLine = line.ToLowerInvariant();
        return indicators.Any(ind => lowerLine.Contains(ind));
    }

    public ShellType? GetShellTypeForLanguage(string language)
    {
        return language.ToLowerInvariant() switch
        {
            "bash" or "sh" or "shell" or "zsh" => ShellType.Bash,
            "fish" => ShellType.Fish,
            "powershell" or "pwsh" or "ps1" => ShellType.PowerShell,
            "cmd" or "batch" or "bat" => ShellType.Cmd,
            _ => null
        };
    }
}
```

### Command Block UI

```xml
<!-- CommandBlockControl.axaml -->
<UserControl xmlns="https://github.com/avaloniaui"
             x:Class="SeniorIntern.Desktop.Controls.CommandBlockControl"
             x:DataType="vm:CommandBlockViewModel">

    <Border Classes="command-block"
            Classes.executed="{Binding Status, Converter={StaticResource EnumConverter}, ConverterParameter=Executed}">
        <Grid RowDefinitions="Auto, Auto, Auto">
            <!-- Description (if any) -->
            <TextBlock Grid.Row="0"
                       Text="{Binding Description}"
                       IsVisible="{Binding Description, Converter={x:Static StringConverters.IsNotNullOrEmpty}}"
                       Foreground="{DynamicResource TextMuted}"
                       Margin="0,0,0,4"
                       FontSize="12" />

            <!-- Command Content -->
            <Border Grid.Row="1" Classes="command-content" Padding="12,8">
                <Grid ColumnDefinitions="Auto, *, Auto">
                    <TextBlock Text="$" Foreground="{DynamicResource TerminalPromptColor}"
                               FontFamily="Cascadia Mono" Margin="0,0,8,0" />
                    <SelectableTextBlock Grid.Column="1"
                                         Text="{Binding Command}"
                                         FontFamily="Cascadia Mono"
                                         FontSize="13"
                                         TextWrapping="Wrap" />
                </Grid>
            </Border>

            <!-- Actions -->
            <StackPanel Grid.Row="2" Orientation="Horizontal" Spacing="8" Margin="0,8,0,0">
                <Button Command="{Binding CopyCommand}"
                        ToolTip.Tip="Copy command">
                    <StackPanel Orientation="Horizontal" Spacing="4">
                        <PathIcon Data="{StaticResource CopyIcon}" Width="14" Height="14" />
                        <TextBlock Text="Copy" />
                    </StackPanel>
                </Button>

                <Button Command="{Binding SendToTerminalCommand}"
                        Classes="accent"
                        ToolTip.Tip="Send to terminal (doesn't execute)">
                    <StackPanel Orientation="Horizontal" Spacing="4">
                        <PathIcon Data="{StaticResource TerminalIcon}" Width="14" Height="14" />
                        <TextBlock Text="Send to Terminal" />
                    </StackPanel>
                </Button>

                <Button Command="{Binding ExecuteCommand}"
                        ToolTip.Tip="Execute in terminal"
                        Classes="secondary">
                    <StackPanel Orientation="Horizontal" Spacing="4">
                        <PathIcon Data="{StaticResource PlayIcon}" Width="14" Height="14" />
                        <TextBlock Text="Run" />
                    </StackPanel>
                </Button>
            </StackPanel>

            <!-- Status indicator -->
            <Border Classes="status-badge"
                    IsVisible="{Binding Status, Converter={StaticResource IsNotPendingConverter}}"
                    HorizontalAlignment="Right"
                    VerticalAlignment="Top"
                    Margin="8">
                <TextBlock Text="{Binding Status}"
                           FontSize="10" />
            </Border>
        </Grid>
    </Border>
</UserControl>
```

### CommandBlockViewModel

```csharp
namespace SeniorIntern.Desktop.ViewModels;

public partial class CommandBlockViewModel : ViewModelBase
{
    private readonly ITerminalService _terminalService;
    private readonly IClipboardService _clipboard;

    [ObservableProperty]
    private CommandBlock _commandBlock = null!;

    [ObservableProperty]
    private CommandBlockStatus _status = CommandBlockStatus.Pending;

    public string Command => CommandBlock.Command;
    public string? Description => CommandBlock.Description;
    public string? Language => CommandBlock.Language;

    [RelayCommand]
    private async Task CopyAsync()
    {
        await _clipboard.SetTextAsync(Command);
        Status = CommandBlockStatus.Copied;
    }

    [RelayCommand]
    private async Task SendToTerminalAsync()
    {
        var activeSession = _terminalService.ActiveSession;
        if (activeSession == null)
        {
            // Create new terminal if none exists
            activeSession = await _terminalService.CreateSessionAsync();
        }

        // Send command without executing (no newline)
        await _terminalService.WriteInputAsync(activeSession.Id, Command);
        Status = CommandBlockStatus.Copied;
    }

    [RelayCommand]
    private async Task ExecuteAsync()
    {
        var activeSession = _terminalService.ActiveSession;
        if (activeSession == null)
        {
            activeSession = await _terminalService.CreateSessionAsync();
        }

        // Send command and execute (with newline)
        await _terminalService.WriteInputAsync(activeSession.Id, Command + "\r");
        Status = CommandBlockStatus.Executed;
    }
}
```

### Output Capture for Context

```csharp
namespace SeniorIntern.Core.Models;

public sealed class TerminalOutputCapture
{
    public Guid Id { get; init; } = Guid.NewGuid();
    public Guid SessionId { get; init; }
    public string Command { get; init; } = string.Empty;
    public string Output { get; init; } = string.Empty;
    public int? ExitCode { get; init; }
    public DateTime StartedAt { get; init; }
    public DateTime CompletedAt { get; init; }
    public TimeSpan Duration => CompletedAt - StartedAt;

    /// <summary>
    /// Estimated token count for including in LLM context
    /// </summary>
    public int EstimatedTokens => (Output.Length + Command.Length) / 4;
}
```

### Terminal Context Attachment

```csharp
namespace SeniorIntern.Desktop.ViewModels;

public partial class ChatViewModel : ViewModelBase
{
    // ... existing properties ...

    [ObservableProperty]
    private TerminalOutputCapture? _attachedTerminalOutput;

    [RelayCommand]
    private async Task AttachTerminalOutputAsync()
    {
        var activeSession = _terminalService.ActiveSession;
        if (activeSession == null) return;

        // Get recent output
        var buffer = _terminalService.GetBuffer(activeSession.Id);
        var output = buffer.GetText();

        // Truncate if too long
        const int maxChars = 4000;
        if (output.Length > maxChars)
        {
            output = "...(truncated)\n" + output[^maxChars..];
        }

        AttachedTerminalOutput = new TerminalOutputCapture
        {
            SessionId = activeSession.Id,
            Output = output,
            StartedAt = DateTime.UtcNow,
            CompletedAt = DateTime.UtcNow
        };
    }

    [RelayCommand]
    private void ClearTerminalContext()
    {
        AttachedTerminalOutput = null;
    }

    protected override string BuildContextPrompt()
    {
        var sb = new StringBuilder();

        // File contexts
        foreach (var ctx in AttachedContexts)
        {
            sb.AppendLine($"--- File: {ctx.FileName} ---");
            sb.AppendLine(ctx.Content);
            sb.AppendLine();
        }

        // Terminal output context
        if (AttachedTerminalOutput != null)
        {
            sb.AppendLine("--- Terminal Output ---");
            if (!string.IsNullOrEmpty(AttachedTerminalOutput.Command))
            {
                sb.AppendLine($"$ {AttachedTerminalOutput.Command}");
            }
            sb.AppendLine(AttachedTerminalOutput.Output);
            sb.AppendLine();
        }

        return sb.ToString();
    }
}
```

### Terminal Context UI

```xml
<!-- Addition to ChatContextBar.axaml -->
<Border Classes="context-pill terminal-context"
        IsVisible="{Binding AttachedTerminalOutput, Converter={x:Static ObjectConverters.IsNotNull}}"
        Margin="0,0,4,4">
    <Grid ColumnDefinitions="Auto, *, Auto">
        <PathIcon Data="{StaticResource TerminalIcon}"
                  Width="12" Height="12" Margin="0,0,4,0" />
        <TextBlock Grid.Column="1"
                   Text="Terminal Output"
                   FontSize="12" />
        <Button Grid.Column="2"
                Command="{Binding ClearTerminalContextCommand}"
                Classes="pill-close">
            <PathIcon Data="{StaticResource CloseIcon}" Width="8" Height="8" />
        </Button>
    </Grid>
</Border>

<!-- Button to attach terminal output -->
<Button Command="{Binding AttachTerminalOutputCommand}"
        ToolTip.Tip="Attach terminal output to context"
        IsEnabled="{Binding HasActiveTerminal}">
    <PathIcon Data="{StaticResource TerminalIcon}" Width="14" Height="14" />
</Button>
```

### Files to Create (v0.5.4)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Models/CommandBlock.cs` | Command block model |
| `src/SeniorIntern.Core/Models/TerminalOutputCapture.cs` | Output capture model |
| `src/SeniorIntern.Core/Interfaces/ICommandExtractorService.cs` | Extractor interface |
| `src/SeniorIntern.Services/CommandExtractorService.cs` | Extractor implementation |
| `src/SeniorIntern.Desktop/Controls/CommandBlockControl.axaml` | Command block UI |
| `src/SeniorIntern.Desktop/ViewModels/CommandBlockViewModel.cs` | Command block VM |

### Files to Modify (v0.5.4)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/ViewModels/ChatViewModel.cs` | Add terminal context |
| `src/SeniorIntern.Desktop/ViewModels/ChatMessageViewModel.cs` | Add command extraction |
| `src/SeniorIntern.Desktop/Views/ChatContextBar.axaml` | Add terminal context UI |

### Testing Strategy (v0.5.4)
- Command extraction from various formats
- Copy/send/execute workflow tests
- Output capture tests
- Context attachment tests

---

## v0.5.5: Polish & Integration

### Objective
Final polish including terminal history, search within terminal, comprehensive keyboard shortcuts, settings panel, and integration testing.

### Terminal Search

```csharp
namespace SeniorIntern.Core.Models;

public sealed class TerminalSearchResult
{
    public int LineIndex { get; init; }
    public int StartColumn { get; init; }
    public int Length { get; init; }
}

public sealed class TerminalSearchState
{
    public string Query { get; set; } = string.Empty;
    public bool CaseSensitive { get; set; }
    public bool UseRegex { get; set; }
    public IReadOnlyList<TerminalSearchResult> Results { get; set; } = Array.Empty<TerminalSearchResult>();
    public int CurrentResultIndex { get; set; } = -1;

    public TerminalSearchResult? CurrentResult =>
        CurrentResultIndex >= 0 && CurrentResultIndex < Results.Count
            ? Results[CurrentResultIndex]
            : null;
}
```

### Terminal Search UI

```xml
<!-- TerminalSearchBar.axaml -->
<Border Classes="terminal-search-bar"
        IsVisible="{Binding IsSearchVisible}"
        HorizontalAlignment="Right"
        VerticalAlignment="Top"
        Margin="16">
    <Grid ColumnDefinitions="*, Auto, Auto, Auto, Auto">
        <TextBox Text="{Binding SearchQuery}"
                 Watermark="Search..."
                 Width="200"
                 KeyDown="OnSearchKeyDown" />

        <TextBlock Grid.Column="1"
                   Text="{Binding SearchResultsText}"
                   VerticalAlignment="Center"
                   Margin="8,0"
                   Foreground="{DynamicResource TextMuted}" />

        <Button Grid.Column="2" Classes="icon-button"
                Command="{Binding PreviousSearchResultCommand}"
                ToolTip.Tip="Previous (Shift+Enter)">
            <PathIcon Data="{StaticResource ChevronUpIcon}" />
        </Button>

        <Button Grid.Column="3" Classes="icon-button"
                Command="{Binding NextSearchResultCommand}"
                ToolTip.Tip="Next (Enter)">
            <PathIcon Data="{StaticResource ChevronDownIcon}" />
        </Button>

        <Button Grid.Column="4" Classes="icon-button"
                Command="{Binding CloseSearchCommand}"
                ToolTip.Tip="Close (Escape)">
            <PathIcon Data="{StaticResource CloseIcon}" />
        </Button>
    </Grid>
</Border>
```

### Keyboard Shortcuts (Complete List)

| Category | Shortcut | Action |
|----------|----------|--------|
| **Terminal Panel** | Ctrl+` | Toggle terminal visibility |
| | Ctrl+Shift+` | New terminal |
| | Ctrl+Shift+T | New terminal (alt) |
| | Ctrl+Shift+W | Close active terminal |
| | Ctrl+PageUp | Previous terminal tab |
| | Ctrl+PageDown | Next terminal tab |
| | Ctrl+Shift+1..9 | Switch to terminal 1-9 |
| **Terminal Input** | Ctrl+C | Send SIGINT (interrupt) |
| | Ctrl+Z | Send SIGTSTP (suspend) |
| | Ctrl+D | Send EOF |
| | Ctrl+L | Clear terminal |
| | Ctrl+U | Clear line before cursor |
| | Ctrl+K | Clear line after cursor |
| | Ctrl+W | Delete word before cursor |
| | Ctrl+A | Move to line start |
| | Ctrl+E | Move to line end |
| **Terminal Search** | Ctrl+F | Open search |
| | Escape | Close search |
| | Enter | Next result |
| | Shift+Enter | Previous result |
| | F3 | Next result |
| | Shift+F3 | Previous result |
| **Terminal Selection** | Ctrl+Shift+C | Copy selection |
| | Ctrl+Shift+V | Paste |
| | Ctrl+Shift+A | Select all |
| | Shift+Click | Extend selection |
| | Double-click | Select word |
| | Triple-click | Select line |
| **Terminal Scroll** | Shift+PageUp | Scroll up one page |
| | Shift+PageDown | Scroll down one page |
| | Shift+Home | Scroll to top |
| | Shift+End | Scroll to bottom |
| | Ctrl+Shift+Up | Scroll up one line |
| | Ctrl+Shift+Down | Scroll down one line |
| **Command Blocks** | Ctrl+Enter | Execute command |
| | Ctrl+Shift+Enter | Send to terminal |

### Terminal Settings Panel

```xml
<!-- TerminalSettingsPanel.axaml -->
<UserControl xmlns="https://github.com/avaloniaui"
             x:Class="SeniorIntern.Desktop.Views.TerminalSettingsPanel">

    <StackPanel Spacing="24" Padding="16">
        <TextBlock Text="Terminal Settings" FontSize="18" FontWeight="SemiBold" />

        <!-- Appearance -->
        <StackPanel Spacing="12">
            <TextBlock Text="Appearance" FontWeight="SemiBold" />

            <Grid ColumnDefinitions="150, *">
                <TextBlock Text="Font Family" VerticalAlignment="Center" />
                <ComboBox Grid.Column="1"
                          ItemsSource="{Binding AvailableFonts}"
                          SelectedItem="{Binding Settings.TerminalFontFamily}" />
            </Grid>

            <Grid ColumnDefinitions="150, *, Auto">
                <TextBlock Text="Font Size" VerticalAlignment="Center" />
                <Slider Grid.Column="1"
                        Minimum="8" Maximum="24"
                        Value="{Binding Settings.TerminalFontSize}" />
                <TextBlock Grid.Column="2" Text="{Binding Settings.TerminalFontSize}"
                           Width="30" TextAlignment="Right" />
            </Grid>

            <Grid ColumnDefinitions="150, *">
                <TextBlock Text="Theme" VerticalAlignment="Center" />
                <ComboBox Grid.Column="1"
                          ItemsSource="{Binding AvailableThemes}"
                          SelectedItem="{Binding Settings.TerminalTheme}" />
            </Grid>

            <Grid ColumnDefinitions="150, *">
                <TextBlock Text="Cursor Style" VerticalAlignment="Center" />
                <ComboBox Grid.Column="1"
                          ItemsSource="{Binding CursorStyles}"
                          SelectedItem="{Binding Settings.TerminalCursorStyle}" />
            </Grid>

            <CheckBox Content="Blinking cursor"
                      IsChecked="{Binding Settings.TerminalCursorBlink}" />
        </StackPanel>

        <!-- Behavior -->
        <StackPanel Spacing="12">
            <TextBlock Text="Behavior" FontWeight="SemiBold" />

            <Grid ColumnDefinitions="150, *, Auto">
                <TextBlock Text="Scrollback Lines" VerticalAlignment="Center" />
                <Slider Grid.Column="1"
                        Minimum="1000" Maximum="100000"
                        Value="{Binding Settings.TerminalScrollbackLines}" />
                <TextBlock Grid.Column="2" Text="{Binding Settings.TerminalScrollbackLines}"
                           Width="60" TextAlignment="Right" />
            </Grid>

            <CheckBox Content="Enable bell sound"
                      IsChecked="{Binding Settings.TerminalBellEnabled}" />

            <CheckBox Content="Sync active terminal with workspace"
                      IsChecked="{Binding Settings.SyncActiveTerminalWithWorkspace}" />
        </StackPanel>

        <!-- Shell Profiles -->
        <StackPanel Spacing="12">
            <Grid ColumnDefinitions="*, Auto">
                <TextBlock Text="Shell Profiles" FontWeight="SemiBold" />
                <Button Grid.Column="1" Content="Add Profile"
                        Command="{Binding AddProfileCommand}" />
            </Grid>

            <ListBox ItemsSource="{Binding ShellProfiles}"
                     SelectedItem="{Binding SelectedProfile}"
                     MinHeight="100">
                <ListBox.ItemTemplate>
                    <DataTemplate>
                        <Grid ColumnDefinitions="Auto, *, Auto">
                            <PathIcon Data="{Binding Icon}" Width="16" Height="16" />
                            <StackPanel Grid.Column="1" Margin="8,0">
                                <TextBlock Text="{Binding Name}" />
                                <TextBlock Text="{Binding ShellPath}"
                                           FontSize="11"
                                           Foreground="{DynamicResource TextMuted}" />
                            </StackPanel>
                            <StackPanel Grid.Column="2" Orientation="Horizontal">
                                <Button Classes="icon-button"
                                        Command="{Binding $parent[UserControl].DataContext.EditProfileCommand}"
                                        CommandParameter="{Binding}">
                                    <PathIcon Data="{StaticResource EditIcon}" />
                                </Button>
                                <Button Classes="icon-button"
                                        Command="{Binding $parent[UserControl].DataContext.DeleteProfileCommand}"
                                        CommandParameter="{Binding}">
                                    <PathIcon Data="{StaticResource DeleteIcon}" />
                                </Button>
                            </StackPanel>
                        </Grid>
                    </DataTemplate>
                </ListBox.ItemTemplate>
            </ListBox>

            <Grid ColumnDefinitions="150, *">
                <TextBlock Text="Default Profile" VerticalAlignment="Center" />
                <ComboBox Grid.Column="1"
                          ItemsSource="{Binding ShellProfiles}"
                          SelectedItem="{Binding DefaultProfile}"
                          DisplayMemberBinding="{Binding Name}" />
            </Grid>
        </StackPanel>
    </StackPanel>
</UserControl>
```

### Status Bar Terminal Integration

```
┌─────────────────────────────────────────────────────────────────────────────┐
│ Model: llama.gguf │ 📁 myproject │ [🖥️ bash: ~/project] │ ✓ Saved │ T:0.7  │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Files to Create (v0.5.5)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/Views/TerminalSearchBar.axaml` | Search UI |
| `src/SeniorIntern.Desktop/Views/TerminalSettingsPanel.axaml` | Settings panel |
| `src/SeniorIntern.Desktop/ViewModels/TerminalSettingsViewModel.cs` | Settings VM |
| `src/SeniorIntern.Desktop/Views/ShellProfileEditor.axaml` | Profile editor |

### Files to Modify (v0.5.5)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/Controls/TerminalControl.axaml.cs` | Add keyboard shortcuts |
| `src/SeniorIntern.Desktop/Views/TerminalPanel.axaml` | Add search bar |
| `src/SeniorIntern.Desktop/ViewModels/TerminalPanelViewModel.cs` | Add search functionality |
| `src/SeniorIntern.Desktop/Views/MainWindow.axaml` | Add terminal to status bar |

### Testing Strategy (v0.5.5)
- All keyboard shortcuts functional
- Search functionality tests
- Settings persistence tests
- End-to-end integration tests
- Cross-platform terminal tests

---

## Architecture Summary

### Project Structure After v0.5.0

```
SeniorIntern/
├── src/
│   ├── SeniorIntern.Core/
│   │   ├── Models/
│   │   │   ├── TerminalSession.cs               [NEW]
│   │   │   ├── TerminalBuffer.cs                [NEW]
│   │   │   ├── TerminalTypes.cs                 [NEW]
│   │   │   ├── TerminalTheme.cs                 [NEW]
│   │   │   ├── ShellProfile.cs                  [NEW]
│   │   │   ├── CommandBlock.cs                  [NEW]
│   │   │   ├── TerminalOutputCapture.cs         [NEW]
│   │   │   └── AppSettings.cs (updated)
│   │   ├── Terminal/
│   │   │   └── AnsiParser.cs                    [NEW]
│   │   └── Interfaces/
│   │       ├── ITerminalService.cs              [NEW]
│   │       ├── IShellDetectionService.cs        [NEW]
│   │       └── ICommandExtractorService.cs      [NEW]
│   │
│   ├── SeniorIntern.Services/
│   │   ├── TerminalService.cs                   [NEW]
│   │   ├── ShellDetectionService.cs             [NEW]
│   │   └── CommandExtractorService.cs           [NEW]
│   │
│   └── SeniorIntern.Desktop/
│       ├── Controls/
│       │   ├── TerminalControl.axaml            [NEW]
│       │   ├── TerminalRenderer.cs              [NEW]
│       │   └── CommandBlockControl.axaml        [NEW]
│       ├── ViewModels/
│       │   ├── TerminalPanelViewModel.cs        [NEW]
│       │   ├── TerminalSessionViewModel.cs      [NEW]
│       │   ├── TerminalSettingsViewModel.cs     [NEW]
│       │   ├── CommandBlockViewModel.cs         [NEW]
│       │   └── ShellSelectorViewModel.cs        [NEW]
│       └── Views/
│           ├── TerminalPanel.axaml              [NEW]
│           ├── TerminalSearchBar.axaml          [NEW]
│           ├── TerminalSettingsPanel.axaml      [NEW]
│           ├── ShellSelectorDialog.axaml        [NEW]
│           └── ShellProfileEditor.axaml         [NEW]
```

### New NuGet Packages (v0.5.0)

| Package | Version | Project | Purpose |
|---------|---------|---------|---------|
| Pty.Net | 1.0.0 | Services | Cross-platform PTY |
| System.IO.Pipelines | 8.0.0 | Services | Efficient I/O |

### Dependency Flow

```
SeniorIntern.Core (no dependencies)
       ↑
SeniorIntern.Data (→ Core, EF Core)
       ↑
SeniorIntern.Services (→ Core, Data, LLamaSharp, Pty.Net)
       ↑
SeniorIntern.Desktop (→ Core, Services, Avalonia, AvaloniaEdit, SkiaSharp)
```

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Cross-platform PTY differences | Medium | High | Abstract PTY interface, platform-specific tests |
| ANSI parser edge cases | Medium | Medium | Comprehensive test suite, fallback rendering |
| Terminal rendering performance | Medium | Medium | Dirty region tracking, virtualization |
| Shell-specific quirks | High | Low | Shell detection, shell-specific configs |
| Unicode/emoji rendering | Medium | Low | Use proper font fallback |
| Windows ConPTY issues | Medium | Medium | Test extensively, WinPTY fallback |

---

## Acceptance Criteria

### v0.5.1
- [ ] PTY spawns successfully on all platforms
- [ ] ANSI escape sequences parsed correctly
- [ ] Terminal buffer maintains scrollback
- [ ] Basic text input/output works

### v0.5.2
- [ ] Terminal renders with proper fonts/colors
- [ ] Cursor displays and animates
- [ ] Selection and copy/paste work
- [ ] Resize handled smoothly
- [ ] Multiple tabs supported

### v0.5.3
- [ ] Shell detection works on all platforms
- [ ] Shell profiles can be created/edited
- [ ] Working directory syncs with workspace
- [ ] "Open in Terminal" works from file explorer

### v0.5.4
- [ ] Commands extracted from chat messages
- [ ] Copy to terminal works
- [ ] Execute command works
- [ ] Terminal output can be attached as context

### v0.5.5
- [ ] All keyboard shortcuts functional
- [ ] Terminal search works
- [ ] Settings persist correctly
- [ ] Status bar shows terminal info

---

## References

- [Pty.Net Repository](https://github.com/microsoft/pty.net)
- [ANSI Escape Codes](https://en.wikipedia.org/wiki/ANSI_escape_code)
- [VT100 Terminal](https://vt100.net/)
- [Windows Pseudo Console (ConPTY)](https://devblogs.microsoft.com/commandline/windows-command-line-introducing-the-windows-pseudo-console-conpty/)
- [XtermSharp](https://github.com/migueldeicaza/XtermSharp)
- [Windows Terminal Source](https://github.com/microsoft/terminal)
- [Avalonia SkiaSharp](https://docs.avaloniaui.net/docs/guides/graphics-and-animation/how-to-use-skiasharp)
