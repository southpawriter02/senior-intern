# Design Specification: AIntern v0.5.3 "Shell Integration"

## Executive Summary

This document provides a comprehensive design specification for v0.5.3, which implements intelligent shell integration for AIntern's integrated terminal. This sub-version delivers cross-platform shell detection, user-configurable shell profiles, bi-directional working directory synchronization between the terminal and file explorer, and shell-specific features like command history integration. This layer bridges the terminal infrastructure (v0.5.1) and UI (v0.5.2) with the user's preferred shell environments.

### v0.5.3 Scope (from v0.5.0 Design Document)
- Shell detection for Windows (PowerShell, cmd, Git Bash, WSL), macOS (zsh, bash, fish), and Linux (bash, zsh, fish, sh)
- Shell profile management with custom configurations
- Working directory synchronization with the File Explorer
- Shell-specific command handling and features
- File Explorer context menu integration ("Open in Terminal")

---

## Sub-Part Breakdown

| Part | Name | Focus |
|------|------|-------|
| v0.5.3a | Shell Detection Service | Cross-platform shell discovery, PATH searching, version detection |
| v0.5.3b | Shell Configuration System | Shell-specific configurations, commands, and capabilities |
| v0.5.3c | Shell Profile Models | User profile definitions, persistence, profile management |
| v0.5.3d | Profile Management Service | CRUD operations for profiles, default profile handling |
| v0.5.3e | Working Directory Sync | Bi-directional sync between terminal and file explorer, OSC 7 support |
| v0.5.3f | File Explorer Integration | Context menu additions, "Open in Terminal" command, settings UI |

---

## v0.5.3a: Shell Detection Service

### Objective
Create a robust cross-platform shell detection service that discovers available shells on the user's system, identifies the default shell, extracts version information, and provides intelligent fallbacks.

### IShellDetectionService Interface

```csharp
namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Service for detecting available shells on the system
/// </summary>
public interface IShellDetectionService
{
    /// <summary>
    /// Get the user's default/preferred shell
    /// </summary>
    /// <param name="ct">Cancellation token</param>
    /// <returns>Path to the default shell executable</returns>
    Task<string> GetDefaultShellAsync(CancellationToken ct = default);

    /// <summary>
    /// Get all available shells discovered on the system
    /// </summary>
    /// <param name="ct">Cancellation token</param>
    /// <returns>List of discovered shells with metadata</returns>
    Task<IReadOnlyList<ShellInfo>> GetAvailableShellsAsync(CancellationToken ct = default);

    /// <summary>
    /// Detect the shell type from an executable path
    /// </summary>
    /// <param name="shellPath">Path to the shell executable</param>
    /// <returns>Detected shell type</returns>
    ShellType DetectShellType(string shellPath);

    /// <summary>
    /// Get the version of a shell executable
    /// </summary>
    /// <param name="shellPath">Path to the shell executable</param>
    /// <param name="ct">Cancellation token</param>
    /// <returns>Version string or null if unavailable</returns>
    Task<string?> GetShellVersionAsync(string shellPath, CancellationToken ct = default);

    /// <summary>
    /// Validate that a shell path is executable
    /// </summary>
    /// <param name="shellPath">Path to validate</param>
    /// <returns>True if the shell exists and is executable</returns>
    bool ValidateShellPath(string shellPath);

    /// <summary>
    /// Search PATH for an executable by name
    /// </summary>
    /// <param name="executableName">Name of the executable (without extension on Windows)</param>
    /// <returns>Full path or null if not found</returns>
    string? FindInPath(string executableName);
}
```

### ShellInfo Model

```csharp
namespace SeniorIntern.Core.Models.Terminal;

/// <summary>
/// Information about a discovered shell on the system
/// </summary>
public sealed class ShellInfo
{
    /// <summary>
    /// Display name for the shell (e.g., "PowerShell", "Zsh", "Git Bash")
    /// </summary>
    public string Name { get; init; } = string.Empty;

    /// <summary>
    /// Full path to the shell executable
    /// </summary>
    public string Path { get; init; } = string.Empty;

    /// <summary>
    /// Detected shell type
    /// </summary>
    public ShellType Type { get; init; }

    /// <summary>
    /// Version string (e.g., "7.4.0" for PowerShell, "5.9" for zsh)
    /// </summary>
    public string? Version { get; init; }

    /// <summary>
    /// Whether this is the system's default shell
    /// </summary>
    public bool IsDefault { get; init; }

    /// <summary>
    /// Path to an icon representing this shell (optional)
    /// </summary>
    public string? IconPath { get; init; }

    /// <summary>
    /// Additional arguments required to run this shell (e.g., for WSL)
    /// </summary>
    public string? DefaultArguments { get; init; }

    /// <summary>
    /// Description of the shell variant (e.g., "Windows Subsystem for Linux")
    /// </summary>
    public string? Description { get; init; }
}
```

### ShellType Enumeration

```csharp
namespace SeniorIntern.Core.Models.Terminal;

/// <summary>
/// Enumeration of known shell types
/// </summary>
public enum ShellType
{
    /// <summary>
    /// Unknown or unrecognized shell
    /// </summary>
    Unknown = 0,

    /// <summary>
    /// Bash (Bourne Again Shell)
    /// </summary>
    Bash,

    /// <summary>
    /// Zsh (Z Shell)
    /// </summary>
    Zsh,

    /// <summary>
    /// Fish (Friendly Interactive Shell)
    /// </summary>
    Fish,

    /// <summary>
    /// PowerShell (Core or Windows)
    /// </summary>
    PowerShell,

    /// <summary>
    /// Windows Command Prompt
    /// </summary>
    Cmd,

    /// <summary>
    /// POSIX sh
    /// </summary>
    Sh,

    /// <summary>
    /// Tcsh (TENEX C Shell)
    /// </summary>
    Tcsh,

    /// <summary>
    /// Ksh (Korn Shell)
    /// </summary>
    Ksh,

    /// <summary>
    /// Nushell
    /// </summary>
    Nushell,

    /// <summary>
    /// Windows Subsystem for Linux
    /// </summary>
    Wsl
}
```

### ShellDetectionService Implementation

```csharp
namespace SeniorIntern.Services.Terminal;

using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models.Terminal;
using System.Diagnostics;

/// <summary>
/// Cross-platform shell detection service
/// </summary>
public sealed class ShellDetectionService : IShellDetectionService
{
    private readonly ILogger<ShellDetectionService> _logger;
    private readonly Dictionary<ShellType, string> _versionCommands;

    public ShellDetectionService(ILogger<ShellDetectionService> logger)
    {
        _logger = logger;
        _versionCommands = new Dictionary<ShellType, string>
        {
            [ShellType.Bash] = "--version",
            [ShellType.Zsh] = "--version",
            [ShellType.Fish] = "--version",
            [ShellType.PowerShell] = "-Command \"$PSVersionTable.PSVersion.ToString()\"",
            [ShellType.Cmd] = "/c ver",
            [ShellType.Sh] = "--version",
            [ShellType.Nushell] = "--version"
        };
    }

    public async Task<string> GetDefaultShellAsync(CancellationToken ct = default)
    {
        _logger.LogDebug("Detecting default shell for platform: {Platform}",
            Environment.OSVersion.Platform);

        if (OperatingSystem.IsWindows())
        {
            return await GetWindowsDefaultShellAsync(ct);
        }
        else
        {
            return GetUnixDefaultShell();
        }
    }

    private async Task<string> GetWindowsDefaultShellAsync(CancellationToken ct)
    {
        // Priority: PowerShell Core > Windows PowerShell > cmd.exe

        // 1. Check for PowerShell Core (pwsh)
        var pwshPath = FindInPath("pwsh");
        if (pwshPath != null)
        {
            _logger.LogDebug("Found PowerShell Core at: {Path}", pwshPath);
            return pwshPath;
        }

        // 2. Check for Windows PowerShell
        var windowsPowerShellPath = Path.Combine(
            Environment.GetFolderPath(Environment.SpecialFolder.System),
            "WindowsPowerShell", "v1.0", "powershell.exe");

        if (File.Exists(windowsPowerShellPath))
        {
            _logger.LogDebug("Found Windows PowerShell at: {Path}", windowsPowerShellPath);
            return windowsPowerShellPath;
        }

        // 3. Fallback to cmd.exe
        var cmdPath = Path.Combine(
            Environment.GetFolderPath(Environment.SpecialFolder.System),
            "cmd.exe");

        _logger.LogDebug("Falling back to cmd.exe at: {Path}", cmdPath);
        return cmdPath;
    }

    private string GetUnixDefaultShell()
    {
        // 1. Check SHELL environment variable
        var shell = Environment.GetEnvironmentVariable("SHELL");
        if (!string.IsNullOrEmpty(shell) && File.Exists(shell))
        {
            _logger.LogDebug("Using SHELL environment variable: {Shell}", shell);
            return shell;
        }

        // 2. Fallback paths
        var fallbackPaths = new[] { "/bin/zsh", "/bin/bash", "/bin/sh" };
        foreach (var path in fallbackPaths)
        {
            if (File.Exists(path))
            {
                _logger.LogDebug("Using fallback shell: {Path}", path);
                return path;
            }
        }

        throw new InvalidOperationException("No shell found on the system");
    }

    public async Task<IReadOnlyList<ShellInfo>> GetAvailableShellsAsync(CancellationToken ct = default)
    {
        var shells = new List<ShellInfo>();
        var defaultShell = await GetDefaultShellAsync(ct);

        if (OperatingSystem.IsWindows())
        {
            await DiscoverWindowsShellsAsync(shells, defaultShell, ct);
        }
        else
        {
            await DiscoverUnixShellsAsync(shells, defaultShell, ct);
        }

        _logger.LogInformation("Discovered {Count} shells", shells.Count);
        return shells.AsReadOnly();
    }

    private async Task DiscoverWindowsShellsAsync(
        List<ShellInfo> shells,
        string defaultShell,
        CancellationToken ct)
    {
        // PowerShell Core (pwsh)
        var pwshPath = FindInPath("pwsh");
        if (pwshPath != null)
        {
            var version = await GetShellVersionAsync(pwshPath, ct);
            shells.Add(new ShellInfo
            {
                Name = "PowerShell",
                Path = pwshPath,
                Type = ShellType.PowerShell,
                Version = version,
                IsDefault = pwshPath.Equals(defaultShell, StringComparison.OrdinalIgnoreCase),
                Description = "PowerShell Core (cross-platform)"
            });
        }

        // Windows PowerShell
        var windowsPowerShellPath = Path.Combine(
            Environment.GetFolderPath(Environment.SpecialFolder.System),
            "WindowsPowerShell", "v1.0", "powershell.exe");

        if (File.Exists(windowsPowerShellPath))
        {
            var version = await GetShellVersionAsync(windowsPowerShellPath, ct);
            shells.Add(new ShellInfo
            {
                Name = "Windows PowerShell",
                Path = windowsPowerShellPath,
                Type = ShellType.PowerShell,
                Version = version,
                IsDefault = windowsPowerShellPath.Equals(defaultShell, StringComparison.OrdinalIgnoreCase),
                Description = "Windows PowerShell 5.1"
            });
        }

        // Command Prompt
        var cmdPath = Path.Combine(
            Environment.GetFolderPath(Environment.SpecialFolder.System),
            "cmd.exe");

        if (File.Exists(cmdPath))
        {
            shells.Add(new ShellInfo
            {
                Name = "Command Prompt",
                Path = cmdPath,
                Type = ShellType.Cmd,
                IsDefault = cmdPath.Equals(defaultShell, StringComparison.OrdinalIgnoreCase),
                Description = "Windows Command Prompt"
            });
        }

        // Git Bash
        var gitBashPaths = new[]
        {
            @"C:\Program Files\Git\bin\bash.exe",
            @"C:\Program Files (x86)\Git\bin\bash.exe",
            Path.Combine(
                Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),
                "Programs", "Git", "bin", "bash.exe")
        };

        foreach (var path in gitBashPaths)
        {
            if (File.Exists(path))
            {
                var version = await GetShellVersionAsync(path, ct);
                shells.Add(new ShellInfo
                {
                    Name = "Git Bash",
                    Path = path,
                    Type = ShellType.Bash,
                    Version = version,
                    IsDefault = path.Equals(defaultShell, StringComparison.OrdinalIgnoreCase),
                    Description = "Git for Windows Bash",
                    DefaultArguments = "--login -i"
                });
                break; // Only add the first found
            }
        }

        // WSL (Windows Subsystem for Linux)
        var wslPath = FindInPath("wsl");
        if (wslPath != null)
        {
            // Get list of installed distributions
            var distributions = await GetWslDistributionsAsync(ct);
            foreach (var distro in distributions)
            {
                shells.Add(new ShellInfo
                {
                    Name = $"WSL: {distro}",
                    Path = wslPath,
                    Type = ShellType.Wsl,
                    IsDefault = false,
                    Description = "Windows Subsystem for Linux",
                    DefaultArguments = $"-d {distro}"
                });
            }

            // Add default WSL if no specific distros found
            if (distributions.Count == 0)
            {
                shells.Add(new ShellInfo
                {
                    Name = "WSL",
                    Path = wslPath,
                    Type = ShellType.Wsl,
                    IsDefault = false,
                    Description = "Windows Subsystem for Linux"
                });
            }
        }

        // Nushell (if installed)
        var nuPath = FindInPath("nu");
        if (nuPath != null)
        {
            var version = await GetShellVersionAsync(nuPath, ct);
            shells.Add(new ShellInfo
            {
                Name = "Nushell",
                Path = nuPath,
                Type = ShellType.Nushell,
                Version = version,
                IsDefault = false,
                Description = "A new type of shell"
            });
        }
    }

    private async Task DiscoverUnixShellsAsync(
        List<ShellInfo> shells,
        string defaultShell,
        CancellationToken ct)
    {
        var etcShellsPath = "/etc/shells";

        if (File.Exists(etcShellsPath))
        {
            var lines = await File.ReadAllLinesAsync(etcShellsPath, ct);

            foreach (var line in lines)
            {
                var trimmed = line.Trim();

                // Skip comments and empty lines
                if (string.IsNullOrEmpty(trimmed) || trimmed.StartsWith('#'))
                    continue;

                if (File.Exists(trimmed))
                {
                    var type = DetectShellType(trimmed);
                    var version = await GetShellVersionAsync(trimmed, ct);

                    shells.Add(new ShellInfo
                    {
                        Name = GetShellDisplayName(trimmed, type),
                        Path = trimmed,
                        Type = type,
                        Version = version,
                        IsDefault = trimmed == defaultShell
                    });
                }
            }
        }
        else
        {
            // Fallback: Check common paths
            var commonPaths = new[]
            {
                "/bin/bash", "/bin/zsh", "/bin/sh", "/bin/fish",
                "/usr/bin/bash", "/usr/bin/zsh", "/usr/bin/fish",
                "/usr/local/bin/bash", "/usr/local/bin/zsh", "/usr/local/bin/fish"
            };

            foreach (var path in commonPaths.Distinct())
            {
                if (File.Exists(path))
                {
                    var type = DetectShellType(path);
                    var version = await GetShellVersionAsync(path, ct);

                    shells.Add(new ShellInfo
                    {
                        Name = GetShellDisplayName(path, type),
                        Path = path,
                        Type = type,
                        Version = version,
                        IsDefault = path == defaultShell
                    });
                }
            }
        }
    }

    public ShellType DetectShellType(string shellPath)
    {
        if (string.IsNullOrEmpty(shellPath))
            return ShellType.Unknown;

        var fileName = Path.GetFileNameWithoutExtension(shellPath).ToLowerInvariant();

        return fileName switch
        {
            "bash" => ShellType.Bash,
            "zsh" => ShellType.Zsh,
            "fish" => ShellType.Fish,
            "pwsh" or "powershell" => ShellType.PowerShell,
            "cmd" => ShellType.Cmd,
            "sh" or "dash" => ShellType.Sh,
            "tcsh" or "csh" => ShellType.Tcsh,
            "ksh" or "ksh93" or "mksh" => ShellType.Ksh,
            "nu" or "nushell" => ShellType.Nushell,
            "wsl" => ShellType.Wsl,
            _ => ShellType.Unknown
        };
    }

    public async Task<string?> GetShellVersionAsync(string shellPath, CancellationToken ct = default)
    {
        var type = DetectShellType(shellPath);

        if (!_versionCommands.TryGetValue(type, out var versionArg))
            return null;

        try
        {
            using var process = new Process
            {
                StartInfo = new ProcessStartInfo
                {
                    FileName = shellPath,
                    Arguments = versionArg,
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    UseShellExecute = false,
                    CreateNoWindow = true
                }
            };

            process.Start();

            var output = await process.StandardOutput.ReadToEndAsync(ct);
            await process.WaitForExitAsync(ct);

            // Parse version from output
            return ParseVersionFromOutput(type, output);
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Failed to get version for shell: {Path}", shellPath);
            return null;
        }
    }

    private string? ParseVersionFromOutput(ShellType type, string output)
    {
        if (string.IsNullOrWhiteSpace(output))
            return null;

        var firstLine = output.Split('\n').FirstOrDefault()?.Trim();
        if (string.IsNullOrEmpty(firstLine))
            return null;

        // Extract version number patterns
        var versionPattern = new Regex(@"(\d+\.[\d.]+)");
        var match = versionPattern.Match(firstLine);

        return match.Success ? match.Groups[1].Value : firstLine;
    }

    public bool ValidateShellPath(string shellPath)
    {
        if (string.IsNullOrEmpty(shellPath))
            return false;

        if (!File.Exists(shellPath))
            return false;

        // On Unix, check if file is executable
        if (!OperatingSystem.IsWindows())
        {
            try
            {
                var info = new FileInfo(shellPath);
                // Check Unix execute permission via attributes
                return (info.Attributes & FileAttributes.ReadOnly) == 0;
            }
            catch
            {
                return false;
            }
        }

        return true;
    }

    public string? FindInPath(string executableName)
    {
        var pathVar = Environment.GetEnvironmentVariable("PATH") ?? string.Empty;
        var paths = pathVar.Split(Path.PathSeparator);

        var extensions = OperatingSystem.IsWindows()
            ? new[] { ".exe", ".cmd", ".bat", ".com" }
            : new[] { "" };

        foreach (var path in paths)
        {
            foreach (var ext in extensions)
            {
                var fullPath = Path.Combine(path, executableName + ext);
                if (File.Exists(fullPath))
                {
                    return fullPath;
                }
            }
        }

        return null;
    }

    private async Task<List<string>> GetWslDistributionsAsync(CancellationToken ct)
    {
        var distributions = new List<string>();

        try
        {
            using var process = new Process
            {
                StartInfo = new ProcessStartInfo
                {
                    FileName = "wsl",
                    Arguments = "-l -q",
                    RedirectStandardOutput = true,
                    UseShellExecute = false,
                    CreateNoWindow = true
                }
            };

            process.Start();
            var output = await process.StandardOutput.ReadToEndAsync(ct);
            await process.WaitForExitAsync(ct);

            if (process.ExitCode == 0)
            {
                var lines = output.Split('\n', StringSplitOptions.RemoveEmptyEntries);
                foreach (var line in lines)
                {
                    var distro = line.Trim().Replace("\0", ""); // Remove null chars
                    if (!string.IsNullOrEmpty(distro))
                    {
                        distributions.Add(distro);
                    }
                }
            }
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Failed to enumerate WSL distributions");
        }

        return distributions;
    }

    private string GetShellDisplayName(string path, ShellType type)
    {
        return type switch
        {
            ShellType.Bash => "Bash",
            ShellType.Zsh => "Zsh",
            ShellType.Fish => "Fish",
            ShellType.PowerShell => path.Contains("pwsh", StringComparison.OrdinalIgnoreCase)
                ? "PowerShell"
                : "Windows PowerShell",
            ShellType.Cmd => "Command Prompt",
            ShellType.Sh => "sh",
            ShellType.Tcsh => "tcsh",
            ShellType.Ksh => "ksh",
            ShellType.Nushell => "Nushell",
            ShellType.Wsl => "WSL",
            _ => Path.GetFileName(path)
        };
    }
}
```

### v0.5.3a Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/IShellDetectionService.cs` | Shell detection service interface |
| `src/SeniorIntern.Core/Models/Terminal/ShellInfo.cs` | Shell information model |
| `src/SeniorIntern.Core/Models/Terminal/ShellType.cs` | Shell type enumeration |
| `src/SeniorIntern.Services/Terminal/ShellDetectionService.cs` | Shell detection implementation |

### v0.5.3a Files to Modify

| File | Changes |
|------|---------|
| `src/SeniorIntern.Services/DependencyInjection.cs` | Register IShellDetectionService |

### v0.5.3a Verification

```bash
# Verify all files compile
dotnet build src/SeniorIntern.Services

# Run detection manually in tests
dotnet test --filter "ShellDetection"
```

### v0.5.3a Acceptance Criteria

- [ ] Shell detection works on Windows (PowerShell, cmd, Git Bash, WSL)
- [ ] Shell detection works on macOS (zsh, bash, fish)
- [ ] Shell detection works on Linux (bash, zsh, sh, fish)
- [ ] Default shell is correctly identified per platform
- [ ] Version extraction works for supported shells
- [ ] PATH searching correctly finds executables
- [ ] Invalid shell paths are rejected

---

## v0.5.3b: Shell Configuration System

### Objective
Create a comprehensive shell configuration system that provides shell-specific commands, environment variables, escape sequences, and capabilities for each supported shell type.

### ShellConfiguration Model

```csharp
namespace SeniorIntern.Core.Models.Terminal;

/// <summary>
/// Configuration and capabilities for a specific shell type
/// </summary>
public sealed class ShellConfiguration
{
    /// <summary>
    /// The shell type this configuration applies to
    /// </summary>
    public ShellType Type { get; init; }

    /// <summary>
    /// Command to clear the terminal screen
    /// </summary>
    public string ClearCommand { get; init; } = "clear";

    /// <summary>
    /// Command to change the working directory
    /// </summary>
    public string ChangeDirectoryCommand { get; init; } = "cd";

    /// <summary>
    /// Command to print the current working directory
    /// </summary>
    public string PrintWorkingDirectoryCommand { get; init; } = "pwd";

    /// <summary>
    /// Command to view command history
    /// </summary>
    public string HistoryCommand { get; init; } = "history";

    /// <summary>
    /// Command to list directory contents
    /// </summary>
    public string ListDirectoryCommand { get; init; } = "ls";

    /// <summary>
    /// Whether the shell supports OSC 7 (current directory reporting)
    /// </summary>
    public bool SupportsOsc7 { get; init; }

    /// <summary>
    /// Whether the shell supports OSC 9 (notifications)
    /// </summary>
    public bool SupportsOsc9 { get; init; }

    /// <summary>
    /// Whether the shell supports OSC 133 (shell integration marks)
    /// </summary>
    public bool SupportsOsc133 { get; init; }

    /// <summary>
    /// Shell-specific prompt configuration command template
    /// {0} = OSC 7 escape sequence for CWD reporting
    /// </summary>
    public string? PromptConfigTemplate { get; init; }

    /// <summary>
    /// Common profile/configuration files for this shell (expanded paths)
    /// </summary>
    public string[] ProfileFiles { get; init; } = Array.Empty<string>();

    /// <summary>
    /// Arguments to start the shell in login mode
    /// </summary>
    public string LoginArguments { get; init; } = string.Empty;

    /// <summary>
    /// Arguments to start the shell in interactive mode
    /// </summary>
    public string InteractiveArguments { get; init; } = string.Empty;

    /// <summary>
    /// Character used to separate multiple commands
    /// </summary>
    public string CommandSeparator { get; init; } = ";";

    /// <summary>
    /// Character(s) that indicate a line continuation
    /// </summary>
    public string LineContinuation { get; init; } = "\\";

    /// <summary>
    /// Whether quotes need to be escaped with backslash
    /// </summary>
    public bool EscapeQuotesWithBackslash { get; init; } = true;

    /// <summary>
    /// Comment character for this shell
    /// </summary>
    public string CommentPrefix { get; init; } = "#";

    /// <summary>
    /// Environment variable prefix syntax
    /// </summary>
    public string EnvironmentVariablePrefix { get; init; } = "$";

    /// <summary>
    /// Syntax for setting an environment variable
    /// {0} = variable name, {1} = value
    /// </summary>
    public string SetEnvironmentVariableTemplate { get; init; } = "export {0}={1}";

    /// <summary>
    /// Default environment variables for this shell
    /// </summary>
    public Dictionary<string, string> DefaultEnvironment { get; init; } = new();
}
```

### IShellConfigurationService Interface

```csharp
namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Service for retrieving shell-specific configurations
/// </summary>
public interface IShellConfigurationService
{
    /// <summary>
    /// Get the configuration for a specific shell type
    /// </summary>
    ShellConfiguration GetConfiguration(ShellType shellType);

    /// <summary>
    /// Get the configuration for a shell path
    /// </summary>
    ShellConfiguration GetConfiguration(string shellPath);

    /// <summary>
    /// Format a change directory command for the given shell
    /// </summary>
    string FormatChangeDirectoryCommand(ShellType shellType, string path);

    /// <summary>
    /// Get the escape sequence to report current directory (OSC 7)
    /// </summary>
    string? GetCwdReportingEscapeSequence(ShellType shellType, string directory);

    /// <summary>
    /// Get shell-specific environment variables
    /// </summary>
    Dictionary<string, string> GetDefaultEnvironment(ShellType shellType);

    /// <summary>
    /// Generate shell initialization commands for directory sync support
    /// </summary>
    string? GenerateShellIntegrationScript(ShellType shellType);
}
```

### ShellConfigurationService Implementation

```csharp
namespace SeniorIntern.Services.Terminal;

using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models.Terminal;

/// <summary>
/// Provides shell-specific configurations
/// </summary>
public sealed class ShellConfigurationService : IShellConfigurationService
{
    private readonly IShellDetectionService _shellDetection;
    private readonly Dictionary<ShellType, ShellConfiguration> _configurations;

    public ShellConfigurationService(IShellDetectionService shellDetection)
    {
        _shellDetection = shellDetection;
        _configurations = InitializeConfigurations();
    }

    private Dictionary<ShellType, ShellConfiguration> InitializeConfigurations()
    {
        var homeDir = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);

        return new Dictionary<ShellType, ShellConfiguration>
        {
            [ShellType.Bash] = new ShellConfiguration
            {
                Type = ShellType.Bash,
                ClearCommand = "clear",
                ChangeDirectoryCommand = "cd",
                PrintWorkingDirectoryCommand = "pwd",
                HistoryCommand = "history",
                ListDirectoryCommand = "ls -la",
                SupportsOsc7 = true,
                SupportsOsc133 = true,
                PromptConfigTemplate = GetBashPromptConfig(),
                ProfileFiles = new[]
                {
                    Path.Combine(homeDir, ".bashrc"),
                    Path.Combine(homeDir, ".bash_profile"),
                    Path.Combine(homeDir, ".profile")
                },
                LoginArguments = "--login",
                InteractiveArguments = "-i",
                DefaultEnvironment = new Dictionary<string, string>
                {
                    ["TERM"] = "xterm-256color",
                    ["COLORTERM"] = "truecolor"
                }
            },

            [ShellType.Zsh] = new ShellConfiguration
            {
                Type = ShellType.Zsh,
                ClearCommand = "clear",
                ChangeDirectoryCommand = "cd",
                PrintWorkingDirectoryCommand = "pwd",
                HistoryCommand = "history",
                ListDirectoryCommand = "ls -la",
                SupportsOsc7 = true,
                SupportsOsc133 = true,
                PromptConfigTemplate = GetZshPromptConfig(),
                ProfileFiles = new[]
                {
                    Path.Combine(homeDir, ".zshrc"),
                    Path.Combine(homeDir, ".zprofile"),
                    Path.Combine(homeDir, ".zshenv")
                },
                LoginArguments = "--login",
                InteractiveArguments = "-i",
                DefaultEnvironment = new Dictionary<string, string>
                {
                    ["TERM"] = "xterm-256color",
                    ["COLORTERM"] = "truecolor"
                }
            },

            [ShellType.Fish] = new ShellConfiguration
            {
                Type = ShellType.Fish,
                ClearCommand = "clear",
                ChangeDirectoryCommand = "cd",
                PrintWorkingDirectoryCommand = "pwd",
                HistoryCommand = "history",
                ListDirectoryCommand = "ls -la",
                SupportsOsc7 = true,
                SupportsOsc133 = true,
                PromptConfigTemplate = GetFishPromptConfig(),
                ProfileFiles = new[]
                {
                    Path.Combine(homeDir, ".config", "fish", "config.fish")
                },
                LoginArguments = "--login",
                InteractiveArguments = "-i",
                CommandSeparator = "; and",
                SetEnvironmentVariableTemplate = "set -x {0} {1}",
                DefaultEnvironment = new Dictionary<string, string>
                {
                    ["TERM"] = "xterm-256color",
                    ["COLORTERM"] = "truecolor"
                }
            },

            [ShellType.PowerShell] = new ShellConfiguration
            {
                Type = ShellType.PowerShell,
                ClearCommand = "Clear-Host",
                ChangeDirectoryCommand = "Set-Location",
                PrintWorkingDirectoryCommand = "(Get-Location).Path",
                HistoryCommand = "Get-History",
                ListDirectoryCommand = "Get-ChildItem",
                SupportsOsc7 = false,  // PowerShell needs special handling
                SupportsOsc133 = false,
                PromptConfigTemplate = GetPowerShellPromptConfig(),
                ProfileFiles = GetPowerShellProfilePaths(homeDir),
                LoginArguments = "-NoLogo",
                InteractiveArguments = "-NoExit",
                CommandSeparator = ";",
                LineContinuation = "`",
                EscapeQuotesWithBackslash = false,
                CommentPrefix = "#",
                EnvironmentVariablePrefix = "$env:",
                SetEnvironmentVariableTemplate = "$env:{0} = \"{1}\"",
                DefaultEnvironment = new Dictionary<string, string>
                {
                    ["TERM"] = "xterm-256color"
                }
            },

            [ShellType.Cmd] = new ShellConfiguration
            {
                Type = ShellType.Cmd,
                ClearCommand = "cls",
                ChangeDirectoryCommand = "cd /d",
                PrintWorkingDirectoryCommand = "cd",
                HistoryCommand = "doskey /history",
                ListDirectoryCommand = "dir",
                SupportsOsc7 = false,
                SupportsOsc133 = false,
                ProfileFiles = Array.Empty<string>(),
                LoginArguments = "/k",
                CommandSeparator = "&",
                LineContinuation = "^",
                EscapeQuotesWithBackslash = false,
                CommentPrefix = "REM ",
                EnvironmentVariablePrefix = "%",
                SetEnvironmentVariableTemplate = "set {0}={1}",
                DefaultEnvironment = new Dictionary<string, string>()
            },

            [ShellType.Sh] = new ShellConfiguration
            {
                Type = ShellType.Sh,
                ClearCommand = "clear",
                ChangeDirectoryCommand = "cd",
                PrintWorkingDirectoryCommand = "pwd",
                HistoryCommand = "history",
                ListDirectoryCommand = "ls -la",
                SupportsOsc7 = false,
                ProfileFiles = new[]
                {
                    Path.Combine(homeDir, ".profile")
                },
                LoginArguments = "-l",
                DefaultEnvironment = new Dictionary<string, string>
                {
                    ["TERM"] = "xterm"
                }
            },

            [ShellType.Nushell] = new ShellConfiguration
            {
                Type = ShellType.Nushell,
                ClearCommand = "clear",
                ChangeDirectoryCommand = "cd",
                PrintWorkingDirectoryCommand = "pwd",
                HistoryCommand = "history",
                ListDirectoryCommand = "ls",
                SupportsOsc7 = true,
                ProfileFiles = new[]
                {
                    Path.Combine(homeDir, ".config", "nushell", "config.nu")
                },
                LoginArguments = "--login",
                CommandSeparator = ";",
                SetEnvironmentVariableTemplate = "$env.{0} = \"{1}\"",
                DefaultEnvironment = new Dictionary<string, string>
                {
                    ["TERM"] = "xterm-256color"
                }
            },

            [ShellType.Wsl] = new ShellConfiguration
            {
                Type = ShellType.Wsl,
                ClearCommand = "clear",
                ChangeDirectoryCommand = "cd",
                PrintWorkingDirectoryCommand = "pwd",
                HistoryCommand = "history",
                ListDirectoryCommand = "ls -la",
                SupportsOsc7 = true,
                ProfileFiles = Array.Empty<string>(),
                DefaultEnvironment = new Dictionary<string, string>
                {
                    ["TERM"] = "xterm-256color"
                }
            }
        };
    }

    private static string[] GetPowerShellProfilePaths(string homeDir)
    {
        var documents = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);

        return new[]
        {
            // PowerShell Core profile paths
            Path.Combine(documents, "PowerShell", "Microsoft.PowerShell_profile.ps1"),
            Path.Combine(homeDir, ".config", "powershell", "Microsoft.PowerShell_profile.ps1"),
            // Windows PowerShell profile paths
            Path.Combine(documents, "WindowsPowerShell", "Microsoft.PowerShell_profile.ps1")
        };
    }

    public ShellConfiguration GetConfiguration(ShellType shellType)
    {
        return _configurations.TryGetValue(shellType, out var config)
            ? config
            : GetDefaultConfiguration(shellType);
    }

    public ShellConfiguration GetConfiguration(string shellPath)
    {
        var shellType = _shellDetection.DetectShellType(shellPath);
        return GetConfiguration(shellType);
    }

    private ShellConfiguration GetDefaultConfiguration(ShellType shellType)
    {
        return new ShellConfiguration
        {
            Type = shellType,
            ClearCommand = "clear",
            ChangeDirectoryCommand = "cd",
            PrintWorkingDirectoryCommand = "pwd",
            HistoryCommand = "history",
            ListDirectoryCommand = "ls",
            SupportsOsc7 = false,
            ProfileFiles = Array.Empty<string>()
        };
    }

    public string FormatChangeDirectoryCommand(ShellType shellType, string path)
    {
        var config = GetConfiguration(shellType);

        // Handle paths with spaces
        var escapedPath = EscapePath(shellType, path);

        return $"{config.ChangeDirectoryCommand} {escapedPath}";
    }

    private string EscapePath(ShellType shellType, string path)
    {
        // PowerShell and cmd need different escaping
        return shellType switch
        {
            ShellType.PowerShell => $"\"{path}\"",
            ShellType.Cmd => $"\"{path}\"",
            _ => path.Contains(' ') ? $"'{path}'" : path
        };
    }

    public string? GetCwdReportingEscapeSequence(ShellType shellType, string directory)
    {
        var config = GetConfiguration(shellType);

        if (!config.SupportsOsc7)
            return null;

        // OSC 7 format: \e]7;file://hostname/path\a
        var hostname = Environment.MachineName;
        var uri = $"file://{hostname}{directory}";

        return $"\x1b]7;{uri}\x07";
    }

    public Dictionary<string, string> GetDefaultEnvironment(ShellType shellType)
    {
        var config = GetConfiguration(shellType);
        return new Dictionary<string, string>(config.DefaultEnvironment);
    }

    public string? GenerateShellIntegrationScript(ShellType shellType)
    {
        return shellType switch
        {
            ShellType.Bash => GenerateBashIntegration(),
            ShellType.Zsh => GenerateZshIntegration(),
            ShellType.Fish => GenerateFishIntegration(),
            ShellType.PowerShell => GeneratePowerShellIntegration(),
            _ => null
        };
    }

    private static string GetBashPromptConfig()
    {
        return @"
# Senior Intern terminal integration
__si_prompt_command() {
    local cwd=""$(pwd)""
    printf '\e]7;file://%s%s\a' ""$HOSTNAME"" ""$cwd""
}
PROMPT_COMMAND=""__si_prompt_command${PROMPT_COMMAND:+;$PROMPT_COMMAND}""
";
    }

    private static string GetZshPromptConfig()
    {
        return @"
# Senior Intern terminal integration
__si_chpwd() {
    printf '\e]7;file://%s%s\a' ""$HOST"" ""$PWD""
}
autoload -Uz add-zsh-hook
add-zsh-hook chpwd __si_chpwd
__si_chpwd
";
    }

    private static string GetFishPromptConfig()
    {
        return @"
# Senior Intern terminal integration
function __si_pwd_hook --on-variable PWD
    printf '\e]7;file://%s%s\a' (hostname) $PWD
end
__si_pwd_hook
";
    }

    private static string GetPowerShellPromptConfig()
    {
        return @"
# Senior Intern terminal integration
function global:prompt {
    $loc = (Get-Location).Path
    $host.UI.RawUI.WindowTitle = $loc
    # OSC 9;9 for directory (ConEmu/Windows Terminal style)
    Write-Host ""`e]9;9;`""$loc`""`a"" -NoNewline
    return ""PS $loc> ""
}
";
    }

    private string GenerateBashIntegration() => GetBashPromptConfig();
    private string GenerateZshIntegration() => GetZshPromptConfig();
    private string GenerateFishIntegration() => GetFishPromptConfig();
    private string GeneratePowerShellIntegration() => GetPowerShellPromptConfig();
}
```

### v0.5.3b Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Models/Terminal/ShellConfiguration.cs` | Shell configuration model |
| `src/SeniorIntern.Core/Interfaces/IShellConfigurationService.cs` | Configuration service interface |
| `src/SeniorIntern.Services/Terminal/ShellConfigurationService.cs` | Configuration service implementation |

### v0.5.3b Files to Modify

| File | Changes |
|------|---------|
| `src/SeniorIntern.Services/DependencyInjection.cs` | Register IShellConfigurationService |

### v0.5.3b Verification

```bash
# Verify configuration retrieval
dotnet test --filter "ShellConfiguration"

# Verify all shell types have valid configurations
```

### v0.5.3b Acceptance Criteria

- [ ] All ShellType values have corresponding configurations
- [ ] Path escaping works correctly for each shell
- [ ] Change directory command formatting is correct
- [ ] OSC 7 escape sequences are properly formatted
- [ ] Shell integration scripts are syntactically valid
- [ ] Profile file paths are correctly resolved

---

## v0.5.3c: Shell Profile Models

### Objective
Define user-configurable shell profiles that allow customization of shell behavior, appearance, and startup configuration. Profiles can override detected shell defaults and persist user preferences.

### ShellProfile Model

```csharp
namespace SeniorIntern.Core.Models.Terminal;

/// <summary>
/// User-configurable shell profile for terminal sessions
/// </summary>
public sealed class ShellProfile
{
    /// <summary>
    /// Unique identifier for this profile
    /// </summary>
    public Guid Id { get; init; } = Guid.NewGuid();

    /// <summary>
    /// Display name for this profile
    /// </summary>
    public string Name { get; set; } = "Default";

    /// <summary>
    /// Path to the shell executable
    /// </summary>
    public string ShellPath { get; set; } = string.Empty;

    /// <summary>
    /// Type of shell (auto-detected if not specified)
    /// </summary>
    public ShellType ShellType { get; set; } = ShellType.Unknown;

    /// <summary>
    /// Starting directory for new sessions (null = inherit from workspace)
    /// </summary>
    public string? StartingDirectory { get; set; }

    /// <summary>
    /// Command-line arguments passed to the shell
    /// </summary>
    public string? Arguments { get; set; }

    /// <summary>
    /// Custom environment variables for this profile
    /// </summary>
    public Dictionary<string, string> Environment { get; set; } = new();

    /// <summary>
    /// Whether this is the default profile
    /// </summary>
    public bool IsDefault { get; set; }

    /// <summary>
    /// Whether this profile is hidden from the shell selector
    /// </summary>
    public bool IsHidden { get; set; }

    /// <summary>
    /// Sorting order in the shell selector (lower = higher priority)
    /// </summary>
    public int SortOrder { get; set; }

    // Appearance overrides (null = use global settings)

    /// <summary>
    /// Font family override for this profile
    /// </summary>
    public string? FontFamily { get; set; }

    /// <summary>
    /// Font size override for this profile
    /// </summary>
    public double? FontSize { get; set; }

    /// <summary>
    /// Theme name override for this profile
    /// </summary>
    public string? ThemeName { get; set; }

    /// <summary>
    /// Cursor style override for this profile
    /// </summary>
    public TerminalCursorStyle? CursorStyle { get; set; }

    /// <summary>
    /// Whether cursor blinks (null = use global setting)
    /// </summary>
    public bool? CursorBlink { get; set; }

    /// <summary>
    /// Custom tab title format (supports placeholders)
    /// {name} = profile name, {cwd} = current directory, {process} = running process
    /// </summary>
    public string? TabTitleFormat { get; set; }

    /// <summary>
    /// Path to an icon for this profile (optional)
    /// </summary>
    public string? IconPath { get; set; }

    /// <summary>
    /// Accent color for this profile's tab (hex format)
    /// </summary>
    public string? AccentColor { get; set; }

    /// <summary>
    /// Command to run when the session starts (after shell initialization)
    /// </summary>
    public string? StartupCommand { get; set; }

    /// <summary>
    /// Whether to close the tab when the shell exits
    /// </summary>
    public ProfileCloseOnExit CloseOnExit { get; set; } = ProfileCloseOnExit.OnCleanExit;

    /// <summary>
    /// Bell style for this profile
    /// </summary>
    public TerminalBellStyle BellStyle { get; set; } = TerminalBellStyle.Audible;

    /// <summary>
    /// Number of scrollback lines (null = use global setting)
    /// </summary>
    public int? ScrollbackLines { get; set; }

    /// <summary>
    /// Date/time this profile was created
    /// </summary>
    public DateTime CreatedAt { get; init; } = DateTime.UtcNow;

    /// <summary>
    /// Date/time this profile was last modified
    /// </summary>
    public DateTime ModifiedAt { get; set; } = DateTime.UtcNow;

    /// <summary>
    /// Whether this profile is a built-in system profile (read-only)
    /// </summary>
    public bool IsBuiltIn { get; init; }

    /// <summary>
    /// Creates a copy of this profile with a new ID
    /// </summary>
    public ShellProfile Clone()
    {
        return new ShellProfile
        {
            Name = $"{Name} (Copy)",
            ShellPath = ShellPath,
            ShellType = ShellType,
            StartingDirectory = StartingDirectory,
            Arguments = Arguments,
            Environment = new Dictionary<string, string>(Environment),
            IsDefault = false,
            IsHidden = IsHidden,
            SortOrder = SortOrder + 1,
            FontFamily = FontFamily,
            FontSize = FontSize,
            ThemeName = ThemeName,
            CursorStyle = CursorStyle,
            CursorBlink = CursorBlink,
            TabTitleFormat = TabTitleFormat,
            IconPath = IconPath,
            AccentColor = AccentColor,
            StartupCommand = StartupCommand,
            CloseOnExit = CloseOnExit,
            BellStyle = BellStyle,
            ScrollbackLines = ScrollbackLines,
            IsBuiltIn = false
        };
    }
}

/// <summary>
/// Behavior when shell process exits
/// </summary>
public enum ProfileCloseOnExit
{
    /// <summary>
    /// Always close the tab when shell exits
    /// </summary>
    Always,

    /// <summary>
    /// Close only if shell exits with code 0
    /// </summary>
    OnCleanExit,

    /// <summary>
    /// Never auto-close (show exit message)
    /// </summary>
    Never
}

/// <summary>
/// Terminal cursor styles
/// </summary>
public enum TerminalCursorStyle
{
    /// <summary>
    /// Solid block cursor
    /// </summary>
    Block,

    /// <summary>
    /// Underline cursor
    /// </summary>
    Underline,

    /// <summary>
    /// Vertical bar cursor
    /// </summary>
    Bar
}

/// <summary>
/// Terminal bell notification styles
/// </summary>
public enum TerminalBellStyle
{
    /// <summary>
    /// Play audible bell sound
    /// </summary>
    Audible,

    /// <summary>
    /// Flash the terminal window/tab
    /// </summary>
    Visual,

    /// <summary>
    /// Both audible and visual
    /// </summary>
    Both,

    /// <summary>
    /// Disabled
    /// </summary>
    None
}
```

### ShellProfileDefaults Model

```csharp
namespace SeniorIntern.Core.Models.Terminal;

/// <summary>
/// Default values for shell profile settings (from app settings)
/// </summary>
public sealed class ShellProfileDefaults
{
    public string FontFamily { get; set; } = "Cascadia Mono, Consolas, monospace";
    public double FontSize { get; set; } = 14;
    public string ThemeName { get; set; } = "Dark";
    public TerminalCursorStyle CursorStyle { get; set; } = TerminalCursorStyle.Block;
    public bool CursorBlink { get; set; } = true;
    public int ScrollbackLines { get; set; } = 10000;
    public TerminalBellStyle BellStyle { get; set; } = TerminalBellStyle.Audible;
    public ProfileCloseOnExit CloseOnExit { get; set; } = ProfileCloseOnExit.OnCleanExit;
}
```

### TerminalSettings Extension

```csharp
namespace SeniorIntern.Core.Models;

// Extension to AppSettings for terminal-related configuration
public sealed class AppSettings
{
    // ... existing properties ...

    // Terminal Settings (v0.5.3)

    /// <summary>
    /// Default terminal font family
    /// </summary>
    public string TerminalFontFamily { get; set; } = "Cascadia Mono, Consolas, monospace";

    /// <summary>
    /// Default terminal font size
    /// </summary>
    public double TerminalFontSize { get; set; } = 14;

    /// <summary>
    /// Number of scrollback lines to retain
    /// </summary>
    public int TerminalScrollbackLines { get; set; } = 10000;

    /// <summary>
    /// Whether terminal bell is enabled
    /// </summary>
    public TerminalBellStyle TerminalBellStyle { get; set; } = TerminalBellStyle.Audible;

    /// <summary>
    /// Sync terminal working directory with active workspace
    /// </summary>
    public bool SyncTerminalWithWorkspace { get; set; } = true;

    /// <summary>
    /// Sync mode for terminal/workspace directory
    /// </summary>
    public DirectorySyncMode TerminalSyncMode { get; set; } = DirectorySyncMode.ActiveTerminalOnly;

    /// <summary>
    /// ID of the default shell profile
    /// </summary>
    public Guid? DefaultShellProfileId { get; set; }

    /// <summary>
    /// Terminal color theme name
    /// </summary>
    public string TerminalTheme { get; set; } = "Dark";

    /// <summary>
    /// Whether cursor blinks in terminal
    /// </summary>
    public bool TerminalCursorBlink { get; set; } = true;

    /// <summary>
    /// Cursor style in terminal
    /// </summary>
    public TerminalCursorStyle TerminalCursorStyle { get; set; } = TerminalCursorStyle.Block;

    /// <summary>
    /// Height of the terminal panel (when docked)
    /// </summary>
    public double TerminalPanelHeight { get; set; } = 300;

    /// <summary>
    /// Whether to show the terminal panel on startup
    /// </summary>
    public bool ShowTerminalOnStartup { get; set; } = false;

    /// <summary>
    /// Whether to restore terminal sessions on startup
    /// </summary>
    public bool RestoreTerminalSessions { get; set; } = false;

    /// <summary>
    /// Keyboard shortcut to toggle terminal panel
    /// </summary>
    public string TerminalToggleShortcut { get; set; } = "Ctrl+`";

    /// <summary>
    /// Keyboard shortcut to create new terminal
    /// </summary>
    public string TerminalNewShortcut { get; set; } = "Ctrl+Shift+`";

    /// <summary>
    /// Whether to copy on selection
    /// </summary>
    public bool TerminalCopyOnSelect { get; set; } = false;

    /// <summary>
    /// Word separators for double-click selection
    /// </summary>
    public string TerminalWordSeparators { get; set; } = " ()[]{}|;:'\",.<>/?!@#$%^&*-=+~`";
}

/// <summary>
/// How to sync terminal directory with workspace
/// </summary>
public enum DirectorySyncMode
{
    /// <summary>
    /// Only sync the active/focused terminal
    /// </summary>
    ActiveTerminalOnly,

    /// <summary>
    /// Sync all terminals linked to the workspace
    /// </summary>
    AllLinkedTerminals,

    /// <summary>
    /// Never auto-sync (manual only)
    /// </summary>
    Manual
}
```

### v0.5.3c Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Models/Terminal/ShellProfile.cs` | Shell profile model |
| `src/SeniorIntern.Core/Models/Terminal/ProfileCloseOnExit.cs` | Close behavior enum |
| `src/SeniorIntern.Core/Models/Terminal/TerminalCursorStyle.cs` | Cursor style enum |
| `src/SeniorIntern.Core/Models/Terminal/TerminalBellStyle.cs` | Bell style enum |
| `src/SeniorIntern.Core/Models/Terminal/ShellProfileDefaults.cs` | Default values |
| `src/SeniorIntern.Core/Models/Terminal/DirectorySyncMode.cs` | Sync mode enum |

### v0.5.3c Files to Modify

| File | Changes |
|------|---------|
| `src/SeniorIntern.Core/Models/AppSettings.cs` | Add terminal settings properties |

### v0.5.3c Verification

```bash
# Verify models compile
dotnet build src/SeniorIntern.Core

# Verify serialization
dotnet test --filter "ShellProfile"
```

### v0.5.3c Acceptance Criteria

- [ ] ShellProfile can be serialized/deserialized to JSON
- [ ] Profile Clone() creates proper deep copy
- [ ] All enum values are defined correctly
- [ ] AppSettings serialization includes new terminal properties
- [ ] Default values are reasonable for all platforms

---

## v0.5.3d: Profile Management Service

### Objective
Create a service for managing shell profiles including CRUD operations, persistence, default profile handling, and built-in profile generation from detected shells.

### IShellProfileService Interface

```csharp
namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Service for managing shell profiles
/// </summary>
public interface IShellProfileService
{
    /// <summary>
    /// Event raised when profiles change
    /// </summary>
    event EventHandler<ProfilesChangedEventArgs>? ProfilesChanged;

    /// <summary>
    /// Get all available profiles (built-in and custom)
    /// </summary>
    Task<IReadOnlyList<ShellProfile>> GetAllProfilesAsync(CancellationToken ct = default);

    /// <summary>
    /// Get visible profiles (excluding hidden)
    /// </summary>
    Task<IReadOnlyList<ShellProfile>> GetVisibleProfilesAsync(CancellationToken ct = default);

    /// <summary>
    /// Get a profile by ID
    /// </summary>
    Task<ShellProfile?> GetProfileAsync(Guid id, CancellationToken ct = default);

    /// <summary>
    /// Get the default profile
    /// </summary>
    Task<ShellProfile> GetDefaultProfileAsync(CancellationToken ct = default);

    /// <summary>
    /// Create a new profile
    /// </summary>
    Task<ShellProfile> CreateProfileAsync(ShellProfile profile, CancellationToken ct = default);

    /// <summary>
    /// Update an existing profile
    /// </summary>
    Task UpdateProfileAsync(ShellProfile profile, CancellationToken ct = default);

    /// <summary>
    /// Delete a profile
    /// </summary>
    Task DeleteProfileAsync(Guid id, CancellationToken ct = default);

    /// <summary>
    /// Set a profile as the default
    /// </summary>
    Task SetDefaultProfileAsync(Guid id, CancellationToken ct = default);

    /// <summary>
    /// Duplicate a profile
    /// </summary>
    Task<ShellProfile> DuplicateProfileAsync(Guid id, CancellationToken ct = default);

    /// <summary>
    /// Reset profiles to defaults (regenerate built-in profiles)
    /// </summary>
    Task ResetToDefaultsAsync(CancellationToken ct = default);

    /// <summary>
    /// Import profiles from JSON
    /// </summary>
    Task<int> ImportProfilesAsync(string json, CancellationToken ct = default);

    /// <summary>
    /// Export profiles to JSON
    /// </summary>
    Task<string> ExportProfilesAsync(IEnumerable<Guid>? profileIds = null, CancellationToken ct = default);

    /// <summary>
    /// Get effective settings for a profile (with defaults applied)
    /// </summary>
    ShellProfileDefaults GetEffectiveSettings(ShellProfile profile);
}

/// <summary>
/// Event args for profile changes
/// </summary>
public sealed class ProfilesChangedEventArgs : EventArgs
{
    public ProfileChangeType ChangeType { get; init; }
    public Guid? ProfileId { get; init; }
    public ShellProfile? Profile { get; init; }
}

/// <summary>
/// Type of profile change
/// </summary>
public enum ProfileChangeType
{
    Added,
    Updated,
    Deleted,
    DefaultChanged,
    Reset
}
```

### ShellProfileService Implementation

```csharp
namespace SeniorIntern.Services.Terminal;

using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models.Terminal;
using System.Text.Json;

/// <summary>
/// Manages shell profiles with persistence
/// </summary>
public sealed class ShellProfileService : IShellProfileService
{
    private readonly IShellDetectionService _shellDetection;
    private readonly ISettingsService _settingsService;
    private readonly ILogger<ShellProfileService> _logger;
    private readonly string _profilesPath;
    private readonly SemaphoreSlim _lock = new(1, 1);

    private List<ShellProfile>? _profiles;
    private bool _initialized;

    public event EventHandler<ProfilesChangedEventArgs>? ProfilesChanged;

    public ShellProfileService(
        IShellDetectionService shellDetection,
        ISettingsService settingsService,
        ILogger<ShellProfileService> logger)
    {
        _shellDetection = shellDetection;
        _settingsService = settingsService;
        _logger = logger;

        var appDataPath = Path.Combine(
            Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData),
            "SeniorIntern");
        Directory.CreateDirectory(appDataPath);
        _profilesPath = Path.Combine(appDataPath, "shell-profiles.json");
    }

    public async Task<IReadOnlyList<ShellProfile>> GetAllProfilesAsync(CancellationToken ct = default)
    {
        await EnsureInitializedAsync(ct);
        return _profiles!.AsReadOnly();
    }

    public async Task<IReadOnlyList<ShellProfile>> GetVisibleProfilesAsync(CancellationToken ct = default)
    {
        await EnsureInitializedAsync(ct);
        return _profiles!
            .Where(p => !p.IsHidden)
            .OrderBy(p => p.SortOrder)
            .ThenBy(p => p.Name)
            .ToList()
            .AsReadOnly();
    }

    public async Task<ShellProfile?> GetProfileAsync(Guid id, CancellationToken ct = default)
    {
        await EnsureInitializedAsync(ct);
        return _profiles!.FirstOrDefault(p => p.Id == id);
    }

    public async Task<ShellProfile> GetDefaultProfileAsync(CancellationToken ct = default)
    {
        await EnsureInitializedAsync(ct);

        var settings = await _settingsService.GetSettingsAsync();

        // 1. Try configured default profile
        if (settings.DefaultShellProfileId.HasValue)
        {
            var configured = _profiles!.FirstOrDefault(p => p.Id == settings.DefaultShellProfileId.Value);
            if (configured != null)
                return configured;
        }

        // 2. Try profile marked as default
        var defaultProfile = _profiles!.FirstOrDefault(p => p.IsDefault);
        if (defaultProfile != null)
            return defaultProfile;

        // 3. Return first available profile
        return _profiles!.First();
    }

    public async Task<ShellProfile> CreateProfileAsync(ShellProfile profile, CancellationToken ct = default)
    {
        await EnsureInitializedAsync(ct);
        await _lock.WaitAsync(ct);

        try
        {
            // Validate
            if (string.IsNullOrWhiteSpace(profile.ShellPath))
                throw new ArgumentException("Shell path is required", nameof(profile));

            if (!_shellDetection.ValidateShellPath(profile.ShellPath))
                throw new ArgumentException($"Invalid shell path: {profile.ShellPath}", nameof(profile));

            // Auto-detect shell type if not specified
            if (profile.ShellType == ShellType.Unknown)
            {
                profile.ShellType = _shellDetection.DetectShellType(profile.ShellPath);
            }

            profile.ModifiedAt = DateTime.UtcNow;
            _profiles!.Add(profile);

            await SaveProfilesAsync(ct);

            ProfilesChanged?.Invoke(this, new ProfilesChangedEventArgs
            {
                ChangeType = ProfileChangeType.Added,
                ProfileId = profile.Id,
                Profile = profile
            });

            _logger.LogInformation("Created profile: {Name} ({Id})", profile.Name, profile.Id);
            return profile;
        }
        finally
        {
            _lock.Release();
        }
    }

    public async Task UpdateProfileAsync(ShellProfile profile, CancellationToken ct = default)
    {
        await EnsureInitializedAsync(ct);
        await _lock.WaitAsync(ct);

        try
        {
            var existing = _profiles!.FirstOrDefault(p => p.Id == profile.Id);
            if (existing == null)
                throw new InvalidOperationException($"Profile not found: {profile.Id}");

            if (existing.IsBuiltIn)
                throw new InvalidOperationException("Cannot modify built-in profile");

            // Update in place
            var index = _profiles!.IndexOf(existing);
            profile.ModifiedAt = DateTime.UtcNow;
            _profiles[index] = profile;

            await SaveProfilesAsync(ct);

            ProfilesChanged?.Invoke(this, new ProfilesChangedEventArgs
            {
                ChangeType = ProfileChangeType.Updated,
                ProfileId = profile.Id,
                Profile = profile
            });

            _logger.LogInformation("Updated profile: {Name} ({Id})", profile.Name, profile.Id);
        }
        finally
        {
            _lock.Release();
        }
    }

    public async Task DeleteProfileAsync(Guid id, CancellationToken ct = default)
    {
        await EnsureInitializedAsync(ct);
        await _lock.WaitAsync(ct);

        try
        {
            var profile = _profiles!.FirstOrDefault(p => p.Id == id);
            if (profile == null)
                return;

            if (profile.IsBuiltIn)
                throw new InvalidOperationException("Cannot delete built-in profile");

            _profiles.Remove(profile);

            // If this was the default, clear the default setting
            var settings = await _settingsService.GetSettingsAsync();
            if (settings.DefaultShellProfileId == id)
            {
                settings.DefaultShellProfileId = null;
                await _settingsService.SaveSettingsAsync(settings);
            }

            await SaveProfilesAsync(ct);

            ProfilesChanged?.Invoke(this, new ProfilesChangedEventArgs
            {
                ChangeType = ProfileChangeType.Deleted,
                ProfileId = id
            });

            _logger.LogInformation("Deleted profile: {Id}", id);
        }
        finally
        {
            _lock.Release();
        }
    }

    public async Task SetDefaultProfileAsync(Guid id, CancellationToken ct = default)
    {
        await EnsureInitializedAsync(ct);
        await _lock.WaitAsync(ct);

        try
        {
            var profile = _profiles!.FirstOrDefault(p => p.Id == id);
            if (profile == null)
                throw new InvalidOperationException($"Profile not found: {id}");

            // Clear existing default
            foreach (var p in _profiles.Where(p => p.IsDefault))
            {
                p.IsDefault = false;
            }

            profile.IsDefault = true;

            // Update settings
            var settings = await _settingsService.GetSettingsAsync();
            settings.DefaultShellProfileId = id;
            await _settingsService.SaveSettingsAsync(settings);

            await SaveProfilesAsync(ct);

            ProfilesChanged?.Invoke(this, new ProfilesChangedEventArgs
            {
                ChangeType = ProfileChangeType.DefaultChanged,
                ProfileId = id,
                Profile = profile
            });

            _logger.LogInformation("Set default profile: {Name} ({Id})", profile.Name, id);
        }
        finally
        {
            _lock.Release();
        }
    }

    public async Task<ShellProfile> DuplicateProfileAsync(Guid id, CancellationToken ct = default)
    {
        await EnsureInitializedAsync(ct);

        var source = await GetProfileAsync(id, ct);
        if (source == null)
            throw new InvalidOperationException($"Profile not found: {id}");

        var duplicate = source.Clone();
        return await CreateProfileAsync(duplicate, ct);
    }

    public async Task ResetToDefaultsAsync(CancellationToken ct = default)
    {
        await _lock.WaitAsync(ct);

        try
        {
            _profiles = new List<ShellProfile>();
            await GenerateBuiltInProfilesAsync(ct);
            await SaveProfilesAsync(ct);

            ProfilesChanged?.Invoke(this, new ProfilesChangedEventArgs
            {
                ChangeType = ProfileChangeType.Reset
            });

            _logger.LogInformation("Reset profiles to defaults");
        }
        finally
        {
            _lock.Release();
        }
    }

    public async Task<int> ImportProfilesAsync(string json, CancellationToken ct = default)
    {
        var imported = JsonSerializer.Deserialize<List<ShellProfile>>(json);
        if (imported == null || imported.Count == 0)
            return 0;

        await EnsureInitializedAsync(ct);
        await _lock.WaitAsync(ct);

        try
        {
            var count = 0;
            foreach (var profile in imported)
            {
                // Generate new ID to avoid conflicts
                var newProfile = new ShellProfile
                {
                    Name = profile.Name,
                    ShellPath = profile.ShellPath,
                    ShellType = profile.ShellType,
                    StartingDirectory = profile.StartingDirectory,
                    Arguments = profile.Arguments,
                    Environment = new Dictionary<string, string>(profile.Environment),
                    FontFamily = profile.FontFamily,
                    FontSize = profile.FontSize,
                    ThemeName = profile.ThemeName,
                    CursorStyle = profile.CursorStyle,
                    CursorBlink = profile.CursorBlink,
                    TabTitleFormat = profile.TabTitleFormat,
                    StartupCommand = profile.StartupCommand,
                    CloseOnExit = profile.CloseOnExit,
                    BellStyle = profile.BellStyle,
                    ScrollbackLines = profile.ScrollbackLines,
                    IsBuiltIn = false
                };

                if (_shellDetection.ValidateShellPath(newProfile.ShellPath))
                {
                    _profiles!.Add(newProfile);
                    count++;
                }
            }

            await SaveProfilesAsync(ct);
            return count;
        }
        finally
        {
            _lock.Release();
        }
    }

    public async Task<string> ExportProfilesAsync(IEnumerable<Guid>? profileIds = null, CancellationToken ct = default)
    {
        await EnsureInitializedAsync(ct);

        var profilesToExport = profileIds == null
            ? _profiles!.Where(p => !p.IsBuiltIn).ToList()
            : _profiles!.Where(p => profileIds.Contains(p.Id)).ToList();

        return JsonSerializer.Serialize(profilesToExport, new JsonSerializerOptions
        {
            WriteIndented = true
        });
    }

    public ShellProfileDefaults GetEffectiveSettings(ShellProfile profile)
    {
        var settings = _settingsService.GetSettingsAsync().GetAwaiter().GetResult();

        return new ShellProfileDefaults
        {
            FontFamily = profile.FontFamily ?? settings.TerminalFontFamily,
            FontSize = profile.FontSize ?? settings.TerminalFontSize,
            ThemeName = profile.ThemeName ?? settings.TerminalTheme,
            CursorStyle = profile.CursorStyle ?? settings.TerminalCursorStyle,
            CursorBlink = profile.CursorBlink ?? settings.TerminalCursorBlink,
            ScrollbackLines = profile.ScrollbackLines ?? settings.TerminalScrollbackLines,
            BellStyle = profile.BellStyle,
            CloseOnExit = profile.CloseOnExit
        };
    }

    private async Task EnsureInitializedAsync(CancellationToken ct)
    {
        if (_initialized)
            return;

        await _lock.WaitAsync(ct);
        try
        {
            if (_initialized)
                return;

            await LoadProfilesAsync(ct);
            _initialized = true;
        }
        finally
        {
            _lock.Release();
        }
    }

    private async Task LoadProfilesAsync(CancellationToken ct)
    {
        if (File.Exists(_profilesPath))
        {
            try
            {
                var json = await File.ReadAllTextAsync(_profilesPath, ct);
                _profiles = JsonSerializer.Deserialize<List<ShellProfile>>(json) ?? new List<ShellProfile>();
                _logger.LogDebug("Loaded {Count} profiles from disk", _profiles.Count);
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Failed to load profiles, regenerating");
                _profiles = new List<ShellProfile>();
            }
        }
        else
        {
            _profiles = new List<ShellProfile>();
        }

        // Always regenerate built-in profiles to pick up new shells
        await GenerateBuiltInProfilesAsync(ct);
    }

    private async Task GenerateBuiltInProfilesAsync(CancellationToken ct)
    {
        var shells = await _shellDetection.GetAvailableShellsAsync(ct);
        var existingBuiltInIds = _profiles!
            .Where(p => p.IsBuiltIn)
            .Select(p => p.ShellPath)
            .ToHashSet(StringComparer.OrdinalIgnoreCase);

        foreach (var shell in shells)
        {
            // Skip if we already have a built-in profile for this shell
            if (existingBuiltInIds.Contains(shell.Path))
                continue;

            var profile = new ShellProfile
            {
                Name = shell.Name,
                ShellPath = shell.Path,
                ShellType = shell.Type,
                IsDefault = shell.IsDefault,
                IsBuiltIn = true,
                Arguments = shell.DefaultArguments,
                IconPath = shell.IconPath,
                SortOrder = shell.IsDefault ? 0 : 100
            };

            _profiles.Add(profile);
            _logger.LogDebug("Generated built-in profile: {Name}", profile.Name);
        }

        // Ensure at least one default
        if (!_profiles.Any(p => p.IsDefault) && _profiles.Count > 0)
        {
            _profiles[0].IsDefault = true;
        }
    }

    private async Task SaveProfilesAsync(CancellationToken ct)
    {
        var json = JsonSerializer.Serialize(_profiles, new JsonSerializerOptions
        {
            WriteIndented = true
        });

        await File.WriteAllTextAsync(_profilesPath, json, ct);
        _logger.LogDebug("Saved {Count} profiles to disk", _profiles!.Count);
    }
}
```

### v0.5.3d Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/IShellProfileService.cs` | Profile service interface |
| `src/SeniorIntern.Core/Models/Terminal/ProfilesChangedEventArgs.cs` | Event args |
| `src/SeniorIntern.Services/Terminal/ShellProfileService.cs` | Profile service implementation |

### v0.5.3d Files to Modify

| File | Changes |
|------|---------|
| `src/SeniorIntern.Services/DependencyInjection.cs` | Register IShellProfileService as singleton |

### v0.5.3d Verification

```bash
# Verify profile persistence
dotnet test --filter "ShellProfileService"

# Check profiles file location
ls ~/.config/SeniorIntern/shell-profiles.json  # Unix
dir %APPDATA%\SeniorIntern\shell-profiles.json  # Windows
```

### v0.5.3d Acceptance Criteria

- [ ] Profiles persist across application restarts
- [ ] Built-in profiles are generated from detected shells
- [ ] Custom profiles can be created, updated, deleted
- [ ] Default profile can be set and persisted
- [ ] Profile duplication creates proper copy
- [ ] Import/export produces valid JSON
- [ ] Built-in profiles cannot be deleted
- [ ] Profile validation rejects invalid shell paths

---

## v0.5.3e: Working Directory Synchronization

### Objective
Implement bi-directional synchronization between the terminal's working directory and the file explorer's current location. Support OSC 7 escape sequences for directory change detection and provide commands for manual synchronization.

### IWorkingDirectorySyncService Interface

```csharp
namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Service for synchronizing working directories between terminal and file explorer
/// </summary>
public interface IWorkingDirectorySyncService
{
    /// <summary>
    /// Event raised when the terminal's directory changes
    /// </summary>
    event EventHandler<DirectoryChangedEventArgs>? TerminalDirectoryChanged;

    /// <summary>
    /// Event raised when the file explorer's directory changes
    /// </summary>
    event EventHandler<DirectoryChangedEventArgs>? ExplorerDirectoryChanged;

    /// <summary>
    /// Get the current working directory for a terminal session
    /// </summary>
    Task<string?> GetTerminalDirectoryAsync(Guid sessionId, CancellationToken ct = default);

    /// <summary>
    /// Change the terminal's working directory
    /// </summary>
    Task ChangeTerminalDirectoryAsync(Guid sessionId, string path, CancellationToken ct = default);

    /// <summary>
    /// Sync terminal directory to match file explorer
    /// </summary>
    Task SyncTerminalToExplorerAsync(Guid sessionId, CancellationToken ct = default);

    /// <summary>
    /// Sync file explorer to match terminal directory
    /// </summary>
    Task SyncExplorerToTerminalAsync(Guid sessionId, CancellationToken ct = default);

    /// <summary>
    /// Enable/disable automatic sync for a session
    /// </summary>
    void SetAutoSync(Guid sessionId, bool enabled);

    /// <summary>
    /// Check if auto-sync is enabled for a session
    /// </summary>
    bool IsAutoSyncEnabled(Guid sessionId);

    /// <summary>
    /// Process an OSC 7 directory report from the terminal
    /// </summary>
    void ProcessOsc7(Guid sessionId, string uri);

    /// <summary>
    /// Link a terminal session to a workspace
    /// </summary>
    void LinkToWorkspace(Guid sessionId, Guid workspaceId);

    /// <summary>
    /// Unlink a terminal session from its workspace
    /// </summary>
    void UnlinkFromWorkspace(Guid sessionId);
}

/// <summary>
/// Event args for directory changes
/// </summary>
public sealed class DirectoryChangedEventArgs : EventArgs
{
    public Guid SessionId { get; init; }
    public string OldDirectory { get; init; } = string.Empty;
    public string NewDirectory { get; init; } = string.Empty;
    public DirectoryChangeSource Source { get; init; }
}

/// <summary>
/// Source of a directory change
/// </summary>
public enum DirectoryChangeSource
{
    /// <summary>
    /// Directory changed via shell command
    /// </summary>
    Shell,

    /// <summary>
    /// Directory changed via OSC 7 escape sequence
    /// </summary>
    Osc7,

    /// <summary>
    /// Directory changed via explicit API call
    /// </summary>
    Api,

    /// <summary>
    /// Directory changed via file explorer sync
    /// </summary>
    ExplorerSync,

    /// <summary>
    /// Directory changed via workspace change
    /// </summary>
    WorkspaceSync
}
```

### WorkingDirectorySyncService Implementation

```csharp
namespace SeniorIntern.Services.Terminal;

using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models.Terminal;
using System.Collections.Concurrent;
using System.Web;

/// <summary>
/// Manages working directory synchronization between terminal and file explorer
/// </summary>
public sealed class WorkingDirectorySyncService : IWorkingDirectorySyncService, IDisposable
{
    private readonly ITerminalService _terminalService;
    private readonly IShellConfigurationService _shellConfig;
    private readonly ISettingsService _settingsService;
    private readonly ILogger<WorkingDirectorySyncService> _logger;

    private readonly ConcurrentDictionary<Guid, SessionSyncState> _sessionStates = new();

    public event EventHandler<DirectoryChangedEventArgs>? TerminalDirectoryChanged;
    public event EventHandler<DirectoryChangedEventArgs>? ExplorerDirectoryChanged;

    public WorkingDirectorySyncService(
        ITerminalService terminalService,
        IShellConfigurationService shellConfig,
        ISettingsService settingsService,
        ILogger<WorkingDirectorySyncService> logger)
    {
        _terminalService = terminalService;
        _shellConfig = shellConfig;
        _settingsService = settingsService;
        _logger = logger;

        // Subscribe to terminal events
        _terminalService.SessionCreated += OnSessionCreated;
        _terminalService.SessionClosed += OnSessionClosed;
    }

    private void OnSessionCreated(object? sender, TerminalSessionEventArgs e)
    {
        var state = new SessionSyncState
        {
            SessionId = e.Session.Id,
            CurrentDirectory = e.Session.WorkingDirectory,
            AutoSyncEnabled = true
        };

        _sessionStates[e.Session.Id] = state;
        _logger.LogDebug("Tracking directory sync for session: {Id}", e.Session.Id);
    }

    private void OnSessionClosed(object? sender, TerminalSessionEventArgs e)
    {
        _sessionStates.TryRemove(e.Session.Id, out _);
        _logger.LogDebug("Stopped tracking session: {Id}", e.Session.Id);
    }

    public async Task<string?> GetTerminalDirectoryAsync(Guid sessionId, CancellationToken ct = default)
    {
        if (!_sessionStates.TryGetValue(sessionId, out var state))
            return null;

        // If we have a recent directory from OSC 7, use that
        if (!string.IsNullOrEmpty(state.CurrentDirectory))
            return state.CurrentDirectory;

        // Otherwise, query the shell
        return await QueryShellDirectoryAsync(sessionId, ct);
    }

    private async Task<string?> QueryShellDirectoryAsync(Guid sessionId, CancellationToken ct)
    {
        try
        {
            var session = _terminalService.GetSession(sessionId);
            if (session == null)
                return null;

            var config = _shellConfig.GetConfiguration(session.ShellPath);

            // Send pwd command and capture output
            // This is a simplified version - real implementation needs output capture
            await _terminalService.WriteInputAsync(
                sessionId,
                config.PrintWorkingDirectoryCommand + "\n",
                ct);

            // In practice, we'd need to parse the output
            // For now, rely on OSC 7 or stored state
            return null;
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Failed to query shell directory for session: {Id}", sessionId);
            return null;
        }
    }

    public async Task ChangeTerminalDirectoryAsync(Guid sessionId, string path, CancellationToken ct = default)
    {
        var session = _terminalService.GetSession(sessionId);
        if (session == null)
        {
            _logger.LogWarning("Cannot change directory - session not found: {Id}", sessionId);
            return;
        }

        // Validate path exists
        if (!Directory.Exists(path))
        {
            _logger.LogWarning("Cannot change to non-existent directory: {Path}", path);
            return;
        }

        var config = _shellConfig.GetConfiguration(session.ShellPath);
        var command = _shellConfig.FormatChangeDirectoryCommand(session.ShellType, path);

        _logger.LogDebug("Changing directory for session {Id}: {Command}", sessionId, command);

        await _terminalService.WriteInputAsync(sessionId, command + "\n", ct);

        // Update state optimistically
        if (_sessionStates.TryGetValue(sessionId, out var state))
        {
            var oldDir = state.CurrentDirectory;
            state.CurrentDirectory = path;

            TerminalDirectoryChanged?.Invoke(this, new DirectoryChangedEventArgs
            {
                SessionId = sessionId,
                OldDirectory = oldDir ?? string.Empty,
                NewDirectory = path,
                Source = DirectoryChangeSource.Api
            });
        }
    }

    public async Task SyncTerminalToExplorerAsync(Guid sessionId, CancellationToken ct = default)
    {
        // This would be called by the ViewModel when file explorer directory changes
        // The actual explorer directory should be passed from the caller

        // Placeholder - actual implementation gets explorer path from workspace service
        _logger.LogDebug("Sync terminal to explorer requested for session: {Id}", sessionId);
    }

    public async Task SyncExplorerToTerminalAsync(Guid sessionId, CancellationToken ct = default)
    {
        var directory = await GetTerminalDirectoryAsync(sessionId, ct);
        if (string.IsNullOrEmpty(directory))
        {
            _logger.LogWarning("Cannot sync explorer - no terminal directory for session: {Id}", sessionId);
            return;
        }

        ExplorerDirectoryChanged?.Invoke(this, new DirectoryChangedEventArgs
        {
            SessionId = sessionId,
            NewDirectory = directory,
            Source = DirectoryChangeSource.Shell
        });
    }

    public void SetAutoSync(Guid sessionId, bool enabled)
    {
        if (_sessionStates.TryGetValue(sessionId, out var state))
        {
            state.AutoSyncEnabled = enabled;
            _logger.LogDebug("Auto-sync {Status} for session: {Id}",
                enabled ? "enabled" : "disabled", sessionId);
        }
    }

    public bool IsAutoSyncEnabled(Guid sessionId)
    {
        return _sessionStates.TryGetValue(sessionId, out var state) && state.AutoSyncEnabled;
    }

    public void ProcessOsc7(Guid sessionId, string uri)
    {
        // OSC 7 format: file://hostname/path/to/directory
        // Example: file://MacBook-Pro.local/Users/dev/project

        if (!_sessionStates.TryGetValue(sessionId, out var state))
            return;

        try
        {
            var parsedUri = new Uri(uri);
            var path = HttpUtility.UrlDecode(parsedUri.LocalPath);

            // Handle Windows paths from WSL
            if (path.StartsWith("/mnt/") && OperatingSystem.IsWindows())
            {
                // /mnt/c/Users/... -> C:\Users\...
                var parts = path.Split('/', StringSplitOptions.RemoveEmptyEntries);
                if (parts.Length >= 2 && parts[0] == "mnt" && parts[1].Length == 1)
                {
                    var drive = parts[1].ToUpper();
                    var windowsPath = string.Join("\\", parts.Skip(2));
                    path = $"{drive}:\\{windowsPath}";
                }
            }

            if (!string.IsNullOrEmpty(path) && Directory.Exists(path))
            {
                var oldDir = state.CurrentDirectory;
                state.CurrentDirectory = path;

                _logger.LogDebug("OSC 7 directory update for session {Id}: {Path}", sessionId, path);

                TerminalDirectoryChanged?.Invoke(this, new DirectoryChangedEventArgs
                {
                    SessionId = sessionId,
                    OldDirectory = oldDir ?? string.Empty,
                    NewDirectory = path,
                    Source = DirectoryChangeSource.Osc7
                });

                // Auto-sync to explorer if enabled
                var settings = _settingsService.GetSettingsAsync().GetAwaiter().GetResult();
                if (state.AutoSyncEnabled && settings.SyncTerminalWithWorkspace)
                {
                    ExplorerDirectoryChanged?.Invoke(this, new DirectoryChangedEventArgs
                    {
                        SessionId = sessionId,
                        NewDirectory = path,
                        Source = DirectoryChangeSource.Osc7
                    });
                }
            }
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Failed to parse OSC 7 URI: {Uri}", uri);
        }
    }

    public void LinkToWorkspace(Guid sessionId, Guid workspaceId)
    {
        if (_sessionStates.TryGetValue(sessionId, out var state))
        {
            state.LinkedWorkspaceId = workspaceId;
            _logger.LogDebug("Linked session {SessionId} to workspace {WorkspaceId}",
                sessionId, workspaceId);
        }
    }

    public void UnlinkFromWorkspace(Guid sessionId)
    {
        if (_sessionStates.TryGetValue(sessionId, out var state))
        {
            state.LinkedWorkspaceId = null;
            _logger.LogDebug("Unlinked session {Id} from workspace", sessionId);
        }
    }

    public void Dispose()
    {
        _terminalService.SessionCreated -= OnSessionCreated;
        _terminalService.SessionClosed -= OnSessionClosed;
    }

    private sealed class SessionSyncState
    {
        public Guid SessionId { get; init; }
        public string? CurrentDirectory { get; set; }
        public bool AutoSyncEnabled { get; set; }
        public Guid? LinkedWorkspaceId { get; set; }
    }
}
```

### OSC 7 Parser Integration

The ANSI parser from v0.5.1 needs to be extended to handle OSC 7 sequences:

```csharp
// Addition to AnsiParser.cs (v0.5.1)

/// <summary>
/// Event raised when OSC 7 (current directory) is received
/// </summary>
public event EventHandler<Osc7EventArgs>? Osc7Received;

private void ProcessOscState(byte b)
{
    if (b == 0x07 || b == 0x9C) // BEL or ST (String Terminator)
    {
        ExecuteOscCommand();
        _state = ParserState.Ground;
        return;
    }

    // Handle ESC \ as ST
    if (b == 0x5C && _escapeSequence.Length > 0 &&
        _escapeSequence[^1] == '\x1B')
    {
        _escapeSequence.Length--; // Remove the ESC
        ExecuteOscCommand();
        _state = ParserState.Ground;
        return;
    }

    _escapeSequence.Append((char)b);
}

private void ExecuteOscCommand()
{
    var sequence = _escapeSequence.ToString();
    var semicolonIndex = sequence.IndexOf(';');

    if (semicolonIndex <= 0)
        return;

    if (!int.TryParse(sequence.AsSpan(0, semicolonIndex), out var command))
        return;

    var parameter = sequence.Substring(semicolonIndex + 1);

    switch (command)
    {
        case 0: // Set icon name and window title
        case 2: // Set window title
            OnTitleChanged(parameter);
            break;

        case 7: // Current working directory
            Osc7Received?.Invoke(this, new Osc7EventArgs { Uri = parameter });
            break;

        case 9: // ConEmu/Windows Terminal notifications
            ProcessOsc9(parameter);
            break;

        case 133: // Shell integration (prompt marks)
            ProcessOsc133(parameter);
            break;
    }
}

public sealed class Osc7EventArgs : EventArgs
{
    public string Uri { get; init; } = string.Empty;
}
```

### v0.5.3e Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/IWorkingDirectorySyncService.cs` | Sync service interface |
| `src/SeniorIntern.Core/Models/Terminal/DirectoryChangedEventArgs.cs` | Event args |
| `src/SeniorIntern.Core/Models/Terminal/DirectoryChangeSource.cs` | Change source enum |
| `src/SeniorIntern.Services/Terminal/WorkingDirectorySyncService.cs` | Sync service implementation |

### v0.5.3e Files to Modify

| File | Changes |
|------|---------|
| `src/SeniorIntern.Core/Terminal/AnsiParser.cs` | Add OSC 7 handling |
| `src/SeniorIntern.Services/Terminal/TerminalService.cs` | Wire up sync service |
| `src/SeniorIntern.Services/DependencyInjection.cs` | Register IWorkingDirectorySyncService |

### v0.5.3e Verification

```bash
# Test OSC 7 parsing
dotnet test --filter "Osc7"

# Manual test: In terminal, run:
# printf '\e]7;file://localhost/tmp\a'
# Verify directory updates
```

### v0.5.3e Acceptance Criteria

- [ ] OSC 7 sequences are correctly parsed
- [ ] Directory changes trigger appropriate events
- [ ] Auto-sync respects user settings
- [ ] Bi-directional sync works (terminal  explorer)
- [ ] WSL paths are correctly translated on Windows
- [ ] Invalid paths are handled gracefully
- [ ] Sessions can be linked/unlinked from workspaces

---

## v0.5.3f: File Explorer Integration

### Objective
Add "Open in Integrated Terminal" context menu option to the file explorer, create the shell selector UI for choosing which profile to use, and add terminal-related items to the application settings page.

### FileExplorerViewModel Extensions

```csharp
namespace SeniorIntern.Desktop.ViewModels;

public partial class FileExplorerViewModel : ViewModelBase
{
    private readonly IShellProfileService _shellProfileService;
    private readonly ITerminalService _terminalService;
    private readonly IWorkingDirectorySyncService _directorySyncService;

    // ... existing code ...

    [RelayCommand]
    private async Task OpenInTerminalAsync(FileSystemItem? item)
    {
        var path = item?.IsDirectory == true
            ? item.FullPath
            : item?.ParentPath ?? CurrentDirectory;

        if (string.IsNullOrEmpty(path))
            return;

        var profile = await _shellProfileService.GetDefaultProfileAsync();
        await OpenTerminalWithProfileAsync(profile, path);
    }

    [RelayCommand]
    private async Task OpenInTerminalWithProfileAsync(ShellProfile profile, string? path = null)
    {
        var directory = path ?? CurrentDirectory;
        if (string.IsNullOrEmpty(directory))
            return;

        var session = await _terminalService.CreateSessionAsync(new TerminalSessionOptions
        {
            ShellPath = profile.ShellPath,
            Arguments = profile.Arguments,
            WorkingDirectory = directory,
            Environment = profile.Environment,
            Name = profile.Name
        });

        // Link to current workspace
        if (CurrentWorkspace != null)
        {
            _directorySyncService.LinkToWorkspace(session.Id, CurrentWorkspace.Id);
        }

        // Show terminal panel
        Messenger.Send(new ShowTerminalPanelMessage());
    }

    /// <summary>
    /// Get available shell profiles for context menu
    /// </summary>
    public async Task<IReadOnlyList<ShellProfile>> GetShellProfilesAsync()
    {
        return await _shellProfileService.GetVisibleProfilesAsync();
    }
}
```

### ShellSelectorViewModel

```csharp
namespace SeniorIntern.Desktop.ViewModels;

using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models.Terminal;

/// <summary>
/// ViewModel for the shell profile selector dialog
/// </summary>
public partial class ShellSelectorViewModel : ViewModelBase
{
    private readonly IShellProfileService _profileService;
    private readonly IShellDetectionService _shellDetection;
    private readonly IShellConfigurationService _shellConfig;

    [ObservableProperty]
    private ObservableCollection<ShellProfile> _profiles = new();

    [ObservableProperty]
    private ShellProfile? _selectedProfile;

    [ObservableProperty]
    private bool _showNewProfileForm;

    [ObservableProperty]
    private string _newProfileName = string.Empty;

    [ObservableProperty]
    private string _newProfilePath = string.Empty;

    [ObservableProperty]
    private string _newProfileArguments = string.Empty;

    [ObservableProperty]
    private string? _validationError;

    public ShellSelectorViewModel(
        IShellProfileService profileService,
        IShellDetectionService shellDetection,
        IShellConfigurationService shellConfig)
    {
        _profileService = profileService;
        _shellDetection = shellDetection;
        _shellConfig = shellConfig;

        LoadProfilesCommand.Execute(null);
    }

    [RelayCommand]
    private async Task LoadProfilesAsync()
    {
        var profiles = await _profileService.GetVisibleProfilesAsync();
        Profiles = new ObservableCollection<ShellProfile>(profiles);

        SelectedProfile = Profiles.FirstOrDefault(p => p.IsDefault)
                         ?? Profiles.FirstOrDefault();
    }

    [RelayCommand]
    private async Task SelectProfileAsync(ShellProfile profile)
    {
        SelectedProfile = profile;
    }

    [RelayCommand]
    private void ShowNewProfile()
    {
        ShowNewProfileForm = true;
        NewProfileName = string.Empty;
        NewProfilePath = string.Empty;
        NewProfileArguments = string.Empty;
        ValidationError = null;
    }

    [RelayCommand]
    private void CancelNewProfile()
    {
        ShowNewProfileForm = false;
    }

    [RelayCommand]
    private async Task CreateProfileAsync()
    {
        ValidationError = null;

        // Validate
        if (string.IsNullOrWhiteSpace(NewProfileName))
        {
            ValidationError = "Profile name is required";
            return;
        }

        if (string.IsNullOrWhiteSpace(NewProfilePath))
        {
            ValidationError = "Shell path is required";
            return;
        }

        if (!_shellDetection.ValidateShellPath(NewProfilePath))
        {
            ValidationError = "Invalid shell path";
            return;
        }

        try
        {
            var profile = new ShellProfile
            {
                Name = NewProfileName,
                ShellPath = NewProfilePath,
                Arguments = string.IsNullOrWhiteSpace(NewProfileArguments) ? null : NewProfileArguments,
                ShellType = _shellDetection.DetectShellType(NewProfilePath)
            };

            await _profileService.CreateProfileAsync(profile);
            await LoadProfilesAsync();

            ShowNewProfileForm = false;
            SelectedProfile = Profiles.FirstOrDefault(p => p.Id == profile.Id);
        }
        catch (Exception ex)
        {
            ValidationError = ex.Message;
        }
    }

    [RelayCommand]
    private async Task SetAsDefaultAsync(ShellProfile profile)
    {
        await _profileService.SetDefaultProfileAsync(profile.Id);
        await LoadProfilesAsync();
    }

    [RelayCommand]
    private async Task DeleteProfileAsync(ShellProfile profile)
    {
        if (profile.IsBuiltIn)
            return;

        await _profileService.DeleteProfileAsync(profile.Id);
        await LoadProfilesAsync();
    }

    [RelayCommand]
    private async Task BrowseForShellAsync()
    {
        // This would open a file picker dialog
        // Implementation depends on Avalonia's file dialog API
    }
}
```

### ShellSelectorView.axaml

```xml
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:vm="using:SeniorIntern.Desktop.ViewModels"
             x:Class="SeniorIntern.Desktop.Views.ShellSelectorView"
             x:DataType="vm:ShellSelectorViewModel">

    <Design.DataContext>
        <vm:ShellSelectorViewModel />
    </Design.DataContext>

    <Border Background="{DynamicResource BackgroundBrush}"
            BorderBrush="{DynamicResource BorderBrush}"
            BorderThickness="1"
            CornerRadius="8"
            Padding="16"
            Width="400"
            MaxHeight="500">
        <Grid RowDefinitions="Auto,*,Auto">
            <!-- Header -->
            <TextBlock Grid.Row="0"
                       Text="Select Terminal Profile"
                       FontSize="16"
                       FontWeight="SemiBold"
                       Margin="0,0,0,16" />

            <!-- Profile List or New Profile Form -->
            <Panel Grid.Row="1">
                <!-- Profile List -->
                <ScrollViewer IsVisible="{Binding !ShowNewProfileForm}">
                    <ItemsControl ItemsSource="{Binding Profiles}">
                        <ItemsControl.ItemTemplate>
                            <DataTemplate x:DataType="vm:ShellProfile">
                                <Button Command="{Binding $parent[UserControl].((vm:ShellSelectorViewModel)DataContext).SelectProfileCommand}"
                                        CommandParameter="{Binding}"
                                        HorizontalAlignment="Stretch"
                                        Padding="12,8"
                                        Margin="0,0,0,4">
                                    <Button.Styles>
                                        <Style Selector="Button:pointerover">
                                            <Setter Property="Background" Value="{DynamicResource HoverBrush}" />
                                        </Style>
                                    </Button.Styles>

                                    <Grid ColumnDefinitions="Auto,*,Auto">
                                        <!-- Shell Icon -->
                                        <Border Grid.Column="0"
                                                Width="32"
                                                Height="32"
                                                Background="{DynamicResource AccentBrush}"
                                                CornerRadius="4"
                                                Margin="0,0,12,0">
                                            <TextBlock Text="{Binding Name[0]}"
                                                       HorizontalAlignment="Center"
                                                       VerticalAlignment="Center"
                                                       Foreground="White"
                                                       FontWeight="Bold" />
                                        </Border>

                                        <!-- Name and Path -->
                                        <StackPanel Grid.Column="1" VerticalAlignment="Center">
                                            <StackPanel Orientation="Horizontal">
                                                <TextBlock Text="{Binding Name}"
                                                           FontWeight="Medium" />
                                                <TextBlock Text=" (Default)"
                                                           IsVisible="{Binding IsDefault}"
                                                           Foreground="{DynamicResource AccentBrush}"
                                                           FontSize="12" />
                                            </StackPanel>
                                            <TextBlock Text="{Binding ShellPath}"
                                                       FontSize="11"
                                                       Opacity="0.6"
                                                       TextTrimming="CharacterEllipsis" />
                                        </StackPanel>

                                        <!-- Selection Indicator -->
                                        <Border Grid.Column="2"
                                                Width="8"
                                                Height="8"
                                                CornerRadius="4"
                                                Background="{DynamicResource AccentBrush}"
                                                IsVisible="{Binding $parent[UserControl].((vm:ShellSelectorViewModel)DataContext).SelectedProfile.Id,
                                                    Converter={StaticResource EqualityConverter},
                                                    ConverterParameter={Binding Id}}"
                                                VerticalAlignment="Center" />
                                    </Grid>
                                </Button>
                            </DataTemplate>
                        </ItemsControl.ItemTemplate>
                    </ItemsControl>
                </ScrollViewer>

                <!-- New Profile Form -->
                <StackPanel IsVisible="{Binding ShowNewProfileForm}" Spacing="12">
                    <TextBox Watermark="Profile Name"
                             Text="{Binding NewProfileName}" />

                    <Grid ColumnDefinitions="*,Auto">
                        <TextBox Grid.Column="0"
                                 Watermark="Shell Path"
                                 Text="{Binding NewProfilePath}" />
                        <Button Grid.Column="1"
                                Content="..."
                                Command="{Binding BrowseForShellCommand}"
                                Margin="8,0,0,0"
                                Width="40" />
                    </Grid>

                    <TextBox Watermark="Arguments (optional)"
                             Text="{Binding NewProfileArguments}" />

                    <TextBlock Text="{Binding ValidationError}"
                               Foreground="Red"
                               IsVisible="{Binding ValidationError, Converter={x:Static StringConverters.IsNotNullOrEmpty}}"
                               FontSize="12" />
                </StackPanel>
            </Panel>

            <!-- Footer Buttons -->
            <StackPanel Grid.Row="2" Orientation="Horizontal" HorizontalAlignment="Right" Margin="0,16,0,0" Spacing="8">
                <Button Content="New Profile"
                        Command="{Binding ShowNewProfileCommand}"
                        IsVisible="{Binding !ShowNewProfileForm}" />

                <Button Content="Cancel"
                        Command="{Binding CancelNewProfileCommand}"
                        IsVisible="{Binding ShowNewProfileForm}" />

                <Button Content="Create"
                        Command="{Binding CreateProfileCommand}"
                        IsVisible="{Binding ShowNewProfileForm}"
                        Classes="primary" />
            </StackPanel>
        </Grid>
    </Border>
</UserControl>
```

### FileExplorerView Context Menu Update

```xml
<!-- Addition to FileExplorerView.axaml -->
<TreeView.ContextMenu>
    <ContextMenu>
        <!-- Existing items... -->

        <Separator />

        <!-- Open in Terminal -->
        <MenuItem Header="Open in Integrated Terminal"
                  Command="{Binding OpenInTerminalCommand}"
                  CommandParameter="{Binding SelectedItem}"
                  IsVisible="{Binding SelectedItem.IsDirectory}">
            <MenuItem.Icon>
                <PathIcon Data="{StaticResource TerminalIcon}" />
            </MenuItem.Icon>
        </MenuItem>

        <!-- Open in Terminal with Profile -->
        <MenuItem Header="Open in Terminal..."
                  IsVisible="{Binding SelectedItem.IsDirectory}">
            <MenuItem.Icon>
                <PathIcon Data="{StaticResource TerminalIcon}" />
            </MenuItem.Icon>
            <!-- Sub-menu populated dynamically with profiles -->
        </MenuItem>
    </ContextMenu>
</TreeView.ContextMenu>
```

### Terminal Settings Section

```xml
<!-- Addition to SettingsView.axaml -->
<Expander Header="Terminal" IsExpanded="True" Margin="0,16,0,0">
    <StackPanel Spacing="12" Margin="16,8">
        <!-- Default Profile -->
        <StackPanel>
            <TextBlock Text="Default Profile" FontWeight="Medium" Margin="0,0,0,4" />
            <ComboBox ItemsSource="{Binding ShellProfiles}"
                      SelectedItem="{Binding SelectedDefaultProfile}"
                      HorizontalAlignment="Stretch">
                <ComboBox.ItemTemplate>
                    <DataTemplate>
                        <TextBlock Text="{Binding Name}" />
                    </DataTemplate>
                </ComboBox.ItemTemplate>
            </ComboBox>
        </StackPanel>

        <!-- Font Settings -->
        <StackPanel>
            <TextBlock Text="Font" FontWeight="Medium" Margin="0,0,0,4" />
            <Grid ColumnDefinitions="*,100" ColumnSpacing="8">
                <ComboBox Grid.Column="0"
                          ItemsSource="{Binding AvailableFonts}"
                          SelectedItem="{Binding TerminalFontFamily}" />
                <NumericUpDown Grid.Column="1"
                               Value="{Binding TerminalFontSize}"
                               Minimum="8"
                               Maximum="72"
                               Increment="1" />
            </Grid>
        </StackPanel>

        <!-- Theme -->
        <StackPanel>
            <TextBlock Text="Color Theme" FontWeight="Medium" Margin="0,0,0,4" />
            <ComboBox ItemsSource="{Binding TerminalThemes}"
                      SelectedItem="{Binding TerminalTheme}"
                      HorizontalAlignment="Stretch" />
        </StackPanel>

        <!-- Cursor -->
        <StackPanel>
            <TextBlock Text="Cursor" FontWeight="Medium" Margin="0,0,0,4" />
            <Grid ColumnDefinitions="*,*" ColumnSpacing="8">
                <ComboBox Grid.Column="0"
                          ItemsSource="{Binding CursorStyles}"
                          SelectedItem="{Binding TerminalCursorStyle}" />
                <CheckBox Grid.Column="1"
                          Content="Blink"
                          IsChecked="{Binding TerminalCursorBlink}" />
            </Grid>
        </StackPanel>

        <!-- Scrollback -->
        <StackPanel>
            <TextBlock Text="Scrollback Lines" FontWeight="Medium" Margin="0,0,0,4" />
            <NumericUpDown Value="{Binding TerminalScrollbackLines}"
                           Minimum="1000"
                           Maximum="100000"
                           Increment="1000" />
        </StackPanel>

        <!-- Directory Sync -->
        <StackPanel>
            <TextBlock Text="Directory Synchronization" FontWeight="Medium" Margin="0,0,0,4" />
            <CheckBox Content="Sync terminal with file explorer"
                      IsChecked="{Binding SyncTerminalWithWorkspace}" />
            <ComboBox ItemsSource="{Binding DirectorySyncModes}"
                      SelectedItem="{Binding TerminalSyncMode}"
                      IsEnabled="{Binding SyncTerminalWithWorkspace}"
                      Margin="24,4,0,0" />
        </StackPanel>

        <!-- Keyboard Shortcuts -->
        <StackPanel>
            <TextBlock Text="Keyboard Shortcuts" FontWeight="Medium" Margin="0,0,0,4" />
            <Grid ColumnDefinitions="*,Auto" RowDefinitions="Auto,Auto" RowSpacing="4">
                <TextBlock Grid.Row="0" Grid.Column="0" Text="Toggle Terminal" VerticalAlignment="Center" />
                <TextBox Grid.Row="0" Grid.Column="1" Text="{Binding TerminalToggleShortcut}" Width="150" />

                <TextBlock Grid.Row="1" Grid.Column="0" Text="New Terminal" VerticalAlignment="Center" />
                <TextBox Grid.Row="1" Grid.Column="1" Text="{Binding TerminalNewShortcut}" Width="150" />
            </Grid>
        </StackPanel>

        <!-- Manage Profiles Button -->
        <Button Content="Manage Profiles..."
                Command="{Binding OpenProfileManagerCommand}"
                HorizontalAlignment="Left" />
    </StackPanel>
</Expander>
```

### v0.5.3f Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/ViewModels/ShellSelectorViewModel.cs` | Shell selector ViewModel |
| `src/SeniorIntern.Desktop/Views/ShellSelectorView.axaml` | Shell selector UI |
| `src/SeniorIntern.Desktop/Views/ShellSelectorView.axaml.cs` | Shell selector code-behind |
| `src/SeniorIntern.Desktop/Messages/ShowTerminalPanelMessage.cs` | Messenger message |

### v0.5.3f Files to Modify

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/ViewModels/FileExplorerViewModel.cs` | Add terminal commands |
| `src/SeniorIntern.Desktop/Views/FileExplorerView.axaml` | Add context menu items |
| `src/SeniorIntern.Desktop/ViewModels/SettingsViewModel.cs` | Add terminal settings |
| `src/SeniorIntern.Desktop/Views/SettingsView.axaml` | Add terminal settings UI |
| `src/SeniorIntern.Desktop/Assets/Icons.axaml` | Add terminal icon |

### v0.5.3f Verification

```bash
# Verify UI builds
dotnet build src/SeniorIntern.Desktop

# Manual testing checklist:
# - Right-click folder in file explorer
# - Click "Open in Integrated Terminal"
# - Verify terminal opens at correct path
# - Verify shell selector shows available profiles
# - Verify settings panel shows terminal options
```

### v0.5.3f Acceptance Criteria

- [ ] "Open in Terminal" context menu appears for directories
- [ ] Context menu shows available shell profiles
- [ ] Shell selector dialog displays correctly
- [ ] New profiles can be created from selector
- [ ] Terminal settings section is complete
- [ ] Settings changes are persisted
- [ ] Keyboard shortcuts are configurable

---

## Testing Strategy

### Unit Tests

| Test Class | Coverage |
|------------|----------|
| `ShellDetectionServiceTests` | Cross-platform shell discovery, PATH searching |
| `ShellConfigurationServiceTests` | Configuration retrieval, command formatting |
| `ShellProfileServiceTests` | CRUD operations, persistence, defaults |
| `WorkingDirectorySyncServiceTests` | OSC 7 parsing, sync behavior |

### Integration Tests

| Test Class | Coverage |
|------------|----------|
| `ShellIntegrationTests` | Full shell lifecycle with directory sync |
| `ProfilePersistenceTests` | Save/load across application restarts |

### Test Cases

```csharp
namespace SeniorIntern.Tests.Services.Terminal;

public class ShellDetectionServiceTests
{
    [Fact]
    public async Task GetDefaultShell_ReturnsValidPath()
    {
        // Arrange
        var service = new ShellDetectionService(NullLogger<ShellDetectionService>.Instance);

        // Act
        var shell = await service.GetDefaultShellAsync();

        // Assert
        Assert.NotNull(shell);
        Assert.True(File.Exists(shell));
    }

    [Theory]
    [InlineData("/bin/bash", ShellType.Bash)]
    [InlineData("/bin/zsh", ShellType.Zsh)]
    [InlineData("C:\\Windows\\System32\\cmd.exe", ShellType.Cmd)]
    [InlineData("pwsh", ShellType.PowerShell)]
    public void DetectShellType_ReturnsCorrectType(string path, ShellType expected)
    {
        // Arrange
        var service = new ShellDetectionService(NullLogger<ShellDetectionService>.Instance);

        // Act
        var result = service.DetectShellType(path);

        // Assert
        Assert.Equal(expected, result);
    }

    [Fact]
    public async Task GetAvailableShells_ReturnsAtLeastOne()
    {
        // Arrange
        var service = new ShellDetectionService(NullLogger<ShellDetectionService>.Instance);

        // Act
        var shells = await service.GetAvailableShellsAsync();

        // Assert
        Assert.NotEmpty(shells);
        Assert.All(shells, s => Assert.True(File.Exists(s.Path) || s.Type == ShellType.Wsl));
    }
}

public class WorkingDirectorySyncServiceTests
{
    [Theory]
    [InlineData("file://localhost/home/user/project", "/home/user/project")]
    [InlineData("file://MacBook.local/Users/dev/code", "/Users/dev/code")]
    [InlineData("file://hostname/mnt/c/Users/dev", "C:\\Users\\dev")] // WSL path (Windows only)
    public void ProcessOsc7_ParsesUriCorrectly(string uri, string expectedPath)
    {
        // Test OSC 7 URI parsing
    }

    [Fact]
    public void ProcessOsc7_RaisesDirectoryChangedEvent()
    {
        // Test event is raised with correct data
    }

    [Fact]
    public void AutoSync_RespectsUserSettings()
    {
        // Test sync behavior based on settings
    }
}
```

---

## Files Summary

### Files to Create (v0.5.3)

| Part | File | Purpose |
|------|------|---------|
| a | `src/SeniorIntern.Core/Interfaces/IShellDetectionService.cs` | Shell detection interface |
| a | `src/SeniorIntern.Core/Models/Terminal/ShellInfo.cs` | Shell info model |
| a | `src/SeniorIntern.Core/Models/Terminal/ShellType.cs` | Shell type enum |
| a | `src/SeniorIntern.Services/Terminal/ShellDetectionService.cs` | Detection implementation |
| b | `src/SeniorIntern.Core/Models/Terminal/ShellConfiguration.cs` | Shell config model |
| b | `src/SeniorIntern.Core/Interfaces/IShellConfigurationService.cs` | Config service interface |
| b | `src/SeniorIntern.Services/Terminal/ShellConfigurationService.cs` | Config implementation |
| c | `src/SeniorIntern.Core/Models/Terminal/ShellProfile.cs` | Profile model |
| c | `src/SeniorIntern.Core/Models/Terminal/ProfileCloseOnExit.cs` | Close behavior enum |
| c | `src/SeniorIntern.Core/Models/Terminal/TerminalCursorStyle.cs` | Cursor style enum |
| c | `src/SeniorIntern.Core/Models/Terminal/TerminalBellStyle.cs` | Bell style enum |
| c | `src/SeniorIntern.Core/Models/Terminal/ShellProfileDefaults.cs` | Default values |
| c | `src/SeniorIntern.Core/Models/Terminal/DirectorySyncMode.cs` | Sync mode enum |
| d | `src/SeniorIntern.Core/Interfaces/IShellProfileService.cs` | Profile service interface |
| d | `src/SeniorIntern.Core/Models/Terminal/ProfilesChangedEventArgs.cs` | Event args |
| d | `src/SeniorIntern.Services/Terminal/ShellProfileService.cs` | Profile service |
| e | `src/SeniorIntern.Core/Interfaces/IWorkingDirectorySyncService.cs` | Sync service interface |
| e | `src/SeniorIntern.Core/Models/Terminal/DirectoryChangedEventArgs.cs` | Event args |
| e | `src/SeniorIntern.Core/Models/Terminal/DirectoryChangeSource.cs` | Change source enum |
| e | `src/SeniorIntern.Services/Terminal/WorkingDirectorySyncService.cs` | Sync implementation |
| f | `src/SeniorIntern.Desktop/ViewModels/ShellSelectorViewModel.cs` | Shell selector VM |
| f | `src/SeniorIntern.Desktop/Views/ShellSelectorView.axaml` | Shell selector UI |
| f | `src/SeniorIntern.Desktop/Views/ShellSelectorView.axaml.cs` | Code-behind |
| f | `src/SeniorIntern.Desktop/Messages/ShowTerminalPanelMessage.cs` | Messenger message |

**Total: 24 files to create**

### Files to Modify (v0.5.3)

| Part | File | Changes |
|------|------|---------|
| a | `src/SeniorIntern.Services/DependencyInjection.cs` | Register IShellDetectionService |
| b | `src/SeniorIntern.Services/DependencyInjection.cs` | Register IShellConfigurationService |
| c | `src/SeniorIntern.Core/Models/AppSettings.cs` | Add terminal settings |
| d | `src/SeniorIntern.Services/DependencyInjection.cs` | Register IShellProfileService |
| e | `src/SeniorIntern.Core/Terminal/AnsiParser.cs` | Add OSC 7 handling |
| e | `src/SeniorIntern.Services/Terminal/TerminalService.cs` | Wire sync service |
| e | `src/SeniorIntern.Services/DependencyInjection.cs` | Register IWorkingDirectorySyncService |
| f | `src/SeniorIntern.Desktop/ViewModels/FileExplorerViewModel.cs` | Add terminal commands |
| f | `src/SeniorIntern.Desktop/Views/FileExplorerView.axaml` | Add context menu |
| f | `src/SeniorIntern.Desktop/ViewModels/SettingsViewModel.cs` | Add terminal settings |
| f | `src/SeniorIntern.Desktop/Views/SettingsView.axaml` | Add settings UI |
| f | `src/SeniorIntern.Desktop/Assets/Icons.axaml` | Add terminal icon |

**Total: 12 files to modify**

---

## Dependencies

### Internal Dependencies

| v0.5.3 Part | Depends On |
|-------------|------------|
| v0.5.3b | v0.5.3a (ShellDetectionService for shell type detection) |
| v0.5.3c | v0.5.3b (ShellConfiguration for defaults) |
| v0.5.3d | v0.5.3a, v0.5.3c (Detection + Profile models) |
| v0.5.3e | v0.5.3b, v0.5.3d, v0.5.1 (Config, Profiles, TerminalService, AnsiParser) |
| v0.5.3f | v0.5.3d, v0.5.3e, v0.5.2 (Profiles, Sync, Terminal UI) |

### External Dependencies (from v0.5.1/v0.5.2)

- Pty.Net (v0.5.1)
- SkiaSharp (v0.5.2)
- CommunityToolkit.Mvvm (existing)

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Shell detection fails on unusual systems | Medium | Low | Provide manual profile creation fallback |
| OSC 7 not supported by user's shell | Medium | Medium | Implement fallback PWD polling |
| Profile corruption on disk | Low | Medium | Implement validation and auto-repair |
| WSL path translation errors | Medium | Low | Comprehensive path normalization |
| Settings migration from older versions | Medium | Medium | Version-aware settings loader |

---

## Acceptance Criteria

### v0.5.3 Complete

- [ ] Shell detection works correctly on Windows, macOS, and Linux
- [ ] All common shells are detected (bash, zsh, fish, PowerShell, cmd)
- [ ] Shell profiles can be created, edited, and deleted
- [ ] Default profile can be set and persists
- [ ] Profile settings are saved to disk
- [ ] Working directory sync works bi-directionally
- [ ] OSC 7 escape sequences update directory state
- [ ] "Open in Terminal" context menu works
- [ ] Shell selector dialog displays all available profiles
- [ ] Terminal settings section is complete in settings panel
- [ ] Settings changes take effect immediately
- [ ] All unit tests pass
- [ ] Cross-platform manual testing complete
