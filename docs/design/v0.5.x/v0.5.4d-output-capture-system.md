# Design Specification: AIntern v0.5.4d "Output Capture System"

## Overview

**Version**: v0.5.4d
**Parent**: v0.5.4 Command Integration
**Focus**: Terminal output capture, ANSI stripping, truncation, capture history

### Purpose

This sub-version creates a system for capturing terminal output for AI context:
1. Stream-based capture during command execution (StartCapture/StopCapture)
2. On-demand full buffer capture
3. Last N lines capture for recent output
4. Selection-based capture from user-selected text
5. ANSI escape sequence stripping for clean text
6. Intelligent truncation with configurable modes
7. Capture history with automatic pruning

### Dependencies

**From v0.5.4a (Command Block Models)**:
- `TerminalOutputCapture` - Capture result model
- `OutputCaptureMode` - Capture mode enumeration

**From v0.5.1 (Terminal Foundation)**:
- `ITerminalService` - Terminal session and buffer access
- `TerminalBuffer` - Buffer content retrieval

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                   v0.5.4d Output Capture System Architecture                  │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                        Interface Layer                                   │ │
│  │  src/AIntern.Core/Interfaces/                                           │ │
│  ├─────────────────────────────────────────────────────────────────────────┤ │
│  │  IOutputCaptureService                                                   │ │
│  │  ├── Stream Capture:                                                    │ │
│  │  │   ├── StartCapture(sessionId, commandContext?)                       │ │
│  │  │   └── StopCaptureAsync(sessionId) → TerminalOutputCapture?           │ │
│  │  ├── Buffer Capture:                                                    │ │
│  │  │   ├── CaptureBufferAsync(sessionId, mode, lineCount?)                │ │
│  │  │   └── CaptureSelectionAsync(sessionId)                               │ │
│  │  ├── History:                                                           │ │
│  │  │   ├── GetRecentCaptures(sessionId, count)                            │ │
│  │  │   └── GetCapture(captureId)                                          │ │
│  │  └── Configuration:                                                     │ │
│  │      └── Configure(OutputCaptureSettings)                               │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                        Model Layer                                       │ │
│  │  src/AIntern.Core/Models/Terminal/                                      │ │
│  ├─────────────────────────────────────────────────────────────────────────┤ │
│  │                                                                          │ │
│  │  OutputCaptureSettings                  TruncationMode (enum)           │ │
│  │  ├── MaxCaptureLength: int (8000)       ├── KeepStart                   │ │
│  │  ├── MaxCaptureLines: int (500)         ├── KeepEnd                     │ │
│  │  ├── TruncationMode: TruncationMode     └── KeepBoth                    │ │
│  │  ├── StripAnsiSequences: bool (true)                                    │ │
│  │  ├── NormalizeLineEndings: bool (true)                                  │ │
│  │  └── CaptureHistorySize: int (20)                                       │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                     Implementation Layer                                 │ │
│  │  src/AIntern.Services/Terminal/                                         │ │
│  ├─────────────────────────────────────────────────────────────────────────┤ │
│  │  OutputCaptureService : IOutputCaptureService                            │ │
│  │  ├── Dependencies:                                                      │ │
│  │  │   ├── ITerminalService                                               │ │
│  │  │   └── ILogger<OutputCaptureService>                                  │ │
│  │  ├── State:                                                             │ │
│  │  │   ├── _activeCaptures: ConcurrentDictionary<Guid, CaptureContext>   │ │
│  │  │   ├── _captureHistory: ConcurrentDictionary<Guid, TerminalOutputCapture> │
│  │  │   └── _sessionCaptureHistory: ConcurrentDictionary<Guid, Queue<Guid>>│ │
│  │  ├── Event Subscription:                                                │ │
│  │  │   └── ITerminalService.OutputReceived → OnOutputReceived()          │ │
│  │  ├── Regex:                                                             │ │
│  │  │   └── AnsiEscapePattern() [GeneratedRegex]                          │ │
│  │  └── Helper Classes:                                                    │ │
│  │      └── CaptureContext { SessionId, CommandContext, StartedAt, Buffer }│ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Capture Flow Diagrams

### Stream Capture Flow (During Execution)

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                      Stream Capture Flow                                      │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Command Execution (v0.5.4c)                    Output Capture (v0.5.4d)    │
│  ────────────────────────                       ─────────────────────────    │
│                                                                              │
│  ┌──────────────────────┐                                                   │
│  │ ExecuteAsync() begins│                                                   │
│  └──────────┬───────────┘                                                   │
│             │                                                                │
│             ▼                                                                │
│  ┌──────────────────────┐      ┌─────────────────────────────────────────┐  │
│  │ StartCapture(        │ ───▶ │ Create CaptureContext                   │  │
│  │   sessionId,         │      │ ├── SessionId = sessionId               │  │
│  │   command.Command)   │      │ ├── CommandContext = command            │  │
│  └──────────────────────┘      │ ├── StartedAt = DateTime.UtcNow         │  │
│                                │ └── Buffer = new StringBuilder()        │  │
│                                │ Store in _activeCaptures[sessionId]     │  │
│                                └─────────────────────────────────────────┘  │
│             │                                                                │
│             ▼                                                                │
│  ┌──────────────────────┐                                                   │
│  │ WriteInputAsync(     │                                                   │
│  │   command + "\r")    │                                                   │
│  └──────────────────────┘                                                   │
│             │                                                                │
│             │      ┌───────────────────────────────────────────────────┐    │
│             │◀────▶│ Terminal Output Arrives                          │    │
│             │      │ ─────────────────────────────────────────────────  │    │
│             │      │ OnOutputReceived(sessionId, data)                 │    │
│             │      │   if _activeCaptures.TryGetValue(sessionId, ctx)  │    │
│             │      │     ctx.Buffer.Append(data)                       │    │
│             │      │   (accumulates all output during execution)       │    │
│             │      └───────────────────────────────────────────────────┘    │
│             │                                                                │
│             ▼                                                                │
│  ┌──────────────────────┐      ┌─────────────────────────────────────────┐  │
│  │ StopCaptureAsync(    │ ───▶ │ Remove from _activeCaptures             │  │
│  │   sessionId)         │      │ Process output:                         │  │
│  └──────────────────────┘      │ ├── Strip ANSI sequences                │  │
│                                │ ├── Normalize line endings              │  │
│                                │ └── Truncate if needed                  │  │
│                                │ Create TerminalOutputCapture            │  │
│                                │ Add to _captureHistory                  │  │
│                                │ Return capture                          │  │
│                                └─────────────────────────────────────────┘  │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

### Buffer Capture Flow (On-Demand)

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                      Buffer Capture Flow                                      │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  CaptureBufferAsync(sessionId, mode, lineCount?)                             │
│                                                                              │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  STEP 1: Get buffer from terminal service                             │  │
│  │  ─────────────────────────────────────────────────────────────────────│  │
│  │  buffer = _terminalService.GetBuffer(sessionId)                       │  │
│  │  session = _terminalService.GetSession(sessionId)                     │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                           │                                                  │
│                           ▼                                                  │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  STEP 2: Extract content based on mode                                │  │
│  │  ─────────────────────────────────────────────────────────────────────│  │
│  │                                                                        │  │
│  │  switch (mode):                                                        │  │
│  │  ┌─────────────────┬─────────────────────────────────────────────────┐ │  │
│  │  │ FullBuffer      │ output = buffer.GetText()                       │ │  │
│  │  ├─────────────────┼─────────────────────────────────────────────────┤ │  │
│  │  │ LastNLines      │ output = buffer.GetLastLines(lineCount ?? 50)   │ │  │
│  │  ├─────────────────┼─────────────────────────────────────────────────┤ │  │
│  │  │ Selection       │ output = buffer.GetSelectedText() ?? ""         │ │  │
│  │  └─────────────────┴─────────────────────────────────────────────────┘ │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                           │                                                  │
│                           ▼                                                  │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  STEP 3: Process output                                               │  │
│  │  ─────────────────────────────────────────────────────────────────────│  │
│  │  output = ProcessOutput(output)                                       │  │
│  │    → Strip ANSI (if configured)                                      │  │
│  │    → Normalize line endings (if configured)                          │  │
│  │    → Truncate (if exceeds limits)                                    │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                           │                                                  │
│                           ▼                                                  │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  STEP 4: Create capture and add to history                           │  │
│  │  ─────────────────────────────────────────────────────────────────────│  │
│  │  capture = CreateCapture(sessionId, null, output, now, mode, dir)     │  │
│  │  AddToCaptureHistory(sessionId, capture)                              │  │
│  │  return capture                                                       │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Truncation Strategies

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                       Truncation Strategy Comparison                          │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Settings: MaxCaptureLength = 8000 chars, MaxCaptureLines = 500 lines        │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  TruncationMode.KeepStart                                               │ │
│  │  ───────────────────────────────────────────────────────────────────────│ │
│  │  Use case: Initial setup, error context at start                        │ │
│  │                                                                          │ │
│  │  Original:  [=====START==============================END=====]          │ │
│  │  Truncated: [=====START==========]...(truncated)                        │ │
│  │                                                                          │ │
│  │  Implementation:                                                         │ │
│  │    lines.Take(MaxCaptureLines) OR output[..MaxCaptureLength]            │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  TruncationMode.KeepEnd (Default)                                       │ │
│  │  ───────────────────────────────────────────────────────────────────────│ │
│  │  Use case: Recent errors, current state (most common)                   │ │
│  │                                                                          │ │
│  │  Original:  [=====START==============================END=====]          │ │
│  │  Truncated:              ...(truncated)[==========END=====]             │ │
│  │                                                                          │ │
│  │  Implementation:                                                         │ │
│  │    lines.Skip(lines.Length - MaxCaptureLines) OR output[^MaxLength..]   │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  TruncationMode.KeepBoth                                                │ │
│  │  ───────────────────────────────────────────────────────────────────────│ │
│  │  Use case: Need context from start and recent output                    │ │
│  │                                                                          │ │
│  │  Original:  [=====START==============================END=====]          │ │
│  │  Truncated: [==START==]...(truncated)...[==END==]                       │ │
│  │                                                                          │ │
│  │  Implementation:                                                         │ │
│  │    Keep first 50% of limit + "...(truncated)..." + last 50% of limit    │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## ANSI Escape Sequence Stripping

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                     ANSI Escape Sequence Handling                             │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Regex Pattern: \x1B\[[0-9;]*[a-zA-Z]|\x1B\].*?(?:\x07|\x1B\\)               │
│                                                                              │
│  Matches:                                                                    │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  \x1B\[[0-9;]*[a-zA-Z]                                                  │ │
│  │  ───────────────────────────────────────────────────────────────────────│ │
│  │  CSI (Control Sequence Introducer) sequences                            │ │
│  │  Examples:                                                               │ │
│  │  • \x1B[31m     → Red foreground color                                  │ │
│  │  • \x1B[1;34m   → Bold + Blue                                           │ │
│  │  • \x1B[0m      → Reset all attributes                                  │ │
│  │  • \x1B[2J      → Clear screen                                          │ │
│  │  • \x1B[10;20H  → Move cursor to row 10, column 20                      │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  \x1B\].*?(?:\x07|\x1B\\)                                               │ │
│  │  ───────────────────────────────────────────────────────────────────────│ │
│  │  OSC (Operating System Command) sequences                               │ │
│  │  Examples:                                                               │ │
│  │  • \x1B]0;Title\x07         → Set window title                          │ │
│  │  • \x1B]7;file://path\x07   → Set working directory (OSC 7)             │ │
│  │  • \x1B]133;A\x07           → Shell integration markers                 │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  Before stripping:                                                           │
│  "→ \x1B[32mSuccess:\x1B[0m Build completed in \x1B[1m2.3s\x1B[0m"          │
│                                                                              │
│  After stripping:                                                            │
│  "→ Success: Build completed in 2.3s"                                       │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Specifications

### 1. TruncationMode.cs

**Location**: `src/AIntern.Core/Models/Terminal/TruncationMode.cs`

```csharp
namespace AIntern.Core.Models.Terminal;

/// <summary>
/// How to truncate captured output when it exceeds limits.
/// </summary>
public enum TruncationMode
{
    /// <summary>Keep the beginning of output, truncate the end.</summary>
    KeepStart,

    /// <summary>Keep the end of output, truncate the beginning.</summary>
    KeepEnd,

    /// <summary>Keep both start and end, truncate the middle.</summary>
    KeepBoth
}

/// <summary>
/// Extension methods for TruncationMode.
/// </summary>
public static class TruncationModeExtensions
{
    /// <summary>Get the truncation indicator text.</summary>
    public static string GetIndicator(this TruncationMode mode) => mode switch
    {
        TruncationMode.KeepStart => "\n...(truncated)",
        TruncationMode.KeepEnd => "...(truncated)\n",
        TruncationMode.KeepBoth => "\n...(truncated)...\n",
        _ => "\n...(truncated)"
    };

    /// <summary>Get a user-friendly description.</summary>
    public static string ToDescription(this TruncationMode mode) => mode switch
    {
        TruncationMode.KeepStart => "Keep beginning, truncate end",
        TruncationMode.KeepEnd => "Keep end, truncate beginning",
        TruncationMode.KeepBoth => "Keep beginning and end, truncate middle",
        _ => mode.ToString()
    };
}
```

### 2. OutputCaptureSettings.cs

**Location**: `src/AIntern.Core/Models/Terminal/OutputCaptureSettings.cs`

```csharp
namespace AIntern.Core.Models.Terminal;

/// <summary>
/// Settings for terminal output capture.
/// </summary>
public sealed class OutputCaptureSettings
{
    /// <summary>Maximum characters to capture before truncation.</summary>
    public int MaxCaptureLength { get; set; } = 8000;

    /// <summary>Maximum lines to capture before truncation.</summary>
    public int MaxCaptureLines { get; set; } = 500;

    /// <summary>How to truncate when limits are exceeded.</summary>
    public TruncationMode TruncationMode { get; set; } = TruncationMode.KeepEnd;

    /// <summary>Whether to strip ANSI escape sequences from output.</summary>
    public bool StripAnsiSequences { get; set; } = true;

    /// <summary>Whether to normalize line endings to \n.</summary>
    public bool NormalizeLineEndings { get; set; } = true;

    /// <summary>Number of recent captures to retain per session.</summary>
    public int CaptureHistorySize { get; set; } = 20;

    // === Factory Methods ===

    /// <summary>Settings optimized for AI context (smaller, cleaner).</summary>
    public static OutputCaptureSettings ForAIContext() => new()
    {
        MaxCaptureLength = 4000,
        MaxCaptureLines = 200,
        TruncationMode = TruncationMode.KeepEnd,
        StripAnsiSequences = true,
        NormalizeLineEndings = true,
        CaptureHistorySize = 10
    };

    /// <summary>Settings for full capture (larger limits).</summary>
    public static OutputCaptureSettings ForFullCapture() => new()
    {
        MaxCaptureLength = 50000,
        MaxCaptureLines = 2000,
        TruncationMode = TruncationMode.KeepBoth,
        StripAnsiSequences = true,
        NormalizeLineEndings = true,
        CaptureHistorySize = 50
    };

    /// <summary>Settings that preserve raw output.</summary>
    public static OutputCaptureSettings Raw() => new()
    {
        MaxCaptureLength = int.MaxValue,
        MaxCaptureLines = int.MaxValue,
        TruncationMode = TruncationMode.KeepEnd,
        StripAnsiSequences = false,
        NormalizeLineEndings = false,
        CaptureHistorySize = 5
    };
}
```

### 3. IOutputCaptureService.cs

**Location**: `src/AIntern.Core/Interfaces/IOutputCaptureService.cs`

```csharp
namespace AIntern.Core.Interfaces;

using AIntern.Core.Models.Terminal;

/// <summary>
/// Service for capturing terminal output for AI context.
/// </summary>
public interface IOutputCaptureService
{
    // === Stream Capture (during command execution) ===

    /// <summary>
    /// Start capturing output from a terminal session.
    /// Call this before executing a command to capture its output.
    /// </summary>
    /// <param name="sessionId">The session to capture from.</param>
    /// <param name="commandContext">Optional command text for context.</param>
    void StartCapture(Guid sessionId, string? commandContext = null);

    /// <summary>
    /// Stop capturing and return the accumulated output.
    /// </summary>
    /// <param name="sessionId">The session to stop capturing.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>Captured output, or null if no capture was active.</returns>
    Task<TerminalOutputCapture?> StopCaptureAsync(Guid sessionId, CancellationToken ct = default);

    // === Buffer Capture (on-demand) ===

    /// <summary>
    /// Capture the current terminal buffer content.
    /// </summary>
    /// <param name="sessionId">The session to capture from.</param>
    /// <param name="mode">Capture mode (full buffer, last N lines, etc.).</param>
    /// <param name="lineCount">Number of lines for LastNLines mode.</param>
    /// <param name="ct">Cancellation token.</param>
    Task<TerminalOutputCapture> CaptureBufferAsync(
        Guid sessionId,
        OutputCaptureMode mode = OutputCaptureMode.FullBuffer,
        int? lineCount = null,
        CancellationToken ct = default);

    /// <summary>
    /// Capture user-selected text from the terminal.
    /// </summary>
    /// <param name="sessionId">The session to capture from.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>Captured selection, or null if nothing is selected.</returns>
    Task<TerminalOutputCapture?> CaptureSelectionAsync(
        Guid sessionId,
        CancellationToken ct = default);

    // === History ===

    /// <summary>
    /// Get recent captures for a session.
    /// </summary>
    /// <param name="sessionId">The session to get captures for.</param>
    /// <param name="count">Maximum number of captures to return.</param>
    IReadOnlyList<TerminalOutputCapture> GetRecentCaptures(Guid sessionId, int count = 10);

    /// <summary>
    /// Get a specific capture by its ID.
    /// </summary>
    /// <param name="captureId">The capture ID.</param>
    TerminalOutputCapture? GetCapture(Guid captureId);

    // === Configuration ===

    /// <summary>
    /// Configure capture settings.
    /// </summary>
    /// <param name="settings">New settings to apply.</param>
    void Configure(OutputCaptureSettings settings);
}
```

### 4. OutputCaptureService.cs

**Location**: `src/AIntern.Services/Terminal/OutputCaptureService.cs`

```csharp
namespace AIntern.Services.Terminal;

using System.Collections.Concurrent;
using System.Text;
using System.Text.RegularExpressions;
using Microsoft.Extensions.Logging;
using AIntern.Core.Interfaces;
using AIntern.Core.Models.Terminal;

/// <summary>
/// Captures terminal output for AI context.
/// </summary>
public sealed partial class OutputCaptureService : IOutputCaptureService
{
    private readonly ITerminalService _terminalService;
    private readonly ILogger<OutputCaptureService> _logger;

    private readonly ConcurrentDictionary<Guid, CaptureContext> _activeCaptures = new();
    private readonly ConcurrentDictionary<Guid, TerminalOutputCapture> _captureHistory = new();
    private readonly ConcurrentDictionary<Guid, Queue<Guid>> _sessionCaptureHistory = new();

    private OutputCaptureSettings _settings = new();

    /// <summary>
    /// Regex to strip ANSI escape sequences (CSI and OSC sequences).
    /// </summary>
    [GeneratedRegex(@"\x1B\[[0-9;]*[a-zA-Z]|\x1B\].*?(?:\x07|\x1B\\)", RegexOptions.Compiled)]
    private static partial Regex AnsiEscapePattern();

    public OutputCaptureService(
        ITerminalService terminalService,
        ILogger<OutputCaptureService> logger)
    {
        _terminalService = terminalService;
        _logger = logger;

        // Subscribe to terminal output for stream capture
        _terminalService.OutputReceived += OnOutputReceived;
    }

    public void Configure(OutputCaptureSettings settings)
    {
        _settings = settings ?? throw new ArgumentNullException(nameof(settings));
        _logger.LogDebug("Output capture configured: MaxLength={Length}, MaxLines={Lines}, Mode={Mode}",
            settings.MaxCaptureLength, settings.MaxCaptureLines, settings.TruncationMode);
    }

    // === Stream Capture ===

    public void StartCapture(Guid sessionId, string? commandContext = null)
    {
        var context = new CaptureContext
        {
            SessionId = sessionId,
            CommandContext = commandContext,
            StartedAt = DateTime.UtcNow,
            Buffer = new StringBuilder()
        };

        _activeCaptures[sessionId] = context;
        _logger.LogDebug("Started capture for session {Session}, command: {Command}",
            sessionId, commandContext?.Substring(0, Math.Min(50, commandContext?.Length ?? 0)));
    }

    private void OnOutputReceived(object? sender, TerminalOutputEventArgs e)
    {
        if (_activeCaptures.TryGetValue(e.SessionId, out var context))
        {
            context.Buffer.Append(e.Data);
        }
    }

    public Task<TerminalOutputCapture?> StopCaptureAsync(Guid sessionId, CancellationToken ct = default)
    {
        if (!_activeCaptures.TryRemove(sessionId, out var context))
        {
            _logger.LogDebug("No active capture to stop for session {Session}", sessionId);
            return Task.FromResult<TerminalOutputCapture?>(null);
        }

        var rawOutput = context.Buffer.ToString();
        var processedOutput = ProcessOutput(rawOutput);

        var capture = CreateCapture(
            sessionId: sessionId,
            command: context.CommandContext,
            output: processedOutput,
            startedAt: context.StartedAt,
            mode: OutputCaptureMode.LastCommand,
            originalLength: rawOutput.Length);

        AddToCaptureHistory(sessionId, capture);

        _logger.LogDebug("Stopped capture for session {Session}: {Length} chars (original: {Original})",
            sessionId, capture.Output.Length, rawOutput.Length);

        return Task.FromResult<TerminalOutputCapture?>(capture);
    }

    // === Buffer Capture ===

    public async Task<TerminalOutputCapture> CaptureBufferAsync(
        Guid sessionId,
        OutputCaptureMode mode = OutputCaptureMode.FullBuffer,
        int? lineCount = null,
        CancellationToken ct = default)
    {
        var buffer = _terminalService.GetBuffer(sessionId);
        var session = _terminalService.GetSession(sessionId);

        // Extract content based on mode
        string rawOutput = mode switch
        {
            OutputCaptureMode.FullBuffer => buffer.GetText(),
            OutputCaptureMode.LastNLines => buffer.GetLastLines(lineCount ?? 50),
            OutputCaptureMode.Selection => buffer.GetSelectedText() ?? string.Empty,
            _ => buffer.GetText()
        };

        var processedOutput = ProcessOutput(rawOutput);

        var capture = CreateCapture(
            sessionId: sessionId,
            command: null,
            output: processedOutput,
            startedAt: DateTime.UtcNow,
            mode: mode,
            workingDirectory: session?.WorkingDirectory,
            originalLength: rawOutput.Length);

        AddToCaptureHistory(sessionId, capture);

        _logger.LogDebug("Captured {Mode} for session {Session}: {Length} chars",
            mode, sessionId, capture.Output.Length);

        return capture;
    }

    public async Task<TerminalOutputCapture?> CaptureSelectionAsync(
        Guid sessionId,
        CancellationToken ct = default)
    {
        var buffer = _terminalService.GetBuffer(sessionId);
        var selectedText = buffer.GetSelectedText();

        if (string.IsNullOrEmpty(selectedText))
        {
            _logger.LogDebug("No selection to capture for session {Session}", sessionId);
            return null;
        }

        var processedOutput = ProcessOutput(selectedText);
        var session = _terminalService.GetSession(sessionId);

        var capture = CreateCapture(
            sessionId: sessionId,
            command: null,
            output: processedOutput,
            startedAt: DateTime.UtcNow,
            mode: OutputCaptureMode.Selection,
            workingDirectory: session?.WorkingDirectory,
            originalLength: selectedText.Length);

        AddToCaptureHistory(sessionId, capture);

        _logger.LogDebug("Captured selection for session {Session}: {Length} chars",
            sessionId, capture.Output.Length);

        return capture;
    }

    // === History ===

    public IReadOnlyList<TerminalOutputCapture> GetRecentCaptures(Guid sessionId, int count = 10)
    {
        if (!_sessionCaptureHistory.TryGetValue(sessionId, out var queue))
        {
            return Array.Empty<TerminalOutputCapture>();
        }

        return queue
            .Take(count)
            .Select(id => _captureHistory.GetValueOrDefault(id))
            .Where(c => c != null)
            .Cast<TerminalOutputCapture>()
            .ToList()
            .AsReadOnly();
    }

    public TerminalOutputCapture? GetCapture(Guid captureId)
    {
        return _captureHistory.GetValueOrDefault(captureId);
    }

    // === Output Processing ===

    private string ProcessOutput(string output)
    {
        if (string.IsNullOrEmpty(output))
            return string.Empty;

        // Strip ANSI sequences if configured
        if (_settings.StripAnsiSequences)
        {
            output = AnsiEscapePattern().Replace(output, "");
        }

        // Normalize line endings if configured
        if (_settings.NormalizeLineEndings)
        {
            output = output.Replace("\r\n", "\n").Replace("\r", "\n");
        }

        // Truncate if needed
        output = TruncateOutput(output);

        return output.Trim();
    }

    private string TruncateOutput(string output)
    {
        var isTruncated = false;

        // Check line limit
        var lines = output.Split('\n');
        if (lines.Length > _settings.MaxCaptureLines)
        {
            isTruncated = true;
            lines = _settings.TruncationMode switch
            {
                TruncationMode.KeepStart => lines.Take(_settings.MaxCaptureLines).ToArray(),
                TruncationMode.KeepEnd => lines.Skip(lines.Length - _settings.MaxCaptureLines).ToArray(),
                TruncationMode.KeepBoth => KeepBothEnds(lines, _settings.MaxCaptureLines),
                _ => lines.Take(_settings.MaxCaptureLines).ToArray()
            };
            output = string.Join('\n', lines);
        }

        // Check character limit
        if (output.Length > _settings.MaxCaptureLength)
        {
            isTruncated = true;
            var max = _settings.MaxCaptureLength;
            output = _settings.TruncationMode switch
            {
                TruncationMode.KeepStart => output[..max] + "\n...(truncated)",
                TruncationMode.KeepEnd => "...(truncated)\n" + output[^max..],
                TruncationMode.KeepBoth => output[..(max / 2)] + "\n...(truncated)...\n" + output[^(max / 2)..],
                _ => output[..max] + "\n...(truncated)"
            };
        }

        return output;
    }

    private static string[] KeepBothEnds(string[] lines, int maxLines)
    {
        var keepCount = maxLines / 2;
        var start = lines.Take(keepCount);
        var end = lines.Skip(lines.Length - keepCount);
        return start.Concat(new[] { "...(truncated)..." }).Concat(end).ToArray();
    }

    // === Capture Creation ===

    private TerminalOutputCapture CreateCapture(
        Guid sessionId,
        string? command,
        string output,
        DateTime startedAt,
        OutputCaptureMode mode,
        string? workingDirectory = null,
        int? originalLength = null)
    {
        var session = _terminalService.GetSession(sessionId);

        return new TerminalOutputCapture
        {
            SessionId = sessionId,
            SessionName = session?.Name,
            Command = command,
            Output = output,
            IsTruncated = output.Contains("(truncated)"),
            OriginalLength = originalLength ?? output.Length,
            StartedAt = startedAt,
            CompletedAt = DateTime.UtcNow,
            WorkingDirectory = workingDirectory ?? session?.WorkingDirectory,
            CaptureMode = mode
        };
    }

    // === History Management ===

    private void AddToCaptureHistory(Guid sessionId, TerminalOutputCapture capture)
    {
        _captureHistory[capture.Id] = capture;

        var queue = _sessionCaptureHistory.GetOrAdd(sessionId, _ => new Queue<Guid>());
        queue.Enqueue(capture.Id);

        // Prune old captures
        while (queue.Count > _settings.CaptureHistorySize)
        {
            if (queue.TryDequeue(out var oldId))
            {
                _captureHistory.TryRemove(oldId, out _);
            }
        }
    }

    // === Helper Classes ===

    private sealed class CaptureContext
    {
        public Guid SessionId { get; init; }
        public string? CommandContext { get; init; }
        public DateTime StartedAt { get; init; }
        public StringBuilder Buffer { get; init; } = new();
    }
}
```

---

## File Summary

| File | Location | Purpose |
|------|----------|---------|
| `TruncationMode.cs` | `src/AIntern.Core/Models/Terminal/` | Truncation mode enum |
| `OutputCaptureSettings.cs` | `src/AIntern.Core/Models/Terminal/` | Capture settings model |
| `IOutputCaptureService.cs` | `src/AIntern.Core/Interfaces/` | Capture service interface |
| `OutputCaptureService.cs` | `src/AIntern.Services/Terminal/` | Full implementation |

### Files to Modify

| File | Changes |
|------|---------|
| `src/AIntern.Services/DependencyInjection.cs` | Register IOutputCaptureService as singleton |
| `src/AIntern.Core/Models/Terminal/TerminalBuffer.cs` | Add GetLastLines(), GetSelectedText() methods |

---

## Unit Test Plan

| Test | Description |
|------|-------------|
| `StartCapture_CreatesContext` | Context added to active captures |
| `StartCapture_WithCommand_StoresCommand` | Command context stored |
| `StopCapture_ReturnsOutput` | Accumulated output returned |
| `StopCapture_NoActiveCapture_ReturnsNull` | Returns null if not started |
| `StopCapture_RemovesFromActive` | Context removed after stop |
| `OnOutputReceived_AccumulatesData` | Buffer grows with each event |
| `CaptureBuffer_FullBuffer_ReturnsAll` | Entire buffer captured |
| `CaptureBuffer_LastNLines_ReturnsLines` | Last N lines captured |
| `CaptureBuffer_Selection_ReturnsSelected` | Selected text captured |
| `CaptureSelection_NoSelection_ReturnsNull` | Returns null if nothing selected |
| `ProcessOutput_StripsAnsi` | ANSI sequences removed |
| `ProcessOutput_NormalizesLineEndings` | \r\n and \r become \n |
| `ProcessOutput_TrimsWhitespace` | Leading/trailing whitespace removed |
| `Truncate_KeepStart_TruncatesEnd` | Keeps beginning |
| `Truncate_KeepEnd_TruncatesStart` | Keeps ending |
| `Truncate_KeepBoth_KeepsEnds` | Keeps both ends |
| `Truncate_CharacterLimit_Applied` | MaxCaptureLength enforced |
| `Truncate_LineLimit_Applied` | MaxCaptureLines enforced |
| `Truncate_AddsIndicator` | "(truncated)" added |
| `GetRecentCaptures_ReturnsHistory` | Recent captures returned |
| `GetRecentCaptures_LimitsCount` | Count parameter respected |
| `GetCapture_ReturnsById` | Specific capture retrieved |
| `History_PrunesOldCaptures` | Old captures removed |
| `Configure_UpdatesSettings` | New settings applied |
| `Settings_ForAIContext_HasDefaults` | Factory method works |
| `AnsiPattern_MatchesCSI` | CSI sequences matched |
| `AnsiPattern_MatchesOSC` | OSC sequences matched |

**Total Tests**: 27

---

## Verification

```bash
# Verify compilation
dotnet build src/AIntern.Services

# Run unit tests
dotnet test --filter "OutputCapture"

# Verify buffer methods exist
grep -n "GetLastLines\|GetSelectedText" src/AIntern.Core/Models/Terminal/TerminalBuffer.cs
```

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | Stream capture accumulates output during command execution |
| AC-2 | Full buffer capture returns entire scrollback |
| AC-3 | Last N lines capture returns specified line count |
| AC-4 | Selection capture returns user-selected text |
| AC-5 | ANSI escape sequences are stripped when configured |
| AC-6 | Line endings are normalized when configured |
| AC-7 | Output is truncated when exceeding character limit |
| AC-8 | Output is truncated when exceeding line limit |
| AC-9 | KeepStart truncation preserves beginning |
| AC-10 | KeepEnd truncation preserves ending |
| AC-11 | KeepBoth truncation preserves both ends |
| AC-12 | Capture history is maintained per session |
| AC-13 | Old captures are pruned based on history size |

---

## Changelog Entry

```markdown
## v0.5.4d - Output Capture System

### Added
- `TruncationMode` enumeration with:
  - KeepStart, KeepEnd, KeepBoth modes
  - Extension methods for indicators and descriptions

- `OutputCaptureSettings` with:
  - MaxCaptureLength (default: 8000 chars)
  - MaxCaptureLines (default: 500 lines)
  - TruncationMode (default: KeepEnd)
  - StripAnsiSequences (default: true)
  - NormalizeLineEndings (default: true)
  - CaptureHistorySize (default: 20)
  - Factory methods: ForAIContext(), ForFullCapture(), Raw()

- `IOutputCaptureService` interface with:
  - Stream capture: StartCapture(), StopCaptureAsync()
  - Buffer capture: CaptureBufferAsync(), CaptureSelectionAsync()
  - History: GetRecentCaptures(), GetCapture()
  - Configuration: Configure()

- `OutputCaptureService` implementation with:
  - Terminal output event subscription
  - ANSI escape sequence stripping (source-generated regex)
  - Line ending normalization
  - Three truncation strategies
  - Per-session capture history with pruning
  - CaptureContext for stream capture state

### Changed
- Extended `TerminalBuffer` with:
  - GetLastLines(int count) method
  - GetSelectedText() method
```

---

## Timeline Estimate

| Version | Estimated Effort |
|---------|------------------|
| v0.5.4d | 0.75 day |
