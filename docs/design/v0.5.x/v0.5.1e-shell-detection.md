# v0.5.1e – Shell Detection Service

## Overview

This specification defines the **Shell Detection Service** component for AIntern v0.5.1. The Shell Detection Service provides cross-platform detection of available shells on the user's system, automatically identifies the default shell, and supplies shell-specific configuration information. This service is a critical dependency for the Terminal Service (v0.5.1d), enabling automatic shell selection without requiring user configuration.

**Parent Specification:** [v0.5.1-terminal-foundation.md](./v0.5.1-terminal-foundation.md)
**Related Specifications:**
- [v0.5.1a-project-setup.md](./v0.5.1a-project-setup.md) – Project setup and dependencies
- [v0.5.1d-terminal-service.md](./v0.5.1d-terminal-service.md) – Terminal service (consumer of this service)

---

## Table of Contents

1. [Component Purpose](#1-component-purpose)
2. [Architecture Overview](#2-architecture-overview)
3. [File Structure](#3-file-structure)
4. [IShellDetectionService Interface](#4-ishelldetectionservice-interface)
5. [Supporting Types](#5-supporting-types)
6. [ShellDetectionService Implementation](#6-shelldetectionservice-implementation)
7. [Platform-Specific Detection](#7-platform-specific-detection)
8. [Shell Discovery Strategies](#8-shell-discovery-strategies)
9. [Caching and Performance](#9-caching-and-performance)
10. [Error Handling](#10-error-handling)
11. [Testing Strategy](#11-testing-strategy)
12. [Integration Points](#12-integration-points)
13. [Implementation Checklist](#13-implementation-checklist)

---

## 1. Component Purpose

The Shell Detection Service is responsible for:

1. **Default Shell Detection** – Automatically determining the user's preferred shell based on OS configuration
2. **Shell Enumeration** – Discovering all available shells on the system
3. **Shell Validation** – Verifying that detected shell executables are functional
4. **Version Detection** – Extracting shell version information where available
5. **Cross-Platform Support** – Consistent behavior across Windows, macOS, and Linux

### Design Principles

- **Zero Configuration**: Works out of the box without user setup
- **Platform-Aware**: Uses OS-specific mechanisms for accurate detection
- **Fail-Safe**: Always provides a fallback shell if detection fails
- **Cacheable**: Results are cached to avoid repeated filesystem/process operations
- **Non-Blocking**: All detection operations are asynchronous

---

## 2. Architecture Overview

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         Shell Detection Service                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                      IShellDetectionService                          │   │
│  │  ┌────────────────┐  ┌─────────────────────┐  ┌──────────────────┐  │   │
│  │  │ GetDefaultShell│  │ GetAvailableShells  │  │  IsShellAvailable│  │   │
│  │  │    Async()     │  │       Async()       │  │      Async()     │  │   │
│  │  └────────────────┘  └─────────────────────┘  └──────────────────┘  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                         │
│                                    ▼                                         │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                      ShellDetectionService                           │   │
│  │                                                                       │   │
│  │  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────────┐  │   │
│  │  │ Windows Handler │  │  macOS Handler  │  │   Linux Handler     │  │   │
│  │  │ ─────────────── │  │ ─────────────── │  │ ───────────────── │  │   │
│  │  │ • PowerShell    │  │ • $SHELL env    │  │ • $SHELL env       │  │   │
│  │  │ • cmd.exe       │  │ • dscl command  │  │ • /etc/passwd      │  │   │
│  │  │ • Git Bash      │  │ • /bin/zsh      │  │ • /etc/shells      │  │   │
│  │  │ • WSL           │  │ • Homebrew      │  │ • /bin/bash        │  │   │
│  │  └─────────────────┘  └─────────────────┘  └─────────────────────┘  │   │
│  │                                                                       │   │
│  │  ┌─────────────────────────────────────────────────────────────────┐ │   │
│  │  │                     Shell Cache                                  │ │   │
│  │  │  IReadOnlyList<ShellInfo>? _cachedShells                        │ │   │
│  │  └─────────────────────────────────────────────────────────────────┘ │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Detection Flow

```
GetDefaultShellAsync() called
        │
        ├── Windows?
        │   ├── Check for pwsh.exe (PowerShell Core)
        │   ├── Check for powershell.exe (Windows PowerShell)
        │   └── Fallback to cmd.exe
        │
        ├── macOS?
        │   ├── Check $SHELL environment variable
        │   ├── Query dscl for user's shell
        │   └── Fallback to /bin/zsh (Catalina+)
        │
        └── Linux?
            ├── Check $SHELL environment variable
            ├── Parse /etc/passwd for user entry
            └── Fallback to /bin/bash
```

---

## 3. File Structure

```
src/
├── AIntern.Core/
│   └── Interfaces/
│       └── IShellDetectionService.cs    # Interface + ShellInfo + ShellType
│
└── AIntern.Services/
    └── Terminal/
        └── ShellDetectionService.cs     # Cross-platform implementation
```

### File Responsibilities

| File | Purpose | Lines (Est.) |
|------|---------|--------------|
| `IShellDetectionService.cs` | Service interface, ShellInfo record, ShellType enum | ~80 |
| `ShellDetectionService.cs` | Full cross-platform implementation | ~450 |

---

## 4. IShellDetectionService Interface

### Complete Interface Definition

```csharp
// src/AIntern.Core/Interfaces/IShellDetectionService.cs

namespace AIntern.Core.Interfaces;

// ┌─────────────────────────────────────────────────────────────────────────┐
// │ SHELL DETECTION SERVICE INTERFACE (v0.5.1e)                             │
// │ Cross-platform shell discovery and identification.                      │
// └─────────────────────────────────────────────────────────────────────────┘

/// <summary>
/// Service for detecting available shells on the system.
/// </summary>
/// <remarks>
/// <para>Added in v0.5.1e.</para>
/// <para>
/// This service provides cross-platform shell detection capabilities:
/// <list type="bullet">
///   <item>Automatic default shell detection based on OS configuration</item>
///   <item>Enumeration of all available shells</item>
///   <item>Shell validation and version detection</item>
/// </list>
/// </para>
/// <para>
/// Implementations should cache results to avoid repeated filesystem
/// and process operations.
/// </para>
/// </remarks>
public interface IShellDetectionService
{
    /// <summary>
    /// Gets the default shell for the current platform.
    /// </summary>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>Full path to the default shell executable.</returns>
    /// <remarks>
    /// <para>
    /// Detection strategies by platform:
    /// <list type="bullet">
    ///   <item>Windows: PowerShell Core → Windows PowerShell → cmd.exe</item>
    ///   <item>macOS: $SHELL → dscl → /bin/zsh</item>
    ///   <item>Linux: $SHELL → /etc/passwd → /bin/bash</item>
    /// </list>
    /// </para>
    /// <para>
    /// This method always returns a valid shell path. If detection fails,
    /// a platform-appropriate fallback is returned.
    /// </para>
    /// </remarks>
    Task<string> GetDefaultShellAsync(CancellationToken ct = default);

    /// <summary>
    /// Gets all available shells on the system.
    /// </summary>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>List of available shells with metadata.</returns>
    /// <remarks>
    /// <para>
    /// Results are cached after the first call. The cache persists
    /// for the lifetime of the service instance.
    /// </para>
    /// <para>
    /// The returned list is ordered with the default shell first,
    /// followed by other shells in a platform-appropriate order.
    /// </para>
    /// </remarks>
    Task<IReadOnlyList<ShellInfo>> GetAvailableShellsAsync(CancellationToken ct = default);

    /// <summary>
    /// Checks if a shell is available at the specified path.
    /// </summary>
    /// <param name="path">Full path to the shell executable.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>True if the shell exists and is executable; false otherwise.</returns>
    /// <remarks>
    /// <para>
    /// This method verifies that:
    /// <list type="bullet">
    ///   <item>The file exists at the specified path</item>
    ///   <item>The file is executable (responds to --version or similar)</item>
    /// </list>
    /// </para>
    /// <para>
    /// A timeout of 5 seconds is applied to the validation process.
    /// </para>
    /// </remarks>
    Task<bool> IsShellAvailableAsync(string path, CancellationToken ct = default);
}
```

---

## 5. Supporting Types

### 5.1 ShellInfo Record

```csharp
// src/AIntern.Core/Interfaces/IShellDetectionService.cs (continued)

/// <summary>
/// Information about an available shell.
/// </summary>
/// <remarks>
/// <para>Added in v0.5.1e.</para>
/// <para>
/// This record contains metadata about a detected shell, including
/// its display name, path, type classification, and version information.
/// </para>
/// </remarks>
public sealed record ShellInfo
{
    /// <summary>
    /// Display name for the shell (e.g., "PowerShell", "Bash", "Zsh").
    /// </summary>
    /// <remarks>
    /// This is a user-friendly name suitable for display in UI elements
    /// like dropdown menus or tab labels.
    /// </remarks>
    public required string Name { get; init; }

    /// <summary>
    /// Full path to the shell executable.
    /// </summary>
    /// <remarks>
    /// This is the absolute path that should be passed to the PTY
    /// when spawning a new terminal session.
    /// </remarks>
    public required string Path { get; init; }

    /// <summary>
    /// Shell type identifier.
    /// </summary>
    /// <remarks>
    /// Used to determine shell-specific behaviors such as:
    /// <list type="bullet">
    ///   <item>Default arguments to pass</item>
    ///   <item>Clear screen command</item>
    ///   <item>Working directory change command</item>
    /// </list>
    /// </remarks>
    public required ShellType Type { get; init; }

    /// <summary>
    /// Version string if available (e.g., "7.4.0", "5.2.15").
    /// </summary>
    /// <remarks>
    /// Obtained by running the shell with --version or equivalent.
    /// May be null if version detection fails or is not supported.
    /// </remarks>
    public string? Version { get; init; }

    /// <summary>
    /// Whether this is the system default shell.
    /// </summary>
    /// <remarks>
    /// Exactly one shell in the list returned by
    /// <see cref="IShellDetectionService.GetAvailableShellsAsync"/>
    /// will have this set to true.
    /// </remarks>
    public bool IsDefault { get; init; }

    /// <summary>
    /// Returns a display string for this shell.
    /// </summary>
    public override string ToString() =>
        Version != null ? $"{Name} ({Version})" : Name;
}
```

### 5.2 ShellType Enum

```csharp
// src/AIntern.Core/Interfaces/IShellDetectionService.cs (continued)

/// <summary>
/// Known shell types.
/// </summary>
/// <remarks>
/// <para>Added in v0.5.1e.</para>
/// <para>
/// This enum identifies the type of shell for determining
/// shell-specific behaviors and commands.
/// </para>
/// </remarks>
public enum ShellType
{
    /// <summary>
    /// Unknown or unrecognized shell type.
    /// </summary>
    Unknown,

    /// <summary>
    /// GNU Bourne-Again Shell (bash).
    /// Common on Linux and available on macOS/Windows via Git.
    /// </summary>
    Bash,

    /// <summary>
    /// Z Shell (zsh).
    /// Default on macOS since Catalina (10.15).
    /// </summary>
    Zsh,

    /// <summary>
    /// Friendly Interactive Shell (fish).
    /// Known for user-friendly features and syntax highlighting.
    /// </summary>
    Fish,

    /// <summary>
    /// PowerShell (Core or Windows).
    /// Cross-platform on pwsh, Windows-only on powershell.exe.
    /// </summary>
    PowerShell,

    /// <summary>
    /// Windows Command Prompt (cmd.exe).
    /// Legacy Windows shell.
    /// </summary>
    Cmd,

    /// <summary>
    /// Nushell (nu).
    /// Modern shell with structured data support.
    /// </summary>
    Nushell,

    /// <summary>
    /// Bourne Shell (sh).
    /// POSIX-compliant shell, often a symlink to bash or dash.
    /// </summary>
    Sh
}
```

---

## 6. ShellDetectionService Implementation

### Complete Implementation

```csharp
// src/AIntern.Services/Terminal/ShellDetectionService.cs

using System.Diagnostics;
using System.Runtime.InteropServices;
using AIntern.Core.Interfaces;
using Microsoft.Extensions.Logging;

namespace AIntern.Services.Terminal;

// ┌─────────────────────────────────────────────────────────────────────────┐
// │ SHELL DETECTION SERVICE (v0.5.1e)                                       │
// │ Cross-platform shell discovery and identification.                      │
// └─────────────────────────────────────────────────────────────────────────┘

/// <summary>
/// Cross-platform shell detection service.
/// </summary>
/// <remarks>
/// <para>Added in v0.5.1e.</para>
/// <para>
/// Detects available shells on Windows, macOS, and Linux using
/// platform-specific mechanisms.
/// </para>
/// </remarks>
public sealed class ShellDetectionService : IShellDetectionService
{
    // ─────────────────────────────────────────────────────────────────────
    // Fields
    // ─────────────────────────────────────────────────────────────────────

    private readonly ILogger<ShellDetectionService> _logger;
    private IReadOnlyList<ShellInfo>? _cachedShells;
    private string? _cachedDefaultShell;

    // ─────────────────────────────────────────────────────────────────────
    // Constructor
    // ─────────────────────────────────────────────────────────────────────

    /// <summary>
    /// Creates a new shell detection service.
    /// </summary>
    /// <param name="logger">Logger instance.</param>
    public ShellDetectionService(ILogger<ShellDetectionService> logger)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    // ─────────────────────────────────────────────────────────────────────
    // IShellDetectionService Implementation
    // ─────────────────────────────────────────────────────────────────────

    /// <inheritdoc />
    public async Task<string> GetDefaultShellAsync(CancellationToken ct = default)
    {
        // Return cached result if available
        if (_cachedDefaultShell != null)
            return _cachedDefaultShell;

        string? defaultShell = null;

        if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
        {
            defaultShell = await GetWindowsDefaultShellAsync(ct);
        }
        else if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
        {
            defaultShell = await GetMacDefaultShellAsync(ct);
        }
        else if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
        {
            defaultShell = await GetLinuxDefaultShellAsync(ct);
        }

        if (string.IsNullOrEmpty(defaultShell))
        {
            _logger.LogWarning("Could not detect default shell, falling back to platform default");
            defaultShell = GetFallbackShell();
        }

        _logger.LogInformation("Default shell detected: {Shell}", defaultShell);
        _cachedDefaultShell = defaultShell;
        return defaultShell;
    }

    /// <inheritdoc />
    public async Task<IReadOnlyList<ShellInfo>> GetAvailableShellsAsync(
        CancellationToken ct = default)
    {
        // Return cached result if available
        if (_cachedShells != null)
            return _cachedShells;

        var shells = new List<ShellInfo>();
        var defaultShell = await GetDefaultShellAsync(ct);

        if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
        {
            await AddWindowsShellsAsync(shells, defaultShell, ct);
        }
        else
        {
            await AddUnixShellsAsync(shells, defaultShell, ct);
        }

        // Sort with default shell first
        shells.Sort((a, b) =>
        {
            if (a.IsDefault && !b.IsDefault) return -1;
            if (!a.IsDefault && b.IsDefault) return 1;
            return string.Compare(a.Name, b.Name, StringComparison.Ordinal);
        });

        _cachedShells = shells.AsReadOnly();
        _logger.LogDebug("Found {Count} available shells", _cachedShells.Count);
        return _cachedShells;
    }

    /// <inheritdoc />
    public async Task<bool> IsShellAvailableAsync(string path, CancellationToken ct = default)
    {
        if (string.IsNullOrWhiteSpace(path))
            return false;

        try
        {
            if (!File.Exists(path))
            {
                _logger.LogDebug("Shell not found at path: {Path}", path);
                return false;
            }

            // Try to execute --version to verify it's a working shell
            using var process = new Process
            {
                StartInfo = new ProcessStartInfo
                {
                    FileName = path,
                    Arguments = "--version",
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    UseShellExecute = false,
                    CreateNoWindow = true
                }
            };

            process.Start();

            // Wait with timeout
            using var timeoutCts = CancellationTokenSource.CreateLinkedTokenSource(ct);
            timeoutCts.CancelAfter(TimeSpan.FromSeconds(5));

            try
            {
                await process.WaitForExitAsync(timeoutCts.Token);
                return true;
            }
            catch (OperationCanceledException)
            {
                // Timeout or cancellation
                try { process.Kill(); } catch { }
                return false;
            }
        }
        catch (Exception ex)
        {
            _logger.LogDebug(ex, "Error checking shell availability at: {Path}", path);
            return false;
        }
    }

    // ─────────────────────────────────────────────────────────────────────
    // Windows Detection
    // ─────────────────────────────────────────────────────────────────────

    private async Task<string?> GetWindowsDefaultShellAsync(CancellationToken ct)
    {
        _logger.LogDebug("Detecting Windows default shell");

        // Check for PowerShell Core first (preferred)
        var pwshPath = FindExecutable("pwsh");
        if (pwshPath != null && await IsShellAvailableAsync(pwshPath, ct))
        {
            _logger.LogDebug("Found PowerShell Core at: {Path}", pwshPath);
            return pwshPath;
        }

        // Fall back to Windows PowerShell
        var windowsPowerShell = Path.Combine(
            Environment.GetFolderPath(Environment.SpecialFolder.System),
            "WindowsPowerShell", "v1.0", "powershell.exe");

        if (File.Exists(windowsPowerShell))
        {
            _logger.LogDebug("Found Windows PowerShell at: {Path}", windowsPowerShell);
            return windowsPowerShell;
        }

        // Ultimate fallback to cmd.exe
        var cmdPath = Path.Combine(
            Environment.GetFolderPath(Environment.SpecialFolder.System),
            "cmd.exe");

        if (File.Exists(cmdPath))
        {
            _logger.LogDebug("Falling back to cmd.exe at: {Path}", cmdPath);
            return cmdPath;
        }

        return null;
    }

    private async Task AddWindowsShellsAsync(
        List<ShellInfo> shells,
        string defaultShell,
        CancellationToken ct)
    {
        _logger.LogDebug("Enumerating Windows shells");

        // PowerShell Core
        var pwshPath = FindExecutable("pwsh");
        if (pwshPath != null && await IsShellAvailableAsync(pwshPath, ct))
        {
            shells.Add(new ShellInfo
            {
                Name = "PowerShell",
                Path = pwshPath,
                Type = ShellType.PowerShell,
                IsDefault = NormalizePath(pwshPath) == NormalizePath(defaultShell),
                Version = await GetVersionAsync(pwshPath, "--version", ct)
            });
        }

        // Windows PowerShell
        var windowsPowerShell = Path.Combine(
            Environment.GetFolderPath(Environment.SpecialFolder.System),
            "WindowsPowerShell", "v1.0", "powershell.exe");

        if (File.Exists(windowsPowerShell) &&
            NormalizePath(windowsPowerShell) != NormalizePath(pwshPath))
        {
            shells.Add(new ShellInfo
            {
                Name = "Windows PowerShell",
                Path = windowsPowerShell,
                Type = ShellType.PowerShell,
                IsDefault = NormalizePath(windowsPowerShell) == NormalizePath(defaultShell)
            });
        }

        // Command Prompt
        var cmdPath = Path.Combine(
            Environment.GetFolderPath(Environment.SpecialFolder.System),
            "cmd.exe");

        if (File.Exists(cmdPath))
        {
            shells.Add(new ShellInfo
            {
                Name = "Command Prompt",
                Path = cmdPath,
                Type = ShellType.Cmd,
                IsDefault = NormalizePath(cmdPath) == NormalizePath(defaultShell)
            });
        }

        // Git Bash
        var gitBashPaths = new[]
        {
            @"C:\Program Files\Git\bin\bash.exe",
            @"C:\Program Files (x86)\Git\bin\bash.exe",
            Path.Combine(
                Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),
                "Programs", "Git", "bin", "bash.exe")
        };

        foreach (var gitBash in gitBashPaths)
        {
            if (File.Exists(gitBash))
            {
                shells.Add(new ShellInfo
                {
                    Name = "Git Bash",
                    Path = gitBash,
                    Type = ShellType.Bash,
                    IsDefault = NormalizePath(gitBash) == NormalizePath(defaultShell),
                    Version = await GetVersionAsync(gitBash, "--version", ct)
                });
                break; // Only add once
            }
        }

        // WSL (Windows Subsystem for Linux)
        var wslPath = Path.Combine(
            Environment.GetFolderPath(Environment.SpecialFolder.System),
            "wsl.exe");

        if (File.Exists(wslPath))
        {
            shells.Add(new ShellInfo
            {
                Name = "WSL",
                Path = wslPath,
                Type = ShellType.Bash,
                IsDefault = NormalizePath(wslPath) == NormalizePath(defaultShell)
            });
        }

        // Nushell
        var nuPath = FindExecutable("nu");
        if (nuPath != null && await IsShellAvailableAsync(nuPath, ct))
        {
            shells.Add(new ShellInfo
            {
                Name = "Nushell",
                Path = nuPath,
                Type = ShellType.Nushell,
                IsDefault = NormalizePath(nuPath) == NormalizePath(defaultShell),
                Version = await GetVersionAsync(nuPath, "--version", ct)
            });
        }
    }

    // ─────────────────────────────────────────────────────────────────────
    // macOS Detection
    // ─────────────────────────────────────────────────────────────────────

    private async Task<string?> GetMacDefaultShellAsync(CancellationToken ct)
    {
        _logger.LogDebug("Detecting macOS default shell");

        // Try SHELL environment variable first
        var shell = Environment.GetEnvironmentVariable("SHELL");
        if (!string.IsNullOrEmpty(shell) && await IsShellAvailableAsync(shell, ct))
        {
            _logger.LogDebug("Found shell from $SHELL: {Shell}", shell);
            return shell;
        }

        // Try dscl to get user's configured shell
        try
        {
            using var process = new Process
            {
                StartInfo = new ProcessStartInfo
                {
                    FileName = "dscl",
                    Arguments = $". -read /Users/{Environment.UserName} UserShell",
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    UseShellExecute = false,
                    CreateNoWindow = true
                }
            };

            process.Start();
            var output = await process.StandardOutput.ReadToEndAsync(ct);
            await process.WaitForExitAsync(ct);

            // Output format: "UserShell: /bin/zsh"
            var parts = output.Split(':', 2);
            if (parts.Length == 2)
            {
                shell = parts[1].Trim();
                if (await IsShellAvailableAsync(shell, ct))
                {
                    _logger.LogDebug("Found shell from dscl: {Shell}", shell);
                    return shell;
                }
            }
        }
        catch (Exception ex)
        {
            _logger.LogDebug(ex, "Failed to get shell from dscl");
        }

        // macOS defaults to zsh since Catalina (10.15)
        const string zshPath = "/bin/zsh";
        if (File.Exists(zshPath))
        {
            _logger.LogDebug("Falling back to /bin/zsh");
            return zshPath;
        }

        return null;
    }

    // ─────────────────────────────────────────────────────────────────────
    // Linux Detection
    // ─────────────────────────────────────────────────────────────────────

    private async Task<string?> GetLinuxDefaultShellAsync(CancellationToken ct)
    {
        _logger.LogDebug("Detecting Linux default shell");

        // Try SHELL environment variable
        var shell = Environment.GetEnvironmentVariable("SHELL");
        if (!string.IsNullOrEmpty(shell) && await IsShellAvailableAsync(shell, ct))
        {
            _logger.LogDebug("Found shell from $SHELL: {Shell}", shell);
            return shell;
        }

        // Try to read from /etc/passwd
        try
        {
            var passwd = await File.ReadAllTextAsync("/etc/passwd", ct);
            var username = Environment.UserName;
            var lines = passwd.Split('\n');

            foreach (var line in lines)
            {
                if (line.StartsWith(username + ":", StringComparison.Ordinal))
                {
                    var parts = line.Split(':');
                    if (parts.Length >= 7)
                    {
                        shell = parts[6].Trim();
                        if (await IsShellAvailableAsync(shell, ct))
                        {
                            _logger.LogDebug("Found shell from /etc/passwd: {Shell}", shell);
                            return shell;
                        }
                    }
                }
            }
        }
        catch (Exception ex)
        {
            _logger.LogDebug(ex, "Failed to get shell from /etc/passwd");
        }

        // Fall back to bash
        const string bashPath = "/bin/bash";
        if (File.Exists(bashPath))
        {
            _logger.LogDebug("Falling back to /bin/bash");
            return bashPath;
        }

        return null;
    }

    // ─────────────────────────────────────────────────────────────────────
    // Unix Shell Enumeration (shared by macOS and Linux)
    // ─────────────────────────────────────────────────────────────────────

    private async Task AddUnixShellsAsync(
        List<ShellInfo> shells,
        string defaultShell,
        CancellationToken ct)
    {
        _logger.LogDebug("Enumerating Unix shells");

        // Well-known shell paths to check
        var shellPaths = new (string Name, string Path, ShellType Type)[]
        {
            ("Bash", "/bin/bash", ShellType.Bash),
            ("Bash", "/usr/bin/bash", ShellType.Bash),
            ("Zsh", "/bin/zsh", ShellType.Zsh),
            ("Zsh", "/usr/bin/zsh", ShellType.Zsh),
            ("Fish", "/usr/bin/fish", ShellType.Fish),
            ("Fish", "/usr/local/bin/fish", ShellType.Fish),
            ("Fish", "/opt/homebrew/bin/fish", ShellType.Fish),
            ("Sh", "/bin/sh", ShellType.Sh),
            ("Nushell", "/usr/bin/nu", ShellType.Nushell),
            ("Nushell", "/usr/local/bin/nu", ShellType.Nushell),
            ("Nushell", "/opt/homebrew/bin/nu", ShellType.Nushell),
        };

        var addedPaths = new HashSet<string>(StringComparer.Ordinal);

        foreach (var (name, path, type) in shellPaths)
        {
            // Skip duplicates (e.g., if /bin/bash and /usr/bin/bash are the same)
            var normalizedPath = NormalizePath(path);
            if (normalizedPath == null || addedPaths.Contains(normalizedPath))
                continue;

            if (await IsShellAvailableAsync(path, ct))
            {
                addedPaths.Add(normalizedPath);
                shells.Add(new ShellInfo
                {
                    Name = name,
                    Path = path,
                    Type = type,
                    IsDefault = NormalizePath(path) == NormalizePath(defaultShell),
                    Version = await GetVersionAsync(path, "--version", ct)
                });
            }
        }

        // Check for PowerShell Core on Unix
        var pwshPaths = new[]
        {
            "/usr/bin/pwsh",
            "/usr/local/bin/pwsh",
            "/opt/homebrew/bin/pwsh",
            "/snap/bin/pwsh"
        };

        foreach (var pwshPath in pwshPaths)
        {
            if (await IsShellAvailableAsync(pwshPath, ct))
            {
                shells.Add(new ShellInfo
                {
                    Name = "PowerShell",
                    Path = pwshPath,
                    Type = ShellType.PowerShell,
                    IsDefault = NormalizePath(pwshPath) == NormalizePath(defaultShell),
                    Version = await GetVersionAsync(pwshPath, "--version", ct)
                });
                break; // Only add once
            }
        }
    }

    // ─────────────────────────────────────────────────────────────────────
    // Helper Methods
    // ─────────────────────────────────────────────────────────────────────

    /// <summary>
    /// Gets the platform-appropriate fallback shell.
    /// </summary>
    private static string GetFallbackShell()
    {
        if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
        {
            return Path.Combine(
                Environment.GetFolderPath(Environment.SpecialFolder.System),
                "cmd.exe");
        }

        return "/bin/sh";
    }

    /// <summary>
    /// Finds an executable in the PATH.
    /// </summary>
    private static string? FindExecutable(string name)
    {
        var pathEnv = Environment.GetEnvironmentVariable("PATH");
        if (string.IsNullOrEmpty(pathEnv))
            return null;

        var paths = pathEnv.Split(Path.PathSeparator);
        var extension = RuntimeInformation.IsOSPlatform(OSPlatform.Windows) ? ".exe" : "";

        foreach (var path in paths)
        {
            try
            {
                var fullPath = Path.Combine(path, name + extension);
                if (File.Exists(fullPath))
                    return fullPath;
            }
            catch
            {
                // Skip invalid paths
            }
        }

        return null;
    }

    /// <summary>
    /// Gets the version string from a shell executable.
    /// </summary>
    private async Task<string?> GetVersionAsync(
        string path,
        string args,
        CancellationToken ct)
    {
        try
        {
            using var process = new Process
            {
                StartInfo = new ProcessStartInfo
                {
                    FileName = path,
                    Arguments = args,
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    UseShellExecute = false,
                    CreateNoWindow = true
                }
            };

            process.Start();

            // Read first line of output
            var output = await process.StandardOutput.ReadLineAsync(ct);

            // Wait with timeout
            using var timeoutCts = CancellationTokenSource.CreateLinkedTokenSource(ct);
            timeoutCts.CancelAfter(TimeSpan.FromSeconds(2));

            try
            {
                await process.WaitForExitAsync(timeoutCts.Token);
            }
            catch (OperationCanceledException)
            {
                try { process.Kill(); } catch { }
            }

            return ParseVersionString(output);
        }
        catch (Exception ex)
        {
            _logger.LogDebug(ex, "Failed to get version for shell: {Path}", path);
            return null;
        }
    }

    /// <summary>
    /// Extracts a clean version number from shell --version output.
    /// </summary>
    private static string? ParseVersionString(string? output)
    {
        if (string.IsNullOrWhiteSpace(output))
            return null;

        // Try to extract version number patterns like "5.2.15", "7.4.0", etc.
        var cleaned = output.Trim();

        // Handle common formats:
        // "GNU bash, version 5.2.15(1)-release"
        // "zsh 5.9 (x86_64-apple-darwin23.0)"
        // "PowerShell 7.4.0"
        // "fish, version 3.6.1"

        // Return first line, trimmed
        var firstLine = cleaned.Split('\n')[0].Trim();

        // If it's reasonably short, return as-is
        if (firstLine.Length <= 50)
            return firstLine;

        // Otherwise, try to extract just the version number
        var versionMatch = System.Text.RegularExpressions.Regex.Match(
            firstLine, @"\d+\.\d+(\.\d+)?");

        return versionMatch.Success ? versionMatch.Value : null;
    }

    /// <summary>
    /// Normalizes a path for comparison.
    /// </summary>
    private static string? NormalizePath(string? path)
    {
        if (string.IsNullOrEmpty(path))
            return null;

        try
        {
            // Resolve symlinks and normalize
            var fullPath = Path.GetFullPath(path);
            return RuntimeInformation.IsOSPlatform(OSPlatform.Windows)
                ? fullPath.ToLowerInvariant()
                : fullPath;
        }
        catch
        {
            return path;
        }
    }
}
```

---

## 7. Platform-Specific Detection

### Windows Detection Strategy

| Priority | Source | Method | Example Result |
|----------|--------|--------|----------------|
| 1 | PATH | `FindExecutable("pwsh")` | `C:\Program Files\PowerShell\7\pwsh.exe` |
| 2 | System folder | Direct path check | `C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe` |
| 3 | System folder | Fallback | `C:\Windows\System32\cmd.exe` |

**Windows Shell Locations:**

| Shell | Path(s) |
|-------|---------|
| PowerShell Core | `%PATH%\pwsh.exe` |
| Windows PowerShell | `%SystemRoot%\System32\WindowsPowerShell\v1.0\powershell.exe` |
| Command Prompt | `%SystemRoot%\System32\cmd.exe` |
| Git Bash | `C:\Program Files\Git\bin\bash.exe`, `C:\Program Files (x86)\Git\bin\bash.exe` |
| WSL | `%SystemRoot%\System32\wsl.exe` |
| Nushell | `%PATH%\nu.exe` |

### macOS Detection Strategy

| Priority | Source | Method | Example Result |
|----------|--------|--------|----------------|
| 1 | Environment | `$SHELL` variable | `/bin/zsh` |
| 2 | Directory Services | `dscl . -read /Users/$USER UserShell` | `/bin/zsh` |
| 3 | System default | Fallback (Catalina+) | `/bin/zsh` |

**macOS Shell Locations:**

| Shell | Path(s) |
|-------|---------|
| Zsh | `/bin/zsh` |
| Bash | `/bin/bash` |
| Fish | `/usr/local/bin/fish`, `/opt/homebrew/bin/fish` |
| PowerShell | `/usr/local/bin/pwsh`, `/opt/homebrew/bin/pwsh` |
| Nushell | `/usr/local/bin/nu`, `/opt/homebrew/bin/nu` |

### Linux Detection Strategy

| Priority | Source | Method | Example Result |
|----------|--------|--------|----------------|
| 1 | Environment | `$SHELL` variable | `/bin/bash` |
| 2 | passwd | Parse `/etc/passwd` for user entry | `/bin/bash` |
| 3 | System default | Fallback | `/bin/bash` |

**Linux Shell Locations:**

| Shell | Path(s) |
|-------|---------|
| Bash | `/bin/bash`, `/usr/bin/bash` |
| Zsh | `/bin/zsh`, `/usr/bin/zsh` |
| Fish | `/usr/bin/fish` |
| Sh | `/bin/sh` |
| PowerShell | `/usr/bin/pwsh`, `/snap/bin/pwsh` |
| Nushell | `/usr/bin/nu` |

---

## 8. Shell Discovery Strategies

### /etc/shells Parsing (Optional Enhancement)

On Unix systems, `/etc/shells` lists all valid login shells:

```
# /etc/shells: valid login shells
/bin/sh
/bin/bash
/bin/zsh
/usr/bin/zsh
/bin/fish
```

This can be used as an additional discovery source, though the current implementation uses well-known paths for reliability.

### Version Detection Commands

| Shell | Version Command | Example Output |
|-------|----------------|----------------|
| Bash | `bash --version` | `GNU bash, version 5.2.15(1)-release` |
| Zsh | `zsh --version` | `zsh 5.9 (x86_64-apple-darwin23.0)` |
| Fish | `fish --version` | `fish, version 3.6.1` |
| PowerShell | `pwsh --version` | `PowerShell 7.4.0` |
| Nushell | `nu --version` | `0.88.1` |
| Cmd | N/A | No version flag |

---

## 9. Caching and Performance

### Cache Strategy

```
First Call to GetDefaultShellAsync()
        │
        ├── Perform platform-specific detection
        ├── Store result in _cachedDefaultShell
        └── Return cached value

Subsequent Calls
        │
        └── Return _cachedDefaultShell immediately
```

### Cache Invalidation

The current implementation does **not** support cache invalidation. The cache persists for the lifetime of the service instance. This is appropriate because:

1. Shell installations rarely change during application lifetime
2. The service is typically registered as a singleton
3. Users can restart the application if shells are added

### Performance Characteristics

| Operation | Typical Time | Notes |
|-----------|--------------|-------|
| First `GetDefaultShellAsync()` | 50-200ms | Depends on platform |
| Cached `GetDefaultShellAsync()` | <1ms | Direct return |
| First `GetAvailableShellsAsync()` | 500ms-2s | Version detection adds latency |
| Cached `GetAvailableShellsAsync()` | <1ms | Direct return |
| `IsShellAvailableAsync()` | 50-100ms | Process spawn + 5s timeout |

---

## 10. Error Handling

### Exception Strategy

| Method | Behavior on Error |
|--------|-------------------|
| `GetDefaultShellAsync` | Returns fallback shell; never throws |
| `GetAvailableShellsAsync` | Skips unavailable shells; returns partial list |
| `IsShellAvailableAsync` | Returns `false` on any error |

### Fallback Shells

| Platform | Fallback |
|----------|----------|
| Windows | `cmd.exe` |
| macOS | `/bin/zsh` or `/bin/sh` |
| Linux | `/bin/bash` or `/bin/sh` |

### Logging Levels

| Level | Usage |
|-------|-------|
| Information | Default shell detection result |
| Warning | Detection failed, using fallback |
| Debug | Individual shell checks, version queries |

---

## 11. Testing Strategy

### Unit Tests

```csharp
// tests/AIntern.Services.Tests/Terminal/ShellDetectionServiceTests.cs

public class ShellDetectionServiceTests
{
    // Default Shell Detection
    [Fact]
    public async Task GetDefaultShellAsync_ReturnsNonEmptyPath();

    [Fact]
    public async Task GetDefaultShellAsync_ReturnsCachedResult();

    [Fact]
    public async Task GetDefaultShellAsync_ReturnsExistingFile();

    // Available Shells
    [Fact]
    public async Task GetAvailableShellsAsync_ReturnsAtLeastOneShell();

    [Fact]
    public async Task GetAvailableShellsAsync_IncludesDefaultShell();

    [Fact]
    public async Task GetAvailableShellsAsync_ReturnsCachedResult();

    [Fact]
    public async Task GetAvailableShellsAsync_DefaultShellMarkedAsDefault();

    // Shell Availability
    [Fact]
    public async Task IsShellAvailableAsync_ValidShell_ReturnsTrue();

    [Fact]
    public async Task IsShellAvailableAsync_InvalidPath_ReturnsFalse();

    [Fact]
    public async Task IsShellAvailableAsync_NullPath_ReturnsFalse();

    [Fact]
    public async Task IsShellAvailableAsync_NonExecutable_ReturnsFalse();

    // Platform-Specific (conditional)
    [Fact]
    [Trait("Category", "Windows")]
    public async Task GetDefaultShellAsync_Windows_ReturnsPowerShellOrCmd();

    [Fact]
    [Trait("Category", "Unix")]
    public async Task GetDefaultShellAsync_Unix_ReturnsBashOrZsh();

    // Cancellation
    [Fact]
    public async Task GetDefaultShellAsync_Cancellation_ThrowsOperationCanceled();

    // ShellInfo Validation
    [Fact]
    public async Task GetAvailableShellsAsync_AllShellsHaveValidPaths();

    [Fact]
    public async Task GetAvailableShellsAsync_AllShellsHaveNonEmptyNames();

    [Fact]
    public async Task GetAvailableShellsAsync_ExactlyOneDefaultShell();
}
```

### Integration Tests

```csharp
public class ShellDetectionServiceIntegrationTests
{
    [Fact]
    [Trait("Category", "Integration")]
    public async Task DetectedDefaultShell_CanBeSpawned();

    [Fact]
    [Trait("Category", "Integration")]
    public async Task AllDetectedShells_HaveValidVersionInfo();
}
```

---

## 12. Integration Points

### Consumer: TerminalService (v0.5.1d)

The `TerminalService` uses `IShellDetectionService` to auto-detect the shell when creating sessions:

```csharp
public async Task<TerminalSession> CreateSessionAsync(
    TerminalSessionOptions? options = null,
    CancellationToken ct = default)
{
    options ??= TerminalSessionOptions.Default;

    // Use shell detection if no shell specified
    var shellPath = options.ShellPath
        ?? await _shellDetection.GetDefaultShellAsync(ct);

    // ... spawn PTY with shellPath
}
```

### DI Registration

```csharp
// In AIntern.Services/Terminal/TerminalServiceExtensions.cs

public static IServiceCollection AddTerminalServices(this IServiceCollection services)
{
    services.AddSingleton<IShellDetectionService, ShellDetectionService>();
    services.AddSingleton<ITerminalService, TerminalService>();
    return services;
}
```

### Future Integration: Shell Profile Selection (v0.5.3)

In v0.5.3, the shell detection service will be used by a UI component allowing users to select their preferred shell:

```xml
<ComboBox ItemsSource="{Binding AvailableShells}"
          SelectedItem="{Binding SelectedShell}"
          DisplayMemberBinding="{Binding Name}" />
```

---

## 13. Implementation Checklist

### Files to Create

- [ ] `src/AIntern.Core/Interfaces/IShellDetectionService.cs`
  - [ ] IShellDetectionService interface
  - [ ] ShellInfo record
  - [ ] ShellType enum

- [ ] `src/AIntern.Services/Terminal/ShellDetectionService.cs`
  - [ ] ShellDetectionService class
  - [ ] GetDefaultShellAsync implementation
  - [ ] GetAvailableShellsAsync implementation
  - [ ] IsShellAvailableAsync implementation
  - [ ] Windows detection methods
  - [ ] macOS detection methods
  - [ ] Linux detection methods
  - [ ] Helper methods (FindExecutable, GetVersionAsync, etc.)

### Tests to Create

- [ ] `tests/AIntern.Services.Tests/Terminal/ShellDetectionServiceTests.cs`
  - [ ] Default shell detection tests
  - [ ] Available shells enumeration tests
  - [ ] Shell availability tests
  - [ ] Caching tests
  - [ ] Platform-specific tests

### Dependencies

- [ ] Microsoft.Extensions.Logging.Abstractions (already referenced)
- [ ] System.Diagnostics.Process (built-in)

### Verification Steps

1. Build solution and verify no compilation errors
2. Run unit tests and verify all pass
3. Manual testing on each platform:
   - Windows: Verify PowerShell/cmd detection
   - macOS: Verify zsh/bash detection
   - Linux: Verify bash detection
4. Verify integration with TerminalService

---

## Version History

| Version | Date | Changes |
|---------|------|---------|
| v0.5.1e | TBD | Initial specification |

---

## References

- [PowerShell Core Documentation](https://docs.microsoft.com/en-us/powershell/)
- [macOS dscl Command](https://ss64.com/osx/dscl.html)
- [/etc/passwd Format](https://man7.org/linux/man-pages/man5/passwd.5.html)
- [/etc/shells](https://man7.org/linux/man-pages/man5/shells.5.html)
- [v0.5.1-terminal-foundation.md](./v0.5.1-terminal-foundation.md) – Version scope
- [v0.5.1d-terminal-service.md](./v0.5.1d-terminal-service.md) – Primary consumer
