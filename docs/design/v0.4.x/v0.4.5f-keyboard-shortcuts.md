# v0.4.5f: Keyboard Shortcuts - Design Specification

**Status**: _PLANNED_

## Executive Summary

This specification details the **Keyboard Shortcuts** system for The Senior Intern, providing a comprehensive framework for global and context-specific keyboard shortcuts. The system enables power users to efficiently navigate, apply code changes, manage diffs, and control the application without using the mouse, improving productivity and accessibility.

### Key Deliverables

| Component | Type | Purpose |
|-----------|------|---------|
| `KeyboardShortcut` | Struct | Represents a key + modifier combination |
| `ShortcutContext` | Enum | Defines where shortcuts are active |
| `ShortcutHandler` | Class | Associates shortcuts with actions |
| `IKeyboardShortcutService` | Interface | Service contract for shortcut management |
| `KeyboardShortcutService` | Class | Main implementation with registration/dispatch |
| `ShortcutManager` | Class | UI-level keyboard event handling |
| `KeyboardShortcutsPanel` | View | Settings UI for viewing/customizing shortcuts |

---

## Feature Overview

```
v0.4.5f: Keyboard Shortcuts
├── Core Models
│   ├── KeyboardShortcut (struct)
│   │   ├── Key (Avalonia.Input.Key)
│   │   ├── Modifiers (KeyModifiers)
│   │   ├── ToString() → "Ctrl+Shift+A"
│   │   ├── ToDisplayString() → platform-aware
│   │   ├── Parse(string) → KeyboardShortcut
│   │   └── Equality operators
│   ├── ShortcutContext (enum)
│   │   ├── Global (active everywhere)
│   │   ├── ChatInput (chat text box focused)
│   │   ├── ChatView (chat panel focused)
│   │   ├── CodeBlock (code block focused)
│   │   ├── DiffViewer (diff panel focused)
│   │   ├── FileTree (file browser focused)
│   │   ├── Settings (settings panel focused)
│   │   └── Modal (modal dialog open)
│   ├── ShortcutHandler (class)
│   │   ├── Shortcut (KeyboardShortcut)
│   │   ├── ActionId (string, unique)
│   │   ├── Description (string)
│   │   ├── Context (ShortcutContext)
│   │   ├── Category (ShortcutCategory)
│   │   ├── IsEnabled (bool)
│   │   ├── IsCustom (bool)
│   │   └── DefaultShortcut (KeyboardShortcut?)
│   └── ShortcutCategory (enum)
│       ├── General
│       ├── Navigation
│       ├── CodeBlocks
│       ├── DiffViewer
│       ├── Chat
│       └── FileOperations
├── Service Layer
│   ├── IKeyboardShortcutService
│   │   ├── Register(shortcut, actionId, description, context)
│   │   ├── RegisterAction(actionId, handler, category)
│   │   ├── Unregister(shortcut)
│   │   ├── Rebind(actionId, newShortcut)
│   │   ├── ResetToDefault(actionId)
│   │   ├── ResetAllToDefaults()
│   │   ├── GetHandler(shortcut)
│   │   ├── GetHandlersForContext(context)
│   │   ├── GetHandlersByCategory(category)
│   │   ├── GetAllHandlers()
│   │   ├── TryHandle(key, modifiers, context) → bool
│   │   ├── GetConflicts(shortcut) → handlers
│   │   ├── SaveCustomizations()
│   │   └── LoadCustomizations()
│   └── KeyboardShortcutService
│       ├── Default shortcuts registration
│       ├── Action dispatch mechanism
│       ├── Context priority handling
│       ├── Conflict detection
│       ├── Persistence to settings
│       └── Platform-specific modifiers
├── UI Integration
│   ├── ShortcutManager (attached behavior)
│   │   ├── Attaches to MainWindow
│   │   ├── OnKeyDown handler
│   │   ├── Context detection
│   │   └── Action dispatch
│   ├── ShortcutTooltipService
│   │   ├── Auto-adds shortcuts to tooltips
│   │   └── Format: "Apply Changes (Ctrl+Enter)"
│   └── ShortcutHintOverlay
│       ├── Shows available shortcuts
│       ├── Triggered by ? or F1
│       └── Context-sensitive display
├── Settings UI
│   └── KeyboardShortcutsPanel
│       ├── Grouped by category
│       ├── Search/filter
│       ├── Rebind dialog
│       ├── Reset to defaults
│       └── Conflict warnings
└── Default Shortcuts
    ├── Global
    │   ├── Ctrl+Shift+A → Apply all changes
    │   ├── Ctrl+Shift+U → Undo last change
    │   ├── Ctrl+Shift+D → Show diff
    │   ├── Ctrl+, → Open settings
    │   ├── Ctrl+N → New chat
    │   ├── F1 → Show shortcuts help
    │   └── Escape → Cancel/Close
    ├── Chat
    │   ├── Ctrl+Enter → Send message
    │   ├── Escape → Cancel generation
    │   ├── Up → Previous message (when empty)
    │   └── Ctrl+L → Clear chat
    ├── Code Blocks
    │   ├── Ctrl+Enter → Apply block
    │   ├── Ctrl+C → Copy code
    │   ├── Ctrl+D → Show diff
    │   ├── Ctrl+O → Open in editor
    │   └── Ctrl+Shift+O → Apply with options
    ├── Diff Viewer
    │   ├── Enter → Apply changes
    │   ├── Escape → Close diff
    │   ├── J/Down → Next hunk
    │   ├── K/Up → Previous hunk
    │   ├── A → Accept all
    │   ├── R → Reject all
    │   └── Space → Toggle hunk selection
    └── Navigation
        ├── Ctrl+1-9 → Switch to chat N
        ├── Ctrl+Tab → Next chat
        ├── Ctrl+Shift+Tab → Previous chat
        └── Ctrl+W → Close current chat
```

---

## Architecture

### System Integration Diagram

```
┌──────────────────────────────────────────────────────────────────────────┐
│                              MainWindow                                   │
│  ┌────────────────────────────────────────────────────────────────────┐  │
│  │                       ShortcutManager                              │  │
│  │                    (Attached Behavior)                             │  │
│  │  ┌──────────────────────────────────────────────────────────────┐ │  │
│  │  │                     OnKeyDown                                 │ │  │
│  │  │   ┌───────────┐    ┌──────────────┐    ┌────────────────┐   │ │  │
│  │  │   │ Capture   │───▶│ Determine    │───▶│ Dispatch to    │   │ │  │
│  │  │   │ KeyEvent  │    │ Context      │    │ Service        │   │ │  │
│  │  │   └───────────┘    └──────────────┘    └────────────────┘   │ │  │
│  │  └──────────────────────────────────────────────────────────────┘ │  │
│  └────────────────────────────────────────────────────────────────────┘  │
└──────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌──────────────────────────────────────────────────────────────────────────┐
│                      IKeyboardShortcutService                            │
│  ┌────────────────────────────────────────────────────────────────────┐  │
│  │                   KeyboardShortcutService                          │  │
│  │                                                                    │  │
│  │  ┌────────────────────────────────────────────────────────────┐   │  │
│  │  │                    Shortcut Registry                        │   │  │
│  │  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐  │   │  │
│  │  │  │ Global       │  │ Context      │  │ Action           │  │   │  │
│  │  │  │ Shortcuts    │  │ Shortcuts    │  │ Handlers         │  │   │  │
│  │  │  │ Dictionary   │  │ Dictionary   │  │ Dictionary       │  │   │  │
│  │  │  └──────────────┘  └──────────────┘  └──────────────────┘  │   │  │
│  │  └────────────────────────────────────────────────────────────┘   │  │
│  │                                                                    │  │
│  │  ┌────────────────────────────────────────────────────────────┐   │  │
│  │  │                   TryHandle(key, mods, ctx)                 │   │  │
│  │  │   1. Check context-specific shortcuts                       │   │  │
│  │  │   2. Check global shortcuts                                 │   │  │
│  │  │   3. Find action handler                                    │   │  │
│  │  │   4. Execute action                                         │   │  │
│  │  └────────────────────────────────────────────────────────────┘   │  │
│  └────────────────────────────────────────────────────────────────────┘  │
└──────────────────────────────────────────────────────────────────────────┘
                                    │
                    ┌───────────────┼───────────────┐
                    ▼               ▼               ▼
           ┌──────────────┐ ┌──────────────┐ ┌──────────────┐
           │ MainWindow   │ │ ChatViewModel│ │ DiffViewer   │
           │ ViewModel    │ │              │ │ ViewModel    │
           │              │ │ SendMessage  │ │              │
           │ ApplyAll     │ │ Cancel       │ │ NextHunk     │
           │ UndoLast     │ │ ClearChat    │ │ ApplyChanges │
           └──────────────┘ └──────────────┘ └──────────────┘
```

### Context Detection Flow

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     Context Detection Flow                               │
└─────────────────────────────────────────────────────────────────────────┘

  KeyDown Event
         │
         ▼
  ┌──────────────────┐
  │ Get Focused      │
  │ Element          │
  └────────┬─────────┘
           │
           ▼
  ┌──────────────────────────────────────────────────────────────────────┐
  │                    Context Decision Tree                              │
  │                                                                       │
  │  Is Modal Open? ───────────────────────────────────────▶ Modal       │
  │         │ No                                                          │
  │         ▼                                                             │
  │  Is in Settings Panel? ────────────────────────────────▶ Settings    │
  │         │ No                                                          │
  │         ▼                                                             │
  │  Is in DiffViewer? ────────────────────────────────────▶ DiffViewer  │
  │         │ No                                                          │
  │         ▼                                                             │
  │  Is in CodeBlock? (has focus/hover) ───────────────────▶ CodeBlock   │
  │         │ No                                                          │
  │         ▼                                                             │
  │  Is ChatInput focused? ────────────────────────────────▶ ChatInput   │
  │         │ No                                                          │
  │         ▼                                                             │
  │  Is in Chat Panel? ────────────────────────────────────▶ ChatView    │
  │         │ No                                                          │
  │         ▼                                                             │
  │  Is in File Tree? ─────────────────────────────────────▶ FileTree    │
  │         │ No                                                          │
  │         ▼                                                             │
  │  Default ──────────────────────────────────────────────▶ Global      │
  │                                                                       │
  └──────────────────────────────────────────────────────────────────────┘
           │
           ▼
  ┌──────────────────┐
  │ Return Context   │
  └──────────────────┘
```

### Shortcut Resolution Priority

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    Shortcut Resolution Priority                          │
└─────────────────────────────────────────────────────────────────────────┘

  KeyDown: Ctrl+Enter in ChatInput context
         │
         ▼
  ┌──────────────────────────────────────────────────────────────────────┐
  │  Priority 1: Context-Specific Shortcuts                              │
  │                                                                       │
  │  Look for Ctrl+Enter in ChatInput context                            │
  │  ┌─────────────────────────────────────────────────────────────────┐ │
  │  │ Found: "SendMessage" action                                     │ │
  │  │ → Execute and mark handled                                      │ │
  │  └─────────────────────────────────────────────────────────────────┘ │
  └──────────────────────────────────────────────────────────────────────┘
         │ Not Found
         ▼
  ┌──────────────────────────────────────────────────────────────────────┐
  │  Priority 2: Global Shortcuts                                        │
  │                                                                       │
  │  Look for Ctrl+Enter in Global context                               │
  │  ┌─────────────────────────────────────────────────────────────────┐ │
  │  │ Found: Check if action can execute                              │ │
  │  │ → Execute and mark handled                                      │ │
  │  └─────────────────────────────────────────────────────────────────┘ │
  └──────────────────────────────────────────────────────────────────────┘
         │ Not Found
         ▼
  ┌──────────────────────────────────────────────────────────────────────┐
  │  Priority 3: Let Event Bubble                                        │
  │                                                                       │
  │  Do not mark handled, let default behavior occur                     │
  └──────────────────────────────────────────────────────────────────────┘
```

---

## Detailed Design

### 1. KeyboardShortcut Struct

```csharp
// src/SeniorIntern.Core/Models/KeyboardShortcut.cs
using Avalonia.Input;
using System.Runtime.InteropServices;

namespace SeniorIntern.Core.Models;

/// <summary>
/// Represents a keyboard shortcut combination (key + modifiers).
/// Immutable value type with equality semantics.
/// </summary>
public readonly struct KeyboardShortcut : IEquatable<KeyboardShortcut>
{
    /// <summary>
    /// The primary key for the shortcut.
    /// </summary>
    public Key Key { get; }

    /// <summary>
    /// Modifier keys (Ctrl, Shift, Alt, Meta/Cmd).
    /// </summary>
    public KeyModifiers Modifiers { get; }

    /// <summary>
    /// Creates a new keyboard shortcut.
    /// </summary>
    public KeyboardShortcut(Key key, KeyModifiers modifiers = KeyModifiers.None)
    {
        Key = key;
        Modifiers = modifiers;
    }

    /// <summary>
    /// Returns true if this shortcut has any modifiers.
    /// </summary>
    public bool HasModifiers => Modifiers != KeyModifiers.None;

    /// <summary>
    /// Returns true if this shortcut uses the Control modifier.
    /// </summary>
    public bool HasControl => Modifiers.HasFlag(KeyModifiers.Control);

    /// <summary>
    /// Returns true if this shortcut uses the Shift modifier.
    /// </summary>
    public bool HasShift => Modifiers.HasFlag(KeyModifiers.Shift);

    /// <summary>
    /// Returns true if this shortcut uses the Alt modifier.
    /// </summary>
    public bool HasAlt => Modifiers.HasFlag(KeyModifiers.Alt);

    /// <summary>
    /// Returns true if this shortcut uses the Meta/Command modifier.
    /// </summary>
    public bool HasMeta => Modifiers.HasFlag(KeyModifiers.Meta);

    /// <summary>
    /// Returns true if this is a valid, usable shortcut.
    /// </summary>
    public bool IsValid => Key != Key.None;

    /// <summary>
    /// Empty/invalid shortcut constant.
    /// </summary>
    public static readonly KeyboardShortcut None = new(Key.None, KeyModifiers.None);

    #region String Conversion

    /// <summary>
    /// Returns a string representation (e.g., "Ctrl+Shift+A").
    /// </summary>
    public override string ToString()
    {
        if (!IsValid)
            return string.Empty;

        var parts = new List<string>(4);

        if (HasControl) parts.Add("Ctrl");
        if (HasShift) parts.Add("Shift");
        if (HasAlt) parts.Add("Alt");
        if (HasMeta) parts.Add("Meta");

        parts.Add(FormatKey(Key));

        return string.Join("+", parts);
    }

    /// <summary>
    /// Returns a platform-aware display string.
    /// On macOS: "Cmd+Shift+A", on Windows/Linux: "Ctrl+Shift+A"
    /// </summary>
    public string ToDisplayString()
    {
        if (!IsValid)
            return string.Empty;

        var parts = new List<string>(4);
        var isMac = RuntimeInformation.IsOSPlatform(OSPlatform.OSX);

        if (isMac)
        {
            // macOS order: Ctrl, Option (Alt), Shift, Cmd
            if (HasControl) parts.Add("\u2303"); // ⌃
            if (HasAlt) parts.Add("\u2325");     // ⌥
            if (HasShift) parts.Add("\u21E7");   // ⇧
            if (HasMeta) parts.Add("\u2318");    // ⌘
        }
        else
        {
            if (HasControl) parts.Add("Ctrl");
            if (HasAlt) parts.Add("Alt");
            if (HasShift) parts.Add("Shift");
            if (HasMeta) parts.Add("Win");
        }

        parts.Add(FormatKeyForDisplay(Key, isMac));

        return isMac ? string.Concat(parts) : string.Join("+", parts);
    }

    /// <summary>
    /// Parses a shortcut string like "Ctrl+Shift+A".
    /// </summary>
    public static KeyboardShortcut Parse(string shortcutString)
    {
        if (string.IsNullOrWhiteSpace(shortcutString))
            return None;

        var parts = shortcutString.Split('+', StringSplitOptions.RemoveEmptyEntries);
        if (parts.Length == 0)
            return None;

        var modifiers = KeyModifiers.None;
        Key key = Key.None;

        foreach (var part in parts)
        {
            var trimmed = part.Trim();
            var lower = trimmed.ToLowerInvariant();

            switch (lower)
            {
                case "ctrl":
                case "control":
                    modifiers |= KeyModifiers.Control;
                    break;
                case "shift":
                    modifiers |= KeyModifiers.Shift;
                    break;
                case "alt":
                case "option":
                    modifiers |= KeyModifiers.Alt;
                    break;
                case "meta":
                case "cmd":
                case "command":
                case "win":
                case "windows":
                    modifiers |= KeyModifiers.Meta;
                    break;
                default:
                    // Try to parse as a key
                    if (Enum.TryParse<Key>(trimmed, ignoreCase: true, out var parsedKey))
                    {
                        key = parsedKey;
                    }
                    break;
            }
        }

        return new KeyboardShortcut(key, modifiers);
    }

    /// <summary>
    /// Tries to parse a shortcut string.
    /// </summary>
    public static bool TryParse(string shortcutString, out KeyboardShortcut shortcut)
    {
        shortcut = Parse(shortcutString);
        return shortcut.IsValid;
    }

    private static string FormatKey(Key key) => key switch
    {
        Key.OemComma => ",",
        Key.OemPeriod => ".",
        Key.OemPlus => "+",
        Key.OemMinus => "-",
        Key.OemOpenBrackets => "[",
        Key.OemCloseBrackets => "]",
        Key.OemSemicolon => ";",
        Key.OemQuotes => "'",
        Key.OemBackslash => "\\",
        Key.OemPipe => "|",
        Key.OemQuestion => "/",
        Key.OemTilde => "`",
        Key.Back => "Backspace",
        Key.Return => "Enter",
        Key.Escape => "Esc",
        Key.Space => "Space",
        Key.Prior => "PageUp",
        Key.Next => "PageDown",
        _ => key.ToString()
    };

    private static string FormatKeyForDisplay(Key key, bool isMac) => key switch
    {
        Key.Back => isMac ? "\u232B" : "Backspace",     // ⌫
        Key.Return => isMac ? "\u21A9" : "Enter",       // ↩
        Key.Escape => isMac ? "\u238B" : "Esc",         // ⎋
        Key.Space => isMac ? "\u2423" : "Space",        // ␣
        Key.Tab => isMac ? "\u21E5" : "Tab",            // ⇥
        Key.Up => isMac ? "\u2191" : "Up",              // ↑
        Key.Down => isMac ? "\u2193" : "Down",          // ↓
        Key.Left => isMac ? "\u2190" : "Left",          // ←
        Key.Right => isMac ? "\u2192" : "Right",        // →
        Key.Delete => isMac ? "\u2326" : "Del",         // ⌦
        Key.Home => isMac ? "\u2196" : "Home",          // ↖
        Key.End => isMac ? "\u2198" : "End",            // ↘
        Key.Prior => isMac ? "\u21DE" : "PgUp",         // ⇞
        Key.Next => isMac ? "\u21DF" : "PgDn",          // ⇟
        _ => FormatKey(key)
    };

    #endregion

    #region Equality

    public bool Equals(KeyboardShortcut other) =>
        Key == other.Key && Modifiers == other.Modifiers;

    public override bool Equals(object? obj) =>
        obj is KeyboardShortcut other && Equals(other);

    public override int GetHashCode() => HashCode.Combine(Key, Modifiers);

    public static bool operator ==(KeyboardShortcut left, KeyboardShortcut right) =>
        left.Equals(right);

    public static bool operator !=(KeyboardShortcut left, KeyboardShortcut right) =>
        !left.Equals(right);

    #endregion

    #region Factory Methods

    /// <summary>
    /// Creates a Ctrl+Key shortcut.
    /// </summary>
    public static KeyboardShortcut Ctrl(Key key) =>
        new(key, KeyModifiers.Control);

    /// <summary>
    /// Creates a Ctrl+Shift+Key shortcut.
    /// </summary>
    public static KeyboardShortcut CtrlShift(Key key) =>
        new(key, KeyModifiers.Control | KeyModifiers.Shift);

    /// <summary>
    /// Creates a Ctrl+Alt+Key shortcut.
    /// </summary>
    public static KeyboardShortcut CtrlAlt(Key key) =>
        new(key, KeyModifiers.Control | KeyModifiers.Alt);

    /// <summary>
    /// Creates a Shift+Key shortcut.
    /// </summary>
    public static KeyboardShortcut Shift(Key key) =>
        new(key, KeyModifiers.Shift);

    /// <summary>
    /// Creates an Alt+Key shortcut.
    /// </summary>
    public static KeyboardShortcut Alt(Key key) =>
        new(key, KeyModifiers.Alt);

    /// <summary>
    /// Creates a key-only shortcut (no modifiers).
    /// </summary>
    public static KeyboardShortcut KeyOnly(Key key) =>
        new(key, KeyModifiers.None);

    #endregion
}
```

### 2. ShortcutContext and ShortcutCategory Enums

```csharp
// src/SeniorIntern.Core/Models/ShortcutContext.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Defines the UI context where a keyboard shortcut is active.
/// Context-specific shortcuts take priority over global shortcuts.
/// </summary>
public enum ShortcutContext
{
    /// <summary>
    /// Shortcut is active in all contexts.
    /// </summary>
    Global = 0,

    /// <summary>
    /// Chat text input is focused.
    /// </summary>
    ChatInput = 1,

    /// <summary>
    /// Chat message list/panel is focused.
    /// </summary>
    ChatView = 2,

    /// <summary>
    /// A code block is focused or hovered.
    /// </summary>
    CodeBlock = 3,

    /// <summary>
    /// Diff viewer panel is active.
    /// </summary>
    DiffViewer = 4,

    /// <summary>
    /// File tree/browser is focused.
    /// </summary>
    FileTree = 5,

    /// <summary>
    /// Settings panel is open.
    /// </summary>
    Settings = 6,

    /// <summary>
    /// A modal dialog is open.
    /// </summary>
    Modal = 7,

    /// <summary>
    /// Change history panel is focused.
    /// </summary>
    ChangeHistory = 8
}

/// <summary>
/// Categories for grouping shortcuts in the settings UI.
/// </summary>
public enum ShortcutCategory
{
    /// <summary>
    /// General application shortcuts.
    /// </summary>
    General,

    /// <summary>
    /// Navigation between views/panels.
    /// </summary>
    Navigation,

    /// <summary>
    /// Code block operations.
    /// </summary>
    CodeBlocks,

    /// <summary>
    /// Diff viewer operations.
    /// </summary>
    DiffViewer,

    /// <summary>
    /// Chat and messaging.
    /// </summary>
    Chat,

    /// <summary>
    /// File operations.
    /// </summary>
    FileOperations,

    /// <summary>
    /// History and undo operations.
    /// </summary>
    History
}
```

### 3. ShortcutHandler Class

```csharp
// src/SeniorIntern.Core/Models/ShortcutHandler.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Associates a keyboard shortcut with an action.
/// </summary>
public sealed class ShortcutHandler
{
    /// <summary>
    /// The keyboard shortcut that triggers this action.
    /// </summary>
    public KeyboardShortcut Shortcut { get; set; }

    /// <summary>
    /// Unique identifier for the action (e.g., "ApplyAllChanges").
    /// </summary>
    public required string ActionId { get; init; }

    /// <summary>
    /// Human-readable description of the action.
    /// </summary>
    public required string Description { get; init; }

    /// <summary>
    /// Context where this shortcut is active.
    /// </summary>
    public ShortcutContext Context { get; init; } = ShortcutContext.Global;

    /// <summary>
    /// Category for grouping in settings UI.
    /// </summary>
    public ShortcutCategory Category { get; init; } = ShortcutCategory.General;

    /// <summary>
    /// Whether this shortcut is currently enabled.
    /// </summary>
    public bool IsEnabled { get; set; } = true;

    /// <summary>
    /// Whether this shortcut has been customized from the default.
    /// </summary>
    public bool IsCustom { get; set; }

    /// <summary>
    /// The default shortcut (before customization).
    /// </summary>
    public KeyboardShortcut? DefaultShortcut { get; init; }

    /// <summary>
    /// Gets the display string for the shortcut.
    /// </summary>
    public string DisplayString => Shortcut.ToDisplayString();

    /// <summary>
    /// Creates a clone with a new shortcut.
    /// </summary>
    public ShortcutHandler WithShortcut(KeyboardShortcut newShortcut) => new()
    {
        Shortcut = newShortcut,
        ActionId = ActionId,
        Description = Description,
        Context = Context,
        Category = Category,
        IsEnabled = IsEnabled,
        IsCustom = true,
        DefaultShortcut = DefaultShortcut ?? Shortcut
    };
}
```

### 4. ShortcutAction Delegate and Registry

```csharp
// src/SeniorIntern.Core/Models/ShortcutAction.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Delegate for shortcut action handlers.
/// </summary>
/// <param name="context">The context where the shortcut was triggered</param>
/// <returns>True if the action was handled, false to allow bubbling</returns>
public delegate Task<bool> ShortcutActionHandler(ShortcutContext context);

/// <summary>
/// Registration for a shortcut action.
/// </summary>
public sealed class ShortcutActionRegistration
{
    /// <summary>
    /// Unique action identifier.
    /// </summary>
    public required string ActionId { get; init; }

    /// <summary>
    /// The handler to execute.
    /// </summary>
    public required ShortcutActionHandler Handler { get; init; }

    /// <summary>
    /// Optional predicate to check if action can execute.
    /// </summary>
    public Func<bool>? CanExecute { get; init; }

    /// <summary>
    /// Category for settings display.
    /// </summary>
    public ShortcutCategory Category { get; init; } = ShortcutCategory.General;
}
```

### 5. IKeyboardShortcutService Interface

```csharp
// src/SeniorIntern.Core/Interfaces/IKeyboardShortcutService.cs
using Avalonia.Input;
using SeniorIntern.Core.Models;

namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Service for managing and dispatching keyboard shortcuts.
/// </summary>
public interface IKeyboardShortcutService
{
    /// <summary>
    /// Raised when a shortcut is triggered.
    /// </summary>
    event EventHandler<ShortcutTriggeredEventArgs>? ShortcutTriggered;

    /// <summary>
    /// Raised when shortcut bindings change.
    /// </summary>
    event EventHandler? ShortcutsChanged;

    #region Registration

    /// <summary>
    /// Registers a shortcut binding.
    /// </summary>
    void Register(
        KeyboardShortcut shortcut,
        string actionId,
        string description,
        ShortcutContext context,
        ShortcutCategory category = ShortcutCategory.General);

    /// <summary>
    /// Registers an action handler.
    /// </summary>
    void RegisterAction(ShortcutActionRegistration registration);

    /// <summary>
    /// Unregisters a shortcut binding.
    /// </summary>
    void Unregister(KeyboardShortcut shortcut);

    /// <summary>
    /// Unregisters all shortcuts for an action.
    /// </summary>
    void UnregisterAction(string actionId);

    #endregion

    #region Customization

    /// <summary>
    /// Rebinds an action to a new shortcut.
    /// </summary>
    /// <returns>True if successful, false if conflict exists</returns>
    bool Rebind(string actionId, KeyboardShortcut newShortcut);

    /// <summary>
    /// Resets an action to its default shortcut.
    /// </summary>
    void ResetToDefault(string actionId);

    /// <summary>
    /// Resets all shortcuts to defaults.
    /// </summary>
    void ResetAllToDefaults();

    /// <summary>
    /// Enables or disables a shortcut.
    /// </summary>
    void SetEnabled(string actionId, bool enabled);

    #endregion

    #region Query

    /// <summary>
    /// Gets the handler for a specific shortcut.
    /// </summary>
    ShortcutHandler? GetHandler(KeyboardShortcut shortcut);

    /// <summary>
    /// Gets the handler for an action ID.
    /// </summary>
    ShortcutHandler? GetHandlerByActionId(string actionId);

    /// <summary>
    /// Gets all handlers for a context.
    /// </summary>
    IEnumerable<ShortcutHandler> GetHandlersForContext(ShortcutContext context);

    /// <summary>
    /// Gets all handlers in a category.
    /// </summary>
    IEnumerable<ShortcutHandler> GetHandlersByCategory(ShortcutCategory category);

    /// <summary>
    /// Gets all registered handlers.
    /// </summary>
    IEnumerable<ShortcutHandler> GetAllHandlers();

    /// <summary>
    /// Gets shortcuts that conflict with the given shortcut.
    /// </summary>
    IEnumerable<ShortcutHandler> GetConflicts(KeyboardShortcut shortcut, ShortcutContext context);

    /// <summary>
    /// Gets the shortcut for an action, if any.
    /// </summary>
    KeyboardShortcut? GetShortcutForAction(string actionId);

    #endregion

    #region Dispatch

    /// <summary>
    /// Attempts to handle a key event.
    /// </summary>
    /// <returns>True if a shortcut was triggered</returns>
    Task<bool> TryHandleAsync(Key key, KeyModifiers modifiers, ShortcutContext context);

    /// <summary>
    /// Synchronous version for compatibility.
    /// </summary>
    bool TryHandle(Key key, KeyModifiers modifiers, ShortcutContext context, out string? actionId);

    #endregion

    #region Persistence

    /// <summary>
    /// Saves customized shortcuts to settings.
    /// </summary>
    Task SaveCustomizationsAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// Loads customized shortcuts from settings.
    /// </summary>
    Task LoadCustomizationsAsync(CancellationToken cancellationToken = default);

    #endregion
}

/// <summary>
/// Event args for shortcut triggered events.
/// </summary>
public sealed class ShortcutTriggeredEventArgs : EventArgs
{
    public required KeyboardShortcut Shortcut { get; init; }
    public required string ActionId { get; init; }
    public required ShortcutContext Context { get; init; }
    public bool Handled { get; set; }
}
```

### 6. KeyboardShortcutService Implementation

```csharp
// src/SeniorIntern.Services/KeyboardShortcutService.cs
using Avalonia.Input;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using System.Collections.Concurrent;

namespace SeniorIntern.Services;

/// <summary>
/// Service for managing keyboard shortcuts and dispatching actions.
/// </summary>
public sealed class KeyboardShortcutService : IKeyboardShortcutService
{
    private readonly ISettingsService _settingsService;
    private readonly ILogger<KeyboardShortcutService>? _logger;

    private readonly ConcurrentDictionary<KeyboardShortcut, ShortcutHandler> _shortcuts = new();
    private readonly ConcurrentDictionary<string, ShortcutHandler> _actionHandlers = new();
    private readonly ConcurrentDictionary<string, ShortcutActionRegistration> _actionRegistrations = new();
    private readonly ConcurrentDictionary<ShortcutContext, List<KeyboardShortcut>> _contextShortcuts = new();

    private readonly List<ShortcutHandler> _defaultShortcuts = new();

    public event EventHandler<ShortcutTriggeredEventArgs>? ShortcutTriggered;
    public event EventHandler? ShortcutsChanged;

    public KeyboardShortcutService(
        ISettingsService settingsService,
        ILogger<KeyboardShortcutService>? logger = null)
    {
        _settingsService = settingsService;
        _logger = logger;

        RegisterDefaultShortcuts();
    }

    #region Default Shortcuts

    private void RegisterDefaultShortcuts()
    {
        // ═══════════════════════════════════════════════════════════
        // Global Shortcuts
        // ═══════════════════════════════════════════════════════════

        RegisterDefault(
            KeyboardShortcut.CtrlShift(Key.A),
            "ApplyAllChanges",
            "Apply all pending changes",
            ShortcutContext.Global,
            ShortcutCategory.General);

        RegisterDefault(
            KeyboardShortcut.CtrlShift(Key.U),
            "UndoLastChange",
            "Undo last file change",
            ShortcutContext.Global,
            ShortcutCategory.History);

        RegisterDefault(
            KeyboardShortcut.CtrlShift(Key.Z),
            "UndoLastChange",
            "Undo last file change (alternate)",
            ShortcutContext.Global,
            ShortcutCategory.History);

        RegisterDefault(
            KeyboardShortcut.CtrlShift(Key.D),
            "ShowDiff",
            "Show diff for selected code block",
            ShortcutContext.Global,
            ShortcutCategory.DiffViewer);

        RegisterDefault(
            KeyboardShortcut.Ctrl(Key.OemComma),
            "OpenSettings",
            "Open settings",
            ShortcutContext.Global,
            ShortcutCategory.General);

        RegisterDefault(
            KeyboardShortcut.Ctrl(Key.N),
            "NewChat",
            "Start new chat",
            ShortcutContext.Global,
            ShortcutCategory.Chat);

        RegisterDefault(
            KeyboardShortcut.KeyOnly(Key.F1),
            "ShowShortcutsHelp",
            "Show keyboard shortcuts help",
            ShortcutContext.Global,
            ShortcutCategory.General);

        RegisterDefault(
            KeyboardShortcut.CtrlShift(Key.H),
            "ToggleHistory",
            "Toggle change history panel",
            ShortcutContext.Global,
            ShortcutCategory.History);

        // ═══════════════════════════════════════════════════════════
        // Chat Input Shortcuts
        // ═══════════════════════════════════════════════════════════

        RegisterDefault(
            KeyboardShortcut.Ctrl(Key.Return),
            "SendMessage",
            "Send message",
            ShortcutContext.ChatInput,
            ShortcutCategory.Chat);

        RegisterDefault(
            KeyboardShortcut.KeyOnly(Key.Escape),
            "CancelGeneration",
            "Cancel generation",
            ShortcutContext.ChatInput,
            ShortcutCategory.Chat);

        RegisterDefault(
            KeyboardShortcut.Ctrl(Key.L),
            "ClearChat",
            "Clear chat history",
            ShortcutContext.ChatInput,
            ShortcutCategory.Chat);

        RegisterDefault(
            KeyboardShortcut.Ctrl(Key.Up),
            "PreviousMessage",
            "Edit previous message",
            ShortcutContext.ChatInput,
            ShortcutCategory.Chat);

        // ═══════════════════════════════════════════════════════════
        // Code Block Shortcuts
        // ═══════════════════════════════════════════════════════════

        RegisterDefault(
            KeyboardShortcut.Ctrl(Key.Return),
            "ApplyBlock",
            "Apply code block",
            ShortcutContext.CodeBlock,
            ShortcutCategory.CodeBlocks);

        RegisterDefault(
            KeyboardShortcut.Ctrl(Key.C),
            "CopyBlock",
            "Copy code block",
            ShortcutContext.CodeBlock,
            ShortcutCategory.CodeBlocks);

        RegisterDefault(
            KeyboardShortcut.Ctrl(Key.D),
            "ShowBlockDiff",
            "Show diff for code block",
            ShortcutContext.CodeBlock,
            ShortcutCategory.CodeBlocks);

        RegisterDefault(
            KeyboardShortcut.Ctrl(Key.O),
            "OpenInEditor",
            "Open target file in editor",
            ShortcutContext.CodeBlock,
            ShortcutCategory.CodeBlocks);

        RegisterDefault(
            KeyboardShortcut.CtrlShift(Key.O),
            "ApplyWithOptions",
            "Apply with options dialog",
            ShortcutContext.CodeBlock,
            ShortcutCategory.CodeBlocks);

        RegisterDefault(
            KeyboardShortcut.Ctrl(Key.I),
            "InsertAtCursor",
            "Insert at cursor position",
            ShortcutContext.CodeBlock,
            ShortcutCategory.CodeBlocks);

        // ═══════════════════════════════════════════════════════════
        // Diff Viewer Shortcuts
        // ═══════════════════════════════════════════════════════════

        RegisterDefault(
            KeyboardShortcut.KeyOnly(Key.Return),
            "ApplyChanges",
            "Apply changes",
            ShortcutContext.DiffViewer,
            ShortcutCategory.DiffViewer);

        RegisterDefault(
            KeyboardShortcut.KeyOnly(Key.Escape),
            "CloseDiff",
            "Close diff viewer",
            ShortcutContext.DiffViewer,
            ShortcutCategory.DiffViewer);

        RegisterDefault(
            KeyboardShortcut.KeyOnly(Key.J),
            "NextHunk",
            "Navigate to next hunk",
            ShortcutContext.DiffViewer,
            ShortcutCategory.DiffViewer);

        RegisterDefault(
            KeyboardShortcut.KeyOnly(Key.Down),
            "NextHunk",
            "Navigate to next hunk",
            ShortcutContext.DiffViewer,
            ShortcutCategory.DiffViewer);

        RegisterDefault(
            KeyboardShortcut.KeyOnly(Key.K),
            "PreviousHunk",
            "Navigate to previous hunk",
            ShortcutContext.DiffViewer,
            ShortcutCategory.DiffViewer);

        RegisterDefault(
            KeyboardShortcut.KeyOnly(Key.Up),
            "PreviousHunk",
            "Navigate to previous hunk",
            ShortcutContext.DiffViewer,
            ShortcutCategory.DiffViewer);

        RegisterDefault(
            KeyboardShortcut.KeyOnly(Key.A),
            "AcceptAllHunks",
            "Accept all hunks",
            ShortcutContext.DiffViewer,
            ShortcutCategory.DiffViewer);

        RegisterDefault(
            KeyboardShortcut.KeyOnly(Key.R),
            "RejectAllHunks",
            "Reject all hunks",
            ShortcutContext.DiffViewer,
            ShortcutCategory.DiffViewer);

        RegisterDefault(
            KeyboardShortcut.KeyOnly(Key.Space),
            "ToggleHunk",
            "Toggle current hunk selection",
            ShortcutContext.DiffViewer,
            ShortcutCategory.DiffViewer);

        RegisterDefault(
            KeyboardShortcut.Ctrl(Key.D1),
            "SideBySideView",
            "Side-by-side view",
            ShortcutContext.DiffViewer,
            ShortcutCategory.DiffViewer);

        RegisterDefault(
            KeyboardShortcut.Ctrl(Key.D2),
            "InlineView",
            "Inline view",
            ShortcutContext.DiffViewer,
            ShortcutCategory.DiffViewer);

        RegisterDefault(
            KeyboardShortcut.Ctrl(Key.D3),
            "UnifiedView",
            "Unified view",
            ShortcutContext.DiffViewer,
            ShortcutCategory.DiffViewer);

        // ═══════════════════════════════════════════════════════════
        // Navigation Shortcuts
        // ═══════════════════════════════════════════════════════════

        RegisterDefault(
            KeyboardShortcut.Ctrl(Key.Tab),
            "NextChat",
            "Switch to next chat",
            ShortcutContext.Global,
            ShortcutCategory.Navigation);

        RegisterDefault(
            KeyboardShortcut.CtrlShift(Key.Tab),
            "PreviousChat",
            "Switch to previous chat",
            ShortcutContext.Global,
            ShortcutCategory.Navigation);

        RegisterDefault(
            KeyboardShortcut.Ctrl(Key.W),
            "CloseChat",
            "Close current chat",
            ShortcutContext.Global,
            ShortcutCategory.Navigation);

        // Ctrl+1 through Ctrl+9 for chat switching
        for (int i = 1; i <= 9; i++)
        {
            var key = (Key)(Key.D1 + i - 1);
            RegisterDefault(
                KeyboardShortcut.Ctrl(key),
                $"SwitchToChat{i}",
                $"Switch to chat {i}",
                ShortcutContext.Global,
                ShortcutCategory.Navigation);
        }

        // ═══════════════════════════════════════════════════════════
        // File Tree Shortcuts
        // ═══════════════════════════════════════════════════════════

        RegisterDefault(
            KeyboardShortcut.KeyOnly(Key.Return),
            "OpenFile",
            "Open selected file",
            ShortcutContext.FileTree,
            ShortcutCategory.FileOperations);

        RegisterDefault(
            KeyboardShortcut.KeyOnly(Key.Delete),
            "DeleteFile",
            "Delete selected file",
            ShortcutContext.FileTree,
            ShortcutCategory.FileOperations);

        RegisterDefault(
            KeyboardShortcut.KeyOnly(Key.F2),
            "RenameFile",
            "Rename selected file",
            ShortcutContext.FileTree,
            ShortcutCategory.FileOperations);

        RegisterDefault(
            KeyboardShortcut.Ctrl(Key.C),
            "CopyFilePath",
            "Copy file path",
            ShortcutContext.FileTree,
            ShortcutCategory.FileOperations);

        // ═══════════════════════════════════════════════════════════
        // Change History Shortcuts
        // ═══════════════════════════════════════════════════════════

        RegisterDefault(
            KeyboardShortcut.KeyOnly(Key.Return),
            "ViewChange",
            "View selected change",
            ShortcutContext.ChangeHistory,
            ShortcutCategory.History);

        RegisterDefault(
            KeyboardShortcut.Ctrl(Key.Z),
            "UndoChange",
            "Undo selected change",
            ShortcutContext.ChangeHistory,
            ShortcutCategory.History);
    }

    private void RegisterDefault(
        KeyboardShortcut shortcut,
        string actionId,
        string description,
        ShortcutContext context,
        ShortcutCategory category)
    {
        var handler = new ShortcutHandler
        {
            Shortcut = shortcut,
            ActionId = actionId,
            Description = description,
            Context = context,
            Category = category,
            DefaultShortcut = shortcut
        };

        _defaultShortcuts.Add(handler);
        RegisterHandler(handler);
    }

    #endregion

    #region Registration

    public void Register(
        KeyboardShortcut shortcut,
        string actionId,
        string description,
        ShortcutContext context,
        ShortcutCategory category = ShortcutCategory.General)
    {
        var handler = new ShortcutHandler
        {
            Shortcut = shortcut,
            ActionId = actionId,
            Description = description,
            Context = context,
            Category = category,
            DefaultShortcut = shortcut
        };

        RegisterHandler(handler);
    }

    private void RegisterHandler(ShortcutHandler handler)
    {
        _shortcuts[handler.Shortcut] = handler;
        _actionHandlers[handler.ActionId] = handler;

        // Add to context index
        if (!_contextShortcuts.TryGetValue(handler.Context, out var list))
        {
            list = new List<KeyboardShortcut>();
            _contextShortcuts[handler.Context] = list;
        }

        if (!list.Contains(handler.Shortcut))
        {
            list.Add(handler.Shortcut);
        }

        _logger?.LogDebug(
            "Registered shortcut {Shortcut} for action {ActionId} in context {Context}",
            handler.Shortcut, handler.ActionId, handler.Context);
    }

    public void RegisterAction(ShortcutActionRegistration registration)
    {
        _actionRegistrations[registration.ActionId] = registration;
        _logger?.LogDebug("Registered action handler for {ActionId}", registration.ActionId);
    }

    public void Unregister(KeyboardShortcut shortcut)
    {
        if (_shortcuts.TryRemove(shortcut, out var handler))
        {
            _actionHandlers.TryRemove(handler.ActionId, out _);

            if (_contextShortcuts.TryGetValue(handler.Context, out var list))
            {
                list.Remove(shortcut);
            }

            ShortcutsChanged?.Invoke(this, EventArgs.Empty);
            _logger?.LogDebug("Unregistered shortcut {Shortcut}", shortcut);
        }
    }

    public void UnregisterAction(string actionId)
    {
        if (_actionHandlers.TryRemove(actionId, out var handler))
        {
            _shortcuts.TryRemove(handler.Shortcut, out _);

            if (_contextShortcuts.TryGetValue(handler.Context, out var list))
            {
                list.Remove(handler.Shortcut);
            }
        }

        _actionRegistrations.TryRemove(actionId, out _);
        ShortcutsChanged?.Invoke(this, EventArgs.Empty);
    }

    #endregion

    #region Customization

    public bool Rebind(string actionId, KeyboardShortcut newShortcut)
    {
        if (!_actionHandlers.TryGetValue(actionId, out var handler))
        {
            _logger?.LogWarning("Cannot rebind unknown action {ActionId}", actionId);
            return false;
        }

        // Check for conflicts
        var conflicts = GetConflicts(newShortcut, handler.Context).ToList();
        if (conflicts.Any(c => c.ActionId != actionId))
        {
            _logger?.LogWarning(
                "Cannot rebind {ActionId} to {Shortcut} - conflicts with {ConflictingAction}",
                actionId, newShortcut, conflicts.First().ActionId);
            return false;
        }

        // Remove old shortcut
        _shortcuts.TryRemove(handler.Shortcut, out _);
        if (_contextShortcuts.TryGetValue(handler.Context, out var list))
        {
            list.Remove(handler.Shortcut);
        }

        // Create updated handler
        var updatedHandler = handler.WithShortcut(newShortcut);
        _shortcuts[newShortcut] = updatedHandler;
        _actionHandlers[actionId] = updatedHandler;

        if (!_contextShortcuts.TryGetValue(handler.Context, out list))
        {
            list = new List<KeyboardShortcut>();
            _contextShortcuts[handler.Context] = list;
        }
        list.Add(newShortcut);

        ShortcutsChanged?.Invoke(this, EventArgs.Empty);
        _logger?.LogInformation(
            "Rebound action {ActionId} from {OldShortcut} to {NewShortcut}",
            actionId, handler.Shortcut, newShortcut);

        return true;
    }

    public void ResetToDefault(string actionId)
    {
        var defaultHandler = _defaultShortcuts.FirstOrDefault(h => h.ActionId == actionId);
        if (defaultHandler is null)
        {
            _logger?.LogWarning("No default shortcut for action {ActionId}", actionId);
            return;
        }

        if (_actionHandlers.TryGetValue(actionId, out var current))
        {
            _shortcuts.TryRemove(current.Shortcut, out _);
        }

        var restoredHandler = new ShortcutHandler
        {
            Shortcut = defaultHandler.Shortcut,
            ActionId = defaultHandler.ActionId,
            Description = defaultHandler.Description,
            Context = defaultHandler.Context,
            Category = defaultHandler.Category,
            DefaultShortcut = defaultHandler.Shortcut,
            IsCustom = false
        };

        RegisterHandler(restoredHandler);
        ShortcutsChanged?.Invoke(this, EventArgs.Empty);
    }

    public void ResetAllToDefaults()
    {
        _shortcuts.Clear();
        _actionHandlers.Clear();
        _contextShortcuts.Clear();

        foreach (var handler in _defaultShortcuts)
        {
            RegisterHandler(new ShortcutHandler
            {
                Shortcut = handler.Shortcut,
                ActionId = handler.ActionId,
                Description = handler.Description,
                Context = handler.Context,
                Category = handler.Category,
                DefaultShortcut = handler.Shortcut,
                IsCustom = false
            });
        }

        ShortcutsChanged?.Invoke(this, EventArgs.Empty);
        _logger?.LogInformation("Reset all shortcuts to defaults");
    }

    public void SetEnabled(string actionId, bool enabled)
    {
        if (_actionHandlers.TryGetValue(actionId, out var handler))
        {
            handler.IsEnabled = enabled;
            ShortcutsChanged?.Invoke(this, EventArgs.Empty);
        }
    }

    #endregion

    #region Query

    public ShortcutHandler? GetHandler(KeyboardShortcut shortcut)
    {
        return _shortcuts.TryGetValue(shortcut, out var handler) ? handler : null;
    }

    public ShortcutHandler? GetHandlerByActionId(string actionId)
    {
        return _actionHandlers.TryGetValue(actionId, out var handler) ? handler : null;
    }

    public IEnumerable<ShortcutHandler> GetHandlersForContext(ShortcutContext context)
    {
        if (!_contextShortcuts.TryGetValue(context, out var shortcuts))
        {
            return Enumerable.Empty<ShortcutHandler>();
        }

        return shortcuts
            .Select(s => _shortcuts.TryGetValue(s, out var h) ? h : null)
            .Where(h => h is not null)!;
    }

    public IEnumerable<ShortcutHandler> GetHandlersByCategory(ShortcutCategory category)
    {
        return _actionHandlers.Values.Where(h => h.Category == category);
    }

    public IEnumerable<ShortcutHandler> GetAllHandlers()
    {
        return _actionHandlers.Values;
    }

    public IEnumerable<ShortcutHandler> GetConflicts(KeyboardShortcut shortcut, ShortcutContext context)
    {
        // A conflict exists if:
        // 1. Same shortcut in same context
        // 2. Same shortcut where one is Global (global conflicts with all)

        return _shortcuts.Values.Where(h =>
            h.Shortcut == shortcut &&
            (h.Context == context ||
             h.Context == ShortcutContext.Global ||
             context == ShortcutContext.Global));
    }

    public KeyboardShortcut? GetShortcutForAction(string actionId)
    {
        return _actionHandlers.TryGetValue(actionId, out var handler)
            ? handler.Shortcut
            : null;
    }

    #endregion

    #region Dispatch

    public async Task<bool> TryHandleAsync(Key key, KeyModifiers modifiers, ShortcutContext context)
    {
        var shortcut = new KeyboardShortcut(key, modifiers);

        // Try context-specific first
        if (TryFindHandler(shortcut, context, out var handler) ||
            TryFindHandler(shortcut, ShortcutContext.Global, out handler))
        {
            if (handler is null || !handler.IsEnabled)
                return false;

            _logger?.LogDebug(
                "Handling shortcut {Shortcut} as action {ActionId}",
                shortcut, handler.ActionId);

            // Raise event
            var args = new ShortcutTriggeredEventArgs
            {
                Shortcut = shortcut,
                ActionId = handler.ActionId,
                Context = context
            };
            ShortcutTriggered?.Invoke(this, args);

            if (args.Handled)
                return true;

            // Try to execute action
            if (_actionRegistrations.TryGetValue(handler.ActionId, out var registration))
            {
                if (registration.CanExecute?.Invoke() != false)
                {
                    var result = await registration.Handler(context);
                    return result;
                }
            }

            // Action registered but no handler - still mark as handled
            return true;
        }

        return false;
    }

    public bool TryHandle(Key key, KeyModifiers modifiers, ShortcutContext context, out string? actionId)
    {
        var shortcut = new KeyboardShortcut(key, modifiers);

        if (TryFindHandler(shortcut, context, out var handler) ||
            TryFindHandler(shortcut, ShortcutContext.Global, out handler))
        {
            if (handler is not null && handler.IsEnabled)
            {
                actionId = handler.ActionId;
                return true;
            }
        }

        actionId = null;
        return false;
    }

    private bool TryFindHandler(KeyboardShortcut shortcut, ShortcutContext context, out ShortcutHandler? handler)
    {
        if (_shortcuts.TryGetValue(shortcut, out handler))
        {
            if (handler.Context == context)
                return true;
        }

        handler = null;
        return false;
    }

    #endregion

    #region Persistence

    public async Task SaveCustomizationsAsync(CancellationToken cancellationToken = default)
    {
        var customizations = _actionHandlers.Values
            .Where(h => h.IsCustom)
            .Select(h => new ShortcutCustomization
            {
                ActionId = h.ActionId,
                ShortcutString = h.Shortcut.ToString(),
                IsEnabled = h.IsEnabled
            })
            .ToList();

        var settings = await _settingsService.GetSettingsAsync(cancellationToken);
        settings.CustomShortcuts = customizations;
        await _settingsService.SaveSettingsAsync(settings, cancellationToken);

        _logger?.LogInformation("Saved {Count} shortcut customizations", customizations.Count);
    }

    public async Task LoadCustomizationsAsync(CancellationToken cancellationToken = default)
    {
        var settings = await _settingsService.GetSettingsAsync(cancellationToken);

        if (settings.CustomShortcuts is null || settings.CustomShortcuts.Count == 0)
            return;

        foreach (var customization in settings.CustomShortcuts)
        {
            if (KeyboardShortcut.TryParse(customization.ShortcutString, out var shortcut))
            {
                Rebind(customization.ActionId, shortcut);

                if (!customization.IsEnabled)
                {
                    SetEnabled(customization.ActionId, false);
                }
            }
        }

        _logger?.LogInformation(
            "Loaded {Count} shortcut customizations",
            settings.CustomShortcuts.Count);
    }

    #endregion
}

/// <summary>
/// Persisted shortcut customization.
/// </summary>
public sealed class ShortcutCustomization
{
    public required string ActionId { get; init; }
    public required string ShortcutString { get; init; }
    public bool IsEnabled { get; init; } = true;
}
```

### 7. ShortcutManager (UI Integration)

```csharp
// src/SeniorIntern.Desktop/Services/ShortcutManager.cs
using Avalonia.Controls;
using Avalonia.Input;
using Avalonia.Interactivity;
using Avalonia.VisualTree;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Desktop.Views;

namespace SeniorIntern.Desktop.Services;

/// <summary>
/// Manages keyboard event handling and context detection for the main window.
/// </summary>
public sealed class ShortcutManager : IDisposable
{
    private readonly Window _window;
    private readonly IKeyboardShortcutService _shortcutService;
    private readonly Func<string, Task> _actionDispatcher;

    private bool _isDisposed;

    public ShortcutManager(
        Window window,
        IKeyboardShortcutService shortcutService,
        Func<string, Task> actionDispatcher)
    {
        _window = window;
        _shortcutService = shortcutService;
        _actionDispatcher = actionDispatcher;

        _window.KeyDown += OnKeyDown;
    }

    private async void OnKeyDown(object? sender, KeyEventArgs e)
    {
        // Skip if already handled
        if (e.Handled)
            return;

        // Skip modifier-only key presses
        if (IsModifierKey(e.Key))
            return;

        var context = DetermineContext();

        if (_shortcutService.TryHandle(e.Key, e.KeyModifiers, context, out var actionId))
        {
            e.Handled = true;
            await _actionDispatcher(actionId!);
        }
    }

    private ShortcutContext DetermineContext()
    {
        // Check for modal dialogs first
        if (IsModalOpen())
            return ShortcutContext.Modal;

        var focused = TopLevel.GetTopLevel(_window)?.FocusManager?.GetFocusedElement();

        // Check specific control types
        if (focused is TextBox textBox)
        {
            if (textBox.Name == "ChatInputTextBox" || IsInChatInput(textBox))
                return ShortcutContext.ChatInput;
        }

        // Check parent containers
        if (IsInControl<DiffViewerControl>(focused))
            return ShortcutContext.DiffViewer;

        if (IsInControl<CodeBlockControl>(focused))
            return ShortcutContext.CodeBlock;

        if (IsInControl<ChatPanel>(focused))
            return ShortcutContext.ChatView;

        if (IsInControl<FileTreeControl>(focused))
            return ShortcutContext.FileTree;

        if (IsInControl<ChangeHistoryPanel>(focused))
            return ShortcutContext.ChangeHistory;

        if (IsInControl<SettingsPanel>(focused))
            return ShortcutContext.Settings;

        return ShortcutContext.Global;
    }

    private bool IsModalOpen()
    {
        // Check if any modal overlay is visible
        var overlay = _window.FindDescendantOfType<ModalOverlay>();
        return overlay?.IsVisible == true;
    }

    private bool IsInChatInput(TextBox textBox)
    {
        return textBox.FindAncestorOfType<ChatInputControl>() is not null;
    }

    private bool IsInControl<T>(IInputElement? element) where T : Control
    {
        if (element is not Visual visual)
            return false;

        return visual.FindAncestorOfType<T>() is not null;
    }

    private static bool IsModifierKey(Key key)
    {
        return key switch
        {
            Key.LeftCtrl or Key.RightCtrl => true,
            Key.LeftShift or Key.RightShift => true,
            Key.LeftAlt or Key.RightAlt => true,
            Key.LWin or Key.RWin => true,
            _ => false
        };
    }

    public void Dispose()
    {
        if (_isDisposed)
            return;

        _window.KeyDown -= OnKeyDown;
        _isDisposed = true;
    }
}
```

### 8. MainWindow Integration

```csharp
// src/SeniorIntern.Desktop/Views/MainWindow.axaml.cs (additions)
using SeniorIntern.Desktop.Services;

public partial class MainWindow : Window
{
    private ShortcutManager? _shortcutManager;
    private readonly IKeyboardShortcutService _shortcutService;

    public MainWindow(IKeyboardShortcutService shortcutService)
    {
        _shortcutService = shortcutService;
        InitializeComponent();
    }

    protected override void OnOpened(EventArgs e)
    {
        base.OnOpened(e);

        _shortcutManager = new ShortcutManager(
            this,
            _shortcutService,
            HandleShortcutActionAsync);

        // Register action handlers
        RegisterActionHandlers();
    }

    protected override void OnClosed(EventArgs e)
    {
        _shortcutManager?.Dispose();
        base.OnClosed(e);
    }

    private void RegisterActionHandlers()
    {
        var vm = DataContext as MainWindowViewModel;
        if (vm is null) return;

        _shortcutService.RegisterAction(new ShortcutActionRegistration
        {
            ActionId = "ApplyAllChanges",
            Handler = async ctx =>
            {
                if (vm.ApplyAllPendingChangesCommand.CanExecute(null))
                {
                    await vm.ApplyAllPendingChangesCommand.ExecuteAsync(null);
                    return true;
                }
                return false;
            },
            CanExecute = () => vm.ApplyAllPendingChangesCommand.CanExecute(null),
            Category = ShortcutCategory.General
        });

        _shortcutService.RegisterAction(new ShortcutActionRegistration
        {
            ActionId = "UndoLastChange",
            Handler = async ctx =>
            {
                if (vm.UndoLastChangeCommand.CanExecute(null))
                {
                    await vm.UndoLastChangeCommand.ExecuteAsync(null);
                    return true;
                }
                return false;
            },
            CanExecute = () => vm.UndoLastChangeCommand.CanExecute(null),
            Category = ShortcutCategory.History
        });

        _shortcutService.RegisterAction(new ShortcutActionRegistration
        {
            ActionId = "SendMessage",
            Handler = async ctx =>
            {
                if (vm.ChatViewModel.SendMessageCommand.CanExecute(null))
                {
                    await vm.ChatViewModel.SendMessageCommand.ExecuteAsync(null);
                    return true;
                }
                return false;
            },
            CanExecute = () => vm.ChatViewModel.SendMessageCommand.CanExecute(null),
            Category = ShortcutCategory.Chat
        });

        _shortcutService.RegisterAction(new ShortcutActionRegistration
        {
            ActionId = "CancelGeneration",
            Handler = async ctx =>
            {
                vm.ChatViewModel.CancelGenerationCommand.Execute(null);
                return true;
            },
            CanExecute = () => vm.ChatViewModel.IsGenerating,
            Category = ShortcutCategory.Chat
        });

        _shortcutService.RegisterAction(new ShortcutActionRegistration
        {
            ActionId = "OpenSettings",
            Handler = async ctx =>
            {
                vm.OpenSettingsCommand.Execute(null);
                return true;
            },
            Category = ShortcutCategory.General
        });

        _shortcutService.RegisterAction(new ShortcutActionRegistration
        {
            ActionId = "NewChat",
            Handler = async ctx =>
            {
                vm.NewChatCommand.Execute(null);
                return true;
            },
            Category = ShortcutCategory.Chat
        });

        _shortcutService.RegisterAction(new ShortcutActionRegistration
        {
            ActionId = "ShowShortcutsHelp",
            Handler = async ctx =>
            {
                vm.ShowShortcutsHelpCommand.Execute(null);
                return true;
            },
            Category = ShortcutCategory.General
        });

        // Register navigation shortcuts for Ctrl+1-9
        for (int i = 1; i <= 9; i++)
        {
            var index = i - 1;
            _shortcutService.RegisterAction(new ShortcutActionRegistration
            {
                ActionId = $"SwitchToChat{i}",
                Handler = async ctx =>
                {
                    if (index < vm.Chats.Count)
                    {
                        vm.SelectedChat = vm.Chats[index];
                        return true;
                    }
                    return false;
                },
                CanExecute = () => index < vm.Chats.Count,
                Category = ShortcutCategory.Navigation
            });
        }
    }

    private async Task HandleShortcutActionAsync(string actionId)
    {
        // Fallback handler for actions not registered via RegisterAction
        var vm = DataContext as MainWindowViewModel;
        if (vm is null) return;

        switch (actionId)
        {
            case "NextChat":
                vm.NextChatCommand.Execute(null);
                break;
            case "PreviousChat":
                vm.PreviousChatCommand.Execute(null);
                break;
            case "CloseChat":
                vm.CloseChatCommand.Execute(null);
                break;
            case "ToggleHistory":
                vm.ToggleHistoryPanelCommand.Execute(null);
                break;
            case "ClearChat":
                vm.ChatViewModel.ClearChatCommand.Execute(null);
                break;
        }
    }
}
```

### 9. Keyboard Shortcuts Settings Panel

```xml
<!-- src/SeniorIntern.Desktop/Views/Settings/KeyboardShortcutsPanel.axaml -->
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:vm="using:SeniorIntern.Desktop.ViewModels.Settings"
             x:Class="SeniorIntern.Desktop.Views.Settings.KeyboardShortcutsPanel"
             x:DataType="vm:KeyboardShortcutsViewModel">

    <Grid RowDefinitions="Auto, Auto, *, Auto">

        <!-- Header -->
        <StackPanel Grid.Row="0" Margin="0,0,0,16">
            <TextBlock Text="Keyboard Shortcuts"
                       FontSize="20"
                       FontWeight="SemiBold" />
            <TextBlock Text="Customize keyboard shortcuts for quick access to features"
                       FontSize="13"
                       Foreground="{DynamicResource TextMuted}"
                       Margin="0,4,0,0" />
        </StackPanel>

        <!-- Search -->
        <Grid Grid.Row="1" ColumnDefinitions="*, Auto" Margin="0,0,0,16">
            <TextBox Watermark="Search shortcuts..."
                     Text="{Binding SearchQuery}"
                     Classes="search-box" />
            <Button Grid.Column="1"
                    Content="Reset All"
                    Command="{Binding ResetAllCommand}"
                    Margin="8,0,0,0" />
        </Grid>

        <!-- Shortcuts List -->
        <ScrollViewer Grid.Row="2">
            <ItemsControl ItemsSource="{Binding GroupedShortcuts}">
                <ItemsControl.ItemTemplate>
                    <DataTemplate>
                        <StackPanel Margin="0,0,0,24">
                            <!-- Category Header -->
                            <TextBlock Text="{Binding Category}"
                                       FontWeight="SemiBold"
                                       FontSize="14"
                                       Margin="0,0,0,8" />

                            <!-- Shortcuts in Category -->
                            <ItemsControl ItemsSource="{Binding Handlers}">
                                <ItemsControl.ItemTemplate>
                                    <DataTemplate>
                                        <Grid ColumnDefinitions="*, Auto, Auto"
                                              Margin="0,4"
                                              Classes="shortcut-row">

                                            <!-- Description -->
                                            <StackPanel VerticalAlignment="Center">
                                                <TextBlock Text="{Binding Description}" />
                                                <TextBlock Text="{Binding Context, StringFormat='Context: {0}'}"
                                                           FontSize="11"
                                                           Foreground="{DynamicResource TextMuted}"
                                                           IsVisible="{Binding Context, Converter={x:Static ObjectConverters.IsNotNull}}" />
                                            </StackPanel>

                                            <!-- Shortcut Display -->
                                            <Border Grid.Column="1"
                                                    Classes="shortcut-badge"
                                                    Padding="8,4"
                                                    Margin="8,0">
                                                <TextBlock Text="{Binding DisplayString}"
                                                           FontFamily="Consolas, Menlo, monospace"
                                                           FontSize="12" />
                                            </Border>

                                            <!-- Actions -->
                                            <StackPanel Grid.Column="2"
                                                        Orientation="Horizontal"
                                                        Spacing="4">
                                                <Button ToolTip.Tip="Change shortcut"
                                                        Command="{Binding $parent[ItemsControl].DataContext.EditShortcutCommand}"
                                                        CommandParameter="{Binding}"
                                                        Classes="icon-button">
                                                    <PathIcon Data="{StaticResource EditIcon}" Width="14" Height="14" />
                                                </Button>
                                                <Button ToolTip.Tip="Reset to default"
                                                        Command="{Binding $parent[ItemsControl].DataContext.ResetShortcutCommand}"
                                                        CommandParameter="{Binding}"
                                                        IsVisible="{Binding IsCustom}"
                                                        Classes="icon-button">
                                                    <PathIcon Data="{StaticResource ResetIcon}" Width="14" Height="14" />
                                                </Button>
                                            </StackPanel>
                                        </Grid>
                                    </DataTemplate>
                                </ItemsControl.ItemTemplate>
                            </ItemsControl>
                        </StackPanel>
                    </DataTemplate>
                </ItemsControl.ItemTemplate>
            </ItemsControl>
        </ScrollViewer>

        <!-- Footer -->
        <Border Grid.Row="3"
                Classes="info-banner"
                Padding="12"
                Margin="0,16,0,0">
            <StackPanel Orientation="Horizontal" Spacing="8">
                <PathIcon Data="{StaticResource InfoIcon}" Width="16" Height="16" />
                <TextBlock Text="Press F1 anywhere to see available shortcuts for the current context"
                           FontSize="12"
                           VerticalAlignment="Center" />
            </StackPanel>
        </Border>
    </Grid>
</UserControl>
```

### 10. KeyboardShortcutsViewModel

```csharp
// src/SeniorIntern.Desktop/ViewModels/Settings/KeyboardShortcutsViewModel.cs
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;

namespace SeniorIntern.Desktop.ViewModels.Settings;

public partial class KeyboardShortcutsViewModel : ViewModelBase
{
    private readonly IKeyboardShortcutService _shortcutService;
    private readonly IDialogService _dialogService;

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(GroupedShortcuts))]
    private string _searchQuery = string.Empty;

    public IEnumerable<ShortcutCategoryGroup> GroupedShortcuts =>
        GetGroupedShortcuts();

    public KeyboardShortcutsViewModel(
        IKeyboardShortcutService shortcutService,
        IDialogService dialogService)
    {
        _shortcutService = shortcutService;
        _dialogService = dialogService;

        _shortcutService.ShortcutsChanged += (s, e) => OnPropertyChanged(nameof(GroupedShortcuts));
    }

    private IEnumerable<ShortcutCategoryGroup> GetGroupedShortcuts()
    {
        var handlers = _shortcutService.GetAllHandlers();

        if (!string.IsNullOrWhiteSpace(SearchQuery))
        {
            var query = SearchQuery.ToLowerInvariant();
            handlers = handlers.Where(h =>
                h.Description.Contains(query, StringComparison.OrdinalIgnoreCase) ||
                h.ActionId.Contains(query, StringComparison.OrdinalIgnoreCase) ||
                h.DisplayString.Contains(query, StringComparison.OrdinalIgnoreCase));
        }

        return handlers
            .GroupBy(h => h.Category)
            .OrderBy(g => g.Key)
            .Select(g => new ShortcutCategoryGroup
            {
                Category = FormatCategory(g.Key),
                Handlers = g.OrderBy(h => h.Description).ToList()
            });
    }

    private static string FormatCategory(ShortcutCategory category) => category switch
    {
        ShortcutCategory.General => "General",
        ShortcutCategory.Navigation => "Navigation",
        ShortcutCategory.CodeBlocks => "Code Blocks",
        ShortcutCategory.DiffViewer => "Diff Viewer",
        ShortcutCategory.Chat => "Chat",
        ShortcutCategory.FileOperations => "File Operations",
        ShortcutCategory.History => "History & Undo",
        _ => category.ToString()
    };

    [RelayCommand]
    private async Task EditShortcutAsync(ShortcutHandler handler)
    {
        var newShortcut = await _dialogService.ShowShortcutCaptureDialogAsync(
            handler.Description,
            handler.Shortcut);

        if (newShortcut.HasValue && newShortcut.Value.IsValid)
        {
            var conflicts = _shortcutService.GetConflicts(newShortcut.Value, handler.Context).ToList();

            if (conflicts.Any(c => c.ActionId != handler.ActionId))
            {
                var confirm = await _dialogService.ShowConfirmationAsync(
                    "Shortcut Conflict",
                    $"This shortcut is already used by '{conflicts.First().Description}'. " +
                    "Do you want to replace it?");

                if (!confirm)
                    return;

                // Remove conflicting shortcut
                foreach (var conflict in conflicts.Where(c => c.ActionId != handler.ActionId))
                {
                    _shortcutService.Unregister(conflict.Shortcut);
                }
            }

            _shortcutService.Rebind(handler.ActionId, newShortcut.Value);
            await _shortcutService.SaveCustomizationsAsync();
        }
    }

    [RelayCommand]
    private async Task ResetShortcutAsync(ShortcutHandler handler)
    {
        _shortcutService.ResetToDefault(handler.ActionId);
        await _shortcutService.SaveCustomizationsAsync();
    }

    [RelayCommand]
    private async Task ResetAllAsync()
    {
        var confirm = await _dialogService.ShowConfirmationAsync(
            "Reset All Shortcuts",
            "Are you sure you want to reset all shortcuts to their defaults?");

        if (confirm)
        {
            _shortcutService.ResetAllToDefaults();
            await _shortcutService.SaveCustomizationsAsync();
        }
    }
}

public sealed class ShortcutCategoryGroup
{
    public required string Category { get; init; }
    public required IReadOnlyList<ShortcutHandler> Handlers { get; init; }
}
```

### 11. Shortcut Capture Dialog

```csharp
// src/SeniorIntern.Desktop/ViewModels/ShortcutCaptureDialogViewModel.cs
using Avalonia.Input;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using SeniorIntern.Core.Models;

namespace SeniorIntern.Desktop.ViewModels;

public partial class ShortcutCaptureDialogViewModel : ViewModelBase
{
    [ObservableProperty]
    private string _actionDescription = string.Empty;

    [ObservableProperty]
    private KeyboardShortcut _currentShortcut;

    [ObservableProperty]
    private KeyboardShortcut _capturedShortcut;

    [ObservableProperty]
    private bool _isCapturing;

    [ObservableProperty]
    private string _capturePrompt = "Press a key combination...";

    public event EventHandler<KeyboardShortcut?>? RequestClose;

    public void HandleKeyDown(KeyEventArgs e)
    {
        if (!IsCapturing)
            return;

        // Ignore modifier-only presses
        if (IsModifierKey(e.Key))
            return;

        CapturedShortcut = new KeyboardShortcut(e.Key, e.KeyModifiers);
        CapturePrompt = CapturedShortcut.ToDisplayString();
        e.Handled = true;
    }

    [RelayCommand]
    private void StartCapture()
    {
        IsCapturing = true;
        CapturedShortcut = KeyboardShortcut.None;
        CapturePrompt = "Press a key combination...";
    }

    [RelayCommand]
    private void Confirm()
    {
        RequestClose?.Invoke(this, CapturedShortcut.IsValid ? CapturedShortcut : null);
    }

    [RelayCommand]
    private void Cancel()
    {
        RequestClose?.Invoke(this, null);
    }

    [RelayCommand]
    private void Clear()
    {
        CapturedShortcut = KeyboardShortcut.None;
        CapturePrompt = "No shortcut assigned";
    }

    private static bool IsModifierKey(Key key) => key switch
    {
        Key.LeftCtrl or Key.RightCtrl => true,
        Key.LeftShift or Key.RightShift => true,
        Key.LeftAlt or Key.RightAlt => true,
        Key.LWin or Key.RWin => true,
        _ => false
    };
}
```

---

## Unit Tests

### KeyboardShortcut Tests

```csharp
// tests/SeniorIntern.Core.Tests/Models/KeyboardShortcutTests.cs
using Avalonia.Input;
using SeniorIntern.Core.Models;
using Xunit;

namespace SeniorIntern.Core.Tests.Models;

public class KeyboardShortcutTests
{
    [Fact]
    public void Constructor_SetsPropertiesCorrectly()
    {
        var shortcut = new KeyboardShortcut(Key.A, KeyModifiers.Control | KeyModifiers.Shift);

        Assert.Equal(Key.A, shortcut.Key);
        Assert.Equal(KeyModifiers.Control | KeyModifiers.Shift, shortcut.Modifiers);
        Assert.True(shortcut.HasControl);
        Assert.True(shortcut.HasShift);
        Assert.False(shortcut.HasAlt);
        Assert.False(shortcut.HasMeta);
    }

    [Fact]
    public void IsValid_ReturnsFalseForNoneKey()
    {
        var shortcut = new KeyboardShortcut(Key.None, KeyModifiers.Control);
        Assert.False(shortcut.IsValid);
    }

    [Fact]
    public void None_IsNotValid()
    {
        Assert.False(KeyboardShortcut.None.IsValid);
    }

    [Theory]
    [InlineData(Key.A, KeyModifiers.Control, "Ctrl+A")]
    [InlineData(Key.S, KeyModifiers.Control | KeyModifiers.Shift, "Ctrl+Shift+S")]
    [InlineData(Key.F1, KeyModifiers.None, "F1")]
    [InlineData(Key.Escape, KeyModifiers.None, "Esc")]
    [InlineData(Key.Return, KeyModifiers.Control, "Ctrl+Enter")]
    public void ToString_FormatsCorrectly(Key key, KeyModifiers mods, string expected)
    {
        var shortcut = new KeyboardShortcut(key, mods);
        Assert.Equal(expected, shortcut.ToString());
    }

    [Theory]
    [InlineData("Ctrl+A", Key.A, KeyModifiers.Control)]
    [InlineData("Ctrl+Shift+S", Key.S, KeyModifiers.Control | KeyModifiers.Shift)]
    [InlineData("Alt+F4", Key.F4, KeyModifiers.Alt)]
    [InlineData("F1", Key.F1, KeyModifiers.None)]
    [InlineData("Escape", Key.Escape, KeyModifiers.None)]
    public void Parse_ParsesCorrectly(string input, Key expectedKey, KeyModifiers expectedMods)
    {
        var shortcut = KeyboardShortcut.Parse(input);

        Assert.Equal(expectedKey, shortcut.Key);
        Assert.Equal(expectedMods, shortcut.Modifiers);
    }

    [Theory]
    [InlineData("")]
    [InlineData("   ")]
    [InlineData(null)]
    public void Parse_InvalidInput_ReturnsNone(string? input)
    {
        var shortcut = KeyboardShortcut.Parse(input!);
        Assert.Equal(KeyboardShortcut.None, shortcut);
    }

    [Fact]
    public void TryParse_ValidInput_ReturnsTrue()
    {
        var result = KeyboardShortcut.TryParse("Ctrl+A", out var shortcut);

        Assert.True(result);
        Assert.Equal(Key.A, shortcut.Key);
    }

    [Fact]
    public void TryParse_InvalidInput_ReturnsFalse()
    {
        var result = KeyboardShortcut.TryParse("NotAKey", out var shortcut);

        Assert.False(result);
        Assert.False(shortcut.IsValid);
    }

    [Fact]
    public void Equality_SameShortcuts_AreEqual()
    {
        var shortcut1 = new KeyboardShortcut(Key.A, KeyModifiers.Control);
        var shortcut2 = new KeyboardShortcut(Key.A, KeyModifiers.Control);

        Assert.Equal(shortcut1, shortcut2);
        Assert.True(shortcut1 == shortcut2);
        Assert.Equal(shortcut1.GetHashCode(), shortcut2.GetHashCode());
    }

    [Fact]
    public void Equality_DifferentShortcuts_AreNotEqual()
    {
        var shortcut1 = new KeyboardShortcut(Key.A, KeyModifiers.Control);
        var shortcut2 = new KeyboardShortcut(Key.B, KeyModifiers.Control);

        Assert.NotEqual(shortcut1, shortcut2);
        Assert.True(shortcut1 != shortcut2);
    }

    [Fact]
    public void FactoryMethods_CreateCorrectShortcuts()
    {
        Assert.Equal(new KeyboardShortcut(Key.A, KeyModifiers.Control), KeyboardShortcut.Ctrl(Key.A));
        Assert.Equal(new KeyboardShortcut(Key.A, KeyModifiers.Control | KeyModifiers.Shift), KeyboardShortcut.CtrlShift(Key.A));
        Assert.Equal(new KeyboardShortcut(Key.A, KeyModifiers.Alt), KeyboardShortcut.Alt(Key.A));
        Assert.Equal(new KeyboardShortcut(Key.F1, KeyModifiers.None), KeyboardShortcut.KeyOnly(Key.F1));
    }
}
```

### KeyboardShortcutService Tests

```csharp
// tests/SeniorIntern.Services.Tests/KeyboardShortcutServiceTests.cs
using Avalonia.Input;
using Moq;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Services;
using Xunit;

namespace SeniorIntern.Services.Tests;

public class KeyboardShortcutServiceTests
{
    private readonly Mock<ISettingsService> _mockSettingsService;
    private readonly KeyboardShortcutService _service;

    public KeyboardShortcutServiceTests()
    {
        _mockSettingsService = new Mock<ISettingsService>();
        _mockSettingsService
            .Setup(x => x.GetSettingsAsync(It.IsAny<CancellationToken>()))
            .ReturnsAsync(new AppSettings());

        _service = new KeyboardShortcutService(_mockSettingsService.Object);
    }

    [Fact]
    public void DefaultShortcuts_AreRegistered()
    {
        var handlers = _service.GetAllHandlers().ToList();

        Assert.NotEmpty(handlers);
        Assert.Contains(handlers, h => h.ActionId == "ApplyAllChanges");
        Assert.Contains(handlers, h => h.ActionId == "SendMessage");
        Assert.Contains(handlers, h => h.ActionId == "UndoLastChange");
    }

    [Fact]
    public void Register_AddsShortcut()
    {
        var shortcut = new KeyboardShortcut(Key.X, KeyModifiers.Control | KeyModifiers.Alt);

        _service.Register(shortcut, "TestAction", "Test", ShortcutContext.Global);

        var handler = _service.GetHandler(shortcut);
        Assert.NotNull(handler);
        Assert.Equal("TestAction", handler.ActionId);
    }

    [Fact]
    public void Unregister_RemovesShortcut()
    {
        var shortcut = new KeyboardShortcut(Key.Y, KeyModifiers.Control);
        _service.Register(shortcut, "RemoveMe", "Test", ShortcutContext.Global);

        _service.Unregister(shortcut);

        Assert.Null(_service.GetHandler(shortcut));
    }

    [Fact]
    public void GetHandlersForContext_ReturnsCorrectHandlers()
    {
        var chatHandlers = _service.GetHandlersForContext(ShortcutContext.ChatInput).ToList();

        Assert.NotEmpty(chatHandlers);
        Assert.All(chatHandlers, h => Assert.Equal(ShortcutContext.ChatInput, h.Context));
    }

    [Fact]
    public void GetHandlersByCategory_ReturnsCorrectHandlers()
    {
        var chatHandlers = _service.GetHandlersByCategory(ShortcutCategory.Chat).ToList();

        Assert.NotEmpty(chatHandlers);
        Assert.All(chatHandlers, h => Assert.Equal(ShortcutCategory.Chat, h.Category));
    }

    [Fact]
    public void TryHandle_ContextSpecific_TakesPriority()
    {
        // Ctrl+Enter is both ChatInput (SendMessage) and CodeBlock (ApplyBlock)
        var result = _service.TryHandle(Key.Return, KeyModifiers.Control, ShortcutContext.ChatInput, out var actionId);

        Assert.True(result);
        Assert.Equal("SendMessage", actionId);
    }

    [Fact]
    public void TryHandle_FallsBackToGlobal()
    {
        // Ctrl+Shift+A is Global (ApplyAllChanges)
        var result = _service.TryHandle(Key.A, KeyModifiers.Control | KeyModifiers.Shift, ShortcutContext.ChatInput, out var actionId);

        Assert.True(result);
        Assert.Equal("ApplyAllChanges", actionId);
    }

    [Fact]
    public void TryHandle_UnknownShortcut_ReturnsFalse()
    {
        var result = _service.TryHandle(Key.Q, KeyModifiers.Control | KeyModifiers.Alt | KeyModifiers.Shift, ShortcutContext.Global, out var actionId);

        Assert.False(result);
        Assert.Null(actionId);
    }

    [Fact]
    public void Rebind_ChangesShortcut()
    {
        var newShortcut = new KeyboardShortcut(Key.F12, KeyModifiers.None);

        var result = _service.Rebind("ApplyAllChanges", newShortcut);

        Assert.True(result);
        var handler = _service.GetHandlerByActionId("ApplyAllChanges");
        Assert.NotNull(handler);
        Assert.Equal(newShortcut, handler.Shortcut);
        Assert.True(handler.IsCustom);
    }

    [Fact]
    public void Rebind_DetectsConflicts()
    {
        // Try to bind to an existing shortcut
        var conflictingShortcut = KeyboardShortcut.CtrlShift(Key.D);

        var result = _service.Rebind("ApplyAllChanges", conflictingShortcut);

        // Should fail because Ctrl+Shift+D is already "ShowDiff"
        Assert.False(result);
    }

    [Fact]
    public void ResetToDefault_RestoresOriginalShortcut()
    {
        var originalHandler = _service.GetHandlerByActionId("ApplyAllChanges");
        var originalShortcut = originalHandler!.Shortcut;

        // Change it
        _service.Rebind("ApplyAllChanges", new KeyboardShortcut(Key.F12, KeyModifiers.None));

        // Reset it
        _service.ResetToDefault("ApplyAllChanges");

        var handler = _service.GetHandlerByActionId("ApplyAllChanges");
        Assert.Equal(originalShortcut, handler!.Shortcut);
        Assert.False(handler.IsCustom);
    }

    [Fact]
    public void ResetAllToDefaults_RestoresAllShortcuts()
    {
        // Modify some shortcuts
        _service.Rebind("ApplyAllChanges", new KeyboardShortcut(Key.F12, KeyModifiers.None));
        _service.Rebind("SendMessage", new KeyboardShortcut(Key.F11, KeyModifiers.None));

        // Reset all
        _service.ResetAllToDefaults();

        // Verify originals restored
        var applyHandler = _service.GetHandlerByActionId("ApplyAllChanges");
        var sendHandler = _service.GetHandlerByActionId("SendMessage");

        Assert.False(applyHandler!.IsCustom);
        Assert.False(sendHandler!.IsCustom);
    }

    [Fact]
    public void GetConflicts_FindsOverlappingShortcuts()
    {
        var shortcut = KeyboardShortcut.CtrlShift(Key.A);

        var conflicts = _service.GetConflicts(shortcut, ShortcutContext.Global).ToList();

        Assert.NotEmpty(conflicts);
        Assert.Contains(conflicts, h => h.ActionId == "ApplyAllChanges");
    }

    [Fact]
    public void SetEnabled_DisablesShortcut()
    {
        _service.SetEnabled("ApplyAllChanges", false);

        var handler = _service.GetHandlerByActionId("ApplyAllChanges");
        Assert.False(handler!.IsEnabled);

        // Disabled shortcut should not trigger
        var result = _service.TryHandle(Key.A, KeyModifiers.Control | KeyModifiers.Shift, ShortcutContext.Global, out _);
        Assert.False(result);
    }

    [Fact]
    public async Task RegisterAction_EnablesAsyncExecution()
    {
        var executed = false;

        _service.RegisterAction(new ShortcutActionRegistration
        {
            ActionId = "ApplyAllChanges",
            Handler = async ctx =>
            {
                executed = true;
                return true;
            },
            Category = ShortcutCategory.General
        });

        await _service.TryHandleAsync(Key.A, KeyModifiers.Control | KeyModifiers.Shift, ShortcutContext.Global);

        Assert.True(executed);
    }

    [Fact]
    public void ShortcutsChanged_RaisedOnModification()
    {
        var eventRaised = false;
        _service.ShortcutsChanged += (s, e) => eventRaised = true;

        _service.Rebind("ApplyAllChanges", new KeyboardShortcut(Key.F12, KeyModifiers.None));

        Assert.True(eventRaised);
    }
}
```

---

## Files to Create

| File Path | Type | Purpose |
|-----------|------|---------|
| `src/SeniorIntern.Core/Models/KeyboardShortcut.cs` | Struct | Shortcut key combination |
| `src/SeniorIntern.Core/Models/ShortcutContext.cs` | Enum | Context definitions |
| `src/SeniorIntern.Core/Models/ShortcutHandler.cs` | Class | Handler binding |
| `src/SeniorIntern.Core/Models/ShortcutAction.cs` | Classes | Action delegate and registration |
| `src/SeniorIntern.Core/Interfaces/IKeyboardShortcutService.cs` | Interface | Service contract |
| `src/SeniorIntern.Services/KeyboardShortcutService.cs` | Class | Service implementation |
| `src/SeniorIntern.Desktop/Services/ShortcutManager.cs` | Class | UI keyboard handler |
| `src/SeniorIntern.Desktop/ViewModels/Settings/KeyboardShortcutsViewModel.cs` | ViewModel | Settings panel ViewModel |
| `src/SeniorIntern.Desktop/ViewModels/ShortcutCaptureDialogViewModel.cs` | ViewModel | Capture dialog ViewModel |
| `src/SeniorIntern.Desktop/Views/Settings/KeyboardShortcutsPanel.axaml` | View | Settings panel XAML |
| `src/SeniorIntern.Desktop/Views/Settings/KeyboardShortcutsPanel.axaml.cs` | Code-behind | Settings panel code-behind |
| `src/SeniorIntern.Desktop/Views/ShortcutCaptureDialog.axaml` | View | Capture dialog XAML |
| `tests/SeniorIntern.Core.Tests/Models/KeyboardShortcutTests.cs` | Tests | Shortcut model tests |
| `tests/SeniorIntern.Services.Tests/KeyboardShortcutServiceTests.cs` | Tests | Service tests |

## Files to Modify

| File Path | Changes |
|-----------|---------|
| `src/SeniorIntern.Core/Models/AppSettings.cs` | Add `CustomShortcuts` property |
| `src/SeniorIntern.Desktop/Views/MainWindow.axaml.cs` | Add ShortcutManager integration |
| `src/SeniorIntern.Desktop/ViewModels/MainWindowViewModel.cs` | Add shortcut-related commands |
| `src/SeniorIntern.Desktop/App.axaml.cs` | Register IKeyboardShortcutService |

---

## Default Shortcuts Reference

### Global Shortcuts

| Shortcut | Action | Description |
|----------|--------|-------------|
| Ctrl+Shift+A | ApplyAllChanges | Apply all pending changes |
| Ctrl+Shift+U | UndoLastChange | Undo last file change |
| Ctrl+Shift+Z | UndoLastChange | Undo last file change (alternate) |
| Ctrl+Shift+D | ShowDiff | Show diff for selected code block |
| Ctrl+, | OpenSettings | Open settings panel |
| Ctrl+N | NewChat | Start new chat |
| F1 | ShowShortcutsHelp | Show keyboard shortcuts help |
| Ctrl+Shift+H | ToggleHistory | Toggle change history panel |
| Ctrl+Tab | NextChat | Switch to next chat |
| Ctrl+Shift+Tab | PreviousChat | Switch to previous chat |
| Ctrl+W | CloseChat | Close current chat |
| Ctrl+1-9 | SwitchToChat1-9 | Switch to chat 1-9 |

### Chat Shortcuts

| Shortcut | Action | Context | Description |
|----------|--------|---------|-------------|
| Ctrl+Enter | SendMessage | ChatInput | Send message |
| Escape | CancelGeneration | ChatInput | Cancel generation |
| Ctrl+L | ClearChat | ChatInput | Clear chat history |
| Ctrl+Up | PreviousMessage | ChatInput | Edit previous message |

### Code Block Shortcuts

| Shortcut | Action | Description |
|----------|--------|-------------|
| Ctrl+Enter | ApplyBlock | Apply code block |
| Ctrl+C | CopyBlock | Copy code block |
| Ctrl+D | ShowBlockDiff | Show diff for code block |
| Ctrl+O | OpenInEditor | Open target file in editor |
| Ctrl+Shift+O | ApplyWithOptions | Apply with options dialog |
| Ctrl+I | InsertAtCursor | Insert at cursor position |

### Diff Viewer Shortcuts

| Shortcut | Action | Description |
|----------|--------|-------------|
| Enter | ApplyChanges | Apply changes |
| Escape | CloseDiff | Close diff viewer |
| J / Down | NextHunk | Navigate to next hunk |
| K / Up | PreviousHunk | Navigate to previous hunk |
| A | AcceptAllHunks | Accept all hunks |
| R | RejectAllHunks | Reject all hunks |
| Space | ToggleHunk | Toggle current hunk selection |
| Ctrl+1 | SideBySideView | Side-by-side view |
| Ctrl+2 | InlineView | Inline view |
| Ctrl+3 | UnifiedView | Unified view |

---

## Acceptance Criteria

### Functional Requirements

1. **Shortcut Registration**
   - [ ] All default shortcuts registered on service initialization
   - [ ] Custom shortcuts can be registered at runtime
   - [ ] Shortcuts can be unregistered
   - [ ] Duplicate shortcuts are handled via conflict detection

2. **Context Detection**
   - [ ] Correct context detected based on focused element
   - [ ] Modal context takes highest priority
   - [ ] Context-specific shortcuts override global shortcuts
   - [ ] Global shortcuts work in all non-conflicting contexts

3. **Shortcut Dispatch**
   - [ ] Key events are captured and dispatched
   - [ ] Modifier-only key presses are ignored
   - [ ] Handled events don't bubble
   - [ ] Action handlers are executed asynchronously

4. **Customization**
   - [ ] Shortcuts can be rebound to different keys
   - [ ] Shortcuts can be reset to defaults
   - [ ] All shortcuts can be reset at once
   - [ ] Customizations are persisted to settings
   - [ ] Customizations are loaded on startup

5. **Settings UI**
   - [ ] All shortcuts displayed grouped by category
   - [ ] Search/filter functionality
   - [ ] Visual indication of custom shortcuts
   - [ ] Shortcut capture dialog works correctly
   - [ ] Conflict warnings displayed

6. **Platform Support**
   - [ ] Correct display strings on Windows/Linux (Ctrl)
   - [ ] Correct display strings on macOS (symbols)
   - [ ] Key parsing handles platform variations

### Non-Functional Requirements

1. **Performance**
   - [ ] Shortcut lookup < 1ms
   - [ ] No perceptible delay in key handling
   - [ ] Context detection is efficient

2. **Accessibility**
   - [ ] All features accessible via keyboard
   - [ ] Tab navigation works in settings
   - [ ] Screen reader compatible

3. **Reliability**
   - [ ] Invalid shortcuts handled gracefully
   - [ ] Service is thread-safe
   - [ ] Persistence errors don't crash app

---

## Design Decisions

### 1. Context-Based Priority

**Decision**: Context-specific shortcuts take absolute priority over global shortcuts.

**Rationale**:
- Users expect focused context to control behavior
- Prevents confusion when same key does different things
- Allows overriding globals in specific contexts
- Standard behavior in most applications

**Trade-offs**:
- (+) Predictable behavior
- (+) Flexible customization
- (-) Same key can mean different things
- (-) Requires clear context indicators

### 2. Struct for KeyboardShortcut

**Decision**: Use a readonly struct instead of a class for KeyboardShortcut.

**Rationale**:
- Shortcuts are small, immutable value types
- Frequently used as dictionary keys (needs GetHashCode)
- No inheritance needed
- Stack allocation is efficient

**Trade-offs**:
- (+) Better performance
- (+) Natural value semantics
- (+) Safe dictionary keys
- (-) Cannot be null (use None instead)

### 3. Action Registration Separation

**Decision**: Separate shortcut registration from action handler registration.

**Rationale**:
- Shortcuts can be defined in configuration
- Handlers are defined in code with dependencies
- Allows rebinding without changing handlers
- Enables testing shortcuts without executing actions

**Trade-offs**:
- (+) More flexible architecture
- (+) Better testability
- (-) Two-step registration
- (-) Must match action IDs

### 4. String-Based Action IDs

**Decision**: Use string identifiers for actions rather than enums or types.

**Rationale**:
- Easy to persist and serialize
- Extensible without code changes
- Works well with configuration
- Simple to debug and log

**Trade-offs**:
- (+) Flexible and extensible
- (+) Easy serialization
- (-) No compile-time checking
- (-) Possible typos

### 5. Async Action Handlers

**Decision**: Action handlers return Task<bool> for async support.

**Rationale**:
- Many actions involve I/O (file operations, etc.)
- Prevents UI blocking
- Consistent with MVVM async commands
- Return value indicates if action was handled

**Trade-offs**:
- (+) Non-blocking UI
- (+) Consistent with app patterns
- (-) Slightly more complex
- (-) Fire-and-forget in key handler

### 6. Conflict Detection Over Prevention

**Decision**: Allow conflicting shortcuts to be registered but warn users.

**Rationale**:
- Users may intentionally override defaults
- Hard conflicts should be rare
- Soft conflicts (different contexts) are fine
- User education is better than restrictions

**Trade-offs**:
- (+) More user freedom
- (+) Handles intentional overrides
- (-) Possible confusion
- (-) Requires conflict UI

---

## Future Considerations

### Potential Enhancements

1. **Chord Shortcuts**
   - Support multi-key sequences (e.g., Ctrl+K, Ctrl+C)
   - Chord timeout configuration
   - Visual indicator for pending chord

2. **Command Palette**
   - Searchable command list (Ctrl+Shift+P style)
   - Shows all available actions with shortcuts
   - Fuzzy search matching

3. **Recording Macros**
   - Record sequences of actions
   - Assign to custom shortcut
   - Playback with timing control

4. **Import/Export**
   - Export shortcut configuration
   - Import from file
   - Preset configurations (VS Code style, etc.)

5. **Context-Aware Hints**
   - Overlay showing available shortcuts
   - Changes based on current context
   - Dismissable after learning

6. **Vim Mode**
   - Optional vim-style navigation
   - Modal editing support
   - Custom mode switching
