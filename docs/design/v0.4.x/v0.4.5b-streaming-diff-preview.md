# v0.4.5b: Streaming Diff Preview - Design Specification

**Status**: _PLANNED_

## Executive Summary

This specification details the **Streaming Diff Preview** system for The Senior Intern, enabling real-time diff computation and visualization while the LLM is still generating a response. As code blocks are detected and grow during token streaming, diffs are computed incrementally and displayed to the user, providing immediate visual feedback on proposed changes.

### Key Deliverables

| Component | Type | Purpose |
|-----------|------|---------|
| `DiffComputationState` | Class | Tracks state of a streaming diff computation |
| `DiffComputationStatus` | Enum | Status values (Pending, Computing, Completed, Failed, Cancelled) |
| `IStreamingDiffCoordinator` | Interface | Contract for streaming diff coordination |
| `StreamingDiffCoordinator` | Class | Orchestrates incremental diff computation |
| `DiffComputationQueue` | Class | Manages debounced diff computation requests |
| `StreamingDiffPreviewControl` | UserControl | Lightweight preview showing diff stats during streaming |
| `StreamingDiffViewModel` | ViewModel | Per-code-block diff state for UI binding |

---

## Feature Overview

```
v0.4.5b: Streaming Diff Preview
├── Core Models
│   ├── DiffComputationState
│   │   ├── BlockId (Guid, identifies code block)
│   │   ├── StartedAt (DateTime, computation start)
│   │   ├── LastUpdatedAt (DateTime, last recompute)
│   │   ├── Status (DiffComputationStatus)
│   │   ├── Result (DiffResult?, computed diff)
│   │   ├── ErrorMessage (string?, if failed)
│   │   ├── ContentHash (string, for change detection)
│   │   └── ComputationCount (int, recompute counter)
│   └── DiffComputationStatus (5 values)
│       ├── Pending (queued, not started)
│       ├── Computing (actively computing)
│       ├── Completed (finished successfully)
│       ├── Failed (error occurred)
│       └── Cancelled (aborted by user/system)
├── Coordinator Service
│   ├── IStreamingDiffCoordinator
│   │   ├── OnCodeBlockDetectedAsync()
│   │   ├── OnCodeBlockUpdatedAsync()
│   │   ├── FinalizeBlockDiffAsync()
│   │   ├── GetComputationState()
│   │   ├── CancelAll()
│   │   └── Event: DiffComputed
│   └── StreamingDiffCoordinator
│       ├── Debouncing (250ms default)
│       ├── Content hashing for change detection
│       ├── Concurrent computation management
│       └── Settings-aware (respects ShowDiffPreviewDuringStreaming)
├── Computation Queue
│   └── DiffComputationQueue
│       ├── Enqueue(CodeBlock, priority)
│       ├── ProcessAsync() (background loop)
│       ├── Debounce/coalesce updates
│       └── Priority: Finalize > Update > Detect
├── ViewModel Integration
│   ├── CodeBlockViewModel additions
│   │   ├── StreamingDiffState (DiffComputationState?)
│   │   ├── IsComputingDiff (bool)
│   │   ├── HasStreamingDiff (bool)
│   │   ├── StreamingDiffStats (string, e.g., "+5 -3")
│   │   └── ShowStreamingDiffPreview (bool)
│   └── ChatMessageViewModel additions
│       ├── ActiveDiffComputations (ObservableCollection)
│       ├── HasPendingDiffs (bool)
│       └── UpdateStreamingDiffPreviewAsync()
└── UI Components
    ├── StreamingDiffPreviewControl
    │   ├── Compact stats display (+/- counts)
    │   ├── Animated computing indicator
    │   ├── Error state display
    │   └── Click to expand full preview
    └── StreamingDiffIndicator
        ├── Pulse animation during compute
        └── Color coding by diff type
```

---

## Architecture Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           LLM Token Streaming                                │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                    LLM Response (Streaming)                          │    │
│  │   "Here's the updated code:\n```csharp\npublic class..."            │    │
│  └──────────────────────────────┬──────────────────────────────────────┘    │
│                                 │                                           │
│                                 ▼                                           │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │              CodeBlockParserService (v0.4.1f)                        │    │
│  │   Incrementally detects code blocks as tokens arrive                 │    │
│  └──────────────────────────────┬──────────────────────────────────────┘    │
│                                 │                                           │
│              ┌──────────────────┼──────────────────┐                        │
│              │ CodeBlock        │ CodeBlock        │                        │
│              │ Detected         │ Updated          │                        │
│              ▼                  ▼                  ▼                        │
└─────────────────────────────────────────────────────────────────────────────┘
                                  │
                                  ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                       StreamingDiffCoordinator                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌────────────────────────┐    ┌────────────────────────────────────────┐   │
│  │  DiffComputationQueue  │    │      Active Computations               │   │
│  │  ┌──────────────────┐  │    │  ConcurrentDictionary<Guid, State>     │   │
│  │  │ Priority Queue   │  │    │                                        │   │
│  │  │ ┌──────────────┐ │  │    │  ┌────────────┐  ┌────────────┐       │   │
│  │  │ │ Finalize (3) │ │  │    │  │ Block A    │  │ Block B    │       │   │
│  │  │ │ Update   (2) │ │  │    │  │ Computing  │  │ Completed  │       │   │
│  │  │ │ Detect   (1) │ │  │    │  │ DiffResult │  │ DiffResult │       │   │
│  │  │ └──────────────┘ │  │    │  └────────────┘  └────────────┘       │   │
│  │  └──────────────────┘  │    │                                        │   │
│  │                        │    └────────────────────────────────────────┘   │
│  │  Debounce: 250ms       │                                                 │
│  │  Coalesce: Same block  │                                                 │
│  └────────────────────────┘                                                 │
│                                                                             │
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │                        Diff Computation                               │   │
│  │                                                                       │   │
│  │  1. Check settings (ShowDiffPreviewDuringStreaming)                   │   │
│  │  2. Hash content to detect actual changes                             │   │
│  │  3. Load original file (if exists)                                    │   │
│  │  4. Compute diff via IDiffService                                     │   │
│  │  5. Update state and fire DiffComputed event                          │   │
│  │                                                                       │   │
│  └──────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                                  │
                                  │ DiffComputed Event
                                  ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                         ViewModel Layer                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌────────────────────────────────────────────────────────────────────┐     │
│  │                   CodeBlockViewModel                                │     │
│  │  ┌────────────────┐  ┌────────────────┐  ┌────────────────────┐    │     │
│  │  │ StreamingDiff  │  │ IsComputingDiff│  │ StreamingDiffStats │    │     │
│  │  │ State          │  │ = true/false   │  │ = "+12 -5 ~3"      │    │     │
│  │  └────────────────┘  └────────────────┘  └────────────────────┘    │     │
│  └────────────────────────────────────────────────────────────────────┘     │
│                                                                             │
│  ┌────────────────────────────────────────────────────────────────────┐     │
│  │                  ChatMessageViewModel                               │     │
│  │  ┌────────────────────────────────────────────────────────────┐    │     │
│  │  │ CodeBlocks: ObservableCollection<CodeBlockViewModel>       │    │     │
│  │  │ HasPendingDiffs: bool (any block computing)                │    │     │
│  │  │ TotalDiffStats: aggregated stats                           │    │     │
│  │  └────────────────────────────────────────────────────────────┘    │     │
│  └────────────────────────────────────────────────────────────────────┘     │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                                  │
                                  ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                            UI Layer                                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌────────────────────────────────────────────────────────────────────┐     │
│  │                  CodeBlockControl                                   │     │
│  │  ┌──────────────────────────────────────────────────────────────┐  │     │
│  │  │  ┌──────────────────────────────────────────────────────┐    │  │     │
│  │  │  │              Code Content (syntax highlighted)        │    │  │     │
│  │  │  └──────────────────────────────────────────────────────┘    │  │     │
│  │  │  ┌──────────────────────────────────────────────────────┐    │  │     │
│  │  │  │        StreamingDiffPreviewControl                    │    │  │     │
│  │  │  │  ┌────────────┐ ┌──────────┐ ┌─────────────────────┐ │    │  │     │
│  │  │  │  │ ⏳ or ✓    │ │ +12 -5   │ │ "Click to preview"  │ │    │  │     │
│  │  │  │  │ (spinner)  │ │ (stats)  │ │                     │ │    │  │     │
│  │  │  │  └────────────┘ └──────────┘ └─────────────────────┘ │    │  │     │
│  │  │  └──────────────────────────────────────────────────────┘    │  │     │
│  │  └──────────────────────────────────────────────────────────────┘  │     │
│  └────────────────────────────────────────────────────────────────────┘     │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Data Flow Sequence

```
┌─────────┐     ┌───────────┐     ┌────────────────┐     ┌───────────┐     ┌─────┐
│   LLM   │     │  Parser   │     │  Coordinator   │     │ ViewModel │     │ UI  │
└────┬────┘     └─────┬─────┘     └───────┬────────┘     └─────┬─────┘     └──┬──┘
     │                │                   │                    │              │
     │ Token stream   │                   │                    │              │
     │───────────────>│                   │                    │              │
     │                │                   │                    │              │
     │                │ CodeBlock         │                    │              │
     │                │ Detected (partial)│                    │              │
     │                │──────────────────>│                    │              │
     │                │                   │                    │              │
     │                │                   │ Queue diff         │              │
     │                │                   │ computation        │              │
     │                │                   │────┐               │              │
     │                │                   │    │ debounce      │              │
     │                │                   │<───┘ 250ms         │              │
     │                │                   │                    │              │
     │ More tokens    │                   │                    │              │
     │───────────────>│                   │                    │              │
     │                │                   │                    │              │
     │                │ CodeBlock Updated │                    │              │
     │                │ (more content)    │                    │              │
     │                │──────────────────>│                    │              │
     │                │                   │                    │              │
     │                │                   │ Coalesce with      │              │
     │                │                   │ pending request    │              │
     │                │                   │                    │              │
     │                │                   │ ─ ─ ─ ─ ─ ─ ─ ─ ─ │              │
     │                │                   │ Debounce expires   │              │
     │                │                   │ ─ ─ ─ ─ ─ ─ ─ ─ ─ │              │
     │                │                   │                    │              │
     │                │                   │ Compute diff       │              │
     │                │                   │ (async)            │              │
     │                │                   │────┐               │              │
     │                │                   │    │               │              │
     │                │                   │<───┘               │              │
     │                │                   │                    │              │
     │                │                   │ DiffComputed       │              │
     │                │                   │ event              │              │
     │                │                   │───────────────────>│              │
     │                │                   │                    │              │
     │                │                   │                    │ Update       │
     │                │                   │                    │ bindings     │
     │                │                   │                    │─────────────>│
     │                │                   │                    │              │
     │                │                   │                    │              │ Show
     │                │                   │                    │              │ stats
     │                │                   │                    │              │
     │ Stream done    │                   │                    │              │
     │───────────────>│                   │                    │              │
     │                │                   │                    │              │
     │                │ Block finalized   │                    │              │
     │                │──────────────────>│                    │              │
     │                │                   │                    │              │
     │                │                   │ Force final        │              │
     │                │                   │ computation        │              │
     │                │                   │────┐               │              │
     │                │                   │    │               │              │
     │                │                   │<───┘               │              │
     │                │                   │                    │              │
     │                │                   │ Final diff result  │              │
     │                │                   │───────────────────>│              │
     │                │                   │                    │              │
     │                │                   │                    │─────────────>│
     │                │                   │                    │              │
     │                │                   │                    │              │ Final
     │                │                   │                    │              │ preview
```

---

## Detailed Design

### 1. DiffComputationState Model

```csharp
// src/SeniorIntern.Core/Models/DiffComputationState.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Tracks the state of a streaming diff computation for a single code block.
/// </summary>
public sealed class DiffComputationState
{
    /// <summary>
    /// Identifier of the code block being diffed.
    /// </summary>
    public Guid BlockId { get; init; }

    /// <summary>
    /// When the first computation was requested.
    /// </summary>
    public DateTime StartedAt { get; init; } = DateTime.UtcNow;

    /// <summary>
    /// When the diff was last updated.
    /// </summary>
    public DateTime LastUpdatedAt { get; set; } = DateTime.UtcNow;

    /// <summary>
    /// Current status of the computation.
    /// </summary>
    public DiffComputationStatus Status { get; set; } = DiffComputationStatus.Pending;

    /// <summary>
    /// The computed diff result (null if not yet computed or failed).
    /// </summary>
    public DiffResult? Result { get; set; }

    /// <summary>
    /// Error message if computation failed.
    /// </summary>
    public string? ErrorMessage { get; set; }

    /// <summary>
    /// Hash of the content that was last diffed (for change detection).
    /// </summary>
    public string? ContentHash { get; set; }

    /// <summary>
    /// Number of times this diff has been recomputed.
    /// </summary>
    public int ComputationCount { get; set; }

    /// <summary>
    /// Target file path being diffed.
    /// </summary>
    public string? TargetFilePath { get; set; }

    /// <summary>
    /// Whether this is a new file (no original to compare).
    /// </summary>
    public bool IsNewFile { get; set; }

    /// <summary>
    /// Time spent computing (for diagnostics).
    /// </summary>
    public TimeSpan ComputationDuration { get; set; }

    /// <summary>
    /// Whether the diff has been finalized (streaming complete).
    /// </summary>
    public bool IsFinalized { get; set; }

    /// <summary>
    /// Whether a new computation is needed (content changed since last compute).
    /// </summary>
    public bool NeedsRecompute { get; set; }

    // ═══════════════════════════════════════════════════════════════
    // Computed Properties
    // ═══════════════════════════════════════════════════════════════

    /// <summary>
    /// Whether the computation completed successfully.
    /// </summary>
    public bool IsCompleted => Status == DiffComputationStatus.Completed;

    /// <summary>
    /// Whether the computation is currently in progress.
    /// </summary>
    public bool IsComputing => Status == DiffComputationStatus.Computing;

    /// <summary>
    /// Whether the computation failed.
    /// </summary>
    public bool IsFailed => Status == DiffComputationStatus.Failed;

    /// <summary>
    /// Whether a valid diff result is available.
    /// </summary>
    public bool HasResult => Result is not null && IsCompleted;

    /// <summary>
    /// Summary stats string for display (e.g., "+5 -3 ~2").
    /// </summary>
    public string StatsDisplay => Result?.Stats is { } stats
        ? FormatStats(stats)
        : string.Empty;

    private static string FormatStats(DiffStats stats)
    {
        var parts = new List<string>(3);
        if (stats.AddedLines > 0) parts.Add($"+{stats.AddedLines}");
        if (stats.RemovedLines > 0) parts.Add($"-{stats.RemovedLines}");
        if (stats.ModifiedLines > 0) parts.Add($"~{stats.ModifiedLines}");
        return parts.Count > 0 ? string.Join(" ", parts) : "No changes";
    }
}
```

### 2. DiffComputationStatus Enum

```csharp
// src/SeniorIntern.Core/Models/DiffComputationStatus.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Status of a streaming diff computation.
/// </summary>
public enum DiffComputationStatus
{
    /// <summary>
    /// Computation is queued but not yet started.
    /// </summary>
    Pending = 0,

    /// <summary>
    /// Computation is actively running.
    /// </summary>
    Computing = 1,

    /// <summary>
    /// Computation completed successfully.
    /// </summary>
    Completed = 2,

    /// <summary>
    /// Computation failed with an error.
    /// </summary>
    Failed = 3,

    /// <summary>
    /// Computation was cancelled (e.g., user stopped streaming).
    /// </summary>
    Cancelled = 4
}
```

### 3. DiffComputedEventArgs

```csharp
// src/SeniorIntern.Core/Events/DiffComputedEventArgs.cs
namespace SeniorIntern.Core.Events;

/// <summary>
/// Event arguments for when a streaming diff computation completes.
/// </summary>
public sealed class DiffComputedEventArgs : EventArgs
{
    /// <summary>
    /// Creates new diff computed event args.
    /// </summary>
    public DiffComputedEventArgs(
        Guid blockId,
        DiffComputationState state,
        bool isIntermediate)
    {
        BlockId = blockId;
        State = state ?? throw new ArgumentNullException(nameof(state));
        IsIntermediate = isIntermediate;
        ComputedAt = DateTime.UtcNow;
    }

    /// <summary>
    /// The code block ID this diff is for.
    /// </summary>
    public Guid BlockId { get; }

    /// <summary>
    /// The full computation state.
    /// </summary>
    public DiffComputationState State { get; }

    /// <summary>
    /// True if this is an intermediate result (streaming still in progress).
    /// </summary>
    public bool IsIntermediate { get; }

    /// <summary>
    /// True if this is the final result (streaming complete).
    /// </summary>
    public bool IsFinal => !IsIntermediate;

    /// <summary>
    /// When the diff was computed.
    /// </summary>
    public DateTime ComputedAt { get; }

    /// <summary>
    /// The diff result (convenience accessor).
    /// </summary>
    public DiffResult? Result => State.Result;

    /// <summary>
    /// Whether computation was successful.
    /// </summary>
    public bool IsSuccess => State.IsCompleted && State.Result is not null;
}
```

### 4. IStreamingDiffCoordinator Interface

```csharp
// src/SeniorIntern.Core/Interfaces/IStreamingDiffCoordinator.cs
using SeniorIntern.Core.Events;
using SeniorIntern.Core.Models;

namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Coordinates diff computation during LLM response streaming.
/// </summary>
public interface IStreamingDiffCoordinator
{
    /// <summary>
    /// Event raised when a diff computation completes (intermediate or final).
    /// </summary>
    event EventHandler<DiffComputedEventArgs>? DiffComputed;

    /// <summary>
    /// Called when a code block is first detected during streaming.
    /// Queues an initial diff computation.
    /// </summary>
    /// <param name="block">The detected code block.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>The initial computation state.</returns>
    Task<DiffComputationState> OnCodeBlockDetectedAsync(
        CodeBlock block,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Called when a code block's content is updated during streaming.
    /// May trigger a debounced recomputation.
    /// </summary>
    /// <param name="block">The updated code block.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>The current computation state (may be cached).</returns>
    Task<DiffComputationState> OnCodeBlockUpdatedAsync(
        CodeBlock block,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Called when streaming completes to finalize diff computation.
    /// Forces immediate recomputation with final content.
    /// </summary>
    /// <param name="block">The finalized code block.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>The final computation state.</returns>
    Task<DiffComputationState> FinalizeBlockDiffAsync(
        CodeBlock block,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Get current computation state for a code block.
    /// </summary>
    /// <param name="blockId">The code block ID.</param>
    /// <returns>The computation state, or null if not found.</returns>
    DiffComputationState? GetComputationState(Guid blockId);

    /// <summary>
    /// Get all active computation states.
    /// </summary>
    /// <returns>All tracked computation states.</returns>
    IReadOnlyCollection<DiffComputationState> GetAllStates();

    /// <summary>
    /// Cancel computation for a specific block.
    /// </summary>
    /// <param name="blockId">The code block ID to cancel.</param>
    void Cancel(Guid blockId);

    /// <summary>
    /// Cancel all active computations.
    /// </summary>
    void CancelAll();

    /// <summary>
    /// Clear all tracked states (e.g., when starting new conversation).
    /// </summary>
    void Reset();
}
```

### 5. StreamingDiffCoordinator Implementation

```csharp
// src/SeniorIntern.Services/Streaming/StreamingDiffCoordinator.cs
using SeniorIntern.Core.Events;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using System.Collections.Concurrent;
using System.Security.Cryptography;
using System.Text;

namespace SeniorIntern.Services.Streaming;

/// <summary>
/// Coordinates streaming diff computation during LLM response generation.
/// </summary>
public sealed class StreamingDiffCoordinator : IStreamingDiffCoordinator, IDisposable
{
    private readonly IDiffService _diffService;
    private readonly IWorkspaceService _workspaceService;
    private readonly ISettingsService _settingsService;
    private readonly ILogger<StreamingDiffCoordinator> _logger;
    private readonly ConcurrentDictionary<Guid, DiffComputationState> _states = new();
    private readonly DiffComputationQueue _queue;
    private readonly CancellationTokenSource _disposalCts = new();
    private bool _disposed;

    /// <summary>
    /// Default debounce interval for update coalescing.
    /// </summary>
    public static readonly TimeSpan DefaultDebounceInterval = TimeSpan.FromMilliseconds(250);

    /// <summary>
    /// Minimum interval between recomputations for the same block.
    /// </summary>
    public static readonly TimeSpan MinRecomputeInterval = TimeSpan.FromMilliseconds(100);

    public event EventHandler<DiffComputedEventArgs>? DiffComputed;

    public StreamingDiffCoordinator(
        IDiffService diffService,
        IWorkspaceService workspaceService,
        ISettingsService settingsService,
        ILogger<StreamingDiffCoordinator> logger)
    {
        _diffService = diffService ?? throw new ArgumentNullException(nameof(diffService));
        _workspaceService = workspaceService ?? throw new ArgumentNullException(nameof(workspaceService));
        _settingsService = settingsService ?? throw new ArgumentNullException(nameof(settingsService));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));

        _queue = new DiffComputationQueue(
            DefaultDebounceInterval,
            ProcessComputationAsync,
            _logger);

        // Start processing queue
        _ = _queue.StartProcessingAsync(_disposalCts.Token);
    }

    public async Task<DiffComputationState> OnCodeBlockDetectedAsync(
        CodeBlock block,
        CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(block);

        // Check if streaming diff preview is enabled
        var settings = await _settingsService.GetSettingsAsync(cancellationToken);
        if (!settings.ShowDiffPreviewDuringStreaming)
        {
            return CreateDisabledState(block);
        }

        // Skip blocks without target file paths
        if (string.IsNullOrEmpty(block.TargetFilePath))
        {
            return CreateNoTargetState(block);
        }

        // Create or get existing state
        var state = _states.GetOrAdd(block.Id, _ => new DiffComputationState
        {
            BlockId = block.Id,
            TargetFilePath = block.TargetFilePath,
            StartedAt = DateTime.UtcNow
        });

        // Queue computation
        _queue.Enqueue(new DiffComputationRequest(
            block,
            DiffComputationPriority.Detect,
            cancellationToken));

        _logger.LogDebug("Queued initial diff computation for block {BlockId}", block.Id);
        return state;
    }

    public async Task<DiffComputationState> OnCodeBlockUpdatedAsync(
        CodeBlock block,
        CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(block);

        if (!_states.TryGetValue(block.Id, out var state))
        {
            // First time seeing this block, treat as detection
            return await OnCodeBlockDetectedAsync(block, cancellationToken);
        }

        // Check if content actually changed
        var newHash = ComputeContentHash(block.Content);
        if (state.ContentHash == newHash)
        {
            // Content unchanged, return cached state
            return state;
        }

        // Mark as needing recompute
        state.NeedsRecompute = true;

        // Queue update (will be debounced/coalesced)
        _queue.Enqueue(new DiffComputationRequest(
            block,
            DiffComputationPriority.Update,
            cancellationToken));

        return state;
    }

    public async Task<DiffComputationState> FinalizeBlockDiffAsync(
        CodeBlock block,
        CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(block);

        if (!_states.TryGetValue(block.Id, out var state))
        {
            // No existing state, compute fresh
            state = new DiffComputationState
            {
                BlockId = block.Id,
                TargetFilePath = block.TargetFilePath,
                StartedAt = DateTime.UtcNow
            };
            _states[block.Id] = state;
        }

        state.IsFinalized = true;

        // Force immediate computation (bypass debounce)
        await ProcessComputationAsync(new DiffComputationRequest(
            block,
            DiffComputationPriority.Finalize,
            cancellationToken));

        return state;
    }

    public DiffComputationState? GetComputationState(Guid blockId) =>
        _states.TryGetValue(blockId, out var state) ? state : null;

    public IReadOnlyCollection<DiffComputationState> GetAllStates() =>
        _states.Values.ToList().AsReadOnly();

    public void Cancel(Guid blockId)
    {
        if (_states.TryGetValue(blockId, out var state))
        {
            state.Status = DiffComputationStatus.Cancelled;
            _logger.LogDebug("Cancelled diff computation for block {BlockId}", blockId);
        }
    }

    public void CancelAll()
    {
        foreach (var state in _states.Values)
        {
            state.Status = DiffComputationStatus.Cancelled;
        }
        _queue.Clear();
        _logger.LogDebug("Cancelled all diff computations");
    }

    public void Reset()
    {
        CancelAll();
        _states.Clear();
        _logger.LogDebug("Reset streaming diff coordinator");
    }

    private async Task ProcessComputationAsync(DiffComputationRequest request)
    {
        var block = request.Block;

        if (!_states.TryGetValue(block.Id, out var state))
        {
            _logger.LogWarning("No state found for block {BlockId}", block.Id);
            return;
        }

        // Skip if already cancelled
        if (state.Status == DiffComputationStatus.Cancelled)
            return;

        // Skip if no target file path
        if (string.IsNullOrEmpty(block.TargetFilePath))
            return;

        var stopwatch = System.Diagnostics.Stopwatch.StartNew();
        state.Status = DiffComputationStatus.Computing;

        try
        {
            var workspace = _workspaceService.CurrentWorkspace;
            if (workspace is null)
            {
                state.Status = DiffComputationStatus.Failed;
                state.ErrorMessage = "No workspace loaded";
                return;
            }

            var fullPath = Path.Combine(workspace.RootPath, block.TargetFilePath);
            DiffResult diff;

            if (!File.Exists(fullPath))
            {
                // New file - all content is additions
                state.IsNewFile = true;
                diff = _diffService.CreateNewFileDiff(block.TargetFilePath, block.Content);
            }
            else
            {
                // Existing file - compute actual diff
                var originalContent = await File.ReadAllTextAsync(
                    fullPath,
                    request.CancellationToken);

                diff = _diffService.ComputeDiff(
                    originalContent,
                    block.Content,
                    block.TargetFilePath);
            }

            stopwatch.Stop();

            // Update state
            state.Result = diff;
            state.ContentHash = ComputeContentHash(block.Content);
            state.LastUpdatedAt = DateTime.UtcNow;
            state.ComputationDuration = stopwatch.Elapsed;
            state.ComputationCount++;
            state.NeedsRecompute = false;
            state.Status = DiffComputationStatus.Completed;

            _logger.LogDebug(
                "Computed diff for block {BlockId}: {Stats} in {Duration}ms",
                block.Id,
                state.StatsDisplay,
                stopwatch.ElapsedMilliseconds);

            // Raise event
            var eventArgs = new DiffComputedEventArgs(
                block.Id,
                state,
                isIntermediate: !state.IsFinalized);

            DiffComputed?.Invoke(this, eventArgs);
        }
        catch (OperationCanceledException)
        {
            state.Status = DiffComputationStatus.Cancelled;
            _logger.LogDebug("Diff computation cancelled for block {BlockId}", block.Id);
        }
        catch (Exception ex)
        {
            stopwatch.Stop();
            state.Status = DiffComputationStatus.Failed;
            state.ErrorMessage = ex.Message;
            state.ComputationDuration = stopwatch.Elapsed;

            _logger.LogError(ex, "Diff computation failed for block {BlockId}", block.Id);

            // Still raise event for failure
            var eventArgs = new DiffComputedEventArgs(
                block.Id,
                state,
                isIntermediate: !state.IsFinalized);

            DiffComputed?.Invoke(this, eventArgs);
        }
    }

    private static DiffComputationState CreateDisabledState(CodeBlock block) => new()
    {
        BlockId = block.Id,
        Status = DiffComputationStatus.Cancelled,
        ErrorMessage = "Streaming diff preview disabled in settings"
    };

    private static DiffComputationState CreateNoTargetState(CodeBlock block) => new()
    {
        BlockId = block.Id,
        Status = DiffComputationStatus.Completed,
        ErrorMessage = "No target file path specified"
    };

    private static string ComputeContentHash(string content)
    {
        var bytes = Encoding.UTF8.GetBytes(content);
        var hash = SHA256.HashData(bytes);
        return Convert.ToBase64String(hash);
    }

    public void Dispose()
    {
        if (_disposed) return;
        _disposed = true;

        _disposalCts.Cancel();
        _queue.Dispose();
        _disposalCts.Dispose();
    }
}
```

### 6. DiffComputationQueue

```csharp
// src/SeniorIntern.Services/Streaming/DiffComputationQueue.cs
using SeniorIntern.Core.Models;
using System.Collections.Concurrent;
using System.Threading.Channels;

namespace SeniorIntern.Services.Streaming;

/// <summary>
/// Priority for diff computation requests.
/// </summary>
public enum DiffComputationPriority
{
    /// <summary>
    /// Initial detection (lowest priority).
    /// </summary>
    Detect = 1,

    /// <summary>
    /// Content update (medium priority).
    /// </summary>
    Update = 2,

    /// <summary>
    /// Finalization (highest priority, bypasses debounce).
    /// </summary>
    Finalize = 3
}

/// <summary>
/// Request to compute a diff for a code block.
/// </summary>
/// <param name="Block">The code block to diff.</param>
/// <param name="Priority">Computation priority.</param>
/// <param name="CancellationToken">Cancellation token.</param>
public sealed record DiffComputationRequest(
    CodeBlock Block,
    DiffComputationPriority Priority,
    CancellationToken CancellationToken);

/// <summary>
/// Manages debounced, prioritized diff computation requests.
/// </summary>
public sealed class DiffComputationQueue : IDisposable
{
    private readonly TimeSpan _debounceInterval;
    private readonly Func<DiffComputationRequest, Task> _processor;
    private readonly ILogger _logger;
    private readonly ConcurrentDictionary<Guid, PendingComputation> _pending = new();
    private readonly Channel<DiffComputationRequest> _channel;
    private readonly CancellationTokenSource _cts = new();
    private bool _disposed;

    public DiffComputationQueue(
        TimeSpan debounceInterval,
        Func<DiffComputationRequest, Task> processor,
        ILogger logger)
    {
        _debounceInterval = debounceInterval;
        _processor = processor ?? throw new ArgumentNullException(nameof(processor));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));

        _channel = Channel.CreateUnbounded<DiffComputationRequest>(
            new UnboundedChannelOptions
            {
                SingleReader = true,
                SingleWriter = false
            });
    }

    /// <summary>
    /// Enqueue a computation request.
    /// Requests for the same block are coalesced with debouncing.
    /// </summary>
    public void Enqueue(DiffComputationRequest request)
    {
        ArgumentNullException.ThrowIfNull(request);

        var blockId = request.Block.Id;

        // Finalize requests bypass debouncing
        if (request.Priority == DiffComputationPriority.Finalize)
        {
            // Cancel any pending debounced request
            if (_pending.TryRemove(blockId, out var pending))
            {
                pending.Cancel();
            }

            // Process immediately
            _channel.Writer.TryWrite(request);
            return;
        }

        // Debounce detection and update requests
        var computation = _pending.AddOrUpdate(
            blockId,
            _ => new PendingComputation(request, _debounceInterval, () => FlushPending(blockId)),
            (_, existing) =>
            {
                existing.Update(request);
                return existing;
            });
    }

    /// <summary>
    /// Start processing the queue.
    /// </summary>
    public async Task StartProcessingAsync(CancellationToken cancellationToken)
    {
        using var linked = CancellationTokenSource.CreateLinkedTokenSource(
            cancellationToken, _cts.Token);

        try
        {
            await foreach (var request in _channel.Reader.ReadAllAsync(linked.Token))
            {
                try
                {
                    await _processor(request);
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex,
                        "Error processing diff computation for block {BlockId}",
                        request.Block.Id);
                }
            }
        }
        catch (OperationCanceledException)
        {
            // Expected on shutdown
        }
    }

    /// <summary>
    /// Clear all pending computations.
    /// </summary>
    public void Clear()
    {
        foreach (var pending in _pending.Values)
        {
            pending.Cancel();
        }
        _pending.Clear();
    }

    private void FlushPending(Guid blockId)
    {
        if (_pending.TryRemove(blockId, out var pending))
        {
            var request = pending.GetLatestRequest();
            if (request is not null)
            {
                _channel.Writer.TryWrite(request);
            }
        }
    }

    public void Dispose()
    {
        if (_disposed) return;
        _disposed = true;

        _cts.Cancel();
        Clear();
        _channel.Writer.Complete();
        _cts.Dispose();
    }

    /// <summary>
    /// Tracks a pending debounced computation.
    /// </summary>
    private sealed class PendingComputation : IDisposable
    {
        private DiffComputationRequest _latestRequest;
        private readonly TimeSpan _debounceInterval;
        private readonly Action _onDebounceExpired;
        private CancellationTokenSource? _debounceCts;
        private readonly object _lock = new();

        public PendingComputation(
            DiffComputationRequest request,
            TimeSpan debounceInterval,
            Action onDebounceExpired)
        {
            _latestRequest = request;
            _debounceInterval = debounceInterval;
            _onDebounceExpired = onDebounceExpired;
            StartDebounceTimer();
        }

        public void Update(DiffComputationRequest request)
        {
            lock (_lock)
            {
                // Keep higher priority request
                if (request.Priority >= _latestRequest.Priority)
                {
                    _latestRequest = request;
                }
                // Reset debounce timer
                StartDebounceTimer();
            }
        }

        public DiffComputationRequest? GetLatestRequest()
        {
            lock (_lock)
            {
                return _latestRequest;
            }
        }

        public void Cancel()
        {
            lock (_lock)
            {
                _debounceCts?.Cancel();
                _debounceCts?.Dispose();
                _debounceCts = null;
            }
        }

        private void StartDebounceTimer()
        {
            _debounceCts?.Cancel();
            _debounceCts?.Dispose();
            _debounceCts = new CancellationTokenSource();

            var token = _debounceCts.Token;
            _ = Task.Delay(_debounceInterval, token).ContinueWith(
                _ => _onDebounceExpired(),
                token,
                TaskContinuationOptions.OnlyOnRanToCompletion,
                TaskScheduler.Default);
        }

        public void Dispose()
        {
            Cancel();
        }
    }
}
```

### 7. StreamingDiffViewModel

```csharp
// src/SeniorIntern.Desktop/ViewModels/StreamingDiffViewModel.cs
using CommunityToolkit.Mvvm.ComponentModel;
using SeniorIntern.Core.Models;

namespace SeniorIntern.Desktop.ViewModels;

/// <summary>
/// ViewModel for streaming diff preview state on a code block.
/// </summary>
public partial class StreamingDiffViewModel : ViewModelBase
{
    /// <summary>
    /// The code block ID this diff is for.
    /// </summary>
    [ObservableProperty]
    private Guid _blockId;

    /// <summary>
    /// Current computation status.
    /// </summary>
    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(IsComputing))]
    [NotifyPropertyChangedFor(nameof(IsCompleted))]
    [NotifyPropertyChangedFor(nameof(IsFailed))]
    [NotifyPropertyChangedFor(nameof(ShowStats))]
    [NotifyPropertyChangedFor(nameof(ShowError))]
    [NotifyPropertyChangedFor(nameof(ShowSpinner))]
    private DiffComputationStatus _status = DiffComputationStatus.Pending;

    /// <summary>
    /// The computed diff result.
    /// </summary>
    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(HasResult))]
    [NotifyPropertyChangedFor(nameof(StatsDisplay))]
    [NotifyPropertyChangedFor(nameof(AddedLines))]
    [NotifyPropertyChangedFor(nameof(RemovedLines))]
    [NotifyPropertyChangedFor(nameof(ModifiedLines))]
    [NotifyPropertyChangedFor(nameof(HasChanges))]
    private DiffResult? _result;

    /// <summary>
    /// Error message if computation failed.
    /// </summary>
    [ObservableProperty]
    private string? _errorMessage;

    /// <summary>
    /// Whether this is a new file (no original).
    /// </summary>
    [ObservableProperty]
    private bool _isNewFile;

    /// <summary>
    /// Whether the diff has been finalized.
    /// </summary>
    [ObservableProperty]
    private bool _isFinalized;

    /// <summary>
    /// Target file path.
    /// </summary>
    [ObservableProperty]
    private string? _targetFilePath;

    /// <summary>
    /// Number of times recomputed.
    /// </summary>
    [ObservableProperty]
    private int _computationCount;

    // ═══════════════════════════════════════════════════════════════
    // Computed Properties
    // ═══════════════════════════════════════════════════════════════

    /// <summary>
    /// Whether computation is in progress.
    /// </summary>
    public bool IsComputing => Status == DiffComputationStatus.Computing;

    /// <summary>
    /// Whether computation completed successfully.
    /// </summary>
    public bool IsCompleted => Status == DiffComputationStatus.Completed;

    /// <summary>
    /// Whether computation failed.
    /// </summary>
    public bool IsFailed => Status == DiffComputationStatus.Failed;

    /// <summary>
    /// Whether a valid result is available.
    /// </summary>
    public bool HasResult => Result is not null && IsCompleted;

    /// <summary>
    /// Whether to show the stats display.
    /// </summary>
    public bool ShowStats => HasResult && HasChanges;

    /// <summary>
    /// Whether to show error state.
    /// </summary>
    public bool ShowError => IsFailed && !string.IsNullOrEmpty(ErrorMessage);

    /// <summary>
    /// Whether to show the spinner.
    /// </summary>
    public bool ShowSpinner => IsComputing || Status == DiffComputationStatus.Pending;

    /// <summary>
    /// Number of added lines.
    /// </summary>
    public int AddedLines => Result?.Stats.AddedLines ?? 0;

    /// <summary>
    /// Number of removed lines.
    /// </summary>
    public int RemovedLines => Result?.Stats.RemovedLines ?? 0;

    /// <summary>
    /// Number of modified lines.
    /// </summary>
    public int ModifiedLines => Result?.Stats.ModifiedLines ?? 0;

    /// <summary>
    /// Whether there are any changes.
    /// </summary>
    public bool HasChanges => Result?.HasChanges ?? false;

    /// <summary>
    /// Formatted stats display string.
    /// </summary>
    public string StatsDisplay
    {
        get
        {
            if (Result?.Stats is not { } stats) return string.Empty;

            var parts = new List<string>(3);
            if (stats.AddedLines > 0) parts.Add($"+{stats.AddedLines}");
            if (stats.RemovedLines > 0) parts.Add($"-{stats.RemovedLines}");
            if (stats.ModifiedLines > 0) parts.Add($"~{stats.ModifiedLines}");

            if (parts.Count == 0)
            {
                return IsNewFile ? "New file" : "No changes";
            }

            return string.Join(" ", parts);
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // Methods
    // ═══════════════════════════════════════════════════════════════

    /// <summary>
    /// Updates this ViewModel from a computation state.
    /// </summary>
    public void UpdateFromState(DiffComputationState state)
    {
        ArgumentNullException.ThrowIfNull(state);

        BlockId = state.BlockId;
        Status = state.Status;
        Result = state.Result;
        ErrorMessage = state.ErrorMessage;
        IsNewFile = state.IsNewFile;
        IsFinalized = state.IsFinalized;
        TargetFilePath = state.TargetFilePath;
        ComputationCount = state.ComputationCount;
    }

    /// <summary>
    /// Creates a ViewModel from a computation state.
    /// </summary>
    public static StreamingDiffViewModel FromState(DiffComputationState state)
    {
        var vm = new StreamingDiffViewModel();
        vm.UpdateFromState(state);
        return vm;
    }
}
```

### 8. CodeBlockViewModel Additions

```csharp
// src/SeniorIntern.Desktop/ViewModels/CodeBlockViewModel.cs (additions)
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using SeniorIntern.Core.Models;

namespace SeniorIntern.Desktop.ViewModels;

public partial class CodeBlockViewModel : ViewModelBase
{
    // ... existing properties ...

    // ═══════════════════════════════════════════════════════════════
    // Streaming Diff Preview (v0.4.5b)
    // ═══════════════════════════════════════════════════════════════

    /// <summary>
    /// Streaming diff preview ViewModel.
    /// </summary>
    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(HasStreamingDiff))]
    [NotifyPropertyChangedFor(nameof(IsComputingDiff))]
    [NotifyPropertyChangedFor(nameof(StreamingDiffStats))]
    [NotifyPropertyChangedFor(nameof(ShowStreamingDiffPreview))]
    private StreamingDiffViewModel? _streamingDiff;

    /// <summary>
    /// Whether streaming diff is available.
    /// </summary>
    public bool HasStreamingDiff => StreamingDiff?.HasResult ?? false;

    /// <summary>
    /// Whether diff is currently being computed.
    /// </summary>
    public bool IsComputingDiff => StreamingDiff?.IsComputing ?? false;

    /// <summary>
    /// Stats display from streaming diff.
    /// </summary>
    public string StreamingDiffStats => StreamingDiff?.StatsDisplay ?? string.Empty;

    /// <summary>
    /// Whether to show the streaming diff preview control.
    /// </summary>
    public bool ShowStreamingDiffPreview =>
        StreamingDiff is not null &&
        IsApplicable &&
        (StreamingDiff.ShowSpinner || StreamingDiff.HasResult || StreamingDiff.ShowError);

    /// <summary>
    /// Updates streaming diff state from coordinator event.
    /// </summary>
    public void UpdateStreamingDiff(DiffComputationState state)
    {
        if (StreamingDiff is null)
        {
            StreamingDiff = StreamingDiffViewModel.FromState(state);
        }
        else
        {
            StreamingDiff.UpdateFromState(state);
        }

        OnPropertyChanged(nameof(HasStreamingDiff));
        OnPropertyChanged(nameof(IsComputingDiff));
        OnPropertyChanged(nameof(StreamingDiffStats));
        OnPropertyChanged(nameof(ShowStreamingDiffPreview));
    }

    /// <summary>
    /// Command to show full diff preview.
    /// </summary>
    [RelayCommand]
    private void ShowDiffPreview()
    {
        if (StreamingDiff?.Result is not null)
        {
            // Will be handled by parent to show diff panel
            RequestShowDiffPreview?.Invoke(this, StreamingDiff.Result);
        }
    }

    /// <summary>
    /// Event to request showing the full diff preview.
    /// </summary>
    public event EventHandler<DiffResult>? RequestShowDiffPreview;
}
```

### 9. StreamingDiffPreviewControl

```xml
<!-- src/SeniorIntern.Desktop/Controls/StreamingDiffPreviewControl.axaml -->
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:vm="using:SeniorIntern.Desktop.ViewModels"
             x:Class="SeniorIntern.Desktop.Controls.StreamingDiffPreviewControl"
             x:DataType="vm:StreamingDiffViewModel">

    <UserControl.Styles>
        <!-- Pulse animation for computing state -->
        <Style Selector="Border.computing">
            <Style.Animations>
                <Animation Duration="0:0:1" IterationCount="Infinite">
                    <KeyFrame Cue="0%">
                        <Setter Property="Opacity" Value="0.6"/>
                    </KeyFrame>
                    <KeyFrame Cue="50%">
                        <Setter Property="Opacity" Value="1.0"/>
                    </KeyFrame>
                    <KeyFrame Cue="100%">
                        <Setter Property="Opacity" Value="0.6"/>
                    </KeyFrame>
                </Animation>
            </Style.Animations>
        </Style>
    </UserControl.Styles>

    <Border Background="{DynamicResource ControlBackground}"
            CornerRadius="4"
            Padding="8,4"
            Margin="0,4,0,0">

        <Grid ColumnDefinitions="Auto,*,Auto">

            <!-- Status Indicator -->
            <Border Grid.Column="0"
                    Width="16" Height="16"
                    CornerRadius="8"
                    Margin="0,0,8,0"
                    Classes.computing="{Binding ShowSpinner}">

                <!-- Computing spinner -->
                <Panel IsVisible="{Binding ShowSpinner}">
                    <Ellipse Width="14" Height="14"
                             Stroke="{DynamicResource AccentBrush}"
                             StrokeThickness="2"
                             StrokeDashArray="3,3">
                        <Ellipse.RenderTransform>
                            <RotateTransform/>
                        </Ellipse.RenderTransform>
                        <Ellipse.Styles>
                            <Style Selector="Ellipse">
                                <Style.Animations>
                                    <Animation Duration="0:0:1" IterationCount="Infinite">
                                        <KeyFrame Cue="0%">
                                            <Setter Property="RenderTransform" Value="rotate(0deg)"/>
                                        </KeyFrame>
                                        <KeyFrame Cue="100%">
                                            <Setter Property="RenderTransform" Value="rotate(360deg)"/>
                                        </KeyFrame>
                                    </Animation>
                                </Style.Animations>
                            </Style>
                        </Ellipse.Styles>
                    </Ellipse>
                </Panel>

                <!-- Completed checkmark -->
                <Panel IsVisible="{Binding IsCompleted}">
                    <Ellipse Width="14" Height="14"
                             Fill="{DynamicResource SuccessBackground}"/>
                    <TextBlock Text="✓"
                               FontSize="10"
                               Foreground="{DynamicResource SuccessForeground}"
                               HorizontalAlignment="Center"
                               VerticalAlignment="Center"/>
                </Panel>

                <!-- Error indicator -->
                <Panel IsVisible="{Binding IsFailed}">
                    <Ellipse Width="14" Height="14"
                             Fill="{DynamicResource ErrorBackground}"/>
                    <TextBlock Text="!"
                               FontSize="10"
                               FontWeight="Bold"
                               Foreground="{DynamicResource ErrorForeground}"
                               HorizontalAlignment="Center"
                               VerticalAlignment="Center"/>
                </Panel>
            </Border>

            <!-- Stats Display -->
            <StackPanel Grid.Column="1"
                        Orientation="Horizontal"
                        Spacing="8"
                        VerticalAlignment="Center">

                <!-- Added lines -->
                <StackPanel Orientation="Horizontal"
                            IsVisible="{Binding HasChanges}">
                    <TextBlock Text="+"
                               FontFamily="Consolas,Monaco,monospace"
                               FontWeight="Bold"
                               Foreground="#89D185"
                               IsVisible="{Binding AddedLines}"/>
                    <TextBlock Text="{Binding AddedLines}"
                               FontFamily="Consolas,Monaco,monospace"
                               Foreground="#89D185"
                               IsVisible="{Binding AddedLines}"/>
                </StackPanel>

                <!-- Removed lines -->
                <StackPanel Orientation="Horizontal"
                            IsVisible="{Binding HasChanges}">
                    <TextBlock Text="-"
                               FontFamily="Consolas,Monaco,monospace"
                               FontWeight="Bold"
                               Foreground="#F48771"
                               IsVisible="{Binding RemovedLines}"/>
                    <TextBlock Text="{Binding RemovedLines}"
                               FontFamily="Consolas,Monaco,monospace"
                               Foreground="#F48771"
                               IsVisible="{Binding RemovedLines}"/>
                </StackPanel>

                <!-- Modified lines -->
                <StackPanel Orientation="Horizontal"
                            IsVisible="{Binding HasChanges}">
                    <TextBlock Text="~"
                               FontFamily="Consolas,Monaco,monospace"
                               FontWeight="Bold"
                               Foreground="#CCA700"
                               IsVisible="{Binding ModifiedLines}"/>
                    <TextBlock Text="{Binding ModifiedLines}"
                               FontFamily="Consolas,Monaco,monospace"
                               Foreground="#CCA700"
                               IsVisible="{Binding ModifiedLines}"/>
                </StackPanel>

                <!-- No changes / New file -->
                <TextBlock Text="{Binding StatsDisplay}"
                           Foreground="{DynamicResource TextMuted}"
                           IsVisible="{Binding !HasChanges}"/>

                <!-- Computing text -->
                <TextBlock Text="Computing diff..."
                           Foreground="{DynamicResource TextMuted}"
                           FontStyle="Italic"
                           IsVisible="{Binding ShowSpinner}"/>

                <!-- Error text -->
                <TextBlock Text="{Binding ErrorMessage}"
                           Foreground="{DynamicResource ErrorForeground}"
                           IsVisible="{Binding ShowError}"
                           TextTrimming="CharacterEllipsis"
                           MaxWidth="200"/>
            </StackPanel>

            <!-- Preview button -->
            <Button Grid.Column="2"
                    Theme="{DynamicResource SubtleButton}"
                    Padding="4,2"
                    IsVisible="{Binding HasResult}"
                    ToolTip.Tip="Click to preview full diff">
                <StackPanel Orientation="Horizontal" Spacing="4">
                    <TextBlock Text="Preview"
                               FontSize="11"
                               Foreground="{DynamicResource TextMuted}"/>
                    <TextBlock Text="→"
                               FontSize="11"
                               Foreground="{DynamicResource TextMuted}"/>
                </StackPanel>
            </Button>
        </Grid>
    </Border>
</UserControl>
```

### 10. StreamingDiffPreviewControl Code-Behind

```csharp
// src/SeniorIntern.Desktop/Controls/StreamingDiffPreviewControl.axaml.cs
using Avalonia.Controls;

namespace SeniorIntern.Desktop.Controls;

public partial class StreamingDiffPreviewControl : UserControl
{
    public StreamingDiffPreviewControl()
    {
        InitializeComponent();
    }
}
```

### 11. Service Registration

```csharp
// src/SeniorIntern.Desktop/Extensions/ServiceCollectionExtensions.cs (additions)
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Services.Streaming;

namespace SeniorIntern.Desktop.Extensions;

public static partial class ServiceCollectionExtensions
{
    public static IServiceCollection AddStreamingDiffServices(this IServiceCollection services)
    {
        // Register streaming diff coordinator as singleton
        // (maintains state across the application lifetime)
        services.AddSingleton<IStreamingDiffCoordinator, StreamingDiffCoordinator>();

        return services;
    }
}
```

---

## Unit Tests

### DiffComputationStateTests

```csharp
// tests/SeniorIntern.Core.Tests/Models/DiffComputationStateTests.cs
namespace SeniorIntern.Core.Tests.Models;

public class DiffComputationStateTests
{
    [Fact]
    public void Constructor_SetsDefaultValues()
    {
        // Act
        var state = new DiffComputationState { BlockId = Guid.NewGuid() };

        // Assert
        Assert.Equal(DiffComputationStatus.Pending, state.Status);
        Assert.Null(state.Result);
        Assert.Null(state.ErrorMessage);
        Assert.Equal(0, state.ComputationCount);
        Assert.False(state.IsFinalized);
    }

    [Theory]
    [InlineData(DiffComputationStatus.Pending, false, false, false)]
    [InlineData(DiffComputationStatus.Computing, false, true, false)]
    [InlineData(DiffComputationStatus.Completed, true, false, false)]
    [InlineData(DiffComputationStatus.Failed, false, false, true)]
    [InlineData(DiffComputationStatus.Cancelled, false, false, false)]
    public void StatusProperties_ReflectStatus(
        DiffComputationStatus status,
        bool expectedCompleted,
        bool expectedComputing,
        bool expectedFailed)
    {
        // Arrange
        var state = new DiffComputationState
        {
            BlockId = Guid.NewGuid(),
            Status = status
        };

        // Assert
        Assert.Equal(expectedCompleted, state.IsCompleted);
        Assert.Equal(expectedComputing, state.IsComputing);
        Assert.Equal(expectedFailed, state.IsFailed);
    }

    [Fact]
    public void HasResult_TrueWhenCompletedWithResult()
    {
        // Arrange
        var state = new DiffComputationState
        {
            BlockId = Guid.NewGuid(),
            Status = DiffComputationStatus.Completed,
            Result = new DiffResult { OriginalFilePath = "test.cs" }
        };

        // Assert
        Assert.True(state.HasResult);
    }

    [Fact]
    public void HasResult_FalseWhenCompletedWithoutResult()
    {
        // Arrange
        var state = new DiffComputationState
        {
            BlockId = Guid.NewGuid(),
            Status = DiffComputationStatus.Completed,
            Result = null
        };

        // Assert
        Assert.False(state.HasResult);
    }

    [Fact]
    public void StatsDisplay_FormatsCorrectly()
    {
        // Arrange
        var state = new DiffComputationState
        {
            BlockId = Guid.NewGuid(),
            Status = DiffComputationStatus.Completed,
            Result = new DiffResult
            {
                Stats = new DiffStats
                {
                    AddedLines = 10,
                    RemovedLines = 5,
                    ModifiedLines = 3
                }
            }
        };

        // Assert
        Assert.Equal("+10 -5 ~3", state.StatsDisplay);
    }

    [Fact]
    public void StatsDisplay_OmitsZeroCounts()
    {
        // Arrange
        var state = new DiffComputationState
        {
            BlockId = Guid.NewGuid(),
            Status = DiffComputationStatus.Completed,
            Result = new DiffResult
            {
                Stats = new DiffStats
                {
                    AddedLines = 5,
                    RemovedLines = 0,
                    ModifiedLines = 0
                }
            }
        };

        // Assert
        Assert.Equal("+5", state.StatsDisplay);
    }
}
```

### StreamingDiffCoordinatorTests

```csharp
// tests/SeniorIntern.Services.Tests/Streaming/StreamingDiffCoordinatorTests.cs
namespace SeniorIntern.Services.Tests.Streaming;

public class StreamingDiffCoordinatorTests : IDisposable
{
    private readonly Mock<IDiffService> _diffServiceMock;
    private readonly Mock<IWorkspaceService> _workspaceServiceMock;
    private readonly Mock<ISettingsService> _settingsServiceMock;
    private readonly Mock<ILogger<StreamingDiffCoordinator>> _loggerMock;
    private readonly StreamingDiffCoordinator _coordinator;
    private readonly string _tempDir;

    public StreamingDiffCoordinatorTests()
    {
        _diffServiceMock = new Mock<IDiffService>();
        _workspaceServiceMock = new Mock<IWorkspaceService>();
        _settingsServiceMock = new Mock<ISettingsService>();
        _loggerMock = new Mock<ILogger<StreamingDiffCoordinator>>();

        _tempDir = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString());
        Directory.CreateDirectory(_tempDir);

        var workspace = new Workspace { RootPath = _tempDir };
        _workspaceServiceMock.Setup(w => w.CurrentWorkspace).Returns(workspace);

        var settings = new AppSettings { ShowDiffPreviewDuringStreaming = true };
        _settingsServiceMock.Setup(s => s.GetSettingsAsync(It.IsAny<CancellationToken>()))
            .ReturnsAsync(settings);

        _coordinator = new StreamingDiffCoordinator(
            _diffServiceMock.Object,
            _workspaceServiceMock.Object,
            _settingsServiceMock.Object,
            _loggerMock.Object);
    }

    [Fact]
    public async Task OnCodeBlockDetectedAsync_QueuesComputation()
    {
        // Arrange
        var block = new CodeBlock
        {
            Id = Guid.NewGuid(),
            Content = "public class Test { }",
            TargetFilePath = "Test.cs"
        };

        _diffServiceMock.Setup(d => d.CreateNewFileDiff(It.IsAny<string>(), It.IsAny<string>()))
            .Returns(new DiffResult { IsNewFile = true });

        // Act
        var state = await _coordinator.OnCodeBlockDetectedAsync(block);

        // Assert
        Assert.NotNull(state);
        Assert.Equal(block.Id, state.BlockId);
    }

    [Fact]
    public async Task OnCodeBlockDetectedAsync_ReturnsDisabledState_WhenSettingOff()
    {
        // Arrange
        var settings = new AppSettings { ShowDiffPreviewDuringStreaming = false };
        _settingsServiceMock.Setup(s => s.GetSettingsAsync(It.IsAny<CancellationToken>()))
            .ReturnsAsync(settings);

        var block = new CodeBlock
        {
            Id = Guid.NewGuid(),
            Content = "test",
            TargetFilePath = "test.cs"
        };

        // Act
        var state = await _coordinator.OnCodeBlockDetectedAsync(block);

        // Assert
        Assert.Equal(DiffComputationStatus.Cancelled, state.Status);
        Assert.Contains("disabled", state.ErrorMessage, StringComparison.OrdinalIgnoreCase);
    }

    [Fact]
    public async Task OnCodeBlockUpdatedAsync_DetectsContentChanges()
    {
        // Arrange
        var blockId = Guid.NewGuid();
        var block1 = new CodeBlock
        {
            Id = blockId,
            Content = "public class Test { }",
            TargetFilePath = "Test.cs"
        };

        _diffServiceMock.Setup(d => d.CreateNewFileDiff(It.IsAny<string>(), It.IsAny<string>()))
            .Returns(new DiffResult { IsNewFile = true });

        // Initial detection
        await _coordinator.OnCodeBlockDetectedAsync(block1);

        var block2 = new CodeBlock
        {
            Id = blockId,
            Content = "public class Test { public void Method() { } }",
            TargetFilePath = "Test.cs"
        };

        // Act
        var state = await _coordinator.OnCodeBlockUpdatedAsync(block2);

        // Assert
        Assert.True(state.NeedsRecompute);
    }

    [Fact]
    public async Task OnCodeBlockUpdatedAsync_ReturnsCached_WhenContentUnchanged()
    {
        // Arrange
        var blockId = Guid.NewGuid();
        var block = new CodeBlock
        {
            Id = blockId,
            Content = "public class Test { }",
            TargetFilePath = "Test.cs"
        };

        _diffServiceMock.Setup(d => d.CreateNewFileDiff(It.IsAny<string>(), It.IsAny<string>()))
            .Returns(new DiffResult
            {
                IsNewFile = true,
                Stats = new DiffStats { AddedLines = 1 }
            });

        // Initial detection
        await _coordinator.OnCodeBlockDetectedAsync(block);
        await Task.Delay(300); // Wait for debounce

        // Act - same content
        var state = await _coordinator.OnCodeBlockUpdatedAsync(block);

        // Assert - should not flag for recompute
        Assert.False(state.NeedsRecompute);
    }

    [Fact]
    public async Task FinalizeBlockDiffAsync_ForcesImmediateComputation()
    {
        // Arrange
        var block = new CodeBlock
        {
            Id = Guid.NewGuid(),
            Content = "final content",
            TargetFilePath = "Test.cs"
        };

        _diffServiceMock.Setup(d => d.CreateNewFileDiff(It.IsAny<string>(), It.IsAny<string>()))
            .Returns(new DiffResult { IsNewFile = true });

        // Act
        var state = await _coordinator.FinalizeBlockDiffAsync(block);

        // Assert
        Assert.True(state.IsFinalized);
    }

    [Fact]
    public void GetComputationState_ReturnsNull_ForUnknownBlock()
    {
        // Act
        var state = _coordinator.GetComputationState(Guid.NewGuid());

        // Assert
        Assert.Null(state);
    }

    [Fact]
    public void CancelAll_CancelsAllComputations()
    {
        // Arrange
        var block1 = new CodeBlock { Id = Guid.NewGuid(), TargetFilePath = "a.cs" };
        var block2 = new CodeBlock { Id = Guid.NewGuid(), TargetFilePath = "b.cs" };

        _coordinator.OnCodeBlockDetectedAsync(block1);
        _coordinator.OnCodeBlockDetectedAsync(block2);

        // Act
        _coordinator.CancelAll();

        // Assert
        var state1 = _coordinator.GetComputationState(block1.Id);
        var state2 = _coordinator.GetComputationState(block2.Id);

        Assert.Equal(DiffComputationStatus.Cancelled, state1?.Status);
        Assert.Equal(DiffComputationStatus.Cancelled, state2?.Status);
    }

    [Fact]
    public void Reset_ClearsAllStates()
    {
        // Arrange
        var block = new CodeBlock { Id = Guid.NewGuid(), TargetFilePath = "test.cs" };
        _coordinator.OnCodeBlockDetectedAsync(block);

        // Act
        _coordinator.Reset();

        // Assert
        Assert.Empty(_coordinator.GetAllStates());
    }

    public void Dispose()
    {
        _coordinator.Dispose();
        if (Directory.Exists(_tempDir))
        {
            Directory.Delete(_tempDir, true);
        }
    }
}
```

### DiffComputationQueueTests

```csharp
// tests/SeniorIntern.Services.Tests/Streaming/DiffComputationQueueTests.cs
namespace SeniorIntern.Services.Tests.Streaming;

public class DiffComputationQueueTests : IDisposable
{
    private readonly Mock<ILogger> _loggerMock;
    private readonly List<DiffComputationRequest> _processedRequests;
    private readonly DiffComputationQueue _queue;

    public DiffComputationQueueTests()
    {
        _loggerMock = new Mock<ILogger>();
        _processedRequests = new List<DiffComputationRequest>();

        _queue = new DiffComputationQueue(
            TimeSpan.FromMilliseconds(50), // Short debounce for testing
            async request =>
            {
                _processedRequests.Add(request);
                await Task.CompletedTask;
            },
            _loggerMock.Object);

        // Start processing
        _ = _queue.StartProcessingAsync(CancellationToken.None);
    }

    [Fact]
    public async Task Enqueue_ProcessesAfterDebounce()
    {
        // Arrange
        var block = new CodeBlock { Id = Guid.NewGuid() };
        var request = new DiffComputationRequest(block, DiffComputationPriority.Detect, default);

        // Act
        _queue.Enqueue(request);

        // Wait for debounce + processing
        await Task.Delay(100);

        // Assert
        Assert.Single(_processedRequests);
        Assert.Equal(block.Id, _processedRequests[0].Block.Id);
    }

    [Fact]
    public async Task Enqueue_CoalescesRapidUpdates()
    {
        // Arrange
        var blockId = Guid.NewGuid();
        var block1 = new CodeBlock { Id = blockId, Content = "v1" };
        var block2 = new CodeBlock { Id = blockId, Content = "v2" };
        var block3 = new CodeBlock { Id = blockId, Content = "v3" };

        // Act - rapid fire updates
        _queue.Enqueue(new DiffComputationRequest(block1, DiffComputationPriority.Update, default));
        _queue.Enqueue(new DiffComputationRequest(block2, DiffComputationPriority.Update, default));
        _queue.Enqueue(new DiffComputationRequest(block3, DiffComputationPriority.Update, default));

        // Wait for debounce
        await Task.Delay(100);

        // Assert - only one request processed (the latest)
        Assert.Single(_processedRequests);
        Assert.Equal("v3", _processedRequests[0].Block.Content);
    }

    [Fact]
    public async Task Enqueue_FinalizeBypassesDebounce()
    {
        // Arrange
        var block = new CodeBlock { Id = Guid.NewGuid(), Content = "final" };
        var request = new DiffComputationRequest(block, DiffComputationPriority.Finalize, default);

        // Act
        _queue.Enqueue(request);

        // Short wait - should process immediately without full debounce
        await Task.Delay(20);

        // Assert
        Assert.Single(_processedRequests);
    }

    [Fact]
    public async Task Enqueue_KeepsHigherPriorityRequest()
    {
        // Arrange
        var blockId = Guid.NewGuid();
        var detectBlock = new CodeBlock { Id = blockId, Content = "detect" };
        var updateBlock = new CodeBlock { Id = blockId, Content = "update" };

        // Act - detect first, then update
        _queue.Enqueue(new DiffComputationRequest(detectBlock, DiffComputationPriority.Detect, default));
        _queue.Enqueue(new DiffComputationRequest(updateBlock, DiffComputationPriority.Update, default));

        // Wait for debounce
        await Task.Delay(100);

        // Assert - update (higher priority) was processed
        Assert.Single(_processedRequests);
        Assert.Equal(DiffComputationPriority.Update, _processedRequests[0].Priority);
    }

    [Fact]
    public void Clear_RemovesPendingRequests()
    {
        // Arrange
        var block = new CodeBlock { Id = Guid.NewGuid() };
        _queue.Enqueue(new DiffComputationRequest(block, DiffComputationPriority.Detect, default));

        // Act - clear before debounce expires
        _queue.Clear();

        // Wait a bit
        Thread.Sleep(100);

        // Assert - nothing processed
        Assert.Empty(_processedRequests);
    }

    public void Dispose()
    {
        _queue.Dispose();
    }
}
```

### StreamingDiffViewModelTests

```csharp
// tests/SeniorIntern.Desktop.Tests/ViewModels/StreamingDiffViewModelTests.cs
namespace SeniorIntern.Desktop.Tests.ViewModels;

public class StreamingDiffViewModelTests
{
    [Fact]
    public void UpdateFromState_SetsAllProperties()
    {
        // Arrange
        var vm = new StreamingDiffViewModel();
        var state = new DiffComputationState
        {
            BlockId = Guid.NewGuid(),
            Status = DiffComputationStatus.Completed,
            IsNewFile = true,
            IsFinalized = true,
            TargetFilePath = "test.cs",
            ComputationCount = 3,
            Result = new DiffResult
            {
                Stats = new DiffStats { AddedLines = 10 }
            }
        };

        // Act
        vm.UpdateFromState(state);

        // Assert
        Assert.Equal(state.BlockId, vm.BlockId);
        Assert.Equal(DiffComputationStatus.Completed, vm.Status);
        Assert.True(vm.IsNewFile);
        Assert.True(vm.IsFinalized);
        Assert.Equal("test.cs", vm.TargetFilePath);
        Assert.Equal(3, vm.ComputationCount);
        Assert.NotNull(vm.Result);
    }

    [Fact]
    public void FromState_CreatesConfiguredViewModel()
    {
        // Arrange
        var state = new DiffComputationState
        {
            BlockId = Guid.NewGuid(),
            Status = DiffComputationStatus.Computing
        };

        // Act
        var vm = StreamingDiffViewModel.FromState(state);

        // Assert
        Assert.Equal(state.BlockId, vm.BlockId);
        Assert.True(vm.IsComputing);
    }

    [Fact]
    public void StatsDisplay_FormatsAdditionsCorrectly()
    {
        // Arrange
        var vm = new StreamingDiffViewModel
        {
            Status = DiffComputationStatus.Completed,
            Result = new DiffResult
            {
                Stats = new DiffStats { AddedLines = 15, RemovedLines = 3 }
            }
        };

        // Assert
        Assert.Equal("+15 -3", vm.StatsDisplay);
    }

    [Fact]
    public void StatsDisplay_ShowsNewFile_WhenNoChanges()
    {
        // Arrange
        var vm = new StreamingDiffViewModel
        {
            Status = DiffComputationStatus.Completed,
            IsNewFile = true,
            Result = new DiffResult
            {
                Stats = new DiffStats()
            }
        };

        // Assert
        Assert.Equal("New file", vm.StatsDisplay);
    }

    [Fact]
    public void ShowStats_TrueWhenHasChanges()
    {
        // Arrange
        var vm = new StreamingDiffViewModel
        {
            Status = DiffComputationStatus.Completed,
            Result = new DiffResult
            {
                Hunks = new[] { new DiffHunk() },
                Stats = new DiffStats { AddedLines = 1 }
            }
        };

        // Assert
        Assert.True(vm.ShowStats);
    }

    [Fact]
    public void ShowSpinner_TrueWhenComputing()
    {
        // Arrange
        var vm = new StreamingDiffViewModel
        {
            Status = DiffComputationStatus.Computing
        };

        // Assert
        Assert.True(vm.ShowSpinner);
    }

    [Fact]
    public void ShowError_TrueWhenFailedWithMessage()
    {
        // Arrange
        var vm = new StreamingDiffViewModel
        {
            Status = DiffComputationStatus.Failed,
            ErrorMessage = "File not found"
        };

        // Assert
        Assert.True(vm.ShowError);
    }
}
```

---

## Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Models/DiffComputationState.cs` | Streaming diff state tracking |
| `src/SeniorIntern.Core/Models/DiffComputationStatus.cs` | Status enum |
| `src/SeniorIntern.Core/Events/DiffComputedEventArgs.cs` | Diff computed event args |
| `src/SeniorIntern.Core/Interfaces/IStreamingDiffCoordinator.cs` | Coordinator interface |
| `src/SeniorIntern.Services/Streaming/StreamingDiffCoordinator.cs` | Coordinator implementation |
| `src/SeniorIntern.Services/Streaming/DiffComputationQueue.cs` | Debounced computation queue |
| `src/SeniorIntern.Desktop/ViewModels/StreamingDiffViewModel.cs` | Streaming diff ViewModel |
| `src/SeniorIntern.Desktop/Controls/StreamingDiffPreviewControl.axaml` | Preview UI control |
| `src/SeniorIntern.Desktop/Controls/StreamingDiffPreviewControl.axaml.cs` | Control code-behind |
| `tests/SeniorIntern.Core.Tests/Models/DiffComputationStateTests.cs` | State model tests |
| `tests/SeniorIntern.Services.Tests/Streaming/StreamingDiffCoordinatorTests.cs` | Coordinator tests |
| `tests/SeniorIntern.Services.Tests/Streaming/DiffComputationQueueTests.cs` | Queue tests |
| `tests/SeniorIntern.Desktop.Tests/ViewModels/StreamingDiffViewModelTests.cs` | ViewModel tests |

---

## Files to Modify

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/ViewModels/CodeBlockViewModel.cs` | Add streaming diff properties and methods |
| `src/SeniorIntern.Desktop/Controls/CodeBlockControl.axaml` | Include StreamingDiffPreviewControl |
| `src/SeniorIntern.Desktop/Extensions/ServiceCollectionExtensions.cs` | Register streaming diff services |

---

## Acceptance Criteria

### Functional Requirements

1. **Diff Computation During Streaming**
   - [ ] Diffs compute as code blocks are detected during LLM streaming
   - [ ] Updates are debounced (250ms default) to avoid excessive computation
   - [ ] Content hashing detects actual changes vs. spurious updates
   - [ ] Final computation runs when streaming completes

2. **Status Tracking**
   - [ ] Each code block has tracked computation state
   - [ ] States transition: Pending → Computing → Completed/Failed/Cancelled
   - [ ] Error messages captured for failed computations
   - [ ] Computation count tracks recomputations

3. **Settings Integration**
   - [ ] Respects `ShowDiffPreviewDuringStreaming` setting from v0.4.5a
   - [ ] When disabled, returns cancelled state with explanation
   - [ ] Setting changes take effect on next streaming session

4. **UI Preview**
   - [ ] Shows spinner during computation
   - [ ] Displays +/- stats when complete
   - [ ] Shows error indicator on failure
   - [ ] Click triggers full diff preview

5. **Performance**
   - [ ] Debouncing prevents excessive computation
   - [ ] Content hashing avoids unnecessary recomputation
   - [ ] Queue processes efficiently without blocking UI
   - [ ] Finalize bypasses debounce for immediate results

### Non-Functional Requirements

1. **Thread Safety**
   - [ ] ConcurrentDictionary for state storage
   - [ ] Channel-based queue for async processing
   - [ ] Safe cancellation and disposal

2. **Memory Management**
   - [ ] States cleaned up on Reset()
   - [ ] Proper disposal of CancellationTokenSource instances
   - [ ] No memory leaks from event handlers

3. **Error Handling**
   - [ ] File read errors captured gracefully
   - [ ] Cancellation handled without exceptions
   - [ ] Failed computations don't block others

---

## Design Decisions

### 1. Debounce Strategy

**Decision**: Use 250ms debounce with coalescing for same-block updates.

**Rationale**:
- LLM streaming sends frequent token updates
- Full diff computation on every token is wasteful
- 250ms balances responsiveness with efficiency
- Coalescing keeps only the latest content

**Alternatives Considered**:
- No debouncing (every update) - Too expensive
- Longer debounce (500ms+) - Too laggy for user experience
- Token count threshold - Complex, doesn't account for file size

### 2. Priority Queue

**Decision**: Three-level priority (Detect < Update < Finalize).

**Rationale**:
- Initial detection can wait for debounce
- Updates should coalesce but still compute
- Finalize must run immediately for accurate final result
- Higher priority requests replace lower ones for same block

### 3. Content Hashing

**Decision**: SHA256 hash to detect actual content changes.

**Rationale**:
- String comparison too expensive for large content
- Hash comparison is O(1) after initial computation
- SHA256 is fast enough for this use case
- Avoids recomputing diff when content unchanged

### 4. Event-Based Communication

**Decision**: DiffComputed event for coordinator → ViewModel communication.

**Rationale**:
- Decouples coordinator from specific ViewModels
- Supports multiple listeners
- Works well with Avalonia's UI thread marshaling
- Events can be filtered by BlockId

### 5. State Storage

**Decision**: ConcurrentDictionary keyed by BlockId.

**Rationale**:
- Thread-safe access from queue processor and callers
- O(1) lookup by block ID
- Atomic GetOrAdd for initial state creation
- Easy enumeration for CancelAll/Reset

---

## Accessibility Considerations

1. **Status Announcements**
   - Computing state should be announced by screen readers
   - Completion/failure should trigger announcements
   - Stats should be readable (not just color-coded)

2. **Keyboard Navigation**
   - Preview button accessible via Tab
   - Spinner doesn't trap focus

3. **Color Contrast**
   - Stats colors (green/red/yellow) have sufficient contrast
   - Error state uses both color and icon

---

## Performance Considerations

1. **Debounce Tuning**
   - 250ms default is configurable via constants
   - Consider user-adjustable in future settings

2. **File I/O**
   - Original file read cached if workspace service supports it
   - Async file reads don't block UI

3. **Diff Computation**
   - DiffPlex is efficient for typical file sizes
   - Very large files may need chunking (future enhancement)

4. **Memory**
   - DiffResult stored per block (consider size limits)
   - Old states cleaned on conversation change

---

## Dependencies

### Internal Dependencies
- v0.4.1 (Code Block Extraction) - CodeBlock model, streaming parser
- v0.4.2 (Diff Engine) - IDiffService, DiffResult, DiffStats
- v0.4.5a (Settings Models) - ShowDiffPreviewDuringStreaming setting

### External Dependencies
- System.Threading.Channels (queue implementation)
- System.Security.Cryptography (content hashing)

### Consumers
- v0.4.5g (Quick Actions) - Uses streaming diff for preview
- v0.4.5h (Change History) - May track diff results
