# v0.4.5c: Partial Snippet Models - Design Specification

**Status**: _PLANNED_

## Executive Summary

This specification details the **Partial Snippet Models** for The Senior Intern, defining the data structures that enable applying code snippets to specific locations within files rather than replacing entire file contents. These models support line-based operations including replacement of specific line ranges, insertion before/after specific lines, and appending/prepending content.

### Key Deliverables

| Component | Type | Purpose |
|-----------|------|---------|
| `LineRange` | Struct | Represents a range of lines (1-indexed, inclusive) |
| `SnippetInsertMode` | Enum | How to insert a snippet (Replace, InsertBefore, InsertAfter, etc.) |
| `SnippetApplyOptions` | Record | Configuration for applying a snippet to a file |
| `SnippetContext` | Class | Context information about where a snippet should be applied |
| `IndentationStyle` | Record | Detected or specified indentation style |
| `SnippetAnchor` | Class | Text-based anchor for locating insertion points |
| `AnchorMatchResult` | Class | Result of searching for an anchor in file content |

---

## Feature Overview

```
v0.4.5c: Partial Snippet Models
├── Line Range Models
│   ├── LineRange (struct)
│   │   ├── StartLine (int, 1-indexed, inclusive)
│   │   ├── EndLine (int, 1-indexed, inclusive)
│   │   ├── LineCount (computed)
│   │   ├── IsValid (computed)
│   │   ├── Factory Methods
│   │   │   ├── SingleLine(int)
│   │   │   ├── FromLine(int) → to end
│   │   │   ├── EntireFile(int lineCount)
│   │   │   └── Empty
│   │   └── Query Methods
│   │       ├── Contains(int line)
│   │       ├── Overlaps(LineRange)
│   │       ├── Merge(LineRange)
│   │       └── Intersect(LineRange)
│   └── ColumnRange (struct)
│       ├── StartColumn (int, 0-indexed)
│       ├── EndColumn (int, 0-indexed, exclusive)
│       └── For future character-level operations
├── Insert Mode
│   └── SnippetInsertMode (enum, 6 values)
│       ├── Replace (replace specific lines)
│       ├── InsertBefore (insert before target line)
│       ├── InsertAfter (insert after target line)
│       ├── Append (add to end of file)
│       ├── Prepend (add to beginning of file)
│       └── ReplaceFile (replace entire file)
├── Apply Options
│   └── SnippetApplyOptions (record)
│       ├── InsertMode (SnippetInsertMode)
│       ├── TargetLine (int?, for Before/After)
│       ├── ReplaceRange (LineRange?, for Replace)
│       ├── Anchor (SnippetAnchor?, text-based location)
│       ├── PreserveIndentation (bool, default: true)
│       ├── IndentationOverride (string?)
│       ├── AddBlankLineBefore (bool)
│       ├── AddBlankLineAfter (bool)
│       ├── TrimTrailingWhitespace (bool, default: true)
│       ├── NormalizeLineEndings (bool, default: true)
│       └── Factory Methods
│           ├── FullReplace
│           ├── ReplaceLines(start, end)
│           ├── InsertAfterLine(line)
│           ├── InsertBeforeLine(line)
│           ├── AppendToFile
│           ├── PrependToFile
│           └── FromAnchor(anchor, mode)
├── Snippet Context
│   └── SnippetContext (class)
│       ├── FilePath (string)
│       ├── OriginalContent (string)
│       ├── OriginalLines (IReadOnlyList<string>)
│       ├── LineCount (int)
│       ├── DetectedIndentation (IndentationStyle)
│       ├── LineEnding (string, \n or \r\n)
│       ├── HasTrailingNewline (bool)
│       └── Methods
│           ├── GetLine(int) → string
│           ├── GetLines(LineRange) → IEnumerable<string>
│           ├── GetLineIndentation(int) → string
│           └── FindText(string) → LineRange?
├── Indentation
│   └── IndentationStyle (record)
│       ├── UseTabs (bool)
│       ├── SpacesPerIndent (int, 1-8)
│       ├── Confidence (double, 0.0-1.0)
│       ├── IndentString (computed)
│       └── Static Instances
│           ├── Default (4 spaces)
│           ├── TwoSpaces
│           ├── Tabs
│           └── Unknown
└── Anchor System
    ├── SnippetAnchor (class)
    │   ├── AnchorType (enum)
    │   │   ├── ExactText (literal match)
    │   │   ├── Regex (pattern match)
    │   │   ├── FunctionSignature (method/function)
    │   │   ├── ClassDeclaration (class/struct)
    │   │   └── CommentMarker (// TODO, etc.)
    │   ├── Pattern (string)
    │   ├── Occurrence (int, 1 = first, -1 = last)
    │   ├── Offset (int, lines from anchor)
    │   └── CaseSensitive (bool)
    └── AnchorMatchResult (class)
        ├── Found (bool)
        ├── MatchedLine (int?)
        ├── MatchedText (string?)
        ├── Confidence (double)
        └── Alternatives (IReadOnlyList<int>)
```

---

## Architecture Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         Partial Snippet Model Layer                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │                          LineRange (struct)                            │  │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐   │  │
│  │  │ StartLine   │  │  EndLine    │  │ LineCount   │  │  IsValid    │   │  │
│  │  │ (1-indexed) │  │ (inclusive) │  │ (computed)  │  │ (computed)  │   │  │
│  │  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘   │  │
│  │  ┌─────────────────────────────────────────────────────────────────┐  │  │
│  │  │ Methods: Contains, Overlaps, Merge, Intersect, Expand, Shift    │  │  │
│  │  └─────────────────────────────────────────────────────────────────┘  │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │                     SnippetInsertMode (enum)                          │  │
│  │  ┌─────────┐ ┌────────────┐ ┌───────────┐ ┌────────┐ ┌─────────────┐  │  │
│  │  │ Replace │ │InsertBefore│ │InsertAfter│ │ Append │ │ ReplaceFile │  │  │
│  │  └─────────┘ └────────────┘ └───────────┘ └────────┘ └─────────────┘  │  │
│  │                        ┌─────────┐                                     │  │
│  │                        │ Prepend │                                     │  │
│  │                        └─────────┘                                     │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │                    SnippetApplyOptions (record)                        │  │
│  │  ┌─────────────────────────────────────────────────────────────────┐  │  │
│  │  │                    Location Specification                        │  │  │
│  │  │  ┌────────────┐  ┌────────────┐  ┌────────────┐  ┌────────────┐  │  │  │
│  │  │  │ InsertMode │  │ TargetLine │  │ReplaceRange│  │   Anchor   │  │  │  │
│  │  │  └────────────┘  └────────────┘  └────────────┘  └────────────┘  │  │  │
│  │  └─────────────────────────────────────────────────────────────────┘  │  │
│  │  ┌─────────────────────────────────────────────────────────────────┐  │  │
│  │  │                    Formatting Options                            │  │  │
│  │  │  ┌──────────────────┐  ┌──────────────────┐  ┌────────────────┐  │  │  │
│  │  │  │PreserveIndentation│ │IndentationOverride│ │ TrimWhitespace │  │  │  │
│  │  │  └──────────────────┘  └──────────────────┘  └────────────────┘  │  │  │
│  │  │  ┌──────────────────┐  ┌──────────────────┐                      │  │  │
│  │  │  │ AddBlankBefore   │  │  AddBlankAfter   │                      │  │  │
│  │  │  └──────────────────┘  └──────────────────┘                      │  │  │
│  │  └─────────────────────────────────────────────────────────────────┘  │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │                       SnippetContext (class)                          │  │
│  │  ┌──────────┐  ┌───────────────┐  ┌────────────────┐  ┌────────────┐  │  │
│  │  │ FilePath │  │OriginalContent│  │OriginalLines[] │  │ LineCount  │  │  │
│  │  └──────────┘  └───────────────┘  └────────────────┘  └────────────┘  │  │
│  │  ┌──────────────────┐  ┌────────────┐  ┌──────────────────────────┐   │  │
│  │  │DetectedIndentation│  │ LineEnding │  │ HasTrailingNewline       │   │  │
│  │  └──────────────────┘  └────────────┘  └──────────────────────────┘   │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │                       SnippetAnchor (class)                           │  │
│  │  ┌────────────┐  ┌─────────┐  ┌────────────┐  ┌───────┐  ┌─────────┐  │  │
│  │  │ AnchorType │  │ Pattern │  │ Occurrence │  │Offset │  │CaseSens │  │  │
│  │  └────────────┘  └─────────┘  └────────────┘  └───────┘  └─────────┘  │  │
│  │                                                                       │  │
│  │  AnchorType: ExactText | Regex | FunctionSignature | ClassDeclaration │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Usage Flow Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        Snippet Apply Flow                                    │
└─────────────────────────────────────────────────────────────────────────────┘

     User selects snippet          User chooses
     from code block               insert location
            │                            │
            ▼                            ▼
┌─────────────────────┐      ┌─────────────────────────┐
│   Code Block with   │      │   Location Selection    │
│   snippet content   │      │   (UI from v0.4.5e)     │
└──────────┬──────────┘      └────────────┬────────────┘
           │                              │
           │                              ▼
           │               ┌──────────────────────────────┐
           │               │    SnippetApplyOptions       │
           │               │  ┌────────────────────────┐  │
           │               │  │ InsertMode: InsertAfter│  │
           │               │  │ TargetLine: 42         │  │
           │               │  │ PreserveIndentation: ✓ │  │
           │               │  │ AddBlankLineBefore: ✓  │  │
           │               │  └────────────────────────┘  │
           │               └──────────────┬───────────────┘
           │                              │
           ▼                              ▼
┌─────────────────────────────────────────────────────────────┐
│                  SnippetApplyService (v0.4.5d)              │
│                                                             │
│  1. Load file content → SnippetContext                      │
│  2. Resolve anchor (if using text-based location)           │
│  3. Validate options against file                           │
│  4. Adjust indentation                                      │
│  5. Compute result content                                  │
│  6. Generate diff                                           │
│                                                             │
└──────────────────────────────┬──────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────┐
│                 SnippetApplyPreview                          │
│  ┌───────────────────────────────────────────────────────┐  │
│  │ ResultContent: "...merged file content..."             │  │
│  │ Diff: DiffResult with hunks                            │  │
│  │ AffectedRange: Lines 42-55                             │  │
│  │ LinesAdded: 14                                         │  │
│  │ LinesRemoved: 0                                        │  │
│  └───────────────────────────────────────────────────────┘  │
└──────────────────────────────┬──────────────────────────────┘
                               │
            ┌──────────────────┴───────────────────┐
            │                                      │
            ▼                                      ▼
   ┌─────────────────┐                   ┌─────────────────┐
   │  User reviews   │                   │  User confirms  │
   │  diff preview   │                   │  and applies    │
   └─────────────────┘                   └────────┬────────┘
                                                  │
                                                  ▼
                                         ┌─────────────────┐
                                         │ SnippetApply    │
                                         │ Result          │
                                         │ (Success/Fail)  │
                                         └─────────────────┘
```

---

## Detailed Design

### 1. LineRange Struct

```csharp
// src/SeniorIntern.Core/Models/LineRange.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Represents a range of lines in a file (1-indexed, inclusive).
/// </summary>
public readonly struct LineRange : IEquatable<LineRange>, IComparable<LineRange>
{
    /// <summary>
    /// Start line number (1-indexed, inclusive).
    /// </summary>
    public int StartLine { get; }

    /// <summary>
    /// End line number (1-indexed, inclusive).
    /// </summary>
    public int EndLine { get; }

    /// <summary>
    /// Creates a new line range.
    /// </summary>
    /// <param name="startLine">Start line (1-indexed, inclusive).</param>
    /// <param name="endLine">End line (1-indexed, inclusive).</param>
    public LineRange(int startLine, int endLine)
    {
        StartLine = startLine;
        EndLine = endLine;
    }

    // ═══════════════════════════════════════════════════════════════
    // Computed Properties
    // ═══════════════════════════════════════════════════════════════

    /// <summary>
    /// Number of lines in this range (inclusive).
    /// </summary>
    public int LineCount => IsValid ? EndLine - StartLine + 1 : 0;

    /// <summary>
    /// Whether this is a valid range (StartLine > 0 and EndLine >= StartLine).
    /// </summary>
    public bool IsValid => StartLine > 0 && EndLine >= StartLine;

    /// <summary>
    /// Whether this is an empty range.
    /// </summary>
    public bool IsEmpty => !IsValid || LineCount == 0;

    /// <summary>
    /// Whether this is a single-line range.
    /// </summary>
    public bool IsSingleLine => IsValid && StartLine == EndLine;

    // ═══════════════════════════════════════════════════════════════
    // Factory Methods
    // ═══════════════════════════════════════════════════════════════

    /// <summary>
    /// An empty/invalid range.
    /// </summary>
    public static LineRange Empty => new(0, 0);

    /// <summary>
    /// Creates a range for a single line.
    /// </summary>
    /// <param name="line">The line number (1-indexed).</param>
    public static LineRange SingleLine(int line) => new(line, line);

    /// <summary>
    /// Creates a range from a start line to the end of file.
    /// The EndLine is set to int.MaxValue and should be clamped when used.
    /// </summary>
    /// <param name="startLine">Start line (1-indexed).</param>
    public static LineRange FromLine(int startLine) => new(startLine, int.MaxValue);

    /// <summary>
    /// Creates a range representing the entire file.
    /// </summary>
    /// <param name="lineCount">Total number of lines in the file.</param>
    public static LineRange EntireFile(int lineCount) => new(1, lineCount);

    /// <summary>
    /// Creates a range from a 0-indexed array bounds.
    /// </summary>
    /// <param name="startIndex">0-indexed start.</param>
    /// <param name="endIndex">0-indexed end (exclusive).</param>
    public static LineRange FromZeroIndexed(int startIndex, int endIndex) =>
        new(startIndex + 1, endIndex);

    // ═══════════════════════════════════════════════════════════════
    // Query Methods
    // ═══════════════════════════════════════════════════════════════

    /// <summary>
    /// Checks if the given line number is within this range.
    /// </summary>
    /// <param name="lineNumber">Line number to check (1-indexed).</param>
    public bool Contains(int lineNumber) =>
        IsValid && lineNumber >= StartLine && lineNumber <= EndLine;

    /// <summary>
    /// Checks if this range contains another range entirely.
    /// </summary>
    public bool Contains(LineRange other) =>
        IsValid && other.IsValid &&
        other.StartLine >= StartLine && other.EndLine <= EndLine;

    /// <summary>
    /// Checks if this range overlaps with another range.
    /// </summary>
    public bool Overlaps(LineRange other) =>
        IsValid && other.IsValid &&
        StartLine <= other.EndLine && EndLine >= other.StartLine;

    /// <summary>
    /// Checks if this range is adjacent to another (touching but not overlapping).
    /// </summary>
    public bool IsAdjacentTo(LineRange other) =>
        IsValid && other.IsValid &&
        (EndLine + 1 == other.StartLine || other.EndLine + 1 == StartLine);

    // ═══════════════════════════════════════════════════════════════
    // Transformation Methods
    // ═══════════════════════════════════════════════════════════════

    /// <summary>
    /// Merges this range with another, creating a range that spans both.
    /// </summary>
    public LineRange Merge(LineRange other)
    {
        if (!IsValid) return other;
        if (!other.IsValid) return this;
        return new LineRange(
            Math.Min(StartLine, other.StartLine),
            Math.Max(EndLine, other.EndLine));
    }

    /// <summary>
    /// Returns the intersection of this range with another.
    /// </summary>
    public LineRange Intersect(LineRange other)
    {
        if (!Overlaps(other)) return Empty;
        return new LineRange(
            Math.Max(StartLine, other.StartLine),
            Math.Min(EndLine, other.EndLine));
    }

    /// <summary>
    /// Expands the range by the specified number of lines on each side.
    /// </summary>
    /// <param name="linesBefore">Lines to add before (clamped to 1).</param>
    /// <param name="linesAfter">Lines to add after.</param>
    public LineRange Expand(int linesBefore, int linesAfter) =>
        IsValid
            ? new LineRange(
                Math.Max(1, StartLine - linesBefore),
                EndLine + linesAfter)
            : this;

    /// <summary>
    /// Shifts the range by the specified number of lines.
    /// </summary>
    /// <param name="offset">Number of lines to shift (positive = down, negative = up).</param>
    public LineRange Shift(int offset) =>
        IsValid
            ? new LineRange(
                Math.Max(1, StartLine + offset),
                Math.Max(1, EndLine + offset))
            : this;

    /// <summary>
    /// Clamps the range to fit within the specified bounds.
    /// </summary>
    /// <param name="maxLine">Maximum line number.</param>
    public LineRange ClampTo(int maxLine) =>
        IsValid
            ? new LineRange(
                Math.Min(StartLine, maxLine),
                Math.Min(EndLine, maxLine))
            : this;

    // ═══════════════════════════════════════════════════════════════
    // Conversion Methods
    // ═══════════════════════════════════════════════════════════════

    /// <summary>
    /// Converts to 0-indexed start position (for array access).
    /// </summary>
    public int ToZeroIndexedStart() => StartLine - 1;

    /// <summary>
    /// Converts to 0-indexed end position (exclusive, for array slicing).
    /// </summary>
    public int ToZeroIndexedEnd() => EndLine;

    /// <summary>
    /// Enumerates all line numbers in this range.
    /// </summary>
    public IEnumerable<int> EnumerateLines()
    {
        if (!IsValid) yield break;
        for (int i = StartLine; i <= EndLine; i++)
            yield return i;
    }

    // ═══════════════════════════════════════════════════════════════
    // Equality and Comparison
    // ═══════════════════════════════════════════════════════════════

    public bool Equals(LineRange other) =>
        StartLine == other.StartLine && EndLine == other.EndLine;

    public override bool Equals(object? obj) =>
        obj is LineRange other && Equals(other);

    public override int GetHashCode() =>
        HashCode.Combine(StartLine, EndLine);

    public int CompareTo(LineRange other)
    {
        var startComparison = StartLine.CompareTo(other.StartLine);
        return startComparison != 0 ? startComparison : EndLine.CompareTo(other.EndLine);
    }

    public static bool operator ==(LineRange left, LineRange right) => left.Equals(right);
    public static bool operator !=(LineRange left, LineRange right) => !left.Equals(right);
    public static bool operator <(LineRange left, LineRange right) => left.CompareTo(right) < 0;
    public static bool operator >(LineRange left, LineRange right) => left.CompareTo(right) > 0;
    public static bool operator <=(LineRange left, LineRange right) => left.CompareTo(right) <= 0;
    public static bool operator >=(LineRange left, LineRange right) => left.CompareTo(right) >= 0;

    public override string ToString() =>
        !IsValid ? "Invalid"
        : IsSingleLine ? $"Line {StartLine}"
        : $"Lines {StartLine}-{EndLine}";

    /// <summary>
    /// Formats as a unified diff header range.
    /// </summary>
    public string ToDiffHeader() =>
        IsSingleLine ? $"{StartLine}" : $"{StartLine},{LineCount}";
}
```

### 2. ColumnRange Struct

```csharp
// src/SeniorIntern.Core/Models/ColumnRange.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Represents a range of columns within a line (0-indexed, end exclusive).
/// Reserved for future character-level operations.
/// </summary>
public readonly struct ColumnRange : IEquatable<ColumnRange>
{
    /// <summary>
    /// Start column (0-indexed, inclusive).
    /// </summary>
    public int StartColumn { get; }

    /// <summary>
    /// End column (0-indexed, exclusive).
    /// </summary>
    public int EndColumn { get; }

    /// <summary>
    /// Creates a new column range.
    /// </summary>
    public ColumnRange(int startColumn, int endColumn)
    {
        StartColumn = startColumn;
        EndColumn = endColumn;
    }

    /// <summary>
    /// Number of characters in this range.
    /// </summary>
    public int Length => IsValid ? EndColumn - StartColumn : 0;

    /// <summary>
    /// Whether this is a valid range.
    /// </summary>
    public bool IsValid => StartColumn >= 0 && EndColumn >= StartColumn;

    /// <summary>
    /// An empty column range.
    /// </summary>
    public static ColumnRange Empty => new(0, 0);

    /// <summary>
    /// Creates a range representing the entire line.
    /// </summary>
    public static ColumnRange EntireLine(int lineLength) => new(0, lineLength);

    /// <summary>
    /// Creates a range from start to end of line.
    /// </summary>
    public static ColumnRange FromColumn(int startColumn) => new(startColumn, int.MaxValue);

    public bool Equals(ColumnRange other) =>
        StartColumn == other.StartColumn && EndColumn == other.EndColumn;

    public override bool Equals(object? obj) =>
        obj is ColumnRange other && Equals(other);

    public override int GetHashCode() =>
        HashCode.Combine(StartColumn, EndColumn);

    public static bool operator ==(ColumnRange left, ColumnRange right) => left.Equals(right);
    public static bool operator !=(ColumnRange left, ColumnRange right) => !left.Equals(right);

    public override string ToString() =>
        !IsValid ? "Invalid" : $"Columns {StartColumn}-{EndColumn}";
}
```

### 3. SnippetInsertMode Enum

```csharp
// src/SeniorIntern.Core/Models/SnippetInsertMode.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Specifies how a code snippet should be inserted into a file.
/// </summary>
public enum SnippetInsertMode
{
    /// <summary>
    /// Replace specific lines in the file with the snippet content.
    /// Requires ReplaceRange to be specified.
    /// </summary>
    Replace = 0,

    /// <summary>
    /// Insert the snippet before a specific line.
    /// Requires TargetLine to be specified.
    /// </summary>
    InsertBefore = 1,

    /// <summary>
    /// Insert the snippet after a specific line.
    /// Requires TargetLine to be specified.
    /// </summary>
    InsertAfter = 2,

    /// <summary>
    /// Append the snippet to the end of the file.
    /// No additional parameters required.
    /// </summary>
    Append = 3,

    /// <summary>
    /// Prepend the snippet to the beginning of the file.
    /// No additional parameters required.
    /// </summary>
    Prepend = 4,

    /// <summary>
    /// Replace the entire file contents with the snippet.
    /// No additional parameters required.
    /// </summary>
    ReplaceFile = 5
}
```

### 4. SnippetAnchorType Enum

```csharp
// src/SeniorIntern.Core/Models/SnippetAnchorType.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Type of text-based anchor for locating insertion points.
/// </summary>
public enum SnippetAnchorType
{
    /// <summary>
    /// Match exact text (literal string match).
    /// </summary>
    ExactText = 0,

    /// <summary>
    /// Match using a regular expression pattern.
    /// </summary>
    Regex = 1,

    /// <summary>
    /// Match a function or method signature.
    /// Pattern should be the function name or partial signature.
    /// </summary>
    FunctionSignature = 2,

    /// <summary>
    /// Match a class, struct, or interface declaration.
    /// Pattern should be the type name.
    /// </summary>
    ClassDeclaration = 3,

    /// <summary>
    /// Match a comment marker (e.g., // TODO, // FIXME).
    /// Pattern should be the marker text.
    /// </summary>
    CommentMarker = 4,

    /// <summary>
    /// Match an import or using statement.
    /// Pattern should be the namespace or module.
    /// </summary>
    ImportStatement = 5,

    /// <summary>
    /// Match a property or field declaration.
    /// Pattern should be the member name.
    /// </summary>
    MemberDeclaration = 6
}
```

### 5. SnippetAnchor Class

```csharp
// src/SeniorIntern.Core/Models/SnippetAnchor.cs
using System.Text.RegularExpressions;

namespace SeniorIntern.Core.Models;

/// <summary>
/// Represents a text-based anchor for locating insertion points in a file.
/// </summary>
public sealed class SnippetAnchor
{
    /// <summary>
    /// Type of anchor matching to use.
    /// </summary>
    public SnippetAnchorType AnchorType { get; init; } = SnippetAnchorType.ExactText;

    /// <summary>
    /// The pattern to match against.
    /// For ExactText: literal string to find.
    /// For Regex: regular expression pattern.
    /// For FunctionSignature: function name or partial signature.
    /// For ClassDeclaration: class/struct/interface name.
    /// For CommentMarker: marker text (e.g., "TODO").
    /// </summary>
    public string Pattern { get; init; } = string.Empty;

    /// <summary>
    /// Which occurrence to match.
    /// Positive numbers: 1 = first, 2 = second, etc.
    /// Negative numbers: -1 = last, -2 = second-to-last, etc.
    /// </summary>
    public int Occurrence { get; init; } = 1;

    /// <summary>
    /// Line offset from the anchor.
    /// Positive: lines after the anchor.
    /// Negative: lines before the anchor.
    /// Zero: the anchor line itself.
    /// </summary>
    public int Offset { get; init; } = 0;

    /// <summary>
    /// Whether pattern matching is case-sensitive.
    /// Default is true for code matching.
    /// </summary>
    public bool CaseSensitive { get; init; } = true;

    /// <summary>
    /// Whether to match whole words only.
    /// Applies to ExactText and some other types.
    /// </summary>
    public bool WholeWordOnly { get; init; } = false;

    /// <summary>
    /// Description of what this anchor represents (for UI display).
    /// </summary>
    public string? Description { get; init; }

    // ═══════════════════════════════════════════════════════════════
    // Factory Methods
    // ═══════════════════════════════════════════════════════════════

    /// <summary>
    /// Creates an anchor for exact text matching.
    /// </summary>
    public static SnippetAnchor ExactText(string text, int occurrence = 1) => new()
    {
        AnchorType = SnippetAnchorType.ExactText,
        Pattern = text,
        Occurrence = occurrence,
        Description = $"Text: \"{TruncateForDisplay(text)}\""
    };

    /// <summary>
    /// Creates an anchor for regex pattern matching.
    /// </summary>
    public static SnippetAnchor RegexPattern(string pattern, int occurrence = 1) => new()
    {
        AnchorType = SnippetAnchorType.Regex,
        Pattern = pattern,
        Occurrence = occurrence,
        Description = $"Pattern: {TruncateForDisplay(pattern)}"
    };

    /// <summary>
    /// Creates an anchor for a function or method.
    /// </summary>
    public static SnippetAnchor Function(string functionName, int occurrence = 1) => new()
    {
        AnchorType = SnippetAnchorType.FunctionSignature,
        Pattern = functionName,
        Occurrence = occurrence,
        WholeWordOnly = true,
        Description = $"Function: {functionName}"
    };

    /// <summary>
    /// Creates an anchor for a class, struct, or interface.
    /// </summary>
    public static SnippetAnchor Class(string className, int occurrence = 1) => new()
    {
        AnchorType = SnippetAnchorType.ClassDeclaration,
        Pattern = className,
        Occurrence = occurrence,
        WholeWordOnly = true,
        Description = $"Class: {className}"
    };

    /// <summary>
    /// Creates an anchor for a comment marker.
    /// </summary>
    public static SnippetAnchor CommentMarker(string marker, int occurrence = 1) => new()
    {
        AnchorType = SnippetAnchorType.CommentMarker,
        Pattern = marker,
        Occurrence = occurrence,
        CaseSensitive = false,
        Description = $"Comment: {marker}"
    };

    /// <summary>
    /// Creates an anchor for an import/using statement.
    /// </summary>
    public static SnippetAnchor Import(string namespaceName) => new()
    {
        AnchorType = SnippetAnchorType.ImportStatement,
        Pattern = namespaceName,
        Occurrence = -1, // Last import, so new import goes after
        Description = $"After imports for: {namespaceName}"
    };

    /// <summary>
    /// Creates an anchor after the last import statement.
    /// </summary>
    public static SnippetAnchor AfterLastImport() => new()
    {
        AnchorType = SnippetAnchorType.ImportStatement,
        Pattern = string.Empty,
        Occurrence = -1,
        Offset = 1,
        Description = "After last import"
    };

    // ═══════════════════════════════════════════════════════════════
    // Validation
    // ═══════════════════════════════════════════════════════════════

    /// <summary>
    /// Validates that this anchor is properly configured.
    /// </summary>
    public bool IsValid => AnchorType switch
    {
        SnippetAnchorType.ExactText => !string.IsNullOrEmpty(Pattern),
        SnippetAnchorType.Regex => IsValidRegex(Pattern),
        SnippetAnchorType.FunctionSignature => !string.IsNullOrWhiteSpace(Pattern),
        SnippetAnchorType.ClassDeclaration => !string.IsNullOrWhiteSpace(Pattern),
        SnippetAnchorType.CommentMarker => !string.IsNullOrWhiteSpace(Pattern),
        SnippetAnchorType.ImportStatement => true, // Empty pattern means "any import"
        SnippetAnchorType.MemberDeclaration => !string.IsNullOrWhiteSpace(Pattern),
        _ => false
    };

    private static bool IsValidRegex(string pattern)
    {
        if (string.IsNullOrEmpty(pattern)) return false;
        try
        {
            _ = new Regex(pattern);
            return true;
        }
        catch
        {
            return false;
        }
    }

    private static string TruncateForDisplay(string text, int maxLength = 30)
    {
        if (text.Length <= maxLength) return text;
        return text[..(maxLength - 3)] + "...";
    }

    public override string ToString() =>
        Description ?? $"{AnchorType}: {Pattern}";
}
```

### 6. AnchorMatchResult Class

```csharp
// src/SeniorIntern.Core/Models/AnchorMatchResult.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Result of searching for an anchor in file content.
/// </summary>
public sealed class AnchorMatchResult
{
    /// <summary>
    /// Whether the anchor was found.
    /// </summary>
    public bool Found { get; init; }

    /// <summary>
    /// The line number where the anchor was found (1-indexed).
    /// Null if not found.
    /// </summary>
    public int? MatchedLine { get; init; }

    /// <summary>
    /// The actual text that matched the anchor pattern.
    /// </summary>
    public string? MatchedText { get; init; }

    /// <summary>
    /// Confidence level of the match (0.0 to 1.0).
    /// 1.0 = exact match, lower values for fuzzy matches.
    /// </summary>
    public double Confidence { get; init; }

    /// <summary>
    /// Line range of the matched construct (e.g., entire function for FunctionSignature).
    /// </summary>
    public LineRange? MatchedRange { get; init; }

    /// <summary>
    /// Column range within the matched line.
    /// </summary>
    public ColumnRange? MatchedColumns { get; init; }

    /// <summary>
    /// Alternative line numbers where partial or similar matches were found.
    /// Useful for disambiguation in UI.
    /// </summary>
    public IReadOnlyList<int> Alternatives { get; init; } = Array.Empty<int>();

    /// <summary>
    /// Error message if the search failed.
    /// </summary>
    public string? ErrorMessage { get; init; }

    // ═══════════════════════════════════════════════════════════════
    // Factory Methods
    // ═══════════════════════════════════════════════════════════════

    /// <summary>
    /// Creates a successful match result.
    /// </summary>
    public static AnchorMatchResult Success(
        int matchedLine,
        string? matchedText = null,
        double confidence = 1.0,
        LineRange? matchedRange = null) => new()
    {
        Found = true,
        MatchedLine = matchedLine,
        MatchedText = matchedText,
        Confidence = confidence,
        MatchedRange = matchedRange ?? LineRange.SingleLine(matchedLine)
    };

    /// <summary>
    /// Creates a not-found result.
    /// </summary>
    public static AnchorMatchResult NotFound(string? reason = null) => new()
    {
        Found = false,
        ErrorMessage = reason ?? "Anchor not found"
    };

    /// <summary>
    /// Creates a result with multiple possible matches (ambiguous).
    /// </summary>
    public static AnchorMatchResult Ambiguous(
        IReadOnlyList<int> candidateLines,
        string? message = null) => new()
    {
        Found = false,
        Alternatives = candidateLines,
        ErrorMessage = message ?? $"Multiple matches found ({candidateLines.Count})"
    };

    /// <summary>
    /// Creates an error result.
    /// </summary>
    public static AnchorMatchResult Error(string message) => new()
    {
        Found = false,
        ErrorMessage = message
    };

    /// <summary>
    /// Gets the effective line after applying anchor offset.
    /// </summary>
    public int? GetEffectiveLine(int offset)
    {
        if (!Found || !MatchedLine.HasValue) return null;
        return Math.Max(1, MatchedLine.Value + offset);
    }
}
```

### 7. IndentationStyle Record

```csharp
// src/SeniorIntern.Core/Models/IndentationStyle.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Represents the indentation style of a file.
/// </summary>
public sealed record IndentationStyle
{
    /// <summary>
    /// Whether the file uses tabs for indentation.
    /// </summary>
    public bool UseTabs { get; init; }

    /// <summary>
    /// Number of spaces per indentation level (if using spaces).
    /// Valid range: 1-8.
    /// </summary>
    public int SpacesPerIndent { get; init; } = 4;

    /// <summary>
    /// Confidence level of detection (0.0 to 1.0).
    /// Lower confidence means the detection was uncertain.
    /// </summary>
    public double Confidence { get; init; }

    /// <summary>
    /// Number of lines analyzed to determine style.
    /// </summary>
    public int LinesAnalyzed { get; init; }

    /// <summary>
    /// The string to use for one level of indentation.
    /// </summary>
    public string IndentString => UseTabs ? "\t" : new string(' ', SpacesPerIndent);

    /// <summary>
    /// Creates an indentation string for the specified level.
    /// </summary>
    /// <param name="level">Number of indentation levels.</param>
    public string GetIndent(int level)
    {
        if (level <= 0) return string.Empty;
        return UseTabs
            ? new string('\t', level)
            : new string(' ', SpacesPerIndent * level);
    }

    /// <summary>
    /// Calculates the indentation level of a given string.
    /// </summary>
    /// <param name="indent">The indentation string to analyze.</param>
    public int CalculateLevel(string indent)
    {
        if (string.IsNullOrEmpty(indent)) return 0;

        if (UseTabs)
        {
            return indent.Count(c => c == '\t');
        }

        int spaces = indent.TakeWhile(char.IsWhiteSpace).Count();
        return spaces / SpacesPerIndent;
    }

    // ═══════════════════════════════════════════════════════════════
    // Predefined Styles
    // ═══════════════════════════════════════════════════════════════

    /// <summary>
    /// Default style: 4 spaces.
    /// </summary>
    public static IndentationStyle Default => new()
    {
        UseTabs = false,
        SpacesPerIndent = 4,
        Confidence = 0.5
    };

    /// <summary>
    /// Two-space indentation (common in JavaScript/TypeScript).
    /// </summary>
    public static IndentationStyle TwoSpaces => new()
    {
        UseTabs = false,
        SpacesPerIndent = 2,
        Confidence = 1.0
    };

    /// <summary>
    /// Four-space indentation (common in Python, C#).
    /// </summary>
    public static IndentationStyle FourSpaces => new()
    {
        UseTabs = false,
        SpacesPerIndent = 4,
        Confidence = 1.0
    };

    /// <summary>
    /// Tab indentation.
    /// </summary>
    public static IndentationStyle Tabs => new()
    {
        UseTabs = true,
        SpacesPerIndent = 4, // For display purposes
        Confidence = 1.0
    };

    /// <summary>
    /// Unknown/mixed style (low confidence).
    /// </summary>
    public static IndentationStyle Unknown => new()
    {
        UseTabs = false,
        SpacesPerIndent = 4,
        Confidence = 0.0
    };

    public override string ToString() =>
        UseTabs ? "Tabs" : $"{SpacesPerIndent} spaces";
}
```

### 8. SnippetApplyOptions Record

```csharp
// src/SeniorIntern.Core/Models/SnippetApplyOptions.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Options for applying a code snippet to a specific location in a file.
/// </summary>
public sealed record SnippetApplyOptions
{
    // ═══════════════════════════════════════════════════════════════
    // Location Specification
    // ═══════════════════════════════════════════════════════════════

    /// <summary>
    /// How to insert the snippet.
    /// </summary>
    public SnippetInsertMode InsertMode { get; init; } = SnippetInsertMode.ReplaceFile;

    /// <summary>
    /// Target line for InsertBefore/InsertAfter operations (1-indexed).
    /// </summary>
    public int? TargetLine { get; init; }

    /// <summary>
    /// Lines to replace (for Replace mode).
    /// </summary>
    public LineRange? ReplaceRange { get; init; }

    /// <summary>
    /// Text-based anchor for locating the insertion point.
    /// Takes precedence over TargetLine when specified.
    /// </summary>
    public SnippetAnchor? Anchor { get; init; }

    // ═══════════════════════════════════════════════════════════════
    // Formatting Options
    // ═══════════════════════════════════════════════════════════════

    /// <summary>
    /// Whether to preserve the indentation of the target location.
    /// When true, snippet content is re-indented to match the target.
    /// </summary>
    public bool PreserveIndentation { get; init; } = true;

    /// <summary>
    /// Explicit indentation string to use.
    /// If null, indentation is auto-detected from the file.
    /// </summary>
    public string? IndentationOverride { get; init; }

    /// <summary>
    /// Whether to add a blank line before the inserted content.
    /// </summary>
    public bool AddBlankLineBefore { get; init; } = false;

    /// <summary>
    /// Whether to add a blank line after the inserted content.
    /// </summary>
    public bool AddBlankLineAfter { get; init; } = false;

    /// <summary>
    /// Whether to trim trailing whitespace from each line.
    /// </summary>
    public bool TrimTrailingWhitespace { get; init; } = true;

    /// <summary>
    /// Whether to normalize line endings to match the file's style.
    /// </summary>
    public bool NormalizeLineEndings { get; init; } = true;

    /// <summary>
    /// Whether to ensure the file ends with a newline.
    /// </summary>
    public bool EnsureTrailingNewline { get; init; } = true;

    // ═══════════════════════════════════════════════════════════════
    // Validation
    // ═══════════════════════════════════════════════════════════════

    /// <summary>
    /// Validates these options.
    /// </summary>
    public bool IsValid => InsertMode switch
    {
        SnippetInsertMode.Replace => ReplaceRange?.IsValid ?? false,
        SnippetInsertMode.InsertBefore => TargetLine > 0 || Anchor?.IsValid == true,
        SnippetInsertMode.InsertAfter => TargetLine > 0 || Anchor?.IsValid == true,
        SnippetInsertMode.Append => true,
        SnippetInsertMode.Prepend => true,
        SnippetInsertMode.ReplaceFile => true,
        _ => false
    };

    /// <summary>
    /// Gets validation errors for these options.
    /// </summary>
    public IReadOnlyList<string> GetValidationErrors()
    {
        var errors = new List<string>();

        switch (InsertMode)
        {
            case SnippetInsertMode.Replace:
                if (ReplaceRange is null)
                    errors.Add("ReplaceRange is required for Replace mode");
                else if (!ReplaceRange.Value.IsValid)
                    errors.Add("ReplaceRange is invalid");
                break;

            case SnippetInsertMode.InsertBefore:
            case SnippetInsertMode.InsertAfter:
                if (TargetLine is null && Anchor is null)
                    errors.Add($"TargetLine or Anchor is required for {InsertMode} mode");
                else if (TargetLine.HasValue && TargetLine.Value < 1)
                    errors.Add("TargetLine must be at least 1");
                else if (Anchor is not null && !Anchor.IsValid)
                    errors.Add("Anchor is invalid");
                break;
        }

        return errors;
    }

    // ═══════════════════════════════════════════════════════════════
    // Factory Methods
    // ═══════════════════════════════════════════════════════════════

    /// <summary>
    /// Creates options for full file replacement.
    /// </summary>
    public static SnippetApplyOptions FullReplace => new()
    {
        InsertMode = SnippetInsertMode.ReplaceFile
    };

    /// <summary>
    /// Creates options for replacing specific lines.
    /// </summary>
    public static SnippetApplyOptions ReplaceLines(int startLine, int endLine) => new()
    {
        InsertMode = SnippetInsertMode.Replace,
        ReplaceRange = new LineRange(startLine, endLine)
    };

    /// <summary>
    /// Creates options for replacing a line range.
    /// </summary>
    public static SnippetApplyOptions ReplaceLines(LineRange range) => new()
    {
        InsertMode = SnippetInsertMode.Replace,
        ReplaceRange = range
    };

    /// <summary>
    /// Creates options for inserting after a specific line.
    /// </summary>
    public static SnippetApplyOptions InsertAfterLine(int line) => new()
    {
        InsertMode = SnippetInsertMode.InsertAfter,
        TargetLine = line
    };

    /// <summary>
    /// Creates options for inserting before a specific line.
    /// </summary>
    public static SnippetApplyOptions InsertBeforeLine(int line) => new()
    {
        InsertMode = SnippetInsertMode.InsertBefore,
        TargetLine = line
    };

    /// <summary>
    /// Creates options for inserting at an anchor location.
    /// </summary>
    public static SnippetApplyOptions AtAnchor(
        SnippetAnchor anchor,
        SnippetInsertMode mode = SnippetInsertMode.InsertAfter) => new()
    {
        InsertMode = mode,
        Anchor = anchor
    };

    /// <summary>
    /// Creates options for appending to the end of the file.
    /// </summary>
    public static SnippetApplyOptions AppendToFile => new()
    {
        InsertMode = SnippetInsertMode.Append,
        AddBlankLineBefore = true
    };

    /// <summary>
    /// Creates options for prepending to the beginning of the file.
    /// </summary>
    public static SnippetApplyOptions PrependToFile => new()
    {
        InsertMode = SnippetInsertMode.Prepend,
        AddBlankLineAfter = true
    };

    /// <summary>
    /// Creates options for inserting after the last import statement.
    /// </summary>
    public static SnippetApplyOptions AfterImports => new()
    {
        InsertMode = SnippetInsertMode.InsertAfter,
        Anchor = SnippetAnchor.AfterLastImport(),
        AddBlankLineBefore = true
    };

    /// <summary>
    /// Creates a copy with modified insert mode and target.
    /// </summary>
    public SnippetApplyOptions WithTarget(SnippetInsertMode mode, int? targetLine = null) =>
        this with
        {
            InsertMode = mode,
            TargetLine = targetLine,
            ReplaceRange = mode == SnippetInsertMode.Replace ? ReplaceRange : null
        };

    /// <summary>
    /// Creates a copy with indentation settings.
    /// </summary>
    public SnippetApplyOptions WithIndentation(
        bool preserveIndentation = true,
        string? indentationOverride = null) =>
        this with
        {
            PreserveIndentation = preserveIndentation,
            IndentationOverride = indentationOverride
        };

    /// <summary>
    /// Creates a copy with spacing settings.
    /// </summary>
    public SnippetApplyOptions WithSpacing(
        bool blankLineBefore = false,
        bool blankLineAfter = false) =>
        this with
        {
            AddBlankLineBefore = blankLineBefore,
            AddBlankLineAfter = blankLineAfter
        };
}
```

### 9. SnippetContext Class

```csharp
// src/SeniorIntern.Core/Models/SnippetContext.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Context information about a file for snippet application.
/// </summary>
public sealed class SnippetContext
{
    private readonly string[] _lines;

    /// <summary>
    /// Creates a new snippet context from file content.
    /// </summary>
    public SnippetContext(string filePath, string content)
    {
        FilePath = filePath ?? throw new ArgumentNullException(nameof(filePath));
        OriginalContent = content ?? string.Empty;

        // Detect line ending style
        LineEnding = DetectLineEnding(OriginalContent);

        // Split into lines (preserve empty trailing lines)
        _lines = OriginalContent.Split(new[] { "\r\n", "\n" }, StringSplitOptions.None);

        // Check for trailing newline
        HasTrailingNewline = OriginalContent.Length > 0 &&
            (OriginalContent.EndsWith('\n') || OriginalContent.EndsWith("\r\n"));

        // Detect indentation style
        DetectedIndentation = DetectIndentation(_lines);
    }

    /// <summary>
    /// Path to the file.
    /// </summary>
    public string FilePath { get; }

    /// <summary>
    /// Original file content.
    /// </summary>
    public string OriginalContent { get; }

    /// <summary>
    /// File content split into lines.
    /// </summary>
    public IReadOnlyList<string> OriginalLines => _lines;

    /// <summary>
    /// Number of lines in the file.
    /// </summary>
    public int LineCount => _lines.Length;

    /// <summary>
    /// Detected indentation style.
    /// </summary>
    public IndentationStyle DetectedIndentation { get; }

    /// <summary>
    /// Line ending style (\n or \r\n).
    /// </summary>
    public string LineEnding { get; }

    /// <summary>
    /// Whether the file ends with a newline.
    /// </summary>
    public bool HasTrailingNewline { get; }

    /// <summary>
    /// Whether the file is empty.
    /// </summary>
    public bool IsEmpty => string.IsNullOrEmpty(OriginalContent);

    // ═══════════════════════════════════════════════════════════════
    // Line Access Methods
    // ═══════════════════════════════════════════════════════════════

    /// <summary>
    /// Gets a line by line number (1-indexed).
    /// </summary>
    /// <param name="lineNumber">1-indexed line number.</param>
    /// <returns>The line content, or null if out of range.</returns>
    public string? GetLine(int lineNumber)
    {
        var index = lineNumber - 1;
        return index >= 0 && index < _lines.Length ? _lines[index] : null;
    }

    /// <summary>
    /// Gets lines within a range.
    /// </summary>
    /// <param name="range">Line range (1-indexed).</param>
    public IEnumerable<string> GetLines(LineRange range)
    {
        if (!range.IsValid) yield break;

        var start = Math.Max(0, range.StartLine - 1);
        var end = Math.Min(_lines.Length, range.EndLine);

        for (int i = start; i < end; i++)
        {
            yield return _lines[i];
        }
    }

    /// <summary>
    /// Gets the indentation of a specific line.
    /// </summary>
    /// <param name="lineNumber">1-indexed line number.</param>
    public string GetLineIndentation(int lineNumber)
    {
        var line = GetLine(lineNumber);
        if (line is null) return string.Empty;

        int whitespaceCount = 0;
        foreach (char c in line)
        {
            if (c == ' ' || c == '\t')
                whitespaceCount++;
            else
                break;
        }

        return line[..whitespaceCount];
    }

    /// <summary>
    /// Gets the indentation level of a specific line.
    /// </summary>
    /// <param name="lineNumber">1-indexed line number.</param>
    public int GetIndentationLevel(int lineNumber)
    {
        var indent = GetLineIndentation(lineNumber);
        return DetectedIndentation.CalculateLevel(indent);
    }

    // ═══════════════════════════════════════════════════════════════
    // Search Methods
    // ═══════════════════════════════════════════════════════════════

    /// <summary>
    /// Finds the first line containing the specified text.
    /// </summary>
    /// <param name="text">Text to search for.</param>
    /// <param name="caseSensitive">Whether search is case-sensitive.</param>
    /// <returns>Line number (1-indexed) or null if not found.</returns>
    public int? FindText(string text, bool caseSensitive = true)
    {
        var comparison = caseSensitive
            ? StringComparison.Ordinal
            : StringComparison.OrdinalIgnoreCase;

        for (int i = 0; i < _lines.Length; i++)
        {
            if (_lines[i].Contains(text, comparison))
                return i + 1;
        }

        return null;
    }

    /// <summary>
    /// Finds all lines containing the specified text.
    /// </summary>
    public IReadOnlyList<int> FindAllText(string text, bool caseSensitive = true)
    {
        var comparison = caseSensitive
            ? StringComparison.Ordinal
            : StringComparison.OrdinalIgnoreCase;

        var results = new List<int>();
        for (int i = 0; i < _lines.Length; i++)
        {
            if (_lines[i].Contains(text, comparison))
                results.Add(i + 1);
        }

        return results;
    }

    /// <summary>
    /// Finds the range of lines containing a code block (e.g., function, class).
    /// </summary>
    public LineRange? FindBlockRange(int startLine, char openBrace = '{', char closeBrace = '}')
    {
        if (startLine < 1 || startLine > LineCount) return null;

        int braceCount = 0;
        bool foundOpen = false;
        int endLine = startLine;

        for (int i = startLine - 1; i < _lines.Length; i++)
        {
            foreach (char c in _lines[i])
            {
                if (c == openBrace)
                {
                    braceCount++;
                    foundOpen = true;
                }
                else if (c == closeBrace)
                {
                    braceCount--;
                }
            }

            if (foundOpen && braceCount == 0)
            {
                endLine = i + 1;
                break;
            }
        }

        return foundOpen ? new LineRange(startLine, endLine) : null;
    }

    // ═══════════════════════════════════════════════════════════════
    // Factory Methods
    // ═══════════════════════════════════════════════════════════════

    /// <summary>
    /// Creates a context from a file path by reading the file.
    /// </summary>
    public static async Task<SnippetContext> FromFileAsync(
        string filePath,
        CancellationToken cancellationToken = default)
    {
        var content = File.Exists(filePath)
            ? await File.ReadAllTextAsync(filePath, cancellationToken)
            : string.Empty;

        return new SnippetContext(filePath, content);
    }

    /// <summary>
    /// Creates a context for a new file (empty content).
    /// </summary>
    public static SnippetContext ForNewFile(string filePath) =>
        new(filePath, string.Empty);

    // ═══════════════════════════════════════════════════════════════
    // Private Helpers
    // ═══════════════════════════════════════════════════════════════

    private static string DetectLineEnding(string content)
    {
        if (string.IsNullOrEmpty(content)) return Environment.NewLine;

        int crlfCount = 0;
        int lfCount = 0;

        for (int i = 0; i < content.Length; i++)
        {
            if (content[i] == '\n')
            {
                if (i > 0 && content[i - 1] == '\r')
                    crlfCount++;
                else
                    lfCount++;
            }
        }

        return crlfCount > lfCount ? "\r\n" : "\n";
    }

    private static IndentationStyle DetectIndentation(string[] lines)
    {
        int tabLines = 0;
        int spaceLines = 0;
        var spaceCounts = new Dictionary<int, int>();

        foreach (var line in lines)
        {
            if (string.IsNullOrWhiteSpace(line)) continue;

            char firstChar = line.FirstOrDefault();
            if (firstChar == '\t')
            {
                tabLines++;
            }
            else if (firstChar == ' ')
            {
                spaceLines++;
                int spaces = line.TakeWhile(c => c == ' ').Count();
                if (spaces > 0)
                {
                    spaceCounts.TryGetValue(spaces, out int count);
                    spaceCounts[spaces] = count + 1;
                }
            }
        }

        int totalIndentedLines = tabLines + spaceLines;
        if (totalIndentedLines == 0)
            return IndentationStyle.Default;

        bool useTabs = tabLines > spaceLines;
        int spacesPerIndent = 4;

        if (!useTabs && spaceCounts.Count > 0)
        {
            // Find most common space count that's likely an indent
            var gcd = spaceCounts.Keys.Where(k => k is >= 2 and <= 8).ToList();
            if (gcd.Count > 0)
            {
                spacesPerIndent = gcd
                    .GroupBy(s => s)
                    .OrderByDescending(g => spaceCounts.GetValueOrDefault(g.Key, 0))
                    .Select(g => g.Key)
                    .FirstOrDefault(4);
            }
        }

        double confidence = totalIndentedLines > 10 ? 0.9 : (totalIndentedLines / 10.0) * 0.9;

        return new IndentationStyle
        {
            UseTabs = useTabs,
            SpacesPerIndent = spacesPerIndent,
            Confidence = confidence,
            LinesAnalyzed = lines.Length
        };
    }
}
```

---

## Unit Tests

### LineRangeTests

```csharp
// tests/SeniorIntern.Core.Tests/Models/LineRangeTests.cs
namespace SeniorIntern.Core.Tests.Models;

public class LineRangeTests
{
    [Theory]
    [InlineData(1, 10, true)]
    [InlineData(5, 5, true)]
    [InlineData(0, 5, false)]
    [InlineData(-1, 5, false)]
    [InlineData(10, 5, false)]
    public void IsValid_ReturnsCorrectResult(int start, int end, bool expected)
    {
        var range = new LineRange(start, end);
        Assert.Equal(expected, range.IsValid);
    }

    [Theory]
    [InlineData(1, 10, 10)]
    [InlineData(5, 5, 1)]
    [InlineData(1, 100, 100)]
    public void LineCount_CalculatesCorrectly(int start, int end, int expected)
    {
        var range = new LineRange(start, end);
        Assert.Equal(expected, range.LineCount);
    }

    [Theory]
    [InlineData(1, 10, 5, true)]
    [InlineData(1, 10, 1, true)]
    [InlineData(1, 10, 10, true)]
    [InlineData(1, 10, 0, false)]
    [InlineData(1, 10, 11, false)]
    public void Contains_Line_ReturnsCorrectResult(int start, int end, int line, bool expected)
    {
        var range = new LineRange(start, end);
        Assert.Equal(expected, range.Contains(line));
    }

    [Fact]
    public void Contains_Range_WorksCorrectly()
    {
        var outer = new LineRange(1, 20);
        var inner = new LineRange(5, 15);
        var partial = new LineRange(15, 25);

        Assert.True(outer.Contains(inner));
        Assert.False(outer.Contains(partial));
        Assert.False(inner.Contains(outer));
    }

    [Theory]
    [InlineData(1, 10, 5, 15, true)]
    [InlineData(1, 10, 10, 20, true)]
    [InlineData(1, 10, 11, 20, false)]
    [InlineData(5, 10, 1, 5, true)]
    public void Overlaps_ReturnsCorrectResult(
        int start1, int end1, int start2, int end2, bool expected)
    {
        var range1 = new LineRange(start1, end1);
        var range2 = new LineRange(start2, end2);
        Assert.Equal(expected, range1.Overlaps(range2));
    }

    [Fact]
    public void Merge_CombinesRanges()
    {
        var range1 = new LineRange(1, 10);
        var range2 = new LineRange(15, 20);

        var merged = range1.Merge(range2);

        Assert.Equal(1, merged.StartLine);
        Assert.Equal(20, merged.EndLine);
    }

    [Fact]
    public void Intersect_FindsOverlap()
    {
        var range1 = new LineRange(1, 15);
        var range2 = new LineRange(10, 20);

        var intersection = range1.Intersect(range2);

        Assert.Equal(10, intersection.StartLine);
        Assert.Equal(15, intersection.EndLine);
    }

    [Fact]
    public void Intersect_ReturnsEmpty_WhenNoOverlap()
    {
        var range1 = new LineRange(1, 10);
        var range2 = new LineRange(15, 20);

        var intersection = range1.Intersect(range2);

        Assert.False(intersection.IsValid);
    }

    [Fact]
    public void SingleLine_CreatesSingleLineRange()
    {
        var range = LineRange.SingleLine(5);

        Assert.Equal(5, range.StartLine);
        Assert.Equal(5, range.EndLine);
        Assert.True(range.IsSingleLine);
        Assert.Equal(1, range.LineCount);
    }

    [Fact]
    public void Shift_MovesRange()
    {
        var range = new LineRange(5, 10);

        var shifted = range.Shift(3);

        Assert.Equal(8, shifted.StartLine);
        Assert.Equal(13, shifted.EndLine);
    }

    [Fact]
    public void Shift_ClampsToMinimum()
    {
        var range = new LineRange(2, 5);

        var shifted = range.Shift(-5);

        Assert.Equal(1, shifted.StartLine);
        Assert.Equal(1, shifted.EndLine);
    }

    [Fact]
    public void EnumerateLines_YieldsAllLines()
    {
        var range = new LineRange(3, 7);

        var lines = range.EnumerateLines().ToList();

        Assert.Equal(new[] { 3, 4, 5, 6, 7 }, lines);
    }

    [Fact]
    public void Equality_WorksCorrectly()
    {
        var range1 = new LineRange(1, 10);
        var range2 = new LineRange(1, 10);
        var range3 = new LineRange(1, 11);

        Assert.Equal(range1, range2);
        Assert.NotEqual(range1, range3);
        Assert.True(range1 == range2);
        Assert.True(range1 != range3);
    }
}
```

### SnippetApplyOptionsTests

```csharp
// tests/SeniorIntern.Core.Tests/Models/SnippetApplyOptionsTests.cs
namespace SeniorIntern.Core.Tests.Models;

public class SnippetApplyOptionsTests
{
    [Fact]
    public void FullReplace_IsValid()
    {
        var options = SnippetApplyOptions.FullReplace;

        Assert.True(options.IsValid);
        Assert.Equal(SnippetInsertMode.ReplaceFile, options.InsertMode);
    }

    [Fact]
    public void ReplaceLines_WithValidRange_IsValid()
    {
        var options = SnippetApplyOptions.ReplaceLines(5, 10);

        Assert.True(options.IsValid);
        Assert.Equal(SnippetInsertMode.Replace, options.InsertMode);
        Assert.Equal(5, options.ReplaceRange?.StartLine);
        Assert.Equal(10, options.ReplaceRange?.EndLine);
    }

    [Fact]
    public void ReplaceLines_WithInvalidRange_IsNotValid()
    {
        var options = new SnippetApplyOptions
        {
            InsertMode = SnippetInsertMode.Replace,
            ReplaceRange = new LineRange(10, 5) // Invalid: end < start
        };

        Assert.False(options.IsValid);
    }

    [Fact]
    public void InsertAfterLine_IsValid()
    {
        var options = SnippetApplyOptions.InsertAfterLine(42);

        Assert.True(options.IsValid);
        Assert.Equal(SnippetInsertMode.InsertAfter, options.InsertMode);
        Assert.Equal(42, options.TargetLine);
    }

    [Fact]
    public void InsertBefore_WithoutTargetLine_IsNotValid()
    {
        var options = new SnippetApplyOptions
        {
            InsertMode = SnippetInsertMode.InsertBefore,
            TargetLine = null
        };

        Assert.False(options.IsValid);
    }

    [Fact]
    public void InsertBefore_WithAnchor_IsValid()
    {
        var options = new SnippetApplyOptions
        {
            InsertMode = SnippetInsertMode.InsertBefore,
            Anchor = SnippetAnchor.Function("MyMethod")
        };

        Assert.True(options.IsValid);
    }

    [Fact]
    public void AppendToFile_IsValid()
    {
        var options = SnippetApplyOptions.AppendToFile;

        Assert.True(options.IsValid);
        Assert.Equal(SnippetInsertMode.Append, options.InsertMode);
        Assert.True(options.AddBlankLineBefore);
    }

    [Fact]
    public void GetValidationErrors_ReturnsErrors_ForInvalidOptions()
    {
        var options = new SnippetApplyOptions
        {
            InsertMode = SnippetInsertMode.Replace,
            ReplaceRange = null
        };

        var errors = options.GetValidationErrors();

        Assert.Single(errors);
        Assert.Contains("ReplaceRange", errors[0]);
    }

    [Fact]
    public void GetValidationErrors_ReturnsEmpty_ForValidOptions()
    {
        var options = SnippetApplyOptions.InsertAfterLine(10);

        var errors = options.GetValidationErrors();

        Assert.Empty(errors);
    }

    [Fact]
    public void DefaultOptions_PreserveIndentation()
    {
        var options = new SnippetApplyOptions();

        Assert.True(options.PreserveIndentation);
        Assert.True(options.TrimTrailingWhitespace);
        Assert.True(options.NormalizeLineEndings);
    }

    [Fact]
    public void WithIndentation_CreatesModifiedCopy()
    {
        var original = SnippetApplyOptions.InsertAfterLine(5);

        var modified = original.WithIndentation(
            preserveIndentation: false,
            indentationOverride: "  ");

        Assert.False(modified.PreserveIndentation);
        Assert.Equal("  ", modified.IndentationOverride);
        Assert.True(original.PreserveIndentation); // Original unchanged
    }

    [Fact]
    public void WithSpacing_CreatesModifiedCopy()
    {
        var original = SnippetApplyOptions.InsertAfterLine(5);

        var modified = original.WithSpacing(
            blankLineBefore: true,
            blankLineAfter: true);

        Assert.True(modified.AddBlankLineBefore);
        Assert.True(modified.AddBlankLineAfter);
        Assert.False(original.AddBlankLineBefore); // Original unchanged
    }
}
```

### SnippetAnchorTests

```csharp
// tests/SeniorIntern.Core.Tests/Models/SnippetAnchorTests.cs
namespace SeniorIntern.Core.Tests.Models;

public class SnippetAnchorTests
{
    [Fact]
    public void ExactText_CreatesValidAnchor()
    {
        var anchor = SnippetAnchor.ExactText("public void DoSomething()");

        Assert.True(anchor.IsValid);
        Assert.Equal(SnippetAnchorType.ExactText, anchor.AnchorType);
        Assert.Equal("public void DoSomething()", anchor.Pattern);
        Assert.Equal(1, anchor.Occurrence);
    }

    [Fact]
    public void Function_CreatesValidAnchor()
    {
        var anchor = SnippetAnchor.Function("ProcessData");

        Assert.True(anchor.IsValid);
        Assert.Equal(SnippetAnchorType.FunctionSignature, anchor.AnchorType);
        Assert.True(anchor.WholeWordOnly);
    }

    [Fact]
    public void Class_CreatesValidAnchor()
    {
        var anchor = SnippetAnchor.Class("MyService");

        Assert.True(anchor.IsValid);
        Assert.Equal(SnippetAnchorType.ClassDeclaration, anchor.AnchorType);
    }

    [Fact]
    public void CommentMarker_IsCaseInsensitive()
    {
        var anchor = SnippetAnchor.CommentMarker("TODO");

        Assert.True(anchor.IsValid);
        Assert.False(anchor.CaseSensitive);
    }

    [Fact]
    public void RegexPattern_ValidatesPattern()
    {
        var validAnchor = SnippetAnchor.RegexPattern(@"public\s+void\s+\w+");
        var invalidAnchor = SnippetAnchor.RegexPattern(@"[invalid(regex");

        Assert.True(validAnchor.IsValid);
        Assert.False(invalidAnchor.IsValid);
    }

    [Fact]
    public void Occurrence_NegativeForLast()
    {
        var anchor = SnippetAnchor.ExactText("using", occurrence: -1);

        Assert.Equal(-1, anchor.Occurrence);
    }

    [Fact]
    public void AfterLastImport_HasCorrectSettings()
    {
        var anchor = SnippetAnchor.AfterLastImport();

        Assert.Equal(SnippetAnchorType.ImportStatement, anchor.AnchorType);
        Assert.Equal(-1, anchor.Occurrence);
        Assert.Equal(1, anchor.Offset);
    }

    [Fact]
    public void EmptyPattern_InvalidForExactText()
    {
        var anchor = new SnippetAnchor
        {
            AnchorType = SnippetAnchorType.ExactText,
            Pattern = string.Empty
        };

        Assert.False(anchor.IsValid);
    }

    [Fact]
    public void EmptyPattern_ValidForImportStatement()
    {
        var anchor = new SnippetAnchor
        {
            AnchorType = SnippetAnchorType.ImportStatement,
            Pattern = string.Empty // Matches any import
        };

        Assert.True(anchor.IsValid);
    }
}
```

### SnippetContextTests

```csharp
// tests/SeniorIntern.Core.Tests/Models/SnippetContextTests.cs
namespace SeniorIntern.Core.Tests.Models;

public class SnippetContextTests
{
    [Fact]
    public void Constructor_SplitsLinesCorrectly()
    {
        var content = "line1\nline2\nline3";
        var context = new SnippetContext("/test.cs", content);

        Assert.Equal(3, context.LineCount);
        Assert.Equal("line1", context.GetLine(1));
        Assert.Equal("line2", context.GetLine(2));
        Assert.Equal("line3", context.GetLine(3));
    }

    [Fact]
    public void Constructor_HandlesWindowsLineEndings()
    {
        var content = "line1\r\nline2\r\nline3";
        var context = new SnippetContext("/test.cs", content);

        Assert.Equal(3, context.LineCount);
        Assert.Equal("\r\n", context.LineEnding);
    }

    [Fact]
    public void Constructor_DetectsTrailingNewline()
    {
        var withNewline = new SnippetContext("/test.cs", "line1\nline2\n");
        var withoutNewline = new SnippetContext("/test.cs", "line1\nline2");

        Assert.True(withNewline.HasTrailingNewline);
        Assert.False(withoutNewline.HasTrailingNewline);
    }

    [Fact]
    public void GetLine_ReturnsNull_ForOutOfRange()
    {
        var context = new SnippetContext("/test.cs", "line1\nline2");

        Assert.Null(context.GetLine(0));
        Assert.Null(context.GetLine(5));
    }

    [Fact]
    public void GetLines_ReturnsRangeOfLines()
    {
        var content = "line1\nline2\nline3\nline4\nline5";
        var context = new SnippetContext("/test.cs", content);

        var lines = context.GetLines(new LineRange(2, 4)).ToList();

        Assert.Equal(3, lines.Count);
        Assert.Equal("line2", lines[0]);
        Assert.Equal("line3", lines[1]);
        Assert.Equal("line4", lines[2]);
    }

    [Fact]
    public void GetLineIndentation_ExtractsWhitespace()
    {
        var content = "no indent\n    four spaces\n\ttab";
        var context = new SnippetContext("/test.cs", content);

        Assert.Equal("", context.GetLineIndentation(1));
        Assert.Equal("    ", context.GetLineIndentation(2));
        Assert.Equal("\t", context.GetLineIndentation(3));
    }

    [Fact]
    public void FindText_FindsFirstOccurrence()
    {
        var content = "hello world\nfoo bar\nhello again";
        var context = new SnippetContext("/test.cs", content);

        var line = context.FindText("hello");

        Assert.Equal(1, line);
    }

    [Fact]
    public void FindAllText_FindsAllOccurrences()
    {
        var content = "hello world\nfoo bar\nhello again";
        var context = new SnippetContext("/test.cs", content);

        var lines = context.FindAllText("hello");

        Assert.Equal(new[] { 1, 3 }, lines);
    }

    [Fact]
    public void FindText_CaseSensitive()
    {
        var content = "Hello\nhello";
        var context = new SnippetContext("/test.cs", content);

        Assert.Equal(1, context.FindText("Hello", caseSensitive: true));
        Assert.Equal(1, context.FindText("hello", caseSensitive: false));
    }

    [Fact]
    public void DetectsIndentation_FourSpaces()
    {
        var content = "class Test {\n    public void Method() {\n        DoSomething();\n    }\n}";
        var context = new SnippetContext("/test.cs", content);

        Assert.False(context.DetectedIndentation.UseTabs);
        Assert.Equal(4, context.DetectedIndentation.SpacesPerIndent);
    }

    [Fact]
    public void DetectsIndentation_Tabs()
    {
        var content = "class Test {\n\tpublic void Method() {\n\t\tDoSomething();\n\t}\n}";
        var context = new SnippetContext("/test.cs", content);

        Assert.True(context.DetectedIndentation.UseTabs);
    }

    [Fact]
    public void IsEmpty_TrueForEmptyContent()
    {
        var context = new SnippetContext("/test.cs", "");

        Assert.True(context.IsEmpty);
    }

    [Fact]
    public void ForNewFile_CreatesEmptyContext()
    {
        var context = SnippetContext.ForNewFile("/new.cs");

        Assert.True(context.IsEmpty);
        Assert.Equal(0, context.LineCount);
    }
}
```

### IndentationStyleTests

```csharp
// tests/SeniorIntern.Core.Tests/Models/IndentationStyleTests.cs
namespace SeniorIntern.Core.Tests.Models;

public class IndentationStyleTests
{
    [Fact]
    public void IndentString_ReturnsTab_WhenUseTabs()
    {
        var style = IndentationStyle.Tabs;

        Assert.Equal("\t", style.IndentString);
    }

    [Fact]
    public void IndentString_ReturnsSpaces_WhenNotUseTabs()
    {
        var style = new IndentationStyle { UseTabs = false, SpacesPerIndent = 2 };

        Assert.Equal("  ", style.IndentString);
    }

    [Fact]
    public void GetIndent_ReturnsCorrectIndentation()
    {
        var twoSpaces = IndentationStyle.TwoSpaces;
        var tabs = IndentationStyle.Tabs;

        Assert.Equal("    ", twoSpaces.GetIndent(2));
        Assert.Equal("\t\t\t", tabs.GetIndent(3));
    }

    [Fact]
    public void GetIndent_ReturnsEmpty_ForZeroLevel()
    {
        var style = IndentationStyle.Default;

        Assert.Equal("", style.GetIndent(0));
        Assert.Equal("", style.GetIndent(-1));
    }

    [Fact]
    public void CalculateLevel_WorksForSpaces()
    {
        var style = new IndentationStyle { UseTabs = false, SpacesPerIndent = 4 };

        Assert.Equal(0, style.CalculateLevel(""));
        Assert.Equal(1, style.CalculateLevel("    "));
        Assert.Equal(2, style.CalculateLevel("        "));
    }

    [Fact]
    public void CalculateLevel_WorksForTabs()
    {
        var style = IndentationStyle.Tabs;

        Assert.Equal(0, style.CalculateLevel(""));
        Assert.Equal(1, style.CalculateLevel("\t"));
        Assert.Equal(3, style.CalculateLevel("\t\t\t"));
    }

    [Fact]
    public void PredefinedStyles_HaveCorrectValues()
    {
        Assert.Equal(4, IndentationStyle.Default.SpacesPerIndent);
        Assert.Equal(2, IndentationStyle.TwoSpaces.SpacesPerIndent);
        Assert.True(IndentationStyle.Tabs.UseTabs);
        Assert.Equal(0.0, IndentationStyle.Unknown.Confidence);
    }
}
```

---

## Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Models/LineRange.cs` | Line range value type |
| `src/SeniorIntern.Core/Models/ColumnRange.cs` | Column range value type (future) |
| `src/SeniorIntern.Core/Models/SnippetInsertMode.cs` | Insert mode enum |
| `src/SeniorIntern.Core/Models/SnippetAnchorType.cs` | Anchor type enum |
| `src/SeniorIntern.Core/Models/SnippetAnchor.cs` | Text-based anchor for locating insertion points |
| `src/SeniorIntern.Core/Models/AnchorMatchResult.cs` | Result of anchor search |
| `src/SeniorIntern.Core/Models/IndentationStyle.cs` | Indentation style record |
| `src/SeniorIntern.Core/Models/SnippetApplyOptions.cs` | Snippet apply options record |
| `src/SeniorIntern.Core/Models/SnippetContext.cs` | File context for snippet application |
| `tests/SeniorIntern.Core.Tests/Models/LineRangeTests.cs` | LineRange tests |
| `tests/SeniorIntern.Core.Tests/Models/SnippetApplyOptionsTests.cs` | Options tests |
| `tests/SeniorIntern.Core.Tests/Models/SnippetAnchorTests.cs` | Anchor tests |
| `tests/SeniorIntern.Core.Tests/Models/SnippetContextTests.cs` | Context tests |
| `tests/SeniorIntern.Core.Tests/Models/IndentationStyleTests.cs` | Indentation tests |

---

## Files to Modify

| File | Changes |
|------|---------|
| None | This is a pure model specification with no modifications to existing files |

---

## Acceptance Criteria

### Functional Requirements

1. **LineRange**
   - [ ] 1-indexed, inclusive range representation
   - [ ] Contains, Overlaps, Merge, Intersect operations work correctly
   - [ ] Factory methods create valid ranges
   - [ ] Shift and Expand operations clamp to valid values
   - [ ] Equality and comparison operators work correctly

2. **SnippetInsertMode**
   - [ ] All six modes defined (Replace, InsertBefore, InsertAfter, Append, Prepend, ReplaceFile)
   - [ ] Clear documentation for each mode's requirements

3. **SnippetApplyOptions**
   - [ ] IsValid correctly validates all insert modes
   - [ ] Factory methods create properly configured options
   - [ ] GetValidationErrors returns meaningful messages
   - [ ] Record immutability with `with` expressions

4. **SnippetAnchor**
   - [ ] All anchor types supported with appropriate validation
   - [ ] Factory methods create anchors with sensible defaults
   - [ ] Negative occurrence values for "from end" matching
   - [ ] Offset for positioning relative to anchor

5. **SnippetContext**
   - [ ] Correctly parses file content into lines
   - [ ] Detects line ending style
   - [ ] Detects indentation style
   - [ ] GetLine, GetLines work with 1-indexed line numbers
   - [ ] FindText and FindAllText work correctly

6. **IndentationStyle**
   - [ ] GetIndent produces correct indentation strings
   - [ ] CalculateLevel reverses GetIndent correctly
   - [ ] Predefined styles have correct values

### Non-Functional Requirements

1. **Immutability**
   - [ ] LineRange and ColumnRange are readonly structs
   - [ ] SnippetApplyOptions and IndentationStyle are records
   - [ ] Collections use IReadOnlyList

2. **Performance**
   - [ ] LineRange operations are O(1)
   - [ ] SnippetContext line access is O(1)
   - [ ] No unnecessary allocations in hot paths

3. **Thread Safety**
   - [ ] All models are immutable and thread-safe
   - [ ] SnippetContext uses immutable array for lines

---

## Design Decisions

### 1. LineRange as Struct

**Decision**: Implement LineRange as a readonly struct with 1-indexed, inclusive bounds.

**Rationale**:
- Small value type (two ints) - efficient to copy
- 1-indexed matches how users think about line numbers
- Inclusive bounds are more intuitive ("lines 1-10" means 10 lines)
- Readonly ensures immutability

**Alternatives Considered**:
- Class with 0-indexed bounds - Mismatch with user expectations
- Range struct from System - Different semantics (end-exclusive)
- Tuple - No named properties or methods

### 2. Text-Based Anchors

**Decision**: Support text-based anchors alongside line numbers.

**Rationale**:
- Files change frequently; line numbers become stale
- Text patterns are more robust to insertions/deletions elsewhere
- Function/class names provide semantic meaning
- Supports fuzzy matching for user-friendly experience

**Alternatives Considered**:
- Line numbers only - Too fragile
- AST-based positioning - Complex, language-specific
- Diff-based positioning - Requires original content

### 3. Separation of Context and Options

**Decision**: Separate SnippetContext (file state) from SnippetApplyOptions (operation config).

**Rationale**:
- Context can be reused for multiple operations
- Options can be serialized/stored independently
- Clear separation of concerns
- Context creation can be async (file I/O)

### 4. Indentation Detection

**Decision**: Auto-detect indentation from file content with confidence score.

**Rationale**:
- Most files have consistent indentation
- Detection allows matching file style automatically
- Confidence score indicates reliability
- Override available when detection is wrong

### 5. Factory Methods

**Decision**: Provide static factory methods for common configurations.

**Rationale**:
- Common cases are easy to use (SnippetApplyOptions.AppendToFile)
- Documentation in method names
- Reduced risk of misconfiguration
- Record `with` expressions for customization

---

## Dependencies

### Internal Dependencies
- None (this is a foundational model spec)

### External Dependencies
- System.Text.RegularExpressions (for anchor pattern validation)

### Consumers (future specs)
- v0.4.5d (Snippet Apply Service) - Uses all models defined here
- v0.4.5e (Snippet Options UI) - Binds to SnippetApplyOptions
- v0.4.1 (Code Block Extraction) - May use LineRange for ReplacementRange

---

## Future Considerations

1. **Character-Level Operations**
   - ColumnRange reserved for future inline editing
   - Could support partial line replacement

2. **Multi-Language Anchor Patterns**
   - Language-specific patterns for functions, classes
   - TreeSitter integration for AST-based anchoring

3. **Anchor Caching**
   - Cache resolved anchor positions
   - Invalidate on file change

4. **Fuzzy Matching**
   - Levenshtein distance for approximate text matches
   - Confidence-based ranking of alternatives
