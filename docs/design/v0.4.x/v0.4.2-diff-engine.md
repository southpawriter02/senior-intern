# Design Specification: The Senior Intern v0.4.2 "Diff Engine"

**Status**: _IMPLEMENTED_

## Executive Summary

This document provides a comprehensive design specification for v0.4.2, which implements a diff computation engine and side-by-side diff visualization UI. This enables users to see exactly what changes will be made before applying code changes proposed by the LLM.

### Parent Version Reference
- **Parent**: v0.4.0 "Code Generation & Diffing"
- **Focus**: Compute and visualize side-by-side diffs, inline highlighting

### Dependencies
- v0.4.1 (Code Block Extraction) - Required for CodeBlock model
- DiffPlex NuGet package for diff computation

---

## Sub-Part Breakdown

| Sub-Part | Name | Focus |
|----------|------|-------|
| v0.4.2a | Diff Models | DiffResult, DiffHunk, DiffLine, DiffStats models |
| v0.4.2b | Diff Service | IDiffService interface and DiffPlex-based implementation |
| v0.4.2c | Inline Diff | Character-level diff computation for modified lines |
| v0.4.2d | Diff ViewModels | DiffViewerViewModel, DiffHunkViewModel, DiffLineViewModel |
| v0.4.2e | Side-by-Side View | DiffViewerPanel with synchronized scrolling |
| v0.4.2f | Diff Line Rendering | DiffLineControl with inline change highlighting |
| v0.4.2g | Diff Navigation | Hunk navigation, keyboard shortcuts, minimap |
| v0.4.2h | Theming & Polish | Diff colors, gutter styling, animations |

---

## v0.4.2a: Diff Models

### Objective
Define the data models for representing computed diffs between original and proposed content.

### DiffResult Model

```csharp
// src/SeniorIntern.Core/Models/DiffResult.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Represents the complete result of a diff computation between two texts.
/// </summary>
public sealed class DiffResult
{
    /// <summary>
    /// Unique identifier for this diff result.
    /// </summary>
    public Guid Id { get; init; } = Guid.NewGuid();

    /// <summary>
    /// Path to the original file (if applicable).
    /// </summary>
    public string OriginalFilePath { get; init; } = string.Empty;

    /// <summary>
    /// The original content before changes.
    /// </summary>
    public string OriginalContent { get; init; } = string.Empty;

    /// <summary>
    /// The proposed content after changes.
    /// </summary>
    public string ProposedContent { get; init; } = string.Empty;

    /// <summary>
    /// Individual diff hunks (groups of changes).
    /// </summary>
    public IReadOnlyList<DiffHunk> Hunks { get; init; } = Array.Empty<DiffHunk>();

    /// <summary>
    /// Summary statistics for the diff.
    /// </summary>
    public DiffStats Stats { get; init; } = new();

    /// <summary>
    /// Whether this represents a new file creation.
    /// </summary>
    public bool IsNewFile { get; init; }

    /// <summary>
    /// Whether this represents a file deletion.
    /// </summary>
    public bool IsDeleteFile { get; init; }

    /// <summary>
    /// Whether this represents a binary file (not diffable).
    /// </summary>
    public bool IsBinaryFile { get; init; }

    /// <summary>
    /// The code block that generated this diff (if applicable).
    /// </summary>
    public Guid? SourceBlockId { get; init; }

    /// <summary>
    /// When this diff was computed.
    /// </summary>
    public DateTime ComputedAt { get; init; } = DateTime.UtcNow;

    /// <summary>
    /// Whether there are any actual changes.
    /// </summary>
    public bool HasChanges => Hunks.Count > 0 &&
        (Stats.AddedLines > 0 || Stats.RemovedLines > 0 || Stats.ModifiedLines > 0);

    /// <summary>
    /// Total number of hunks.
    /// </summary>
    public int HunkCount => Hunks.Count;
}
```

### DiffHunk Model

```csharp
// src/SeniorIntern.Core/Models/DiffHunk.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Represents a contiguous group of changes in a diff.
/// </summary>
public sealed class DiffHunk
{
    /// <summary>
    /// Unique identifier for this hunk.
    /// </summary>
    public Guid Id { get; init; } = Guid.NewGuid();

    /// <summary>
    /// Starting line number in the original content (1-based).
    /// </summary>
    public int OriginalStartLine { get; init; }

    /// <summary>
    /// Number of lines from the original content in this hunk.
    /// </summary>
    public int OriginalLineCount { get; init; }

    /// <summary>
    /// Starting line number in the proposed content (1-based).
    /// </summary>
    public int ProposedStartLine { get; init; }

    /// <summary>
    /// Number of lines from the proposed content in this hunk.
    /// </summary>
    public int ProposedLineCount { get; init; }

    /// <summary>
    /// All lines in this hunk with their change types.
    /// </summary>
    public IReadOnlyList<DiffLine> Lines { get; init; } = Array.Empty<DiffLine>();

    /// <summary>
    /// Optional header/context for this hunk (e.g., function name).
    /// </summary>
    public string? ContextHeader { get; init; }

    /// <summary>
    /// Index of this hunk in the parent DiffResult (0-based).
    /// </summary>
    public int Index { get; init; }

    /// <summary>
    /// Standard hunk header format (@@ -start,count +start,count @@).
    /// </summary>
    public string Header =>
        $"@@ -{OriginalStartLine},{OriginalLineCount} +{ProposedStartLine},{ProposedLineCount} @@";

    /// <summary>
    /// Lines that were added in this hunk.
    /// </summary>
    public IEnumerable<DiffLine> AddedLines =>
        Lines.Where(l => l.Type == DiffLineType.Added);

    /// <summary>
    /// Lines that were removed in this hunk.
    /// </summary>
    public IEnumerable<DiffLine> RemovedLines =>
        Lines.Where(l => l.Type == DiffLineType.Removed);

    /// <summary>
    /// Whether this hunk contains only additions.
    /// </summary>
    public bool IsInsertOnly => Lines.All(l =>
        l.Type is DiffLineType.Added or DiffLineType.Unchanged);

    /// <summary>
    /// Whether this hunk contains only deletions.
    /// </summary>
    public bool IsDeleteOnly => Lines.All(l =>
        l.Type is DiffLineType.Removed or DiffLineType.Unchanged);
}
```

### DiffLine Model

```csharp
// src/SeniorIntern.Core/Models/DiffLine.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Represents a single line in a diff with its change type.
/// </summary>
public sealed class DiffLine
{
    /// <summary>
    /// Line number in the original content (null if line was added).
    /// </summary>
    public int? OriginalLineNumber { get; init; }

    /// <summary>
    /// Line number in the proposed content (null if line was removed).
    /// </summary>
    public int? ProposedLineNumber { get; init; }

    /// <summary>
    /// The text content of this line.
    /// </summary>
    public string Content { get; init; } = string.Empty;

    /// <summary>
    /// The type of change for this line.
    /// </summary>
    public DiffLineType Type { get; init; }

    /// <summary>
    /// Inline character-level changes (for modified lines).
    /// </summary>
    public IReadOnlyList<InlineChange>? InlineChanges { get; init; }

    /// <summary>
    /// Whether this line has inline character-level changes.
    /// </summary>
    public bool HasInlineChanges => InlineChanges?.Count > 0;

    /// <summary>
    /// The paired line for modified lines (original pairs with proposed).
    /// </summary>
    public DiffLine? PairedLine { get; set; }

    /// <summary>
    /// Display prefix for unified diff format.
    /// </summary>
    public char Prefix => Type switch
    {
        DiffLineType.Added => '+',
        DiffLineType.Removed => '-',
        DiffLineType.Modified => '~',
        _ => ' '
    };

    /// <summary>
    /// The appropriate line number based on diff side.
    /// </summary>
    public int? GetLineNumber(DiffSide side) => side switch
    {
        DiffSide.Original => OriginalLineNumber,
        DiffSide.Proposed => ProposedLineNumber,
        _ => null
    };
}

/// <summary>
/// Type of change for a diff line.
/// </summary>
public enum DiffLineType
{
    /// <summary>
    /// Line is unchanged between original and proposed.
    /// </summary>
    Unchanged,

    /// <summary>
    /// Line was added in proposed content.
    /// </summary>
    Added,

    /// <summary>
    /// Line was removed from original content.
    /// </summary>
    Removed,

    /// <summary>
    /// Line was modified (exists in both but different).
    /// </summary>
    Modified
}

/// <summary>
/// Which side of a side-by-side diff.
/// </summary>
public enum DiffSide
{
    Original,
    Proposed
}
```

### InlineChange Model

```csharp
// src/SeniorIntern.Core/Models/InlineChange.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Represents a character-level change within a line.
/// </summary>
public sealed class InlineChange
{
    /// <summary>
    /// Starting column position (0-based).
    /// </summary>
    public int StartColumn { get; init; }

    /// <summary>
    /// Length of the changed text segment.
    /// </summary>
    public int Length { get; init; }

    /// <summary>
    /// The changed text content.
    /// </summary>
    public string Text { get; init; } = string.Empty;

    /// <summary>
    /// Type of inline change.
    /// </summary>
    public InlineChangeType Type { get; init; }

    /// <summary>
    /// End column position (exclusive).
    /// </summary>
    public int EndColumn => StartColumn + Length;
}

/// <summary>
/// Type of character-level change.
/// </summary>
public enum InlineChangeType
{
    /// <summary>
    /// Text was added.
    /// </summary>
    Added,

    /// <summary>
    /// Text was removed.
    /// </summary>
    Removed,

    /// <summary>
    /// Text is unchanged.
    /// </summary>
    Unchanged
}
```

### DiffStats Model

```csharp
// src/SeniorIntern.Core/Models/DiffStats.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Summary statistics for a diff.
/// </summary>
public sealed record DiffStats
{
    /// <summary>
    /// Total number of lines in the diff.
    /// </summary>
    public int TotalLines { get; init; }

    /// <summary>
    /// Number of lines added.
    /// </summary>
    public int AddedLines { get; init; }

    /// <summary>
    /// Number of lines removed.
    /// </summary>
    public int RemovedLines { get; init; }

    /// <summary>
    /// Number of lines modified.
    /// </summary>
    public int ModifiedLines { get; init; }

    /// <summary>
    /// Number of unchanged context lines.
    /// </summary>
    public int UnchangedLines { get; init; }

    /// <summary>
    /// Net line change (added - removed).
    /// </summary>
    public int NetChange => AddedLines - RemovedLines;

    /// <summary>
    /// Percentage of file changed.
    /// </summary>
    public double ChangePercentage => TotalLines > 0
        ? (double)(AddedLines + RemovedLines + ModifiedLines) / TotalLines * 100
        : 0;

    /// <summary>
    /// Human-readable summary.
    /// </summary>
    public string Summary => $"+{AddedLines} -{RemovedLines}" +
        (ModifiedLines > 0 ? $" ~{ModifiedLines}" : "");

    /// <summary>
    /// Empty stats instance.
    /// </summary>
    public static DiffStats Empty => new();
}
```

### Files to Create (v0.4.2a)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Models/DiffResult.cs` | Main diff result model |
| `src/SeniorIntern.Core/Models/DiffHunk.cs` | Hunk grouping model |
| `src/SeniorIntern.Core/Models/DiffLine.cs` | Line diff model with enums |
| `src/SeniorIntern.Core/Models/InlineChange.cs` | Character-level change model |
| `src/SeniorIntern.Core/Models/DiffStats.cs` | Statistics record |

### Testing Strategy (v0.4.2a)

```csharp
public class DiffModelsTests
{
    [Fact]
    public void DiffResult_HasChanges_WithAddedLines_ReturnsTrue()
    {
        var result = new DiffResult
        {
            Stats = new DiffStats { AddedLines = 5 },
            Hunks = new[] { new DiffHunk() }
        };
        Assert.True(result.HasChanges);
    }

    [Fact]
    public void DiffHunk_Header_FormatsCorrectly()
    {
        var hunk = new DiffHunk
        {
            OriginalStartLine = 10,
            OriginalLineCount = 5,
            ProposedStartLine = 10,
            ProposedLineCount = 7
        };
        Assert.Equal("@@ -10,5 +10,7 @@", hunk.Header);
    }

    [Fact]
    public void DiffStats_NetChange_CalculatesCorrectly()
    {
        var stats = new DiffStats { AddedLines = 10, RemovedLines = 3 };
        Assert.Equal(7, stats.NetChange);
    }

    [Fact]
    public void DiffLine_Prefix_ReturnsCorrectSymbol()
    {
        Assert.Equal('+', new DiffLine { Type = DiffLineType.Added }.Prefix);
        Assert.Equal('-', new DiffLine { Type = DiffLineType.Removed }.Prefix);
        Assert.Equal(' ', new DiffLine { Type = DiffLineType.Unchanged }.Prefix);
    }
}
```

### Acceptance Criteria (v0.4.2a)

- [ ] DiffResult contains all required properties
- [ ] DiffHunk generates correct header format
- [ ] DiffLine supports both original and proposed line numbers
- [ ] InlineChange tracks character-level positions
- [ ] DiffStats calculates net change and percentages
- [ ] All models are immutable where appropriate

---

## v0.4.2b: Diff Service

### Objective
Implement the core diff computation service using DiffPlex library.

### IDiffService Interface

```csharp
// src/SeniorIntern.Core/Interfaces/IDiffService.cs
namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Service for computing diffs between text content.
/// </summary>
public interface IDiffService
{
    /// <summary>
    /// Compute diff between original and proposed content.
    /// </summary>
    DiffResult ComputeDiff(string originalContent, string proposedContent);

    /// <summary>
    /// Compute diff with file path context.
    /// </summary>
    DiffResult ComputeDiff(string originalContent, string proposedContent, string filePath);

    /// <summary>
    /// Compute diff for a new file (all lines added).
    /// </summary>
    DiffResult ComputeNewFileDiff(string proposedContent, string filePath);

    /// <summary>
    /// Compute diff for file deletion (all lines removed).
    /// </summary>
    DiffResult ComputeDeleteFileDiff(string originalContent, string filePath);

    /// <summary>
    /// Compute diff for a code block against its target file.
    /// </summary>
    Task<DiffResult> ComputeDiffForBlockAsync(
        CodeBlock block,
        string workspacePath,
        CancellationToken ct = default);

    /// <summary>
    /// Compute diff for multiple code blocks targeting the same file.
    /// </summary>
    Task<DiffResult> ComputeMergedDiffAsync(
        IReadOnlyList<CodeBlock> blocks,
        string workspacePath,
        CancellationToken ct = default);
}
```

### DiffOptions

```csharp
// src/SeniorIntern.Core/Models/DiffOptions.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Options for diff computation.
/// </summary>
public sealed class DiffOptions
{
    /// <summary>
    /// Number of context lines to include around changes.
    /// </summary>
    public int ContextLines { get; init; } = 3;

    /// <summary>
    /// Whether to compute inline character-level diffs.
    /// </summary>
    public bool ComputeInlineDiffs { get; init; } = true;

    /// <summary>
    /// Whether to ignore whitespace differences.
    /// </summary>
    public bool IgnoreWhitespace { get; init; } = false;

    /// <summary>
    /// Whether to ignore case differences.
    /// </summary>
    public bool IgnoreCase { get; init; } = false;

    /// <summary>
    /// Whether to trim trailing whitespace before comparison.
    /// </summary>
    public bool TrimTrailingWhitespace { get; init; } = true;

    /// <summary>
    /// Minimum number of unchanged lines to separate hunks.
    /// </summary>
    public int HunkSeparationThreshold { get; init; } = 6;

    /// <summary>
    /// Maximum line length for inline diff (longer lines skip inline).
    /// </summary>
    public int MaxInlineDiffLineLength { get; init; } = 500;

    /// <summary>
    /// Default options instance.
    /// </summary>
    public static DiffOptions Default => new();
}
```

### DiffService Implementation

```csharp
// src/SeniorIntern.Services/DiffService.cs
namespace SeniorIntern.Services;

using DiffPlex;
using DiffPlex.DiffBuilder;
using DiffPlex.DiffBuilder.Model;
using DiffPlex.Chunkers;

/// <summary>
/// Computes diffs between text content using DiffPlex.
/// </summary>
public sealed class DiffService : IDiffService
{
    private readonly IFileSystemService _fileSystemService;
    private readonly ILogger<DiffService>? _logger;
    private readonly DiffOptions _defaultOptions;

    private readonly Differ _differ;
    private readonly InlineDiffBuilder _inlineDiffBuilder;
    private readonly SideBySideDiffBuilder _sideBySideDiffBuilder;

    public DiffService(
        IFileSystemService fileSystemService,
        ILogger<DiffService>? logger = null,
        DiffOptions? defaultOptions = null)
    {
        _fileSystemService = fileSystemService;
        _logger = logger;
        _defaultOptions = defaultOptions ?? DiffOptions.Default;

        _differ = new Differ();
        _inlineDiffBuilder = new InlineDiffBuilder(_differ);
        _sideBySideDiffBuilder = new SideBySideDiffBuilder(_differ);
    }

    public DiffResult ComputeDiff(string originalContent, string proposedContent)
    {
        return ComputeDiff(originalContent, proposedContent, string.Empty);
    }

    public DiffResult ComputeDiff(
        string originalContent,
        string proposedContent,
        string filePath)
    {
        return ComputeDiffInternal(
            originalContent,
            proposedContent,
            filePath,
            _defaultOptions);
    }

    private DiffResult ComputeDiffInternal(
        string originalContent,
        string proposedContent,
        string filePath,
        DiffOptions options)
    {
        // Normalize line endings
        originalContent = NormalizeLineEndings(originalContent);
        proposedContent = NormalizeLineEndings(proposedContent);

        // Apply preprocessing
        if (options.TrimTrailingWhitespace)
        {
            originalContent = TrimTrailingWhitespace(originalContent);
            proposedContent = TrimTrailingWhitespace(proposedContent);
        }

        // Quick check for identical content
        if (originalContent == proposedContent)
        {
            return CreateEmptyDiff(originalContent, filePath);
        }

        // Compute the diff using DiffPlex
        var diffModel = _sideBySideDiffBuilder.BuildDiffModel(
            originalContent,
            proposedContent);

        // Convert to our model with hunks
        var hunks = BuildHunks(diffModel, options);

        // Compute inline diffs if enabled
        if (options.ComputeInlineDiffs)
        {
            ComputeInlineDiffs(hunks, options);
        }

        // Calculate statistics
        var stats = ComputeStats(hunks);

        return new DiffResult
        {
            OriginalFilePath = filePath,
            OriginalContent = originalContent,
            ProposedContent = proposedContent,
            Hunks = hunks,
            Stats = stats,
            IsNewFile = string.IsNullOrEmpty(originalContent),
            IsDeleteFile = string.IsNullOrEmpty(proposedContent)
        };
    }

    private List<DiffHunk> BuildHunks(
        SideBySideDiffModel diffModel,
        DiffOptions options)
    {
        var hunks = new List<DiffHunk>();
        var currentHunkLines = new List<DiffLine>();

        int hunkOrigStart = 0, hunkPropStart = 0;
        int unchangedRun = 0;
        bool inHunk = false;
        int hunkIndex = 0;

        var originalLines = diffModel.OldText.Lines;
        var proposedLines = diffModel.NewText.Lines;
        int maxLines = Math.Max(originalLines.Count, proposedLines.Count);

        for (int i = 0; i < maxLines; i++)
        {
            var origLine = i < originalLines.Count ? originalLines[i] : null;
            var propLine = i < proposedLines.Count ? proposedLines[i] : null;

            var diffLine = CreateDiffLine(origLine, propLine, i);

            if (diffLine.Type != DiffLineType.Unchanged)
            {
                // Start or continue a hunk
                if (!inHunk)
                {
                    inHunk = true;
                    hunkOrigStart = Math.Max(1, (diffLine.OriginalLineNumber ?? 1) - options.ContextLines);
                    hunkPropStart = Math.Max(1, (diffLine.ProposedLineNumber ?? 1) - options.ContextLines);

                    // Add leading context lines
                    AddLeadingContext(currentHunkLines, originalLines, proposedLines,
                        i, options.ContextLines);
                }

                currentHunkLines.Add(diffLine);
                unchangedRun = 0;
            }
            else if (inHunk)
            {
                currentHunkLines.Add(diffLine);
                unchangedRun++;

                // Check if we should close the hunk
                if (unchangedRun >= options.HunkSeparationThreshold)
                {
                    // Trim trailing context and close hunk
                    TrimTrailingContext(currentHunkLines, options.ContextLines);

                    hunks.Add(CreateHunk(
                        hunkOrigStart, hunkPropStart,
                        currentHunkLines, hunkIndex++));

                    currentHunkLines = new List<DiffLine>();
                    inHunk = false;
                    unchangedRun = 0;
                }
            }
        }

        // Close any remaining hunk
        if (currentHunkLines.Count > 0 &&
            currentHunkLines.Any(l => l.Type != DiffLineType.Unchanged))
        {
            TrimTrailingContext(currentHunkLines, options.ContextLines);
            hunks.Add(CreateHunk(
                hunkOrigStart, hunkPropStart,
                currentHunkLines, hunkIndex));
        }

        return hunks;
    }

    private DiffLine CreateDiffLine(
        DiffPiece? origPiece,
        DiffPiece? propPiece,
        int index)
    {
        var type = DetermineLineType(origPiece, propPiece);

        return new DiffLine
        {
            OriginalLineNumber = origPiece?.Position,
            ProposedLineNumber = propPiece?.Position,
            Content = type switch
            {
                DiffLineType.Removed => origPiece?.Text ?? string.Empty,
                DiffLineType.Added => propPiece?.Text ?? string.Empty,
                _ => origPiece?.Text ?? propPiece?.Text ?? string.Empty
            },
            Type = type
        };
    }

    private static DiffLineType DetermineLineType(
        DiffPiece? origPiece,
        DiffPiece? propPiece)
    {
        if (origPiece == null && propPiece != null)
            return DiffLineType.Added;

        if (origPiece != null && propPiece == null)
            return DiffLineType.Removed;

        if (origPiece?.Type == ChangeType.Deleted)
            return DiffLineType.Removed;

        if (propPiece?.Type == ChangeType.Inserted)
            return DiffLineType.Added;

        if (origPiece?.Type == ChangeType.Modified ||
            propPiece?.Type == ChangeType.Modified)
            return DiffLineType.Modified;

        return DiffLineType.Unchanged;
    }

    private void AddLeadingContext(
        List<DiffLine> hunkLines,
        IList<DiffPiece> originalLines,
        IList<DiffPiece> proposedLines,
        int currentIndex,
        int contextLines)
    {
        int startIndex = Math.Max(0, currentIndex - contextLines);
        for (int i = startIndex; i < currentIndex; i++)
        {
            var origLine = i < originalLines.Count ? originalLines[i] : null;
            var propLine = i < proposedLines.Count ? proposedLines[i] : null;

            if (origLine?.Type == ChangeType.Unchanged)
            {
                hunkLines.Add(new DiffLine
                {
                    OriginalLineNumber = origLine.Position,
                    ProposedLineNumber = propLine?.Position,
                    Content = origLine.Text ?? string.Empty,
                    Type = DiffLineType.Unchanged
                });
            }
        }
    }

    private static void TrimTrailingContext(
        List<DiffLine> hunkLines,
        int maxContext)
    {
        int trailingUnchanged = 0;
        for (int i = hunkLines.Count - 1; i >= 0; i--)
        {
            if (hunkLines[i].Type == DiffLineType.Unchanged)
                trailingUnchanged++;
            else
                break;
        }

        int toRemove = Math.Max(0, trailingUnchanged - maxContext);
        if (toRemove > 0)
        {
            hunkLines.RemoveRange(hunkLines.Count - toRemove, toRemove);
        }
    }

    private static DiffHunk CreateHunk(
        int origStart,
        int propStart,
        List<DiffLine> lines,
        int index)
    {
        int origCount = lines.Count(l =>
            l.Type is DiffLineType.Unchanged or DiffLineType.Removed or DiffLineType.Modified);
        int propCount = lines.Count(l =>
            l.Type is DiffLineType.Unchanged or DiffLineType.Added or DiffLineType.Modified);

        return new DiffHunk
        {
            OriginalStartLine = origStart,
            OriginalLineCount = origCount,
            ProposedStartLine = propStart,
            ProposedLineCount = propCount,
            Lines = lines.ToList(),
            Index = index
        };
    }

    private DiffResult CreateEmptyDiff(string content, string filePath)
    {
        return new DiffResult
        {
            OriginalFilePath = filePath,
            OriginalContent = content,
            ProposedContent = content,
            Hunks = Array.Empty<DiffHunk>(),
            Stats = DiffStats.Empty
        };
    }

    public DiffResult ComputeNewFileDiff(string proposedContent, string filePath)
    {
        var lines = proposedContent.Split('\n');
        var diffLines = lines.Select((line, i) => new DiffLine
        {
            ProposedLineNumber = i + 1,
            Content = line,
            Type = DiffLineType.Added
        }).ToList();

        return new DiffResult
        {
            OriginalFilePath = filePath,
            OriginalContent = string.Empty,
            ProposedContent = proposedContent,
            Hunks = new[]
            {
                new DiffHunk
                {
                    OriginalStartLine = 0,
                    OriginalLineCount = 0,
                    ProposedStartLine = 1,
                    ProposedLineCount = lines.Length,
                    Lines = diffLines,
                    Index = 0
                }
            },
            Stats = new DiffStats
            {
                TotalLines = lines.Length,
                AddedLines = lines.Length
            },
            IsNewFile = true
        };
    }

    public DiffResult ComputeDeleteFileDiff(string originalContent, string filePath)
    {
        var lines = originalContent.Split('\n');
        var diffLines = lines.Select((line, i) => new DiffLine
        {
            OriginalLineNumber = i + 1,
            Content = line,
            Type = DiffLineType.Removed
        }).ToList();

        return new DiffResult
        {
            OriginalFilePath = filePath,
            OriginalContent = originalContent,
            ProposedContent = string.Empty,
            Hunks = new[]
            {
                new DiffHunk
                {
                    OriginalStartLine = 1,
                    OriginalLineCount = lines.Length,
                    ProposedStartLine = 0,
                    ProposedLineCount = 0,
                    Lines = diffLines,
                    Index = 0
                }
            },
            Stats = new DiffStats
            {
                TotalLines = lines.Length,
                RemovedLines = lines.Length
            },
            IsDeleteFile = true
        };
    }

    public async Task<DiffResult> ComputeDiffForBlockAsync(
        CodeBlock block,
        string workspacePath,
        CancellationToken ct = default)
    {
        if (string.IsNullOrEmpty(block.TargetFilePath))
            throw new ArgumentException("Code block must have a target file path");

        var fullPath = Path.Combine(workspacePath, block.TargetFilePath);

        if (!await _fileSystemService.FileExistsAsync(fullPath, ct))
        {
            _logger?.LogDebug("Target file does not exist, creating new file diff: {Path}",
                block.TargetFilePath);
            return ComputeNewFileDiff(block.Content, block.TargetFilePath);
        }

        var originalContent = await _fileSystemService.ReadFileAsync(fullPath, ct);

        if (block.BlockType == CodeBlockType.CompleteFile)
        {
            return ComputeDiff(originalContent, block.Content, block.TargetFilePath);
        }

        if (block.ReplacementRange != null && block.ReplacementRange.Value.IsValid)
        {
            // Snippet with specific replacement range
            var proposedContent = ReplaceLines(
                originalContent,
                block.ReplacementRange.Value.StartLine,
                block.ReplacementRange.Value.EndLine,
                block.Content);
            return ComputeDiff(originalContent, proposedContent, block.TargetFilePath);
        }

        // Snippet without range - replace entire file for now
        // TODO: Implement smart snippet merging in future version
        _logger?.LogDebug("Snippet without replacement range, using full replacement");
        return ComputeDiff(originalContent, block.Content, block.TargetFilePath);
    }

    public async Task<DiffResult> ComputeMergedDiffAsync(
        IReadOnlyList<CodeBlock> blocks,
        string workspacePath,
        CancellationToken ct = default)
    {
        if (blocks.Count == 0)
            throw new ArgumentException("At least one code block required");

        if (blocks.Count == 1)
            return await ComputeDiffForBlockAsync(blocks[0], workspacePath, ct);

        // Get the target file path (all blocks should target same file)
        var targetPath = blocks[0].TargetFilePath;
        if (blocks.Any(b => b.TargetFilePath != targetPath))
            throw new ArgumentException("All blocks must target the same file");

        // TODO: Implement proper multi-block merging
        // For now, just use the last complete file block or merge snippets
        var completeFile = blocks.LastOrDefault(b => b.BlockType == CodeBlockType.CompleteFile);
        if (completeFile != null)
        {
            return await ComputeDiffForBlockAsync(completeFile, workspacePath, ct);
        }

        // Fall back to first block
        return await ComputeDiffForBlockAsync(blocks[0], workspacePath, ct);
    }

    private static string ReplaceLines(
        string content,
        int startLine,
        int endLine,
        string replacement)
    {
        var lines = content.Split('\n').ToList();
        var replacementLines = replacement.Split('\n');

        // Validate range
        if (startLine < 1 || startLine > lines.Count)
            throw new ArgumentOutOfRangeException(nameof(startLine));
        if (endLine < startLine || endLine > lines.Count)
            throw new ArgumentOutOfRangeException(nameof(endLine));

        // Remove old lines
        lines.RemoveRange(startLine - 1, endLine - startLine + 1);

        // Insert new lines
        lines.InsertRange(startLine - 1, replacementLines);

        return string.Join('\n', lines);
    }

    private static DiffStats ComputeStats(IReadOnlyList<DiffHunk> hunks)
    {
        int added = 0, removed = 0, modified = 0, unchanged = 0;

        foreach (var hunk in hunks)
        {
            foreach (var line in hunk.Lines)
            {
                switch (line.Type)
                {
                    case DiffLineType.Added: added++; break;
                    case DiffLineType.Removed: removed++; break;
                    case DiffLineType.Modified: modified++; break;
                    case DiffLineType.Unchanged: unchanged++; break;
                }
            }
        }

        return new DiffStats
        {
            TotalLines = added + removed + modified + unchanged,
            AddedLines = added,
            RemovedLines = removed,
            ModifiedLines = modified,
            UnchangedLines = unchanged
        };
    }

    private static string NormalizeLineEndings(string text)
    {
        return text.Replace("\r\n", "\n").Replace("\r", "\n");
    }

    private static string TrimTrailingWhitespace(string text)
    {
        var lines = text.Split('\n');
        return string.Join('\n', lines.Select(l => l.TrimEnd()));
    }

    // Inline diff computation delegated to v0.4.2c
    private void ComputeInlineDiffs(List<DiffHunk> hunks, DiffOptions options)
    {
        // Implementation in v0.4.2c
    }
}
```

### Files to Create (v0.4.2b)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/IDiffService.cs` | Diff service interface |
| `src/SeniorIntern.Core/Models/DiffOptions.cs` | Configuration options |
| `src/SeniorIntern.Services/DiffService.cs` | Main implementation |

### Files to Modify (v0.4.2b)

| File | Changes |
|------|---------|
| `Directory.Packages.props` | Add DiffPlex 1.7.2 package |
| `src/SeniorIntern.Services/SeniorIntern.Services.csproj` | Reference DiffPlex |
| `src/SeniorIntern.Desktop/Extensions/ServiceCollectionExtensions.cs` | Register DiffService |

### Testing Strategy (v0.4.2b)

```csharp
public class DiffServiceTests
{
    [Fact]
    public void ComputeDiff_IdenticalContent_ReturnsNoChanges()
    {
        var service = CreateService();
        var result = service.ComputeDiff("hello\nworld", "hello\nworld");

        Assert.False(result.HasChanges);
        Assert.Empty(result.Hunks);
    }

    [Fact]
    public void ComputeDiff_AddedLines_ReturnsCorrectStats()
    {
        var service = CreateService();
        var result = service.ComputeDiff(
            "line1\nline2",
            "line1\nline2\nline3\nline4");

        Assert.True(result.HasChanges);
        Assert.Equal(2, result.Stats.AddedLines);
    }

    [Fact]
    public void ComputeDiff_RemovedLines_ReturnsCorrectStats()
    {
        var service = CreateService();
        var result = service.ComputeDiff(
            "line1\nline2\nline3",
            "line1");

        Assert.Equal(2, result.Stats.RemovedLines);
    }

    [Fact]
    public void ComputeNewFileDiff_AllLinesAdded()
    {
        var service = CreateService();
        var result = service.ComputeNewFileDiff("line1\nline2\nline3", "test.txt");

        Assert.True(result.IsNewFile);
        Assert.Equal(3, result.Stats.AddedLines);
        Assert.Single(result.Hunks);
    }

    [Fact]
    public void ComputeDiff_CreatesHunksWithContext()
    {
        var service = CreateService();
        var original = string.Join("\n", Enumerable.Range(1, 20).Select(i => $"line{i}"));
        var proposed = original.Replace("line10", "modified10");

        var result = service.ComputeDiff(original, proposed);

        Assert.Single(result.Hunks);
        // Should include context lines around the change
        Assert.True(result.Hunks[0].Lines.Count >= 4);
    }
}
```

### Acceptance Criteria (v0.4.2b)

- [ ] DiffService computes correct diffs for additions
- [ ] DiffService computes correct diffs for removals
- [ ] DiffService computes correct diffs for modifications
- [ ] Hunks include correct context lines
- [ ] Multiple hunks created for distant changes
- [ ] New file diffs mark all lines as added
- [ ] Delete file diffs mark all lines as removed
- [ ] Statistics are accurate

---

## v0.4.2c: Inline Diff

### Objective
Implement character-level diff computation for modified lines to highlight exactly what changed within a line.

### IInlineDiffService Interface

```csharp
// src/SeniorIntern.Core/Interfaces/IInlineDiffService.cs
namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Service for computing character-level inline diffs.
/// </summary>
public interface IInlineDiffService
{
    /// <summary>
    /// Compute inline changes between two lines.
    /// </summary>
    IReadOnlyList<InlineChange> ComputeInlineChanges(
        string originalLine,
        string proposedLine);

    /// <summary>
    /// Split a line into segments with change information.
    /// </summary>
    IReadOnlyList<InlineSegment> GetInlineSegments(
        string content,
        IReadOnlyList<InlineChange> changes,
        DiffSide side);
}

/// <summary>
/// A segment of text with inline change information for rendering.
/// </summary>
public sealed class InlineSegment
{
    public string Text { get; init; } = string.Empty;
    public bool IsChanged { get; init; }
    public InlineChangeType Type { get; init; }
}
```

### InlineDiffService Implementation

```csharp
// src/SeniorIntern.Services/InlineDiffService.cs
namespace SeniorIntern.Services;

using DiffPlex;
using DiffPlex.DiffBuilder;

public sealed class InlineDiffService : IInlineDiffService
{
    private readonly Differ _differ;

    public InlineDiffService()
    {
        _differ = new Differ();
    }

    public IReadOnlyList<InlineChange> ComputeInlineChanges(
        string originalLine,
        string proposedLine)
    {
        if (originalLine == proposedLine)
            return Array.Empty<InlineChange>();

        var changes = new List<InlineChange>();

        // Use character-level diff
        var diff = _differ.CreateCharacterDiffs(originalLine, proposedLine, false);

        int origPos = 0;
        int propPos = 0;

        foreach (var block in diff.DiffBlocks)
        {
            // Add unchanged text before this block
            if (block.InsertStartB > propPos)
            {
                var unchangedLength = block.InsertStartB - propPos;
                changes.Add(new InlineChange
                {
                    StartColumn = propPos,
                    Length = unchangedLength,
                    Text = proposedLine.Substring(propPos, unchangedLength),
                    Type = InlineChangeType.Unchanged
                });
            }

            // Add removed characters (from original)
            if (block.DeleteCountA > 0)
            {
                changes.Add(new InlineChange
                {
                    StartColumn = block.DeleteStartA,
                    Length = block.DeleteCountA,
                    Text = originalLine.Substring(block.DeleteStartA, block.DeleteCountA),
                    Type = InlineChangeType.Removed
                });
            }

            // Add inserted characters (in proposed)
            if (block.InsertCountB > 0)
            {
                changes.Add(new InlineChange
                {
                    StartColumn = block.InsertStartB,
                    Length = block.InsertCountB,
                    Text = proposedLine.Substring(block.InsertStartB, block.InsertCountB),
                    Type = InlineChangeType.Added
                });
            }

            origPos = block.DeleteStartA + block.DeleteCountA;
            propPos = block.InsertStartB + block.InsertCountB;
        }

        // Add any remaining unchanged text
        if (propPos < proposedLine.Length)
        {
            changes.Add(new InlineChange
            {
                StartColumn = propPos,
                Length = proposedLine.Length - propPos,
                Text = proposedLine.Substring(propPos),
                Type = InlineChangeType.Unchanged
            });
        }

        return changes;
    }

    public IReadOnlyList<InlineSegment> GetInlineSegments(
        string content,
        IReadOnlyList<InlineChange> changes,
        DiffSide side)
    {
        if (changes.Count == 0)
        {
            return new[]
            {
                new InlineSegment { Text = content, IsChanged = false }
            };
        }

        var segments = new List<InlineSegment>();

        foreach (var change in changes)
        {
            // Filter based on side
            bool includeSegment = change.Type switch
            {
                InlineChangeType.Unchanged => true,
                InlineChangeType.Added => side == DiffSide.Proposed,
                InlineChangeType.Removed => side == DiffSide.Original,
                _ => true
            };

            if (includeSegment)
            {
                segments.Add(new InlineSegment
                {
                    Text = change.Text,
                    IsChanged = change.Type != InlineChangeType.Unchanged,
                    Type = change.Type
                });
            }
        }

        return segments;
    }
}
```

### Update DiffService for Inline Diffs

```csharp
// Add to DiffService.cs

private readonly IInlineDiffService _inlineDiffService;

// In constructor:
_inlineDiffService = new InlineDiffService();

private void ComputeInlineDiffs(List<DiffHunk> hunks, DiffOptions options)
{
    foreach (var hunk in hunks)
    {
        // Find paired modified lines (removed followed by added)
        var lines = hunk.Lines.ToList();

        for (int i = 0; i < lines.Count - 1; i++)
        {
            var current = lines[i];
            var next = lines[i + 1];

            // Look for remove/add pairs that likely represent modifications
            if (current.Type == DiffLineType.Removed &&
                next.Type == DiffLineType.Added)
            {
                // Check if lines are similar enough for inline diff
                if (ShouldComputeInlineDiff(current.Content, next.Content, options))
                {
                    var inlineChanges = _inlineDiffService.ComputeInlineChanges(
                        current.Content,
                        next.Content);

                    // Update lines with inline changes
                    lines[i] = current with { InlineChanges = inlineChanges };
                    lines[i + 1] = next with { InlineChanges = inlineChanges };

                    // Link the paired lines
                    lines[i].PairedLine = lines[i + 1];
                    lines[i + 1].PairedLine = lines[i];
                }
            }
        }
    }
}

private static bool ShouldComputeInlineDiff(
    string original,
    string proposed,
    DiffOptions options)
{
    // Skip very long lines
    if (original.Length > options.MaxInlineDiffLineLength ||
        proposed.Length > options.MaxInlineDiffLineLength)
        return false;

    // Skip if lines are too different (use Levenshtein ratio)
    var similarity = ComputeSimilarity(original, proposed);
    return similarity >= 0.3; // At least 30% similar
}

private static double ComputeSimilarity(string a, string b)
{
    if (string.IsNullOrEmpty(a) && string.IsNullOrEmpty(b))
        return 1.0;
    if (string.IsNullOrEmpty(a) || string.IsNullOrEmpty(b))
        return 0.0;

    int maxLen = Math.Max(a.Length, b.Length);
    int distance = LevenshteinDistance(a, b);
    return 1.0 - ((double)distance / maxLen);
}

private static int LevenshteinDistance(string a, string b)
{
    var costs = new int[b.Length + 1];

    for (int i = 0; i <= b.Length; i++)
        costs[i] = i;

    for (int i = 1; i <= a.Length; i++)
    {
        int previousCost = costs[0];
        costs[0] = i;

        for (int j = 1; j <= b.Length; j++)
        {
            int currentCost = costs[j];
            costs[j] = Math.Min(
                Math.Min(costs[j - 1] + 1, costs[j] + 1),
                previousCost + (a[i - 1] == b[j - 1] ? 0 : 1));
            previousCost = currentCost;
        }
    }

    return costs[b.Length];
}
```

### Files to Create (v0.4.2c)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/IInlineDiffService.cs` | Inline diff interface |
| `src/SeniorIntern.Services/InlineDiffService.cs` | Inline diff implementation |

### Files to Modify (v0.4.2c)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Services/DiffService.cs` | Add inline diff computation |

### Testing Strategy (v0.4.2c)

```csharp
public class InlineDiffServiceTests
{
    [Fact]
    public void ComputeInlineChanges_SingleWordChange_IdentifiesChange()
    {
        var service = new InlineDiffService();
        var changes = service.ComputeInlineChanges(
            "Hello world",
            "Hello universe");

        Assert.Contains(changes, c => c.Type == InlineChangeType.Removed && c.Text == "world");
        Assert.Contains(changes, c => c.Type == InlineChangeType.Added && c.Text == "universe");
    }

    [Fact]
    public void ComputeInlineChanges_IdenticalLines_ReturnsEmpty()
    {
        var service = new InlineDiffService();
        var changes = service.ComputeInlineChanges("same text", "same text");

        Assert.Empty(changes.Where(c => c.Type != InlineChangeType.Unchanged));
    }

    [Fact]
    public void GetInlineSegments_FiltersForSide()
    {
        var service = new InlineDiffService();
        var changes = service.ComputeInlineChanges("old", "new");

        var originalSegments = service.GetInlineSegments("old", changes, DiffSide.Original);
        var proposedSegments = service.GetInlineSegments("new", changes, DiffSide.Proposed);

        // Original side should not show added text
        Assert.DoesNotContain(originalSegments, s => s.Type == InlineChangeType.Added);
        // Proposed side should not show removed text
        Assert.DoesNotContain(proposedSegments, s => s.Type == InlineChangeType.Removed);
    }
}
```

### Acceptance Criteria (v0.4.2c)

- [ ] Character-level changes detected within lines
- [ ] Added characters marked correctly
- [ ] Removed characters marked correctly
- [ ] Unchanged text preserved
- [ ] Segments filtered correctly for each side
- [ ] Similar lines paired for inline diff
- [ ] Very long lines skip inline diff

---

## v0.4.2d: Diff ViewModels

### Objective
Create ViewModels for the diff viewer UI with proper data binding and commands.

### DiffViewerViewModel

```csharp
// src/SeniorIntern.Desktop/ViewModels/DiffViewerViewModel.cs
namespace SeniorIntern.Desktop.ViewModels;

public partial class DiffViewerViewModel : ViewModelBase
{
    private readonly IDiffService _diffService;
    private readonly IInlineDiffService _inlineDiffService;

    [ObservableProperty]
    private DiffResult? _diffResult;

    [ObservableProperty]
    private CodeBlock? _sourceBlock;

    [ObservableProperty]
    private string _filePath = string.Empty;

    [ObservableProperty]
    private string _fileName = string.Empty;

    [ObservableProperty]
    private string? _language;

    [ObservableProperty]
    private bool _isNewFile;

    [ObservableProperty]
    private bool _isLoading;

    [ObservableProperty]
    private string? _errorMessage;

    // View options
    [ObservableProperty]
    private bool _showInlineChanges = true;

    [ObservableProperty]
    private bool _wordWrap;

    [ObservableProperty]
    private bool _synchronizedScroll = true;

    [ObservableProperty]
    private bool _showLineNumbers = true;

    [ObservableProperty]
    private int _contextLines = 3;

    // Navigation
    [ObservableProperty]
    private int _currentHunkIndex;

    [ObservableProperty]
    private int _totalHunks;

    [ObservableProperty]
    private ObservableCollection<DiffHunkViewModel> _hunks = new();

    // Scroll positions (for synchronized scrolling)
    [ObservableProperty]
    private double _originalScrollOffset;

    [ObservableProperty]
    private double _proposedScrollOffset;

    // Computed properties
    public string StatsDisplay => DiffResult?.Stats.Summary ?? string.Empty;

    public bool HasChanges => DiffResult?.HasChanges ?? false;

    public bool CanNavigatePrevious => CurrentHunkIndex > 0;

    public bool CanNavigateNext => CurrentHunkIndex < TotalHunks - 1;

    public DiffViewerViewModel(
        IDiffService diffService,
        IInlineDiffService inlineDiffService)
    {
        _diffService = diffService;
        _inlineDiffService = inlineDiffService;
    }

    public async Task LoadDiffAsync(CodeBlock block, string workspacePath)
    {
        try
        {
            IsLoading = true;
            ErrorMessage = null;
            SourceBlock = block;
            FilePath = block.TargetFilePath ?? string.Empty;
            FileName = Path.GetFileName(FilePath);
            Language = block.DisplayLanguage;

            var result = await _diffService.ComputeDiffForBlockAsync(
                block, workspacePath);

            SetDiffResult(result);
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Failed to compute diff: {ex.Message}";
        }
        finally
        {
            IsLoading = false;
        }
    }

    public void LoadDiff(DiffResult result)
    {
        SetDiffResult(result);
    }

    private void SetDiffResult(DiffResult result)
    {
        DiffResult = result;
        IsNewFile = result.IsNewFile;
        TotalHunks = result.Hunks.Count;
        CurrentHunkIndex = 0;

        Hunks.Clear();
        foreach (var hunk in result.Hunks)
        {
            Hunks.Add(new DiffHunkViewModel(hunk, _inlineDiffService, ShowInlineChanges));
        }

        OnPropertyChanged(nameof(StatsDisplay));
        OnPropertyChanged(nameof(HasChanges));
    }

    partial void OnShowInlineChangesChanged(bool value)
    {
        foreach (var hunk in Hunks)
        {
            hunk.ShowInlineChanges = value;
        }
    }

    partial void OnCurrentHunkIndexChanged(int value)
    {
        OnPropertyChanged(nameof(CanNavigatePrevious));
        OnPropertyChanged(nameof(CanNavigateNext));
    }

    [RelayCommand]
    private void NextHunk()
    {
        if (CanNavigateNext)
        {
            CurrentHunkIndex++;
            ScrollToCurrentHunk();
        }
    }

    [RelayCommand]
    private void PreviousHunk()
    {
        if (CanNavigatePrevious)
        {
            CurrentHunkIndex--;
            ScrollToCurrentHunk();
        }
    }

    [RelayCommand]
    private void GoToHunk(int index)
    {
        if (index >= 0 && index < TotalHunks)
        {
            CurrentHunkIndex = index;
            ScrollToCurrentHunk();
        }
    }

    private void ScrollToCurrentHunk()
    {
        // Raise event for view to handle scrolling
        HunkNavigationRequested?.Invoke(this, CurrentHunkIndex);
    }

    [RelayCommand]
    private void ToggleInlineChanges()
    {
        ShowInlineChanges = !ShowInlineChanges;
    }

    [RelayCommand]
    private void ToggleWordWrap()
    {
        WordWrap = !WordWrap;
    }

    [RelayCommand]
    private void ToggleSynchronizedScroll()
    {
        SynchronizedScroll = !SynchronizedScroll;
    }

    [RelayCommand]
    private async Task CopyProposedAsync()
    {
        if (DiffResult?.ProposedContent != null)
        {
            // Copy to clipboard
            await ClipboardService.SetTextAsync(DiffResult.ProposedContent);
        }
    }

    // Events
    public event EventHandler<int>? HunkNavigationRequested;
    public event EventHandler? ApplyRequested;
    public event EventHandler? RejectRequested;

    [RelayCommand]
    private void RequestApply()
    {
        ApplyRequested?.Invoke(this, EventArgs.Empty);
    }

    [RelayCommand]
    private void RequestReject()
    {
        RejectRequested?.Invoke(this, EventArgs.Empty);
    }
}
```

### DiffHunkViewModel

```csharp
// src/SeniorIntern.Desktop/ViewModels/DiffHunkViewModel.cs
namespace SeniorIntern.Desktop.ViewModels;

public partial class DiffHunkViewModel : ViewModelBase
{
    private readonly IInlineDiffService _inlineDiffService;

    [ObservableProperty]
    private Guid _id;

    [ObservableProperty]
    private int _index;

    [ObservableProperty]
    private string _header = string.Empty;

    [ObservableProperty]
    private string? _contextHeader;

    [ObservableProperty]
    private ObservableCollection<DiffLineViewModel> _originalLines = new();

    [ObservableProperty]
    private ObservableCollection<DiffLineViewModel> _proposedLines = new();

    [ObservableProperty]
    private bool _showInlineChanges = true;

    [ObservableProperty]
    private bool _isExpanded = true;

    public int AddedCount { get; }
    public int RemovedCount { get; }

    public DiffHunkViewModel(
        DiffHunk hunk,
        IInlineDiffService inlineDiffService,
        bool showInlineChanges)
    {
        _inlineDiffService = inlineDiffService;

        Id = hunk.Id;
        Index = hunk.Index;
        Header = hunk.Header;
        ContextHeader = hunk.ContextHeader;
        ShowInlineChanges = showInlineChanges;

        AddedCount = hunk.Lines.Count(l => l.Type == DiffLineType.Added);
        RemovedCount = hunk.Lines.Count(l => l.Type == DiffLineType.Removed);

        BuildSideBySideLines(hunk);
    }

    private void BuildSideBySideLines(DiffHunk hunk)
    {
        // Build aligned side-by-side lines
        var originalList = new List<DiffLineViewModel>();
        var proposedList = new List<DiffLineViewModel>();

        foreach (var line in hunk.Lines)
        {
            switch (line.Type)
            {
                case DiffLineType.Unchanged:
                    // Add to both sides
                    originalList.Add(CreateLineViewModel(line, DiffSide.Original));
                    proposedList.Add(CreateLineViewModel(line, DiffSide.Proposed));
                    break;

                case DiffLineType.Removed:
                    // Add to original, placeholder to proposed
                    originalList.Add(CreateLineViewModel(line, DiffSide.Original));
                    proposedList.Add(CreatePlaceholderLine());
                    break;

                case DiffLineType.Added:
                    // Placeholder to original, add to proposed
                    originalList.Add(CreatePlaceholderLine());
                    proposedList.Add(CreateLineViewModel(line, DiffSide.Proposed));
                    break;

                case DiffLineType.Modified:
                    // Add to appropriate side
                    if (line.OriginalLineNumber.HasValue)
                    {
                        originalList.Add(CreateLineViewModel(line, DiffSide.Original));
                    }
                    if (line.ProposedLineNumber.HasValue)
                    {
                        proposedList.Add(CreateLineViewModel(line, DiffSide.Proposed));
                    }
                    break;
            }
        }

        // Align the lists by adding placeholders where needed
        AlignLists(originalList, proposedList);

        OriginalLines = new ObservableCollection<DiffLineViewModel>(originalList);
        ProposedLines = new ObservableCollection<DiffLineViewModel>(proposedList);
    }

    private DiffLineViewModel CreateLineViewModel(DiffLine line, DiffSide side)
    {
        var segments = line.HasInlineChanges && ShowInlineChanges
            ? _inlineDiffService.GetInlineSegments(line.Content, line.InlineChanges!, side)
            : null;

        return new DiffLineViewModel
        {
            LineNumber = line.GetLineNumber(side),
            Content = line.Content,
            Type = line.Type,
            Side = side,
            InlineSegments = segments,
            IsPlaceholder = false
        };
    }

    private static DiffLineViewModel CreatePlaceholderLine()
    {
        return new DiffLineViewModel
        {
            IsPlaceholder = true,
            Type = DiffLineType.Unchanged
        };
    }

    private static void AlignLists(
        List<DiffLineViewModel> original,
        List<DiffLineViewModel> proposed)
    {
        // Ensure both lists have the same length
        while (original.Count < proposed.Count)
        {
            original.Add(CreatePlaceholderLine());
        }
        while (proposed.Count < original.Count)
        {
            proposed.Add(CreatePlaceholderLine());
        }
    }

    partial void OnShowInlineChangesChanged(bool value)
    {
        // Rebuild segments when toggling inline changes
        // (Would need to store original DiffHunk reference)
    }
}
```

### DiffLineViewModel

```csharp
// src/SeniorIntern.Desktop/ViewModels/DiffLineViewModel.cs
namespace SeniorIntern.Desktop.ViewModels;

public partial class DiffLineViewModel : ViewModelBase
{
    [ObservableProperty]
    private int? _lineNumber;

    [ObservableProperty]
    private string _content = string.Empty;

    [ObservableProperty]
    private DiffLineType _type;

    [ObservableProperty]
    private DiffSide _side;

    [ObservableProperty]
    private IReadOnlyList<InlineSegment>? _inlineSegments;

    [ObservableProperty]
    private bool _isPlaceholder;

    [ObservableProperty]
    private bool _isHighlighted;

    public bool HasInlineSegments => InlineSegments?.Count > 0;

    public string LineNumberDisplay => LineNumber?.ToString() ?? string.Empty;

    public bool IsAdded => Type == DiffLineType.Added;
    public bool IsRemoved => Type == DiffLineType.Removed;
    public bool IsModified => Type == DiffLineType.Modified;
    public bool IsUnchanged => Type == DiffLineType.Unchanged;
}
```

### Files to Create (v0.4.2d)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/ViewModels/DiffViewerViewModel.cs` | Main diff viewer VM |
| `src/SeniorIntern.Desktop/ViewModels/DiffHunkViewModel.cs` | Hunk VM with side-by-side |
| `src/SeniorIntern.Desktop/ViewModels/DiffLineViewModel.cs` | Individual line VM |

### Acceptance Criteria (v0.4.2d)

- [ ] DiffViewerViewModel loads diffs from code blocks
- [ ] Hunk navigation works correctly
- [ ] Side-by-side alignment correct
- [ ] Placeholder lines inserted for alignment
- [ ] Inline segments created when enabled
- [ ] View options toggle correctly

---

## v0.4.2e: Side-by-Side View

### Objective
Create the main DiffViewerPanel with synchronized side-by-side scrolling.

### DiffViewerPanel.axaml

```xml
<!-- src/SeniorIntern.Desktop/Views/DiffViewerPanel.axaml -->
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:vm="using:SeniorIntern.Desktop.ViewModels"
             xmlns:controls="using:SeniorIntern.Desktop.Controls"
             x:Class="SeniorIntern.Desktop.Views.DiffViewerPanel"
             x:DataType="vm:DiffViewerViewModel">

    <Grid RowDefinitions="Auto, *, Auto">
        <!-- Header -->
        <Border Grid.Row="0" Classes="diff-header">
            <Grid ColumnDefinitions="Auto, *, Auto, Auto">
                <!-- File info -->
                <StackPanel Orientation="Horizontal" Spacing="8" Margin="12,8">
                    <PathIcon Data="{StaticResource FileCodeIcon}"
                              Width="16" Height="16" />
                    <TextBlock Text="{Binding FileName}"
                               FontWeight="SemiBold"
                               VerticalAlignment="Center" />
                    <Border Classes="language-badge"
                            IsVisible="{Binding Language,
                                Converter={x:Static StringConverters.IsNotNullOrEmpty}}">
                        <TextBlock Text="{Binding Language}" FontSize="11" />
                    </Border>
                    <Border Classes="new-file-badge" IsVisible="{Binding IsNewFile}">
                        <TextBlock Text="NEW FILE" FontSize="10" FontWeight="Bold" />
                    </Border>
                </StackPanel>

                <!-- Stats -->
                <StackPanel Grid.Column="1"
                            Orientation="Horizontal"
                            HorizontalAlignment="Center"
                            Spacing="16"
                            Margin="0,8">
                    <StackPanel Orientation="Horizontal" Spacing="4">
                        <TextBlock Text="+"
                                   Foreground="{DynamicResource DiffAddedForeground}"
                                   FontWeight="Bold" />
                        <TextBlock Text="{Binding DiffResult.Stats.AddedLines}"
                                   Foreground="{DynamicResource DiffAddedForeground}" />
                    </StackPanel>
                    <StackPanel Orientation="Horizontal" Spacing="4">
                        <TextBlock Text="-"
                                   Foreground="{DynamicResource DiffRemovedForeground}"
                                   FontWeight="Bold" />
                        <TextBlock Text="{Binding DiffResult.Stats.RemovedLines}"
                                   Foreground="{DynamicResource DiffRemovedForeground}" />
                    </StackPanel>
                    <TextBlock Text="{Binding TotalHunks, StringFormat='{}{0} hunks'}"
                               Foreground="{DynamicResource TextMuted}"
                               FontSize="12" />
                </StackPanel>

                <!-- Navigation -->
                <StackPanel Grid.Column="2"
                            Orientation="Horizontal"
                            Spacing="4"
                            Margin="8">
                    <TextBlock VerticalAlignment="Center"
                               Margin="0,0,8,0">
                        <TextBlock.Text>
                            <MultiBinding StringFormat="{}{0}/{1}">
                                <Binding Path="CurrentHunkIndex"
                                         Converter="{StaticResource IncrementConverter}" />
                                <Binding Path="TotalHunks" />
                            </MultiBinding>
                        </TextBlock.Text>
                    </TextBlock>
                    <Button Classes="icon-button"
                            Command="{Binding PreviousHunkCommand}"
                            IsEnabled="{Binding CanNavigatePrevious}"
                            ToolTip.Tip="Previous change (Ctrl+↑)">
                        <PathIcon Data="{StaticResource ChevronUpIcon}" Width="14" Height="14" />
                    </Button>
                    <Button Classes="icon-button"
                            Command="{Binding NextHunkCommand}"
                            IsEnabled="{Binding CanNavigateNext}"
                            ToolTip.Tip="Next change (Ctrl+↓)">
                        <PathIcon Data="{StaticResource ChevronDownIcon}" Width="14" Height="14" />
                    </Button>
                </StackPanel>

                <!-- Toolbar -->
                <StackPanel Grid.Column="3"
                            Orientation="Horizontal"
                            Spacing="4"
                            Margin="8">
                    <ToggleButton Classes="icon-button"
                                  IsChecked="{Binding ShowInlineChanges}"
                                  ToolTip.Tip="Show character-level changes">
                        <PathIcon Data="{StaticResource HighlightIcon}" Width="14" Height="14" />
                    </ToggleButton>
                    <ToggleButton Classes="icon-button"
                                  IsChecked="{Binding WordWrap}"
                                  ToolTip.Tip="Word wrap">
                        <PathIcon Data="{StaticResource WrapTextIcon}" Width="14" Height="14" />
                    </ToggleButton>
                    <ToggleButton Classes="icon-button"
                                  IsChecked="{Binding SynchronizedScroll}"
                                  ToolTip.Tip="Synchronized scrolling">
                        <PathIcon Data="{StaticResource LinkIcon}" Width="14" Height="14" />
                    </ToggleButton>
                </StackPanel>
            </Grid>
        </Border>

        <!-- Side-by-Side Content -->
        <Grid Grid.Row="1" ColumnDefinitions="*, 1, *">
            <!-- Original Panel -->
            <Border Grid.Column="0" Classes="diff-panel original">
                <Grid RowDefinitions="Auto, *">
                    <Border Classes="panel-header" Padding="12,6">
                        <TextBlock Text="Original"
                                   FontWeight="SemiBold"
                                   Foreground="{DynamicResource TextMuted}" />
                    </Border>
                    <ScrollViewer Grid.Row="1"
                                  x:Name="OriginalScrollViewer"
                                  HorizontalScrollBarVisibility="Auto"
                                  VerticalScrollBarVisibility="Auto">
                        <ItemsControl ItemsSource="{Binding Hunks}">
                            <ItemsControl.ItemTemplate>
                                <DataTemplate DataType="{x:Type vm:DiffHunkViewModel}">
                                    <controls:DiffHunkControl
                                        Side="Original"
                                        ShowInlineChanges="{Binding ShowInlineChanges}" />
                                </DataTemplate>
                            </ItemsControl.ItemTemplate>
                        </ItemsControl>
                    </ScrollViewer>
                </Grid>
            </Border>

            <!-- Splitter -->
            <GridSplitter Grid.Column="1"
                          Width="1"
                          Background="{DynamicResource DiffSplitterBackground}"
                          ResizeDirection="Columns" />

            <!-- Proposed Panel -->
            <Border Grid.Column="2" Classes="diff-panel proposed">
                <Grid RowDefinitions="Auto, *">
                    <Border Classes="panel-header" Padding="12,6">
                        <TextBlock Text="Proposed"
                                   FontWeight="SemiBold"
                                   Foreground="{DynamicResource TextMuted}" />
                    </Border>
                    <ScrollViewer Grid.Row="1"
                                  x:Name="ProposedScrollViewer"
                                  HorizontalScrollBarVisibility="Auto"
                                  VerticalScrollBarVisibility="Auto">
                        <ItemsControl ItemsSource="{Binding Hunks}">
                            <ItemsControl.ItemTemplate>
                                <DataTemplate DataType="{x:Type vm:DiffHunkViewModel}">
                                    <controls:DiffHunkControl
                                        Side="Proposed"
                                        ShowInlineChanges="{Binding ShowInlineChanges}" />
                                </DataTemplate>
                            </ItemsControl.ItemTemplate>
                        </ItemsControl>
                    </ScrollViewer>
                </Grid>
            </Border>
        </Grid>

        <!-- Footer Actions -->
        <Border Grid.Row="2" Classes="diff-footer" Padding="12,8">
            <Grid ColumnDefinitions="Auto, *, Auto">
                <Button Content="Open in Editor"
                        Classes="secondary"
                        Command="{Binding OpenInEditorCommand}" />

                <StackPanel Grid.Column="2"
                            Orientation="Horizontal"
                            Spacing="8">
                    <Button Content="Reject"
                            Classes="secondary"
                            Command="{Binding RequestRejectCommand}" />
                    <Button Content="Apply Changes"
                            Classes="primary accent"
                            Command="{Binding RequestApplyCommand}" />
                </StackPanel>
            </Grid>
        </Border>

        <!-- Loading Overlay -->
        <Border Grid.RowSpan="3"
                Background="#80000000"
                IsVisible="{Binding IsLoading}">
            <StackPanel HorizontalAlignment="Center"
                        VerticalAlignment="Center"
                        Spacing="12">
                <ProgressBar IsIndeterminate="True" Width="120" />
                <TextBlock Text="Computing diff..."
                           Foreground="White" />
            </StackPanel>
        </Border>

        <!-- Error Overlay -->
        <Border Grid.RowSpan="3"
                Background="{DynamicResource ErrorBackground}"
                IsVisible="{Binding ErrorMessage,
                    Converter={x:Static StringConverters.IsNotNullOrEmpty}}"
                Padding="24">
            <StackPanel HorizontalAlignment="Center"
                        VerticalAlignment="Center"
                        Spacing="12">
                <PathIcon Data="{StaticResource ErrorIcon}"
                          Width="32" Height="32"
                          Foreground="{DynamicResource ErrorForeground}" />
                <TextBlock Text="{Binding ErrorMessage}"
                           TextWrapping="Wrap"
                           MaxWidth="400"
                           TextAlignment="Center" />
            </StackPanel>
        </Border>
    </Grid>
</UserControl>
```

### DiffViewerPanel Code-Behind

```csharp
// src/SeniorIntern.Desktop/Views/DiffViewerPanel.axaml.cs
namespace SeniorIntern.Desktop.Views;

public partial class DiffViewerPanel : UserControl
{
    private bool _isSyncingScroll;

    public DiffViewerPanel()
    {
        InitializeComponent();

        // Wire up synchronized scrolling
        OriginalScrollViewer.ScrollChanged += OnOriginalScrollChanged;
        ProposedScrollViewer.ScrollChanged += OnProposedScrollChanged;
    }

    protected override void OnDataContextChanged(EventArgs e)
    {
        base.OnDataContextChanged(e);

        if (DataContext is DiffViewerViewModel vm)
        {
            vm.HunkNavigationRequested += OnHunkNavigationRequested;
        }
    }

    private void OnOriginalScrollChanged(object? sender, ScrollChangedEventArgs e)
    {
        if (_isSyncingScroll) return;

        if (DataContext is DiffViewerViewModel { SynchronizedScroll: true })
        {
            _isSyncingScroll = true;
            ProposedScrollViewer.Offset = OriginalScrollViewer.Offset;
            _isSyncingScroll = false;
        }
    }

    private void OnProposedScrollChanged(object? sender, ScrollChangedEventArgs e)
    {
        if (_isSyncingScroll) return;

        if (DataContext is DiffViewerViewModel { SynchronizedScroll: true })
        {
            _isSyncingScroll = true;
            OriginalScrollViewer.Offset = ProposedScrollViewer.Offset;
            _isSyncingScroll = false;
        }
    }

    private void OnHunkNavigationRequested(object? sender, int hunkIndex)
    {
        // Scroll to the specified hunk
        // This would require measuring hunk positions
        // For now, we can use a simple approach
        ScrollToHunk(hunkIndex);
    }

    private void ScrollToHunk(int hunkIndex)
    {
        // Find the hunk control and scroll to it
        var itemsControl = OriginalScrollViewer.Content as ItemsControl;
        if (itemsControl?.ItemContainerGenerator.ContainerFromIndex(hunkIndex)
            is Control hunkControl)
        {
            hunkControl.BringIntoView();
        }
    }
}
```

### Files to Create (v0.4.2e)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/Views/DiffViewerPanel.axaml` | Main diff view |
| `src/SeniorIntern.Desktop/Views/DiffViewerPanel.axaml.cs` | Code-behind |

### Acceptance Criteria (v0.4.2e)

- [ ] Side-by-side panels display correctly
- [ ] Synchronized scrolling works
- [ ] Navigation buttons work
- [ ] Stats display correctly
- [ ] Loading overlay shows during computation
- [ ] Error overlay shows on failure
- [ ] Splitter allows resizing

---

## v0.4.2f: Diff Line Rendering

### Objective
Create controls for rendering diff hunks and lines with inline change highlighting.

### DiffHunkControl.axaml

```xml
<!-- src/SeniorIntern.Desktop/Controls/DiffHunkControl.axaml -->
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:vm="using:SeniorIntern.Desktop.ViewModels"
             xmlns:controls="using:SeniorIntern.Desktop.Controls"
             x:Class="SeniorIntern.Desktop.Controls.DiffHunkControl"
             x:DataType="vm:DiffHunkViewModel">

    <UserControl.Styles>
        <Style Selector="Border.hunk-header">
            <Setter Property="Background" Value="{DynamicResource DiffHunkHeaderBackground}" />
            <Setter Property="Padding" Value="8,4" />
        </Style>
    </UserControl.Styles>

    <Border Classes="diff-hunk" Margin="0,0,0,8">
        <Grid RowDefinitions="Auto, Auto">
            <!-- Hunk Header -->
            <Border Grid.Row="0" Classes="hunk-header">
                <Grid ColumnDefinitions="*, Auto">
                    <TextBlock Text="{Binding Header}"
                               FontFamily="Cascadia Code, Consolas, monospace"
                               FontSize="11"
                               Foreground="{DynamicResource DiffHunkHeaderForeground}" />
                    <StackPanel Grid.Column="1"
                                Orientation="Horizontal"
                                Spacing="8">
                        <TextBlock Text="{Binding AddedCount, StringFormat='+{0}'}"
                                   Foreground="{DynamicResource DiffAddedForeground}"
                                   FontSize="11" />
                        <TextBlock Text="{Binding RemovedCount, StringFormat='-{0}'}"
                                   Foreground="{DynamicResource DiffRemovedForeground}"
                                   FontSize="11" />
                    </StackPanel>
                </Grid>
            </Border>

            <!-- Lines -->
            <ItemsControl Grid.Row="1"
                          ItemsSource="{Binding Lines}"
                          x:Name="LinesContainer">
                <ItemsControl.ItemTemplate>
                    <DataTemplate DataType="{x:Type vm:DiffLineViewModel}">
                        <controls:DiffLineControl />
                    </DataTemplate>
                </ItemsControl.ItemTemplate>
            </ItemsControl>
        </Grid>
    </Border>
</UserControl>
```

### DiffHunkControl Code-Behind

```csharp
// src/SeniorIntern.Desktop/Controls/DiffHunkControl.axaml.cs
namespace SeniorIntern.Desktop.Controls;

public partial class DiffHunkControl : UserControl
{
    public static readonly StyledProperty<DiffSide> SideProperty =
        AvaloniaProperty.Register<DiffHunkControl, DiffSide>(nameof(Side));

    public static readonly StyledProperty<bool> ShowInlineChangesProperty =
        AvaloniaProperty.Register<DiffHunkControl, bool>(nameof(ShowInlineChanges), true);

    public DiffSide Side
    {
        get => GetValue(SideProperty);
        set => SetValue(SideProperty, value);
    }

    public bool ShowInlineChanges
    {
        get => GetValue(ShowInlineChangesProperty);
        set => SetValue(ShowInlineChangesProperty, value);
    }

    public DiffHunkControl()
    {
        InitializeComponent();
    }

    protected override void OnPropertyChanged(AvaloniaPropertyChangedEventArgs change)
    {
        base.OnPropertyChanged(change);

        if (change.Property == SideProperty)
        {
            UpdateLinesSource();
        }
    }

    private void UpdateLinesSource()
    {
        if (DataContext is DiffHunkViewModel vm)
        {
            LinesContainer.ItemsSource = Side == DiffSide.Original
                ? vm.OriginalLines
                : vm.ProposedLines;
        }
    }

    protected override void OnDataContextChanged(EventArgs e)
    {
        base.OnDataContextChanged(e);
        UpdateLinesSource();
    }
}
```

### DiffLineControl.axaml

```xml
<!-- src/SeniorIntern.Desktop/Controls/DiffLineControl.axaml -->
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:vm="using:SeniorIntern.Desktop.ViewModels"
             x:Class="SeniorIntern.Desktop.Controls.DiffLineControl"
             x:DataType="vm:DiffLineViewModel">

    <Grid ColumnDefinitions="48, *"
          MinHeight="20"
          Classes.added="{Binding IsAdded}"
          Classes.removed="{Binding IsRemoved}"
          Classes.modified="{Binding IsModified}"
          Classes.placeholder="{Binding IsPlaceholder}">

        <!-- Line Number Gutter -->
        <Border Grid.Column="0" Classes="line-gutter">
            <TextBlock Text="{Binding LineNumberDisplay}"
                       HorizontalAlignment="Right"
                       Padding="0,0,8,0"
                       FontFamily="Cascadia Code, Consolas, monospace"
                       FontSize="12"
                       Foreground="{DynamicResource DiffGutterForeground}"
                       IsVisible="{Binding !IsPlaceholder}" />
        </Border>

        <!-- Line Content -->
        <Border Grid.Column="1" Classes="line-content" Padding="8,1">
            <!-- Placeholder (empty line for alignment) -->
            <Panel IsVisible="{Binding IsPlaceholder}">
                <Rectangle Fill="{DynamicResource DiffPlaceholderBackground}"
                           Height="18"
                           HorizontalAlignment="Stretch" />
            </Panel>

            <!-- Regular content (no inline changes) -->
            <SelectableTextBlock Text="{Binding Content}"
                                 FontFamily="Cascadia Code, Consolas, monospace"
                                 FontSize="13"
                                 IsVisible="{Binding !HasInlineSegments}"
                                 Classes.content-visible="{Binding !IsPlaceholder}" />

            <!-- Content with inline changes -->
            <ItemsControl ItemsSource="{Binding InlineSegments}"
                          IsVisible="{Binding HasInlineSegments}">
                <ItemsControl.ItemsPanel>
                    <ItemsPanelTemplate>
                        <WrapPanel Orientation="Horizontal" />
                    </ItemsPanelTemplate>
                </ItemsControl.ItemsPanel>
                <ItemsControl.ItemTemplate>
                    <DataTemplate>
                        <TextBlock Text="{Binding Text}"
                                   FontFamily="Cascadia Code, Consolas, monospace"
                                   FontSize="13"
                                   Classes.inline-added="{Binding IsChanged,
                                       Converter={StaticResource InlineAddedConverter}}"
                                   Classes.inline-removed="{Binding IsChanged,
                                       Converter={StaticResource InlineRemovedConverter}}" />
                    </DataTemplate>
                </ItemsControl.ItemTemplate>
            </ItemsControl>
        </Border>
    </Grid>
</UserControl>
```

### DiffLineControl Code-Behind

```csharp
// src/SeniorIntern.Desktop/Controls/DiffLineControl.axaml.cs
namespace SeniorIntern.Desktop.Controls;

public partial class DiffLineControl : UserControl
{
    public DiffLineControl()
    {
        InitializeComponent();
    }
}
```

### Files to Create (v0.4.2f)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/Controls/DiffHunkControl.axaml` | Hunk container |
| `src/SeniorIntern.Desktop/Controls/DiffHunkControl.axaml.cs` | Hunk code-behind |
| `src/SeniorIntern.Desktop/Controls/DiffLineControl.axaml` | Line rendering |
| `src/SeniorIntern.Desktop/Controls/DiffLineControl.axaml.cs` | Line code-behind |

### Acceptance Criteria (v0.4.2f)

- [ ] Hunk headers display correctly
- [ ] Line numbers shown in gutter
- [ ] Added lines have green background
- [ ] Removed lines have red background
- [ ] Placeholder lines show for alignment
- [ ] Inline changes highlighted within lines
- [ ] Monospace font used consistently

---

## v0.4.2g: Diff Navigation

### Objective
Implement keyboard shortcuts and navigation helpers for the diff viewer.

### Keyboard Shortcuts

| Shortcut | Action |
|----------|--------|
| `Ctrl+↑` | Previous hunk |
| `Ctrl+↓` | Next hunk |
| `Escape` | Close diff viewer |
| `Ctrl+Enter` | Apply changes |
| `Ctrl+C` | Copy proposed content |
| `Ctrl+I` | Toggle inline changes |
| `Ctrl+W` | Toggle word wrap |

### DiffNavigationService

```csharp
// src/SeniorIntern.Desktop/Services/DiffNavigationService.cs
namespace SeniorIntern.Desktop.Services;

public sealed class DiffNavigationService
{
    private readonly List<DiffHunk> _hunks = new();
    private int _currentIndex = -1;

    public int CurrentIndex => _currentIndex;
    public int TotalHunks => _hunks.Count;
    public DiffHunk? CurrentHunk => _currentIndex >= 0 && _currentIndex < _hunks.Count
        ? _hunks[_currentIndex]
        : null;

    public void SetHunks(IEnumerable<DiffHunk> hunks)
    {
        _hunks.Clear();
        _hunks.AddRange(hunks);
        _currentIndex = _hunks.Count > 0 ? 0 : -1;
    }

    public bool MoveNext()
    {
        if (_currentIndex < _hunks.Count - 1)
        {
            _currentIndex++;
            return true;
        }
        return false;
    }

    public bool MovePrevious()
    {
        if (_currentIndex > 0)
        {
            _currentIndex--;
            return true;
        }
        return false;
    }

    public bool MoveTo(int index)
    {
        if (index >= 0 && index < _hunks.Count)
        {
            _currentIndex = index;
            return true;
        }
        return false;
    }

    public int FindHunkContainingLine(int lineNumber, DiffSide side)
    {
        for (int i = 0; i < _hunks.Count; i++)
        {
            var hunk = _hunks[i];
            var start = side == DiffSide.Original
                ? hunk.OriginalStartLine
                : hunk.ProposedStartLine;
            var count = side == DiffSide.Original
                ? hunk.OriginalLineCount
                : hunk.ProposedLineCount;

            if (lineNumber >= start && lineNumber < start + count)
                return i;
        }
        return -1;
    }
}
```

### Keyboard Handler

```csharp
// Add to DiffViewerPanel.axaml.cs

protected override void OnKeyDown(KeyEventArgs e)
{
    base.OnKeyDown(e);

    if (DataContext is not DiffViewerViewModel vm)
        return;

    var modifiers = e.KeyModifiers;
    var key = e.Key;

    if (modifiers.HasFlag(KeyModifiers.Control))
    {
        switch (key)
        {
            case Key.Up:
                vm.PreviousHunkCommand.Execute(null);
                e.Handled = true;
                break;
            case Key.Down:
                vm.NextHunkCommand.Execute(null);
                e.Handled = true;
                break;
            case Key.Enter:
                vm.RequestApplyCommand.Execute(null);
                e.Handled = true;
                break;
            case Key.C:
                vm.CopyProposedCommand.Execute(null);
                e.Handled = true;
                break;
            case Key.I:
                vm.ToggleInlineChangesCommand.Execute(null);
                e.Handled = true;
                break;
            case Key.W:
                vm.ToggleWordWrapCommand.Execute(null);
                e.Handled = true;
                break;
        }
    }
    else if (key == Key.Escape)
    {
        vm.RequestRejectCommand.Execute(null);
        e.Handled = true;
    }
}
```

### Files to Create (v0.4.2g)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/Services/DiffNavigationService.cs` | Navigation helper |

### Files to Modify (v0.4.2g)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/Views/DiffViewerPanel.axaml.cs` | Add keyboard handling |

### Acceptance Criteria (v0.4.2g)

- [ ] Ctrl+Up navigates to previous hunk
- [ ] Ctrl+Down navigates to next hunk
- [ ] Escape closes/rejects
- [ ] Ctrl+Enter applies changes
- [ ] Keyboard focus works correctly
- [ ] Navigation wraps or stops at boundaries

---

## v0.4.2h: Theming & Polish

### Objective
Add diff-specific colors, animations, and visual polish.

### Diff Theme Colors

```xml
<!-- Add to src/SeniorIntern.Desktop/Themes/Dark.axaml -->

<!-- Diff Panel Colors -->
<Color x:Key="DiffHeaderBackground">#1F1F1F</Color>
<Color x:Key="DiffPanelBackground">#1A1A1A</Color>
<Color x:Key="DiffSplitterBackground">#333333</Color>
<Color x:Key="DiffFooterBackground">#1F1F1F</Color>

<!-- Diff Line Colors -->
<Color x:Key="DiffAddedBackground">#1E3A21</Color>
<Color x:Key="DiffAddedForeground">#4ADE80</Color>
<Color x:Key="DiffAddedGutter">#2D5A31</Color>

<Color x:Key="DiffRemovedBackground">#3A1E1E</Color>
<Color x:Key="DiffRemovedForeground">#F87171</Color>
<Color x:Key="DiffRemovedGutter">#5A2D2D</Color>

<Color x:Key="DiffModifiedBackground">#3A3A1E</Color>
<Color x:Key="DiffModifiedForeground">#FBBF24</Color>

<Color x:Key="DiffUnchangedBackground">Transparent</Color>
<Color x:Key="DiffPlaceholderBackground">#0A0A0A</Color>

<!-- Inline Change Colors -->
<Color x:Key="DiffInlineAddedBackground">#2D5A31</Color>
<Color x:Key="DiffInlineRemovedBackground">#5A2D2D</Color>

<!-- Hunk Colors -->
<Color x:Key="DiffHunkHeaderBackground">#252526</Color>
<Color x:Key="DiffHunkHeaderForeground">#858585</Color>
<Color x:Key="DiffHunkBorder">#333333</Color>

<!-- Gutter Colors -->
<Color x:Key="DiffGutterBackground">#1A1A1A</Color>
<Color x:Key="DiffGutterForeground">#6E7681</Color>
<Color x:Key="DiffGutterBorder">#2D2D2D</Color>

<!-- Create SolidColorBrushes -->
<SolidColorBrush x:Key="DiffHeaderBackgroundBrush" Color="{StaticResource DiffHeaderBackground}" />
<SolidColorBrush x:Key="DiffPanelBackgroundBrush" Color="{StaticResource DiffPanelBackground}" />
<SolidColorBrush x:Key="DiffAddedBackgroundBrush" Color="{StaticResource DiffAddedBackground}" />
<SolidColorBrush x:Key="DiffAddedForegroundBrush" Color="{StaticResource DiffAddedForeground}" />
<SolidColorBrush x:Key="DiffRemovedBackgroundBrush" Color="{StaticResource DiffRemovedBackground}" />
<SolidColorBrush x:Key="DiffRemovedForegroundBrush" Color="{StaticResource DiffRemovedForeground}" />
<SolidColorBrush x:Key="DiffInlineAddedBackgroundBrush" Color="{StaticResource DiffInlineAddedBackground}" />
<SolidColorBrush x:Key="DiffInlineRemovedBackgroundBrush" Color="{StaticResource DiffInlineRemovedBackground}" />
<SolidColorBrush x:Key="DiffHunkHeaderBackgroundBrush" Color="{StaticResource DiffHunkHeaderBackground}" />
<SolidColorBrush x:Key="DiffGutterBackgroundBrush" Color="{StaticResource DiffGutterBackground}" />
<SolidColorBrush x:Key="DiffGutterForegroundBrush" Color="{StaticResource DiffGutterForeground}" />
```

### Diff Styles

```xml
<!-- Add to Dark.axaml -->

<!-- Diff Panel Styles -->
<Style Selector="Border.diff-header">
    <Setter Property="Background" Value="{DynamicResource DiffHeaderBackgroundBrush}" />
    <Setter Property="BorderBrush" Value="{DynamicResource BorderBrush}" />
    <Setter Property="BorderThickness" Value="0,0,0,1" />
</Style>

<Style Selector="Border.diff-panel">
    <Setter Property="Background" Value="{DynamicResource DiffPanelBackgroundBrush}" />
</Style>

<Style Selector="Border.diff-footer">
    <Setter Property="Background" Value="{DynamicResource DiffFooterBackgroundBrush}" />
    <Setter Property="BorderBrush" Value="{DynamicResource BorderBrush}" />
    <Setter Property="BorderThickness" Value="0,1,0,0" />
</Style>

<Style Selector="Border.panel-header">
    <Setter Property="Background" Value="{DynamicResource DiffHunkHeaderBackgroundBrush}" />
    <Setter Property="BorderBrush" Value="{DynamicResource BorderBrush}" />
    <Setter Property="BorderThickness" Value="0,0,0,1" />
</Style>

<!-- Line Styles -->
<Style Selector="Grid.added">
    <Setter Property="Background" Value="{DynamicResource DiffAddedBackgroundBrush}" />
</Style>

<Style Selector="Grid.removed">
    <Setter Property="Background" Value="{DynamicResource DiffRemovedBackgroundBrush}" />
</Style>

<Style Selector="Grid.modified">
    <Setter Property="Background" Value="{DynamicResource DiffModifiedBackgroundBrush}" />
</Style>

<Style Selector="Grid.placeholder">
    <Setter Property="Background" Value="{DynamicResource DiffPlaceholderBackgroundBrush}" />
    <Setter Property="Opacity" Value="0.5" />
</Style>

<!-- Gutter Styles -->
<Style Selector="Border.line-gutter">
    <Setter Property="Background" Value="{DynamicResource DiffGutterBackgroundBrush}" />
    <Setter Property="BorderBrush" Value="{DynamicResource DiffGutterBorderBrush}" />
    <Setter Property="BorderThickness" Value="0,0,1,0" />
    <Setter Property="MinWidth" Value="48" />
</Style>

<!-- Inline Change Styles -->
<Style Selector="TextBlock.inline-added">
    <Setter Property="Background" Value="{DynamicResource DiffInlineAddedBackgroundBrush}" />
    <Setter Property="Foreground" Value="{DynamicResource DiffAddedForegroundBrush}" />
</Style>

<Style Selector="TextBlock.inline-removed">
    <Setter Property="Background" Value="{DynamicResource DiffInlineRemovedBackgroundBrush}" />
    <Setter Property="Foreground" Value="{DynamicResource DiffRemovedForegroundBrush}" />
    <Setter Property="TextDecorations" Value="Strikethrough" />
</Style>

<!-- New File Badge -->
<Style Selector="Border.new-file-badge">
    <Setter Property="Background" Value="{DynamicResource DiffAddedBackgroundBrush}" />
    <Setter Property="Padding" Value="6,2" />
    <Setter Property="CornerRadius" Value="3" />
</Style>

<Style Selector="Border.new-file-badge TextBlock">
    <Setter Property="Foreground" Value="{DynamicResource DiffAddedForegroundBrush}" />
</Style>
```

### Icon Resources

```xml
<!-- Add to App.axaml -->

<StreamGeometry x:Key="FileCodeIcon">M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z</StreamGeometry>
<StreamGeometry x:Key="ChevronUpIcon">M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z</StreamGeometry>
<StreamGeometry x:Key="ChevronDownIcon">M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6z</StreamGeometry>
<StreamGeometry x:Key="HighlightIcon">M9 3L7.17 5.83l3.95 3.95-2.48 2.48L4.68 8.3 2 11V3h9zm12 18l1.83-2.83-3.95-3.95 2.48-2.48 3.96 3.96L22 13v8h-9l2.83-1.83z</StreamGeometry>
<StreamGeometry x:Key="WrapTextIcon">M4 19h6v-2H4v2zM20 5H4v2h16V5zm-3 6H4v2h13.25c1.1 0 2 .9 2 2s-.9 2-2 2H15v-2l-3 3 3 3v-2h2c2.21 0 4-1.79 4-4s-1.79-4-4-4z</StreamGeometry>
<StreamGeometry x:Key="LinkIcon">M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z</StreamGeometry>
<StreamGeometry x:Key="ErrorIcon">M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z</StreamGeometry>
```

### Files to Modify (v0.4.2h)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/Themes/Dark.axaml` | Add all diff colors and styles |
| `src/SeniorIntern.Desktop/App.axaml` | Add icon resources |

### Acceptance Criteria (v0.4.2h)

- [ ] All diff colors match design
- [ ] Added lines visually distinct
- [ ] Removed lines visually distinct
- [ ] Inline changes highlighted
- [ ] Gutter styled appropriately
- [ ] Icons render correctly
- [ ] Dark theme cohesive

---

## Architecture Summary

### Component Diagram

```
┌─────────────────────────────────────────────────────────────────┐
│                      DiffViewerPanel                             │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │                  DiffViewerViewModel                      │   │
│  │  - DiffResult                                             │   │
│  │  - Navigation state                                       │   │
│  │  - View options                                           │   │
│  └──────────────────────────────────────────────────────────┘   │
│                              │                                   │
│        ┌─────────────────────┴─────────────────────┐            │
│        │                                           │            │
│        ▼                                           ▼            │
│  ┌─────────────┐                           ┌─────────────┐      │
│  │  Original   │   Synchronized Scroll     │  Proposed   │      │
│  │  ScrollView │ ◄──────────────────────► │  ScrollView │      │
│  └─────────────┘                           └─────────────┘      │
│        │                                           │            │
│        ▼                                           ▼            │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │              DiffHunkControl (per hunk)                  │   │
│  │  ┌─────────────────────────────────────────────────────┐│   │
│  │  │           DiffLineControl (per line)                ││   │
│  │  │  [Gutter] [Content with InlineSegments]            ││   │
│  │  └─────────────────────────────────────────────────────┘│   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                       Services Layer                             │
├─────────────────────────────────────────────────────────────────┤
│  ┌────────────────────┐     ┌────────────────────────────────┐  │
│  │    DiffService     │────►│    InlineDiffService           │  │
│  │  - ComputeDiff()   │     │  - ComputeInlineChanges()      │  │
│  │  - BuildHunks()    │     │  - GetInlineSegments()         │  │
│  └────────────────────┘     └────────────────────────────────┘  │
│           │                                                      │
│           ▼                                                      │
│  ┌────────────────────┐                                         │
│  │    DiffPlex        │  (NuGet package)                        │
│  │  - Differ          │                                         │
│  │  - SideBySide      │                                         │
│  └────────────────────┘                                         │
└─────────────────────────────────────────────────────────────────┘
```

### Data Flow

```
1. User clicks "Apply" on CodeBlock
              │
              ▼
2. DiffViewerViewModel.LoadDiffAsync(block, workspacePath)
              │
              ▼
3. DiffService.ComputeDiffForBlockAsync()
              │
              ├──► Read original file content
              │
              ├──► DiffPlex computes line-level diff
              │
              ├──► BuildHunks() groups changes
              │
              └──► InlineDiffService.ComputeInlineChanges()
                            │
                            ▼
4. DiffResult created with Hunks, Stats
              │
              ▼
5. DiffHunkViewModel created for each hunk
              │
              ├──► BuildSideBySideLines() aligns original/proposed
              │
              └──► DiffLineViewModel created with InlineSegments
                            │
                            ▼
6. UI renders DiffViewerPanel
              │
              ├──► Side-by-side panels with synchronized scroll
              │
              └──► DiffLineControl renders each line with highlighting
```

---

## Files Summary

### Files to Create (Total: 16)

| File | Sub-Part |
|------|----------|
| `src/SeniorIntern.Core/Models/DiffResult.cs` | v0.4.2a |
| `src/SeniorIntern.Core/Models/DiffHunk.cs` | v0.4.2a |
| `src/SeniorIntern.Core/Models/DiffLine.cs` | v0.4.2a |
| `src/SeniorIntern.Core/Models/InlineChange.cs` | v0.4.2a |
| `src/SeniorIntern.Core/Models/DiffStats.cs` | v0.4.2a |
| `src/SeniorIntern.Core/Interfaces/IDiffService.cs` | v0.4.2b |
| `src/SeniorIntern.Core/Models/DiffOptions.cs` | v0.4.2b |
| `src/SeniorIntern.Services/DiffService.cs` | v0.4.2b |
| `src/SeniorIntern.Core/Interfaces/IInlineDiffService.cs` | v0.4.2c |
| `src/SeniorIntern.Services/InlineDiffService.cs` | v0.4.2c |
| `src/SeniorIntern.Desktop/ViewModels/DiffViewerViewModel.cs` | v0.4.2d |
| `src/SeniorIntern.Desktop/ViewModels/DiffHunkViewModel.cs` | v0.4.2d |
| `src/SeniorIntern.Desktop/ViewModels/DiffLineViewModel.cs` | v0.4.2d |
| `src/SeniorIntern.Desktop/Views/DiffViewerPanel.axaml` | v0.4.2e |
| `src/SeniorIntern.Desktop/Views/DiffViewerPanel.axaml.cs` | v0.4.2e |
| `src/SeniorIntern.Desktop/Controls/DiffHunkControl.axaml` | v0.4.2f |
| `src/SeniorIntern.Desktop/Controls/DiffHunkControl.axaml.cs` | v0.4.2f |
| `src/SeniorIntern.Desktop/Controls/DiffLineControl.axaml` | v0.4.2f |
| `src/SeniorIntern.Desktop/Controls/DiffLineControl.axaml.cs` | v0.4.2f |
| `src/SeniorIntern.Desktop/Services/DiffNavigationService.cs` | v0.4.2g |

### Files to Modify (Total: 5)

| File | Changes |
|------|---------|
| `Directory.Packages.props` | Add DiffPlex 1.7.2 |
| `src/SeniorIntern.Services/SeniorIntern.Services.csproj` | Reference DiffPlex |
| `src/SeniorIntern.Desktop/Extensions/ServiceCollectionExtensions.cs` | Register services |
| `src/SeniorIntern.Desktop/Themes/Dark.axaml` | Add diff colors/styles |
| `src/SeniorIntern.Desktop/App.axaml` | Add icon resources |

---

## NuGet Dependencies

| Package | Version | Purpose |
|---------|---------|---------|
| DiffPlex | 1.7.2 | Core diff computation |

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| DiffPlex performance on large files | Low | Medium | Add file size limits, async processing |
| Synchronized scroll lag | Medium | Low | Debounce scroll events |
| Inline diff false positives | Low | Low | Similarity threshold tuning |
| Memory usage with many hunks | Low | Medium | Virtualize long diffs |
| Side-by-side alignment edge cases | Medium | Medium | Comprehensive test cases |

---

## References

- [v0.4.0 Code Generation & Diffing](v0.4.0-code-generation-diffing.md) - Parent specification
- [v0.4.1 Code Block Extraction](v0.4.1-code-block-extraction.md) - Dependency
- [DiffPlex Documentation](https://github.com/mmanela/diffplex) - Diff library
- [GitHub Diff UI](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/about-comparing-branches-in-pull-requests) - UI inspiration
