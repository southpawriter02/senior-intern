# v0.4.5i: Status Bar Integration - Detailed Design Specification

**Status**: _PLANNED_

## Executive Summary

This specification details the Status Bar Integration feature for The Senior Intern v0.4.5 "Polish & Integration" release. The status bar provides at-a-glance visibility into pending changes, model status, saved state, and temperature settings, with click-to-navigate functionality for quick access to related features.

## Feature Overview

```
v0.4.5i Status Bar Integration
â”œâ”€â”€ Models
â”‚   â”œâ”€â”€ StatusBarSection (enum)
â”‚   â”œâ”€â”€ StatusBarItem (record)
â”‚   â””â”€â”€ StatusBarConfiguration (record)
â”œâ”€â”€ Services
â”‚   â”œâ”€â”€ IStatusBarService (interface)
â”‚   â””â”€â”€ StatusBarService (implementation)
â”œâ”€â”€ ViewModels
â”‚   â”œâ”€â”€ StatusBarViewModel (main)
â”‚   â”œâ”€â”€ StatusBarItemViewModel (individual items)
â”‚   â””â”€â”€ PendingChangesIndicatorViewModel (specialized)
â”œâ”€â”€ Views
â”‚   â”œâ”€â”€ StatusBar.axaml (main container)
â”‚   â”œâ”€â”€ StatusBarItem.axaml (reusable item)
â”‚   â””â”€â”€ PendingChangesIndicator.axaml (specialized indicator)
â”œâ”€â”€ Converters
â”‚   â”œâ”€â”€ StatusToColorConverter
â”‚   â””â”€â”€ CountToVisibilityConverter
â””â”€â”€ Tests
    â”œâ”€â”€ StatusBarServiceTests
    â”œâ”€â”€ StatusBarViewModelTests
    â””â”€â”€ PendingChangesIndicatorViewModelTests
```

## Architecture Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         Status Bar Architecture                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚   IUndoManager   â”‚    â”‚ ISettingsService â”‚    â”‚ IModelService    â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚           â”‚                       â”‚                       â”‚                  â”‚
â”‚           â”‚  Events               â”‚  Settings             â”‚  Model Status    â”‚
â”‚           â”‚                       â”‚                       â”‚                  â”‚
â”‚           â–¼                       â–¼                       â–¼                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚                      StatusBarService                             â”‚       â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚       â”‚
â”‚  â”‚  â”‚ - Aggregates status from multiple sources                   â”‚ â”‚       â”‚
â”‚  â”‚  â”‚ - Manages status bar item visibility                        â”‚ â”‚       â”‚
â”‚  â”‚  â”‚ - Coordinates navigation actions                            â”‚ â”‚       â”‚
â”‚  â”‚  â”‚ - Handles real-time updates                                 â”‚ â”‚       â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                                   â”‚                                          â”‚
â”‚                                   â–¼                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚                     StatusBarViewModel                            â”‚       â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚       â”‚
â”‚  â”‚  â”‚ - PendingChangesCount, HasPendingChanges                    â”‚ â”‚       â”‚
â”‚  â”‚  â”‚ - ModelName, ModelStatus, IsModelConnected                  â”‚ â”‚       â”‚
â”‚  â”‚  â”‚ - IsSaved, SavedStatusText                                  â”‚ â”‚       â”‚
â”‚  â”‚  â”‚ - Temperature, TemperatureDisplay                           â”‚ â”‚       â”‚
â”‚  â”‚  â”‚ - Commands: ShowChangeHistory, ShowSettings, CycleModel     â”‚ â”‚       â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                                   â”‚                                          â”‚
â”‚                                   â–¼                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚                         StatusBar.axaml                           â”‚       â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚       â”‚
â”‚  â”‚  â”‚ Model  â”‚ Spacer   â”‚ Pending        â”‚ Saved   â”‚ Temperature  â”‚ â”‚       â”‚
â”‚  â”‚  â”‚ Status â”‚          â”‚ Changes        â”‚ Status  â”‚ Display      â”‚ â”‚       â”‚
â”‚  â”‚  â”‚ [â—]    â”‚          â”‚ [ğŸ“ 3 changes] â”‚ [âœ“]     â”‚ [T: 0.7]     â”‚ â”‚       â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Detailed Design

### 1. Models

#### 1.1 StatusBarSection Enum

```csharp
// src/SeniorIntern.Core/Models/StatusBarSection.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Defines the sections of the status bar for positioning and ordering.
/// </summary>
public enum StatusBarSection
{
    /// <summary>Left-aligned section for primary status (model info).</summary>
    Left = 0,

    /// <summary>Center section (typically empty, provides spacing).</summary>
    Center = 1,

    /// <summary>Right section for secondary status items.</summary>
    Right = 2,

    /// <summary>Far-right section for tertiary items (temperature, etc.).</summary>
    FarRight = 3
}
```

#### 1.2 StatusBarItem Record

```csharp
// src/SeniorIntern.Core/Models/StatusBarItem.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Represents an item that can be displayed in the status bar.
/// </summary>
/// <param name="Id">Unique identifier for the status bar item.</param>
/// <param name="Section">Which section of the status bar this item belongs to.</param>
/// <param name="Order">Order within the section (lower = further left).</param>
/// <param name="IsVisible">Whether the item should currently be displayed.</param>
/// <param name="IsClickable">Whether the item responds to clicks.</param>
/// <param name="Tooltip">Tooltip text to display on hover.</param>
public record StatusBarItem(
    string Id,
    StatusBarSection Section,
    int Order,
    bool IsVisible = true,
    bool IsClickable = false,
    string? Tooltip = null)
{
    /// <summary>The content to display (text, icon, or both).</summary>
    public string? Text { get; init; }

    /// <summary>Icon resource key for the item.</summary>
    public string? IconKey { get; init; }

    /// <summary>Badge count to show (0 = no badge).</summary>
    public int BadgeCount { get; init; }

    /// <summary>Status color indicator (null = default).</summary>
    public StatusColor? Color { get; init; }

    /// <summary>Command identifier to invoke on click.</summary>
    public string? CommandId { get; init; }

    // Factory methods for common items
    public static StatusBarItem ModelStatus(string modelName, bool isConnected) => new(
        Id: "model-status",
        Section: StatusBarSection.Left,
        Order: 0,
        IsVisible: true,
        IsClickable: true,
        Tooltip: isConnected ? $"Connected to {modelName}" : "Click to configure model")
    {
        Text = $"Model: {modelName}",
        IconKey = "CircleIcon",
        Color = isConnected ? StatusColor.Success : StatusColor.Warning,
        CommandId = "ShowModelSettings"
    };

    public static StatusBarItem PendingChanges(int count) => new(
        Id: "pending-changes",
        Section: StatusBarSection.Right,
        Order: 0,
        IsVisible: count > 0,
        IsClickable: true,
        Tooltip: "Click to view change history")
    {
        Text = count switch
        {
            1 => "1 pending change",
            _ => $"{count} pending changes"
        },
        IconKey = "EditIcon",
        BadgeCount = count,
        CommandId = "ShowChangeHistory"
    };

    public static StatusBarItem SavedStatus(bool isSaved, DateTime? lastSaved = null) => new(
        Id: "saved-status",
        Section: StatusBarSection.Right,
        Order: 10,
        IsVisible: true,
        IsClickable: false,
        Tooltip: lastSaved.HasValue
            ? $"Last saved: {lastSaved.Value:g}"
            : "All changes saved")
    {
        Text = isSaved ? "Saved" : "Unsaved",
        IconKey = isSaved ? "CheckIcon" : "WarningIcon",
        Color = isSaved ? StatusColor.Success : StatusColor.Warning
    };

    public static StatusBarItem Temperature(double temperature) => new(
        Id: "temperature",
        Section: StatusBarSection.FarRight,
        Order: 0,
        IsVisible: true,
        IsClickable: true,
        Tooltip: $"Model temperature: {temperature:F2}\nClick to adjust")
    {
        Text = $"T: {temperature:F1}",
        CommandId = "ShowTemperatureSlider"
    };
}
```

#### 1.3 StatusColor Enum

```csharp
// src/SeniorIntern.Core/Models/StatusColor.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Status indicator colors for status bar items.
/// </summary>
public enum StatusColor
{
    /// <summary>Default/neutral color.</summary>
    Default,

    /// <summary>Success/positive indicator (green).</summary>
    Success,

    /// <summary>Warning indicator (yellow/orange).</summary>
    Warning,

    /// <summary>Error indicator (red).</summary>
    Error,

    /// <summary>Info indicator (blue).</summary>
    Info,

    /// <summary>Muted/secondary indicator (gray).</summary>
    Muted
}
```

#### 1.4 StatusBarConfiguration Record

```csharp
// src/SeniorIntern.Core/Models/StatusBarConfiguration.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Configuration options for the status bar display and behavior.
/// </summary>
/// <param name="ShowModelStatus">Whether to show model connection status.</param>
/// <param name="ShowPendingChanges">Whether to show pending changes indicator.</param>
/// <param name="ShowSavedStatus">Whether to show saved/unsaved status.</param>
/// <param name="ShowTemperature">Whether to show temperature display.</param>
/// <param name="AnimateChanges">Whether to animate status changes.</param>
/// <param name="CompactMode">Whether to use compact display mode.</param>
public record StatusBarConfiguration(
    bool ShowModelStatus = true,
    bool ShowPendingChanges = true,
    bool ShowSavedStatus = true,
    bool ShowTemperature = true,
    bool AnimateChanges = true,
    bool CompactMode = false)
{
    /// <summary>Default configuration with all features enabled.</summary>
    public static StatusBarConfiguration Default => new();

    /// <summary>Compact configuration for smaller displays.</summary>
    public static StatusBarConfiguration Compact => new(CompactMode: true);

    /// <summary>Minimal configuration showing only essential items.</summary>
    public static StatusBarConfiguration Minimal => new(
        ShowModelStatus: true,
        ShowPendingChanges: true,
        ShowSavedStatus: false,
        ShowTemperature: false);
}
```

### 2. Services

#### 2.1 IStatusBarService Interface

```csharp
// src/SeniorIntern.Core/Interfaces/IStatusBarService.cs
using SeniorIntern.Core.Models;

namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Service for managing status bar content and interactions.
/// </summary>
public interface IStatusBarService
{
    /// <summary>Gets the current status bar configuration.</summary>
    StatusBarConfiguration Configuration { get; }

    /// <summary>Gets all current status bar items.</summary>
    IReadOnlyList<StatusBarItem> Items { get; }

    /// <summary>Gets items for a specific section.</summary>
    IReadOnlyList<StatusBarItem> GetItemsForSection(StatusBarSection section);

    /// <summary>Updates the configuration.</summary>
    void UpdateConfiguration(StatusBarConfiguration configuration);

    /// <summary>Registers a custom status bar item.</summary>
    void RegisterItem(StatusBarItem item);

    /// <summary>Unregisters a status bar item by ID.</summary>
    void UnregisterItem(string itemId);

    /// <summary>Updates an existing item.</summary>
    void UpdateItem(string itemId, Action<StatusBarItem> update);

    /// <summary>Sets the visibility of an item.</summary>
    void SetItemVisibility(string itemId, bool isVisible);

    /// <summary>Executes the command associated with an item.</summary>
    Task ExecuteItemCommandAsync(string itemId, CancellationToken cancellationToken = default);

    /// <summary>Raised when any status bar item changes.</summary>
    event EventHandler<StatusBarItemChangedEventArgs>? ItemChanged;

    /// <summary>Raised when the item collection changes.</summary>
    event EventHandler<StatusBarItemsChangedEventArgs>? ItemsChanged;

    /// <summary>Raised when configuration changes.</summary>
    event EventHandler<StatusBarConfiguration>? ConfigurationChanged;
}

/// <summary>Event args for individual item changes.</summary>
public class StatusBarItemChangedEventArgs : EventArgs
{
    public required string ItemId { get; init; }
    public required StatusBarItem OldItem { get; init; }
    public required StatusBarItem NewItem { get; init; }
    public required StatusBarItemChangeType ChangeType { get; init; }
}

/// <summary>Event args for collection changes.</summary>
public class StatusBarItemsChangedEventArgs : EventArgs
{
    public required IReadOnlyList<StatusBarItem> AddedItems { get; init; }
    public required IReadOnlyList<string> RemovedItemIds { get; init; }
}

/// <summary>Type of change to a status bar item.</summary>
public enum StatusBarItemChangeType
{
    Added,
    Updated,
    Removed,
    VisibilityChanged
}
```

#### 2.2 StatusBarService Implementation

```csharp
// src/SeniorIntern.Services/StatusBarService.cs
using System.Collections.Concurrent;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;

namespace SeniorIntern.Services;

/// <summary>
/// Implementation of status bar management service.
/// </summary>
public sealed class StatusBarService : IStatusBarService, IDisposable
{
    private readonly IUndoManager _undoManager;
    private readonly ISettingsService _settingsService;
    private readonly IModelService _modelService;
    private readonly IWorkspaceService _workspaceService;
    private readonly ConcurrentDictionary<string, StatusBarItem> _items = new();
    private readonly object _lock = new();

    private StatusBarConfiguration _configuration = StatusBarConfiguration.Default;

    public StatusBarConfiguration Configuration => _configuration;

    public IReadOnlyList<StatusBarItem> Items => _items.Values
        .OrderBy(i => i.Section)
        .ThenBy(i => i.Order)
        .ToList();

    public event EventHandler<StatusBarItemChangedEventArgs>? ItemChanged;
    public event EventHandler<StatusBarItemsChangedEventArgs>? ItemsChanged;
    public event EventHandler<StatusBarConfiguration>? ConfigurationChanged;

    public StatusBarService(
        IUndoManager undoManager,
        ISettingsService settingsService,
        IModelService modelService,
        IWorkspaceService workspaceService)
    {
        _undoManager = undoManager ?? throw new ArgumentNullException(nameof(undoManager));
        _settingsService = settingsService ?? throw new ArgumentNullException(nameof(settingsService));
        _modelService = modelService ?? throw new ArgumentNullException(nameof(modelService));
        _workspaceService = workspaceService ?? throw new ArgumentNullException(nameof(workspaceService));

        // Initialize default items
        InitializeDefaultItems();

        // Subscribe to events
        _undoManager.ChangeRecorded += OnChangeRecorded;
        _undoManager.ChangeUndone += OnChangeUndone;
        _undoManager.ChangeExpired += OnChangeExpired;
        _modelService.ConnectionStatusChanged += OnModelConnectionChanged;
        _workspaceService.SaveStateChanged += OnSaveStateChanged;
        _settingsService.SettingsChanged += OnSettingsChanged;
    }

    private void InitializeDefaultItems()
    {
        var settings = _settingsService.GetSettings();
        var modelInfo = _modelService.GetCurrentModelInfo();
        var undoableCount = _undoManager.GetUndoableCount();

        var defaultItems = new[]
        {
            StatusBarItem.ModelStatus(modelInfo.Name, modelInfo.IsConnected),
            StatusBarItem.PendingChanges(undoableCount),
            StatusBarItem.SavedStatus(_workspaceService.IsSaved, _workspaceService.LastSaveTime),
            StatusBarItem.Temperature(settings.ModelSettings.Temperature)
        };

        foreach (var item in defaultItems)
        {
            _items.TryAdd(item.Id, item);
        }
    }

    public IReadOnlyList<StatusBarItem> GetItemsForSection(StatusBarSection section)
    {
        return _items.Values
            .Where(i => i.Section == section && i.IsVisible)
            .OrderBy(i => i.Order)
            .ToList();
    }

    public void UpdateConfiguration(StatusBarConfiguration configuration)
    {
        var old = _configuration;
        _configuration = configuration;

        // Update item visibility based on configuration
        SetItemVisibility("model-status", configuration.ShowModelStatus);
        SetItemVisibility("pending-changes", configuration.ShowPendingChanges);
        SetItemVisibility("saved-status", configuration.ShowSavedStatus);
        SetItemVisibility("temperature", configuration.ShowTemperature);

        ConfigurationChanged?.Invoke(this, configuration);
    }

    public void RegisterItem(StatusBarItem item)
    {
        ArgumentNullException.ThrowIfNull(item);

        if (_items.TryAdd(item.Id, item))
        {
            ItemsChanged?.Invoke(this, new StatusBarItemsChangedEventArgs
            {
                AddedItems = new[] { item },
                RemovedItemIds = Array.Empty<string>()
            });

            ItemChanged?.Invoke(this, new StatusBarItemChangedEventArgs
            {
                ItemId = item.Id,
                OldItem = item,
                NewItem = item,
                ChangeType = StatusBarItemChangeType.Added
            });
        }
    }

    public void UnregisterItem(string itemId)
    {
        if (_items.TryRemove(itemId, out var removed))
        {
            ItemsChanged?.Invoke(this, new StatusBarItemsChangedEventArgs
            {
                AddedItems = Array.Empty<StatusBarItem>(),
                RemovedItemIds = new[] { itemId }
            });

            ItemChanged?.Invoke(this, new StatusBarItemChangedEventArgs
            {
                ItemId = itemId,
                OldItem = removed,
                NewItem = removed,
                ChangeType = StatusBarItemChangeType.Removed
            });
        }
    }

    public void UpdateItem(string itemId, Action<StatusBarItem> update)
    {
        if (_items.TryGetValue(itemId, out var oldItem))
        {
            // Create a modified copy (records are immutable)
            var builder = new StatusBarItemBuilder(oldItem);
            update(builder.Item);
            var newItem = builder.Build();

            if (_items.TryUpdate(itemId, newItem, oldItem))
            {
                ItemChanged?.Invoke(this, new StatusBarItemChangedEventArgs
                {
                    ItemId = itemId,
                    OldItem = oldItem,
                    NewItem = newItem,
                    ChangeType = StatusBarItemChangeType.Updated
                });
            }
        }
    }

    public void SetItemVisibility(string itemId, bool isVisible)
    {
        if (_items.TryGetValue(itemId, out var oldItem) && oldItem.IsVisible != isVisible)
        {
            var newItem = oldItem with { IsVisible = isVisible };

            if (_items.TryUpdate(itemId, newItem, oldItem))
            {
                ItemChanged?.Invoke(this, new StatusBarItemChangedEventArgs
                {
                    ItemId = itemId,
                    OldItem = oldItem,
                    NewItem = newItem,
                    ChangeType = StatusBarItemChangeType.VisibilityChanged
                });
            }
        }
    }

    public async Task ExecuteItemCommandAsync(string itemId, CancellationToken cancellationToken = default)
    {
        if (!_items.TryGetValue(itemId, out var item) || string.IsNullOrEmpty(item.CommandId))
            return;

        switch (item.CommandId)
        {
            case "ShowChangeHistory":
                await ShowChangeHistoryAsync(cancellationToken);
                break;

            case "ShowModelSettings":
                await ShowModelSettingsAsync(cancellationToken);
                break;

            case "ShowTemperatureSlider":
                await ShowTemperatureSliderAsync(cancellationToken);
                break;

            default:
                // Allow extensibility for custom commands
                break;
        }
    }

    private Task ShowChangeHistoryAsync(CancellationToken cancellationToken)
    {
        // This will be wired up by the MainWindowViewModel
        // The service raises an event that the ViewModel handles
        return Task.CompletedTask;
    }

    private Task ShowModelSettingsAsync(CancellationToken cancellationToken)
    {
        return Task.CompletedTask;
    }

    private Task ShowTemperatureSliderAsync(CancellationToken cancellationToken)
    {
        return Task.CompletedTask;
    }

    // Event handlers
    private void OnChangeRecorded(object? sender, FileChangeRecord record)
    {
        UpdatePendingChangesCount();
    }

    private void OnChangeUndone(object? sender, FileChangeRecord record)
    {
        UpdatePendingChangesCount();
    }

    private void OnChangeExpired(object? sender, FileChangeRecord record)
    {
        UpdatePendingChangesCount();
    }

    private void UpdatePendingChangesCount()
    {
        var count = _undoManager.GetUndoableCount();
        var newItem = StatusBarItem.PendingChanges(count);

        if (_items.TryGetValue("pending-changes", out var oldItem))
        {
            _items.TryUpdate("pending-changes", newItem, oldItem);

            ItemChanged?.Invoke(this, new StatusBarItemChangedEventArgs
            {
                ItemId = "pending-changes",
                OldItem = oldItem,
                NewItem = newItem,
                ChangeType = StatusBarItemChangeType.Updated
            });
        }
    }

    private void OnModelConnectionChanged(object? sender, ModelConnectionEventArgs args)
    {
        var newItem = StatusBarItem.ModelStatus(args.ModelName, args.IsConnected);

        if (_items.TryGetValue("model-status", out var oldItem))
        {
            _items.TryUpdate("model-status", newItem, oldItem);

            ItemChanged?.Invoke(this, new StatusBarItemChangedEventArgs
            {
                ItemId = "model-status",
                OldItem = oldItem,
                NewItem = newItem,
                ChangeType = StatusBarItemChangeType.Updated
            });
        }
    }

    private void OnSaveStateChanged(object? sender, SaveStateEventArgs args)
    {
        var newItem = StatusBarItem.SavedStatus(args.IsSaved, args.LastSaveTime);

        if (_items.TryGetValue("saved-status", out var oldItem))
        {
            _items.TryUpdate("saved-status", newItem, oldItem);

            ItemChanged?.Invoke(this, new StatusBarItemChangedEventArgs
            {
                ItemId = "saved-status",
                OldItem = oldItem,
                NewItem = newItem,
                ChangeType = StatusBarItemChangeType.Updated
            });
        }
    }

    private void OnSettingsChanged(object? sender, AppSettings settings)
    {
        var newItem = StatusBarItem.Temperature(settings.ModelSettings.Temperature);

        if (_items.TryGetValue("temperature", out var oldItem))
        {
            _items.TryUpdate("temperature", newItem, oldItem);

            ItemChanged?.Invoke(this, new StatusBarItemChangedEventArgs
            {
                ItemId = "temperature",
                OldItem = oldItem,
                NewItem = newItem,
                ChangeType = StatusBarItemChangeType.Updated
            });
        }
    }

    public void Dispose()
    {
        _undoManager.ChangeRecorded -= OnChangeRecorded;
        _undoManager.ChangeUndone -= OnChangeUndone;
        _undoManager.ChangeExpired -= OnChangeExpired;
        _modelService.ConnectionStatusChanged -= OnModelConnectionChanged;
        _workspaceService.SaveStateChanged -= OnSaveStateChanged;
        _settingsService.SettingsChanged -= OnSettingsChanged;
    }
}

/// <summary>
/// Helper class for building modified StatusBarItems.
/// </summary>
internal class StatusBarItemBuilder
{
    public StatusBarItem Item { get; private set; }

    public StatusBarItemBuilder(StatusBarItem item)
    {
        Item = item;
    }

    public StatusBarItem Build() => Item;
}
```

### 3. ViewModels

#### 3.1 StatusBarViewModel

```csharp
// src/SeniorIntern.Desktop/ViewModels/StatusBarViewModel.cs
using System.Collections.ObjectModel;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;

namespace SeniorIntern.Desktop.ViewModels;

/// <summary>
/// ViewModel for the main status bar component.
/// </summary>
public partial class StatusBarViewModel : ViewModelBase
{
    private readonly IStatusBarService _statusBarService;
    private readonly IUndoManager _undoManager;

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(PendingChangesText))]
    [NotifyPropertyChangedFor(nameof(HasPendingChanges))]
    private int _pendingChangesCount;

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(ModelDisplayText))]
    private string _modelName = "Unknown";

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(ModelStatusColor))]
    [NotifyPropertyChangedFor(nameof(ModelDisplayText))]
    private bool _isModelConnected;

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(SavedStatusText))]
    [NotifyPropertyChangedFor(nameof(SavedStatusColor))]
    private bool _isSaved = true;

    [ObservableProperty]
    private DateTime? _lastSaveTime;

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(TemperatureDisplay))]
    private double _temperature = 0.7;

    [ObservableProperty]
    private bool _isCompactMode;

    [ObservableProperty]
    private ObservableCollection<StatusBarItemViewModel> _leftItems = new();

    [ObservableProperty]
    private ObservableCollection<StatusBarItemViewModel> _rightItems = new();

    [ObservableProperty]
    private ObservableCollection<StatusBarItemViewModel> _farRightItems = new();

    // Computed properties
    public string PendingChangesText => PendingChangesCount switch
    {
        0 => "No pending changes",
        1 => "1 pending change",
        _ => $"{PendingChangesCount} pending changes"
    };

    public bool HasPendingChanges => PendingChangesCount > 0;

    public string ModelDisplayText => IsCompactMode
        ? ModelName
        : $"Model: {ModelName}";

    public string ModelStatusColor => IsModelConnected
        ? "Success"
        : "Warning";

    public string SavedStatusText => IsSaved ? "Saved" : "Unsaved";

    public string SavedStatusColor => IsSaved ? "Success" : "Warning";

    public string TemperatureDisplay => $"T: {Temperature:F1}";

    public string TemperatureTooltip => $"Model temperature: {Temperature:F2}\nClick to adjust";

    public string PendingChangesTooltip => HasPendingChanges
        ? "Click to view change history"
        : "No pending changes";

    public string SavedStatusTooltip => LastSaveTime.HasValue
        ? $"Last saved: {LastSaveTime.Value:g}"
        : "All changes saved";

    // Events for navigation
    public event EventHandler? ShowChangeHistoryRequested;
    public event EventHandler? ShowModelSettingsRequested;
    public event EventHandler? ShowTemperatureSliderRequested;

    public StatusBarViewModel(
        IStatusBarService statusBarService,
        IUndoManager undoManager)
    {
        _statusBarService = statusBarService ?? throw new ArgumentNullException(nameof(statusBarService));
        _undoManager = undoManager ?? throw new ArgumentNullException(nameof(undoManager));

        // Subscribe to service events
        _statusBarService.ItemChanged += OnItemChanged;
        _statusBarService.ConfigurationChanged += OnConfigurationChanged;

        // Initialize from service
        RefreshFromService();
    }

    private void RefreshFromService()
    {
        var items = _statusBarService.Items;

        // Update individual properties from items
        var pendingItem = items.FirstOrDefault(i => i.Id == "pending-changes");
        if (pendingItem != null)
        {
            PendingChangesCount = pendingItem.BadgeCount;
        }

        var modelItem = items.FirstOrDefault(i => i.Id == "model-status");
        if (modelItem != null)
        {
            // Parse model name from text
            ModelName = modelItem.Text?.Replace("Model: ", "") ?? "Unknown";
            IsModelConnected = modelItem.Color == StatusColor.Success;
        }

        var savedItem = items.FirstOrDefault(i => i.Id == "saved-status");
        if (savedItem != null)
        {
            IsSaved = savedItem.Color == StatusColor.Success;
        }

        var tempItem = items.FirstOrDefault(i => i.Id == "temperature");
        if (tempItem != null && double.TryParse(
            tempItem.Text?.Replace("T: ", ""),
            out var temp))
        {
            Temperature = temp;
        }

        // Update configuration-based properties
        IsCompactMode = _statusBarService.Configuration.CompactMode;

        // Build item collections for sections
        RebuildItemCollections();
    }

    private void RebuildItemCollections()
    {
        LeftItems.Clear();
        RightItems.Clear();
        FarRightItems.Clear();

        foreach (var item in _statusBarService.GetItemsForSection(StatusBarSection.Left))
        {
            LeftItems.Add(new StatusBarItemViewModel(item, ExecuteItemCommand));
        }

        foreach (var item in _statusBarService.GetItemsForSection(StatusBarSection.Right))
        {
            RightItems.Add(new StatusBarItemViewModel(item, ExecuteItemCommand));
        }

        foreach (var item in _statusBarService.GetItemsForSection(StatusBarSection.FarRight))
        {
            FarRightItems.Add(new StatusBarItemViewModel(item, ExecuteItemCommand));
        }
    }

    private void OnItemChanged(object? sender, StatusBarItemChangedEventArgs e)
    {
        // Update the specific property based on which item changed
        switch (e.ItemId)
        {
            case "pending-changes":
                PendingChangesCount = e.NewItem.BadgeCount;
                break;

            case "model-status":
                ModelName = e.NewItem.Text?.Replace("Model: ", "") ?? "Unknown";
                IsModelConnected = e.NewItem.Color == StatusColor.Success;
                break;

            case "saved-status":
                IsSaved = e.NewItem.Color == StatusColor.Success;
                break;

            case "temperature":
                if (double.TryParse(e.NewItem.Text?.Replace("T: ", ""), out var temp))
                {
                    Temperature = temp;
                }
                break;
        }

        // Rebuild if visibility changed
        if (e.ChangeType == StatusBarItemChangeType.VisibilityChanged ||
            e.ChangeType == StatusBarItemChangeType.Added ||
            e.ChangeType == StatusBarItemChangeType.Removed)
        {
            RebuildItemCollections();
        }
    }

    private void OnConfigurationChanged(object? sender, StatusBarConfiguration config)
    {
        IsCompactMode = config.CompactMode;
        RebuildItemCollections();
    }

    private async Task ExecuteItemCommand(string itemId)
    {
        await _statusBarService.ExecuteItemCommandAsync(itemId);

        // Also raise local events for ViewModel-level handling
        switch (itemId)
        {
            case "pending-changes":
                ShowChangeHistoryRequested?.Invoke(this, EventArgs.Empty);
                break;

            case "model-status":
                ShowModelSettingsRequested?.Invoke(this, EventArgs.Empty);
                break;

            case "temperature":
                ShowTemperatureSliderRequested?.Invoke(this, EventArgs.Empty);
                break;
        }
    }

    [RelayCommand]
    private void ShowChangeHistory()
    {
        ShowChangeHistoryRequested?.Invoke(this, EventArgs.Empty);
    }

    [RelayCommand]
    private void ShowModelSettings()
    {
        ShowModelSettingsRequested?.Invoke(this, EventArgs.Empty);
    }

    [RelayCommand]
    private void ShowTemperatureSlider()
    {
        ShowTemperatureSliderRequested?.Invoke(this, EventArgs.Empty);
    }

    [RelayCommand]
    private void ToggleCompactMode()
    {
        var newConfig = _statusBarService.Configuration with
        {
            CompactMode = !_statusBarService.Configuration.CompactMode
        };
        _statusBarService.UpdateConfiguration(newConfig);
    }
}
```

#### 3.2 StatusBarItemViewModel

```csharp
// src/SeniorIntern.Desktop/ViewModels/StatusBarItemViewModel.cs
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using SeniorIntern.Core.Models;

namespace SeniorIntern.Desktop.ViewModels;

/// <summary>
/// ViewModel for an individual status bar item.
/// </summary>
public partial class StatusBarItemViewModel : ViewModelBase
{
    private readonly Func<string, Task> _executeCommand;

    [ObservableProperty]
    private string _id;

    [ObservableProperty]
    private string? _text;

    [ObservableProperty]
    private string? _iconKey;

    [ObservableProperty]
    private int _badgeCount;

    [ObservableProperty]
    private bool _isVisible;

    [ObservableProperty]
    private bool _isClickable;

    [ObservableProperty]
    private string? _tooltip;

    [ObservableProperty]
    private StatusColor _color;

    // Computed properties
    public bool HasBadge => BadgeCount > 0;

    public bool HasIcon => !string.IsNullOrEmpty(IconKey);

    public bool HasText => !string.IsNullOrEmpty(Text);

    public string ColorBrushKey => Color switch
    {
        StatusColor.Success => "SuccessBrush",
        StatusColor.Warning => "WarningBrush",
        StatusColor.Error => "ErrorBrush",
        StatusColor.Info => "InfoBrush",
        StatusColor.Muted => "MutedBrush",
        _ => "ForegroundBrush"
    };

    public StatusBarItemViewModel(StatusBarItem item, Func<string, Task> executeCommand)
    {
        _executeCommand = executeCommand ?? throw new ArgumentNullException(nameof(executeCommand));

        UpdateFromItem(item);
    }

    public void UpdateFromItem(StatusBarItem item)
    {
        Id = item.Id;
        Text = item.Text;
        IconKey = item.IconKey;
        BadgeCount = item.BadgeCount;
        IsVisible = item.IsVisible;
        IsClickable = item.IsClickable;
        Tooltip = item.Tooltip;
        Color = item.Color ?? StatusColor.Default;
    }

    [RelayCommand(CanExecute = nameof(CanExecute))]
    private async Task Execute()
    {
        if (IsClickable)
        {
            await _executeCommand(Id);
        }
    }

    private bool CanExecute() => IsClickable;
}
```

#### 3.3 PendingChangesIndicatorViewModel

```csharp
// src/SeniorIntern.Desktop/ViewModels/PendingChangesIndicatorViewModel.cs
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using SeniorIntern.Core.Interfaces;

namespace SeniorIntern.Desktop.ViewModels;

/// <summary>
/// Specialized ViewModel for the pending changes indicator with animation support.
/// </summary>
public partial class PendingChangesIndicatorViewModel : ViewModelBase, IDisposable
{
    private readonly IUndoManager _undoManager;
    private readonly System.Timers.Timer _pulseTimer;

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(DisplayText))]
    [NotifyPropertyChangedFor(nameof(IsVisible))]
    [NotifyPropertyChangedFor(nameof(ShouldPulse))]
    private int _count;

    [ObservableProperty]
    private bool _isPulsing;

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(ShouldPulse))]
    private bool _hasRecentChange;

    [ObservableProperty]
    private DateTime? _mostRecentChangeTime;

    // Computed properties
    public string DisplayText => Count switch
    {
        0 => string.Empty,
        1 => "1 pending change",
        _ => $"{Count} pending changes"
    };

    public string ShortDisplayText => Count switch
    {
        0 => string.Empty,
        _ => Count.ToString()
    };

    public bool IsVisible => Count > 0;

    public bool ShouldPulse => HasRecentChange && Count > 0;

    public string Tooltip => Count switch
    {
        0 => "No pending changes",
        1 => "1 change can be undone\nClick to view history",
        _ => $"{Count} changes can be undone\nClick to view history"
    };

    // Events
    public event EventHandler? Clicked;

    public PendingChangesIndicatorViewModel(IUndoManager undoManager)
    {
        _undoManager = undoManager ?? throw new ArgumentNullException(nameof(undoManager));

        // Initialize
        Count = _undoManager.GetUndoableCount();

        // Subscribe to changes
        _undoManager.ChangeRecorded += OnChangeRecorded;
        _undoManager.ChangeUndone += OnChangeUndone;
        _undoManager.ChangeExpired += OnChangeExpired;

        // Pulse timer for animation
        _pulseTimer = new System.Timers.Timer(2000); // 2 second pulse duration
        _pulseTimer.Elapsed += OnPulseTimerElapsed;
        _pulseTimer.AutoReset = false;
    }

    private void OnChangeRecorded(object? sender, FileChangeRecord record)
    {
        Count = _undoManager.GetUndoableCount();
        MostRecentChangeTime = record.Timestamp;
        TriggerPulse();
    }

    private void OnChangeUndone(object? sender, FileChangeRecord record)
    {
        Count = _undoManager.GetUndoableCount();
    }

    private void OnChangeExpired(object? sender, FileChangeRecord record)
    {
        Count = _undoManager.GetUndoableCount();
    }

    private void TriggerPulse()
    {
        HasRecentChange = true;
        IsPulsing = true;
        _pulseTimer.Stop();
        _pulseTimer.Start();
    }

    private void OnPulseTimerElapsed(object? sender, System.Timers.ElapsedEventArgs e)
    {
        HasRecentChange = false;
        IsPulsing = false;
    }

    [RelayCommand]
    private void Click()
    {
        Clicked?.Invoke(this, EventArgs.Empty);
    }

    public void Dispose()
    {
        _undoManager.ChangeRecorded -= OnChangeRecorded;
        _undoManager.ChangeUndone -= OnChangeUndone;
        _undoManager.ChangeExpired -= OnChangeExpired;

        _pulseTimer.Stop();
        _pulseTimer.Dispose();
    }
}
```

### 4. Views

#### 4.1 StatusBar.axaml

```xml
<!-- src/SeniorIntern.Desktop/Views/StatusBar.axaml -->
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             xmlns:vm="using:SeniorIntern.Desktop.ViewModels"
             xmlns:views="using:SeniorIntern.Desktop.Views"
             xmlns:converters="using:SeniorIntern.Desktop.Converters"
             mc:Ignorable="d" d:DesignWidth="800" d:DesignHeight="28"
             x:Class="SeniorIntern.Desktop.Views.StatusBar"
             x:DataType="vm:StatusBarViewModel">

    <UserControl.Resources>
        <converters:StatusToColorConverter x:Key="StatusToColorConverter" />
        <converters:CountToVisibilityConverter x:Key="CountToVisibilityConverter" />
    </UserControl.Resources>

    <UserControl.Styles>
        <!-- Status bar container -->
        <Style Selector="Border.status-bar">
            <Setter Property="Background" Value="{DynamicResource StatusBarBackground}" />
            <Setter Property="BorderBrush" Value="{DynamicResource StatusBarBorder}" />
            <Setter Property="BorderThickness" Value="0,1,0,0" />
            <Setter Property="Padding" Value="8,4" />
            <Setter Property="MinHeight" Value="24" />
        </Style>

        <!-- Status bar button -->
        <Style Selector="Button.status-button">
            <Setter Property="Background" Value="Transparent" />
            <Setter Property="BorderThickness" Value="0" />
            <Setter Property="Padding" Value="6,2" />
            <Setter Property="Cursor" Value="Hand" />
            <Setter Property="CornerRadius" Value="3" />
        </Style>

        <Style Selector="Button.status-button:pointerover">
            <Setter Property="Background" Value="{DynamicResource StatusBarHover}" />
        </Style>

        <Style Selector="Button.status-button:pressed">
            <Setter Property="Background" Value="{DynamicResource StatusBarPressed}" />
        </Style>

        <!-- Status indicator dot -->
        <Style Selector="Ellipse.status-dot">
            <Setter Property="Width" Value="8" />
            <Setter Property="Height" Value="8" />
        </Style>

        <Style Selector="Ellipse.status-dot.success">
            <Setter Property="Fill" Value="{DynamicResource SuccessBrush}" />
        </Style>

        <Style Selector="Ellipse.status-dot.warning">
            <Setter Property="Fill" Value="{DynamicResource WarningBrush}" />
        </Style>

        <Style Selector="Ellipse.status-dot.error">
            <Setter Property="Fill" Value="{DynamicResource ErrorBrush}" />
        </Style>

        <!-- Status text -->
        <Style Selector="TextBlock.status-text">
            <Setter Property="FontSize" Value="12" />
            <Setter Property="VerticalAlignment" Value="Center" />
        </Style>

        <Style Selector="TextBlock.status-text.muted">
            <Setter Property="Foreground" Value="{DynamicResource TextMuted}" />
        </Style>

        <!-- Badge -->
        <Style Selector="Border.badge">
            <Setter Property="Background" Value="{DynamicResource AccentBrush}" />
            <Setter Property="CornerRadius" Value="8" />
            <Setter Property="MinWidth" Value="16" />
            <Setter Property="Padding" Value="4,0" />
        </Style>

        <!-- Pulse animation -->
        <Style Selector="Border.pulsing">
            <Style.Animations>
                <Animation Duration="0:0:0.5" IterationCount="3">
                    <KeyFrame Cue="0%">
                        <Setter Property="Opacity" Value="1" />
                    </KeyFrame>
                    <KeyFrame Cue="50%">
                        <Setter Property="Opacity" Value="0.5" />
                    </KeyFrame>
                    <KeyFrame Cue="100%">
                        <Setter Property="Opacity" Value="1" />
                    </KeyFrame>
                </Animation>
            </Style.Animations>
        </Style>
    </UserControl.Styles>

    <Border Classes="status-bar">
        <Grid ColumnDefinitions="Auto, *, Auto, Auto, Auto">

            <!-- Left Section: Model Status -->
            <Button Grid.Column="0"
                    Classes="status-button"
                    Command="{Binding ShowModelSettingsCommand}"
                    ToolTip.Tip="{Binding ModelName, StringFormat='Connected to {0}\nClick to configure'}">
                <StackPanel Orientation="Horizontal" Spacing="6">
                    <Ellipse Classes="status-dot"
                             Classes.success="{Binding IsModelConnected}"
                             Classes.warning="{Binding !IsModelConnected}" />
                    <TextBlock Classes="status-text"
                               Text="{Binding ModelDisplayText}" />
                </StackPanel>
            </Button>

            <!-- Center: Spacer -->
            <Border Grid.Column="1" />

            <!-- Right Section: Pending Changes -->
            <Button Grid.Column="2"
                    Classes="status-button"
                    Command="{Binding ShowChangeHistoryCommand}"
                    IsVisible="{Binding HasPendingChanges}"
                    ToolTip.Tip="{Binding PendingChangesTooltip}">
                <Border Classes.pulsing="{Binding HasPendingChanges}">
                    <StackPanel Orientation="Horizontal" Spacing="4">
                        <PathIcon Data="{StaticResource EditIcon}"
                                  Width="12" Height="12"
                                  Foreground="{DynamicResource AccentBrush}" />
                        <TextBlock Classes="status-text"
                                   Text="{Binding PendingChangesText}" />
                    </StackPanel>
                </Border>
            </Button>

            <!-- Right Section: Saved Status -->
            <StackPanel Grid.Column="3"
                        Orientation="Horizontal"
                        Spacing="4"
                        Margin="12,0"
                        VerticalAlignment="Center"
                        ToolTip.Tip="{Binding SavedStatusTooltip}">
                <PathIcon Data="{StaticResource CheckIcon}"
                          Width="12" Height="12"
                          Foreground="{DynamicResource SuccessBrush}"
                          IsVisible="{Binding IsSaved}" />
                <PathIcon Data="{StaticResource WarningIcon}"
                          Width="12" Height="12"
                          Foreground="{DynamicResource WarningBrush}"
                          IsVisible="{Binding !IsSaved}" />
                <TextBlock Classes="status-text"
                           Text="{Binding SavedStatusText}"
                           Classes.muted="{Binding IsSaved}" />
            </StackPanel>

            <!-- Far Right: Temperature -->
            <Button Grid.Column="4"
                    Classes="status-button"
                    Command="{Binding ShowTemperatureSliderCommand}"
                    ToolTip.Tip="{Binding TemperatureTooltip}">
                <TextBlock Classes="status-text muted"
                           Text="{Binding TemperatureDisplay}" />
            </Button>

        </Grid>
    </Border>
</UserControl>
```

#### 4.2 StatusBar Code-Behind

```csharp
// src/SeniorIntern.Desktop/Views/StatusBar.axaml.cs
using Avalonia.Controls;

namespace SeniorIntern.Desktop.Views;

public partial class StatusBar : UserControl
{
    public StatusBar()
    {
        InitializeComponent();
    }
}
```

#### 4.3 PendingChangesIndicator.axaml

```xml
<!-- src/SeniorIntern.Desktop/Views/PendingChangesIndicator.axaml -->
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             xmlns:vm="using:SeniorIntern.Desktop.ViewModels"
             mc:Ignorable="d" d:DesignWidth="150" d:DesignHeight="28"
             x:Class="SeniorIntern.Desktop.Views.PendingChangesIndicator"
             x:DataType="vm:PendingChangesIndicatorViewModel">

    <UserControl.Styles>
        <!-- Container -->
        <Style Selector="Button.indicator-button">
            <Setter Property="Background" Value="Transparent" />
            <Setter Property="BorderThickness" Value="0" />
            <Setter Property="Padding" Value="6,2" />
            <Setter Property="Cursor" Value="Hand" />
            <Setter Property="CornerRadius" Value="3" />
        </Style>

        <Style Selector="Button.indicator-button:pointerover">
            <Setter Property="Background" Value="{DynamicResource StatusBarHover}" />
        </Style>

        <!-- Pulse animation for new changes -->
        <Style Selector="Border.pulse-container.pulsing">
            <Style.Animations>
                <Animation Duration="0:0:0.6" IterationCount="3" Easing="SineEaseInOut">
                    <KeyFrame Cue="0%">
                        <Setter Property="RenderTransform">
                            <ScaleTransform ScaleX="1" ScaleY="1" />
                        </Setter>
                    </KeyFrame>
                    <KeyFrame Cue="50%">
                        <Setter Property="RenderTransform">
                            <ScaleTransform ScaleX="1.1" ScaleY="1.1" />
                        </Setter>
                    </KeyFrame>
                    <KeyFrame Cue="100%">
                        <Setter Property="RenderTransform">
                            <ScaleTransform ScaleX="1" ScaleY="1" />
                        </Setter>
                    </KeyFrame>
                </Animation>
            </Style.Animations>
        </Style>

        <!-- Badge background glow for emphasis -->
        <Style Selector="Border.badge-glow">
            <Setter Property="Background" Value="{DynamicResource AccentBrush}" />
            <Setter Property="CornerRadius" Value="10" />
            <Setter Property="Padding" Value="6,2" />
        </Style>

        <Style Selector="Border.badge-glow.pulsing">
            <Style.Animations>
                <Animation Duration="0:0:0.6" IterationCount="3">
                    <KeyFrame Cue="0%">
                        <Setter Property="BoxShadow" Value="0 0 0 0 #00007ACC" />
                    </KeyFrame>
                    <KeyFrame Cue="50%">
                        <Setter Property="BoxShadow" Value="0 0 8 2 #80007ACC" />
                    </KeyFrame>
                    <KeyFrame Cue="100%">
                        <Setter Property="BoxShadow" Value="0 0 0 0 #00007ACC" />
                    </KeyFrame>
                </Animation>
            </Style.Animations>
        </Style>
    </UserControl.Styles>

    <Button Classes="indicator-button"
            Command="{Binding ClickCommand}"
            IsVisible="{Binding IsVisible}"
            ToolTip.Tip="{Binding Tooltip}">
        <Border Classes="pulse-container"
                Classes.pulsing="{Binding IsPulsing}"
                RenderTransformOrigin="0.5,0.5">
            <StackPanel Orientation="Horizontal" Spacing="6">
                <!-- Icon -->
                <PathIcon Data="{StaticResource EditIcon}"
                          Width="14" Height="14"
                          Foreground="{DynamicResource AccentBrush}" />

                <!-- Count Badge -->
                <Border Classes="badge-glow"
                        Classes.pulsing="{Binding IsPulsing}"
                        IsVisible="{Binding HasBadge}">
                    <TextBlock Text="{Binding ShortDisplayText}"
                               FontSize="11"
                               FontWeight="SemiBold"
                               Foreground="White"
                               HorizontalAlignment="Center" />
                </Border>

                <!-- Text (when not compact) -->
                <TextBlock Text="{Binding DisplayText}"
                           FontSize="12"
                           VerticalAlignment="Center"
                           IsVisible="{Binding !$parent[UserControl].DataContext.IsCompactMode}" />
            </StackPanel>
        </Border>
    </Button>
</UserControl>
```

#### 4.4 PendingChangesIndicator Code-Behind

```csharp
// src/SeniorIntern.Desktop/Views/PendingChangesIndicator.axaml.cs
using Avalonia.Controls;

namespace SeniorIntern.Desktop.Views;

public partial class PendingChangesIndicator : UserControl
{
    public PendingChangesIndicator()
    {
        InitializeComponent();
    }
}
```

#### 4.5 StatusBarItem.axaml (Reusable)

```xml
<!-- src/SeniorIntern.Desktop/Views/StatusBarItem.axaml -->
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             xmlns:vm="using:SeniorIntern.Desktop.ViewModels"
             mc:Ignorable="d" d:DesignWidth="100" d:DesignHeight="24"
             x:Class="SeniorIntern.Desktop.Views.StatusBarItem"
             x:DataType="vm:StatusBarItemViewModel">

    <UserControl.Styles>
        <Style Selector="Button.item-button">
            <Setter Property="Background" Value="Transparent" />
            <Setter Property="BorderThickness" Value="0" />
            <Setter Property="Padding" Value="4,2" />
            <Setter Property="CornerRadius" Value="3" />
            <Setter Property="MinHeight" Value="20" />
        </Style>

        <Style Selector="Button.item-button.clickable">
            <Setter Property="Cursor" Value="Hand" />
        </Style>

        <Style Selector="Button.item-button.clickable:pointerover">
            <Setter Property="Background" Value="{DynamicResource StatusBarHover}" />
        </Style>

        <Style Selector="Button.item-button.clickable:pressed">
            <Setter Property="Background" Value="{DynamicResource StatusBarPressed}" />
        </Style>

        <!-- Non-clickable items just show content -->
        <Style Selector="Border.item-container">
            <Setter Property="Padding" Value="4,2" />
        </Style>
    </UserControl.Styles>

    <Panel IsVisible="{Binding IsVisible}">
        <!-- Clickable version -->
        <Button Classes="item-button clickable"
                Command="{Binding ExecuteCommand}"
                ToolTip.Tip="{Binding Tooltip}"
                IsVisible="{Binding IsClickable}">
            <StackPanel Orientation="Horizontal" Spacing="4">
                <PathIcon Data="{Binding IconKey, Converter={StaticResource IconKeyToGeometryConverter}}"
                          Width="12" Height="12"
                          Foreground="{Binding ColorBrushKey, Converter={StaticResource BrushKeyConverter}}"
                          IsVisible="{Binding HasIcon}" />
                <TextBlock Text="{Binding Text}"
                           FontSize="12"
                           VerticalAlignment="Center"
                           IsVisible="{Binding HasText}" />
                <Border Background="{DynamicResource AccentBrush}"
                        CornerRadius="8"
                        MinWidth="16"
                        Padding="4,0"
                        IsVisible="{Binding HasBadge}">
                    <TextBlock Text="{Binding BadgeCount}"
                               FontSize="10"
                               FontWeight="SemiBold"
                               Foreground="White"
                               HorizontalAlignment="Center" />
                </Border>
            </StackPanel>
        </Button>

        <!-- Non-clickable version -->
        <Border Classes="item-container"
                ToolTip.Tip="{Binding Tooltip}"
                IsVisible="{Binding !IsClickable}">
            <StackPanel Orientation="Horizontal" Spacing="4">
                <PathIcon Data="{Binding IconKey, Converter={StaticResource IconKeyToGeometryConverter}}"
                          Width="12" Height="12"
                          Foreground="{Binding ColorBrushKey, Converter={StaticResource BrushKeyConverter}}"
                          IsVisible="{Binding HasIcon}" />
                <TextBlock Text="{Binding Text}"
                           FontSize="12"
                           Foreground="{DynamicResource TextMuted}"
                           VerticalAlignment="Center"
                           IsVisible="{Binding HasText}" />
            </StackPanel>
        </Border>
    </Panel>
</UserControl>
```

#### 4.6 StatusBarItem Code-Behind

```csharp
// src/SeniorIntern.Desktop/Views/StatusBarItem.axaml.cs
using Avalonia.Controls;

namespace SeniorIntern.Desktop.Views;

public partial class StatusBarItem : UserControl
{
    public StatusBarItem()
    {
        InitializeComponent();
    }
}
```

### 5. Converters

#### 5.1 StatusToColorConverter

```csharp
// src/SeniorIntern.Desktop/Converters/StatusToColorConverter.cs
using System.Globalization;
using Avalonia.Data.Converters;
using Avalonia.Media;
using SeniorIntern.Core.Models;

namespace SeniorIntern.Desktop.Converters;

/// <summary>
/// Converts StatusColor enum to Avalonia brush.
/// </summary>
public class StatusToColorConverter : IValueConverter
{
    public object? Convert(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        if (value is not StatusColor color)
            return null;

        // Return brush key that can be resolved from resources
        return color switch
        {
            StatusColor.Success => "SuccessBrush",
            StatusColor.Warning => "WarningBrush",
            StatusColor.Error => "ErrorBrush",
            StatusColor.Info => "InfoBrush",
            StatusColor.Muted => "MutedBrush",
            _ => "ForegroundBrush"
        };
    }

    public object? ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        throw new NotSupportedException();
    }
}
```

#### 5.2 CountToVisibilityConverter

```csharp
// src/SeniorIntern.Desktop/Converters/CountToVisibilityConverter.cs
using System.Globalization;
using Avalonia.Data.Converters;

namespace SeniorIntern.Desktop.Converters;

/// <summary>
/// Converts a count to visibility (visible if count > 0).
/// </summary>
public class CountToVisibilityConverter : IValueConverter
{
    public object? Convert(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        if (value is int count)
        {
            return count > 0;
        }

        return false;
    }

    public object? ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        throw new NotSupportedException();
    }
}
```

### 6. MainWindow Integration

#### 6.1 MainWindow.axaml Updates

```xml
<!-- Addition to src/SeniorIntern.Desktop/Views/MainWindow.axaml -->
<!-- Replace existing status bar section with: -->

<Window.Styles>
    <!-- Add status bar styles -->
    <Style Selector="views|StatusBar">
        <Setter Property="DockPanel.Dock" Value="Bottom" />
    </Style>
</Window.Styles>

<!-- In the main layout grid -->
<Grid RowDefinitions="Auto, *, Auto">
    <!-- Toolbar -->
    <Border Grid.Row="0" Classes="toolbar">
        <!-- Existing toolbar content -->
    </Border>

    <!-- Main content area -->
    <Grid Grid.Row="1" ColumnDefinitions="Auto, *, Auto">
        <!-- Sidebar -->
        <Border Grid.Column="0" Classes="sidebar">
            <!-- Model selector, change history panel, etc. -->
        </Border>

        <!-- Chat area -->
        <Border Grid.Column="1" Classes="chat-area">
            <!-- Chat content -->
        </Border>

        <!-- Right panel (optional) -->
        <Border Grid.Column="2" Classes="right-panel"
                IsVisible="{Binding IsRightPanelVisible}">
            <!-- Additional panels -->
        </Border>
    </Grid>

    <!-- Status Bar -->
    <views:StatusBar Grid.Row="2"
                     DataContext="{Binding StatusBarViewModel}" />
</Grid>
```

#### 6.2 MainWindowViewModel Updates

```csharp
// src/SeniorIntern.Desktop/ViewModels/MainWindowViewModel.cs (additions)
public partial class MainWindowViewModel : ViewModelBase
{
    // Existing fields...

    [ObservableProperty]
    private StatusBarViewModel _statusBarViewModel;

    [ObservableProperty]
    private bool _isChangeHistoryPanelVisible;

    public MainWindowViewModel(
        // Existing parameters...
        IStatusBarService statusBarService,
        IUndoManager undoManager)
    {
        // Existing initialization...

        // Initialize status bar
        StatusBarViewModel = new StatusBarViewModel(statusBarService, undoManager);
        StatusBarViewModel.ShowChangeHistoryRequested += OnShowChangeHistoryRequested;
        StatusBarViewModel.ShowModelSettingsRequested += OnShowModelSettingsRequested;
        StatusBarViewModel.ShowTemperatureSliderRequested += OnShowTemperatureSliderRequested;
    }

    private void OnShowChangeHistoryRequested(object? sender, EventArgs e)
    {
        // Toggle or show the change history panel
        IsChangeHistoryPanelVisible = !IsChangeHistoryPanelVisible;

        // Or navigate to the panel
        // NavigateToChangeHistory();
    }

    private void OnShowModelSettingsRequested(object? sender, EventArgs e)
    {
        // Open model settings dialog or panel
        // ShowModelSettingsDialog();
    }

    private void OnShowTemperatureSliderRequested(object? sender, EventArgs e)
    {
        // Show temperature adjustment popup
        // ShowTemperaturePopup();
    }

    [RelayCommand]
    private void ToggleChangeHistoryPanel()
    {
        IsChangeHistoryPanelVisible = !IsChangeHistoryPanelVisible;
    }
}
```

### 7. Theme Resources

```xml
<!-- Addition to src/SeniorIntern.Desktop/Themes/StatusBarTheme.axaml -->
<ResourceDictionary xmlns="https://github.com/avaloniaui"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">

    <!-- Light Theme Colors -->
    <Color x:Key="StatusBarBackgroundLight">#F3F3F3</Color>
    <Color x:Key="StatusBarBorderLight">#E0E0E0</Color>
    <Color x:Key="StatusBarHoverLight">#E8E8E8</Color>
    <Color x:Key="StatusBarPressedLight">#D0D0D0</Color>

    <!-- Dark Theme Colors -->
    <Color x:Key="StatusBarBackgroundDark">#252526</Color>
    <Color x:Key="StatusBarBorderDark">#3C3C3C</Color>
    <Color x:Key="StatusBarHoverDark">#3E3E3E</Color>
    <Color x:Key="StatusBarPressedDark">#505050</Color>

    <!-- Status Colors -->
    <Color x:Key="SuccessColor">#4CAF50</Color>
    <Color x:Key="WarningColor">#FF9800</Color>
    <Color x:Key="ErrorColor">#F44336</Color>
    <Color x:Key="InfoColor">#2196F3</Color>
    <Color x:Key="MutedColor">#9E9E9E</Color>

    <!-- Brushes (resolved based on theme) -->
    <SolidColorBrush x:Key="SuccessBrush" Color="{DynamicResource SuccessColor}" />
    <SolidColorBrush x:Key="WarningBrush" Color="{DynamicResource WarningColor}" />
    <SolidColorBrush x:Key="ErrorBrush" Color="{DynamicResource ErrorColor}" />
    <SolidColorBrush x:Key="InfoBrush" Color="{DynamicResource InfoColor}" />
    <SolidColorBrush x:Key="MutedBrush" Color="{DynamicResource MutedColor}" />

    <!-- Icons -->
    <StreamGeometry x:Key="EditIcon">M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z</StreamGeometry>
    <StreamGeometry x:Key="CheckIcon">M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z</StreamGeometry>
    <StreamGeometry x:Key="WarningIcon">M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z</StreamGeometry>
    <StreamGeometry x:Key="CircleIcon">M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2z</StreamGeometry>

</ResourceDictionary>
```

## Unit Tests

### 8.1 StatusBarServiceTests

```csharp
// tests/SeniorIntern.Services.Tests/StatusBarServiceTests.cs
using Moq;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Services;
using Xunit;

namespace SeniorIntern.Services.Tests;

public class StatusBarServiceTests
{
    private readonly Mock<IUndoManager> _undoManagerMock;
    private readonly Mock<ISettingsService> _settingsServiceMock;
    private readonly Mock<IModelService> _modelServiceMock;
    private readonly Mock<IWorkspaceService> _workspaceServiceMock;
    private readonly StatusBarService _service;

    public StatusBarServiceTests()
    {
        _undoManagerMock = new Mock<IUndoManager>();
        _settingsServiceMock = new Mock<ISettingsService>();
        _modelServiceMock = new Mock<IModelService>();
        _workspaceServiceMock = new Mock<IWorkspaceService>();

        _settingsServiceMock.Setup(s => s.GetSettings())
            .Returns(new AppSettings { ModelSettings = new ModelSettings { Temperature = 0.7 } });

        _modelServiceMock.Setup(m => m.GetCurrentModelInfo())
            .Returns(new ModelInfo { Name = "GPT-4", IsConnected = true });

        _undoManagerMock.Setup(u => u.GetUndoableCount()).Returns(0);
        _workspaceServiceMock.Setup(w => w.IsSaved).Returns(true);

        _service = new StatusBarService(
            _undoManagerMock.Object,
            _settingsServiceMock.Object,
            _modelServiceMock.Object,
            _workspaceServiceMock.Object);
    }

    [Fact]
    public void Constructor_InitializesDefaultItems()
    {
        // Assert
        Assert.NotEmpty(_service.Items);
        Assert.Contains(_service.Items, i => i.Id == "model-status");
        Assert.Contains(_service.Items, i => i.Id == "pending-changes");
        Assert.Contains(_service.Items, i => i.Id == "saved-status");
        Assert.Contains(_service.Items, i => i.Id == "temperature");
    }

    [Fact]
    public void GetItemsForSection_ReturnsCorrectItems()
    {
        // Act
        var leftItems = _service.GetItemsForSection(StatusBarSection.Left);
        var rightItems = _service.GetItemsForSection(StatusBarSection.Right);

        // Assert
        Assert.Single(leftItems);
        Assert.Equal("model-status", leftItems[0].Id);
    }

    [Fact]
    public void RegisterItem_AddsNewItem()
    {
        // Arrange
        var newItem = new StatusBarItem(
            Id: "custom-item",
            Section: StatusBarSection.Right,
            Order: 5);

        StatusBarItemChangedEventArgs? eventArgs = null;
        _service.ItemChanged += (_, args) => eventArgs = args;

        // Act
        _service.RegisterItem(newItem);

        // Assert
        Assert.Contains(_service.Items, i => i.Id == "custom-item");
        Assert.NotNull(eventArgs);
        Assert.Equal(StatusBarItemChangeType.Added, eventArgs.ChangeType);
    }

    [Fact]
    public void UnregisterItem_RemovesItem()
    {
        // Arrange
        var customItem = new StatusBarItem("custom", StatusBarSection.Right, 0);
        _service.RegisterItem(customItem);

        StatusBarItemChangedEventArgs? eventArgs = null;
        _service.ItemChanged += (_, args) => eventArgs = args;

        // Act
        _service.UnregisterItem("custom");

        // Assert
        Assert.DoesNotContain(_service.Items, i => i.Id == "custom");
        Assert.NotNull(eventArgs);
        Assert.Equal(StatusBarItemChangeType.Removed, eventArgs.ChangeType);
    }

    [Fact]
    public void SetItemVisibility_UpdatesVisibility()
    {
        // Arrange
        StatusBarItemChangedEventArgs? eventArgs = null;
        _service.ItemChanged += (_, args) => eventArgs = args;

        // Act
        _service.SetItemVisibility("temperature", false);

        // Assert
        var tempItem = _service.Items.First(i => i.Id == "temperature");
        Assert.False(tempItem.IsVisible);
        Assert.NotNull(eventArgs);
        Assert.Equal(StatusBarItemChangeType.VisibilityChanged, eventArgs.ChangeType);
    }

    [Fact]
    public void UpdateConfiguration_UpdatesItemVisibility()
    {
        // Arrange
        var config = new StatusBarConfiguration(
            ShowModelStatus: true,
            ShowPendingChanges: true,
            ShowSavedStatus: false,
            ShowTemperature: false);

        // Act
        _service.UpdateConfiguration(config);

        // Assert
        var savedItem = _service.Items.First(i => i.Id == "saved-status");
        var tempItem = _service.Items.First(i => i.Id == "temperature");
        Assert.False(savedItem.IsVisible);
        Assert.False(tempItem.IsVisible);
    }

    [Fact]
    public void ChangeRecorded_UpdatesPendingCount()
    {
        // Arrange
        _undoManagerMock.Setup(u => u.GetUndoableCount()).Returns(5);

        StatusBarItemChangedEventArgs? eventArgs = null;
        _service.ItemChanged += (_, args) => eventArgs = args;

        // Act
        _undoManagerMock.Raise(u => u.ChangeRecorded += null,
            _undoManagerMock.Object,
            new FileChangeRecord { Id = Guid.NewGuid() });

        // Assert
        Assert.NotNull(eventArgs);
        Assert.Equal("pending-changes", eventArgs.ItemId);
        Assert.Equal(5, eventArgs.NewItem.BadgeCount);
    }

    [Fact]
    public void ModelConnectionChanged_UpdatesModelStatus()
    {
        // Arrange
        StatusBarItemChangedEventArgs? eventArgs = null;
        _service.ItemChanged += (_, args) => eventArgs = args;

        // Act
        _modelServiceMock.Raise(m => m.ConnectionStatusChanged += null,
            _modelServiceMock.Object,
            new ModelConnectionEventArgs { ModelName = "Claude", IsConnected = true });

        // Assert
        Assert.NotNull(eventArgs);
        Assert.Equal("model-status", eventArgs.ItemId);
        Assert.Contains("Claude", eventArgs.NewItem.Text);
    }
}
```

### 8.2 StatusBarViewModelTests

```csharp
// tests/SeniorIntern.Desktop.Tests/ViewModels/StatusBarViewModelTests.cs
using Moq;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Desktop.ViewModels;
using Xunit;

namespace SeniorIntern.Desktop.Tests.ViewModels;

public class StatusBarViewModelTests
{
    private readonly Mock<IStatusBarService> _statusBarServiceMock;
    private readonly Mock<IUndoManager> _undoManagerMock;
    private readonly StatusBarViewModel _viewModel;

    public StatusBarViewModelTests()
    {
        _statusBarServiceMock = new Mock<IStatusBarService>();
        _undoManagerMock = new Mock<IUndoManager>();

        _statusBarServiceMock.Setup(s => s.Items).Returns(new List<StatusBarItem>
        {
            StatusBarItem.ModelStatus("GPT-4", true),
            StatusBarItem.PendingChanges(3),
            StatusBarItem.SavedStatus(true),
            StatusBarItem.Temperature(0.7)
        });

        _statusBarServiceMock.Setup(s => s.Configuration)
            .Returns(StatusBarConfiguration.Default);

        _statusBarServiceMock.Setup(s => s.GetItemsForSection(It.IsAny<StatusBarSection>()))
            .Returns(new List<StatusBarItem>());

        _viewModel = new StatusBarViewModel(
            _statusBarServiceMock.Object,
            _undoManagerMock.Object);
    }

    [Fact]
    public void Constructor_InitializesFromService()
    {
        // Assert
        Assert.Equal(3, _viewModel.PendingChangesCount);
        Assert.Equal("GPT-4", _viewModel.ModelName);
        Assert.True(_viewModel.IsModelConnected);
        Assert.True(_viewModel.IsSaved);
        Assert.Equal(0.7, _viewModel.Temperature);
    }

    [Fact]
    public void PendingChangesText_FormatsCorrectly()
    {
        // Test singular
        _viewModel.PendingChangesCount = 1;
        Assert.Equal("1 pending change", _viewModel.PendingChangesText);

        // Test plural
        _viewModel.PendingChangesCount = 5;
        Assert.Equal("5 pending changes", _viewModel.PendingChangesText);

        // Test zero
        _viewModel.PendingChangesCount = 0;
        Assert.Equal("No pending changes", _viewModel.PendingChangesText);
    }

    [Fact]
    public void HasPendingChanges_ReflectsCount()
    {
        // Zero
        _viewModel.PendingChangesCount = 0;
        Assert.False(_viewModel.HasPendingChanges);

        // Non-zero
        _viewModel.PendingChangesCount = 1;
        Assert.True(_viewModel.HasPendingChanges);
    }

    [Fact]
    public void ModelStatusColor_ReflectsConnection()
    {
        // Connected
        _viewModel.IsModelConnected = true;
        Assert.Equal("Success", _viewModel.ModelStatusColor);

        // Disconnected
        _viewModel.IsModelConnected = false;
        Assert.Equal("Warning", _viewModel.ModelStatusColor);
    }

    [Fact]
    public void TemperatureDisplay_FormatsCorrectly()
    {
        _viewModel.Temperature = 0.75;
        Assert.Equal("T: 0.8", _viewModel.TemperatureDisplay);

        _viewModel.Temperature = 1.0;
        Assert.Equal("T: 1.0", _viewModel.TemperatureDisplay);
    }

    [Fact]
    public void ShowChangeHistoryCommand_RaisesEvent()
    {
        // Arrange
        var eventRaised = false;
        _viewModel.ShowChangeHistoryRequested += (_, _) => eventRaised = true;

        // Act
        _viewModel.ShowChangeHistoryCommand.Execute(null);

        // Assert
        Assert.True(eventRaised);
    }

    [Fact]
    public void ItemChanged_UpdatesCorrectProperty()
    {
        // Arrange - simulate pending changes update
        var oldItem = StatusBarItem.PendingChanges(3);
        var newItem = StatusBarItem.PendingChanges(5);

        var eventArgs = new StatusBarItemChangedEventArgs
        {
            ItemId = "pending-changes",
            OldItem = oldItem,
            NewItem = newItem,
            ChangeType = StatusBarItemChangeType.Updated
        };

        // Act
        _statusBarServiceMock.Raise(s => s.ItemChanged += null,
            _statusBarServiceMock.Object, eventArgs);

        // Assert
        Assert.Equal(5, _viewModel.PendingChangesCount);
    }

    [Fact]
    public void ConfigurationChanged_UpdatesCompactMode()
    {
        // Arrange
        var newConfig = StatusBarConfiguration.Compact;

        _statusBarServiceMock.Setup(s => s.Configuration).Returns(newConfig);

        // Act
        _statusBarServiceMock.Raise(s => s.ConfigurationChanged += null,
            _statusBarServiceMock.Object, newConfig);

        // Assert
        Assert.True(_viewModel.IsCompactMode);
    }
}
```

### 8.3 PendingChangesIndicatorViewModelTests

```csharp
// tests/SeniorIntern.Desktop.Tests/ViewModels/PendingChangesIndicatorViewModelTests.cs
using Moq;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Desktop.ViewModels;
using Xunit;

namespace SeniorIntern.Desktop.Tests.ViewModels;

public class PendingChangesIndicatorViewModelTests
{
    private readonly Mock<IUndoManager> _undoManagerMock;
    private readonly PendingChangesIndicatorViewModel _viewModel;

    public PendingChangesIndicatorViewModelTests()
    {
        _undoManagerMock = new Mock<IUndoManager>();
        _undoManagerMock.Setup(u => u.GetUndoableCount()).Returns(0);

        _viewModel = new PendingChangesIndicatorViewModel(_undoManagerMock.Object);
    }

    [Fact]
    public void Constructor_InitializesWithZeroCount()
    {
        // Assert
        Assert.Equal(0, _viewModel.Count);
        Assert.False(_viewModel.IsVisible);
    }

    [Fact]
    public void DisplayText_FormatsCorrectly()
    {
        // Zero
        _viewModel.Count = 0;
        Assert.Equal(string.Empty, _viewModel.DisplayText);

        // Singular
        _viewModel.Count = 1;
        Assert.Equal("1 pending change", _viewModel.DisplayText);

        // Plural
        _viewModel.Count = 5;
        Assert.Equal("5 pending changes", _viewModel.DisplayText);
    }

    [Fact]
    public void ShortDisplayText_ShowsJustNumber()
    {
        _viewModel.Count = 0;
        Assert.Equal(string.Empty, _viewModel.ShortDisplayText);

        _viewModel.Count = 42;
        Assert.Equal("42", _viewModel.ShortDisplayText);
    }

    [Fact]
    public void IsVisible_TrueWhenCountPositive()
    {
        _viewModel.Count = 0;
        Assert.False(_viewModel.IsVisible);

        _viewModel.Count = 1;
        Assert.True(_viewModel.IsVisible);
    }

    [Fact]
    public void ChangeRecorded_UpdatesCount()
    {
        // Arrange
        _undoManagerMock.Setup(u => u.GetUndoableCount()).Returns(5);

        var record = new FileChangeRecord
        {
            Id = Guid.NewGuid(),
            Timestamp = DateTime.UtcNow
        };

        // Act
        _undoManagerMock.Raise(u => u.ChangeRecorded += null,
            _undoManagerMock.Object, record);

        // Assert
        Assert.Equal(5, _viewModel.Count);
        Assert.True(_viewModel.HasRecentChange);
    }

    [Fact]
    public void ChangeUndone_UpdatesCount()
    {
        // Arrange
        _viewModel.Count = 5;
        _undoManagerMock.Setup(u => u.GetUndoableCount()).Returns(4);

        var record = new FileChangeRecord { Id = Guid.NewGuid() };

        // Act
        _undoManagerMock.Raise(u => u.ChangeUndone += null,
            _undoManagerMock.Object, record);

        // Assert
        Assert.Equal(4, _viewModel.Count);
    }

    [Fact]
    public void ClickCommand_RaisesClickedEvent()
    {
        // Arrange
        var eventRaised = false;
        _viewModel.Clicked += (_, _) => eventRaised = true;

        // Act
        _viewModel.ClickCommand.Execute(null);

        // Assert
        Assert.True(eventRaised);
    }

    [Fact]
    public void Tooltip_DescribesState()
    {
        // Zero
        _viewModel.Count = 0;
        Assert.Equal("No pending changes", _viewModel.Tooltip);

        // Singular
        _viewModel.Count = 1;
        Assert.Contains("1 change can be undone", _viewModel.Tooltip);

        // Plural
        _viewModel.Count = 5;
        Assert.Contains("5 changes can be undone", _viewModel.Tooltip);
    }

    [Fact]
    public void Dispose_UnsubscribesFromEvents()
    {
        // Act
        _viewModel.Dispose();

        // Trigger event after dispose - should not throw or update
        _undoManagerMock.Setup(u => u.GetUndoableCount()).Returns(10);
        _undoManagerMock.Raise(u => u.ChangeRecorded += null,
            _undoManagerMock.Object,
            new FileChangeRecord { Id = Guid.NewGuid() });

        // Assert - count should remain at original value
        Assert.Equal(0, _viewModel.Count);
    }
}
```

## Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Models/StatusBarSection.cs` | Section enum for positioning |
| `src/SeniorIntern.Core/Models/StatusBarItem.cs` | Item record with factory methods |
| `src/SeniorIntern.Core/Models/StatusColor.cs` | Color indicator enum |
| `src/SeniorIntern.Core/Models/StatusBarConfiguration.cs` | Configuration record |
| `src/SeniorIntern.Core/Interfaces/IStatusBarService.cs` | Service interface |
| `src/SeniorIntern.Services/StatusBarService.cs` | Service implementation |
| `src/SeniorIntern.Desktop/ViewModels/StatusBarViewModel.cs` | Main status bar ViewModel |
| `src/SeniorIntern.Desktop/ViewModels/StatusBarItemViewModel.cs` | Item ViewModel |
| `src/SeniorIntern.Desktop/ViewModels/PendingChangesIndicatorViewModel.cs` | Specialized indicator ViewModel |
| `src/SeniorIntern.Desktop/Views/StatusBar.axaml` | Status bar view |
| `src/SeniorIntern.Desktop/Views/StatusBar.axaml.cs` | Code-behind |
| `src/SeniorIntern.Desktop/Views/StatusBarItem.axaml` | Reusable item control |
| `src/SeniorIntern.Desktop/Views/StatusBarItem.axaml.cs` | Code-behind |
| `src/SeniorIntern.Desktop/Views/PendingChangesIndicator.axaml` | Specialized indicator |
| `src/SeniorIntern.Desktop/Views/PendingChangesIndicator.axaml.cs` | Code-behind |
| `src/SeniorIntern.Desktop/Converters/StatusToColorConverter.cs` | Color converter |
| `src/SeniorIntern.Desktop/Converters/CountToVisibilityConverter.cs` | Visibility converter |
| `src/SeniorIntern.Desktop/Themes/StatusBarTheme.axaml` | Theme resources |
| `tests/SeniorIntern.Services.Tests/StatusBarServiceTests.cs` | Service tests |
| `tests/SeniorIntern.Desktop.Tests/ViewModels/StatusBarViewModelTests.cs` | ViewModel tests |
| `tests/SeniorIntern.Desktop.Tests/ViewModels/PendingChangesIndicatorViewModelTests.cs` | Indicator tests |

## Files to Modify

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/Views/MainWindow.axaml` | Add StatusBar to layout |
| `src/SeniorIntern.Desktop/ViewModels/MainWindowViewModel.cs` | Add StatusBarViewModel, wire events |
| `src/SeniorIntern.Desktop/App.axaml` | Register StatusBarTheme resources |
| `src/SeniorIntern.Services/ServiceCollectionExtensions.cs` | Register IStatusBarService |

## Acceptance Criteria

### Functional Requirements

- [ ] Status bar displays at bottom of main window
- [ ] Model status shows connection indicator (green/yellow dot)
- [ ] Model name updates when model changes
- [ ] Pending changes count updates in real-time
- [ ] Clicking pending changes opens change history panel
- [ ] Saved status shows check mark when saved, warning when unsaved
- [ ] Temperature displays with one decimal precision
- [ ] Clicking temperature opens adjustment control

### Visual Requirements

- [ ] Status bar has consistent height (24-28px)
- [ ] Items have proper spacing and alignment
- [ ] Hover states provide visual feedback
- [ ] Pulse animation on new pending changes
- [ ] Colors match application theme
- [ ] Compact mode reduces text, keeps icons

### Performance Requirements

- [ ] Status updates < 16ms for smooth animation
- [ ] No memory leaks from event subscriptions
- [ ] Efficient rendering with minimal repaints

### Accessibility Requirements

- [ ] All items have tooltips
- [ ] Keyboard navigation works
- [ ] Screen reader compatible
- [ ] Sufficient color contrast

## Design Decisions

### 1. Separate Service Layer

**Decision:** Create IStatusBarService to manage status bar state.

**Rationale:**
- Centralizes status aggregation logic
- Enables extensibility for custom items
- Separates concerns from ViewModels
- Facilitates unit testing

### 2. Record-Based Items

**Decision:** Use immutable records for StatusBarItem.

**Rationale:**
- Thread-safe by design
- Simplifies change tracking
- Enables efficient comparison
- Fits reactive update pattern

### 3. Event-Based Updates

**Decision:** Use events for status changes rather than polling.

**Rationale:**
- More efficient than polling
- Immediate UI updates
- Lower CPU usage
- Better battery life on mobile

### 4. Pulse Animation for Attention

**Decision:** Animate pending changes indicator when count increases.

**Rationale:**
- Draws user attention to changes
- Non-intrusive notification
- Familiar UX pattern
- Self-limiting (3 pulses)

### 5. Click-to-Navigate Pattern

**Decision:** Status items are clickable to navigate to related features.

**Rationale:**
- Reduces navigation friction
- Discoverable functionality
- Common desktop pattern
- Efficient workspace usage

## Future Considerations

### Potential Enhancements

1. **Custom Status Items:** Plugin API for extensions to add status items
2. **Status History:** Track status changes over time for debugging
3. **Multi-Window Support:** Synchronize status across windows
4. **Touch-Friendly Mode:** Larger touch targets for tablet use
5. **Notification Badges:** Expandable badge with preview content
6. **Status Presets:** Quick-switch between different status configurations
7. **Progress Indicators:** Show ongoing operation progress in status bar

### Technical Debt

- Consider using reactive extensions for cleaner event composition
- Evaluate ObservableCollection vs. INotifyCollectionChanged for items
- Profile animation performance on lower-end hardware

## Dependencies

### Internal Dependencies

- v0.4.3d: IUndoManager for pending changes tracking
- v0.4.5h: Change History Panel for navigation target
- v0.4.1a: Core models and interfaces

### External Dependencies

- Avalonia 11.x for UI framework
- CommunityToolkit.Mvvm for MVVM patterns
- System.Timers for pulse animation timing

## References

- [v0.4.5 Polish & Integration](v0.4.5-polish-integration.md)
- [v0.4.3d Undo System](v0.4.3d-undo-system.md)
- [v0.4.5h Change History Panel](v0.4.5h-change-history-panel.md)
- [Avalonia Styling](https://docs.avaloniaui.net/docs/styling)
- [CommunityToolkit.Mvvm](https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/)
