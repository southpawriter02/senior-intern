# v0.4.4b: File Tree Parser - Design Specification

**Status**: _IMPLEMENTED_

## Executive Summary

This specification details the **File Tree Parser** for The Senior Intern's Multi-File Creation system. The parser is responsible for detecting and extracting multi-file proposals from LLM responses, including parsing ASCII tree structures, correlating code blocks with file paths, finding common root directories, and extracting contextual descriptions. This component bridges the gap between raw LLM output and the structured `FileTreeProposal` model.

### Key Deliverables

| Component | Type | Purpose |
|-----------|------|---------|
| `IFileTreeParser` | Interface | Contract for parsing LLM responses |
| `FileTreeParser` | Class | Implementation with regex-based parsing |
| `TreeParseResult` | Record | Intermediate result from tree parsing |
| `ParsedTreeNode` | Class | Node in parsed tree structure |
| `FileTreeParserOptions` | Record | Configuration for parser behavior |

---

## Feature Overview

```
v0.4.4b: File Tree Parser
├── IFileTreeParser Interface
│   ├── ParseProposal(content, messageId, codeBlocks)
│   ├── ContainsFileTree(content)
│   ├── ParseAsciiTree(treeContent)
│   ├── ExtractDescription(content)
│   └── TryParseProposal (out pattern)
├── FileTreeParser Implementation
│   ├── Regex Patterns (source-generated)
│   │   ├── TreeBlockPattern (fenced code blocks)
│   │   ├── TreeLinePattern (├└│── characters)
│   │   ├── SimpleListingPattern (indented paths)
│   │   ├── InlineTreePattern (single-line trees)
│   │   └── PathCommentPattern (# comments)
│   ├── Structure Indicators
│   │   ├── "project structure"
│   │   ├── "file structure"
│   │   ├── "folder structure"
│   │   ├── "directory structure"
│   │   ├── "create these files"
│   │   └── (configurable list)
│   ├── Tree Parsing Logic
│   │   ├── CalculateDepth (indentation)
│   │   ├── BuildPathStack (parent tracking)
│   │   ├── ResolveFullPath (stack to path)
│   │   └── FilterDirectories (exclude folders)
│   ├── Path Analysis
│   │   ├── FindCommonRoot (LCP algorithm)
│   │   ├── NormalizePath (forward slashes)
│   │   └── ValidatePath (basic checks)
│   └── Description Extraction
│       ├── FindIndicatorContext
│       ├── CleanMarkdownFormatting
│       └── TruncateDescription
├── TreeParseResult
│   ├── Paths (extracted file paths)
│   ├── RawTreeText (original text)
│   ├── TreeFormat (detected format)
│   └── RootDirectory (if detected)
├── ParsedTreeNode
│   ├── Name (file/folder name)
│   ├── FullPath (complete path)
│   ├── IsDirectory (ends with /)
│   ├── Depth (nesting level)
│   ├── Children (nested nodes)
│   └── Comment (inline comment)
├── FileTreeParserOptions
│   ├── MinimumFilesForProposal (default: 2)
│   ├── MaxTreeDepth (default: 20)
│   ├── StructureIndicators (customizable)
│   ├── EnableSimpleListing (default: true)
│   └── TrimComments (default: true)
└── Integration Points
    ├── CodeBlockExtractionService (v0.4.1)
    ├── ILanguageDetectionService (language hints)
    └── FileTreeProposal (v0.4.4a output)
```

---

## Architecture Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           LLM Response Content                               │
│  "Here's the project structure:                                             │
│   ```                                                                       │
│   src/                                                                      │
│   ├── Models/                                                               │
│   │   └── User.cs                                                          │
│   └── Services/                                                             │
│       └── UserService.cs                                                    │
│   ```                                                                       │
│   Here's the implementation:                                                │
│   ```csharp                                                                 │
│   // src/Models/User.cs                                                     │
│   public class User { }                                                     │
│   ```"                                                                      │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                            FileTreeParser                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────────────┐  ┌─────────────────────┐  ┌─────────────────────┐  │
│  │  ContainsFileTree   │  │   ParseAsciiTree    │  │ ExtractDescription  │  │
│  │                     │  │                     │  │                     │  │
│  │ • Check indicators  │  │ • Line-by-line      │  │ • Find indicator    │  │
│  │ • Match tree block  │  │ • Calculate depth   │  │ • Extract context   │  │
│  │ • Return bool       │  │ • Build path stack  │  │ • Clean markdown    │  │
│  └─────────────────────┘  │ • Filter dirs       │  └─────────────────────┘  │
│            │              └─────────────────────┘             │              │
│            │                        │                         │              │
│            ▼                        ▼                         ▼              │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │                          ParseProposal                                 │  │
│  │                                                                       │  │
│  │  1. Filter code blocks with paths                                     │  │
│  │  2. Require minimum 2 blocks                                          │  │
│  │  3. Check for ASCII tree                                              │  │
│  │  4. Parse tree if present                                             │  │
│  │  5. Create FileOperation from each block                              │  │
│  │  6. Find common root path                                             │  │
│  │  7. Extract description                                               │  │
│  │  8. Build FileTreeProposal                                            │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                    │                                         │
└────────────────────────────────────┼─────────────────────────────────────────┘
                                     │
                                     ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                           FileTreeProposal                                   │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────────────────────┐  │
│  │     Id      │  │  MessageId  │  │  Operations: List<FileOperation>   │  │
│  └─────────────┘  └─────────────┘  │  ┌───────────────────────────────┐ │  │
│  ┌─────────────┐  ┌─────────────┐  │  │ Path: src/Models/User.cs      │ │  │
│  │  RootPath   │  │ Description │  │  │ Type: Create                  │ │  │
│  │   "src"     │  │ "Project    │  │  │ Content: "public class..."    │ │  │
│  └─────────────┘  │  structure" │  │  └───────────────────────────────┘ │  │
│                   └─────────────┘  │  ┌───────────────────────────────┐ │  │
│  ┌─────────────────────────────┐   │  │ Path: src/Services/...        │ │  │
│  │ RawTreeText: "src/\n├──..." │   │  │ ...                           │ │  │
│  └─────────────────────────────┘   │  └───────────────────────────────┘ │  │
│                                    └─────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Tree Parsing Flow Diagram

```
                    ASCII Tree Input
                          │
    "src/                 │
    ├── Models/           │
    │   ├── User.cs       │
    │   └── Product.cs    │
    └── Services/         │
        └── UserService.cs"
                          │
                          ▼
              ┌───────────────────────┐
              │   Split into Lines    │
              └───────────────────────┘
                          │
                          ▼
         ┌────────────────────────────────┐
         │  For Each Line:                │
         │  1. Match pattern              │
         │  2. Extract name               │
         │  3. Calculate depth            │
         └────────────────────────────────┘
                          │
    ┌─────────────────────┼─────────────────────┐
    ▼                     ▼                     ▼
┌────────┐          ┌────────┐           ┌────────┐
│Line 1  │          │Line 2  │           │Line N  │
│"src/"  │          │"├──    │           │"└──    │
│Depth:0 │          │Models/"│           │User... │
│IsDir:Y │          │Depth:1 │           │Depth:2 │
└────────┘          │IsDir:Y │           │IsDir:N │
    │               └────────┘           └────────┘
    │                    │                    │
    ▼                    ▼                    ▼
┌───────────────────────────────────────────────────┐
│              Path Stack Management                 │
│                                                   │
│  Stack: []              → Push("src")             │
│  Stack: ["src"]         → Push("Models")          │
│  Stack: ["src","Models"]→ Push("User.cs")         │
│                                                   │
│  On depth decrease: Pop until matching depth      │
└───────────────────────────────────────────────────┘
                          │
                          ▼
              ┌───────────────────────┐
              │   Build Full Paths    │
              │                       │
              │ "src/Models/User.cs"  │
              │ "src/Models/Product.cs│
              │ "src/Services/..."    │
              └───────────────────────┘
                          │
                          ▼
              ┌───────────────────────┐
              │ Filter: Remove dirs   │
              │ (paths ending in /)   │
              └───────────────────────┘
                          │
                          ▼
              ┌───────────────────────┐
              │    Return Paths       │
              │   [file1, file2, ...]│
              └───────────────────────┘
```

---

## Common Root Path Algorithm

```
Input Paths:
  "src/Models/User.cs"
  "src/Models/Product.cs"
  "src/Services/UserService.cs"
  "src/Program.cs"

Step 1: Split into segments
  ["src", "Models", "User.cs"]
  ["src", "Models", "Product.cs"]
  ["src", "Services", "UserService.cs"]
  ["src", "Program.cs"]

Step 2: Find minimum length (excluding filename)
  min = 1 (for "src/Program.cs")

Step 3: Compare segments at each position
  Position 0: "src" == "src" == "src" == "src" ✓
  Position 1: "Models" != "Services" != "Program.cs" ✗

Step 4: Stop at first mismatch
  Common segments: ["src"]

Step 5: Join result
  Common root: "src"

Special Cases:
  - Empty list → ""
  - Single file → parent directory
  - No common prefix → ""
  - All same directory → that directory
```

---

## Detailed Design

### 1. IFileTreeParser Interface

```csharp
// src/SeniorIntern.Core/Interfaces/IFileTreeParser.cs
namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Parser for detecting and extracting multi-file proposals from LLM responses.
/// </summary>
/// <remarks>
/// The parser analyzes LLM response content to identify:
/// 1. ASCII file tree structures (├└│── format)
/// 2. Multiple code blocks with file path annotations
/// 3. Contextual descriptions about the proposed structure
/// </remarks>
public interface IFileTreeParser
{
    /// <summary>
    /// Parse a message to detect and extract multi-file proposals.
    /// </summary>
    /// <param name="content">The full message content from the LLM.</param>
    /// <param name="messageId">ID of the source message for linking.</param>
    /// <param name="codeBlocks">Pre-extracted code blocks from the message.</param>
    /// <returns>
    /// A FileTreeProposal if multi-file proposal detected (2+ files), null otherwise.
    /// </returns>
    /// <remarks>
    /// Detection requires at least 2 code blocks with TargetFilePath set.
    /// The parser correlates ASCII trees with code blocks when present.
    /// </remarks>
    FileTreeProposal? ParseProposal(
        string content,
        Guid messageId,
        IReadOnlyList<CodeBlock> codeBlocks);

    /// <summary>
    /// Try to parse a proposal with detailed result information.
    /// </summary>
    /// <param name="content">The full message content.</param>
    /// <param name="messageId">ID of the source message.</param>
    /// <param name="codeBlocks">Pre-extracted code blocks.</param>
    /// <param name="proposal">The parsed proposal if successful.</param>
    /// <param name="reason">Reason for failure if unsuccessful.</param>
    /// <returns>True if a valid proposal was parsed.</returns>
    bool TryParseProposal(
        string content,
        Guid messageId,
        IReadOnlyList<CodeBlock> codeBlocks,
        out FileTreeProposal? proposal,
        out string? reason);

    /// <summary>
    /// Detect if content contains a file tree structure.
    /// </summary>
    /// <param name="content">The content to analyze.</param>
    /// <returns>True if an ASCII file tree is detected.</returns>
    /// <remarks>
    /// Checks for both structure indicator phrases and tree-like patterns.
    /// Does not validate the tree structure itself.
    /// </remarks>
    bool ContainsFileTree(string content);

    /// <summary>
    /// Parse an ASCII file tree into a list of file paths.
    /// </summary>
    /// <param name="treeContent">The tree content (without code fences).</param>
    /// <returns>List of file paths extracted from the tree.</returns>
    /// <remarks>
    /// Handles multiple tree formats:
    /// - Standard: ├── └── │
    /// - Simple: indented paths
    /// - Mixed: combination of both
    /// Directories (ending in /) are excluded from the result.
    /// </remarks>
    IReadOnlyList<string> ParseAsciiTree(string treeContent);

    /// <summary>
    /// Parse an ASCII tree into a structured node tree.
    /// </summary>
    /// <param name="treeContent">The tree content.</param>
    /// <returns>Root node of the parsed tree structure.</returns>
    ParsedTreeNode? ParseAsciiTreeStructured(string treeContent);

    /// <summary>
    /// Extract description from surrounding text.
    /// </summary>
    /// <param name="content">The full message content.</param>
    /// <returns>
    /// Extracted description near structure indicators, or null if not found.
    /// </returns>
    /// <remarks>
    /// Looks for text near phrases like "project structure" or "files to create".
    /// Cleans markdown formatting from the extracted text.
    /// </remarks>
    string? ExtractDescription(string content);

    /// <summary>
    /// Find the common root path from a collection of paths.
    /// </summary>
    /// <param name="paths">Collection of file paths.</param>
    /// <returns>Common root directory, or empty string if none.</returns>
    string FindCommonRoot(IEnumerable<string> paths);

    /// <summary>
    /// Validate that a path is suitable for file operations.
    /// </summary>
    /// <param name="path">The path to validate.</param>
    /// <returns>True if the path is valid for use.</returns>
    bool IsValidPath(string path);
}
```

### 2. Supporting Types

```csharp
// src/SeniorIntern.Core/Models/TreeParseResult.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Result of parsing an ASCII tree structure.
/// </summary>
public sealed record TreeParseResult
{
    /// <summary>
    /// Extracted file paths (directories excluded).
    /// </summary>
    public IReadOnlyList<string> Paths { get; init; } = Array.Empty<string>();

    /// <summary>
    /// All paths including directories.
    /// </summary>
    public IReadOnlyList<string> AllPaths { get; init; } = Array.Empty<string>();

    /// <summary>
    /// Directory paths only.
    /// </summary>
    public IReadOnlyList<string> Directories { get; init; } = Array.Empty<string>();

    /// <summary>
    /// The original raw tree text.
    /// </summary>
    public string RawTreeText { get; init; } = string.Empty;

    /// <summary>
    /// Detected tree format.
    /// </summary>
    public TreeFormat Format { get; init; }

    /// <summary>
    /// Root directory if detected from the tree.
    /// </summary>
    public string? RootDirectory { get; init; }

    /// <summary>
    /// Maximum depth of nesting in the tree.
    /// </summary>
    public int MaxDepth { get; init; }

    /// <summary>
    /// Any comments extracted from the tree.
    /// </summary>
    public IReadOnlyDictionary<string, string> Comments { get; init; } =
        new Dictionary<string, string>();

    /// <summary>
    /// Whether parsing was successful.
    /// </summary>
    public bool Success => Paths.Count > 0;

    /// <summary>
    /// Error message if parsing failed.
    /// </summary>
    public string? ErrorMessage { get; init; }
}

/// <summary>
/// Format of the ASCII tree structure.
/// </summary>
public enum TreeFormat
{
    /// <summary>
    /// Standard Unicode box-drawing characters (├└│──).
    /// </summary>
    Standard,

    /// <summary>
    /// ASCII-only characters (+|`-).
    /// </summary>
    AsciiOnly,

    /// <summary>
    /// Simple indented listing.
    /// </summary>
    Indented,

    /// <summary>
    /// Mixed format (combination of styles).
    /// </summary>
    Mixed,

    /// <summary>
    /// Unknown or unrecognized format.
    /// </summary>
    Unknown
}

// src/SeniorIntern.Core/Models/ParsedTreeNode.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// A node in a parsed tree structure.
/// </summary>
public sealed class ParsedTreeNode
{
    /// <summary>
    /// Name of the file or directory.
    /// </summary>
    public string Name { get; init; } = string.Empty;

    /// <summary>
    /// Full path from root.
    /// </summary>
    public string FullPath { get; init; } = string.Empty;

    /// <summary>
    /// Whether this is a directory (ends with /).
    /// </summary>
    public bool IsDirectory { get; init; }

    /// <summary>
    /// Nesting depth (0 = root).
    /// </summary>
    public int Depth { get; init; }

    /// <summary>
    /// Child nodes (for directories).
    /// </summary>
    public List<ParsedTreeNode> Children { get; init; } = new();

    /// <summary>
    /// Parent node reference.
    /// </summary>
    public ParsedTreeNode? Parent { get; set; }

    /// <summary>
    /// Inline comment if present (e.g., "# main entry point").
    /// </summary>
    public string? Comment { get; init; }

    /// <summary>
    /// The original line from the tree.
    /// </summary>
    public string? OriginalLine { get; init; }

    /// <summary>
    /// File extension (empty for directories).
    /// </summary>
    public string Extension => IsDirectory
        ? string.Empty
        : Path.GetExtension(Name);

    /// <summary>
    /// Whether this node has children.
    /// </summary>
    public bool HasChildren => Children.Count > 0;

    /// <summary>
    /// Get all descendant file paths.
    /// </summary>
    public IEnumerable<string> GetAllFilePaths()
    {
        if (!IsDirectory)
        {
            yield return FullPath;
        }

        foreach (var child in Children)
        {
            foreach (var path in child.GetAllFilePaths())
            {
                yield return path;
            }
        }
    }

    /// <summary>
    /// Get all descendant directory paths.
    /// </summary>
    public IEnumerable<string> GetAllDirectoryPaths()
    {
        if (IsDirectory && !string.IsNullOrEmpty(FullPath))
        {
            yield return FullPath;
        }

        foreach (var child in Children)
        {
            foreach (var path in child.GetAllDirectoryPaths())
            {
                yield return path;
            }
        }
    }
}

// src/SeniorIntern.Core/Models/FileTreeParserOptions.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Configuration options for the file tree parser.
/// </summary>
public sealed record FileTreeParserOptions
{
    /// <summary>
    /// Minimum number of files required to create a proposal.
    /// </summary>
    /// <remarks>
    /// A single file doesn't constitute a "multi-file" proposal.
    /// Default is 2.
    /// </remarks>
    public int MinimumFilesForProposal { get; init; } = 2;

    /// <summary>
    /// Maximum tree depth to parse.
    /// </summary>
    /// <remarks>
    /// Prevents stack overflow on malformed input.
    /// Default is 20.
    /// </remarks>
    public int MaxTreeDepth { get; init; } = 20;

    /// <summary>
    /// Maximum number of files to include in a proposal.
    /// </summary>
    /// <remarks>
    /// Very large proposals may be impractical.
    /// Default is 100.
    /// </remarks>
    public int MaxFilesInProposal { get; init; } = 100;

    /// <summary>
    /// Phrases that indicate a file structure follows.
    /// </summary>
    public IReadOnlyList<string> StructureIndicators { get; init; } = new[]
    {
        "project structure",
        "file structure",
        "folder structure",
        "directory structure",
        "here's the structure",
        "create these files",
        "create the following",
        "files to create",
        "following files",
        "file layout"
    };

    /// <summary>
    /// Whether to enable simple indented listing parsing.
    /// </summary>
    public bool EnableSimpleListing { get; init; } = true;

    /// <summary>
    /// Whether to trim inline comments from paths.
    /// </summary>
    public bool TrimComments { get; init; } = true;

    /// <summary>
    /// Whether to preserve the raw tree text in the proposal.
    /// </summary>
    public bool PreserveRawTreeText { get; init; } = true;

    /// <summary>
    /// Maximum description length to extract.
    /// </summary>
    public int MaxDescriptionLength { get; init; } = 200;

    /// <summary>
    /// Minimum description length to accept.
    /// </summary>
    public int MinDescriptionLength { get; init; } = 10;

    /// <summary>
    /// Whether to require structure indicators for tree detection.
    /// </summary>
    public bool RequireStructureIndicator { get; init; } = true;

    /// <summary>
    /// Code block types to include in proposals.
    /// </summary>
    public IReadOnlyList<CodeBlockType> IncludedBlockTypes { get; init; } = new[]
    {
        CodeBlockType.CompleteFile,
        CodeBlockType.Snippet
    };

    /// <summary>
    /// Default options.
    /// </summary>
    public static FileTreeParserOptions Default { get; } = new();

    /// <summary>
    /// Lenient options (fewer restrictions).
    /// </summary>
    public static FileTreeParserOptions Lenient { get; } = new()
    {
        MinimumFilesForProposal = 1,
        RequireStructureIndicator = false,
        MaxFilesInProposal = 500
    };
}
```

### 3. FileTreeParser Implementation

```csharp
// src/SeniorIntern.Services/FileTreeParser.cs
namespace SeniorIntern.Services;

using System.Text.RegularExpressions;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;

/// <summary>
/// Parses LLM responses to detect and extract multi-file proposals.
/// </summary>
/// <remarks>
/// Uses source-generated regex for performance.
/// Handles multiple tree formats and edge cases.
/// </remarks>
public sealed partial class FileTreeParser : IFileTreeParser
{
    private readonly ILanguageDetectionService _languageService;
    private readonly FileTreeParserOptions _options;
    private readonly ILogger<FileTreeParser>? _logger;

    #region Regex Patterns (Source-Generated)

    /// <summary>
    /// Pattern for fenced code blocks containing tree structures.
    /// Matches: ```text, ```tree, ```plaintext, or just ```
    /// </summary>
    [GeneratedRegex(
        @"```(?:text|tree|plaintext|ascii|structure)?\s*\n((?:[\s│├└┬┼─|+`\-\\]+[\w\.\-/@]+/?(?:\s*#[^\n]*)?\n?)+)```",
        RegexOptions.Compiled | RegexOptions.Multiline | RegexOptions.IgnoreCase)]
    private static partial Regex TreeBlockPattern();

    /// <summary>
    /// Pattern for standard tree lines with Unicode box-drawing.
    /// Matches: ├── filename.ext or └── filename.ext
    /// </summary>
    [GeneratedRegex(
        @"^[\s│]*[├└](?:──|─)\s*(.+?)(?:\s*#.*)?$",
        RegexOptions.Compiled | RegexOptions.Multiline)]
    private static partial Regex TreeLinePattern();

    /// <summary>
    /// Pattern for ASCII-only tree lines.
    /// Matches: +-- filename.ext or `-- filename.ext
    /// </summary>
    [GeneratedRegex(
        @"^[\s|]*[+`](?:--|-)\s*(.+?)(?:\s*#.*)?$",
        RegexOptions.Compiled | RegexOptions.Multiline)]
    private static partial Regex AsciiTreeLinePattern();

    /// <summary>
    /// Pattern for simple indented directory listing.
    /// Matches: indented paths like "  Models/User.cs"
    /// </summary>
    [GeneratedRegex(
        @"^(\s*)([a-zA-Z_][\w\-\.]*(?:/[\w\-\.]+)*/?)$",
        RegexOptions.Compiled | RegexOptions.Multiline)]
    private static partial Regex SimpleListingPattern();

    /// <summary>
    /// Pattern for root directory line.
    /// Matches: "src/" or "project-name/" at the start
    /// </summary>
    [GeneratedRegex(
        @"^([a-zA-Z_][\w\-\.]*)/?\s*$",
        RegexOptions.Compiled)]
    private static partial Regex RootDirectoryPattern();

    /// <summary>
    /// Pattern for inline comments.
    /// Matches: # comment at end of line
    /// </summary>
    [GeneratedRegex(
        @"\s*#\s*(.+)$",
        RegexOptions.Compiled)]
    private static partial Regex InlineCommentPattern();

    /// <summary>
    /// Pattern for markdown formatting to remove.
    /// </summary>
    [GeneratedRegex(
        @"^#+\s*|[*_`\[\]]",
        RegexOptions.Compiled)]
    private static partial Regex MarkdownFormattingPattern();

    /// <summary>
    /// Pattern for path validation (valid characters).
    /// </summary>
    [GeneratedRegex(
        @"^[\w\-\./\\@]+$",
        RegexOptions.Compiled)]
    private static partial Regex ValidPathPattern();

    #endregion

    #region Constructor

    public FileTreeParser(
        ILanguageDetectionService languageService,
        FileTreeParserOptions? options = null,
        ILogger<FileTreeParser>? logger = null)
    {
        _languageService = languageService ?? throw new ArgumentNullException(nameof(languageService));
        _options = options ?? FileTreeParserOptions.Default;
        _logger = logger;
    }

    #endregion

    #region IFileTreeParser Implementation

    public FileTreeProposal? ParseProposal(
        string content,
        Guid messageId,
        IReadOnlyList<CodeBlock> codeBlocks)
    {
        TryParseProposal(content, messageId, codeBlocks, out var proposal, out _);
        return proposal;
    }

    public bool TryParseProposal(
        string content,
        Guid messageId,
        IReadOnlyList<CodeBlock> codeBlocks,
        out FileTreeProposal? proposal,
        out string? reason)
    {
        proposal = null;
        reason = null;

        if (string.IsNullOrWhiteSpace(content))
        {
            reason = "Content is empty";
            return false;
        }

        if (codeBlocks == null || codeBlocks.Count == 0)
        {
            reason = "No code blocks provided";
            return false;
        }

        // Filter to code blocks with file paths
        var blocksWithPaths = codeBlocks
            .Where(b => !string.IsNullOrEmpty(b.TargetFilePath))
            .Where(b => _options.IncludedBlockTypes.Contains(b.BlockType))
            .ToList();

        if (blocksWithPaths.Count < _options.MinimumFilesForProposal)
        {
            reason = $"Only {blocksWithPaths.Count} code blocks with paths found " +
                     $"(minimum: {_options.MinimumFilesForProposal})";
            _logger?.LogDebug("Proposal rejected: {Reason}", reason);
            return false;
        }

        if (blocksWithPaths.Count > _options.MaxFilesInProposal)
        {
            reason = $"Too many files ({blocksWithPaths.Count}) exceeds maximum " +
                     $"({_options.MaxFilesInProposal})";
            _logger?.LogWarning("Proposal rejected: {Reason}", reason);
            return false;
        }

        // Check for explicit ASCII file tree
        string? rawTreeText = null;
        var treePaths = new List<string>();

        if (ContainsFileTree(content))
        {
            var treeMatch = TreeBlockPattern().Match(content);
            if (treeMatch.Success)
            {
                rawTreeText = treeMatch.Groups[1].Value;
                treePaths = ParseAsciiTree(rawTreeText).ToList();

                _logger?.LogDebug(
                    "Parsed ASCII tree with {PathCount} paths",
                    treePaths.Count);
            }
        }

        // Build operations from code blocks
        var operations = new List<FileOperation>();
        int order = 0;

        foreach (var block in blocksWithPaths)
        {
            var operation = FileOperation.FromCodeBlock(block, order++);

            // Validate path
            if (!IsValidPath(operation.Path))
            {
                _logger?.LogWarning(
                    "Skipping invalid path: {Path}",
                    operation.Path);
                continue;
            }

            operations.Add(operation);
        }

        if (operations.Count < _options.MinimumFilesForProposal)
        {
            reason = $"Only {operations.Count} valid operations after filtering";
            return false;
        }

        // Find common root path
        var rootPath = FindCommonRoot(operations.Select(o => o.Path));

        // Extract description
        var description = ExtractDescription(content);

        proposal = new FileTreeProposal
        {
            MessageId = messageId,
            RootPath = rootPath,
            Operations = operations,
            Description = description,
            RawTreeText = _options.PreserveRawTreeText ? rawTreeText : null
        };

        _logger?.LogInformation(
            "Created proposal with {FileCount} files in root '{Root}'",
            operations.Count,
            rootPath);

        return true;
    }

    public bool ContainsFileTree(string content)
    {
        if (string.IsNullOrWhiteSpace(content))
            return false;

        var lowerContent = content.ToLowerInvariant();

        // Check for structure indicators if required
        if (_options.RequireStructureIndicator)
        {
            var hasIndicator = _options.StructureIndicators
                .Any(ind => lowerContent.Contains(ind.ToLowerInvariant()));

            if (!hasIndicator)
                return false;
        }

        // Check for tree block pattern
        return TreeBlockPattern().IsMatch(content);
    }

    public IReadOnlyList<string> ParseAsciiTree(string treeContent)
    {
        if (string.IsNullOrWhiteSpace(treeContent))
            return Array.Empty<string>();

        var paths = new List<string>();
        var lines = treeContent.Split('\n', StringSplitOptions.RemoveEmptyEntries);
        var pathStack = new Stack<(int Depth, string Name, bool IsDir)>();

        foreach (var line in lines)
        {
            var parseResult = ParseTreeLine(line);
            if (parseResult == null)
                continue;

            var (name, depth, isDirectory, comment) = parseResult.Value;

            // Enforce max depth
            if (depth > _options.MaxTreeDepth)
            {
                _logger?.LogWarning(
                    "Tree depth {Depth} exceeds maximum {Max}",
                    depth,
                    _options.MaxTreeDepth);
                continue;
            }

            // Pop items from stack until we're at the right level
            while (pathStack.Count > 0 && pathStack.Peek().Depth >= depth)
            {
                pathStack.Pop();
            }

            // Handle root directory specially
            if (depth == 0 && isDirectory && pathStack.Count == 0)
            {
                pathStack.Push((depth, name.TrimEnd('/'), true));
                continue;
            }

            pathStack.Push((depth, name.TrimEnd('/'), isDirectory));

            // Build full path from stack
            var pathParts = pathStack.Reverse().Select(p => p.Name).ToList();
            var fullPath = string.Join("/", pathParts);

            // Only add files (not directories)
            if (!isDirectory)
            {
                paths.Add(NormalizePath(fullPath));
            }
        }

        return paths;
    }

    public ParsedTreeNode? ParseAsciiTreeStructured(string treeContent)
    {
        if (string.IsNullOrWhiteSpace(treeContent))
            return null;

        var root = new ParsedTreeNode
        {
            Name = "",
            FullPath = "",
            IsDirectory = true,
            Depth = -1
        };

        var lines = treeContent.Split('\n', StringSplitOptions.RemoveEmptyEntries);
        var nodeStack = new Stack<ParsedTreeNode>();
        nodeStack.Push(root);

        foreach (var line in lines)
        {
            var parseResult = ParseTreeLine(line);
            if (parseResult == null)
                continue;

            var (name, depth, isDirectory, comment) = parseResult.Value;

            // Pop until we find the parent
            while (nodeStack.Count > 1 && nodeStack.Peek().Depth >= depth)
            {
                nodeStack.Pop();
            }

            var parent = nodeStack.Peek();

            // Build full path
            var fullPath = string.IsNullOrEmpty(parent.FullPath)
                ? name.TrimEnd('/')
                : $"{parent.FullPath}/{name.TrimEnd('/')}";

            var node = new ParsedTreeNode
            {
                Name = name.TrimEnd('/'),
                FullPath = fullPath,
                IsDirectory = isDirectory,
                Depth = depth,
                Parent = parent,
                Comment = comment,
                OriginalLine = line
            };

            parent.Children.Add(node);

            if (isDirectory)
            {
                nodeStack.Push(node);
            }
        }

        return root;
    }

    public string? ExtractDescription(string content)
    {
        if (string.IsNullOrWhiteSpace(content))
            return null;

        var lowerContent = content.ToLowerInvariant();

        // Find the best matching indicator
        foreach (var indicator in _options.StructureIndicators)
        {
            var index = lowerContent.IndexOf(indicator.ToLowerInvariant());
            if (index < 0)
                continue;

            // Get the line containing the indicator
            var lineStart = content.LastIndexOf('\n', Math.Max(0, index - 1)) + 1;
            var lineEnd = content.IndexOf('\n', index);
            if (lineEnd < 0)
                lineEnd = content.Length;

            var line = content[lineStart..lineEnd].Trim();

            // Clean markdown formatting
            line = MarkdownFormattingPattern().Replace(line, "").Trim();

            // Validate length
            if (line.Length >= _options.MinDescriptionLength &&
                line.Length <= _options.MaxDescriptionLength)
            {
                return line;
            }

            // Try to truncate if too long
            if (line.Length > _options.MaxDescriptionLength)
            {
                var truncated = line[..(_options.MaxDescriptionLength - 3)] + "...";
                return truncated;
            }
        }

        return null;
    }

    public string FindCommonRoot(IEnumerable<string> paths)
    {
        var pathList = paths.Select(NormalizePath).ToList();

        if (pathList.Count == 0)
            return string.Empty;

        if (pathList.Count == 1)
        {
            var dir = Path.GetDirectoryName(pathList[0]);
            return dir?.Replace('\\', '/') ?? string.Empty;
        }

        // Split all paths into segments
        var segments = pathList
            .Select(p => p.Split('/'))
            .ToList();

        // Find minimum length (excluding the filename)
        var minLength = segments.Min(s => s.Length);
        var commonParts = new List<string>();

        // Compare each segment position
        for (int i = 0; i < minLength - 1; i++)
        {
            var segment = segments[0][i];
            var allMatch = segments.All(s =>
                s[i].Equals(segment, StringComparison.OrdinalIgnoreCase));

            if (allMatch)
            {
                commonParts.Add(segment);
            }
            else
            {
                break;
            }
        }

        return string.Join("/", commonParts);
    }

    public bool IsValidPath(string path)
    {
        if (string.IsNullOrWhiteSpace(path))
            return false;

        // Normalize first
        path = NormalizePath(path);

        // Check for dangerous patterns
        if (path.Contains(".."))
            return false;

        if (path.StartsWith("/") || path.StartsWith("\\"))
            return false;

        // Check for valid characters
        if (!ValidPathPattern().IsMatch(path))
            return false;

        // Check path length (Windows limit)
        if (path.Length > 260)
            return false;

        return true;
    }

    #endregion

    #region Private Helper Methods

    /// <summary>
    /// Parse a single line from the tree structure.
    /// </summary>
    private (string Name, int Depth, bool IsDirectory, string? Comment)? ParseTreeLine(string line)
    {
        if (string.IsNullOrWhiteSpace(line))
            return null;

        string? name = null;
        int depth = 0;
        string? comment = null;

        // Try standard Unicode tree format first
        var match = TreeLinePattern().Match(line);
        if (match.Success)
        {
            name = match.Groups[1].Value.Trim();
            depth = CalculateDepth(line);
        }

        // Try ASCII-only format
        if (name == null)
        {
            match = AsciiTreeLinePattern().Match(line);
            if (match.Success)
            {
                name = match.Groups[1].Value.Trim();
                depth = CalculateDepth(line);
            }
        }

        // Try simple listing format
        if (name == null && _options.EnableSimpleListing)
        {
            match = SimpleListingPattern().Match(line);
            if (match.Success)
            {
                name = match.Groups[2].Value.Trim();
                depth = match.Groups[1].Value.Length / 2; // 2 spaces per level
            }
        }

        // Try root directory pattern
        if (name == null)
        {
            match = RootDirectoryPattern().Match(line.Trim());
            if (match.Success)
            {
                name = match.Groups[1].Value + "/";
                depth = 0;
            }
        }

        if (name == null)
            return null;

        // Extract comment if present
        if (_options.TrimComments)
        {
            var commentMatch = InlineCommentPattern().Match(name);
            if (commentMatch.Success)
            {
                comment = commentMatch.Groups[1].Value.Trim();
                name = name[..commentMatch.Index].Trim();
            }
        }

        var isDirectory = name.EndsWith('/') ||
                         name.EndsWith('\\') ||
                         !name.Contains('.');

        return (name, depth, isDirectory, comment);
    }

    /// <summary>
    /// Calculate the depth/indentation level of a tree line.
    /// </summary>
    private static int CalculateDepth(string line)
    {
        int depth = 0;
        int spaceCount = 0;

        foreach (var c in line)
        {
            switch (c)
            {
                case ' ':
                    spaceCount++;
                    if (spaceCount == 4)
                    {
                        depth++;
                        spaceCount = 0;
                    }
                    break;

                case '\t':
                    depth++;
                    spaceCount = 0;
                    break;

                case '│':
                case '|':
                    depth++;
                    spaceCount = 0;
                    break;

                case '├':
                case '└':
                case '+':
                case '`':
                    // Stop counting at the branch marker
                    return depth;

                default:
                    if (!char.IsWhiteSpace(c))
                        return depth;
                    break;
            }
        }

        return depth;
    }

    /// <summary>
    /// Normalize a path to use forward slashes and clean up.
    /// </summary>
    private static string NormalizePath(string path)
    {
        return path
            .Replace('\\', '/')
            .TrimStart('/')
            .TrimEnd('/');
    }

    #endregion
}
```

### 4. Dependency Injection Registration

```csharp
// src/SeniorIntern.Services/ServiceCollectionExtensions.cs (partial)
namespace SeniorIntern.Services;

public static partial class ServiceCollectionExtensions
{
    /// <summary>
    /// Register file tree parser services.
    /// </summary>
    public static IServiceCollection AddFileTreeParser(
        this IServiceCollection services,
        Action<FileTreeParserOptions>? configureOptions = null)
    {
        var options = FileTreeParserOptions.Default;
        configureOptions?.Invoke(options);

        services.AddSingleton(options);
        services.AddSingleton<IFileTreeParser, FileTreeParser>();

        return services;
    }
}
```

---

## Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/IFileTreeParser.cs` | Parser interface definition |
| `src/SeniorIntern.Core/Models/TreeParseResult.cs` | Result of tree parsing operation |
| `src/SeniorIntern.Core/Models/ParsedTreeNode.cs` | Structured tree node model |
| `src/SeniorIntern.Core/Models/FileTreeParserOptions.cs` | Parser configuration options |
| `src/SeniorIntern.Services/FileTreeParser.cs` | Parser implementation |

---

## Files to Modify

| File | Modification |
|------|--------------|
| `src/SeniorIntern.Services/ServiceCollectionExtensions.cs` | Add `AddFileTreeParser` extension |

---

## Dependencies

| Dependency | Purpose |
|------------|---------|
| `System.Text.RegularExpressions` | Regex patterns for parsing |
| `Microsoft.Extensions.Logging` | Logging infrastructure |
| `SeniorIntern.Core.Models.FileTreeProposal` | Output model (v0.4.4a) |
| `SeniorIntern.Core.Models.FileOperation` | Operation model (v0.4.4a) |
| `SeniorIntern.Core.Models.CodeBlock` | Input from v0.4.1 |
| `ILanguageDetectionService` | Language detection for code blocks |

---

## Testing Strategy

### Unit Tests

```csharp
// tests/SeniorIntern.Services.Tests/FileTreeParserTests.cs
namespace SeniorIntern.Services.Tests;

public class FileTreeParserTests
{
    private readonly Mock<ILanguageDetectionService> _languageServiceMock;
    private readonly FileTreeParser _parser;

    public FileTreeParserTests()
    {
        _languageServiceMock = new Mock<ILanguageDetectionService>();
        _parser = new FileTreeParser(
            _languageServiceMock.Object,
            FileTreeParserOptions.Default);
    }

    #region ParseAsciiTree Tests

    [Fact]
    public void ParseAsciiTree_StandardUnicodeTree_ReturnsCorrectPaths()
    {
        // Arrange
        var tree = """
            src/
            ├── Models/
            │   ├── User.cs
            │   └── Product.cs
            ├── Services/
            │   └── UserService.cs
            └── Program.cs
            """;

        // Act
        var paths = _parser.ParseAsciiTree(tree);

        // Assert
        Assert.Equal(4, paths.Count);
        Assert.Contains("src/Models/User.cs", paths);
        Assert.Contains("src/Models/Product.cs", paths);
        Assert.Contains("src/Services/UserService.cs", paths);
        Assert.Contains("src/Program.cs", paths);
    }

    [Fact]
    public void ParseAsciiTree_AsciiOnlyTree_ReturnsCorrectPaths()
    {
        // Arrange
        var tree = """
            src/
            +-- Models/
            |   +-- User.cs
            |   `-- Product.cs
            `-- Program.cs
            """;

        // Act
        var paths = _parser.ParseAsciiTree(tree);

        // Assert
        Assert.Equal(3, paths.Count);
        Assert.Contains("src/Models/User.cs", paths);
        Assert.Contains("src/Models/Product.cs", paths);
        Assert.Contains("src/Program.cs", paths);
    }

    [Fact]
    public void ParseAsciiTree_WithInlineComments_ExtractsPathsAndIgnoresComments()
    {
        // Arrange
        var tree = """
            src/
            ├── Program.cs  # Main entry point
            └── Config.cs   # Configuration
            """;

        // Act
        var paths = _parser.ParseAsciiTree(tree);

        // Assert
        Assert.Equal(2, paths.Count);
        Assert.Contains("src/Program.cs", paths);
        Assert.Contains("src/Config.cs", paths);
    }

    [Fact]
    public void ParseAsciiTree_DeepNesting_HandlesCorrectly()
    {
        // Arrange
        var tree = """
            src/
            └── Level1/
                └── Level2/
                    └── Level3/
                        └── Level4/
                            └── DeepFile.cs
            """;

        // Act
        var paths = _parser.ParseAsciiTree(tree);

        // Assert
        Assert.Single(paths);
        Assert.Equal("src/Level1/Level2/Level3/Level4/DeepFile.cs", paths[0]);
    }

    [Fact]
    public void ParseAsciiTree_MixedFilesAndDirectories_OnlyReturnsFiles()
    {
        // Arrange
        var tree = """
            project/
            ├── src/
            │   ├── app/
            │   │   └── main.ts
            │   └── index.ts
            ├── tests/
            └── README.md
            """;

        // Act
        var paths = _parser.ParseAsciiTree(tree);

        // Assert
        Assert.Equal(3, paths.Count);
        Assert.Contains("project/src/app/main.ts", paths);
        Assert.Contains("project/src/index.ts", paths);
        Assert.Contains("project/README.md", paths);
        Assert.DoesNotContain("project/src/", paths);
        Assert.DoesNotContain("project/tests/", paths);
    }

    [Fact]
    public void ParseAsciiTree_EmptyInput_ReturnsEmptyList()
    {
        // Arrange & Act
        var paths = _parser.ParseAsciiTree("");

        // Assert
        Assert.Empty(paths);
    }

    [Fact]
    public void ParseAsciiTree_NoValidLines_ReturnsEmptyList()
    {
        // Arrange
        var tree = """
            This is just text
            Not a tree structure
            """;

        // Act
        var paths = _parser.ParseAsciiTree(tree);

        // Assert
        Assert.Empty(paths);
    }

    [Fact]
    public void ParseAsciiTree_SimpleIndentedFormat_ParsesCorrectly()
    {
        // Arrange
        var tree = """
            src/
              Models/
                User.cs
                Product.cs
              Services/
                UserService.cs
            """;

        // Note: This tests the simple listing format if enabled

        // Act
        var paths = _parser.ParseAsciiTree(tree);

        // Assert - Behavior depends on EnableSimpleListing option
        // With default options, this should parse
        Assert.True(paths.Count >= 0); // Adjust based on implementation
    }

    #endregion

    #region ParseAsciiTreeStructured Tests

    [Fact]
    public void ParseAsciiTreeStructured_ReturnsNodeTree()
    {
        // Arrange
        var tree = """
            src/
            ├── Models/
            │   └── User.cs
            └── Program.cs
            """;

        // Act
        var root = _parser.ParseAsciiTreeStructured(tree);

        // Assert
        Assert.NotNull(root);
        Assert.Single(root.Children); // src/
        Assert.Equal("src", root.Children[0].Name);
        Assert.True(root.Children[0].IsDirectory);
        Assert.Equal(2, root.Children[0].Children.Count); // Models/ and Program.cs
    }

    [Fact]
    public void ParseAsciiTreeStructured_GetAllFilePaths_ReturnsAllFiles()
    {
        // Arrange
        var tree = """
            src/
            ├── a.cs
            └── sub/
                └── b.cs
            """;

        // Act
        var root = _parser.ParseAsciiTreeStructured(tree);
        var filePaths = root!.GetAllFilePaths().ToList();

        // Assert
        Assert.Equal(2, filePaths.Count);
        Assert.Contains("src/a.cs", filePaths);
        Assert.Contains("src/sub/b.cs", filePaths);
    }

    #endregion

    #region ContainsFileTree Tests

    [Fact]
    public void ContainsFileTree_WithStructureIndicatorAndTreeBlock_ReturnsTrue()
    {
        // Arrange
        var content = """
            Here's the project structure:

            ```
            src/
            └── App.cs
            ```
            """;

        // Act
        var result = _parser.ContainsFileTree(content);

        // Assert
        Assert.True(result);
    }

    [Fact]
    public void ContainsFileTree_WithoutIndicator_ReturnsFalse()
    {
        // Arrange
        var content = """
            Some code:

            ```
            src/
            └── App.cs
            ```
            """;

        // Act
        var result = _parser.ContainsFileTree(content);

        // Assert
        Assert.False(result); // No indicator phrase
    }

    [Fact]
    public void ContainsFileTree_IndicatorButNoTree_ReturnsFalse()
    {
        // Arrange
        var content = "Here's the project structure: just some text, no tree.";

        // Act
        var result = _parser.ContainsFileTree(content);

        // Assert
        Assert.False(result);
    }

    [Theory]
    [InlineData("file structure")]
    [InlineData("folder structure")]
    [InlineData("directory structure")]
    [InlineData("create these files")]
    [InlineData("files to create")]
    public void ContainsFileTree_VariousIndicators_AreRecognized(string indicator)
    {
        // Arrange
        var content = $"""
            {indicator}:

            ```
            src/
            └── file.cs
            ```
            """;

        // Act
        var result = _parser.ContainsFileTree(content);

        // Assert
        Assert.True(result);
    }

    #endregion

    #region ParseProposal Tests

    [Fact]
    public void ParseProposal_MultipleCodeBlocksWithPaths_CreatesProposal()
    {
        // Arrange
        var content = "Here's the implementation:";
        var messageId = Guid.NewGuid();
        var codeBlocks = new[]
        {
            new CodeBlock
            {
                Id = Guid.NewGuid(),
                TargetFilePath = "src/Models/User.cs",
                Content = "public class User { }",
                BlockType = CodeBlockType.CompleteFile
            },
            new CodeBlock
            {
                Id = Guid.NewGuid(),
                TargetFilePath = "src/Services/UserService.cs",
                Content = "public class UserService { }",
                BlockType = CodeBlockType.CompleteFile
            }
        };

        // Act
        var proposal = _parser.ParseProposal(content, messageId, codeBlocks);

        // Assert
        Assert.NotNull(proposal);
        Assert.Equal(2, proposal.FileCount);
        Assert.Equal(messageId, proposal.MessageId);
        Assert.Equal("src", proposal.RootPath);
    }

    [Fact]
    public void ParseProposal_SingleCodeBlock_ReturnsNull()
    {
        // Arrange
        var codeBlocks = new[]
        {
            new CodeBlock
            {
                TargetFilePath = "src/App.cs",
                Content = "class App { }",
                BlockType = CodeBlockType.CompleteFile
            }
        };

        // Act
        var proposal = _parser.ParseProposal("content", Guid.NewGuid(), codeBlocks);

        // Assert
        Assert.Null(proposal);
    }

    [Fact]
    public void ParseProposal_CodeBlocksWithoutPaths_ReturnsNull()
    {
        // Arrange
        var codeBlocks = new[]
        {
            new CodeBlock { Content = "code1", BlockType = CodeBlockType.CompleteFile },
            new CodeBlock { Content = "code2", BlockType = CodeBlockType.CompleteFile }
        };

        // Act
        var proposal = _parser.ParseProposal("content", Guid.NewGuid(), codeBlocks);

        // Assert
        Assert.Null(proposal);
    }

    [Fact]
    public void ParseProposal_WithAsciiTree_IncludesRawTreeText()
    {
        // Arrange
        var content = """
            Here's the project structure:

            ```
            src/
            ├── User.cs
            └── Product.cs
            ```

            Here's the implementation...
            """;
        var codeBlocks = new[]
        {
            new CodeBlock
            {
                TargetFilePath = "src/User.cs",
                Content = "class User { }",
                BlockType = CodeBlockType.CompleteFile
            },
            new CodeBlock
            {
                TargetFilePath = "src/Product.cs",
                Content = "class Product { }",
                BlockType = CodeBlockType.CompleteFile
            }
        };

        // Act
        var proposal = _parser.ParseProposal(content, Guid.NewGuid(), codeBlocks);

        // Assert
        Assert.NotNull(proposal);
        Assert.NotNull(proposal.RawTreeText);
        Assert.Contains("User.cs", proposal.RawTreeText);
    }

    [Fact]
    public void ParseProposal_MixedBlockTypes_OnlyIncludesConfiguredTypes()
    {
        // Arrange
        var codeBlocks = new[]
        {
            new CodeBlock
            {
                TargetFilePath = "src/A.cs",
                Content = "class A { }",
                BlockType = CodeBlockType.CompleteFile
            },
            new CodeBlock
            {
                TargetFilePath = "src/B.cs",
                Content = "class B { }",
                BlockType = CodeBlockType.Snippet
            },
            new CodeBlock
            {
                TargetFilePath = "src/C.cs",
                Content = "class C { }",
                BlockType = CodeBlockType.DiffHunk // Not included by default
            }
        };

        // Act
        var proposal = _parser.ParseProposal("content", Guid.NewGuid(), codeBlocks);

        // Assert
        Assert.NotNull(proposal);
        Assert.Equal(2, proposal.FileCount); // Only CompleteFile and Snippet
    }

    #endregion

    #region TryParseProposal Tests

    [Fact]
    public void TryParseProposal_Failure_ProvidesReason()
    {
        // Arrange
        var codeBlocks = new[]
        {
            new CodeBlock
            {
                TargetFilePath = "src/A.cs",
                Content = "class A { }",
                BlockType = CodeBlockType.CompleteFile
            }
        };

        // Act
        var result = _parser.TryParseProposal(
            "content",
            Guid.NewGuid(),
            codeBlocks,
            out var proposal,
            out var reason);

        // Assert
        Assert.False(result);
        Assert.Null(proposal);
        Assert.NotNull(reason);
        Assert.Contains("1", reason); // Should mention count
    }

    [Fact]
    public void TryParseProposal_EmptyContent_Fails()
    {
        // Arrange & Act
        var result = _parser.TryParseProposal(
            "",
            Guid.NewGuid(),
            Array.Empty<CodeBlock>(),
            out var proposal,
            out var reason);

        // Assert
        Assert.False(result);
        Assert.Contains("empty", reason?.ToLower());
    }

    #endregion

    #region ExtractDescription Tests

    [Fact]
    public void ExtractDescription_WithIndicatorPhrase_ExtractsLine()
    {
        // Arrange
        var content = """
            Let me help you with that.

            Here's the project structure for authentication:

            ```
            src/
            └── Auth.cs
            ```
            """;

        // Act
        var description = _parser.ExtractDescription(content);

        // Assert
        Assert.NotNull(description);
        Assert.Contains("authentication", description.ToLower());
    }

    [Fact]
    public void ExtractDescription_CleansMarkdownFormatting()
    {
        // Arrange
        var content = """
            ## Here's the **file structure** for the project

            ```
            src/
            ```
            """;

        // Act
        var description = _parser.ExtractDescription(content);

        // Assert
        Assert.NotNull(description);
        Assert.DoesNotContain("##", description);
        Assert.DoesNotContain("**", description);
    }

    [Fact]
    public void ExtractDescription_TooShort_ReturnsNull()
    {
        // Arrange
        var content = """
            file structure

            ```
            src/
            ```
            """;

        // Act
        var description = _parser.ExtractDescription(content);

        // Assert
        // "file structure" alone is too short (< 10 chars typically)
        // Depends on MinDescriptionLength setting
        Assert.True(description == null || description.Length >= 10);
    }

    [Fact]
    public void ExtractDescription_TooLong_Truncates()
    {
        // Arrange
        var longDescription = new string('a', 300);
        var content = $"""
            Here's the project structure: {longDescription}

            ```
            src/
            ```
            """;

        // Act
        var description = _parser.ExtractDescription(content);

        // Assert
        Assert.NotNull(description);
        Assert.True(description.Length <= 203); // MaxDescriptionLength + "..."
    }

    [Fact]
    public void ExtractDescription_NoIndicator_ReturnsNull()
    {
        // Arrange
        var content = "Just some regular text without any file tree indicators.";

        // Act
        var description = _parser.ExtractDescription(content);

        // Assert
        Assert.Null(description);
    }

    #endregion

    #region FindCommonRoot Tests

    [Fact]
    public void FindCommonRoot_SameDirectory_ReturnsDirectory()
    {
        // Arrange
        var paths = new[]
        {
            "src/Models/User.cs",
            "src/Models/Product.cs",
            "src/Models/Order.cs"
        };

        // Act
        var root = _parser.FindCommonRoot(paths);

        // Assert
        Assert.Equal("src/Models", root);
    }

    [Fact]
    public void FindCommonRoot_DifferentDirectories_ReturnsCommonAncestor()
    {
        // Arrange
        var paths = new[]
        {
            "src/Models/User.cs",
            "src/Services/UserService.cs",
            "src/Controllers/UserController.cs"
        };

        // Act
        var root = _parser.FindCommonRoot(paths);

        // Assert
        Assert.Equal("src", root);
    }

    [Fact]
    public void FindCommonRoot_NoCommonPath_ReturnsEmpty()
    {
        // Arrange
        var paths = new[]
        {
            "frontend/App.tsx",
            "backend/Server.cs",
            "docs/README.md"
        };

        // Act
        var root = _parser.FindCommonRoot(paths);

        // Assert
        Assert.Equal("", root);
    }

    [Fact]
    public void FindCommonRoot_SinglePath_ReturnsParentDirectory()
    {
        // Arrange
        var paths = new[] { "src/Models/User.cs" };

        // Act
        var root = _parser.FindCommonRoot(paths);

        // Assert
        Assert.Equal("src/Models", root);
    }

    [Fact]
    public void FindCommonRoot_EmptyList_ReturnsEmpty()
    {
        // Arrange & Act
        var root = _parser.FindCommonRoot(Array.Empty<string>());

        // Assert
        Assert.Equal("", root);
    }

    [Fact]
    public void FindCommonRoot_NormalizesBackslashes()
    {
        // Arrange
        var paths = new[]
        {
            "src\\Models\\User.cs",
            "src/Models/Product.cs"
        };

        // Act
        var root = _parser.FindCommonRoot(paths);

        // Assert
        Assert.Equal("src/Models", root);
    }

    #endregion

    #region IsValidPath Tests

    [Theory]
    [InlineData("src/file.cs", true)]
    [InlineData("src/Models/User.cs", true)]
    [InlineData("file.txt", true)]
    [InlineData("path/to/deep/file.ts", true)]
    [InlineData("src/file-name.cs", true)]
    [InlineData("src/file_name.cs", true)]
    [InlineData("src/@types/index.d.ts", true)]
    public void IsValidPath_ValidPaths_ReturnsTrue(string path, bool expected)
    {
        // Act
        var result = _parser.IsValidPath(path);

        // Assert
        Assert.Equal(expected, result);
    }

    [Theory]
    [InlineData("", false)]
    [InlineData("   ", false)]
    [InlineData("../escape.cs", false)]
    [InlineData("/absolute/path.cs", false)]
    [InlineData("\\windows\\path.cs", false)]
    [InlineData("path/../../../etc/passwd", false)]
    public void IsValidPath_InvalidPaths_ReturnsFalse(string path, bool expected)
    {
        // Act
        var result = _parser.IsValidPath(path);

        // Assert
        Assert.Equal(expected, result);
    }

    #endregion

    #region Edge Cases

    [Fact]
    public void ParseAsciiTree_UnicodeFilenames_HandlesCorrectly()
    {
        // Arrange
        var tree = """
            src/
            ├── файл.cs
            └── 文件.ts
            """;

        // Act
        var paths = _parser.ParseAsciiTree(tree);

        // Assert
        // Depends on ValidPathPattern - may or may not include Unicode
        // Current implementation may reject these
        Assert.True(paths.Count >= 0);
    }

    [Fact]
    public void ParseAsciiTree_MalformedTree_HandlesGracefully()
    {
        // Arrange
        var tree = """
            src/
            ├── file1.cs
            │   └── nested-without-dir.cs
            ├── file2.cs
            └──
            """;

        // Act - Should not throw
        var paths = _parser.ParseAsciiTree(tree);

        // Assert
        Assert.NotNull(paths);
    }

    [Fact]
    public void ParseProposal_VeryLargeProposal_RejectsOverLimit()
    {
        // Arrange
        var codeBlocks = Enumerable.Range(0, 150)
            .Select(i => new CodeBlock
            {
                TargetFilePath = $"src/File{i}.cs",
                Content = $"class File{i} {{ }}",
                BlockType = CodeBlockType.CompleteFile
            })
            .ToList();

        // Act
        var success = _parser.TryParseProposal(
            "content",
            Guid.NewGuid(),
            codeBlocks,
            out var proposal,
            out var reason);

        // Assert
        Assert.False(success);
        Assert.Contains("maximum", reason?.ToLower());
    }

    #endregion
}

// tests/SeniorIntern.Services.Tests/FileTreeParserOptionsTests.cs
namespace SeniorIntern.Services.Tests;

public class FileTreeParserOptionsTests
{
    [Fact]
    public void Default_HasExpectedValues()
    {
        // Arrange & Act
        var options = FileTreeParserOptions.Default;

        // Assert
        Assert.Equal(2, options.MinimumFilesForProposal);
        Assert.Equal(20, options.MaxTreeDepth);
        Assert.Equal(100, options.MaxFilesInProposal);
        Assert.True(options.EnableSimpleListing);
        Assert.True(options.TrimComments);
    }

    [Fact]
    public void Lenient_HasRelaxedValues()
    {
        // Arrange & Act
        var options = FileTreeParserOptions.Lenient;

        // Assert
        Assert.Equal(1, options.MinimumFilesForProposal);
        Assert.False(options.RequireStructureIndicator);
        Assert.Equal(500, options.MaxFilesInProposal);
    }

    [Fact]
    public void StructureIndicators_ContainsExpectedPhrases()
    {
        // Arrange
        var options = FileTreeParserOptions.Default;

        // Assert
        Assert.Contains("project structure", options.StructureIndicators);
        Assert.Contains("file structure", options.StructureIndicators);
        Assert.Contains("create these files", options.StructureIndicators);
    }
}
```

---

## Acceptance Criteria

- [ ] ASCII tree structures with Unicode box-drawing characters (├└│──) parsed correctly
- [ ] ASCII-only tree structures (+|`-) parsed correctly
- [ ] Simple indented listings parsed when enabled
- [ ] Tree depth calculated correctly for proper nesting
- [ ] Inline comments (# comment) extracted and optionally trimmed
- [ ] Directories (paths ending in /) excluded from file list
- [ ] Common root path found using longest common prefix algorithm
- [ ] Description extracted from text near structure indicators
- [ ] Markdown formatting cleaned from extracted descriptions
- [ ] Single-file proposals rejected (minimum 2 files)
- [ ] Very large proposals rejected (configurable maximum)
- [ ] Invalid paths (../, absolute paths) rejected
- [ ] Empty or whitespace content handled gracefully
- [ ] Malformed trees don't cause crashes
- [ ] Configuration options respected (indicators, limits, flags)
- [ ] TryParseProposal provides meaningful failure reasons
- [ ] ParseAsciiTreeStructured returns navigable node tree

---

## Design Decisions

| Decision | Rationale | Alternatives Considered |
|----------|-----------|------------------------|
| Source-generated regex | Performance (compiled at build time) | Runtime Regex compilation |
| Minimum 2 files for proposal | Single file isn't "multi-file" | Configurable minimum (implemented via options) |
| Structure indicators required | Reduces false positives | Optional (available via Lenient options) |
| Exclude directories from paths | Operations are file-centric | Include directories as separate operations |
| Path stack for depth tracking | Natural tree traversal | Recursive parsing |
| Forward slash normalization | Cross-platform consistency | Platform-specific handling |
| Configurable options record | Flexibility without constructor overloads | Multiple constructor overloads |
| Separate structured parsing method | Some consumers need tree structure | Always return structure |
| Maximum file limit | Prevent abuse/memory issues | No limit (risky) |

---

## Accessibility Considerations

- Error messages and failure reasons use clear, descriptive language
- ParsedTreeNode provides full path for screen reader compatibility
- Comments extracted separately for assistive technology access
- No color-dependent information in parsing logic

---

## Performance Considerations

| Concern | Mitigation |
|---------|------------|
| Regex compilation | Source-generated regex compiles at build time |
| Large tree parsing | MaxTreeDepth limit prevents stack overflow |
| Many code blocks | MaxFilesInProposal limit prevents memory issues |
| String allocations | Reuse StringBuilder in loops (if needed) |
| Path normalization | Simple char replacement, O(n) |
| Common root finding | O(n*m) where n=paths, m=segments; acceptable for <100 files |

---

## Future Enhancements

1. **Tree Format Auto-Detection**: Automatically detect and switch between Unicode/ASCII formats
2. **Fuzzy Path Matching**: Match tree paths to code block paths with tolerance
3. **Conflict Detection**: Warn when tree structure doesn't match code blocks
4. **Template Recognition**: Detect common project templates (React, .NET, etc.)
5. **Incremental Parsing**: Support streaming/incremental tree building
6. **Custom Indicators**: User-configurable structure indicator phrases
7. **Multi-Root Support**: Handle multiple root directories in single tree

---

## Related Specifications

| Specification | Relationship |
|---------------|--------------|
| v0.4.1 (Code Block Extraction) | Provides CodeBlock input |
| v0.4.4a (Core Models) | Provides FileTreeProposal, FileOperation output |
| v0.4.4c (Proposal Service) | Consumes parsed proposals |
| v0.4.4h (Chat Integration) | Triggers parsing on message completion |
