# Design Specification: The Senior Intern v0.4.5 "Polish & Integration"

**Status**: _IN PROGRESS_

## Executive Summary

This document provides a comprehensive design specification for v0.4.5, which integrates all code generation features into a cohesive experience. This includes streaming diff preview during LLM generation, partial snippet apply for targeted code insertion, keyboard shortcuts for power users, change history panel, status bar integration, and settings management.

### Parent Version Reference
- **Parent**: v0.4.0 "Code Generation & Diffing"
- **Focus**: Streaming diff preview, partial snippet apply, keyboard shortcuts, change history

### Dependencies
- v0.4.1 (Code Block Extraction) - Required for CodeBlock model and parsing
- v0.4.2 (Diff Engine) - Required for DiffResult and diff computation
- v0.4.3 (Apply Changes Workflow) - Required for FileChangeService and UndoManager
- v0.4.4 (Multi-File Creation) - Required for batch operations

---

## Sub-Part Breakdown

| Sub-Part | Name | Focus |
|----------|------|-------|
| v0.4.5a | Settings Models | Code generation settings in AppSettings |
| v0.4.5b | Streaming Diff Preview | Compute diffs during LLM streaming |
| v0.4.5c | Partial Snippet Models | SnippetApplyOptions, LineRange, InsertMode |
| v0.4.5d | Snippet Apply Service | ISnippetApplyService for targeted insertion |
| v0.4.5e | Snippet Options UI | SnippetApplyOptionsPopup with mode selection |
| v0.4.5f | Keyboard Shortcuts | Global and context-specific shortcuts |
| v0.4.5g | Quick Actions | Inline action buttons on code blocks |
| v0.4.5h | Change History Panel | Track and browse recent changes |
| v0.4.5i | Status Bar Integration | Pending changes indicator |

---

## v0.4.5a: Settings Models

### Objective
Extend AppSettings with code generation preferences that persist across sessions.

### Updated AppSettings

```csharp
// src/SeniorIntern.Core/Models/AppSettings.cs (additions)
namespace SeniorIntern.Core.Models;

public sealed class AppSettings
{
    // ... existing properties from v0.1.0 - v0.3.x ...

    // ═══════════════════════════════════════════════════════════════
    // Code Generation Settings (v0.4.0)
    // ═══════════════════════════════════════════════════════════════

    /// <summary>
    /// Automatically detect and parse code blocks from LLM responses.
    /// </summary>
    public bool AutoDetectCodeBlocks { get; set; } = true;

    /// <summary>
    /// Show diff preview while LLM is still streaming response.
    /// </summary>
    public bool ShowDiffPreviewDuringStreaming { get; set; } = true;

    /// <summary>
    /// Create backup file before applying changes.
    /// </summary>
    public bool CreateBackupBeforeApply { get; set; } = true;

    /// <summary>
    /// Time window in minutes during which undo is available.
    /// </summary>
    public int UndoWindowMinutes { get; set; } = 30;

    /// <summary>
    /// Maximum age in days for backup files before cleanup.
    /// </summary>
    public int MaxBackupAgeDays { get; set; } = 7;

    /// <summary>
    /// Automatically refresh editor after applying changes.
    /// </summary>
    public bool AutoRefreshEditorAfterApply { get; set; } = true;

    /// <summary>
    /// Default view mode for diff viewer.
    /// </summary>
    public DiffViewMode DefaultDiffViewMode { get; set; } = DiffViewMode.SideBySide;

    /// <summary>
    /// Show line numbers in diff viewer.
    /// </summary>
    public bool ShowLineNumbersInDiff { get; set; } = true;

    /// <summary>
    /// Highlight whitespace changes in diff viewer.
    /// </summary>
    public bool HighlightWhitespaceChanges { get; set; } = false;

    /// <summary>
    /// Number of context lines to show around changes.
    /// </summary>
    public int DiffContextLines { get; set; } = 3;

    /// <summary>
    /// Show quick action buttons on code blocks.
    /// </summary>
    public bool ShowCodeBlockQuickActions { get; set; } = true;

    /// <summary>
    /// Auto-expand code blocks in chat messages.
    /// </summary>
    public bool AutoExpandCodeBlocks { get; set; } = true;

    /// <summary>
    /// Maximum number of recent changes to track in history.
    /// </summary>
    public int MaxChangeHistoryItems { get; set; } = 50;
}
```

### DiffViewMode Enum

```csharp
// src/SeniorIntern.Core/Models/DiffViewMode.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Display mode for diff viewer.
/// </summary>
public enum DiffViewMode
{
    /// <summary>
    /// Side-by-side comparison with synchronized scrolling.
    /// </summary>
    SideBySide,

    /// <summary>
    /// Inline changes with additions and deletions interleaved.
    /// </summary>
    Inline,

    /// <summary>
    /// Unified diff format (similar to git diff).
    /// </summary>
    Unified
}
```

### Files to Create (v0.4.5a)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Models/DiffViewMode.cs` | Diff view mode enum |

### Files to Modify (v0.4.5a)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Core/Models/AppSettings.cs` | Add code generation settings |

---

## v0.4.5b: Streaming Diff Preview

### Objective
Compute and display diff previews while the LLM is still generating a response, providing immediate visual feedback.

### StreamingDiffCoordinator

```csharp
// src/SeniorIntern.Services/StreamingDiffCoordinator.cs
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using System.Collections.Concurrent;

namespace SeniorIntern.Services;

/// <summary>
/// Coordinates streaming diff computation during LLM response generation.
/// </summary>
public sealed class StreamingDiffCoordinator : IStreamingDiffCoordinator
{
    private readonly IDiffService _diffService;
    private readonly IWorkspaceService _workspaceService;
    private readonly ISettingsService _settingsService;
    private readonly ConcurrentDictionary<Guid, DiffComputationState> _activeComputations = new();

    public StreamingDiffCoordinator(
        IDiffService diffService,
        IWorkspaceService workspaceService,
        ISettingsService settingsService)
    {
        _diffService = diffService;
        _workspaceService = workspaceService;
        _settingsService = settingsService;
    }

    /// <summary>
    /// Called when a code block is detected during streaming.
    /// </summary>
    public async Task<DiffResult?> OnCodeBlockDetectedAsync(
        CodeBlock block,
        CancellationToken cancellationToken = default)
    {
        var settings = await _settingsService.GetSettingsAsync();
        if (!settings.ShowDiffPreviewDuringStreaming)
            return null;

        if (string.IsNullOrEmpty(block.TargetFilePath))
            return null;

        var workspace = _workspaceService.CurrentWorkspace;
        if (workspace is null)
            return null;

        // Track computation state
        var state = new DiffComputationState
        {
            BlockId = block.Id,
            StartedAt = DateTime.UtcNow,
            Status = DiffComputationStatus.Computing
        };
        _activeComputations[block.Id] = state;

        try
        {
            var fullPath = Path.Combine(workspace.RootPath, block.TargetFilePath);

            // For new files, create a simple "all additions" diff
            if (!File.Exists(fullPath))
            {
                var diff = _diffService.CreateNewFileDiff(block.TargetFilePath, block.Content);
                state.Status = DiffComputationStatus.Completed;
                state.Result = diff;
                return diff;
            }

            // For existing files, compute actual diff
            var originalContent = await File.ReadAllTextAsync(fullPath, cancellationToken);
            var diff2 = _diffService.ComputeDiff(
                originalContent,
                block.Content,
                block.TargetFilePath);

            state.Status = DiffComputationStatus.Completed;
            state.Result = diff2;
            return diff2;
        }
        catch (OperationCanceledException)
        {
            state.Status = DiffComputationStatus.Cancelled;
            return null;
        }
        catch (Exception ex)
        {
            state.Status = DiffComputationStatus.Failed;
            state.ErrorMessage = ex.Message;
            return null;
        }
    }

    /// <summary>
    /// Called when a code block's content is updated during streaming.
    /// </summary>
    public async Task<DiffResult?> OnCodeBlockUpdatedAsync(
        CodeBlock block,
        CancellationToken cancellationToken = default)
    {
        // Debounce rapid updates - only recompute if enough time has passed
        if (_activeComputations.TryGetValue(block.Id, out var state))
        {
            if (state.Status == DiffComputationStatus.Computing)
                return state.Result; // Return previous result while computing

            var elapsed = DateTime.UtcNow - state.LastUpdatedAt;
            if (elapsed < TimeSpan.FromMilliseconds(250))
                return state.Result; // Too soon, use cached result
        }

        return await OnCodeBlockDetectedAsync(block, cancellationToken);
    }

    /// <summary>
    /// Called when streaming completes to finalize diff computation.
    /// </summary>
    public async Task<DiffResult?> FinalizeBlockDiffAsync(
        CodeBlock block,
        CancellationToken cancellationToken = default)
    {
        // Force recompute with final content
        if (_activeComputations.TryRemove(block.Id, out _))
        {
            return await OnCodeBlockDetectedAsync(block, cancellationToken);
        }
        return null;
    }

    /// <summary>
    /// Get current computation status for a block.
    /// </summary>
    public DiffComputationState? GetComputationState(Guid blockId)
    {
        return _activeComputations.TryGetValue(blockId, out var state) ? state : null;
    }

    /// <summary>
    /// Cancel all active computations.
    /// </summary>
    public void CancelAll()
    {
        foreach (var state in _activeComputations.Values)
        {
            state.Status = DiffComputationStatus.Cancelled;
        }
        _activeComputations.Clear();
    }
}
```

### DiffComputationState

```csharp
// src/SeniorIntern.Core/Models/DiffComputationState.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Tracks the state of a streaming diff computation.
/// </summary>
public sealed class DiffComputationState
{
    public Guid BlockId { get; init; }
    public DateTime StartedAt { get; init; }
    public DateTime LastUpdatedAt { get; set; } = DateTime.UtcNow;
    public DiffComputationStatus Status { get; set; }
    public DiffResult? Result { get; set; }
    public string? ErrorMessage { get; set; }
}

/// <summary>
/// Status of a streaming diff computation.
/// </summary>
public enum DiffComputationStatus
{
    Pending,
    Computing,
    Completed,
    Failed,
    Cancelled
}
```

### IStreamingDiffCoordinator Interface

```csharp
// src/SeniorIntern.Core/Interfaces/IStreamingDiffCoordinator.cs
using SeniorIntern.Core.Models;

namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Coordinates diff computation during LLM response streaming.
/// </summary>
public interface IStreamingDiffCoordinator
{
    /// <summary>
    /// Called when a code block is first detected during streaming.
    /// </summary>
    Task<DiffResult?> OnCodeBlockDetectedAsync(
        CodeBlock block,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Called when a code block's content is updated during streaming.
    /// </summary>
    Task<DiffResult?> OnCodeBlockUpdatedAsync(
        CodeBlock block,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Finalize diff computation when streaming completes.
    /// </summary>
    Task<DiffResult?> FinalizeBlockDiffAsync(
        CodeBlock block,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Get current computation state for a block.
    /// </summary>
    DiffComputationState? GetComputationState(Guid blockId);

    /// <summary>
    /// Cancel all active computations.
    /// </summary>
    void CancelAll();
}
```

### Updated ChatMessageViewModel

```csharp
// src/SeniorIntern.Desktop/ViewModels/ChatMessageViewModel.cs (additions)
public partial class ChatMessageViewModel : ViewModelBase
{
    // ... existing properties ...

    [ObservableProperty]
    private bool _isComputingDiff;

    [ObservableProperty]
    private DiffResult? _streamingDiffPreview;

    [ObservableProperty]
    private DiffComputationStatus _diffComputationStatus;

    private readonly IStreamingDiffCoordinator? _streamingDiffCoordinator;

    /// <summary>
    /// Called during streaming when a code block is detected or updated.
    /// </summary>
    public async Task UpdateStreamingDiffPreviewAsync(CodeBlock block)
    {
        if (_streamingDiffCoordinator is null)
            return;

        IsComputingDiff = true;
        DiffComputationStatus = DiffComputationStatus.Computing;

        try
        {
            var diff = await _streamingDiffCoordinator.OnCodeBlockUpdatedAsync(block);
            if (diff is not null)
            {
                StreamingDiffPreview = diff;
                HasApplicableCode = true;
            }
            DiffComputationStatus = DiffComputationStatus.Completed;
        }
        catch
        {
            DiffComputationStatus = DiffComputationStatus.Failed;
        }
        finally
        {
            IsComputingDiff = false;
        }
    }

    /// <summary>
    /// Finalize diff when streaming completes.
    /// </summary>
    public async Task FinalizeStreamingDiffAsync(CodeBlock block)
    {
        if (_streamingDiffCoordinator is null)
            return;

        var diff = await _streamingDiffCoordinator.FinalizeBlockDiffAsync(block);
        if (diff is not null)
        {
            StreamingDiffPreview = diff;
        }
        IsComputingDiff = false;
    }
}
```

### Files to Create (v0.4.5b)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Models/DiffComputationState.cs` | Streaming diff state tracking |
| `src/SeniorIntern.Core/Interfaces/IStreamingDiffCoordinator.cs` | Coordinator interface |
| `src/SeniorIntern.Services/StreamingDiffCoordinator.cs` | Streaming diff implementation |

### Files to Modify (v0.4.5b)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/ViewModels/ChatMessageViewModel.cs` | Add streaming diff properties and methods |

---

## v0.4.5c: Partial Snippet Models

### Objective
Define models for applying code snippets to specific locations within files (not full file replacement).

### LineRange Model

```csharp
// src/SeniorIntern.Core/Models/LineRange.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Represents a range of lines in a file (1-indexed, inclusive).
/// </summary>
public readonly struct LineRange : IEquatable<LineRange>
{
    /// <summary>
    /// Start line (1-indexed, inclusive).
    /// </summary>
    public int StartLine { get; init; }

    /// <summary>
    /// End line (1-indexed, inclusive).
    /// </summary>
    public int EndLine { get; init; }

    /// <summary>
    /// Number of lines in the range.
    /// </summary>
    public int LineCount => EndLine - StartLine + 1;

    /// <summary>
    /// Whether this is a valid range.
    /// </summary>
    public bool IsValid => StartLine > 0 && EndLine >= StartLine;

    /// <summary>
    /// Create a line range.
    /// </summary>
    public LineRange(int startLine, int endLine)
    {
        StartLine = startLine;
        EndLine = endLine;
    }

    /// <summary>
    /// Create a single-line range.
    /// </summary>
    public static LineRange SingleLine(int line) => new(line, line);

    /// <summary>
    /// Create a range from start to end of file.
    /// </summary>
    public static LineRange ToEndOfFile(int startLine) => new(startLine, int.MaxValue);

    /// <summary>
    /// Check if a line number is within this range.
    /// </summary>
    public bool Contains(int lineNumber) => lineNumber >= StartLine && lineNumber <= EndLine;

    /// <summary>
    /// Check if this range overlaps with another.
    /// </summary>
    public bool Overlaps(LineRange other) =>
        StartLine <= other.EndLine && EndLine >= other.StartLine;

    public bool Equals(LineRange other) =>
        StartLine == other.StartLine && EndLine == other.EndLine;

    public override bool Equals(object? obj) => obj is LineRange other && Equals(other);

    public override int GetHashCode() => HashCode.Combine(StartLine, EndLine);

    public override string ToString() =>
        StartLine == EndLine ? $"Line {StartLine}" : $"Lines {StartLine}-{EndLine}";

    public static bool operator ==(LineRange left, LineRange right) => left.Equals(right);
    public static bool operator !=(LineRange left, LineRange right) => !left.Equals(right);
}
```

### SnippetInsertMode Enum

```csharp
// src/SeniorIntern.Core/Models/SnippetInsertMode.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// How to insert a code snippet into a file.
/// </summary>
public enum SnippetInsertMode
{
    /// <summary>
    /// Replace specific lines in the file.
    /// </summary>
    Replace,

    /// <summary>
    /// Insert before a specific line.
    /// </summary>
    InsertBefore,

    /// <summary>
    /// Insert after a specific line.
    /// </summary>
    InsertAfter,

    /// <summary>
    /// Append to the end of the file.
    /// </summary>
    Append,

    /// <summary>
    /// Prepend to the beginning of the file.
    /// </summary>
    Prepend,

    /// <summary>
    /// Replace entire file contents.
    /// </summary>
    ReplaceFile
}
```

### SnippetApplyOptions Model

```csharp
// src/SeniorIntern.Core/Models/SnippetApplyOptions.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Options for applying a code snippet to a specific location in a file.
/// </summary>
public sealed record SnippetApplyOptions
{
    /// <summary>
    /// How to insert the snippet.
    /// </summary>
    public SnippetInsertMode InsertMode { get; init; } = SnippetInsertMode.ReplaceFile;

    /// <summary>
    /// Target line for InsertBefore/InsertAfter operations.
    /// </summary>
    public int? TargetLine { get; init; }

    /// <summary>
    /// Lines to replace (for Replace mode).
    /// </summary>
    public LineRange? ReplaceRange { get; init; }

    /// <summary>
    /// Whether to preserve indentation of the target location.
    /// </summary>
    public bool PreserveIndentation { get; init; } = true;

    /// <summary>
    /// Indentation string to use (spaces or tabs).
    /// If null, auto-detect from file.
    /// </summary>
    public string? IndentationOverride { get; init; }

    /// <summary>
    /// Whether to add blank line before inserted content.
    /// </summary>
    public bool AddBlankLineBefore { get; init; } = false;

    /// <summary>
    /// Whether to add blank line after inserted content.
    /// </summary>
    public bool AddBlankLineAfter { get; init; } = false;

    /// <summary>
    /// Create options for full file replacement.
    /// </summary>
    public static SnippetApplyOptions FullReplace => new()
    {
        InsertMode = SnippetInsertMode.ReplaceFile
    };

    /// <summary>
    /// Create options for replacing specific lines.
    /// </summary>
    public static SnippetApplyOptions ReplaceLines(int startLine, int endLine) => new()
    {
        InsertMode = SnippetInsertMode.Replace,
        ReplaceRange = new LineRange(startLine, endLine)
    };

    /// <summary>
    /// Create options for inserting after a line.
    /// </summary>
    public static SnippetApplyOptions InsertAfterLine(int line) => new()
    {
        InsertMode = SnippetInsertMode.InsertAfter,
        TargetLine = line
    };

    /// <summary>
    /// Create options for appending to file.
    /// </summary>
    public static SnippetApplyOptions AppendToFile => new()
    {
        InsertMode = SnippetInsertMode.Append,
        AddBlankLineBefore = true
    };

    /// <summary>
    /// Validate these options.
    /// </summary>
    public bool IsValid => InsertMode switch
    {
        SnippetInsertMode.Replace => ReplaceRange?.IsValid ?? false,
        SnippetInsertMode.InsertBefore or SnippetInsertMode.InsertAfter => TargetLine > 0,
        SnippetInsertMode.Append or SnippetInsertMode.Prepend or SnippetInsertMode.ReplaceFile => true,
        _ => false
    };
}
```

### Files to Create (v0.4.5c)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Models/LineRange.cs` | Line range value type |
| `src/SeniorIntern.Core/Models/SnippetInsertMode.cs` | Insert mode enum |
| `src/SeniorIntern.Core/Models/SnippetApplyOptions.cs` | Snippet apply options |

---

## v0.4.5d: Snippet Apply Service

### Objective
Implement a service that applies code snippets to specific locations within files.

### ISnippetApplyService Interface

```csharp
// src/SeniorIntern.Core/Interfaces/ISnippetApplyService.cs
using SeniorIntern.Core.Models;

namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Service for applying code snippets to specific file locations.
/// </summary>
public interface ISnippetApplyService
{
    /// <summary>
    /// Apply a snippet to a file with specified options.
    /// </summary>
    Task<SnippetApplyResult> ApplySnippetAsync(
        string filePath,
        string snippetContent,
        SnippetApplyOptions options,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Preview the result of applying a snippet (without writing to disk).
    /// </summary>
    Task<SnippetApplyPreview> PreviewSnippetAsync(
        string filePath,
        string snippetContent,
        SnippetApplyOptions options,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Detect the indentation style of a file.
    /// </summary>
    Task<IndentationStyle> DetectIndentationAsync(
        string filePath,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Suggest best insert location based on snippet content.
    /// </summary>
    Task<SnippetLocationSuggestion?> SuggestLocationAsync(
        string filePath,
        string snippetContent,
        CancellationToken cancellationToken = default);
}
```

### SnippetApplyResult Model

```csharp
// src/SeniorIntern.Core/Models/SnippetApplyResult.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Result of applying a snippet to a file.
/// </summary>
public sealed class SnippetApplyResult
{
    public bool Success { get; init; }
    public string FilePath { get; init; } = string.Empty;
    public SnippetApplyOptions Options { get; init; } = SnippetApplyOptions.FullReplace;
    public string? BackupPath { get; init; }
    public int LinesModified { get; init; }
    public int LinesAdded { get; init; }
    public int LinesRemoved { get; init; }
    public string? ErrorMessage { get; init; }
    public DiffResult? Diff { get; init; }

    public static SnippetApplyResult Succeeded(
        string filePath,
        SnippetApplyOptions options,
        string? backupPath,
        int linesModified,
        int linesAdded,
        int linesRemoved,
        DiffResult? diff = null) => new()
    {
        Success = true,
        FilePath = filePath,
        Options = options,
        BackupPath = backupPath,
        LinesModified = linesModified,
        LinesAdded = linesAdded,
        LinesRemoved = linesRemoved,
        Diff = diff
    };

    public static SnippetApplyResult Failed(string filePath, string error) => new()
    {
        Success = false,
        FilePath = filePath,
        ErrorMessage = error
    };
}
```

### SnippetApplyPreview Model

```csharp
// src/SeniorIntern.Core/Models/SnippetApplyPreview.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Preview of applying a snippet (without writing to disk).
/// </summary>
public sealed class SnippetApplyPreview
{
    /// <summary>
    /// The resulting file content after applying the snippet.
    /// </summary>
    public string ResultContent { get; init; } = string.Empty;

    /// <summary>
    /// Diff showing the changes.
    /// </summary>
    public DiffResult Diff { get; init; } = null!;

    /// <summary>
    /// Range of lines that will be affected.
    /// </summary>
    public LineRange AffectedRange { get; init; }

    /// <summary>
    /// Number of lines that will be added.
    /// </summary>
    public int LinesAdded { get; init; }

    /// <summary>
    /// Number of lines that will be removed.
    /// </summary>
    public int LinesRemoved { get; init; }

    /// <summary>
    /// Validation warnings (non-fatal).
    /// </summary>
    public IReadOnlyList<string> Warnings { get; init; } = Array.Empty<string>();
}
```

### IndentationStyle Model

```csharp
// src/SeniorIntern.Core/Models/IndentationStyle.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Detected indentation style of a file.
/// </summary>
public sealed record IndentationStyle
{
    /// <summary>
    /// Whether indentation uses tabs.
    /// </summary>
    public bool UseTabs { get; init; }

    /// <summary>
    /// Number of spaces per indent level (if using spaces).
    /// </summary>
    public int SpacesPerIndent { get; init; } = 4;

    /// <summary>
    /// Confidence of detection (0.0 to 1.0).
    /// </summary>
    public double Confidence { get; init; }

    /// <summary>
    /// Get the indentation string for one level.
    /// </summary>
    public string IndentString => UseTabs ? "\t" : new string(' ', SpacesPerIndent);

    /// <summary>
    /// Default 4-space indentation.
    /// </summary>
    public static IndentationStyle Default => new() { UseTabs = false, SpacesPerIndent = 4, Confidence = 0.5 };

    /// <summary>
    /// Tab indentation.
    /// </summary>
    public static IndentationStyle Tabs => new() { UseTabs = true, SpacesPerIndent = 4, Confidence = 1.0 };
}
```

### SnippetLocationSuggestion Model

```csharp
// src/SeniorIntern.Core/Models/SnippetLocationSuggestion.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Suggested location for inserting a snippet.
/// </summary>
public sealed class SnippetLocationSuggestion
{
    /// <summary>
    /// Suggested insert mode.
    /// </summary>
    public SnippetInsertMode SuggestedMode { get; init; }

    /// <summary>
    /// Suggested target line.
    /// </summary>
    public int? SuggestedLine { get; init; }

    /// <summary>
    /// Suggested line range (for replace).
    /// </summary>
    public LineRange? SuggestedRange { get; init; }

    /// <summary>
    /// Confidence of suggestion (0.0 to 1.0).
    /// </summary>
    public double Confidence { get; init; }

    /// <summary>
    /// Reason for the suggestion.
    /// </summary>
    public string Reason { get; init; } = string.Empty;

    /// <summary>
    /// Context text that matched (if any).
    /// </summary>
    public string? MatchedContext { get; init; }
}
```

### SnippetApplyService Implementation

```csharp
// src/SeniorIntern.Services/SnippetApplyService.cs
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using System.Text;
using System.Text.RegularExpressions;

namespace SeniorIntern.Services;

/// <summary>
/// Service for applying code snippets to specific file locations.
/// </summary>
public sealed class SnippetApplyService : ISnippetApplyService
{
    private readonly IDiffService _diffService;
    private readonly IBackupService _backupService;
    private readonly ISettingsService _settingsService;

    public SnippetApplyService(
        IDiffService diffService,
        IBackupService backupService,
        ISettingsService settingsService)
    {
        _diffService = diffService;
        _backupService = backupService;
        _settingsService = settingsService;
    }

    public async Task<SnippetApplyResult> ApplySnippetAsync(
        string filePath,
        string snippetContent,
        SnippetApplyOptions options,
        CancellationToken cancellationToken = default)
    {
        if (!options.IsValid)
            return SnippetApplyResult.Failed(filePath, "Invalid snippet apply options");

        try
        {
            // Preview first to validate
            var preview = await PreviewSnippetAsync(filePath, snippetContent, options, cancellationToken);

            // Create backup if enabled
            var settings = await _settingsService.GetSettingsAsync();
            string? backupPath = null;
            if (settings.CreateBackupBeforeApply && File.Exists(filePath))
            {
                backupPath = await _backupService.CreateBackupAsync(filePath, cancellationToken);
            }

            // Write the result
            await File.WriteAllTextAsync(filePath, preview.ResultContent, cancellationToken);

            return SnippetApplyResult.Succeeded(
                filePath,
                options,
                backupPath,
                linesModified: preview.AffectedRange.LineCount,
                linesAdded: preview.LinesAdded,
                linesRemoved: preview.LinesRemoved,
                diff: preview.Diff);
        }
        catch (Exception ex)
        {
            return SnippetApplyResult.Failed(filePath, ex.Message);
        }
    }

    public async Task<SnippetApplyPreview> PreviewSnippetAsync(
        string filePath,
        string snippetContent,
        SnippetApplyOptions options,
        CancellationToken cancellationToken = default)
    {
        var originalContent = File.Exists(filePath)
            ? await File.ReadAllTextAsync(filePath, cancellationToken)
            : string.Empty;

        var originalLines = originalContent.Split('\n').ToList();
        var snippetLines = snippetContent.Split('\n').ToList();

        // Adjust indentation if needed
        if (options.PreserveIndentation && options.TargetLine.HasValue)
        {
            var targetIndent = GetLineIndentation(originalLines, options.TargetLine.Value);
            snippetLines = AdjustIndentation(snippetLines, targetIndent, options.IndentationOverride);
        }

        // Apply the insert/replace operation
        var (resultLines, affectedRange) = ApplyOperation(originalLines, snippetLines, options);

        // Add blank lines if requested
        if (options.AddBlankLineBefore && affectedRange.StartLine > 1)
        {
            resultLines.Insert(affectedRange.StartLine - 1, string.Empty);
        }
        if (options.AddBlankLineAfter && affectedRange.EndLine < resultLines.Count)
        {
            resultLines.Insert(affectedRange.EndLine, string.Empty);
        }

        var resultContent = string.Join('\n', resultLines);

        // Compute diff
        var diff = _diffService.ComputeDiff(originalContent, resultContent, filePath);

        // Calculate line changes
        var linesAdded = snippetLines.Count;
        var linesRemoved = options.InsertMode switch
        {
            SnippetInsertMode.Replace => options.ReplaceRange?.LineCount ?? 0,
            SnippetInsertMode.ReplaceFile => originalLines.Count,
            _ => 0
        };

        var warnings = new List<string>();
        if (options.ReplaceRange.HasValue && options.ReplaceRange.Value.EndLine > originalLines.Count)
        {
            warnings.Add($"Replace range extends beyond end of file (file has {originalLines.Count} lines)");
        }

        return new SnippetApplyPreview
        {
            ResultContent = resultContent,
            Diff = diff,
            AffectedRange = affectedRange,
            LinesAdded = linesAdded,
            LinesRemoved = linesRemoved,
            Warnings = warnings
        };
    }

    public async Task<IndentationStyle> DetectIndentationAsync(
        string filePath,
        CancellationToken cancellationToken = default)
    {
        if (!File.Exists(filePath))
            return IndentationStyle.Default;

        var content = await File.ReadAllTextAsync(filePath, cancellationToken);
        var lines = content.Split('\n');

        int tabCount = 0;
        int spaceCount = 0;
        var spaceIndents = new Dictionary<int, int>();

        foreach (var line in lines)
        {
            if (string.IsNullOrWhiteSpace(line))
                continue;

            var leadingWhitespace = line.TakeWhile(char.IsWhiteSpace).ToArray();
            if (leadingWhitespace.Length == 0)
                continue;

            if (leadingWhitespace[0] == '\t')
            {
                tabCount++;
            }
            else if (leadingWhitespace[0] == ' ')
            {
                spaceCount++;
                var spaceLen = leadingWhitespace.TakeWhile(c => c == ' ').Count();
                if (!spaceIndents.ContainsKey(spaceLen))
                    spaceIndents[spaceLen] = 0;
                spaceIndents[spaceLen]++;
            }
        }

        if (tabCount > spaceCount)
        {
            return new IndentationStyle
            {
                UseTabs = true,
                Confidence = tabCount / (double)(tabCount + spaceCount)
            };
        }

        // Detect spaces per indent
        var spacesPerIndent = 4;
        if (spaceIndents.Count > 0)
        {
            // Find GCD of indent levels
            var indentLevels = spaceIndents.Keys.Where(k => k > 0).ToList();
            if (indentLevels.Count > 0)
            {
                spacesPerIndent = indentLevels.Aggregate(GCD);
                if (spacesPerIndent == 0) spacesPerIndent = 4;
            }
        }

        return new IndentationStyle
        {
            UseTabs = false,
            SpacesPerIndent = spacesPerIndent,
            Confidence = spaceCount / (double)(tabCount + spaceCount + 1)
        };
    }

    public async Task<SnippetLocationSuggestion?> SuggestLocationAsync(
        string filePath,
        string snippetContent,
        CancellationToken cancellationToken = default)
    {
        if (!File.Exists(filePath))
        {
            return new SnippetLocationSuggestion
            {
                SuggestedMode = SnippetInsertMode.ReplaceFile,
                Confidence = 1.0,
                Reason = "File does not exist - will create new file"
            };
        }

        var fileContent = await File.ReadAllTextAsync(filePath, cancellationToken);
        var fileLines = fileContent.Split('\n');

        // Try to find matching context in the snippet
        // Look for common patterns like method signatures, class declarations, etc.
        var snippetLines = snippetContent.Split('\n');
        var firstMeaningfulLine = snippetLines.FirstOrDefault(l => !string.IsNullOrWhiteSpace(l));

        if (firstMeaningfulLine is null)
            return null;

        // Check if snippet starts with a method/function signature
        var methodPattern = new Regex(@"^\s*(public|private|protected|internal|static|async|override|virtual)*\s*[\w<>\[\],\s]+\s+\w+\s*\(");
        if (methodPattern.IsMatch(firstMeaningfulLine))
        {
            // Look for similar method in the file to replace
            for (int i = 0; i < fileLines.Length; i++)
            {
                if (methodPattern.IsMatch(fileLines[i]))
                {
                    // Found a method - suggest replacing it
                    var methodEnd = FindMethodEnd(fileLines, i);
                    return new SnippetLocationSuggestion
                    {
                        SuggestedMode = SnippetInsertMode.Replace,
                        SuggestedRange = new LineRange(i + 1, methodEnd + 1),
                        Confidence = 0.6,
                        Reason = "Found similar method signature",
                        MatchedContext = fileLines[i].Trim()
                    };
                }
            }

            // No matching method - suggest inserting at end of class
            var lastBrace = Array.LastIndexOf(fileLines, fileLines.LastOrDefault(l => l.Trim() == "}"));
            if (lastBrace > 0)
            {
                return new SnippetLocationSuggestion
                {
                    SuggestedMode = SnippetInsertMode.InsertBefore,
                    SuggestedLine = lastBrace + 1,
                    Confidence = 0.5,
                    Reason = "Insert new method before closing brace"
                };
            }
        }

        // Default: append to end of file
        return new SnippetLocationSuggestion
        {
            SuggestedMode = SnippetInsertMode.Append,
            Confidence = 0.3,
            Reason = "No specific location detected - appending to end"
        };
    }

    private static string GetLineIndentation(List<string> lines, int lineNumber)
    {
        if (lineNumber <= 0 || lineNumber > lines.Count)
            return string.Empty;

        var line = lines[lineNumber - 1];
        var indent = new string(line.TakeWhile(char.IsWhiteSpace).ToArray());
        return indent;
    }

    private static List<string> AdjustIndentation(
        List<string> lines,
        string targetIndent,
        string? indentOverride)
    {
        if (lines.Count == 0)
            return lines;

        // Find minimum indentation in snippet
        var minIndent = lines
            .Where(l => !string.IsNullOrWhiteSpace(l))
            .Select(l => new string(l.TakeWhile(char.IsWhiteSpace).ToArray()))
            .OrderBy(i => i.Length)
            .FirstOrDefault() ?? string.Empty;

        var effectiveIndent = indentOverride ?? targetIndent;

        return lines.Select(line =>
        {
            if (string.IsNullOrWhiteSpace(line))
                return line;

            if (line.StartsWith(minIndent))
            {
                return effectiveIndent + line[minIndent.Length..];
            }
            return effectiveIndent + line;
        }).ToList();
    }

    private static (List<string> ResultLines, LineRange AffectedRange) ApplyOperation(
        List<string> originalLines,
        List<string> snippetLines,
        SnippetApplyOptions options)
    {
        var result = new List<string>(originalLines);
        LineRange affectedRange;

        switch (options.InsertMode)
        {
            case SnippetInsertMode.ReplaceFile:
                result = new List<string>(snippetLines);
                affectedRange = new LineRange(1, snippetLines.Count);
                break;

            case SnippetInsertMode.Replace:
                var range = options.ReplaceRange!.Value;
                var startIdx = Math.Max(0, range.StartLine - 1);
                var endIdx = Math.Min(result.Count, range.EndLine);
                var removeCount = endIdx - startIdx;
                result.RemoveRange(startIdx, removeCount);
                result.InsertRange(startIdx, snippetLines);
                affectedRange = new LineRange(range.StartLine, range.StartLine + snippetLines.Count - 1);
                break;

            case SnippetInsertMode.InsertBefore:
                var beforeIdx = Math.Max(0, options.TargetLine!.Value - 1);
                result.InsertRange(beforeIdx, snippetLines);
                affectedRange = new LineRange(options.TargetLine.Value, options.TargetLine.Value + snippetLines.Count - 1);
                break;

            case SnippetInsertMode.InsertAfter:
                var afterIdx = Math.Min(result.Count, options.TargetLine!.Value);
                result.InsertRange(afterIdx, snippetLines);
                affectedRange = new LineRange(options.TargetLine.Value + 1, options.TargetLine.Value + snippetLines.Count);
                break;

            case SnippetInsertMode.Append:
                var appendStart = result.Count + 1;
                result.AddRange(snippetLines);
                affectedRange = new LineRange(appendStart, appendStart + snippetLines.Count - 1);
                break;

            case SnippetInsertMode.Prepend:
                result.InsertRange(0, snippetLines);
                affectedRange = new LineRange(1, snippetLines.Count);
                break;

            default:
                throw new ArgumentException($"Unknown insert mode: {options.InsertMode}");
        }

        return (result, affectedRange);
    }

    private static int FindMethodEnd(string[] lines, int startLine)
    {
        int braceCount = 0;
        bool foundOpenBrace = false;

        for (int i = startLine; i < lines.Length; i++)
        {
            foreach (var c in lines[i])
            {
                if (c == '{')
                {
                    braceCount++;
                    foundOpenBrace = true;
                }
                else if (c == '}')
                {
                    braceCount--;
                    if (foundOpenBrace && braceCount == 0)
                        return i;
                }
            }
        }

        return lines.Length - 1;
    }

    private static int GCD(int a, int b)
    {
        while (b != 0)
        {
            var temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }
}
```

### Files to Create (v0.4.5d)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/ISnippetApplyService.cs` | Service interface |
| `src/SeniorIntern.Core/Models/SnippetApplyResult.cs` | Apply result model |
| `src/SeniorIntern.Core/Models/SnippetApplyPreview.cs` | Preview model |
| `src/SeniorIntern.Core/Models/IndentationStyle.cs` | Indentation detection |
| `src/SeniorIntern.Core/Models/SnippetLocationSuggestion.cs` | Location suggestion |
| `src/SeniorIntern.Services/SnippetApplyService.cs` | Service implementation |

---

## v0.4.5e: Snippet Options UI

### Objective
Create a popup UI for configuring how to apply a code snippet to a file.

### SnippetApplyOptionsViewModel

```csharp
// src/SeniorIntern.Desktop/ViewModels/SnippetApplyOptionsViewModel.cs
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;

namespace SeniorIntern.Desktop.ViewModels;

public partial class SnippetApplyOptionsViewModel : ViewModelBase
{
    private readonly ISnippetApplyService _snippetApplyService;
    private readonly IDiffService _diffService;

    [ObservableProperty]
    private string _filePath = string.Empty;

    [ObservableProperty]
    private string _snippetContent = string.Empty;

    [ObservableProperty]
    private SnippetInsertMode _insertMode = SnippetInsertMode.ReplaceFile;

    [ObservableProperty]
    private int _targetLine = 1;

    [ObservableProperty]
    private int _startLine = 1;

    [ObservableProperty]
    private int _endLine = 1;

    [ObservableProperty]
    private bool _preserveIndentation = true;

    [ObservableProperty]
    private bool _addBlankLineBefore;

    [ObservableProperty]
    private bool _addBlankLineAfter;

    [ObservableProperty]
    private SnippetApplyPreview? _preview;

    [ObservableProperty]
    private bool _isPreviewLoading;

    [ObservableProperty]
    private string? _errorMessage;

    [ObservableProperty]
    private SnippetLocationSuggestion? _suggestion;

    [ObservableProperty]
    private int _totalLines;

    public bool IsReplaceMode => InsertMode == SnippetInsertMode.Replace;
    public bool IsInsertMode => InsertMode is SnippetInsertMode.InsertBefore or SnippetInsertMode.InsertAfter;
    public bool ShowTargetLine => IsInsertMode;
    public bool ShowRangeInputs => IsReplaceMode;

    public SnippetApplyOptionsViewModel(
        ISnippetApplyService snippetApplyService,
        IDiffService diffService)
    {
        _snippetApplyService = snippetApplyService;
        _diffService = diffService;
    }

    public async Task InitializeAsync(string filePath, string snippetContent)
    {
        FilePath = filePath;
        SnippetContent = snippetContent;

        // Get file line count
        if (File.Exists(filePath))
        {
            var content = await File.ReadAllTextAsync(filePath);
            TotalLines = content.Split('\n').Length;
            EndLine = TotalLines;
        }

        // Get suggestion
        Suggestion = await _snippetApplyService.SuggestLocationAsync(filePath, snippetContent);
        if (Suggestion is not null)
        {
            ApplySuggestion();
        }

        await RefreshPreviewAsync();
    }

    [RelayCommand]
    private void ApplySuggestion()
    {
        if (Suggestion is null) return;

        InsertMode = Suggestion.SuggestedMode;
        if (Suggestion.SuggestedLine.HasValue)
            TargetLine = Suggestion.SuggestedLine.Value;
        if (Suggestion.SuggestedRange.HasValue)
        {
            StartLine = Suggestion.SuggestedRange.Value.StartLine;
            EndLine = Suggestion.SuggestedRange.Value.EndLine;
        }
    }

    [RelayCommand]
    private async Task RefreshPreviewAsync()
    {
        IsPreviewLoading = true;
        ErrorMessage = null;

        try
        {
            var options = BuildOptions();
            if (!options.IsValid)
            {
                ErrorMessage = "Invalid options configuration";
                Preview = null;
                return;
            }

            Preview = await _snippetApplyService.PreviewSnippetAsync(
                FilePath, SnippetContent, options);
        }
        catch (Exception ex)
        {
            ErrorMessage = ex.Message;
            Preview = null;
        }
        finally
        {
            IsPreviewLoading = false;
        }
    }

    [RelayCommand]
    private async Task<SnippetApplyResult?> ApplyAsync()
    {
        var options = BuildOptions();
        if (!options.IsValid)
        {
            ErrorMessage = "Invalid options configuration";
            return null;
        }

        return await _snippetApplyService.ApplySnippetAsync(
            FilePath, SnippetContent, options);
    }

    private SnippetApplyOptions BuildOptions() => new()
    {
        InsertMode = InsertMode,
        TargetLine = IsInsertMode ? TargetLine : null,
        ReplaceRange = IsReplaceMode ? new LineRange(StartLine, EndLine) : null,
        PreserveIndentation = PreserveIndentation,
        AddBlankLineBefore = AddBlankLineBefore,
        AddBlankLineAfter = AddBlankLineAfter
    };

    partial void OnInsertModeChanged(SnippetInsertMode value)
    {
        OnPropertyChanged(nameof(IsReplaceMode));
        OnPropertyChanged(nameof(IsInsertMode));
        OnPropertyChanged(nameof(ShowTargetLine));
        OnPropertyChanged(nameof(ShowRangeInputs));
        _ = RefreshPreviewAsync();
    }

    partial void OnTargetLineChanged(int value) => _ = RefreshPreviewAsync();
    partial void OnStartLineChanged(int value) => _ = RefreshPreviewAsync();
    partial void OnEndLineChanged(int value) => _ = RefreshPreviewAsync();
}
```

### SnippetApplyOptionsPopup View

```xml
<!-- src/SeniorIntern.Desktop/Views/SnippetApplyOptionsPopup.axaml -->
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:vm="using:SeniorIntern.Desktop.ViewModels"
             x:Class="SeniorIntern.Desktop.Views.SnippetApplyOptionsPopup"
             x:DataType="vm:SnippetApplyOptionsViewModel">

    <Border Classes="popup-container" Padding="16" MinWidth="320">
        <Grid RowDefinitions="Auto, Auto, Auto, Auto, *, Auto">
            <!-- Header -->
            <StackPanel Grid.Row="0" Margin="0,0,0,16">
                <TextBlock Text="Apply Snippet Options"
                           FontWeight="SemiBold"
                           FontSize="16" />
                <TextBlock Text="{Binding FilePath}"
                           FontSize="12"
                           Foreground="{DynamicResource TextMuted}"
                           TextTrimming="CharacterEllipsis" />
            </StackPanel>

            <!-- Suggestion Banner -->
            <Border Grid.Row="1"
                    IsVisible="{Binding Suggestion, Converter={x:Static ObjectConverters.IsNotNull}}"
                    Classes="info-banner"
                    Padding="8"
                    Margin="0,0,0,12">
                <Grid ColumnDefinitions="*, Auto">
                    <StackPanel>
                        <TextBlock Text="Suggested Location"
                                   FontWeight="SemiBold"
                                   FontSize="12" />
                        <TextBlock Text="{Binding Suggestion.Reason}"
                                   FontSize="11"
                                   TextWrapping="Wrap"
                                   Foreground="{DynamicResource TextMuted}" />
                    </StackPanel>
                    <Button Grid.Column="1"
                            Content="Use"
                            Command="{Binding ApplySuggestionCommand}"
                            Classes="accent small" />
                </Grid>
            </Border>

            <!-- Insert Mode Selection -->
            <StackPanel Grid.Row="2" Spacing="8" Margin="0,0,0,12">
                <TextBlock Text="Insert Mode" FontWeight="SemiBold" />

                <RadioButton Content="Replace entire file"
                             GroupName="InsertMode"
                             IsChecked="{Binding InsertMode,
                                 Converter={StaticResource EnumToBoolConverter},
                                 ConverterParameter=ReplaceFile}" />

                <RadioButton Content="Replace specific lines"
                             GroupName="InsertMode"
                             IsChecked="{Binding InsertMode,
                                 Converter={StaticResource EnumToBoolConverter},
                                 ConverterParameter=Replace}" />

                <!-- Line Range Inputs -->
                <Grid ColumnDefinitions="Auto, 80, Auto, 80"
                      Margin="24,4,0,0"
                      IsVisible="{Binding ShowRangeInputs}">
                    <TextBlock Text="From line:"
                               VerticalAlignment="Center" />
                    <NumericUpDown Grid.Column="1"
                                   Value="{Binding StartLine}"
                                   Minimum="1"
                                   Maximum="{Binding TotalLines}"
                                   Margin="8,0" />
                    <TextBlock Grid.Column="2"
                               Text="to:"
                               VerticalAlignment="Center" />
                    <NumericUpDown Grid.Column="3"
                                   Value="{Binding EndLine}"
                                   Minimum="{Binding StartLine}"
                                   Maximum="{Binding TotalLines}"
                                   Margin="8,0" />
                </Grid>

                <RadioButton Content="Insert after line"
                             GroupName="InsertMode"
                             IsChecked="{Binding InsertMode,
                                 Converter={StaticResource EnumToBoolConverter},
                                 ConverterParameter=InsertAfter}" />

                <RadioButton Content="Insert before line"
                             GroupName="InsertMode"
                             IsChecked="{Binding InsertMode,
                                 Converter={StaticResource EnumToBoolConverter},
                                 ConverterParameter=InsertBefore}" />

                <!-- Target Line Input -->
                <Grid ColumnDefinitions="Auto, 80"
                      Margin="24,4,0,0"
                      IsVisible="{Binding ShowTargetLine}">
                    <TextBlock Text="Line:"
                               VerticalAlignment="Center" />
                    <NumericUpDown Grid.Column="1"
                                   Value="{Binding TargetLine}"
                                   Minimum="1"
                                   Maximum="{Binding TotalLines}"
                                   Margin="8,0" />
                </Grid>

                <RadioButton Content="Append to end of file"
                             GroupName="InsertMode"
                             IsChecked="{Binding InsertMode,
                                 Converter={StaticResource EnumToBoolConverter},
                                 ConverterParameter=Append}" />

                <RadioButton Content="Prepend to beginning"
                             GroupName="InsertMode"
                             IsChecked="{Binding InsertMode,
                                 Converter={StaticResource EnumToBoolConverter},
                                 ConverterParameter=Prepend}" />
            </StackPanel>

            <!-- Additional Options -->
            <StackPanel Grid.Row="3" Spacing="4" Margin="0,0,0,12">
                <TextBlock Text="Options" FontWeight="SemiBold" />

                <CheckBox Content="Preserve target indentation"
                          IsChecked="{Binding PreserveIndentation}" />

                <CheckBox Content="Add blank line before"
                          IsChecked="{Binding AddBlankLineBefore}" />

                <CheckBox Content="Add blank line after"
                          IsChecked="{Binding AddBlankLineAfter}" />
            </StackPanel>

            <!-- Preview -->
            <Border Grid.Row="4"
                    Classes="preview-container"
                    MinHeight="150"
                    Margin="0,0,0,12">
                <Grid>
                    <!-- Loading -->
                    <StackPanel IsVisible="{Binding IsPreviewLoading}"
                                HorizontalAlignment="Center"
                                VerticalAlignment="Center">
                        <ProgressRing IsActive="True" Width="24" Height="24" />
                        <TextBlock Text="Computing preview..."
                                   FontSize="12"
                                   Margin="0,8,0,0" />
                    </StackPanel>

                    <!-- Error -->
                    <TextBlock IsVisible="{Binding ErrorMessage, Converter={x:Static StringConverters.IsNotNullOrEmpty}}"
                               Text="{Binding ErrorMessage}"
                               Foreground="{DynamicResource ErrorBrush}"
                               TextWrapping="Wrap"
                               Padding="8" />

                    <!-- Preview Stats -->
                    <StackPanel IsVisible="{Binding Preview, Converter={x:Static ObjectConverters.IsNotNull}}"
                                Padding="8">
                        <TextBlock FontWeight="SemiBold" Text="Preview" />
                        <StackPanel Orientation="Horizontal" Spacing="16" Margin="0,8">
                            <StackPanel Orientation="Horizontal" Spacing="4">
                                <TextBlock Text="+" Foreground="{DynamicResource AdditionBrush}" />
                                <TextBlock Text="{Binding Preview.LinesAdded}" />
                                <TextBlock Text="lines" Foreground="{DynamicResource TextMuted}" />
                            </StackPanel>
                            <StackPanel Orientation="Horizontal" Spacing="4">
                                <TextBlock Text="-" Foreground="{DynamicResource DeletionBrush}" />
                                <TextBlock Text="{Binding Preview.LinesRemoved}" />
                                <TextBlock Text="lines" Foreground="{DynamicResource TextMuted}" />
                            </StackPanel>
                        </StackPanel>

                        <!-- Warnings -->
                        <ItemsControl ItemsSource="{Binding Preview.Warnings}"
                                      IsVisible="{Binding Preview.Warnings.Count}">
                            <ItemsControl.ItemTemplate>
                                <DataTemplate>
                                    <TextBlock Text="{Binding}"
                                               Foreground="{DynamicResource WarningBrush}"
                                               FontSize="12"
                                               Margin="0,2" />
                                </DataTemplate>
                            </ItemsControl.ItemTemplate>
                        </ItemsControl>
                    </StackPanel>
                </Grid>
            </Border>

            <!-- Actions -->
            <StackPanel Grid.Row="5"
                        Orientation="Horizontal"
                        HorizontalAlignment="Right"
                        Spacing="8">
                <Button Content="Preview Diff"
                        Command="{Binding RefreshPreviewCommand}" />
                <Button Content="Apply"
                        Command="{Binding ApplyCommand}"
                        Classes="accent"
                        IsEnabled="{Binding Preview, Converter={x:Static ObjectConverters.IsNotNull}}" />
            </StackPanel>
        </Grid>
    </Border>
</UserControl>
```

### Code-Behind

```csharp
// src/SeniorIntern.Desktop/Views/SnippetApplyOptionsPopup.axaml.cs
using Avalonia.Controls;

namespace SeniorIntern.Desktop.Views;

public partial class SnippetApplyOptionsPopup : UserControl
{
    public SnippetApplyOptionsPopup()
    {
        InitializeComponent();
    }
}
```

### Files to Create (v0.4.5e)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/ViewModels/SnippetApplyOptionsViewModel.cs` | Options ViewModel |
| `src/SeniorIntern.Desktop/Views/SnippetApplyOptionsPopup.axaml` | Options popup XAML |
| `src/SeniorIntern.Desktop/Views/SnippetApplyOptionsPopup.axaml.cs` | Options popup code-behind |

---

## v0.4.5f: Keyboard Shortcuts

### Objective
Implement global and context-specific keyboard shortcuts for power users.

### KeyboardShortcutService

```csharp
// src/SeniorIntern.Services/KeyboardShortcutService.cs
using Avalonia.Input;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using System.Collections.Concurrent;

namespace SeniorIntern.Services;

/// <summary>
/// Manages keyboard shortcuts and their handlers.
/// </summary>
public sealed class KeyboardShortcutService : IKeyboardShortcutService
{
    private readonly ConcurrentDictionary<KeyboardShortcut, ShortcutHandler> _handlers = new();
    private readonly ConcurrentDictionary<string, List<KeyboardShortcut>> _contextShortcuts = new();

    public KeyboardShortcutService()
    {
        RegisterDefaultShortcuts();
    }

    private void RegisterDefaultShortcuts()
    {
        // Global shortcuts
        Register(new KeyboardShortcut(Key.A, KeyModifiers.Control | KeyModifiers.Shift),
            "ApplyAllChanges", "Apply all pending changes", ShortcutContext.Global);

        Register(new KeyboardShortcut(Key.D, KeyModifiers.Control | KeyModifiers.Shift),
            "ShowDiff", "Show diff for selected code block", ShortcutContext.Global);

        Register(new KeyboardShortcut(Key.U, KeyModifiers.Control | KeyModifiers.Shift),
            "UndoLastChange", "Undo last file change", ShortcutContext.Global);

        Register(new KeyboardShortcut(Key.Z, KeyModifiers.Control | KeyModifiers.Shift),
            "UndoLastChange", "Undo last file change", ShortcutContext.Global);

        // Diff viewer shortcuts
        Register(new KeyboardShortcut(Key.Enter, KeyModifiers.None),
            "ApplyChanges", "Apply changes", ShortcutContext.DiffViewer);

        Register(new KeyboardShortcut(Key.Escape, KeyModifiers.None),
            "CloseDiff", "Close diff viewer", ShortcutContext.DiffViewer);

        Register(new KeyboardShortcut(Key.Up, KeyModifiers.None),
            "PreviousHunk", "Navigate to previous hunk", ShortcutContext.DiffViewer);

        Register(new KeyboardShortcut(Key.Down, KeyModifiers.None),
            "NextHunk", "Navigate to next hunk", ShortcutContext.DiffViewer);

        Register(new KeyboardShortcut(Key.J, KeyModifiers.None),
            "NextHunk", "Navigate to next hunk", ShortcutContext.DiffViewer);

        Register(new KeyboardShortcut(Key.K, KeyModifiers.None),
            "PreviousHunk", "Navigate to previous hunk", ShortcutContext.DiffViewer);

        // Code block shortcuts
        Register(new KeyboardShortcut(Key.Enter, KeyModifiers.Control),
            "ApplyBlock", "Apply code block", ShortcutContext.CodeBlock);

        Register(new KeyboardShortcut(Key.C, KeyModifiers.Control),
            "CopyBlock", "Copy code block", ShortcutContext.CodeBlock);

        Register(new KeyboardShortcut(Key.D, KeyModifiers.Control),
            "ShowBlockDiff", "Show diff", ShortcutContext.CodeBlock);

        // Chat view shortcuts
        Register(new KeyboardShortcut(Key.Enter, KeyModifiers.Control),
            "SendMessage", "Send message", ShortcutContext.ChatInput);

        Register(new KeyboardShortcut(Key.Escape, KeyModifiers.None),
            "CancelGeneration", "Cancel generation", ShortcutContext.ChatInput);
    }

    public void Register(KeyboardShortcut shortcut, string actionId, string description, ShortcutContext context)
    {
        var handler = new ShortcutHandler
        {
            Shortcut = shortcut,
            ActionId = actionId,
            Description = description,
            Context = context
        };

        _handlers[shortcut] = handler;

        var contextKey = context.ToString();
        if (!_contextShortcuts.ContainsKey(contextKey))
            _contextShortcuts[contextKey] = new List<KeyboardShortcut>();

        _contextShortcuts[contextKey].Add(shortcut);
    }

    public void Unregister(KeyboardShortcut shortcut)
    {
        if (_handlers.TryRemove(shortcut, out var handler))
        {
            var contextKey = handler.Context.ToString();
            if (_contextShortcuts.TryGetValue(contextKey, out var shortcuts))
            {
                shortcuts.Remove(shortcut);
            }
        }
    }

    public ShortcutHandler? GetHandler(KeyboardShortcut shortcut)
    {
        return _handlers.TryGetValue(shortcut, out var handler) ? handler : null;
    }

    public IEnumerable<ShortcutHandler> GetHandlersForContext(ShortcutContext context)
    {
        var contextKey = context.ToString();
        if (_contextShortcuts.TryGetValue(contextKey, out var shortcuts))
        {
            return shortcuts
                .Select(s => _handlers.TryGetValue(s, out var h) ? h : null)
                .Where(h => h is not null)!;
        }
        return Enumerable.Empty<ShortcutHandler>();
    }

    public IEnumerable<ShortcutHandler> GetAllHandlers() => _handlers.Values;

    public bool TryHandle(Key key, KeyModifiers modifiers, ShortcutContext context, out string? actionId)
    {
        var shortcut = new KeyboardShortcut(key, modifiers);

        // Try context-specific first
        if (_handlers.TryGetValue(shortcut, out var handler) &&
            (handler.Context == context || handler.Context == ShortcutContext.Global))
        {
            actionId = handler.ActionId;
            return true;
        }

        actionId = null;
        return false;
    }
}
```

### KeyboardShortcut Model

```csharp
// src/SeniorIntern.Core/Models/KeyboardShortcut.cs
using Avalonia.Input;

namespace SeniorIntern.Core.Models;

/// <summary>
/// Represents a keyboard shortcut combination.
/// </summary>
public readonly struct KeyboardShortcut : IEquatable<KeyboardShortcut>
{
    public Key Key { get; init; }
    public KeyModifiers Modifiers { get; init; }

    public KeyboardShortcut(Key key, KeyModifiers modifiers = KeyModifiers.None)
    {
        Key = key;
        Modifiers = modifiers;
    }

    public bool Equals(KeyboardShortcut other) =>
        Key == other.Key && Modifiers == other.Modifiers;

    public override bool Equals(object? obj) =>
        obj is KeyboardShortcut other && Equals(other);

    public override int GetHashCode() => HashCode.Combine(Key, Modifiers);

    public override string ToString()
    {
        var parts = new List<string>();

        if (Modifiers.HasFlag(KeyModifiers.Control))
            parts.Add("Ctrl");
        if (Modifiers.HasFlag(KeyModifiers.Shift))
            parts.Add("Shift");
        if (Modifiers.HasFlag(KeyModifiers.Alt))
            parts.Add("Alt");
        if (Modifiers.HasFlag(KeyModifiers.Meta))
            parts.Add("Cmd");

        parts.Add(Key.ToString());
        return string.Join("+", parts);
    }

    public static bool operator ==(KeyboardShortcut left, KeyboardShortcut right) => left.Equals(right);
    public static bool operator !=(KeyboardShortcut left, KeyboardShortcut right) => !left.Equals(right);
}

/// <summary>
/// Context where a shortcut is active.
/// </summary>
public enum ShortcutContext
{
    Global,
    ChatInput,
    ChatView,
    CodeBlock,
    DiffViewer,
    FileTree
}

/// <summary>
/// Handler for a keyboard shortcut.
/// </summary>
public sealed class ShortcutHandler
{
    public KeyboardShortcut Shortcut { get; init; }
    public string ActionId { get; init; } = string.Empty;
    public string Description { get; init; } = string.Empty;
    public ShortcutContext Context { get; init; }
    public bool IsEnabled { get; set; } = true;
}
```

### IKeyboardShortcutService Interface

```csharp
// src/SeniorIntern.Core/Interfaces/IKeyboardShortcutService.cs
using Avalonia.Input;
using SeniorIntern.Core.Models;

namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Service for managing keyboard shortcuts.
/// </summary>
public interface IKeyboardShortcutService
{
    void Register(KeyboardShortcut shortcut, string actionId, string description, ShortcutContext context);
    void Unregister(KeyboardShortcut shortcut);
    ShortcutHandler? GetHandler(KeyboardShortcut shortcut);
    IEnumerable<ShortcutHandler> GetHandlersForContext(ShortcutContext context);
    IEnumerable<ShortcutHandler> GetAllHandlers();
    bool TryHandle(Key key, KeyModifiers modifiers, ShortcutContext context, out string? actionId);
}
```

### MainWindow Keyboard Integration

```csharp
// src/SeniorIntern.Desktop/Views/MainWindow.axaml.cs (additions)
public partial class MainWindow : Window
{
    private readonly IKeyboardShortcutService _shortcutService;

    protected override void OnKeyDown(KeyEventArgs e)
    {
        base.OnKeyDown(e);

        var context = DetermineCurrentContext();

        if (_shortcutService.TryHandle(e.Key, e.KeyModifiers, context, out var actionId))
        {
            e.Handled = true;
            _ = HandleShortcutActionAsync(actionId!);
        }
    }

    private ShortcutContext DetermineCurrentContext()
    {
        // Determine based on focused element
        var focused = FocusManager?.GetFocusedElement();

        return focused switch
        {
            TextBox tb when tb.Name == "ChatInput" => ShortcutContext.ChatInput,
            _ when IsInDiffViewer() => ShortcutContext.DiffViewer,
            _ when IsInCodeBlock() => ShortcutContext.CodeBlock,
            _ => ShortcutContext.Global
        };
    }

    private async Task HandleShortcutActionAsync(string actionId)
    {
        var vm = DataContext as MainWindowViewModel;
        if (vm is null) return;

        switch (actionId)
        {
            case "ApplyAllChanges":
                await vm.ApplyAllPendingChangesCommand.ExecuteAsync(null);
                break;
            case "ShowDiff":
                await vm.ShowSelectedDiffCommand.ExecuteAsync(null);
                break;
            case "UndoLastChange":
                await vm.UndoLastChangeCommand.ExecuteAsync(null);
                break;
            case "SendMessage":
                await vm.ChatViewModel.SendMessageCommand.ExecuteAsync(null);
                break;
            case "CancelGeneration":
                vm.ChatViewModel.CancelGenerationCommand.Execute(null);
                break;
            // Add more action handlers...
        }
    }

    private bool IsInDiffViewer() => /* check if diff viewer is focused */;
    private bool IsInCodeBlock() => /* check if code block is focused */;
}
```

### Files to Create (v0.4.5f)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Models/KeyboardShortcut.cs` | Shortcut model and enums |
| `src/SeniorIntern.Core/Interfaces/IKeyboardShortcutService.cs` | Service interface |
| `src/SeniorIntern.Services/KeyboardShortcutService.cs` | Shortcut service |

### Files to Modify (v0.4.5f)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/Views/MainWindow.axaml.cs` | Add keyboard handling |
| `src/SeniorIntern.Desktop/ViewModels/MainWindowViewModel.cs` | Add shortcut action commands |

---

## v0.4.5g: Quick Actions

### Objective
Add inline action buttons to code blocks for quick apply, copy, diff, and open operations.

### CodeBlockQuickActionsViewModel

```csharp
// src/SeniorIntern.Desktop/ViewModels/CodeBlockQuickActionsViewModel.cs
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;

namespace SeniorIntern.Desktop.ViewModels;

public partial class CodeBlockQuickActionsViewModel : ViewModelBase
{
    private readonly IFileChangeService _fileChangeService;
    private readonly IDiffService _diffService;
    private readonly IClipboardService _clipboardService;
    private readonly IEditorService _editorService;

    [ObservableProperty]
    private CodeBlock? _codeBlock;

    [ObservableProperty]
    private bool _isApplying;

    [ObservableProperty]
    private bool _isCopied;

    [ObservableProperty]
    private string? _statusMessage;

    [ObservableProperty]
    private bool _hasError;

    public bool CanApply => CodeBlock?.IsApplicable == true &&
                            !string.IsNullOrEmpty(CodeBlock?.TargetFilePath);

    public bool CanShowDiff => CanApply;

    public bool CanOpenInEditor => !string.IsNullOrEmpty(CodeBlock?.TargetFilePath) &&
                                   File.Exists(GetFullPath());

    public CodeBlockQuickActionsViewModel(
        IFileChangeService fileChangeService,
        IDiffService diffService,
        IClipboardService clipboardService,
        IEditorService editorService)
    {
        _fileChangeService = fileChangeService;
        _diffService = diffService;
        _clipboardService = clipboardService;
        _editorService = editorService;
    }

    [RelayCommand(CanExecute = nameof(CanApply))]
    private async Task ApplyAsync()
    {
        if (CodeBlock is null) return;

        IsApplying = true;
        HasError = false;
        StatusMessage = null;

        try
        {
            var result = await _fileChangeService.ApplyCodeBlockAsync(
                CodeBlock, ApplyOptions.Default);

            if (result.Success)
            {
                StatusMessage = "Applied!";
                CodeBlock.Status = CodeBlockStatus.Applied;
            }
            else
            {
                HasError = true;
                StatusMessage = result.ErrorMessage ?? "Apply failed";
            }
        }
        catch (Exception ex)
        {
            HasError = true;
            StatusMessage = ex.Message;
        }
        finally
        {
            IsApplying = false;
            await ClearStatusAfterDelayAsync();
        }
    }

    [RelayCommand]
    private async Task CopyAsync()
    {
        if (CodeBlock is null) return;

        await _clipboardService.SetTextAsync(CodeBlock.Content);
        IsCopied = true;
        StatusMessage = "Copied!";

        await ClearStatusAfterDelayAsync();
        IsCopied = false;
    }

    [RelayCommand(CanExecute = nameof(CanShowDiff))]
    private async Task ShowDiffAsync()
    {
        if (CodeBlock is null) return;

        // Raise event to show diff panel
        OnShowDiffRequested?.Invoke(this, CodeBlock);
    }

    [RelayCommand(CanExecute = nameof(CanOpenInEditor))]
    private async Task OpenInEditorAsync()
    {
        if (CodeBlock?.TargetFilePath is null) return;

        var fullPath = GetFullPath();
        if (File.Exists(fullPath))
        {
            await _editorService.OpenFileAsync(fullPath);
        }
    }

    [RelayCommand]
    private void ShowMoreOptions()
    {
        // Raise event to show options popup
        OnShowOptionsRequested?.Invoke(this, CodeBlock!);
    }

    public event EventHandler<CodeBlock>? OnShowDiffRequested;
    public event EventHandler<CodeBlock>? OnShowOptionsRequested;

    private string GetFullPath()
    {
        // Would need workspace context to compute full path
        return CodeBlock?.TargetFilePath ?? string.Empty;
    }

    private async Task ClearStatusAfterDelayAsync()
    {
        await Task.Delay(2000);
        StatusMessage = null;
        HasError = false;
    }

    partial void OnCodeBlockChanged(CodeBlock? value)
    {
        ApplyCommand.NotifyCanExecuteChanged();
        ShowDiffCommand.NotifyCanExecuteChanged();
        OpenInEditorCommand.NotifyCanExecuteChanged();
    }
}
```

### CodeBlockQuickActions View

```xml
<!-- src/SeniorIntern.Desktop/Views/CodeBlockQuickActions.axaml -->
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:vm="using:SeniorIntern.Desktop.ViewModels"
             x:Class="SeniorIntern.Desktop.Views.CodeBlockQuickActions"
             x:DataType="vm:CodeBlockQuickActionsViewModel">

    <Border Classes="quick-actions-container"
            Background="{DynamicResource CodeBlockHeaderBackground}"
            CornerRadius="0,0,4,4"
            Padding="4">
        <Grid ColumnDefinitions="*, Auto">
            <!-- Status Message -->
            <StackPanel Orientation="Horizontal"
                        Spacing="4"
                        VerticalAlignment="Center">
                <!-- Success/Error indicator -->
                <PathIcon IsVisible="{Binding StatusMessage, Converter={x:Static StringConverters.IsNotNullOrEmpty}}"
                          Width="12" Height="12"
                          Data="{Binding HasError,
                              Converter={StaticResource BoolToIconConverter},
                              ConverterParameter=ErrorIcon|CheckIcon}"
                          Foreground="{Binding HasError,
                              Converter={StaticResource BoolToBrushConverter},
                              ConverterParameter=ErrorBrush|SuccessBrush}" />

                <TextBlock Text="{Binding StatusMessage}"
                           FontSize="11"
                           VerticalAlignment="Center"
                           IsVisible="{Binding StatusMessage, Converter={x:Static StringConverters.IsNotNullOrEmpty}}" />

                <!-- File path preview -->
                <TextBlock Text="{Binding CodeBlock.TargetFilePath}"
                           FontSize="11"
                           Foreground="{DynamicResource TextMuted}"
                           IsVisible="{Binding StatusMessage, Converter={x:Static StringConverters.IsNullOrEmpty}}"
                           TextTrimming="CharacterEllipsis"
                           MaxWidth="200" />
            </StackPanel>

            <!-- Action Buttons -->
            <StackPanel Grid.Column="1"
                        Orientation="Horizontal"
                        Spacing="2">
                <!-- Apply Button -->
                <Button ToolTip.Tip="Apply (Ctrl+Enter)"
                        Command="{Binding ApplyCommand}"
                        Classes="icon-button"
                        IsEnabled="{Binding CanApply}">
                    <Panel>
                        <ProgressRing IsVisible="{Binding IsApplying}"
                                      Width="14" Height="14"
                                      IsActive="True" />
                        <PathIcon IsVisible="{Binding !IsApplying}"
                                  Data="{StaticResource CheckIcon}"
                                  Width="14" Height="14" />
                    </Panel>
                </Button>

                <!-- Copy Button -->
                <Button ToolTip.Tip="Copy (Ctrl+C)"
                        Command="{Binding CopyCommand}"
                        Classes="icon-button">
                    <PathIcon Data="{Binding IsCopied,
                                  Converter={StaticResource BoolToIconConverter},
                                  ConverterParameter=CheckIcon|CopyIcon}"
                              Width="14" Height="14" />
                </Button>

                <!-- Show Diff Button -->
                <Button ToolTip.Tip="Show diff (Ctrl+D)"
                        Command="{Binding ShowDiffCommand}"
                        Classes="icon-button"
                        IsEnabled="{Binding CanShowDiff}">
                    <PathIcon Data="{StaticResource DiffIcon}"
                              Width="14" Height="14" />
                </Button>

                <!-- Open in Editor Button -->
                <Button ToolTip.Tip="Open in editor"
                        Command="{Binding OpenInEditorCommand}"
                        Classes="icon-button"
                        IsEnabled="{Binding CanOpenInEditor}">
                    <PathIcon Data="{StaticResource ExternalLinkIcon}"
                              Width="14" Height="14" />
                </Button>

                <!-- More Options Button -->
                <Button ToolTip.Tip="More options"
                        Command="{Binding ShowMoreOptionsCommand}"
                        Classes="icon-button">
                    <PathIcon Data="{StaticResource MoreHorizontalIcon}"
                              Width="14" Height="14" />
                </Button>
            </StackPanel>
        </Grid>
    </Border>
</UserControl>
```

### Code-Behind

```csharp
// src/SeniorIntern.Desktop/Views/CodeBlockQuickActions.axaml.cs
using Avalonia.Controls;

namespace SeniorIntern.Desktop.Views;

public partial class CodeBlockQuickActions : UserControl
{
    public CodeBlockQuickActions()
    {
        InitializeComponent();
    }
}
```

### Files to Create (v0.4.5g)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/ViewModels/CodeBlockQuickActionsViewModel.cs` | Quick actions VM |
| `src/SeniorIntern.Desktop/Views/CodeBlockQuickActions.axaml` | Quick actions view |
| `src/SeniorIntern.Desktop/Views/CodeBlockQuickActions.axaml.cs` | Code-behind |

### Files to Modify (v0.4.5g)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/Views/ChatMessageControl.axaml` | Integrate quick actions into code blocks |

---

## v0.4.5h: Change History Panel

### Objective
Create a panel showing recent file changes with undo capability.

### ChangeHistoryViewModel

```csharp
// src/SeniorIntern.Desktop/ViewModels/ChangeHistoryViewModel.cs
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using System.Collections.ObjectModel;

namespace SeniorIntern.Desktop.ViewModels;

public partial class ChangeHistoryViewModel : ViewModelBase
{
    private readonly IUndoManager _undoManager;
    private readonly IDiffService _diffService;
    private readonly ISettingsService _settingsService;

    [ObservableProperty]
    private ObservableCollection<ChangeHistoryItemViewModel> _recentChanges = new();

    [ObservableProperty]
    private ChangeHistoryItemViewModel? _selectedChange;

    [ObservableProperty]
    private bool _isLoading;

    [ObservableProperty]
    private int _pendingChangesCount;

    public bool HasChanges => RecentChanges.Count > 0;
    public bool HasUndoableChanges => RecentChanges.Any(c => c.CanUndo);

    public ChangeHistoryViewModel(
        IUndoManager undoManager,
        IDiffService diffService,
        ISettingsService settingsService)
    {
        _undoManager = undoManager;
        _diffService = diffService;
        _settingsService = settingsService;

        // Subscribe to undo manager events
        _undoManager.ChangeRecorded += OnChangeRecorded;
        _undoManager.ChangeUndone += OnChangeUndone;
    }

    public async Task LoadHistoryAsync()
    {
        IsLoading = true;

        try
        {
            var settings = await _settingsService.GetSettingsAsync();
            var changes = await _undoManager.GetRecentChangesAsync(settings.MaxChangeHistoryItems);

            RecentChanges.Clear();
            foreach (var change in changes.OrderByDescending(c => c.Timestamp))
            {
                RecentChanges.Add(new ChangeHistoryItemViewModel(change, _undoManager, _diffService));
            }

            UpdateCounts();
        }
        finally
        {
            IsLoading = false;
        }
    }

    [RelayCommand]
    private async Task UndoAllAsync()
    {
        var undoableChanges = RecentChanges.Where(c => c.CanUndo).ToList();

        foreach (var change in undoableChanges)
        {
            await change.UndoCommand.ExecuteAsync(null);
        }

        UpdateCounts();
    }

    [RelayCommand]
    private async Task ClearHistoryAsync()
    {
        await _undoManager.ClearHistoryAsync();
        RecentChanges.Clear();
        UpdateCounts();
    }

    private void OnChangeRecorded(object? sender, FileChangeRecord record)
    {
        var item = new ChangeHistoryItemViewModel(record, _undoManager, _diffService);
        RecentChanges.Insert(0, item);

        // Trim to max items
        while (RecentChanges.Count > 50)
        {
            RecentChanges.RemoveAt(RecentChanges.Count - 1);
        }

        UpdateCounts();
    }

    private void OnChangeUndone(object? sender, FileChangeRecord record)
    {
        var item = RecentChanges.FirstOrDefault(c => c.Record.Id == record.Id);
        if (item is not null)
        {
            item.MarkAsUndone();
        }
        UpdateCounts();
    }

    private void UpdateCounts()
    {
        PendingChangesCount = RecentChanges.Count(c => c.CanUndo);
        OnPropertyChanged(nameof(HasChanges));
        OnPropertyChanged(nameof(HasUndoableChanges));
    }
}
```

### ChangeHistoryItemViewModel

```csharp
// src/SeniorIntern.Desktop/ViewModels/ChangeHistoryItemViewModel.cs
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;

namespace SeniorIntern.Desktop.ViewModels;

public partial class ChangeHistoryItemViewModel : ViewModelBase
{
    private readonly IUndoManager _undoManager;
    private readonly IDiffService _diffService;

    public FileChangeRecord Record { get; }

    [ObservableProperty]
    private bool _canUndo;

    [ObservableProperty]
    private bool _isUndoing;

    [ObservableProperty]
    private bool _wasUndone;

    [ObservableProperty]
    private DiffResult? _diff;

    public string FileName => Path.GetFileName(Record.FilePath);
    public string RelativePath => Record.RelativePath;
    public string RelativeTime => GetRelativeTime(Record.Timestamp);
    public string ChangeTypeLabel => Record.ChangeType switch
    {
        FileChangeType.Created => "Created",
        FileChangeType.Modified => "Modified",
        FileChangeType.Deleted => "Deleted",
        _ => "Changed"
    };

    public string TypeIcon => Record.ChangeType switch
    {
        FileChangeType.Created => "PlusIcon",
        FileChangeType.Modified => "EditIcon",
        FileChangeType.Deleted => "TrashIcon",
        _ => "FileIcon"
    };

    public ChangeHistoryItemViewModel(
        FileChangeRecord record,
        IUndoManager undoManager,
        IDiffService diffService)
    {
        Record = record;
        _undoManager = undoManager;
        _diffService = diffService;

        CanUndo = _undoManager.CanUndo(record);
    }

    [RelayCommand(CanExecute = nameof(CanUndo))]
    private async Task UndoAsync()
    {
        if (!CanUndo) return;

        IsUndoing = true;

        try
        {
            var result = await _undoManager.UndoAsync(Record);
            if (result.Success)
            {
                MarkAsUndone();
            }
        }
        finally
        {
            IsUndoing = false;
        }
    }

    [RelayCommand]
    private async Task ViewDiffAsync()
    {
        if (Diff is not null) return;

        // Load diff for this change
        if (Record.OriginalContent is not null && Record.NewContent is not null)
        {
            Diff = _diffService.ComputeDiff(
                Record.OriginalContent,
                Record.NewContent,
                Record.FilePath);
        }
    }

    public void MarkAsUndone()
    {
        CanUndo = false;
        WasUndone = true;
        UndoCommand.NotifyCanExecuteChanged();
    }

    private static string GetRelativeTime(DateTime timestamp)
    {
        var elapsed = DateTime.UtcNow - timestamp;

        return elapsed.TotalSeconds switch
        {
            < 60 => "Just now",
            < 120 => "1 minute ago",
            < 3600 => $"{(int)elapsed.TotalMinutes} minutes ago",
            < 7200 => "1 hour ago",
            < 86400 => $"{(int)elapsed.TotalHours} hours ago",
            _ => timestamp.ToLocalTime().ToString("g")
        };
    }
}
```

### ChangeHistoryPanel View

```xml
<!-- src/SeniorIntern.Desktop/Views/ChangeHistoryPanel.axaml -->
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:vm="using:SeniorIntern.Desktop.ViewModels"
             x:Class="SeniorIntern.Desktop.Views.ChangeHistoryPanel"
             x:DataType="vm:ChangeHistoryViewModel">

    <Border Classes="panel-container" Padding="0">
        <Grid RowDefinitions="Auto, *, Auto">
            <!-- Header -->
            <Border Grid.Row="0"
                    Classes="panel-header"
                    Padding="12,8">
                <Grid ColumnDefinitions="*, Auto">
                    <StackPanel>
                        <TextBlock Text="Recent Changes"
                                   FontWeight="SemiBold"
                                   FontSize="14" />
                        <TextBlock FontSize="11"
                                   Foreground="{DynamicResource TextMuted}">
                            <Run Text="{Binding PendingChangesCount}" />
                            <Run Text="undoable" />
                        </TextBlock>
                    </StackPanel>

                    <StackPanel Grid.Column="1"
                                Orientation="Horizontal"
                                Spacing="4">
                        <Button ToolTip.Tip="Undo all"
                                Command="{Binding UndoAllCommand}"
                                IsEnabled="{Binding HasUndoableChanges}"
                                Classes="icon-button">
                            <PathIcon Data="{StaticResource UndoAllIcon}"
                                      Width="14" Height="14" />
                        </Button>
                        <Button ToolTip.Tip="Clear history"
                                Command="{Binding ClearHistoryCommand}"
                                IsEnabled="{Binding HasChanges}"
                                Classes="icon-button">
                            <PathIcon Data="{StaticResource TrashIcon}"
                                      Width="14" Height="14" />
                        </Button>
                    </StackPanel>
                </Grid>
            </Border>

            <!-- Loading State -->
            <StackPanel Grid.Row="1"
                        IsVisible="{Binding IsLoading}"
                        HorizontalAlignment="Center"
                        VerticalAlignment="Center">
                <ProgressRing IsActive="True" Width="24" Height="24" />
                <TextBlock Text="Loading history..."
                           FontSize="12"
                           Margin="0,8,0,0" />
            </StackPanel>

            <!-- Empty State -->
            <StackPanel Grid.Row="1"
                        IsVisible="{Binding !HasChanges}"
                        HorizontalAlignment="Center"
                        VerticalAlignment="Center"
                        Opacity="0.5">
                <PathIcon Data="{StaticResource HistoryIcon}"
                          Width="32" Height="32" />
                <TextBlock Text="No recent changes"
                           FontSize="12"
                           Margin="0,8,0,0" />
            </StackPanel>

            <!-- Change List -->
            <ListBox Grid.Row="1"
                     ItemsSource="{Binding RecentChanges}"
                     SelectedItem="{Binding SelectedChange}"
                     IsVisible="{Binding HasChanges}"
                     Classes="history-list">
                <ListBox.ItemTemplate>
                    <DataTemplate DataType="vm:ChangeHistoryItemViewModel">
                        <Grid ColumnDefinitions="Auto, *, Auto, Auto"
                              Margin="4"
                              Opacity="{Binding WasUndone,
                                  Converter={StaticResource BoolToOpacityConverter},
                                  ConverterParameter=0.5|1.0}">
                            <!-- Type Icon -->
                            <PathIcon Data="{Binding TypeIcon, Converter={StaticResource StringToIconConverter}}"
                                      Width="14" Height="14"
                                      Margin="0,0,8,0"
                                      VerticalAlignment="Center" />

                            <!-- File Info -->
                            <StackPanel Grid.Column="1" VerticalAlignment="Center">
                                <TextBlock Text="{Binding FileName}"
                                           FontWeight="Medium"
                                           TextTrimming="CharacterEllipsis" />
                                <StackPanel Orientation="Horizontal" Spacing="8">
                                    <TextBlock Text="{Binding RelativeTime}"
                                               FontSize="11"
                                               Foreground="{DynamicResource TextMuted}" />
                                    <TextBlock Text="{Binding ChangeTypeLabel}"
                                               FontSize="11"
                                               Foreground="{DynamicResource TextMuted}" />
                                </StackPanel>
                            </StackPanel>

                            <!-- Undo Button -->
                            <Button Grid.Column="2"
                                    Content="Undo"
                                    Command="{Binding UndoCommand}"
                                    IsVisible="{Binding CanUndo}"
                                    Classes="small secondary"
                                    Margin="8,0">
                                <Button.IsEnabled>
                                    <MultiBinding Converter="{StaticResource AndConverter}">
                                        <Binding Path="CanUndo" />
                                        <Binding Path="!IsUndoing" />
                                    </MultiBinding>
                                </Button.IsEnabled>
                            </Button>

                            <!-- Undone Badge -->
                            <Border Grid.Column="2"
                                    IsVisible="{Binding WasUndone}"
                                    Classes="badge success"
                                    Margin="8,0">
                                <TextBlock Text="Undone" FontSize="10" />
                            </Border>

                            <!-- View Diff Button -->
                            <Button Grid.Column="3"
                                    ToolTip.Tip="View diff"
                                    Command="{Binding ViewDiffCommand}"
                                    Classes="icon-button">
                                <PathIcon Data="{StaticResource DiffIcon}"
                                          Width="12" Height="12" />
                            </Button>
                        </Grid>
                    </DataTemplate>
                </ListBox.ItemTemplate>
            </ListBox>

            <!-- Summary Footer -->
            <Border Grid.Row="2"
                    Classes="panel-footer"
                    Padding="12,8"
                    IsVisible="{Binding HasChanges}">
                <TextBlock FontSize="11"
                           Foreground="{DynamicResource TextMuted}">
                    <Run Text="{Binding RecentChanges.Count}" />
                    <Run Text="changes in history" />
                </TextBlock>
            </Border>
        </Grid>
    </Border>
</UserControl>
```

### Code-Behind

```csharp
// src/SeniorIntern.Desktop/Views/ChangeHistoryPanel.axaml.cs
using Avalonia.Controls;

namespace SeniorIntern.Desktop.Views;

public partial class ChangeHistoryPanel : UserControl
{
    public ChangeHistoryPanel()
    {
        InitializeComponent();
    }
}
```

### Files to Create (v0.4.5h)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/ViewModels/ChangeHistoryViewModel.cs` | History panel VM |
| `src/SeniorIntern.Desktop/ViewModels/ChangeHistoryItemViewModel.cs` | History item VM |
| `src/SeniorIntern.Desktop/Views/ChangeHistoryPanel.axaml` | History panel view |
| `src/SeniorIntern.Desktop/Views/ChangeHistoryPanel.axaml.cs` | Code-behind |

---

## v0.4.5i: Status Bar Integration

### Objective
Add pending changes indicator to the status bar with click-to-open functionality.

### StatusBarViewModel Updates

```csharp
// src/SeniorIntern.Desktop/ViewModels/StatusBarViewModel.cs (additions)
public partial class StatusBarViewModel : ViewModelBase
{
    private readonly IUndoManager _undoManager;

    [ObservableProperty]
    private int _pendingChangesCount;

    [ObservableProperty]
    private bool _hasPendingChanges;

    public string PendingChangesText => PendingChangesCount switch
    {
        0 => "No pending changes",
        1 => "1 pending change",
        _ => $"{PendingChangesCount} pending changes"
    };

    public StatusBarViewModel(IUndoManager undoManager)
    {
        _undoManager = undoManager;
        _undoManager.ChangeRecorded += (_, _) => UpdatePendingCount();
        _undoManager.ChangeUndone += (_, _) => UpdatePendingCount();
    }

    private void UpdatePendingCount()
    {
        PendingChangesCount = _undoManager.GetUndoableCount();
        HasPendingChanges = PendingChangesCount > 0;
        OnPropertyChanged(nameof(PendingChangesText));
    }

    [RelayCommand]
    private void ShowChangeHistory()
    {
        // Raise event to show history panel
        OnShowChangeHistoryRequested?.Invoke(this, EventArgs.Empty);
    }

    public event EventHandler? OnShowChangeHistoryRequested;
}
```

### Status Bar XAML Updates

```xml
<!-- Addition to MainWindow.axaml status bar section -->
<Border Classes="status-bar" Grid.Row="2">
    <Grid ColumnDefinitions="Auto, *, Auto, Auto, Auto">
        <!-- Model Status -->
        <StackPanel Orientation="Horizontal" Spacing="8">
            <TextBlock Text="Model:" Foreground="{DynamicResource TextMuted}" />
            <TextBlock Text="{Binding ModelStatus}" />
        </StackPanel>

        <!-- Pending Changes Indicator -->
        <Button Grid.Column="2"
                Command="{Binding ShowChangeHistoryCommand}"
                Classes="status-button"
                IsVisible="{Binding HasPendingChanges}"
                ToolTip.Tip="Click to view change history">
            <StackPanel Orientation="Horizontal" Spacing="4">
                <PathIcon Data="{StaticResource EditIcon}"
                          Width="12" Height="12" />
                <TextBlock Text="{Binding PendingChangesText}" />
            </StackPanel>
        </Button>

        <!-- Saved Status -->
        <StackPanel Grid.Column="3"
                    Orientation="Horizontal"
                    Spacing="4"
                    Margin="16,0">
            <PathIcon Data="{StaticResource CheckIcon}"
                      Width="12" Height="12"
                      Foreground="{DynamicResource SuccessBrush}"
                      IsVisible="{Binding IsSaved}" />
            <TextBlock Text="Saved"
                       IsVisible="{Binding IsSaved}" />
        </StackPanel>

        <!-- Temperature -->
        <TextBlock Grid.Column="4"
                   Foreground="{DynamicResource TextMuted}">
            <Run Text="T:" />
            <Run Text="{Binding Temperature, StringFormat=F1}" />
        </TextBlock>
    </Grid>
</Border>
```

### Files to Modify (v0.4.5i)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/ViewModels/StatusBarViewModel.cs` | Add pending changes tracking |
| `src/SeniorIntern.Desktop/Views/MainWindow.axaml` | Add pending changes button to status bar |

---

## Architecture Summary

### Data Flow Diagram

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           v0.4.5 Data Flow                              │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  LLM Streaming ──► CodeBlockParser ──► StreamingDiffCoordinator         │
│        │                                       │                        │
│        │                                       ▼                        │
│        │                              DiffResult (preview)              │
│        │                                       │                        │
│        ▼                                       ▼                        │
│  ChatMessageViewModel ◄──────────────── UI Update                       │
│        │                                                                │
│        │ (user clicks apply)                                            │
│        ▼                                                                │
│  SnippetApplyOptions ──► SnippetApplyService                            │
│                                │                                        │
│                                ▼                                        │
│                         File Modified                                   │
│                                │                                        │
│                                ▼                                        │
│  UndoManager ◄─────── FileChangeRecord                                  │
│        │                                                                │
│        ▼                                                                │
│  ChangeHistoryViewModel ──► ChangeHistoryPanel                          │
│        │                                                                │
│        ▼                                                                │
│  StatusBarViewModel ──► Status Bar UI                                   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### Component Integration

```
┌────────────────────────────────────────────────────────────────────────┐
│                         MainWindow                                      │
├────────────────────────────────────────────────────────────────────────┤
│  ┌──────────────┐  ┌──────────────────────────────────────────────┐   │
│  │   Sidebar    │  │              Content Area                     │   │
│  │              │  │  ┌────────────────────────────────────────┐  │   │
│  │ ┌──────────┐ │  │  │  ChatMessageControl                    │  │   │
│  │ │  Model   │ │  │  │  ┌──────────────────────────────────┐  │  │   │
│  │ │ Selector │ │  │  │  │  Code Block                      │  │  │   │
│  │ └──────────┘ │  │  │  │  ┌────────────────────────────┐  │  │  │   │
│  │              │  │  │  │  │  CodeBlockQuickActions     │  │  │  │   │
│  │ ┌──────────┐ │  │  │  │  │  [Apply][Copy][Diff][Open] │  │  │  │   │
│  │ │  Change  │ │  │  │  │  └────────────────────────────┘  │  │  │   │
│  │ │ History  │ │  │  │  │  + SnippetApplyOptionsPopup      │  │  │   │
│  │ │  Panel   │ │  │  │  └──────────────────────────────────┘  │  │   │
│  │ └──────────┘ │  │  └────────────────────────────────────────┘  │   │
│  └──────────────┘  └──────────────────────────────────────────────┘   │
├────────────────────────────────────────────────────────────────────────┤
│  Status Bar: [Model: name] [📝 3 pending changes] [✓ Saved] [T:0.7]    │
└────────────────────────────────────────────────────────────────────────┘
```

---

## Files Summary

### Files to Create (17 total)

| Sub-Part | File | Purpose |
|----------|------|---------|
| v0.4.5a | `src/SeniorIntern.Core/Models/DiffViewMode.cs` | Diff view mode enum |
| v0.4.5b | `src/SeniorIntern.Core/Models/DiffComputationState.cs` | Streaming diff state |
| v0.4.5b | `src/SeniorIntern.Core/Interfaces/IStreamingDiffCoordinator.cs` | Coordinator interface |
| v0.4.5b | `src/SeniorIntern.Services/StreamingDiffCoordinator.cs` | Coordinator implementation |
| v0.4.5c | `src/SeniorIntern.Core/Models/LineRange.cs` | Line range value type |
| v0.4.5c | `src/SeniorIntern.Core/Models/SnippetInsertMode.cs` | Insert mode enum |
| v0.4.5c | `src/SeniorIntern.Core/Models/SnippetApplyOptions.cs` | Apply options model |
| v0.4.5d | `src/SeniorIntern.Core/Interfaces/ISnippetApplyService.cs` | Service interface |
| v0.4.5d | `src/SeniorIntern.Core/Models/SnippetApplyResult.cs` | Apply result model |
| v0.4.5d | `src/SeniorIntern.Core/Models/SnippetApplyPreview.cs` | Preview model |
| v0.4.5d | `src/SeniorIntern.Core/Models/IndentationStyle.cs` | Indentation detection |
| v0.4.5d | `src/SeniorIntern.Core/Models/SnippetLocationSuggestion.cs` | Location suggestion |
| v0.4.5d | `src/SeniorIntern.Services/SnippetApplyService.cs` | Service implementation |
| v0.4.5e | `src/SeniorIntern.Desktop/ViewModels/SnippetApplyOptionsViewModel.cs` | Options ViewModel |
| v0.4.5e | `src/SeniorIntern.Desktop/Views/SnippetApplyOptionsPopup.axaml` | Options popup XAML |
| v0.4.5e | `src/SeniorIntern.Desktop/Views/SnippetApplyOptionsPopup.axaml.cs` | Popup code-behind |
| v0.4.5f | `src/SeniorIntern.Core/Models/KeyboardShortcut.cs` | Shortcut model |
| v0.4.5f | `src/SeniorIntern.Core/Interfaces/IKeyboardShortcutService.cs` | Shortcut service interface |
| v0.4.5f | `src/SeniorIntern.Services/KeyboardShortcutService.cs` | Shortcut service |
| v0.4.5g | `src/SeniorIntern.Desktop/ViewModels/CodeBlockQuickActionsViewModel.cs` | Quick actions VM |
| v0.4.5g | `src/SeniorIntern.Desktop/Views/CodeBlockQuickActions.axaml` | Quick actions view |
| v0.4.5g | `src/SeniorIntern.Desktop/Views/CodeBlockQuickActions.axaml.cs` | Quick actions code-behind |
| v0.4.5h | `src/SeniorIntern.Desktop/ViewModels/ChangeHistoryViewModel.cs` | History panel VM |
| v0.4.5h | `src/SeniorIntern.Desktop/ViewModels/ChangeHistoryItemViewModel.cs` | History item VM |
| v0.4.5h | `src/SeniorIntern.Desktop/Views/ChangeHistoryPanel.axaml` | History panel view |
| v0.4.5h | `src/SeniorIntern.Desktop/Views/ChangeHistoryPanel.axaml.cs` | History panel code-behind |

### Files to Modify (7 total)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Core/Models/AppSettings.cs` | Add code generation settings |
| `src/SeniorIntern.Desktop/ViewModels/ChatMessageViewModel.cs` | Add streaming diff properties |
| `src/SeniorIntern.Desktop/Views/MainWindow.axaml` | Add keyboard shortcuts, status bar |
| `src/SeniorIntern.Desktop/Views/MainWindow.axaml.cs` | Add keyboard handling |
| `src/SeniorIntern.Desktop/ViewModels/MainWindowViewModel.cs` | Add shortcut action commands |
| `src/SeniorIntern.Desktop/Views/ChatMessageControl.axaml` | Integrate quick actions |
| `src/SeniorIntern.Desktop/ViewModels/StatusBarViewModel.cs` | Add pending changes tracking |

---

## Testing Strategy

### Unit Tests

```csharp
// tests/SeniorIntern.Services.Tests/SnippetApplyServiceTests.cs
[Fact]
public async Task ApplySnippet_ReplaceLines_UpdatesCorrectRange()
{
    // Arrange
    var original = "line1\nline2\nline3\nline4\nline5";
    await File.WriteAllTextAsync(_testFilePath, original);

    var options = SnippetApplyOptions.ReplaceLines(2, 3);
    var snippet = "newline2\nnewline3";

    // Act
    var result = await _service.ApplySnippetAsync(_testFilePath, snippet, options);

    // Assert
    Assert.True(result.Success);
    var content = await File.ReadAllTextAsync(_testFilePath);
    Assert.Equal("line1\nnewline2\nnewline3\nline4\nline5", content);
}

[Fact]
public async Task PreviewSnippet_InsertAfter_ShowsCorrectDiff()
{
    // Arrange
    var original = "line1\nline2\nline3";
    await File.WriteAllTextAsync(_testFilePath, original);

    var options = SnippetApplyOptions.InsertAfterLine(2);
    var snippet = "inserted";

    // Act
    var preview = await _service.PreviewSnippetAsync(_testFilePath, snippet, options);

    // Assert
    Assert.Equal("line1\nline2\ninserted\nline3", preview.ResultContent);
    Assert.Equal(1, preview.LinesAdded);
    Assert.Equal(0, preview.LinesRemoved);
}
```

### Integration Tests

```csharp
[Fact]
public async Task StreamingDiff_UpdatesDuringGeneration()
{
    // Arrange
    var coordinator = new StreamingDiffCoordinator(_diffService, _workspaceService, _settingsService);
    var block = new CodeBlock { Content = "partial", TargetFilePath = "test.cs" };

    // Act - simulate streaming updates
    var diff1 = await coordinator.OnCodeBlockDetectedAsync(block);
    block.Content = "partial content";
    var diff2 = await coordinator.OnCodeBlockUpdatedAsync(block);
    block.Content = "partial content complete";
    var finalDiff = await coordinator.FinalizeBlockDiffAsync(block);

    // Assert
    Assert.NotNull(finalDiff);
    Assert.Contains("complete", finalDiff.NewContent);
}
```

### UI Tests

- Keyboard shortcut activation in different contexts
- Quick action button visibility and state
- Change history panel updates in real-time
- Status bar pending changes indicator
- Snippet options popup interactions

---

## Acceptance Criteria

### v0.4.5a - Settings Models
- [ ] Code generation settings persist across sessions
- [ ] Default values are sensible
- [ ] Settings are accessible from services

### v0.4.5b - Streaming Diff Preview
- [ ] Diff computation starts during streaming
- [ ] Updates debounced to avoid excessive recomputation
- [ ] Final diff computed when streaming completes
- [ ] Loading state shown during computation

### v0.4.5c - Partial Snippet Models
- [ ] LineRange correctly represents line ranges
- [ ] All SnippetInsertMode values handled
- [ ] SnippetApplyOptions validation works

### v0.4.5d - Snippet Apply Service
- [ ] Replace lines works correctly
- [ ] Insert before/after works correctly
- [ ] Append/prepend works correctly
- [ ] Indentation preserved when requested
- [ ] Location suggestions are reasonable

### v0.4.5e - Snippet Options UI
- [ ] All insert modes selectable
- [ ] Line inputs constrained to valid range
- [ ] Preview updates on option changes
- [ ] Apply button disabled when invalid

### v0.4.5f - Keyboard Shortcuts
- [ ] Global shortcuts work from anywhere
- [ ] Context shortcuts only active in context
- [ ] Shortcut conflicts handled gracefully
- [ ] Shortcuts match documented bindings

### v0.4.5g - Quick Actions
- [ ] Apply button shows loading state
- [ ] Copy shows success feedback
- [ ] Diff button opens diff viewer
- [ ] Open in editor works
- [ ] More options shows popup

### v0.4.5h - Change History Panel
- [ ] Recent changes listed in order
- [ ] Undo works for undoable changes
- [ ] View diff shows change details
- [ ] List updates in real-time

### v0.4.5i - Status Bar Integration
- [ ] Pending changes count accurate
- [ ] Click opens history panel
- [ ] Count updates after apply/undo

---

## References

- [v0.4.1 Code Block Extraction](v0.4.1-code-block-extraction.md)
- [v0.4.2 Diff Engine](v0.4.2-diff-engine.md)
- [v0.4.3 Apply Changes Workflow](v0.4.3-apply-changes-workflow.md)
- [v0.4.4 Multi-File Creation](v0.4.4-multi-file-creation.md)
- [Avalonia KeyBindings](https://docs.avaloniaui.net/docs/input/hotkeys)
- [CommunityToolkit.Mvvm RelayCommand](https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/relaycommand)
