# Design Specification: The Senior Intern v0.4.2d "Diff ViewModels"

**Status**: _IMPLEMENTED_

## Executive Summary

This document provides a detailed implementation specification for v0.4.2d, which creates the ViewModels for the diff viewer UI. These ViewModels implement the MVVM pattern to support data binding, commands, and state management for the side-by-side diff visualization.

The diff ViewModels serve as the bridge between the diff computation engine (v0.4.2a-c) and the UI layer (v0.4.2e-h). They transform raw diff data into presentation-ready models, handle user interactions through commands, manage view state like navigation and display options, and emit events for view-specific behaviors.

### v0.4.2d Scope

- Create `DiffViewerViewModel` as the main coordinator for diff display
- Create `DiffHunkViewModel` for individual hunk representation with side-by-side alignment
- Create `DiffLineViewModel` for line-level display with inline segments
- Implement hunk navigation with previous/next commands
- Implement view option toggles (inline changes, word wrap, synchronized scroll)
- Define events for view coordination (scroll requests, apply/reject actions)

### Key Deliverables

| Deliverable | Description |
|-------------|-------------|
| DiffViewerViewModel | Main ViewModel coordinating diff display, navigation, and actions |
| DiffHunkViewModel | Hunk ViewModel with side-by-side line alignment logic |
| DiffLineViewModel | Line ViewModel with inline segment support and computed properties |
| Navigation Commands | NextHunk, PreviousHunk, GoToHunk relay commands |
| View Option Commands | Toggle commands for inline changes, word wrap, sync scroll |
| Coordination Events | HunkNavigationRequested, ApplyRequested, RejectRequested events |

---

## Feature Overview

```
┌──────────────────────────────────────────────────────────────────┐
│                     v0.4.2d Feature Tree                          │
├──────────────────────────────────────────────────────────────────┤
│                                                                   │
│  Diff ViewModels                                                  │
│  ├── DiffViewerViewModel                                          │
│  │   ├── Diff Loading                                             │
│  │   │   ├── LoadDiffAsync(CodeBlock, workspacePath)              │
│  │   │   ├── LoadDiff(DiffResult)                                 │
│  │   │   └── SetDiffResult() - internal state setup               │
│  │   │                                                            │
│  │   ├── Observable Properties                                    │
│  │   │   ├── DiffResult, SourceBlock, FilePath, FileName          │
│  │   │   ├── Language, IsNewFile, IsLoading, ErrorMessage         │
│  │   │   ├── ShowInlineChanges, WordWrap, SynchronizedScroll      │
│  │   │   ├── ShowLineNumbers, ContextLines                        │
│  │   │   ├── CurrentHunkIndex, TotalHunks, Hunks collection       │
│  │   │   └── OriginalScrollOffset, ProposedScrollOffset           │
│  │   │                                                            │
│  │   ├── Computed Properties                                      │
│  │   │   ├── StatsDisplay, HasChanges                             │
│  │   │   └── CanNavigatePrevious, CanNavigateNext                 │
│  │   │                                                            │
│  │   ├── Navigation Commands                                      │
│  │   │   ├── NextHunkCommand, PreviousHunkCommand                 │
│  │   │   └── GoToHunkCommand(index)                               │
│  │   │                                                            │
│  │   ├── Toggle Commands                                          │
│  │   │   ├── ToggleInlineChangesCommand                           │
│  │   │   ├── ToggleWordWrapCommand                                │
│  │   │   └── ToggleSynchronizedScrollCommand                      │
│  │   │                                                            │
│  │   ├── Action Commands                                          │
│  │   │   ├── CopyProposedCommand                                  │
│  │   │   ├── RequestApplyCommand                                  │
│  │   │   └── RequestRejectCommand                                 │
│  │   │                                                            │
│  │   └── Events                                                   │
│  │       ├── HunkNavigationRequested(int index)                   │
│  │       ├── ApplyRequested                                       │
│  │       └── RejectRequested                                      │
│  │                                                                │
│  ├── DiffHunkViewModel                                            │
│  │   ├── Properties (Id, Index, Header, ContextHeader)            │
│  │   ├── OriginalLines, ProposedLines collections                 │
│  │   ├── ShowInlineChanges, IsExpanded flags                      │
│  │   ├── AddedCount, RemovedCount statistics                      │
│  │   └── BuildSideBySideLines() - alignment algorithm             │
│  │                                                                │
│  └── DiffLineViewModel                                            │
│      ├── Properties (LineNumber, Content, Type, Side)             │
│      ├── InlineSegments collection                                │
│      ├── IsPlaceholder, IsHighlighted flags                       │
│      └── Computed: HasInlineSegments, LineNumberDisplay           │
│                                                                   │
└──────────────────────────────────────────────────────────────────┘
```

---

## Architecture Diagrams

### ViewModel Hierarchy

```
┌─────────────────────────────────────────────────────────────────┐
│                    ViewModel Hierarchy                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌────────────────────────────────────────────────────────┐      │
│  │              DiffViewerViewModel                        │      │
│  │  ┌──────────────────────────────────────────────────┐  │      │
│  │  │  Properties:                                      │  │      │
│  │  │    - DiffResult                                   │  │      │
│  │  │    - FilePath, FileName, Language                 │  │      │
│  │  │    - CurrentHunkIndex, TotalHunks                 │  │      │
│  │  │    - View options (ShowInlineChanges, etc.)       │  │      │
│  │  │                                                   │  │      │
│  │  │  Commands: Next/Previous/GoTo, Toggle, Apply      │  │      │
│  │  │  Events: Navigation, Apply, Reject                │  │      │
│  │  └──────────────────────────────────────────────────┘  │      │
│  │                         │                               │      │
│  │                         │ Contains                      │      │
│  │                         ▼                               │      │
│  │  ┌─────────────────────────────────────────────────┐   │      │
│  │  │  ObservableCollection<DiffHunkViewModel> Hunks  │   │      │
│  │  └─────────────────────────────────────────────────┘   │      │
│  └────────────────────────────┬───────────────────────────┘      │
│                               │                                   │
│                               │ Each hunk contains                │
│                               ▼                                   │
│  ┌────────────────────────────────────────────────────────┐      │
│  │              DiffHunkViewModel                          │      │
│  │  ┌──────────────────────────────────────────────────┐  │      │
│  │  │  Properties:                                      │  │      │
│  │  │    - Id, Index, Header, ContextHeader             │  │      │
│  │  │    - ShowInlineChanges, IsExpanded                │  │      │
│  │  │    - AddedCount, RemovedCount                     │  │      │
│  │  │                                                   │  │      │
│  │  │  Method: BuildSideBySideLines(DiffHunk)           │  │      │
│  │  └──────────────────────────────────────────────────┘  │      │
│  │           │                           │                 │      │
│  │           │ OriginalLines             │ ProposedLines   │      │
│  │           ▼                           ▼                 │      │
│  │  ┌──────────────────┐    ┌──────────────────┐          │      │
│  │  │ ObservableCollec │    │ ObservableCollec │          │      │
│  │  │ <DiffLineVM>     │    │ <DiffLineVM>     │          │      │
│  │  └──────────────────┘    └──────────────────┘          │      │
│  └────────────────────────────┬───────────────────────────┘      │
│                               │                                   │
│                               │ Each line is                      │
│                               ▼                                   │
│  ┌────────────────────────────────────────────────────────┐      │
│  │              DiffLineViewModel                          │      │
│  │  ┌──────────────────────────────────────────────────┐  │      │
│  │  │  Properties:                                      │  │      │
│  │  │    - LineNumber?, Content, Type, Side             │  │      │
│  │  │    - InlineSegments (from v0.4.2c)                │  │      │
│  │  │    - IsPlaceholder, IsHighlighted                 │  │      │
│  │  │                                                   │  │      │
│  │  │  Computed: HasInlineSegments, LineNumberDisplay   │  │      │
│  │  │  Computed: IsAdded, IsRemoved, IsModified, etc.   │  │      │
│  │  └──────────────────────────────────────────────────┘  │      │
│  └────────────────────────────────────────────────────────┘      │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Data Flow

```
┌─────────────────────────────────────────────────────────────────┐
│                         Data Flow                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌──────────────┐                                                │
│  │  CodeBlock   │  (from v0.4.1 - Code Block Extraction)        │
│  └──────┬───────┘                                                │
│         │                                                        │
│         ▼                                                        │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │  DiffViewerViewModel.LoadDiffAsync(block, workspacePath)  │   │
│  │                                                           │   │
│  │  1. Set IsLoading = true                                  │   │
│  │  2. Extract FilePath, FileName, Language from block       │   │
│  │  3. Call IDiffService.ComputeDiffForBlockAsync()          │   │
│  │  4. Call SetDiffResult() with result                      │   │
│  │  5. Set IsLoading = false                                 │   │
│  └──────────────────────┬───────────────────────────────────┘   │
│                         │                                        │
│                         ▼                                        │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │  SetDiffResult(DiffResult)                                │   │
│  │                                                           │   │
│  │  1. Store DiffResult                                      │   │
│  │  2. Set IsNewFile, TotalHunks, CurrentHunkIndex = 0       │   │
│  │  3. Clear and rebuild Hunks collection:                   │   │
│  │     foreach (hunk in result.Hunks)                        │   │
│  │       Hunks.Add(new DiffHunkViewModel(hunk, ...))         │   │
│  │  4. Notify StatsDisplay, HasChanges changed               │   │
│  └──────────────────────┬───────────────────────────────────┘   │
│                         │                                        │
│                         ▼                                        │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │  DiffHunkViewModel constructor                            │   │
│  │                                                           │   │
│  │  1. Store hunk properties (Id, Index, Header)             │   │
│  │  2. Calculate AddedCount, RemovedCount                    │   │
│  │  3. Call BuildSideBySideLines(hunk)                       │   │
│  └──────────────────────┬───────────────────────────────────┘   │
│                         │                                        │
│                         ▼                                        │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │  BuildSideBySideLines(DiffHunk)                           │   │
│  │                                                           │   │
│  │  For each DiffLine in hunk:                               │   │
│  │    switch (line.Type)                                     │   │
│  │      Unchanged → Add to both OriginalLines & ProposedLines│   │
│  │      Removed   → Add to OriginalLines, placeholder to Prop│   │
│  │      Added     → Placeholder to Original, add to Proposed │   │
│  │      Modified  → Handle based on line numbers             │   │
│  │                                                           │   │
│  │  Call AlignLists() to ensure equal length                 │   │
│  └──────────────────────┬───────────────────────────────────┘   │
│                         │                                        │
│                         ▼                                        │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │  DiffLineViewModel creation                               │   │
│  │                                                           │   │
│  │  For each line:                                           │   │
│  │    - Set LineNumber, Content, Type, Side                  │   │
│  │    - If HasInlineChanges && ShowInlineChanges:            │   │
│  │        Get segments from IInlineDiffService               │   │
│  │    - Set IsPlaceholder = false (or true for placeholders) │   │
│  └──────────────────────────────────────────────────────────┘   │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Side-by-Side Alignment Algorithm

```
┌─────────────────────────────────────────────────────────────────┐
│              Side-by-Side Alignment Algorithm                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Input: DiffHunk with lines                                      │
│                                                                  │
│  Example Input Lines:                                            │
│    [0] Unchanged: "function foo() {"        (orig:1, prop:1)    │
│    [1] Removed:   "  return 10;"            (orig:2, prop:null) │
│    [2] Added:     "  return 20;"            (orig:null, prop:2) │
│    [3] Unchanged: "}"                       (orig:3, prop:3)    │
│                                                                  │
│  Processing:                                                     │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  Line 0 (Unchanged):                                     │    │
│  │    Original: [1] "function foo() {"                      │    │
│  │    Proposed: [1] "function foo() {"                      │    │
│  ├─────────────────────────────────────────────────────────┤    │
│  │  Line 1 (Removed):                                       │    │
│  │    Original: [2] "  return 10;"   (Removed style)        │    │
│  │    Proposed: [—] <placeholder>    (Empty/dimmed)         │    │
│  ├─────────────────────────────────────────────────────────┤    │
│  │  Line 2 (Added):                                         │    │
│  │    Original: [—] <placeholder>    (Empty/dimmed)         │    │
│  │    Proposed: [2] "  return 20;"   (Added style)          │    │
│  ├─────────────────────────────────────────────────────────┤    │
│  │  Line 3 (Unchanged):                                     │    │
│  │    Original: [3] "}"                                     │    │
│  │    Proposed: [3] "}"                                     │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  Result:                                                         │
│    OriginalLines:  [VM, VM, Placeholder, VM]                    │
│    ProposedLines:  [VM, Placeholder, VM, VM]                    │
│                                                                  │
│  Visual Output:                                                  │
│  ┌─────────────────────┐  ┌─────────────────────┐               │
│  │  ORIGINAL           │  │  PROPOSED           │               │
│  ├─────────────────────┤  ├─────────────────────┤               │
│  │ 1│function foo() {  │  │ 1│function foo() {  │               │
│  │ 2│- return 10;      │  │  │                  │               │
│  │  │                  │  │ 2│+ return 20;      │               │
│  │ 3│}                 │  │ 3│}                 │               │
│  └─────────────────────┘  └─────────────────────┘               │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Command Flow

```
┌─────────────────────────────────────────────────────────────────┐
│                       Command Flow                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Navigation Commands:                                            │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  NextHunkCommand                                         │    │
│  │    ├── Check CanNavigateNext (CurrentHunkIndex < Total-1)│    │
│  │    ├── Increment CurrentHunkIndex                        │    │
│  │    ├── Trigger OnCurrentHunkIndexChanged()               │    │
│  │    │     └── Update CanNavigatePrevious/Next             │    │
│  │    └── Call ScrollToCurrentHunk()                        │    │
│  │          └── Raise HunkNavigationRequested event         │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  Toggle Commands:                                                │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  ToggleInlineChangesCommand                              │    │
│  │    ├── Flip ShowInlineChanges boolean                    │    │
│  │    └── Trigger OnShowInlineChangesChanged()              │    │
│  │          └── Propagate to all DiffHunkViewModels         │    │
│  │                └── Each hunk updates its segments        │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  Action Commands:                                                │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  RequestApplyCommand                                     │    │
│  │    └── Raise ApplyRequested event                        │    │
│  │          └── View/parent handles actual file write       │    │
│  │                                                          │    │
│  │  RequestRejectCommand                                    │    │
│  │    └── Raise RejectRequested event                       │    │
│  │          └── View/parent handles dismissal               │    │
│  │                                                          │    │
│  │  CopyProposedCommand                                     │    │
│  │    └── Copy DiffResult.ProposedContent to clipboard      │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## Prerequisites

Before implementing v0.4.2d, ensure:

- v0.4.2a is complete (Diff models: DiffResult, DiffHunk, DiffLine, etc.)
- v0.4.2b is complete (IDiffService and DiffService implementation)
- v0.4.2c is complete (IInlineDiffService and InlineSegment model)
- CommunityToolkit.Mvvm is available for `[ObservableProperty]` and `[RelayCommand]`
- ViewModelBase class exists in Desktop project

---

## Directory Structure

After v0.4.2d implementation:

```
src/SeniorIntern.Desktop/
├── ViewModels/
│   ├── ViewModelBase.cs                    (existing)
│   ├── MainWindowViewModel.cs              (existing)
│   ├── DiffViewerViewModel.cs              (NEW)
│   ├── DiffHunkViewModel.cs                (NEW)
│   └── DiffLineViewModel.cs                (NEW)
└── ...
```

---

## Detailed Design

### 1. DiffViewerViewModel

**File**: `src/SeniorIntern.Desktop/ViewModels/DiffViewerViewModel.cs`

```csharp
// src/SeniorIntern.Desktop/ViewModels/DiffViewerViewModel.cs
namespace SeniorIntern.Desktop.ViewModels;

using System.Collections.ObjectModel;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;

/// <summary>
/// Main ViewModel for the diff viewer, coordinating diff display, navigation, and user actions.
/// </summary>
/// <remarks>
/// This ViewModel serves as the primary coordinator for the diff viewing experience.
/// It manages:
/// - Loading and displaying diff results from code blocks
/// - Navigation between diff hunks
/// - View options like inline changes, word wrap, and synchronized scrolling
/// - User actions like apply, reject, and copy
/// </remarks>
public partial class DiffViewerViewModel : ViewModelBase
{
    private readonly IDiffService _diffService;
    private readonly IInlineDiffService _inlineDiffService;

    #region Observable Properties - Diff Data

    /// <summary>
    /// The computed diff result being displayed.
    /// </summary>
    [ObservableProperty]
    private DiffResult? _diffResult;

    /// <summary>
    /// The source code block that generated this diff.
    /// </summary>
    [ObservableProperty]
    private CodeBlock? _sourceBlock;

    /// <summary>
    /// Full path to the file being diffed.
    /// </summary>
    [ObservableProperty]
    private string _filePath = string.Empty;

    /// <summary>
    /// File name extracted from the path (for display).
    /// </summary>
    [ObservableProperty]
    private string _fileName = string.Empty;

    /// <summary>
    /// Programming language for syntax highlighting.
    /// </summary>
    [ObservableProperty]
    private string? _language;

    /// <summary>
    /// Whether this diff represents a new file creation.
    /// </summary>
    [ObservableProperty]
    private bool _isNewFile;

    /// <summary>
    /// Whether this diff represents a file deletion.
    /// </summary>
    [ObservableProperty]
    private bool _isDeleteFile;

    #endregion

    #region Observable Properties - Loading State

    /// <summary>
    /// Whether a diff computation is in progress.
    /// </summary>
    [ObservableProperty]
    private bool _isLoading;

    /// <summary>
    /// Error message if diff computation failed.
    /// </summary>
    [ObservableProperty]
    private string? _errorMessage;

    #endregion

    #region Observable Properties - View Options

    /// <summary>
    /// Whether to show character-level inline changes within modified lines.
    /// </summary>
    [ObservableProperty]
    private bool _showInlineChanges = true;

    /// <summary>
    /// Whether to wrap long lines instead of horizontal scrolling.
    /// </summary>
    [ObservableProperty]
    private bool _wordWrap;

    /// <summary>
    /// Whether to synchronize scrolling between original and proposed panels.
    /// </summary>
    [ObservableProperty]
    private bool _synchronizedScroll = true;

    /// <summary>
    /// Whether to display line numbers in the gutter.
    /// </summary>
    [ObservableProperty]
    private bool _showLineNumbers = true;

    /// <summary>
    /// Number of context lines to show around changes.
    /// </summary>
    [ObservableProperty]
    private int _contextLines = 3;

    #endregion

    #region Observable Properties - Navigation

    /// <summary>
    /// Index of the currently focused hunk (0-based).
    /// </summary>
    [ObservableProperty]
    private int _currentHunkIndex;

    /// <summary>
    /// Total number of hunks in the diff.
    /// </summary>
    [ObservableProperty]
    private int _totalHunks;

    /// <summary>
    /// Collection of hunk ViewModels for binding.
    /// </summary>
    [ObservableProperty]
    private ObservableCollection<DiffHunkViewModel> _hunks = new();

    #endregion

    #region Observable Properties - Scroll State

    /// <summary>
    /// Vertical scroll offset for the original panel.
    /// </summary>
    [ObservableProperty]
    private double _originalScrollOffset;

    /// <summary>
    /// Vertical scroll offset for the proposed panel.
    /// </summary>
    [ObservableProperty]
    private double _proposedScrollOffset;

    #endregion

    #region Computed Properties

    /// <summary>
    /// Human-readable summary of diff statistics (e.g., "+10 -5").
    /// </summary>
    public string StatsDisplay => DiffResult?.Stats.Summary ?? string.Empty;

    /// <summary>
    /// Whether this diff contains any changes.
    /// </summary>
    public bool HasChanges => DiffResult?.HasChanges ?? false;

    /// <summary>
    /// Whether navigation to a previous hunk is possible.
    /// </summary>
    public bool CanNavigatePrevious => CurrentHunkIndex > 0;

    /// <summary>
    /// Whether navigation to the next hunk is possible.
    /// </summary>
    public bool CanNavigateNext => CurrentHunkIndex < TotalHunks - 1;

    /// <summary>
    /// Display text for current hunk position (e.g., "2/5").
    /// </summary>
    public string HunkPositionDisplay => TotalHunks > 0
        ? $"{CurrentHunkIndex + 1}/{TotalHunks}"
        : "0/0";

    #endregion

    #region Events

    /// <summary>
    /// Raised when the view should scroll to a specific hunk.
    /// </summary>
    public event EventHandler<int>? HunkNavigationRequested;

    /// <summary>
    /// Raised when the user requests to apply the proposed changes.
    /// </summary>
    public event EventHandler? ApplyRequested;

    /// <summary>
    /// Raised when the user requests to reject/dismiss the diff.
    /// </summary>
    public event EventHandler? RejectRequested;

    /// <summary>
    /// Raised when scroll synchronization is needed.
    /// </summary>
    public event EventHandler<ScrollSyncEventArgs>? ScrollSyncRequested;

    #endregion

    #region Constructor

    /// <summary>
    /// Initializes a new instance of DiffViewerViewModel.
    /// </summary>
    /// <param name="diffService">Service for computing diffs.</param>
    /// <param name="inlineDiffService">Service for inline diff segments.</param>
    public DiffViewerViewModel(
        IDiffService diffService,
        IInlineDiffService inlineDiffService)
    {
        _diffService = diffService ?? throw new ArgumentNullException(nameof(diffService));
        _inlineDiffService = inlineDiffService ?? throw new ArgumentNullException(nameof(inlineDiffService));
    }

    #endregion

    #region Public Methods

    /// <summary>
    /// Load and compute a diff from a code block asynchronously.
    /// </summary>
    /// <param name="block">The code block to diff against the target file.</param>
    /// <param name="workspacePath">Base path for resolving relative file paths.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    public async Task LoadDiffAsync(
        CodeBlock block,
        string workspacePath,
        CancellationToken cancellationToken = default)
    {
        try
        {
            IsLoading = true;
            ErrorMessage = null;

            // Extract metadata from block
            SourceBlock = block;
            FilePath = block.TargetFilePath ?? string.Empty;
            FileName = Path.GetFileName(FilePath);
            Language = block.DisplayLanguage;

            // Compute the diff
            var result = await _diffService.ComputeDiffForBlockAsync(
                block,
                workspacePath,
                cancellationToken);

            SetDiffResult(result);
        }
        catch (OperationCanceledException)
        {
            // Don't set error for cancellation
            throw;
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Failed to compute diff: {ex.Message}";
        }
        finally
        {
            IsLoading = false;
        }
    }

    /// <summary>
    /// Load a pre-computed diff result directly.
    /// </summary>
    /// <param name="result">The diff result to display.</param>
    /// <param name="filePath">Optional file path override.</param>
    public void LoadDiff(DiffResult result, string? filePath = null)
    {
        if (result == null)
            throw new ArgumentNullException(nameof(result));

        FilePath = filePath ?? result.OriginalFilePath;
        FileName = Path.GetFileName(FilePath);

        SetDiffResult(result);
    }

    /// <summary>
    /// Scroll to a specific line number in the diff.
    /// </summary>
    /// <param name="lineNumber">The line number to scroll to.</param>
    /// <param name="side">Which side (Original or Proposed) the line belongs to.</param>
    public void ScrollToLine(int lineNumber, DiffSide side)
    {
        // Find the hunk containing this line
        for (int i = 0; i < Hunks.Count; i++)
        {
            var hunk = Hunks[i];
            var lines = side == DiffSide.Original ? hunk.OriginalLines : hunk.ProposedLines;

            if (lines.Any(l => l.LineNumber == lineNumber))
            {
                CurrentHunkIndex = i;
                ScrollToCurrentHunk();
                return;
            }
        }
    }

    /// <summary>
    /// Clear the current diff and reset state.
    /// </summary>
    public void Clear()
    {
        DiffResult = null;
        SourceBlock = null;
        FilePath = string.Empty;
        FileName = string.Empty;
        Language = null;
        IsNewFile = false;
        IsDeleteFile = false;
        ErrorMessage = null;
        TotalHunks = 0;
        CurrentHunkIndex = 0;
        Hunks.Clear();

        OnPropertyChanged(nameof(StatsDisplay));
        OnPropertyChanged(nameof(HasChanges));
        OnPropertyChanged(nameof(HunkPositionDisplay));
    }

    #endregion

    #region Private Methods

    /// <summary>
    /// Internal method to set diff result and build hunk ViewModels.
    /// </summary>
    private void SetDiffResult(DiffResult result)
    {
        DiffResult = result;
        IsNewFile = result.IsNewFile;
        IsDeleteFile = result.IsDeleteFile;
        TotalHunks = result.Hunks.Count;
        CurrentHunkIndex = 0;

        // Build hunk ViewModels
        Hunks.Clear();
        foreach (var hunk in result.Hunks)
        {
            var hunkVm = new DiffHunkViewModel(
                hunk,
                _inlineDiffService,
                ShowInlineChanges);
            Hunks.Add(hunkVm);
        }

        // Notify computed properties changed
        OnPropertyChanged(nameof(StatsDisplay));
        OnPropertyChanged(nameof(HasChanges));
        OnPropertyChanged(nameof(HunkPositionDisplay));
        OnPropertyChanged(nameof(CanNavigatePrevious));
        OnPropertyChanged(nameof(CanNavigateNext));
    }

    /// <summary>
    /// Raise event to scroll view to the current hunk.
    /// </summary>
    private void ScrollToCurrentHunk()
    {
        HunkNavigationRequested?.Invoke(this, CurrentHunkIndex);
    }

    #endregion

    #region Property Change Handlers

    partial void OnShowInlineChangesChanged(bool value)
    {
        // Propagate to all hunks
        foreach (var hunk in Hunks)
        {
            hunk.ShowInlineChanges = value;
        }
    }

    partial void OnCurrentHunkIndexChanged(int value)
    {
        OnPropertyChanged(nameof(CanNavigatePrevious));
        OnPropertyChanged(nameof(CanNavigateNext));
        OnPropertyChanged(nameof(HunkPositionDisplay));
    }

    partial void OnSynchronizedScrollChanged(bool value)
    {
        // Could reset scroll positions when toggling
    }

    #endregion

    #region Navigation Commands

    /// <summary>
    /// Navigate to the next hunk.
    /// </summary>
    [RelayCommand(CanExecute = nameof(CanNavigateNext))]
    private void NextHunk()
    {
        if (CanNavigateNext)
        {
            CurrentHunkIndex++;
            ScrollToCurrentHunk();
        }
    }

    /// <summary>
    /// Navigate to the previous hunk.
    /// </summary>
    [RelayCommand(CanExecute = nameof(CanNavigatePrevious))]
    private void PreviousHunk()
    {
        if (CanNavigatePrevious)
        {
            CurrentHunkIndex--;
            ScrollToCurrentHunk();
        }
    }

    /// <summary>
    /// Navigate to a specific hunk by index.
    /// </summary>
    [RelayCommand]
    private void GoToHunk(int index)
    {
        if (index >= 0 && index < TotalHunks)
        {
            CurrentHunkIndex = index;
            ScrollToCurrentHunk();
        }
    }

    /// <summary>
    /// Navigate to the first hunk.
    /// </summary>
    [RelayCommand]
    private void FirstHunk()
    {
        if (TotalHunks > 0)
        {
            CurrentHunkIndex = 0;
            ScrollToCurrentHunk();
        }
    }

    /// <summary>
    /// Navigate to the last hunk.
    /// </summary>
    [RelayCommand]
    private void LastHunk()
    {
        if (TotalHunks > 0)
        {
            CurrentHunkIndex = TotalHunks - 1;
            ScrollToCurrentHunk();
        }
    }

    #endregion

    #region Toggle Commands

    /// <summary>
    /// Toggle display of inline character-level changes.
    /// </summary>
    [RelayCommand]
    private void ToggleInlineChanges()
    {
        ShowInlineChanges = !ShowInlineChanges;
    }

    /// <summary>
    /// Toggle word wrap mode.
    /// </summary>
    [RelayCommand]
    private void ToggleWordWrap()
    {
        WordWrap = !WordWrap;
    }

    /// <summary>
    /// Toggle synchronized scrolling between panels.
    /// </summary>
    [RelayCommand]
    private void ToggleSynchronizedScroll()
    {
        SynchronizedScroll = !SynchronizedScroll;
    }

    /// <summary>
    /// Toggle line number display.
    /// </summary>
    [RelayCommand]
    private void ToggleLineNumbers()
    {
        ShowLineNumbers = !ShowLineNumbers;
    }

    #endregion

    #region Action Commands

    /// <summary>
    /// Copy the proposed content to clipboard.
    /// </summary>
    [RelayCommand]
    private async Task CopyProposedAsync()
    {
        if (DiffResult?.ProposedContent != null)
        {
            // Note: Actual clipboard implementation depends on platform service
            await Task.CompletedTask;
            // await ClipboardService.SetTextAsync(DiffResult.ProposedContent);
        }
    }

    /// <summary>
    /// Copy the original content to clipboard.
    /// </summary>
    [RelayCommand]
    private async Task CopyOriginalAsync()
    {
        if (DiffResult?.OriginalContent != null)
        {
            await Task.CompletedTask;
            // await ClipboardService.SetTextAsync(DiffResult.OriginalContent);
        }
    }

    /// <summary>
    /// Request to apply the proposed changes to the file.
    /// </summary>
    [RelayCommand]
    private void RequestApply()
    {
        ApplyRequested?.Invoke(this, EventArgs.Empty);
    }

    /// <summary>
    /// Request to reject/dismiss the diff without applying.
    /// </summary>
    [RelayCommand]
    private void RequestReject()
    {
        RejectRequested?.Invoke(this, EventArgs.Empty);
    }

    #endregion
}

/// <summary>
/// Event args for scroll synchronization requests.
/// </summary>
public sealed class ScrollSyncEventArgs : EventArgs
{
    /// <summary>
    /// The scroll offset to synchronize to.
    /// </summary>
    public double Offset { get; init; }

    /// <summary>
    /// Which panel initiated the scroll.
    /// </summary>
    public DiffSide SourceSide { get; init; }
}
```

### 2. DiffHunkViewModel

**File**: `src/SeniorIntern.Desktop/ViewModels/DiffHunkViewModel.cs`

```csharp
// src/SeniorIntern.Desktop/ViewModels/DiffHunkViewModel.cs
namespace SeniorIntern.Desktop.ViewModels;

using System.Collections.ObjectModel;
using CommunityToolkit.Mvvm.ComponentModel;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;

/// <summary>
/// ViewModel for a diff hunk, providing side-by-side aligned lines for display.
/// </summary>
/// <remarks>
/// This ViewModel transforms a DiffHunk into two aligned collections of lines:
/// one for the original side and one for the proposed side. Placeholder lines
/// are inserted to maintain visual alignment between the two panels.
/// </remarks>
public partial class DiffHunkViewModel : ViewModelBase
{
    private readonly IInlineDiffService _inlineDiffService;
    private readonly DiffHunk _hunk;

    #region Observable Properties

    /// <summary>
    /// Unique identifier for this hunk.
    /// </summary>
    [ObservableProperty]
    private Guid _id;

    /// <summary>
    /// Index of this hunk within the diff (0-based).
    /// </summary>
    [ObservableProperty]
    private int _index;

    /// <summary>
    /// Standard unified diff header (e.g., "@@ -10,5 +10,7 @@").
    /// </summary>
    [ObservableProperty]
    private string _header = string.Empty;

    /// <summary>
    /// Optional context header showing function/class name.
    /// </summary>
    [ObservableProperty]
    private string? _contextHeader;

    /// <summary>
    /// Lines for the original (left) side panel.
    /// </summary>
    [ObservableProperty]
    private ObservableCollection<DiffLineViewModel> _originalLines = new();

    /// <summary>
    /// Lines for the proposed (right) side panel.
    /// </summary>
    [ObservableProperty]
    private ObservableCollection<DiffLineViewModel> _proposedLines = new();

    /// <summary>
    /// Whether to show inline character-level changes.
    /// </summary>
    [ObservableProperty]
    private bool _showInlineChanges = true;

    /// <summary>
    /// Whether this hunk is expanded (collapsed hunks show only header).
    /// </summary>
    [ObservableProperty]
    private bool _isExpanded = true;

    /// <summary>
    /// Whether this hunk is currently focused/selected.
    /// </summary>
    [ObservableProperty]
    private bool _isFocused;

    #endregion

    #region Read-Only Properties

    /// <summary>
    /// Number of lines added in this hunk.
    /// </summary>
    public int AddedCount { get; }

    /// <summary>
    /// Number of lines removed in this hunk.
    /// </summary>
    public int RemovedCount { get; }

    /// <summary>
    /// Number of lines modified in this hunk.
    /// </summary>
    public int ModifiedCount { get; }

    /// <summary>
    /// Total number of changed lines (added + removed + modified).
    /// </summary>
    public int TotalChanges => AddedCount + RemovedCount + ModifiedCount;

    /// <summary>
    /// Starting line number in the original file.
    /// </summary>
    public int OriginalStartLine { get; }

    /// <summary>
    /// Starting line number in the proposed file.
    /// </summary>
    public int ProposedStartLine { get; }

    /// <summary>
    /// Number of lines displayed for this hunk.
    /// </summary>
    public int DisplayLineCount => Math.Max(OriginalLines.Count, ProposedLines.Count);

    #endregion

    #region Constructor

    /// <summary>
    /// Initializes a new instance of DiffHunkViewModel.
    /// </summary>
    /// <param name="hunk">The source diff hunk.</param>
    /// <param name="inlineDiffService">Service for computing inline segments.</param>
    /// <param name="showInlineChanges">Initial value for ShowInlineChanges.</param>
    public DiffHunkViewModel(
        DiffHunk hunk,
        IInlineDiffService inlineDiffService,
        bool showInlineChanges)
    {
        _hunk = hunk ?? throw new ArgumentNullException(nameof(hunk));
        _inlineDiffService = inlineDiffService ?? throw new ArgumentNullException(nameof(inlineDiffService));

        // Copy hunk properties
        Id = hunk.Id;
        Index = hunk.Index;
        Header = hunk.Header;
        ContextHeader = hunk.ContextHeader;
        ShowInlineChanges = showInlineChanges;

        // Store start lines
        OriginalStartLine = hunk.OriginalStartLine;
        ProposedStartLine = hunk.ProposedStartLine;

        // Calculate statistics
        AddedCount = hunk.Lines.Count(l => l.Type == DiffLineType.Added);
        RemovedCount = hunk.Lines.Count(l => l.Type == DiffLineType.Removed);
        ModifiedCount = hunk.Lines.Count(l => l.Type == DiffLineType.Modified);

        // Build side-by-side aligned lines
        BuildSideBySideLines(hunk);
    }

    #endregion

    #region Side-by-Side Building

    /// <summary>
    /// Build aligned side-by-side line collections from the hunk.
    /// </summary>
    private void BuildSideBySideLines(DiffHunk hunk)
    {
        var originalList = new List<DiffLineViewModel>();
        var proposedList = new List<DiffLineViewModel>();

        int i = 0;
        while (i < hunk.Lines.Count)
        {
            var line = hunk.Lines[i];

            switch (line.Type)
            {
                case DiffLineType.Unchanged:
                    // Add to both sides
                    originalList.Add(CreateLineViewModel(line, DiffSide.Original));
                    proposedList.Add(CreateLineViewModel(line, DiffSide.Proposed));
                    i++;
                    break;

                case DiffLineType.Removed:
                    // Check if this is part of a modification (Removed followed by Added)
                    if (i + 1 < hunk.Lines.Count &&
                        hunk.Lines[i + 1].Type == DiffLineType.Added &&
                        line.PairedLine != null)
                    {
                        // Paired modification - add both on same row
                        var removedLine = line;
                        var addedLine = hunk.Lines[i + 1];

                        originalList.Add(CreateLineViewModel(removedLine, DiffSide.Original));
                        proposedList.Add(CreateLineViewModel(addedLine, DiffSide.Proposed));
                        i += 2;
                    }
                    else
                    {
                        // Pure removal - add placeholder to proposed
                        originalList.Add(CreateLineViewModel(line, DiffSide.Original));
                        proposedList.Add(CreatePlaceholderLine());
                        i++;
                    }
                    break;

                case DiffLineType.Added:
                    // Pure addition - add placeholder to original
                    originalList.Add(CreatePlaceholderLine());
                    proposedList.Add(CreateLineViewModel(line, DiffSide.Proposed));
                    i++;
                    break;

                case DiffLineType.Modified:
                    // Handle based on which side has the line
                    if (line.OriginalLineNumber.HasValue)
                    {
                        originalList.Add(CreateLineViewModel(line, DiffSide.Original));
                    }
                    if (line.ProposedLineNumber.HasValue)
                    {
                        proposedList.Add(CreateLineViewModel(line, DiffSide.Proposed));
                    }
                    i++;
                    break;

                default:
                    i++;
                    break;
            }
        }

        // Ensure both lists have the same length by padding with placeholders
        AlignLists(originalList, proposedList);

        OriginalLines = new ObservableCollection<DiffLineViewModel>(originalList);
        ProposedLines = new ObservableCollection<DiffLineViewModel>(proposedList);
    }

    /// <summary>
    /// Create a DiffLineViewModel for a real line.
    /// </summary>
    private DiffLineViewModel CreateLineViewModel(DiffLine line, DiffSide side)
    {
        // Get inline segments if applicable
        IReadOnlyList<InlineSegment>? segments = null;
        if (line.HasInlineChanges && ShowInlineChanges)
        {
            segments = _inlineDiffService.GetInlineSegments(
                line.Content,
                line.InlineChanges!,
                side);
        }

        return new DiffLineViewModel
        {
            LineNumber = line.GetLineNumber(side),
            Content = line.Content,
            Type = line.Type,
            Side = side,
            InlineSegments = segments,
            IsPlaceholder = false
        };
    }

    /// <summary>
    /// Create a placeholder line for alignment.
    /// </summary>
    private static DiffLineViewModel CreatePlaceholderLine()
    {
        return new DiffLineViewModel
        {
            LineNumber = null,
            Content = string.Empty,
            Type = DiffLineType.Unchanged,
            Side = DiffSide.Original, // Doesn't matter for placeholders
            InlineSegments = null,
            IsPlaceholder = true
        };
    }

    /// <summary>
    /// Ensure both lists have the same length by adding placeholders.
    /// </summary>
    private static void AlignLists(
        List<DiffLineViewModel> original,
        List<DiffLineViewModel> proposed)
    {
        while (original.Count < proposed.Count)
        {
            original.Add(CreatePlaceholderLine());
        }
        while (proposed.Count < original.Count)
        {
            proposed.Add(CreatePlaceholderLine());
        }
    }

    #endregion

    #region Property Change Handlers

    partial void OnShowInlineChangesChanged(bool value)
    {
        // Rebuild lines with updated inline segments
        RebuildLines();
    }

    /// <summary>
    /// Rebuild the side-by-side lines (e.g., when ShowInlineChanges changes).
    /// </summary>
    private void RebuildLines()
    {
        BuildSideBySideLines(_hunk);
    }

    #endregion

    #region Commands

    /// <summary>
    /// Toggle the expanded state of this hunk.
    /// </summary>
    [RelayCommand]
    private void ToggleExpanded()
    {
        IsExpanded = !IsExpanded;
    }

    #endregion
}
```

### 3. DiffLineViewModel

**File**: `src/SeniorIntern.Desktop/ViewModels/DiffLineViewModel.cs`

```csharp
// src/SeniorIntern.Desktop/ViewModels/DiffLineViewModel.cs
namespace SeniorIntern.Desktop.ViewModels;

using CommunityToolkit.Mvvm.ComponentModel;
using SeniorIntern.Core.Models;

/// <summary>
/// ViewModel for a single line in the diff viewer.
/// </summary>
/// <remarks>
/// Represents one line in either the original or proposed panel.
/// Supports inline segments for character-level change highlighting,
/// and placeholder lines for maintaining alignment.
/// </remarks>
public partial class DiffLineViewModel : ViewModelBase
{
    #region Observable Properties

    /// <summary>
    /// Line number (null for placeholder lines or added lines on original side).
    /// </summary>
    [ObservableProperty]
    private int? _lineNumber;

    /// <summary>
    /// Text content of the line.
    /// </summary>
    [ObservableProperty]
    private string _content = string.Empty;

    /// <summary>
    /// Type of change for this line.
    /// </summary>
    [ObservableProperty]
    private DiffLineType _type;

    /// <summary>
    /// Which side of the diff this line belongs to.
    /// </summary>
    [ObservableProperty]
    private DiffSide _side;

    /// <summary>
    /// Inline segments for character-level highlighting (null if not applicable).
    /// </summary>
    [ObservableProperty]
    private IReadOnlyList<InlineSegment>? _inlineSegments;

    /// <summary>
    /// Whether this is a placeholder line for alignment purposes.
    /// </summary>
    [ObservableProperty]
    private bool _isPlaceholder;

    /// <summary>
    /// Whether this line is currently highlighted (e.g., during search).
    /// </summary>
    [ObservableProperty]
    private bool _isHighlighted;

    /// <summary>
    /// Whether this line is selected.
    /// </summary>
    [ObservableProperty]
    private bool _isSelected;

    #endregion

    #region Computed Properties

    /// <summary>
    /// Whether this line has inline change segments to display.
    /// </summary>
    public bool HasInlineSegments => InlineSegments?.Count > 0;

    /// <summary>
    /// Line number formatted for display (empty string for null/placeholder).
    /// </summary>
    public string LineNumberDisplay => LineNumber?.ToString() ?? string.Empty;

    /// <summary>
    /// Whether this line represents an addition.
    /// </summary>
    public bool IsAdded => Type == DiffLineType.Added;

    /// <summary>
    /// Whether this line represents a removal.
    /// </summary>
    public bool IsRemoved => Type == DiffLineType.Removed;

    /// <summary>
    /// Whether this line represents a modification.
    /// </summary>
    public bool IsModified => Type == DiffLineType.Modified;

    /// <summary>
    /// Whether this line is unchanged.
    /// </summary>
    public bool IsUnchanged => Type == DiffLineType.Unchanged;

    /// <summary>
    /// Whether this line represents any kind of change.
    /// </summary>
    public bool IsChanged => IsAdded || IsRemoved || IsModified;

    /// <summary>
    /// Prefix character for unified diff format (+, -, ~, or space).
    /// </summary>
    public char Prefix => Type switch
    {
        DiffLineType.Added => '+',
        DiffLineType.Removed => '-',
        DiffLineType.Modified => '~',
        _ => ' '
    };

    /// <summary>
    /// CSS-style class name for styling based on change type.
    /// </summary>
    public string ChangeClass => Type switch
    {
        DiffLineType.Added => "diff-added",
        DiffLineType.Removed => "diff-removed",
        DiffLineType.Modified => "diff-modified",
        _ => IsPlaceholder ? "diff-placeholder" : "diff-unchanged"
    };

    /// <summary>
    /// Background style for this line based on its type.
    /// </summary>
    public string BackgroundStyle => Type switch
    {
        DiffLineType.Added => "DiffAddedBackground",
        DiffLineType.Removed => "DiffRemovedBackground",
        DiffLineType.Modified => "DiffModifiedBackground",
        _ => IsPlaceholder ? "DiffPlaceholderBackground" : "Transparent"
    };

    /// <summary>
    /// Whether this line should be visible (placeholders may be hidden in some views).
    /// </summary>
    public bool IsVisible => !IsPlaceholder || true; // Always visible for alignment

    /// <summary>
    /// Content length for column alignment calculations.
    /// </summary>
    public int ContentLength => Content?.Length ?? 0;

    #endregion

    #region Methods

    /// <summary>
    /// Get the inline segment at a specific column position.
    /// </summary>
    /// <param name="column">The column position (0-based).</param>
    /// <returns>The segment at that position, or null if none.</returns>
    public InlineSegment? GetSegmentAtColumn(int column)
    {
        if (InlineSegments == null)
            return null;

        int currentPos = 0;
        foreach (var segment in InlineSegments)
        {
            if (column >= currentPos && column < currentPos + segment.Length)
            {
                return segment;
            }
            currentPos += segment.Length;
        }

        return null;
    }

    /// <summary>
    /// Returns string representation for debugging.
    /// </summary>
    public override string ToString()
    {
        if (IsPlaceholder)
            return $"[Placeholder]";

        return $"[{LineNumber}] {Prefix} {Content.Truncate(50)}";
    }

    #endregion
}

/// <summary>
/// Extension methods for string truncation.
/// </summary>
internal static class StringExtensions
{
    /// <summary>
    /// Truncate a string to a maximum length, adding ellipsis if truncated.
    /// </summary>
    public static string Truncate(this string? value, int maxLength)
    {
        if (string.IsNullOrEmpty(value))
            return string.Empty;

        if (value.Length <= maxLength)
            return value;

        return value.Substring(0, maxLength - 3) + "...";
    }
}
```

---

## Dependency Registration

**File**: `src/SeniorIntern.Desktop/Extensions/ServiceCollectionExtensions.cs` (modifications)

```csharp
// Add to service registration
services.AddTransient<DiffViewerViewModel>();
// Note: DiffHunkViewModel and DiffLineViewModel are created by DiffViewerViewModel,
// not resolved from DI container
```

---

## Usage Examples

### Example 1: Loading a Diff from a Code Block

```csharp
// In a parent ViewModel or View
var diffViewer = serviceProvider.GetRequiredService<DiffViewerViewModel>();

// Load diff asynchronously
await diffViewer.LoadDiffAsync(codeBlock, workspacePath);

// The view binds to:
// - diffViewer.Hunks for the hunk collection
// - diffViewer.StatsDisplay for "+10 -5" summary
// - diffViewer.IsLoading for progress indicator
// - diffViewer.ErrorMessage for error display
```

### Example 2: Handling Navigation Events

```csharp
// In View code-behind
protected override void OnDataContextChanged(EventArgs e)
{
    base.OnDataContextChanged(e);

    if (DataContext is DiffViewerViewModel vm)
    {
        vm.HunkNavigationRequested += OnHunkNavigationRequested;
        vm.ApplyRequested += OnApplyRequested;
        vm.RejectRequested += OnRejectRequested;
    }
}

private void OnHunkNavigationRequested(object? sender, int hunkIndex)
{
    // Scroll both panels to the hunk at hunkIndex
    var hunk = Hunks[hunkIndex];
    // ... scroll logic
}

private async void OnApplyRequested(object? sender, EventArgs e)
{
    if (DataContext is DiffViewerViewModel vm && vm.DiffResult != null)
    {
        // Write proposed content to file
        await File.WriteAllTextAsync(vm.FilePath, vm.DiffResult.ProposedContent);
        // Close or update view
    }
}
```

### Example 3: Using View Options

```csharp
// Toggle inline changes via binding
<ToggleButton IsChecked="{Binding ShowInlineChanges}" />

// Or via command
<Button Command="{Binding ToggleInlineChangesCommand}" />

// The ViewModel automatically propagates to all hunks
partial void OnShowInlineChangesChanged(bool value)
{
    foreach (var hunk in Hunks)
    {
        hunk.ShowInlineChanges = value;
    }
}
```

### Example 4: Binding in XAML

```xml
<!-- Binding to DiffViewerViewModel -->
<ItemsControl ItemsSource="{Binding Hunks}">
    <ItemsControl.ItemTemplate>
        <DataTemplate DataType="{x:Type vm:DiffHunkViewModel}">
            <Grid>
                <!-- Hunk header -->
                <TextBlock Text="{Binding Header}" />

                <!-- Original lines -->
                <ItemsControl ItemsSource="{Binding OriginalLines}">
                    <ItemsControl.ItemTemplate>
                        <DataTemplate DataType="{x:Type vm:DiffLineViewModel}">
                            <controls:DiffLineControl />
                        </DataTemplate>
                    </ItemsControl.ItemTemplate>
                </ItemsControl>
            </Grid>
        </DataTemplate>
    </ItemsControl.ItemTemplate>
</ItemsControl>
```

---

## Files to Create

| File | Purpose | Lines (approx) |
|------|---------|----------------|
| `src/SeniorIntern.Desktop/ViewModels/DiffViewerViewModel.cs` | Main diff viewer ViewModel | 450 |
| `src/SeniorIntern.Desktop/ViewModels/DiffHunkViewModel.cs` | Hunk ViewModel with alignment | 250 |
| `src/SeniorIntern.Desktop/ViewModels/DiffLineViewModel.cs` | Line ViewModel with segments | 180 |

## Files to Modify

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/Extensions/ServiceCollectionExtensions.cs` | Register `DiffViewerViewModel` with DI |

---

## Testing Strategy

### Unit Tests for DiffViewerViewModel

```csharp
// src/SeniorIntern.Tests/ViewModels/DiffViewerViewModelTests.cs
namespace SeniorIntern.Tests.ViewModels;

public class DiffViewerViewModelTests
{
    private readonly Mock<IDiffService> _diffServiceMock;
    private readonly Mock<IInlineDiffService> _inlineDiffServiceMock;
    private readonly DiffViewerViewModel _viewModel;

    public DiffViewerViewModelTests()
    {
        _diffServiceMock = new Mock<IDiffService>();
        _inlineDiffServiceMock = new Mock<IInlineDiffService>();
        _viewModel = new DiffViewerViewModel(
            _diffServiceMock.Object,
            _inlineDiffServiceMock.Object);
    }

    #region Loading Tests

    [Fact]
    public async Task LoadDiffAsync_SetsIsLoadingDuringOperation()
    {
        // Arrange
        var tcs = new TaskCompletionSource<DiffResult>();
        _diffServiceMock
            .Setup(x => x.ComputeDiffForBlockAsync(It.IsAny<CodeBlock>(), It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .Returns(tcs.Task);

        var block = new CodeBlock { TargetFilePath = "test.cs" };

        // Act
        var loadTask = _viewModel.LoadDiffAsync(block, "/workspace");

        // Assert - IsLoading should be true while loading
        Assert.True(_viewModel.IsLoading);

        // Complete the task
        tcs.SetResult(new DiffResult { Hunks = Array.Empty<DiffHunk>() });
        await loadTask;

        // Assert - IsLoading should be false after completion
        Assert.False(_viewModel.IsLoading);
    }

    [Fact]
    public async Task LoadDiffAsync_SetsErrorMessageOnException()
    {
        // Arrange
        _diffServiceMock
            .Setup(x => x.ComputeDiffForBlockAsync(It.IsAny<CodeBlock>(), It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ThrowsAsync(new Exception("Test error"));

        var block = new CodeBlock { TargetFilePath = "test.cs" };

        // Act
        await _viewModel.LoadDiffAsync(block, "/workspace");

        // Assert
        Assert.NotNull(_viewModel.ErrorMessage);
        Assert.Contains("Test error", _viewModel.ErrorMessage);
        Assert.False(_viewModel.IsLoading);
    }

    [Fact]
    public void LoadDiff_PopulatesHunksCollection()
    {
        // Arrange
        var result = CreateTestDiffResult(hunkCount: 3);

        // Act
        _viewModel.LoadDiff(result);

        // Assert
        Assert.Equal(3, _viewModel.Hunks.Count);
        Assert.Equal(3, _viewModel.TotalHunks);
    }

    [Fact]
    public void LoadDiff_ExtractsFileNameFromPath()
    {
        // Arrange
        var result = new DiffResult
        {
            OriginalFilePath = "/path/to/file.cs",
            Hunks = Array.Empty<DiffHunk>()
        };

        // Act
        _viewModel.LoadDiff(result);

        // Assert
        Assert.Equal("file.cs", _viewModel.FileName);
        Assert.Equal("/path/to/file.cs", _viewModel.FilePath);
    }

    #endregion

    #region Navigation Tests

    [Fact]
    public void NextHunk_IncrementsCurrentHunkIndex()
    {
        // Arrange
        _viewModel.LoadDiff(CreateTestDiffResult(hunkCount: 5));
        Assert.Equal(0, _viewModel.CurrentHunkIndex);

        // Act
        _viewModel.NextHunkCommand.Execute(null);

        // Assert
        Assert.Equal(1, _viewModel.CurrentHunkIndex);
    }

    [Fact]
    public void NextHunk_DoesNotExceedTotalHunks()
    {
        // Arrange
        _viewModel.LoadDiff(CreateTestDiffResult(hunkCount: 2));
        _viewModel.GoToHunkCommand.Execute(1); // Go to last hunk

        // Act
        _viewModel.NextHunkCommand.Execute(null);

        // Assert
        Assert.Equal(1, _viewModel.CurrentHunkIndex); // Should stay at 1
    }

    [Fact]
    public void PreviousHunk_DecrementsCurrentHunkIndex()
    {
        // Arrange
        _viewModel.LoadDiff(CreateTestDiffResult(hunkCount: 5));
        _viewModel.GoToHunkCommand.Execute(3);

        // Act
        _viewModel.PreviousHunkCommand.Execute(null);

        // Assert
        Assert.Equal(2, _viewModel.CurrentHunkIndex);
    }

    [Fact]
    public void PreviousHunk_DoesNotGoBelowZero()
    {
        // Arrange
        _viewModel.LoadDiff(CreateTestDiffResult(hunkCount: 2));
        Assert.Equal(0, _viewModel.CurrentHunkIndex);

        // Act
        _viewModel.PreviousHunkCommand.Execute(null);

        // Assert
        Assert.Equal(0, _viewModel.CurrentHunkIndex); // Should stay at 0
    }

    [Fact]
    public void CanNavigatePrevious_FalseAtFirstHunk()
    {
        // Arrange
        _viewModel.LoadDiff(CreateTestDiffResult(hunkCount: 5));

        // Assert
        Assert.False(_viewModel.CanNavigatePrevious);
    }

    [Fact]
    public void CanNavigateNext_FalseAtLastHunk()
    {
        // Arrange
        _viewModel.LoadDiff(CreateTestDiffResult(hunkCount: 5));
        _viewModel.GoToHunkCommand.Execute(4);

        // Assert
        Assert.False(_viewModel.CanNavigateNext);
    }

    [Fact]
    public void HunkNavigationRequested_RaisedOnNavigation()
    {
        // Arrange
        _viewModel.LoadDiff(CreateTestDiffResult(hunkCount: 5));
        int? navigatedToIndex = null;
        _viewModel.HunkNavigationRequested += (s, i) => navigatedToIndex = i;

        // Act
        _viewModel.NextHunkCommand.Execute(null);

        // Assert
        Assert.Equal(1, navigatedToIndex);
    }

    #endregion

    #region Toggle Tests

    [Fact]
    public void ToggleInlineChanges_FlipsShowInlineChanges()
    {
        // Arrange
        Assert.True(_viewModel.ShowInlineChanges); // Default is true

        // Act
        _viewModel.ToggleInlineChangesCommand.Execute(null);

        // Assert
        Assert.False(_viewModel.ShowInlineChanges);
    }

    [Fact]
    public void ShowInlineChanges_PropagatestoHunks()
    {
        // Arrange
        _viewModel.LoadDiff(CreateTestDiffResult(hunkCount: 3));
        Assert.All(_viewModel.Hunks, h => Assert.True(h.ShowInlineChanges));

        // Act
        _viewModel.ShowInlineChanges = false;

        // Assert
        Assert.All(_viewModel.Hunks, h => Assert.False(h.ShowInlineChanges));
    }

    #endregion

    #region Event Tests

    [Fact]
    public void RequestApply_RaisesApplyRequestedEvent()
    {
        // Arrange
        bool eventRaised = false;
        _viewModel.ApplyRequested += (s, e) => eventRaised = true;

        // Act
        _viewModel.RequestApplyCommand.Execute(null);

        // Assert
        Assert.True(eventRaised);
    }

    [Fact]
    public void RequestReject_RaisesRejectRequestedEvent()
    {
        // Arrange
        bool eventRaised = false;
        _viewModel.RejectRequested += (s, e) => eventRaised = true;

        // Act
        _viewModel.RequestRejectCommand.Execute(null);

        // Assert
        Assert.True(eventRaised);
    }

    #endregion

    #region Helper Methods

    private DiffResult CreateTestDiffResult(int hunkCount)
    {
        var hunks = Enumerable.Range(0, hunkCount)
            .Select(i => new DiffHunk
            {
                Id = Guid.NewGuid(),
                Index = i,
                Lines = new List<DiffLine>
                {
                    new DiffLine { Content = "test", Type = DiffLineType.Unchanged }
                }
            })
            .ToList();

        return new DiffResult
        {
            OriginalFilePath = "test.cs",
            Hunks = hunks,
            Stats = new DiffStats()
        };
    }

    #endregion
}
```

### Unit Tests for DiffHunkViewModel

```csharp
// src/SeniorIntern.Tests/ViewModels/DiffHunkViewModelTests.cs
namespace SeniorIntern.Tests.ViewModels;

public class DiffHunkViewModelTests
{
    private readonly Mock<IInlineDiffService> _inlineDiffServiceMock;

    public DiffHunkViewModelTests()
    {
        _inlineDiffServiceMock = new Mock<IInlineDiffService>();
    }

    [Fact]
    public void Constructor_CopiesHunkProperties()
    {
        // Arrange
        var hunk = new DiffHunk
        {
            Id = Guid.NewGuid(),
            Index = 5,
            Header = "@@ -10,5 +10,7 @@",
            ContextHeader = "function test()",
            Lines = new List<DiffLine>()
        };

        // Act
        var vm = new DiffHunkViewModel(hunk, _inlineDiffServiceMock.Object, true);

        // Assert
        Assert.Equal(hunk.Id, vm.Id);
        Assert.Equal(5, vm.Index);
        Assert.Equal("@@ -10,5 +10,7 @@", vm.Header);
        Assert.Equal("function test()", vm.ContextHeader);
    }

    [Fact]
    public void Constructor_CalculatesStatistics()
    {
        // Arrange
        var hunk = new DiffHunk
        {
            Lines = new List<DiffLine>
            {
                new DiffLine { Type = DiffLineType.Added },
                new DiffLine { Type = DiffLineType.Added },
                new DiffLine { Type = DiffLineType.Removed },
                new DiffLine { Type = DiffLineType.Unchanged }
            }
        };

        // Act
        var vm = new DiffHunkViewModel(hunk, _inlineDiffServiceMock.Object, true);

        // Assert
        Assert.Equal(2, vm.AddedCount);
        Assert.Equal(1, vm.RemovedCount);
        Assert.Equal(3, vm.TotalChanges);
    }

    [Fact]
    public void BuildSideBySideLines_UnchangedLines_AddedToBothSides()
    {
        // Arrange
        var hunk = new DiffHunk
        {
            Lines = new List<DiffLine>
            {
                new DiffLine
                {
                    Content = "unchanged",
                    Type = DiffLineType.Unchanged,
                    OriginalLineNumber = 1,
                    ProposedLineNumber = 1
                }
            }
        };

        // Act
        var vm = new DiffHunkViewModel(hunk, _inlineDiffServiceMock.Object, false);

        // Assert
        Assert.Single(vm.OriginalLines);
        Assert.Single(vm.ProposedLines);
        Assert.Equal("unchanged", vm.OriginalLines[0].Content);
        Assert.Equal("unchanged", vm.ProposedLines[0].Content);
        Assert.False(vm.OriginalLines[0].IsPlaceholder);
        Assert.False(vm.ProposedLines[0].IsPlaceholder);
    }

    [Fact]
    public void BuildSideBySideLines_RemovedLine_PlaceholderOnProposedSide()
    {
        // Arrange
        var hunk = new DiffHunk
        {
            Lines = new List<DiffLine>
            {
                new DiffLine
                {
                    Content = "removed",
                    Type = DiffLineType.Removed,
                    OriginalLineNumber = 1
                }
            }
        };

        // Act
        var vm = new DiffHunkViewModel(hunk, _inlineDiffServiceMock.Object, false);

        // Assert
        Assert.Single(vm.OriginalLines);
        Assert.Single(vm.ProposedLines);
        Assert.Equal("removed", vm.OriginalLines[0].Content);
        Assert.True(vm.ProposedLines[0].IsPlaceholder);
    }

    [Fact]
    public void BuildSideBySideLines_AddedLine_PlaceholderOnOriginalSide()
    {
        // Arrange
        var hunk = new DiffHunk
        {
            Lines = new List<DiffLine>
            {
                new DiffLine
                {
                    Content = "added",
                    Type = DiffLineType.Added,
                    ProposedLineNumber = 1
                }
            }
        };

        // Act
        var vm = new DiffHunkViewModel(hunk, _inlineDiffServiceMock.Object, false);

        // Assert
        Assert.Single(vm.OriginalLines);
        Assert.Single(vm.ProposedLines);
        Assert.True(vm.OriginalLines[0].IsPlaceholder);
        Assert.Equal("added", vm.ProposedLines[0].Content);
    }

    [Fact]
    public void BuildSideBySideLines_ListsAreAligned()
    {
        // Arrange
        var hunk = new DiffHunk
        {
            Lines = new List<DiffLine>
            {
                new DiffLine { Type = DiffLineType.Removed, Content = "a", OriginalLineNumber = 1 },
                new DiffLine { Type = DiffLineType.Removed, Content = "b", OriginalLineNumber = 2 },
                new DiffLine { Type = DiffLineType.Added, Content = "c", ProposedLineNumber = 1 },
            }
        };

        // Act
        var vm = new DiffHunkViewModel(hunk, _inlineDiffServiceMock.Object, false);

        // Assert
        Assert.Equal(vm.OriginalLines.Count, vm.ProposedLines.Count);
    }
}
```

### Unit Tests for DiffLineViewModel

```csharp
// src/SeniorIntern.Tests/ViewModels/DiffLineViewModelTests.cs
namespace SeniorIntern.Tests.ViewModels;

public class DiffLineViewModelTests
{
    [Fact]
    public void LineNumberDisplay_ReturnsEmptyForNull()
    {
        // Arrange
        var vm = new DiffLineViewModel { LineNumber = null };

        // Assert
        Assert.Equal(string.Empty, vm.LineNumberDisplay);
    }

    [Fact]
    public void LineNumberDisplay_ReturnsFormattedNumber()
    {
        // Arrange
        var vm = new DiffLineViewModel { LineNumber = 42 };

        // Assert
        Assert.Equal("42", vm.LineNumberDisplay);
    }

    [Theory]
    [InlineData(DiffLineType.Added, true, false, false, false)]
    [InlineData(DiffLineType.Removed, false, true, false, false)]
    [InlineData(DiffLineType.Modified, false, false, true, false)]
    [InlineData(DiffLineType.Unchanged, false, false, false, true)]
    public void TypeFlags_SetCorrectly(
        DiffLineType type,
        bool expectedAdded,
        bool expectedRemoved,
        bool expectedModified,
        bool expectedUnchanged)
    {
        // Arrange
        var vm = new DiffLineViewModel { Type = type };

        // Assert
        Assert.Equal(expectedAdded, vm.IsAdded);
        Assert.Equal(expectedRemoved, vm.IsRemoved);
        Assert.Equal(expectedModified, vm.IsModified);
        Assert.Equal(expectedUnchanged, vm.IsUnchanged);
    }

    [Theory]
    [InlineData(DiffLineType.Added, '+')]
    [InlineData(DiffLineType.Removed, '-')]
    [InlineData(DiffLineType.Modified, '~')]
    [InlineData(DiffLineType.Unchanged, ' ')]
    public void Prefix_ReturnsCorrectCharacter(DiffLineType type, char expectedPrefix)
    {
        // Arrange
        var vm = new DiffLineViewModel { Type = type };

        // Assert
        Assert.Equal(expectedPrefix, vm.Prefix);
    }

    [Fact]
    public void HasInlineSegments_TrueWhenSegmentsExist()
    {
        // Arrange
        var vm = new DiffLineViewModel
        {
            InlineSegments = new List<InlineSegment>
            {
                new InlineSegment { Text = "test" }
            }
        };

        // Assert
        Assert.True(vm.HasInlineSegments);
    }

    [Fact]
    public void HasInlineSegments_FalseWhenNull()
    {
        // Arrange
        var vm = new DiffLineViewModel { InlineSegments = null };

        // Assert
        Assert.False(vm.HasInlineSegments);
    }

    [Fact]
    public void HasInlineSegments_FalseWhenEmpty()
    {
        // Arrange
        var vm = new DiffLineViewModel { InlineSegments = Array.Empty<InlineSegment>() };

        // Assert
        Assert.False(vm.HasInlineSegments);
    }

    [Fact]
    public void IsChanged_TrueForAddedRemovedModified()
    {
        // Assert
        Assert.True(new DiffLineViewModel { Type = DiffLineType.Added }.IsChanged);
        Assert.True(new DiffLineViewModel { Type = DiffLineType.Removed }.IsChanged);
        Assert.True(new DiffLineViewModel { Type = DiffLineType.Modified }.IsChanged);
        Assert.False(new DiffLineViewModel { Type = DiffLineType.Unchanged }.IsChanged);
    }

    [Theory]
    [InlineData(DiffLineType.Added, "diff-added")]
    [InlineData(DiffLineType.Removed, "diff-removed")]
    [InlineData(DiffLineType.Modified, "diff-modified")]
    [InlineData(DiffLineType.Unchanged, "diff-unchanged")]
    public void ChangeClass_ReturnsCorrectClass(DiffLineType type, string expectedClass)
    {
        // Arrange
        var vm = new DiffLineViewModel { Type = type, IsPlaceholder = false };

        // Assert
        Assert.Equal(expectedClass, vm.ChangeClass);
    }

    [Fact]
    public void ChangeClass_ReturnsPlaceholderClass()
    {
        // Arrange
        var vm = new DiffLineViewModel { Type = DiffLineType.Unchanged, IsPlaceholder = true };

        // Assert
        Assert.Equal("diff-placeholder", vm.ChangeClass);
    }
}
```

---

## Acceptance Criteria

- [ ] `DiffViewerViewModel` accepts `IDiffService` and `IInlineDiffService` via constructor injection
- [ ] `LoadDiffAsync` sets `IsLoading` true during operation, false after completion
- [ ] `LoadDiffAsync` populates `ErrorMessage` on exceptions
- [ ] `LoadDiff` populates `Hunks` collection from `DiffResult`
- [ ] `FileName` extracted correctly from `FilePath`
- [ ] `TotalHunks` matches `DiffResult.Hunks.Count`
- [ ] `CurrentHunkIndex` initializes to 0 after loading
- [ ] `NextHunkCommand` increments `CurrentHunkIndex` when not at end
- [ ] `PreviousHunkCommand` decrements `CurrentHunkIndex` when not at start
- [ ] `CanNavigatePrevious` and `CanNavigateNext` computed correctly
- [ ] `HunkNavigationRequested` event raised on navigation
- [ ] `ShowInlineChanges` change propagates to all `DiffHunkViewModel` instances
- [ ] `ApplyRequested` and `RejectRequested` events raised by commands
- [ ] `DiffHunkViewModel` creates aligned `OriginalLines` and `ProposedLines`
- [ ] Placeholder lines inserted for removed lines on proposed side
- [ ] Placeholder lines inserted for added lines on original side
- [ ] Both line lists have equal length after alignment
- [ ] `DiffLineViewModel` computed properties (`IsAdded`, `Prefix`, etc.) work correctly
- [ ] `LineNumberDisplay` returns empty string for null line numbers
- [ ] All ViewModels registered with DI container

---

## Dependencies

### From v0.4.2a (Diff Models)

- `DiffResult` model
- `DiffHunk` model
- `DiffLine` model
- `DiffLineType` enum
- `DiffSide` enum
- `DiffStats` record

### From v0.4.2b (Diff Service)

- `IDiffService` interface
- `DiffService.ComputeDiffForBlockAsync` method

### From v0.4.2c (Inline Diff)

- `IInlineDiffService` interface
- `InlineSegment` model
- `InlineDiffService.GetInlineSegments` method

### From v0.4.1 (Code Block Extraction)

- `CodeBlock` model with `TargetFilePath`, `DisplayLanguage`

### External

- CommunityToolkit.Mvvm
  - `[ObservableProperty]` attribute
  - `[RelayCommand]` attribute
  - `ObservableObject` base class

---

## Future Enhancements

### Potential v0.4.2d+ Improvements

1. **Search within Diff**: Add search functionality with `IsHighlighted` support
2. **Line Selection**: Implement multi-line selection for partial apply
3. **Collapsible Hunks**: Utilize `IsExpanded` for collapsing unchanged regions
4. **Diff Stats per Hunk**: Show mini-stats in hunk headers
5. **Keyboard Shortcuts**: Direct binding to navigation commands

---

## Revision History

| Version | Date | Changes |
|---------|------|---------|
| 1.0 | 2025-01-10 | Initial design specification |
