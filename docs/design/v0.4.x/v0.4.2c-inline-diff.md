# Design Specification: The Senior Intern v0.4.2c "Inline Diff"

**Status**: _IMPLEMENTED_

## Executive Summary

This document provides a detailed implementation specification for v0.4.2c, which implements character-level diff computation for modified lines. This sub-version enables precise highlighting of exactly what changed within a line, making it easier for users to understand the specific modifications proposed by the LLM.

The inline diff functionality is critical for the diff viewer user experience. When a line has been modified (not purely added or removed), users need to see the exact characters that changed rather than just highlighting the entire line. This granular view enables quick comprehension of changes like variable renames, value modifications, or minor syntax adjustments.

### v0.4.2c Scope

- Define `IInlineDiffService` interface for character-level diff computation
- Implement `InlineDiffService` using DiffPlex character diff API
- Create `InlineSegment` model for rendering inline changes
- Integrate inline diff computation into `DiffService`
- Implement Levenshtein distance similarity detection
- Add configurable thresholds for inline diff triggering

### Key Deliverables

| Deliverable | Description |
|-------------|-------------|
| IInlineDiffService | Interface for character-level inline diff computation |
| InlineDiffService | DiffPlex-based implementation for computing character changes |
| InlineSegment Model | Rendering model for text segments with change information |
| DiffService Integration | ComputeInlineDiffs method and similarity detection |
| Levenshtein Algorithm | Efficient similarity computation for line pairing |

---

## Feature Overview

```
┌──────────────────────────────────────────────────────────────────┐
│                     v0.4.2c Feature Tree                          │
├──────────────────────────────────────────────────────────────────┤
│                                                                   │
│  Inline Diff Engine                                               │
│  ├── IInlineDiffService Interface                                 │
│  │   ├── ComputeInlineChanges(original, proposed)                 │
│  │   └── GetInlineSegments(content, changes, side)                │
│  │                                                                │
│  ├── InlineDiffService Implementation                             │
│  │   ├── DiffPlex Differ character diff integration               │
│  │   ├── DiffBlock processing for insert/delete detection         │
│  │   └── Position tracking for column-accurate changes            │
│  │                                                                │
│  ├── InlineSegment Model                                          │
│  │   ├── Text content segment                                     │
│  │   ├── IsChanged flag for highlighting                          │
│  │   └── InlineChangeType (Added/Removed/Unchanged)               │
│  │                                                                │
│  ├── DiffService Integration                                      │
│  │   ├── ComputeInlineDiffs method for hunk processing            │
│  │   ├── Line pairing logic (Removed → Added detection)           │
│  │   └── DiffLine.InlineChanges population                        │
│  │                                                                │
│  └── Similarity Detection                                         │
│      ├── Levenshtein distance algorithm                           │
│      ├── Configurable similarity threshold (default 30%)          │
│      └── MaxInlineDiffLineLength guard (default 500 chars)        │
│                                                                   │
└──────────────────────────────────────────────────────────────────┘
```

---

## Architecture Diagrams

### Inline Diff Processing Flow

```
┌─────────────────────────────────────────────────────────────────┐
│                   Inline Diff Processing Flow                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  DiffService.ComputeDiffInternal()                               │
│           │                                                      │
│           ▼                                                      │
│  ┌─────────────────────┐                                         │
│  │   BuildHunks()      │  Creates DiffHunks from DiffPlex model  │
│  └──────────┬──────────┘                                         │
│             │                                                    │
│             ▼                                                    │
│  ┌─────────────────────┐                                         │
│  │ ComputeInlineDiffs()│  Process each hunk for inline changes   │
│  └──────────┬──────────┘                                         │
│             │                                                    │
│             ▼                                                    │
│  ┌─────────────────────────────────────────────────────────┐     │
│  │  For each adjacent Removed/Added line pair:              │     │
│  │  ┌─────────────────────────────────────────────────────┐│     │
│  │  │  1. Check ShouldComputeInlineDiff()                 ││     │
│  │  │     ├── Line length < MaxInlineDiffLineLength       ││     │
│  │  │     └── Similarity >= 30% (Levenshtein)             ││     │
│  │  │                                                      ││     │
│  │  │  2. Call InlineDiffService.ComputeInlineChanges()   ││     │
│  │  │     ├── Process DiffPlex DiffBlocks                 ││     │
│  │  │     └── Track column positions                       ││     │
│  │  │                                                      ││     │
│  │  │  3. Update DiffLine with InlineChanges              ││     │
│  │  │  4. Link paired lines via PairedLine property       ││     │
│  │  └─────────────────────────────────────────────────────┘│     │
│  └─────────────────────────────────────────────────────────┘     │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Character-Level Diff Algorithm

```
┌─────────────────────────────────────────────────────────────────┐
│              Character-Level Diff Algorithm                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Input:                                                          │
│    Original: "Hello world"                                       │
│    Proposed: "Hello universe"                                    │
│                                                                  │
│  Step 1: DiffPlex CreateCharacterDiffs()                         │
│  ┌───────────────────────────────────────────────────────────┐   │
│  │  DiffBlock {                                               │   │
│  │    DeleteStartA: 6,  DeleteCountA: 5   ("world")          │   │
│  │    InsertStartB: 6,  InsertCountB: 8   ("universe")       │   │
│  │  }                                                         │   │
│  └───────────────────────────────────────────────────────────┘   │
│                                                                  │
│  Step 2: Build InlineChange List                                 │
│  ┌───────────────────────────────────────────────────────────┐   │
│  │  [0] { StartColumn: 0, Length: 6,  Text: "Hello ",        │   │
│  │        Type: Unchanged }                                   │   │
│  │  [1] { StartColumn: 6, Length: 5,  Text: "world",         │   │
│  │        Type: Removed }                                     │   │
│  │  [2] { StartColumn: 6, Length: 8,  Text: "universe",      │   │
│  │        Type: Added }                                       │   │
│  └───────────────────────────────────────────────────────────┘   │
│                                                                  │
│  Step 3: GetInlineSegments (per side)                            │
│  ┌───────────────────────────────────────────────────────────┐   │
│  │  Original Side:                                            │   │
│  │    "Hello " (unchanged) + "world" (highlighted removed)   │   │
│  │                                                            │   │
│  │  Proposed Side:                                            │   │
│  │    "Hello " (unchanged) + "universe" (highlighted added)  │   │
│  └───────────────────────────────────────────────────────────┘   │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Component Dependencies

```
┌─────────────────────────────────────────────────────────────────┐
│               v0.4.2c Component Dependencies                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐     │
│  │                   DiffService                            │     │
│  │  (src/SeniorIntern.Services/DiffService.cs)             │     │
│  │  ┌─────────────────────────────────────────────────────┐│     │
│  │  │  - _inlineDiffService: IInlineDiffService           ││     │
│  │  │  - ComputeInlineDiffs(hunks, options)               ││     │
│  │  │  - ShouldComputeInlineDiff(original, proposed)      ││     │
│  │  │  - ComputeSimilarity(a, b)                          ││     │
│  │  │  - LevenshteinDistance(a, b)                        ││     │
│  │  └─────────────────────────────────────────────────────┘│     │
│  └────────────────────────────┬────────────────────────────┘     │
│                               │ Uses                              │
│                               ▼                                  │
│  ┌─────────────────────────────────────────────────────────┐     │
│  │              IInlineDiffService                          │     │
│  │  (src/SeniorIntern.Core/Interfaces/)                    │     │
│  │  ┌─────────────────────────────────────────────────────┐│     │
│  │  │  + ComputeInlineChanges(original, proposed)         ││     │
│  │  │  + GetInlineSegments(content, changes, side)        ││     │
│  │  └─────────────────────────────────────────────────────┘│     │
│  └────────────────────────────┬────────────────────────────┘     │
│                               │ Implemented by                    │
│                               ▼                                  │
│  ┌─────────────────────────────────────────────────────────┐     │
│  │              InlineDiffService                           │     │
│  │  (src/SeniorIntern.Services/InlineDiffService.cs)       │     │
│  │  ┌─────────────────────────────────────────────────────┐│     │
│  │  │  - _differ: DiffPlex.Differ                         ││     │
│  │  │  - CreateCharacterDiffs() integration               ││     │
│  │  │  - DiffBlock processing logic                       ││     │
│  │  └─────────────────────────────────────────────────────┘│     │
│  └─────────────────────────────────────────────────────────┘     │
│                                                                  │
│  Dependencies from v0.4.2a/b:                                    │
│  ┌─────────────────────────────────────────────────────────┐     │
│  │  - InlineChange model (v0.4.2a)                         │     │
│  │  - InlineChangeType enum (v0.4.2a)                      │     │
│  │  - DiffSide enum (v0.4.2a)                              │     │
│  │  - DiffOptions.ComputeInlineDiffs (v0.4.2b)             │     │
│  │  - DiffOptions.MaxInlineDiffLineLength (v0.4.2b)        │     │
│  │  - DiffLine.InlineChanges property (v0.4.2a)            │     │
│  │  - DiffLine.PairedLine property (v0.4.2a)               │     │
│  └─────────────────────────────────────────────────────────┘     │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## Detailed Design

### 1. IInlineDiffService Interface

**File**: `src/SeniorIntern.Core/Interfaces/IInlineDiffService.cs`

```csharp
// src/SeniorIntern.Core/Interfaces/IInlineDiffService.cs
namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Service for computing character-level inline diffs.
/// </summary>
/// <remarks>
/// This service enables precise highlighting of character changes within modified lines,
/// allowing users to see exactly which characters were added, removed, or remained unchanged.
/// </remarks>
public interface IInlineDiffService
{
    /// <summary>
    /// Compute inline changes between two lines.
    /// </summary>
    /// <param name="originalLine">The original line content.</param>
    /// <param name="proposedLine">The proposed (modified) line content.</param>
    /// <returns>
    /// A list of inline changes representing character-level modifications.
    /// Returns an empty list if lines are identical.
    /// </returns>
    /// <remarks>
    /// The returned changes include:
    /// - Unchanged segments (for context)
    /// - Removed segments (characters in original but not in proposed)
    /// - Added segments (characters in proposed but not in original)
    /// </remarks>
    IReadOnlyList<InlineChange> ComputeInlineChanges(
        string originalLine,
        string proposedLine);

    /// <summary>
    /// Split a line into segments with change information for rendering.
    /// </summary>
    /// <param name="content">The line content to segment.</param>
    /// <param name="changes">The inline changes computed for this line pair.</param>
    /// <param name="side">Which side of the diff (Original or Proposed).</param>
    /// <returns>
    /// Segments for rendering, filtered appropriately for the specified side.
    /// Original side excludes Added segments; Proposed side excludes Removed segments.
    /// </returns>
    IReadOnlyList<InlineSegment> GetInlineSegments(
        string content,
        IReadOnlyList<InlineChange> changes,
        DiffSide side);
}
```

### 2. InlineSegment Model

**File**: `src/SeniorIntern.Core/Models/InlineSegment.cs`

```csharp
// src/SeniorIntern.Core/Models/InlineSegment.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// A segment of text with inline change information for rendering.
/// </summary>
/// <remarks>
/// InlineSegment is the rendering-focused counterpart to InlineChange.
/// While InlineChange tracks the diff computation results, InlineSegment
/// represents what should actually be displayed on a specific side of the diff.
/// </remarks>
public sealed class InlineSegment
{
    /// <summary>
    /// The text content of this segment.
    /// </summary>
    public string Text { get; init; } = string.Empty;

    /// <summary>
    /// Whether this segment represents changed text.
    /// </summary>
    /// <remarks>
    /// When true, this segment should be visually highlighted in the diff view.
    /// The Type property indicates whether it was added or removed.
    /// </remarks>
    public bool IsChanged { get; init; }

    /// <summary>
    /// The type of change this segment represents.
    /// </summary>
    public InlineChangeType Type { get; init; }

    /// <summary>
    /// Character length of this segment.
    /// </summary>
    public int Length => Text.Length;

    /// <summary>
    /// Whether this segment is empty.
    /// </summary>
    public bool IsEmpty => string.IsNullOrEmpty(Text);
}
```

### 3. InlineDiffService Implementation

**File**: `src/SeniorIntern.Services/InlineDiffService.cs`

```csharp
// src/SeniorIntern.Services/InlineDiffService.cs
namespace SeniorIntern.Services;

using DiffPlex;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;

/// <summary>
/// Computes character-level inline diffs using DiffPlex.
/// </summary>
/// <remarks>
/// This service uses DiffPlex's character-level diff algorithm to identify
/// precisely which characters changed between two versions of a line.
/// The results can then be rendered to highlight inline changes in the UI.
/// </remarks>
public sealed class InlineDiffService : IInlineDiffService
{
    private readonly Differ _differ;

    /// <summary>
    /// Initializes a new instance of the InlineDiffService.
    /// </summary>
    public InlineDiffService()
    {
        _differ = new Differ();
    }

    /// <inheritdoc />
    public IReadOnlyList<InlineChange> ComputeInlineChanges(
        string originalLine,
        string proposedLine)
    {
        // Handle null inputs gracefully
        originalLine ??= string.Empty;
        proposedLine ??= string.Empty;

        // Quick path for identical lines
        if (originalLine == proposedLine)
        {
            return Array.Empty<InlineChange>();
        }

        // Quick path for completely different lines (one empty)
        if (string.IsNullOrEmpty(originalLine))
        {
            return new[]
            {
                new InlineChange
                {
                    StartColumn = 0,
                    Length = proposedLine.Length,
                    Text = proposedLine,
                    Type = InlineChangeType.Added
                }
            };
        }

        if (string.IsNullOrEmpty(proposedLine))
        {
            return new[]
            {
                new InlineChange
                {
                    StartColumn = 0,
                    Length = originalLine.Length,
                    Text = originalLine,
                    Type = InlineChangeType.Removed
                }
            };
        }

        var changes = new List<InlineChange>();

        // Use DiffPlex character-level diff
        var diff = _differ.CreateCharacterDiffs(originalLine, proposedLine, ignoreWhitespace: false);

        int origPos = 0;
        int propPos = 0;

        foreach (var block in diff.DiffBlocks)
        {
            // Add unchanged text before this block (from proposed perspective)
            if (block.InsertStartB > propPos)
            {
                var unchangedLength = block.InsertStartB - propPos;
                changes.Add(new InlineChange
                {
                    StartColumn = propPos,
                    Length = unchangedLength,
                    Text = proposedLine.Substring(propPos, unchangedLength),
                    Type = InlineChangeType.Unchanged
                });
            }

            // Add removed characters (from original)
            if (block.DeleteCountA > 0)
            {
                changes.Add(new InlineChange
                {
                    StartColumn = block.DeleteStartA,
                    Length = block.DeleteCountA,
                    Text = originalLine.Substring(block.DeleteStartA, block.DeleteCountA),
                    Type = InlineChangeType.Removed
                });
            }

            // Add inserted characters (in proposed)
            if (block.InsertCountB > 0)
            {
                changes.Add(new InlineChange
                {
                    StartColumn = block.InsertStartB,
                    Length = block.InsertCountB,
                    Text = proposedLine.Substring(block.InsertStartB, block.InsertCountB),
                    Type = InlineChangeType.Added
                });
            }

            origPos = block.DeleteStartA + block.DeleteCountA;
            propPos = block.InsertStartB + block.InsertCountB;
        }

        // Add any remaining unchanged text at the end
        if (propPos < proposedLine.Length)
        {
            changes.Add(new InlineChange
            {
                StartColumn = propPos,
                Length = proposedLine.Length - propPos,
                Text = proposedLine.Substring(propPos),
                Type = InlineChangeType.Unchanged
            });
        }

        return changes;
    }

    /// <inheritdoc />
    public IReadOnlyList<InlineSegment> GetInlineSegments(
        string content,
        IReadOnlyList<InlineChange> changes,
        DiffSide side)
    {
        // No changes means return the whole content as unchanged
        if (changes == null || changes.Count == 0)
        {
            return new[]
            {
                new InlineSegment
                {
                    Text = content ?? string.Empty,
                    IsChanged = false,
                    Type = InlineChangeType.Unchanged
                }
            };
        }

        var segments = new List<InlineSegment>();

        foreach (var change in changes)
        {
            // Filter based on which side we're rendering
            // Original side: show Unchanged and Removed (not Added)
            // Proposed side: show Unchanged and Added (not Removed)
            bool includeSegment = change.Type switch
            {
                InlineChangeType.Unchanged => true,
                InlineChangeType.Added => side == DiffSide.Proposed,
                InlineChangeType.Removed => side == DiffSide.Original,
                _ => true
            };

            if (includeSegment && !string.IsNullOrEmpty(change.Text))
            {
                segments.Add(new InlineSegment
                {
                    Text = change.Text,
                    IsChanged = change.Type != InlineChangeType.Unchanged,
                    Type = change.Type
                });
            }
        }

        // If no segments were created, return the content as unchanged
        if (segments.Count == 0)
        {
            return new[]
            {
                new InlineSegment
                {
                    Text = content ?? string.Empty,
                    IsChanged = false,
                    Type = InlineChangeType.Unchanged
                }
            };
        }

        return segments;
    }
}
```

### 4. DiffService Integration

**File**: `src/SeniorIntern.Services/DiffService.cs` (modifications)

```csharp
// Add to DiffService.cs - these are the methods to add/update

// Add field
private readonly IInlineDiffService _inlineDiffService;

// Update constructor to initialize inline diff service
public DiffService(
    IFileSystemService fileSystemService,
    ILogger<DiffService>? logger = null,
    DiffOptions? defaultOptions = null)
{
    _fileSystemService = fileSystemService;
    _logger = logger;
    _defaultOptions = defaultOptions ?? DiffOptions.Default;

    _differ = new Differ();
    _inlineDiffBuilder = new InlineDiffBuilder(_differ);
    _sideBySideDiffBuilder = new SideBySideDiffBuilder(_differ);

    // Initialize inline diff service
    _inlineDiffService = new InlineDiffService();
}

/// <summary>
/// Computes inline character-level diffs for modified line pairs within hunks.
/// </summary>
/// <param name="hunks">The diff hunks to process.</param>
/// <param name="options">Diff options including inline diff settings.</param>
/// <remarks>
/// This method identifies adjacent Removed/Added line pairs that represent
/// modifications (rather than pure insertions/deletions) and computes
/// character-level changes for them.
/// </remarks>
private void ComputeInlineDiffs(List<DiffHunk> hunks, DiffOptions options)
{
    foreach (var hunk in hunks)
    {
        // Work with a mutable copy of lines
        var lines = hunk.Lines.ToList();

        for (int i = 0; i < lines.Count - 1; i++)
        {
            var current = lines[i];
            var next = lines[i + 1];

            // Look for Removed → Added pairs that likely represent modifications
            // This pattern indicates a line was changed rather than purely added or removed
            if (current.Type == DiffLineType.Removed &&
                next.Type == DiffLineType.Added)
            {
                // Check if lines are similar enough to warrant inline diff
                if (ShouldComputeInlineDiff(current.Content, next.Content, options))
                {
                    var inlineChanges = _inlineDiffService.ComputeInlineChanges(
                        current.Content,
                        next.Content);

                    // Update both lines with the computed inline changes
                    // Using 'with' expression for immutable record update
                    lines[i] = current with { InlineChanges = inlineChanges };
                    lines[i + 1] = next with { InlineChanges = inlineChanges };

                    // Link the paired lines for synchronized rendering
                    lines[i].PairedLine = lines[i + 1];
                    lines[i + 1].PairedLine = lines[i];

                    _logger?.LogDebug(
                        "Computed inline diff for line pair at index {Index}: {ChangeCount} changes",
                        i, inlineChanges.Count);
                }
            }
        }
    }
}

/// <summary>
/// Determines whether inline diff should be computed for a line pair.
/// </summary>
/// <param name="original">The original line content.</param>
/// <param name="proposed">The proposed line content.</param>
/// <param name="options">Diff options with thresholds.</param>
/// <returns>True if inline diff should be computed; false otherwise.</returns>
/// <remarks>
/// Inline diffs are skipped for:
/// - Very long lines (exceeds MaxInlineDiffLineLength)
/// - Very dissimilar lines (similarity below 30%)
///
/// The similarity threshold prevents computing inline diffs for lines
/// that are so different they would produce confusing results.
/// </remarks>
private static bool ShouldComputeInlineDiff(
    string original,
    string proposed,
    DiffOptions options)
{
    // Skip very long lines to avoid performance issues and visual clutter
    if (original.Length > options.MaxInlineDiffLineLength ||
        proposed.Length > options.MaxInlineDiffLineLength)
    {
        return false;
    }

    // Skip if lines are too different (inline diff would be confusing)
    var similarity = ComputeSimilarity(original, proposed);

    // Require at least 30% similarity for inline diff to be meaningful
    const double MinSimilarityThreshold = 0.3;
    return similarity >= MinSimilarityThreshold;
}

/// <summary>
/// Computes similarity ratio between two strings using Levenshtein distance.
/// </summary>
/// <param name="a">First string.</param>
/// <param name="b">Second string.</param>
/// <returns>Similarity ratio from 0.0 (completely different) to 1.0 (identical).</returns>
private static double ComputeSimilarity(string a, string b)
{
    // Handle edge cases
    if (string.IsNullOrEmpty(a) && string.IsNullOrEmpty(b))
        return 1.0;
    if (string.IsNullOrEmpty(a) || string.IsNullOrEmpty(b))
        return 0.0;

    int maxLen = Math.Max(a.Length, b.Length);
    int distance = LevenshteinDistance(a, b);

    // Convert distance to similarity ratio
    return 1.0 - ((double)distance / maxLen);
}

/// <summary>
/// Computes the Levenshtein (edit) distance between two strings.
/// </summary>
/// <param name="a">First string.</param>
/// <param name="b">Second string.</param>
/// <returns>The minimum number of single-character edits to transform a into b.</returns>
/// <remarks>
/// Uses the space-optimized single-row algorithm with O(min(m,n)) space complexity
/// and O(m*n) time complexity where m and n are the string lengths.
/// </remarks>
private static int LevenshteinDistance(string a, string b)
{
    // Optimization: ensure 'b' is the shorter string for better space efficiency
    if (a.Length < b.Length)
    {
        (a, b) = (b, a);
    }

    var costs = new int[b.Length + 1];

    // Initialize base case: transforming empty string to b[0..j]
    for (int i = 0; i <= b.Length; i++)
    {
        costs[i] = i;
    }

    // Fill in the distance matrix row by row
    for (int i = 1; i <= a.Length; i++)
    {
        int previousCost = costs[0];
        costs[0] = i;

        for (int j = 1; j <= b.Length; j++)
        {
            int currentCost = costs[j];

            // Cost is 0 if characters match, 1 otherwise
            int substitutionCost = a[i - 1] == b[j - 1] ? 0 : 1;

            // Minimum of insertion, deletion, or substitution
            costs[j] = Math.Min(
                Math.Min(
                    costs[j - 1] + 1,      // Insertion
                    costs[j] + 1),          // Deletion
                previousCost + substitutionCost  // Substitution
            );

            previousCost = currentCost;
        }
    }

    return costs[b.Length];
}
```

---

## Configuration Options

### DiffOptions Properties (from v0.4.2b)

The following `DiffOptions` properties control inline diff behavior:

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `ComputeInlineDiffs` | `bool` | `true` | Whether to compute character-level inline diffs |
| `MaxInlineDiffLineLength` | `int` | `500` | Maximum line length for inline diff computation |

### Similarity Threshold

The similarity threshold is implemented as a constant in `DiffService`:

```csharp
const double MinSimilarityThreshold = 0.3;
```

This can be made configurable in future versions by adding to `DiffOptions`:

```csharp
/// <summary>
/// Minimum similarity ratio (0.0-1.0) for computing inline diffs.
/// Lines with lower similarity skip inline diff computation.
/// </summary>
public double MinInlineSimilarity { get; init; } = 0.3;
```

---

## Usage Examples

### Example 1: Basic Inline Diff Computation

```csharp
var inlineDiffService = new InlineDiffService();

// Compute inline changes for a modified line
var changes = inlineDiffService.ComputeInlineChanges(
    "public void ProcessData(string input)",
    "public void ProcessData(string input, bool validate)"
);

// Result: Changes will identify ", bool validate" as Added
```

### Example 2: Getting Segments for Rendering

```csharp
var changes = inlineDiffService.ComputeInlineChanges(
    "var count = 10;",
    "var count = 25;");

// Get segments for original side (will show "10" as removed)
var originalSegments = inlineDiffService.GetInlineSegments(
    "var count = 10;",
    changes,
    DiffSide.Original);

// Get segments for proposed side (will show "25" as added)
var proposedSegments = inlineDiffService.GetInlineSegments(
    "var count = 25;",
    changes,
    DiffSide.Proposed);
```

### Example 3: Full Diff Pipeline with Inline Changes

```csharp
var diffService = new DiffService(fileSystemService);

// Compute diff with inline changes enabled (default)
var result = diffService.ComputeDiff(
    originalCode,
    proposedCode,
    "src/Example.cs");

// Access inline changes on modified lines
foreach (var hunk in result.Hunks)
{
    foreach (var line in hunk.Lines)
    {
        if (line.HasInlineChanges)
        {
            Console.WriteLine($"Line {line.OriginalLineNumber} has inline changes:");
            foreach (var change in line.InlineChanges!)
            {
                Console.WriteLine($"  [{change.Type}] '{change.Text}' at column {change.StartColumn}");
            }
        }
    }
}
```

---

## Visual Rendering Examples

### Example: Variable Rename

```
Original:  var userName = "test";
               ^^^^^^^^ (highlighted as removed)

Proposed:  var displayName = "test";
               ^^^^^^^^^^^ (highlighted as added)
```

### Example: Value Change

```
Original:  const int MAX_RETRIES = 3;
                                   ^ (highlighted as removed)

Proposed:  const int MAX_RETRIES = 5;
                                   ^ (highlighted as added)
```

### Example: Added Parameter

```
Original:  public void Save(Entity entity)
                                          (no highlight after closing paren)

Proposed:  public void Save(Entity entity, bool async)
                                         ^^^^^^^^^^^^ (highlighted as added)
```

---

## Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/IInlineDiffService.cs` | Interface for character-level inline diff service |
| `src/SeniorIntern.Core/Models/InlineSegment.cs` | Rendering model for text segments |
| `src/SeniorIntern.Services/InlineDiffService.cs` | DiffPlex-based implementation |

## Files to Modify

| File | Changes |
|------|---------|
| `src/SeniorIntern.Services/DiffService.cs` | Add `_inlineDiffService` field, implement `ComputeInlineDiffs`, `ShouldComputeInlineDiff`, `ComputeSimilarity`, and `LevenshteinDistance` methods |
| `src/SeniorIntern.Desktop/Extensions/ServiceCollectionExtensions.cs` | Register `IInlineDiffService` with DI container |

---

## Testing Strategy

### Unit Tests for InlineDiffService

```csharp
// src/SeniorIntern.Tests/Services/InlineDiffServiceTests.cs
namespace SeniorIntern.Tests.Services;

public class InlineDiffServiceTests
{
    private readonly InlineDiffService _service;

    public InlineDiffServiceTests()
    {
        _service = new InlineDiffService();
    }

    #region ComputeInlineChanges Tests

    [Fact]
    public void ComputeInlineChanges_IdenticalLines_ReturnsEmpty()
    {
        var changes = _service.ComputeInlineChanges("same text", "same text");

        Assert.Empty(changes);
    }

    [Fact]
    public void ComputeInlineChanges_SingleWordChange_IdentifiesCorrectly()
    {
        var changes = _service.ComputeInlineChanges(
            "Hello world",
            "Hello universe");

        Assert.Contains(changes, c =>
            c.Type == InlineChangeType.Unchanged && c.Text == "Hello ");
        Assert.Contains(changes, c =>
            c.Type == InlineChangeType.Removed && c.Text == "world");
        Assert.Contains(changes, c =>
            c.Type == InlineChangeType.Added && c.Text == "universe");
    }

    [Fact]
    public void ComputeInlineChanges_EmptyOriginal_AllAdded()
    {
        var changes = _service.ComputeInlineChanges("", "new text");

        Assert.Single(changes);
        Assert.Equal(InlineChangeType.Added, changes[0].Type);
        Assert.Equal("new text", changes[0].Text);
    }

    [Fact]
    public void ComputeInlineChanges_EmptyProposed_AllRemoved()
    {
        var changes = _service.ComputeInlineChanges("old text", "");

        Assert.Single(changes);
        Assert.Equal(InlineChangeType.Removed, changes[0].Type);
        Assert.Equal("old text", changes[0].Text);
    }

    [Fact]
    public void ComputeInlineChanges_NullInputs_HandledGracefully()
    {
        var changes = _service.ComputeInlineChanges(null!, null!);
        Assert.Empty(changes);
    }

    [Fact]
    public void ComputeInlineChanges_PreservesColumnPositions()
    {
        var changes = _service.ComputeInlineChanges(
            "abc123xyz",
            "abc456xyz");

        var removedChange = changes.First(c => c.Type == InlineChangeType.Removed);
        var addedChange = changes.First(c => c.Type == InlineChangeType.Added);

        Assert.Equal(3, removedChange.StartColumn);
        Assert.Equal("123", removedChange.Text);
        Assert.Equal(3, addedChange.StartColumn);
        Assert.Equal("456", addedChange.Text);
    }

    [Fact]
    public void ComputeInlineChanges_MultipleChanges_AllDetected()
    {
        var changes = _service.ComputeInlineChanges(
            "var x = 10; var y = 20;",
            "var x = 15; var y = 25;");

        var addedChanges = changes.Where(c => c.Type == InlineChangeType.Added).ToList();
        var removedChanges = changes.Where(c => c.Type == InlineChangeType.Removed).ToList();

        // Should detect changes at both numeric literals
        Assert.True(removedChanges.Any(c => c.Text.Contains("10") || c.Text.Contains("0")));
        Assert.True(addedChanges.Any(c => c.Text.Contains("15") || c.Text.Contains("5")));
    }

    #endregion

    #region GetInlineSegments Tests

    [Fact]
    public void GetInlineSegments_OriginalSide_ExcludesAdded()
    {
        var changes = _service.ComputeInlineChanges("old", "new");

        var segments = _service.GetInlineSegments("old", changes, DiffSide.Original);

        Assert.DoesNotContain(segments, s => s.Type == InlineChangeType.Added);
    }

    [Fact]
    public void GetInlineSegments_ProposedSide_ExcludesRemoved()
    {
        var changes = _service.ComputeInlineChanges("old", "new");

        var segments = _service.GetInlineSegments("new", changes, DiffSide.Proposed);

        Assert.DoesNotContain(segments, s => s.Type == InlineChangeType.Removed);
    }

    [Fact]
    public void GetInlineSegments_NoChanges_ReturnsFullContent()
    {
        var segments = _service.GetInlineSegments(
            "unchanged content",
            Array.Empty<InlineChange>(),
            DiffSide.Original);

        Assert.Single(segments);
        Assert.Equal("unchanged content", segments[0].Text);
        Assert.False(segments[0].IsChanged);
    }

    [Fact]
    public void GetInlineSegments_NullChanges_ReturnsFullContent()
    {
        var segments = _service.GetInlineSegments("content", null!, DiffSide.Original);

        Assert.Single(segments);
        Assert.Equal("content", segments[0].Text);
    }

    [Fact]
    public void GetInlineSegments_MarksChangedSegmentsCorrectly()
    {
        var changes = _service.ComputeInlineChanges("Hello world", "Hello universe");

        var segments = _service.GetInlineSegments("Hello universe", changes, DiffSide.Proposed);

        var unchangedSegment = segments.First(s => s.Text == "Hello ");
        var addedSegment = segments.First(s => s.Text == "universe");

        Assert.False(unchangedSegment.IsChanged);
        Assert.True(addedSegment.IsChanged);
        Assert.Equal(InlineChangeType.Added, addedSegment.Type);
    }

    #endregion
}
```

### Integration Tests for DiffService Inline Diff

```csharp
// src/SeniorIntern.Tests/Services/DiffServiceInlineDiffTests.cs
namespace SeniorIntern.Tests.Services;

public class DiffServiceInlineDiffTests
{
    private readonly Mock<IFileSystemService> _fileSystemMock;
    private readonly DiffService _service;

    public DiffServiceInlineDiffTests()
    {
        _fileSystemMock = new Mock<IFileSystemService>();
        _service = new DiffService(_fileSystemMock.Object);
    }

    [Fact]
    public void ComputeDiff_ModifiedLine_HasInlineChanges()
    {
        var original = "var count = 10;";
        var proposed = "var count = 25;";

        var result = _service.ComputeDiff(original, proposed);

        // Find the modified lines
        var removedLine = result.Hunks
            .SelectMany(h => h.Lines)
            .FirstOrDefault(l => l.Type == DiffLineType.Removed);
        var addedLine = result.Hunks
            .SelectMany(h => h.Lines)
            .FirstOrDefault(l => l.Type == DiffLineType.Added);

        Assert.NotNull(removedLine);
        Assert.NotNull(addedLine);
        Assert.True(removedLine!.HasInlineChanges);
        Assert.True(addedLine!.HasInlineChanges);
    }

    [Fact]
    public void ComputeDiff_VeryDifferentLines_NoInlineChanges()
    {
        var original = "completely different line here";
        var proposed = "xyz123!@#$%^";

        var result = _service.ComputeDiff(original, proposed);

        // Lines should not have inline changes due to low similarity
        var hasAnyInlineChanges = result.Hunks
            .SelectMany(h => h.Lines)
            .Any(l => l.HasInlineChanges);

        Assert.False(hasAnyInlineChanges);
    }

    [Fact]
    public void ComputeDiff_PairedLinesLinked()
    {
        var original = "var x = 10;";
        var proposed = "var x = 20;";

        var result = _service.ComputeDiff(original, proposed);

        var removedLine = result.Hunks
            .SelectMany(h => h.Lines)
            .First(l => l.Type == DiffLineType.Removed);

        Assert.NotNull(removedLine.PairedLine);
        Assert.Equal(DiffLineType.Added, removedLine.PairedLine!.Type);
    }

    [Fact]
    public void ComputeDiff_WithInlineDisabled_NoInlineChanges()
    {
        var options = new DiffOptions { ComputeInlineDiffs = false };
        var service = new DiffService(_fileSystemMock.Object, options: options);

        var result = service.ComputeDiff("var x = 10;", "var x = 20;");

        var hasAnyInlineChanges = result.Hunks
            .SelectMany(h => h.Lines)
            .Any(l => l.HasInlineChanges);

        Assert.False(hasAnyInlineChanges);
    }

    [Fact]
    public void ComputeDiff_LongLine_SkipsInlineDiff()
    {
        var options = new DiffOptions { MaxInlineDiffLineLength = 10 };
        var service = new DiffService(_fileSystemMock.Object, options: options);

        // Lines longer than 10 chars
        var original = "this is a very long line that exceeds the limit";
        var proposed = "this is a very long line that changed a bit";

        var result = service.ComputeDiff(original, proposed);

        var hasAnyInlineChanges = result.Hunks
            .SelectMany(h => h.Lines)
            .Any(l => l.HasInlineChanges);

        Assert.False(hasAnyInlineChanges);
    }
}
```

### Levenshtein Distance Tests

```csharp
// src/SeniorIntern.Tests/Services/LevenshteinDistanceTests.cs
namespace SeniorIntern.Tests.Services;

public class LevenshteinDistanceTests
{
    [Theory]
    [InlineData("", "", 0)]
    [InlineData("abc", "abc", 0)]
    [InlineData("abc", "", 3)]
    [InlineData("", "abc", 3)]
    [InlineData("abc", "abd", 1)]
    [InlineData("abc", "adc", 1)]
    [InlineData("kitten", "sitting", 3)]
    [InlineData("saturday", "sunday", 3)]
    public void LevenshteinDistance_ComputesCorrectly(
        string a, string b, int expectedDistance)
    {
        // Access via reflection since it's private
        var method = typeof(DiffService).GetMethod(
            "LevenshteinDistance",
            System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Static);

        var result = method!.Invoke(null, new object[] { a, b });

        Assert.Equal(expectedDistance, result);
    }

    [Theory]
    [InlineData("abc", "abc", 1.0)]
    [InlineData("abc", "abd", 0.666, 0.01)]
    [InlineData("abc", "xyz", 0.0)]
    [InlineData("", "", 1.0)]
    public void ComputeSimilarity_ComputesCorrectly(
        string a, string b, double expected, double tolerance = 0.001)
    {
        var method = typeof(DiffService).GetMethod(
            "ComputeSimilarity",
            System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Static);

        var result = (double)method!.Invoke(null, new object[] { a, b })!;

        Assert.InRange(result, expected - tolerance, expected + tolerance);
    }
}
```

---

## Acceptance Criteria

- [ ] `IInlineDiffService` interface defined with `ComputeInlineChanges` and `GetInlineSegments` methods
- [ ] `InlineSegment` model created with `Text`, `IsChanged`, and `Type` properties
- [ ] `InlineDiffService` implementation uses DiffPlex `CreateCharacterDiffs` API
- [ ] Character-level changes correctly identify added, removed, and unchanged segments
- [ ] Column positions (StartColumn, EndColumn) are accurate for all changes
- [ ] `GetInlineSegments` correctly filters changes based on DiffSide (Original/Proposed)
- [ ] `DiffService.ComputeInlineDiffs` processes all hunks for inline changes
- [ ] Adjacent Removed/Added line pairs are correctly identified for inline processing
- [ ] `ShouldComputeInlineDiff` respects `MaxInlineDiffLineLength` option
- [ ] Similarity threshold (30%) prevents inline diffs for very different lines
- [ ] `LevenshteinDistance` algorithm is space-optimized O(min(m,n))
- [ ] Paired lines are linked via `DiffLine.PairedLine` property
- [ ] `DiffLine.HasInlineChanges` returns true when `InlineChanges` is populated
- [ ] All null/empty edge cases handled gracefully
- [ ] Unit tests pass for `InlineDiffService`
- [ ] Integration tests pass for `DiffService` inline diff functionality
- [ ] Inline diff can be disabled via `DiffOptions.ComputeInlineDiffs = false`

---

## Performance Considerations

### Levenshtein Distance Optimization

The implementation uses a space-optimized single-row algorithm:

| Aspect | Complexity |
|--------|------------|
| Time | O(m × n) where m and n are string lengths |
| Space | O(min(m, n)) - single row instead of full matrix |

### Inline Diff Thresholds

| Threshold | Value | Purpose |
|-----------|-------|---------|
| `MaxInlineDiffLineLength` | 500 | Prevents expensive computation on very long lines |
| `MinSimilarityThreshold` | 0.3 | Skips inline diff for very dissimilar lines |

### Recommendations

1. **Long Lines**: Lines exceeding 500 characters skip inline diff to avoid performance issues and visual clutter
2. **Similarity Check**: Computing Levenshtein distance before inline diff prevents wasted computation
3. **Early Exit**: Identical lines return empty changes immediately

---

## Future Enhancements

### Potential v0.4.2c+ Improvements

1. **Word-Level Diff Option**: Add option for word-boundary-aware diffing instead of pure character diff
2. **Configurable Similarity Threshold**: Expose `MinInlineSimilarity` in `DiffOptions`
3. **Semantic Diff**: Consider syntax-aware diffing for programming languages
4. **Whitespace Handling**: Option to ignore whitespace changes in inline diff
5. **Performance Caching**: Cache similarity computations for repeated comparisons

---

## Dependencies

### From v0.4.2a (Diff Models)

- `InlineChange` model
- `InlineChangeType` enum
- `DiffSide` enum
- `DiffLine.InlineChanges` property
- `DiffLine.PairedLine` property
- `DiffLine.HasInlineChanges` computed property

### From v0.4.2b (Diff Service)

- `DiffOptions.ComputeInlineDiffs` setting
- `DiffOptions.MaxInlineDiffLineLength` setting
- `DiffService` class structure
- DiffPlex library integration

### External

- DiffPlex NuGet package (already added in v0.4.2b)
  - `Differ.CreateCharacterDiffs()` method
  - `DiffBlock` model

---

## Revision History

| Version | Date | Changes |
|---------|------|---------|
| 1.0 | 2025-01-10 | Initial design specification |
