# Design Specification: The Senior Intern v0.4.1g "ViewModel Integration"

**Status**: _IMPLEMENTED_

## Executive Summary

This document provides a comprehensive implementation specification for v0.4.1g, which integrates the code block parsing and streaming capabilities into the MVVM ViewModel layer. This creates the bridge between the service-layer code block extraction and the UI, enabling real-time display of code blocks during LLM streaming with interactive actions like copy, apply, and show diff.

### v0.4.1g Scope

- Create `CodeBlockViewModel` for individual code block UI binding
- Create `CodeProposalViewModel` for managing collections of code blocks
- Update `ChatMessageViewModel` with code block support and streaming integration
- Update `ChatViewModel` to wire streaming parser events during generation
- Implement clipboard copy functionality
- Create messaging system for cross-ViewModel communication
- Handle code block status updates and statistics

### Key Deliverables

| Deliverable | Description |
|-------------|-------------|
| CodeBlockViewModel | ViewModel for individual code block with commands |
| CodeProposalViewModel | Container ViewModel for multiple code blocks |
| ChatMessageViewModel (updated) | Code block collection and streaming support |
| ChatViewModel (updated) | Streaming parser integration |
| CodeBlockMessages | Messenger messages for copy, apply, diff actions |
| IClipboardService | Abstraction for clipboard operations |

---

## Prerequisites

Before implementing v0.4.1g, ensure:

- v0.4.1a is complete (CodeBlock, CodeProposal, CodeBlockStatus models)
- v0.4.1b is complete (ICodeBlockParserService)
- v0.4.1e is complete (IFilePathInferenceService)
- v0.4.1f is complete (IStreamingCodeBlockParser, events)
- v0.1.0 is complete (existing ChatViewModel, ChatMessageViewModel)

---

## Feature Overview

```
┌───────────────────────────────────────────────────────────────────────┐
│                     v0.4.1g Feature Tree                               │
├───────────────────────────────────────────────────────────────────────┤
│                                                                        │
│  CodeBlockViewModel                                                    │
│  ├── Properties (Observable)                                           │
│  │   ├── Id, Content, Language, DisplayLanguage                       │
│  │   ├── TargetFilePath, BlockType, Status                            │
│  │   ├── ConfidenceScore, LineCount                                   │
│  │   ├── IsStreaming, IsSelected, IsExpanded                          │
│  │   └── PathInferenceResult                                          │
│  │                                                                     │
│  ├── Computed Properties                                               │
│  │   ├── IsApplicable → can apply to file                             │
│  │   ├── IsExample, IsCommand, IsOutput → type checks                 │
│  │   ├── ShowApplyButton, ShowStatusBadge                             │
│  │   ├── FileName → extracted from path                               │
│  │   ├── StatusText, StatusIcon                                       │
│  │   └── FormattedLineCount → "X lines"                               │
│  │                                                                     │
│  ├── Commands                                                          │
│  │   ├── CopyToClipboardCommand                                       │
│  │   ├── ShowDiffCommand                                              │
│  │   ├── ApplyChangesCommand                                          │
│  │   ├── RejectChangesCommand                                         │
│  │   └── SelectFilePathCommand (for ambiguous paths)                  │
│  │                                                                     │
│  └── Streaming Methods                                                 │
│      ├── AppendContent(token)                                         │
│      ├── UpdateFromPartial(PartialCodeBlock)                          │
│      └── CompleteStreaming(CodeBlock)                                 │
│                                                                        │
│  CodeProposalViewModel                                                 │
│  ├── Properties                                                        │
│  │   ├── Id, MessageId, Status                                        │
│  │   └── CodeBlocks (ObservableCollection)                            │
│  │                                                                     │
│  ├── Computed Properties                                               │
│  │   ├── ApplicableCount, AppliedCount, TotalCount                    │
│  │   ├── HasApplicableBlocks, IsFullyApplied                          │
│  │   ├── IsPartiallyApplied, AffectedFiles                            │
│  │   └── ProgressText → "2 of 5 applied"                              │
│  │                                                                     │
│  └── Commands                                                          │
│      ├── ApplyAllCommand                                              │
│      ├── RejectAllCommand                                             │
│      └── ShowSummaryCommand                                           │
│                                                                        │
│  ChatMessageViewModel (Updates)                                        │
│  ├── New Properties                                                    │
│  │   ├── CodeBlocks (ObservableCollection<CodeBlockViewModel>)        │
│  │   ├── HasCodeBlocks, HasApplicableCode                             │
│  │   ├── ApplicableBlockCount, TotalBlockCount                        │
│  │   └── CurrentStreamingBlock                                        │
│  │                                                                     │
│  ├── New Methods                                                       │
│  │   ├── ParseCodeBlocks(parser, context)                             │
│  │   ├── BeginCodeBlock(PartialCodeBlock)                             │
│  │   ├── UpdateStreamingBlock(content)                                │
│  │   ├── CompleteCurrentBlock(CodeBlock)                              │
│  │   └── UpdateCodeBlockStats()                                       │
│  │                                                                     │
│  └── Commands                                                          │
│      ├── CopyCodeCommand(CodeBlockViewModel)                          │
│      ├── ApplyAllCodeCommand                                          │
│      └── RejectAllCodeCommand                                         │
│                                                                        │
│  ChatViewModel (Updates)                                               │
│  ├── New Dependencies                                                  │
│  │   ├── IStreamingParserFactory                                      │
│  │   ├── ICodeBlockParserService                                      │
│  │   └── IClipboardService                                            │
│  │                                                                     │
│  ├── Streaming Integration                                             │
│  │   ├── Create parser per message                                    │
│  │   ├── Subscribe to BlockStarted, ContentAdded, BlockCompleted      │
│  │   ├── Marshal events to UI thread                                  │
│  │   └── Update ChatMessageViewModel in real-time                     │
│  │                                                                     │
│  └── Context Management                                                │
│      ├── AttachedFiles collection (from workspace)                    │
│      └── Pass context to parser for path inference                    │
│                                                                        │
└───────────────────────────────────────────────────────────────────────┘
```

---

## Architecture Diagrams

### ViewModel Hierarchy

```
┌─────────────────────────────────────────────────────────────────────────┐
│                       ViewModel Hierarchy                                │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  MainWindowViewModel                                                     │
│       │                                                                  │
│       ├── ModelSelectorViewModel                                         │
│       │                                                                  │
│       └── ChatViewModel ◄────────────────────────────────────────────┐  │
│            │                                                          │  │
│            │  Dependencies:                                           │  │
│            │  • ILlmService                                           │  │
│            │  • IConversationService                                  │  │
│            │  • ISettingsService                                      │  │
│            │  • IStreamingParserFactory (NEW)                         │  │
│            │  • ICodeBlockParserService (NEW)                         │  │
│            │  • IClipboardService (NEW)                               │  │
│            │                                                          │  │
│            └── Messages: ObservableCollection<ChatMessageViewModel>   │  │
│                 │                                                     │  │
│                 └── ChatMessageViewModel                              │  │
│                      │                                                │  │
│                      │  Properties:                                   │  │
│                      │  • Id, Content, Role, Timestamp                │  │
│                      │  • IsStreaming                                 │  │
│                      │  • CodeBlocks (NEW)                            │  │
│                      │  • HasCodeBlocks, HasApplicableCode (NEW)      │  │
│                      │                                                │  │
│                      └── CodeBlocks: ObservableCollection             │  │
│                           │                                           │  │
│                           └── CodeBlockViewModel                      │  │
│                                │                                      │  │
│                                │  Properties:                         │  │
│                                │  • Id, Content, Language             │  │
│                                │  • TargetFilePath, BlockType         │  │
│                                │  • Status, IsStreaming               │  │
│                                │                                      │  │
│                                │  Commands:                           │  │
│                                │  • CopyToClipboard                   │  │
│                                │  • ShowDiff ──────────────────────┐  │  │
│                                │  • ApplyChanges ───────────────┐  │  │  │
│                                │                                │  │  │  │
│  Messenger Messages ◄───────────────────────────────────────────┴──┘  │  │
│  • ShowDiffRequestMessage                                             │  │
│  • ApplyChangesRequestMessage                                         │  │
│  • CodeBlockStatusChangedMessage                                      │  │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### Streaming Integration Flow

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    Streaming Integration Flow                            │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  User sends message                                                      │
│       │                                                                  │
│       ▼                                                                  │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │ ChatViewModel.SendMessageAsync()                                 │   │
│  │                                                                   │   │
│  │ 1. Create ChatMessageViewModel for assistant response            │   │
│  │ 2. Create streaming parser for this message                      │   │
│  │    var parser = _parserFactory.Create(messageVm.Id);             │   │
│  │ 3. Subscribe to parser events                                    │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│       │                                                                  │
│       ▼                                                                  │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │ Token streaming loop                                             │   │
│  │                                                                   │   │
│  │ await foreach (var token in _llmService.GenerateStreamingAsync)  │   │
│  │ {                                                                 │   │
│  │     // Update message content                                    │   │
│  │     messageVm.AppendContent(token);                              │   │
│  │                                                                   │   │
│  │     // Feed to parser (fires events)                             │   │
│  │     parser.FeedToken(token);                                     │   │
│  │ }                                                                 │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│       │                                                                  │
│       │  Parser Events                                                   │
│       │                                                                  │
│       ├─────► BlockStarted ─────────────────────────────────────────┐   │
│       │       │                                                     │   │
│       │       ▼                                                     │   │
│       │  ┌─────────────────────────────────────────────────────┐    │   │
│       │  │ OnBlockStarted (on UI thread via Dispatcher)        │    │   │
│       │  │                                                      │    │   │
│       │  │ var blockVm = new CodeBlockViewModel                │    │   │
│       │  │ {                                                    │    │   │
│       │  │     Id = e.Block.Id,                                │    │   │
│       │  │     Language = e.Block.Language,                    │    │   │
│       │  │     TargetFilePath = e.Block.TargetFilePath,        │    │   │
│       │  │     IsStreaming = true                              │    │   │
│       │  │ };                                                   │    │   │
│       │  │ messageVm.CodeBlocks.Add(blockVm);                  │    │   │
│       │  │ messageVm.CurrentStreamingBlock = blockVm;          │    │   │
│       │  └─────────────────────────────────────────────────────┘    │   │
│       │                                                              │   │
│       ├─────► ContentAdded ─────────────────────────────────────────┤   │
│       │       │                                                     │   │
│       │       ▼                                                     │   │
│       │  ┌─────────────────────────────────────────────────────┐    │   │
│       │  │ OnContentAdded (throttled, batched)                 │    │   │
│       │  │                                                      │    │   │
│       │  │ messageVm.CurrentStreamingBlock?.AppendContent(     │    │   │
│       │  │     e.Content);                                     │    │   │
│       │  └─────────────────────────────────────────────────────┘    │   │
│       │                                                              │   │
│       └─────► BlockCompleted ───────────────────────────────────────┘   │
│               │                                                          │
│               ▼                                                          │
│          ┌─────────────────────────────────────────────────────┐        │
│          │ OnBlockCompleted                                    │        │
│          │                                                      │        │
│          │ var blockVm = messageVm.CurrentStreamingBlock;      │        │
│          │ blockVm.Content = e.Block.Content;                  │        │
│          │ blockVm.BlockType = e.Block.BlockType;              │        │
│          │ blockVm.LineCount = e.Block.LineCount;              │        │
│          │ blockVm.IsStreaming = false;                        │        │
│          │                                                      │        │
│          │ // Infer path if needed                             │        │
│          │ InferPathForBlock(blockVm);                         │        │
│          │                                                      │        │
│          │ messageVm.UpdateCodeBlockStats();                   │        │
│          │ messageVm.CurrentStreamingBlock = null;             │        │
│          └─────────────────────────────────────────────────────┘        │
│                                                                          │
│  Streaming complete                                                      │
│       │                                                                  │
│       ▼                                                                  │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │ parser.Complete();                                               │   │
│  │ parser.Dispose();                                                │   │
│  │ messageVm.CompleteStreaming();                                   │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### Command Messaging Flow

```
┌─────────────────────────────────────────────────────────────────────────┐
│                       Command Messaging Flow                             │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  User clicks "Apply" button on CodeBlockControl                          │
│       │                                                                  │
│       ▼                                                                  │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │ CodeBlockViewModel.ShowDiffCommand                               │   │
│  │                                                                   │   │
│  │ WeakReferenceMessenger.Default.Send(                             │   │
│  │     new ShowDiffRequestMessage(this));                           │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│       │                                                                  │
│       │  Message travels via WeakReferenceMessenger                      │
│       │                                                                  │
│       ▼                                                                  │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │ MainWindowViewModel (registered recipient)                       │   │
│  │                                                                   │   │
│  │ Receives ShowDiffRequestMessage                                  │   │
│  │                                                                   │   │
│  │ // Will be handled in v0.4.2 (Diff Service)                      │   │
│  │ // For now, show placeholder or log                              │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                          │
│  ═══════════════════════════════════════════════════════════════════════ │
│                                                                          │
│  User clicks "Copy" button                                               │
│       │                                                                  │
│       ▼                                                                  │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │ CodeBlockViewModel.CopyToClipboardCommand                        │   │
│  │                                                                   │   │
│  │ WeakReferenceMessenger.Default.Send(                             │   │
│  │     new CopyToClipboardRequestMessage(Content));                 │   │
│  │                                                                   │   │
│  │ // Or directly if IClipboardService injected:                    │   │
│  │ await _clipboardService.SetTextAsync(Content);                   │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│       │                                                                  │
│       ▼                                                                  │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │ ChatViewModel (registered recipient)                             │   │
│  │                                                                   │   │
│  │ await _clipboardService.SetTextAsync(message.Content);           │   │
│  │                                                                   │   │
│  │ // Optionally show toast/notification                            │   │
│  │ ShowCopyConfirmation();                                          │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### Code Block Status Lifecycle

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    Code Block Status Lifecycle                           │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│                           ┌─────────────┐                                │
│                           │   PENDING   │                                │
│                           │  (Initial)  │                                │
│                           └──────┬──────┘                                │
│                                  │                                       │
│           ┌──────────────────────┼──────────────────────┐                │
│           │                      │                      │                │
│           ▼                      ▼                      ▼                │
│    ┌─────────────┐        ┌─────────────┐        ┌─────────────┐        │
│    │  REVIEWING  │        │   SKIPPED   │        │  REJECTED   │        │
│    │ (Diff open) │        │ (User skip) │        │ (User deny) │        │
│    └──────┬──────┘        └─────────────┘        └─────────────┘        │
│           │                                                              │
│           │  User accepts diff                                           │
│           ▼                                                              │
│    ┌─────────────┐                                                       │
│    │  APPLYING   │                                                       │
│    │ (In progress)│                                                       │
│    └──────┬──────┘                                                       │
│           │                                                              │
│     ┌─────┴─────┐                                                        │
│     │           │                                                        │
│     ▼           ▼                                                        │
│ ┌─────────┐ ┌─────────┐                                                  │
│ │ APPLIED │ │  ERROR  │                                                  │
│ │(Success)│ │(Failed) │                                                  │
│ └─────────┘ └────┬────┘                                                  │
│                  │                                                       │
│                  │  Retry                                                │
│                  ▼                                                       │
│           ┌─────────────┐                                                │
│           │   PENDING   │                                                │
│           │   (Reset)   │                                                │
│           └─────────────┘                                                │
│                                                                          │
│  Special Status:                                                         │
│  ┌─────────────┐                                                         │
│  │  CONFLICT   │  File changed since proposal was created                │
│  └─────────────┘  Requires user to re-review or regenerate               │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## Directory Structure

After v0.4.1g implementation:

```
src/SeniorIntern.Core/
├── Interfaces/
│   └── IClipboardService.cs                         (NEW)
└── Models/
    └── CodeBlockStatus.cs                           (EXISTS from v0.4.1a)

src/SeniorIntern.Desktop/
├── ViewModels/
│   ├── CodeBlockViewModel.cs                        (NEW)
│   ├── CodeProposalViewModel.cs                     (NEW)
│   ├── ChatMessageViewModel.cs                      (MODIFIED)
│   └── ChatViewModel.cs                             (MODIFIED)
├── Messages/
│   └── CodeBlockMessages.cs                         (NEW)
└── Services/
    └── ClipboardService.cs                          (NEW)

tests/SeniorIntern.Desktop.Tests/
├── ViewModels/
│   ├── CodeBlockViewModelTests.cs                   (NEW)
│   ├── CodeProposalViewModelTests.cs                (NEW)
│   └── ChatViewModelStreamingTests.cs               (NEW)
```

---

## Implementation Details

### Task 1: Create IClipboardService Interface

**File:** `src/SeniorIntern.Core/Interfaces/IClipboardService.cs`

```csharp
namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Abstraction for clipboard operations.
/// </summary>
public interface IClipboardService
{
    /// <summary>
    /// Copy text to the system clipboard.
    /// </summary>
    Task SetTextAsync(string text);

    /// <summary>
    /// Get text from the system clipboard.
    /// </summary>
    Task<string?> GetTextAsync();

    /// <summary>
    /// Check if clipboard contains text.
    /// </summary>
    Task<bool> ContainsTextAsync();

    /// <summary>
    /// Clear the clipboard.
    /// </summary>
    Task ClearAsync();
}
```

---

### Task 2: Create ClipboardService Implementation

**File:** `src/SeniorIntern.Desktop/Services/ClipboardService.cs`

```csharp
namespace SeniorIntern.Desktop.Services;

using Avalonia;
using Avalonia.Controls.ApplicationLifetimes;
using Avalonia.Input.Platform;
using SeniorIntern.Core.Interfaces;

/// <summary>
/// Avalonia implementation of clipboard service.
/// </summary>
public sealed class ClipboardService : IClipboardService
{
    private IClipboard? GetClipboard()
    {
        if (Application.Current?.ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)
        {
            return desktop.MainWindow?.Clipboard;
        }
        return null;
    }

    public async Task SetTextAsync(string text)
    {
        var clipboard = GetClipboard();
        if (clipboard != null)
        {
            await clipboard.SetTextAsync(text);
        }
    }

    public async Task<string?> GetTextAsync()
    {
        var clipboard = GetClipboard();
        if (clipboard != null)
        {
            return await clipboard.GetTextAsync();
        }
        return null;
    }

    public async Task<bool> ContainsTextAsync()
    {
        var text = await GetTextAsync();
        return !string.IsNullOrEmpty(text);
    }

    public async Task ClearAsync()
    {
        var clipboard = GetClipboard();
        if (clipboard != null)
        {
            await clipboard.ClearAsync();
        }
    }
}
```

---

### Task 3: Create Code Block Messages

**File:** `src/SeniorIntern.Desktop/Messages/CodeBlockMessages.cs`

```csharp
namespace SeniorIntern.Desktop.Messages;

using CommunityToolkit.Mvvm.Messaging.Messages;
using SeniorIntern.Core.Models;
using SeniorIntern.Desktop.ViewModels;

/// <summary>
/// Request to copy text to clipboard.
/// </summary>
public sealed class CopyToClipboardRequestMessage : ValueChangedMessage<string>
{
    public CopyToClipboardRequestMessage(string content) : base(content) { }
}

/// <summary>
/// Notification that text was copied to clipboard.
/// </summary>
public sealed class ClipboardCopiedMessage : ValueChangedMessage<string>
{
    public string? SourceDescription { get; init; }

    public ClipboardCopiedMessage(string content) : base(content) { }
}

/// <summary>
/// Request to show diff view for a code block.
/// </summary>
public sealed class ShowDiffRequestMessage : ValueChangedMessage<CodeBlockViewModel>
{
    /// <summary>
    /// The message containing this code block.
    /// </summary>
    public Guid MessageId { get; init; }

    public ShowDiffRequestMessage(CodeBlockViewModel block) : base(block)
    {
        MessageId = block.MessageId;
    }
}

/// <summary>
/// Request to apply changes from a code block.
/// </summary>
public sealed class ApplyChangesRequestMessage : ValueChangedMessage<CodeBlockViewModel>
{
    /// <summary>
    /// Whether to skip the diff preview and apply directly.
    /// </summary>
    public bool SkipDiffPreview { get; init; }

    public ApplyChangesRequestMessage(CodeBlockViewModel block) : base(block) { }
}

/// <summary>
/// Request to apply all code blocks from a message.
/// </summary>
public sealed class ApplyAllChangesRequestMessage : ValueChangedMessage<ChatMessageViewModel>
{
    /// <summary>
    /// Whether to skip the diff preview.
    /// </summary>
    public bool SkipDiffPreview { get; init; }

    public ApplyAllChangesRequestMessage(ChatMessageViewModel message) : base(message) { }
}

/// <summary>
/// Notification that a code block's status changed.
/// </summary>
public sealed class CodeBlockStatusChangedMessage
{
    public required Guid BlockId { get; init; }
    public required Guid MessageId { get; init; }
    public required CodeBlockStatus OldStatus { get; init; }
    public required CodeBlockStatus NewStatus { get; init; }
    public string? ErrorMessage { get; init; }
}

/// <summary>
/// Request to select a file path for an ambiguous code block.
/// </summary>
public sealed class SelectFilePathRequestMessage : AsyncRequestMessage<string?>
{
    public required CodeBlockViewModel Block { get; init; }
    public required IReadOnlyList<string> PossiblePaths { get; init; }
}

/// <summary>
/// Notification that path inference completed for a block.
/// </summary>
public sealed class PathInferenceCompletedMessage
{
    public required Guid BlockId { get; init; }
    public required string? InferredPath { get; init; }
    public required float Confidence { get; init; }
    public required bool IsAmbiguous { get; init; }
    public IReadOnlyList<string>? AlternativePaths { get; init; }
}
```

---

### Task 4: Create CodeBlockViewModel

**File:** `src/SeniorIntern.Desktop/ViewModels/CodeBlockViewModel.cs`

```csharp
namespace SeniorIntern.Desktop.ViewModels;

using System.ComponentModel;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using CommunityToolkit.Mvvm.Messaging;
using SeniorIntern.Core.Models;
using SeniorIntern.Desktop.Messages;

/// <summary>
/// ViewModel for an individual code block within a chat message.
/// </summary>
public partial class CodeBlockViewModel : ViewModelBase
{
    #region Observable Properties

    [ObservableProperty]
    private Guid _id;

    [ObservableProperty]
    private Guid _messageId;

    [ObservableProperty]
    private int _sequenceNumber;

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(LineCount))]
    [NotifyPropertyChangedFor(nameof(FormattedLineCount))]
    private string _content = string.Empty;

    [ObservableProperty]
    private string? _language;

    [ObservableProperty]
    private string? _displayLanguage;

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(FileName))]
    [NotifyPropertyChangedFor(nameof(HasTargetPath))]
    [NotifyPropertyChangedFor(nameof(IsApplicable))]
    [NotifyPropertyChangedFor(nameof(ShowApplyButton))]
    private string? _targetFilePath;

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(IsApplicable))]
    [NotifyPropertyChangedFor(nameof(IsExample))]
    [NotifyPropertyChangedFor(nameof(IsCommand))]
    [NotifyPropertyChangedFor(nameof(IsOutput))]
    [NotifyPropertyChangedFor(nameof(IsConfig))]
    [NotifyPropertyChangedFor(nameof(ShowApplyButton))]
    private CodeBlockType _blockType;

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(StatusText))]
    [NotifyPropertyChangedFor(nameof(ShowApplyButton))]
    [NotifyPropertyChangedFor(nameof(ShowStatusBadge))]
    [NotifyPropertyChangedFor(nameof(IsApplied))]
    [NotifyPropertyChangedFor(nameof(IsRejected))]
    [NotifyPropertyChangedFor(nameof(HasError))]
    [NotifyPropertyChangedFor(nameof(HasConflict))]
    private CodeBlockStatus _status = CodeBlockStatus.Pending;

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(ConfidencePercent))]
    [NotifyPropertyChangedFor(nameof(IsLowConfidence))]
    private float _confidenceScore = 1.0f;

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(ShowApplyButton))]
    [NotifyPropertyChangedFor(nameof(ShowStreamingIndicator))]
    private bool _isStreaming;

    [ObservableProperty]
    private bool _isSelected;

    [ObservableProperty]
    private bool _isExpanded = true;

    [ObservableProperty]
    private string? _errorMessage;

    [ObservableProperty]
    private bool _isPathAmbiguous;

    [ObservableProperty]
    private IReadOnlyList<string>? _alternativePaths;

    #endregion

    #region Computed Properties

    /// <summary>Number of lines in the content.</summary>
    public int LineCount => string.IsNullOrEmpty(Content) ? 0 : Content.Split('\n').Length;

    /// <summary>Formatted line count for display.</summary>
    public string FormattedLineCount => LineCount == 1 ? "1 line" : $"{LineCount} lines";

    /// <summary>File name extracted from target path.</summary>
    public string? FileName => !string.IsNullOrEmpty(TargetFilePath)
        ? Path.GetFileName(TargetFilePath)
        : null;

    /// <summary>Whether a target path is set.</summary>
    public bool HasTargetPath => !string.IsNullOrEmpty(TargetFilePath);

    /// <summary>Whether this block can be applied to a file.</summary>
    public bool IsApplicable =>
        BlockType is CodeBlockType.CompleteFile or CodeBlockType.Snippet
        && HasTargetPath
        && Status == CodeBlockStatus.Pending;

    /// <summary>Whether this is an example/illustration block.</summary>
    public bool IsExample => BlockType == CodeBlockType.Example;

    /// <summary>Whether this is a shell command.</summary>
    public bool IsCommand => BlockType == CodeBlockType.Command;

    /// <summary>Whether this is output/result display.</summary>
    public bool IsOutput => BlockType == CodeBlockType.Output;

    /// <summary>Whether this is a config file.</summary>
    public bool IsConfig => BlockType == CodeBlockType.Config;

    /// <summary>Whether to show the Apply button.</summary>
    public bool ShowApplyButton =>
        IsApplicable
        && !IsStreaming
        && Status == CodeBlockStatus.Pending;

    /// <summary>Whether to show the status badge.</summary>
    public bool ShowStatusBadge =>
        Status != CodeBlockStatus.Pending
        && Status != CodeBlockStatus.Reviewing;

    /// <summary>Whether to show streaming indicator.</summary>
    public bool ShowStreamingIndicator => IsStreaming;

    /// <summary>Whether block was successfully applied.</summary>
    public bool IsApplied => Status == CodeBlockStatus.Applied;

    /// <summary>Whether block was rejected by user.</summary>
    public bool IsRejected => Status == CodeBlockStatus.Rejected;

    /// <summary>Whether block has an error.</summary>
    public bool HasError => Status == CodeBlockStatus.Error;

    /// <summary>Whether block has a conflict.</summary>
    public bool HasConflict => Status == CodeBlockStatus.Conflict;

    /// <summary>Confidence as percentage string.</summary>
    public string ConfidencePercent => $"{ConfidenceScore * 100:F0}%";

    /// <summary>Whether confidence is below threshold.</summary>
    public bool IsLowConfidence => ConfidenceScore < 0.7f;

    /// <summary>Status text for display.</summary>
    public string StatusText => Status switch
    {
        CodeBlockStatus.Pending => "",
        CodeBlockStatus.Reviewing => "Reviewing",
        CodeBlockStatus.Applying => "Applying...",
        CodeBlockStatus.Applied => "Applied",
        CodeBlockStatus.Rejected => "Rejected",
        CodeBlockStatus.Skipped => "Skipped",
        CodeBlockStatus.Conflict => "Conflict",
        CodeBlockStatus.Error => "Error",
        _ => ""
    };

    /// <summary>Icon key for current status.</summary>
    public string StatusIcon => Status switch
    {
        CodeBlockStatus.Applied => "CheckIcon",
        CodeBlockStatus.Rejected => "CrossIcon",
        CodeBlockStatus.Conflict => "WarningIcon",
        CodeBlockStatus.Error => "ErrorIcon",
        _ => ""
    };

    #endregion

    #region Constructors

    public CodeBlockViewModel()
    {
        Id = Guid.NewGuid();
    }

    public CodeBlockViewModel(CodeBlock block)
    {
        Id = block.Id;
        MessageId = block.MessageId;
        SequenceNumber = block.SequenceNumber;
        Content = block.Content;
        Language = block.Language;
        DisplayLanguage = block.DisplayLanguage;
        TargetFilePath = block.TargetFilePath;
        BlockType = block.BlockType;
        Status = block.Status;
        ConfidenceScore = block.ConfidenceScore;
    }

    public CodeBlockViewModel(PartialCodeBlock partial)
    {
        Id = partial.Id;
        MessageId = partial.MessageId;
        SequenceNumber = partial.SequenceNumber;
        Content = partial.Content.ToString();
        Language = partial.Language;
        DisplayLanguage = partial.DisplayLanguage;
        TargetFilePath = partial.TargetFilePath;
        IsStreaming = true;
    }

    #endregion

    #region Commands

    [RelayCommand]
    private void CopyToClipboard()
    {
        WeakReferenceMessenger.Default.Send(
            new CopyToClipboardRequestMessage(Content)
            {
                SourceDescription = $"Code block ({DisplayLanguage ?? "unknown"})"
            });
    }

    [RelayCommand(CanExecute = nameof(CanShowDiff))]
    private void ShowDiff()
    {
        Status = CodeBlockStatus.Reviewing;
        WeakReferenceMessenger.Default.Send(new ShowDiffRequestMessage(this));
    }

    private bool CanShowDiff() =>
        HasTargetPath
        && !IsStreaming
        && Status == CodeBlockStatus.Pending;

    [RelayCommand(CanExecute = nameof(CanApplyChanges))]
    private void ApplyChanges()
    {
        WeakReferenceMessenger.Default.Send(
            new ApplyChangesRequestMessage(this) { SkipDiffPreview = true });
    }

    private bool CanApplyChanges() =>
        HasTargetPath
        && !IsStreaming
        && Status is CodeBlockStatus.Pending or CodeBlockStatus.Reviewing;

    [RelayCommand(CanExecute = nameof(CanReject))]
    private void Reject()
    {
        var oldStatus = Status;
        Status = CodeBlockStatus.Rejected;
        WeakReferenceMessenger.Default.Send(new CodeBlockStatusChangedMessage
        {
            BlockId = Id,
            MessageId = MessageId,
            OldStatus = oldStatus,
            NewStatus = Status
        });
    }

    private bool CanReject() =>
        Status is CodeBlockStatus.Pending or CodeBlockStatus.Reviewing or CodeBlockStatus.Conflict;

    [RelayCommand(CanExecute = nameof(CanSelectPath))]
    private async Task SelectPathAsync()
    {
        if (AlternativePaths == null || AlternativePaths.Count == 0)
            return;

        var response = await WeakReferenceMessenger.Default.Send(
            new SelectFilePathRequestMessage
            {
                Block = this,
                PossiblePaths = AlternativePaths
            });

        if (!string.IsNullOrEmpty(response))
        {
            TargetFilePath = response;
            IsPathAmbiguous = false;
            AlternativePaths = null;
            ConfidenceScore = 1.0f; // User selected = certain
        }
    }

    private bool CanSelectPath() => IsPathAmbiguous && AlternativePaths?.Count > 0;

    [RelayCommand]
    private void ToggleExpanded()
    {
        IsExpanded = !IsExpanded;
    }

    #endregion

    #region Streaming Support

    /// <summary>
    /// Append content during streaming.
    /// </summary>
    public void AppendContent(string token)
    {
        Content += token;
    }

    /// <summary>
    /// Update from partial block during streaming.
    /// </summary>
    public void UpdateFromPartial(PartialCodeBlock partial)
    {
        Content = partial.Content.ToString();
        Language = partial.Language;
        DisplayLanguage = partial.DisplayLanguage;
        TargetFilePath = partial.TargetFilePath;
    }

    /// <summary>
    /// Complete streaming with final block data.
    /// </summary>
    public void CompleteStreaming(CodeBlock finalBlock)
    {
        Content = finalBlock.Content;
        Language = finalBlock.Language;
        DisplayLanguage = finalBlock.DisplayLanguage;
        TargetFilePath = finalBlock.TargetFilePath;
        BlockType = finalBlock.BlockType;
        ConfidenceScore = finalBlock.ConfidenceScore;
        IsStreaming = false;

        // Notify commands to re-evaluate CanExecute
        ShowDiffCommand.NotifyCanExecuteChanged();
        ApplyChangesCommand.NotifyCanExecuteChanged();
        RejectCommand.NotifyCanExecuteChanged();
    }

    #endregion

    #region Model Conversion

    /// <summary>
    /// Convert to domain model.
    /// </summary>
    public CodeBlock ToModel() => new()
    {
        Id = Id,
        MessageId = MessageId,
        SequenceNumber = SequenceNumber,
        Content = Content,
        Language = Language,
        DisplayLanguage = DisplayLanguage,
        TargetFilePath = TargetFilePath,
        BlockType = BlockType,
        Status = Status,
        ConfidenceScore = ConfidenceScore
    };

    #endregion

    #region Status Updates

    /// <summary>
    /// Mark as applying (in progress).
    /// </summary>
    public void MarkAsApplying()
    {
        Status = CodeBlockStatus.Applying;
    }

    /// <summary>
    /// Mark as successfully applied.
    /// </summary>
    public void MarkAsApplied()
    {
        var oldStatus = Status;
        Status = CodeBlockStatus.Applied;
        ErrorMessage = null;

        WeakReferenceMessenger.Default.Send(new CodeBlockStatusChangedMessage
        {
            BlockId = Id,
            MessageId = MessageId,
            OldStatus = oldStatus,
            NewStatus = Status
        });
    }

    /// <summary>
    /// Mark as error with message.
    /// </summary>
    public void MarkAsError(string error)
    {
        var oldStatus = Status;
        Status = CodeBlockStatus.Error;
        ErrorMessage = error;

        WeakReferenceMessenger.Default.Send(new CodeBlockStatusChangedMessage
        {
            BlockId = Id,
            MessageId = MessageId,
            OldStatus = oldStatus,
            NewStatus = Status,
            ErrorMessage = error
        });
    }

    /// <summary>
    /// Mark as conflict (file changed).
    /// </summary>
    public void MarkAsConflict(string reason)
    {
        var oldStatus = Status;
        Status = CodeBlockStatus.Conflict;
        ErrorMessage = reason;

        WeakReferenceMessenger.Default.Send(new CodeBlockStatusChangedMessage
        {
            BlockId = Id,
            MessageId = MessageId,
            OldStatus = oldStatus,
            NewStatus = Status,
            ErrorMessage = reason
        });
    }

    /// <summary>
    /// Reset to pending state (for retry).
    /// </summary>
    public void ResetToPending()
    {
        Status = CodeBlockStatus.Pending;
        ErrorMessage = null;

        ShowDiffCommand.NotifyCanExecuteChanged();
        ApplyChangesCommand.NotifyCanExecuteChanged();
        RejectCommand.NotifyCanExecuteChanged();
    }

    #endregion
}
```

---

### Task 5: Create CodeProposalViewModel

**File:** `src/SeniorIntern.Desktop/ViewModels/CodeProposalViewModel.cs`

```csharp
namespace SeniorIntern.Desktop.ViewModels;

using System.Collections.ObjectModel;
using System.Collections.Specialized;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using CommunityToolkit.Mvvm.Messaging;
using SeniorIntern.Core.Models;
using SeniorIntern.Desktop.Messages;

/// <summary>
/// ViewModel for a complete code proposal containing multiple blocks.
/// </summary>
public partial class CodeProposalViewModel : ViewModelBase
{
    #region Observable Properties

    [ObservableProperty]
    private Guid _id;

    [ObservableProperty]
    private Guid _messageId;

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(IsFullyApplied))]
    [NotifyPropertyChangedFor(nameof(IsPartiallyApplied))]
    [NotifyPropertyChangedFor(nameof(CanApplyAll))]
    [NotifyPropertyChangedFor(nameof(CanRejectAll))]
    private ProposalStatus _status = ProposalStatus.Pending;

    [ObservableProperty]
    private DateTime _createdAt;

    #endregion

    #region Collections

    public ObservableCollection<CodeBlockViewModel> CodeBlocks { get; } = new();

    #endregion

    #region Computed Properties

    /// <summary>Total number of code blocks.</summary>
    public int TotalCount => CodeBlocks.Count;

    /// <summary>Number of applicable (can be applied) blocks.</summary>
    public int ApplicableCount => CodeBlocks.Count(b =>
        b.BlockType is CodeBlockType.CompleteFile or CodeBlockType.Snippet
        && b.HasTargetPath);

    /// <summary>Number of blocks already applied.</summary>
    public int AppliedCount => CodeBlocks.Count(b => b.Status == CodeBlockStatus.Applied);

    /// <summary>Number of pending blocks.</summary>
    public int PendingCount => CodeBlocks.Count(b => b.Status == CodeBlockStatus.Pending);

    /// <summary>Number of blocks with errors.</summary>
    public int ErrorCount => CodeBlocks.Count(b =>
        b.Status is CodeBlockStatus.Error or CodeBlockStatus.Conflict);

    /// <summary>Whether any blocks can be applied.</summary>
    public bool HasApplicableBlocks => ApplicableCount > 0;

    /// <summary>Whether all applicable blocks have been applied.</summary>
    public bool IsFullyApplied =>
        ApplicableCount > 0 && AppliedCount == ApplicableCount;

    /// <summary>Whether some but not all blocks have been applied.</summary>
    public bool IsPartiallyApplied =>
        AppliedCount > 0 && AppliedCount < ApplicableCount;

    /// <summary>Whether ApplyAll command can execute.</summary>
    public bool CanApplyAll =>
        PendingCount > 0 && Status != ProposalStatus.Applied;

    /// <summary>Whether RejectAll command can execute.</summary>
    public bool CanRejectAll =>
        PendingCount > 0 && Status != ProposalStatus.Rejected;

    /// <summary>Progress text for display.</summary>
    public string ProgressText
    {
        get
        {
            if (ApplicableCount == 0) return "No applicable code";
            if (IsFullyApplied) return "All changes applied";
            return $"{AppliedCount} of {ApplicableCount} applied";
        }
    }

    /// <summary>List of affected file paths.</summary>
    public IEnumerable<string> AffectedFiles =>
        CodeBlocks
            .Where(b => !string.IsNullOrEmpty(b.TargetFilePath))
            .Select(b => b.TargetFilePath!)
            .Distinct()
            .OrderBy(p => p);

    /// <summary>Number of affected files.</summary>
    public int AffectedFileCount => AffectedFiles.Count();

    #endregion

    #region Constructors

    public CodeProposalViewModel()
    {
        Id = Guid.NewGuid();
        CreatedAt = DateTime.UtcNow;
        CodeBlocks.CollectionChanged += OnCodeBlocksChanged;
    }

    public CodeProposalViewModel(CodeProposal proposal) : this()
    {
        Id = proposal.Id;
        MessageId = proposal.MessageId;
        Status = proposal.Status;
        CreatedAt = proposal.CreatedAt;

        foreach (var block in proposal.CodeBlocks)
        {
            CodeBlocks.Add(new CodeBlockViewModel(block));
        }
    }

    #endregion

    #region Commands

    [RelayCommand(CanExecute = nameof(CanApplyAll))]
    private void ApplyAll()
    {
        Status = ProposalStatus.Applying;

        // Send message for each pending applicable block
        foreach (var block in CodeBlocks.Where(b =>
            b.Status == CodeBlockStatus.Pending && b.IsApplicable))
        {
            WeakReferenceMessenger.Default.Send(
                new ApplyChangesRequestMessage(block) { SkipDiffPreview = true });
        }
    }

    [RelayCommand(CanExecute = nameof(CanRejectAll))]
    private void RejectAll()
    {
        Status = ProposalStatus.Rejected;

        foreach (var block in CodeBlocks.Where(b =>
            b.Status == CodeBlockStatus.Pending))
        {
            block.Reject();
        }

        NotifyStatsChanged();
    }

    [RelayCommand]
    private void ShowSummary()
    {
        // Will be handled by parent view or messenger
        // Shows a summary dialog of all changes
    }

    #endregion

    #region Collection Management

    private void OnCodeBlocksChanged(object? sender, NotifyCollectionChangedEventArgs e)
    {
        // Subscribe to status changes on new blocks
        if (e.NewItems != null)
        {
            foreach (CodeBlockViewModel block in e.NewItems)
            {
                block.PropertyChanged += OnBlockPropertyChanged;
            }
        }

        // Unsubscribe from removed blocks
        if (e.OldItems != null)
        {
            foreach (CodeBlockViewModel block in e.OldItems)
            {
                block.PropertyChanged -= OnBlockPropertyChanged;
            }
        }

        NotifyStatsChanged();
    }

    private void OnBlockPropertyChanged(object? sender, PropertyChangedEventArgs e)
    {
        if (e.PropertyName == nameof(CodeBlockViewModel.Status))
        {
            NotifyStatsChanged();
            UpdateProposalStatus();
        }
    }

    private void NotifyStatsChanged()
    {
        OnPropertyChanged(nameof(TotalCount));
        OnPropertyChanged(nameof(ApplicableCount));
        OnPropertyChanged(nameof(AppliedCount));
        OnPropertyChanged(nameof(PendingCount));
        OnPropertyChanged(nameof(ErrorCount));
        OnPropertyChanged(nameof(HasApplicableBlocks));
        OnPropertyChanged(nameof(IsFullyApplied));
        OnPropertyChanged(nameof(IsPartiallyApplied));
        OnPropertyChanged(nameof(CanApplyAll));
        OnPropertyChanged(nameof(CanRejectAll));
        OnPropertyChanged(nameof(ProgressText));
        OnPropertyChanged(nameof(AffectedFiles));
        OnPropertyChanged(nameof(AffectedFileCount));

        ApplyAllCommand.NotifyCanExecuteChanged();
        RejectAllCommand.NotifyCanExecuteChanged();
    }

    private void UpdateProposalStatus()
    {
        if (IsFullyApplied)
        {
            Status = ProposalStatus.Applied;
        }
        else if (CodeBlocks.All(b => b.Status == CodeBlockStatus.Rejected))
        {
            Status = ProposalStatus.Rejected;
        }
        else if (IsPartiallyApplied)
        {
            Status = ProposalStatus.PartiallyApplied;
        }
        else if (ErrorCount > 0)
        {
            Status = ProposalStatus.Error;
        }
    }

    #endregion

    #region Model Conversion

    public CodeProposal ToModel() => new()
    {
        Id = Id,
        MessageId = MessageId,
        Status = Status,
        CreatedAt = CreatedAt,
        CodeBlocks = CodeBlocks.Select(b => b.ToModel()).ToList()
    };

    #endregion
}
```

---

### Task 6: Update ChatMessageViewModel

**File:** `src/SeniorIntern.Desktop/ViewModels/ChatMessageViewModel.cs` (MODIFIED)

```csharp
namespace SeniorIntern.Desktop.ViewModels;

using System.Collections.ObjectModel;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using CommunityToolkit.Mvvm.Messaging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Desktop.Messages;

public partial class ChatMessageViewModel : ViewModelBase
{
    #region Existing Properties

    [ObservableProperty]
    private Guid _id;

    [ObservableProperty]
    private string _content = string.Empty;

    [ObservableProperty]
    private MessageRole _role;

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(ShowCodeActions))]
    private bool _isStreaming;

    [ObservableProperty]
    private DateTime _timestamp;

    #endregion

    #region New Code Block Properties

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(ShowCodeActions))]
    private ObservableCollection<CodeBlockViewModel> _codeBlocks = new();

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(ShowCodeActions))]
    private bool _hasCodeBlocks;

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(ShowCodeActions))]
    private bool _hasApplicableCode;

    [ObservableProperty]
    private int _applicableBlockCount;

    [ObservableProperty]
    private int _totalBlockCount;

    [ObservableProperty]
    private int _appliedBlockCount;

    [ObservableProperty]
    private CodeBlockViewModel? _currentStreamingBlock;

    #endregion

    #region Computed Properties

    public bool IsUser => Role == MessageRole.User;
    public bool IsAssistant => Role == MessageRole.Assistant;

    public string RoleLabel => Role switch
    {
        MessageRole.User => "You",
        MessageRole.Assistant => "Senior Intern",
        MessageRole.System => "System",
        _ => "Unknown"
    };

    /// <summary>
    /// Whether to show the code actions toolbar.
    /// </summary>
    public bool ShowCodeActions =>
        HasApplicableCode
        && Role == MessageRole.Assistant
        && !IsStreaming;

    /// <summary>
    /// Progress text for applied blocks.
    /// </summary>
    public string ApplyProgressText
    {
        get
        {
            if (ApplicableBlockCount == 0) return "";
            if (AppliedBlockCount == ApplicableBlockCount) return "All applied";
            return $"{AppliedBlockCount}/{ApplicableBlockCount} applied";
        }
    }

    /// <summary>
    /// Whether all applicable blocks have been applied.
    /// </summary>
    public bool IsFullyApplied =>
        ApplicableBlockCount > 0 && AppliedBlockCount == ApplicableBlockCount;

    #endregion

    #region Constructors

    public ChatMessageViewModel()
    {
        Id = Guid.NewGuid();
        Timestamp = DateTime.UtcNow;
        CodeBlocks.CollectionChanged += (_, _) => UpdateCodeBlockStats();
    }

    public ChatMessageViewModel(ChatMessage message) : this()
    {
        Id = message.Id;
        Content = message.Content;
        Role = message.Role;
        Timestamp = message.Timestamp;
        IsStreaming = !message.IsComplete;
    }

    #endregion

    #region Content Methods

    /// <summary>
    /// Appends streamed content (for assistant messages).
    /// </summary>
    public void AppendContent(string token)
    {
        Content += token;
    }

    /// <summary>
    /// Called when streaming is complete.
    /// </summary>
    public void CompleteStreaming()
    {
        IsStreaming = false;
        CurrentStreamingBlock = null;
        OnPropertyChanged(nameof(ShowCodeActions));
    }

    /// <summary>
    /// Marks the message as cancelled.
    /// </summary>
    public void MarkAsCancelled()
    {
        IsStreaming = false;
        CurrentStreamingBlock?.CompleteStreaming(CurrentStreamingBlock.ToModel());
        CurrentStreamingBlock = null;

        if (!string.IsNullOrEmpty(Content) && !Content.EndsWith("..."))
        {
            Content += " [Cancelled]";
        }
    }

    #endregion

    #region Code Block Parsing

    /// <summary>
    /// Parse code blocks from the message content (non-streaming).
    /// </summary>
    public void ParseCodeBlocks(
        ICodeBlockParserService parser,
        IReadOnlyList<FileContext>? context = null)
    {
        if (Role != MessageRole.Assistant || string.IsNullOrEmpty(Content))
            return;

        var proposal = parser.CreateProposal(Content, Id, context);

        CodeBlocks.Clear();
        foreach (var block in proposal.CodeBlocks)
        {
            var vm = new CodeBlockViewModel(block)
            {
                MessageId = Id
            };
            vm.PropertyChanged += OnBlockPropertyChanged;
            CodeBlocks.Add(vm);
        }

        UpdateCodeBlockStats();
    }

    #endregion

    #region Streaming Code Block Methods

    /// <summary>
    /// Begin a new code block during streaming.
    /// </summary>
    public CodeBlockViewModel BeginCodeBlock(PartialCodeBlock partial)
    {
        var vm = new CodeBlockViewModel(partial)
        {
            MessageId = Id,
            IsStreaming = true
        };
        vm.PropertyChanged += OnBlockPropertyChanged;

        CodeBlocks.Add(vm);
        CurrentStreamingBlock = vm;
        UpdateCodeBlockStats();

        return vm;
    }

    /// <summary>
    /// Update the currently streaming block with new content.
    /// </summary>
    public void UpdateStreamingBlock(string content)
    {
        CurrentStreamingBlock?.AppendContent(content);
    }

    /// <summary>
    /// Complete the current streaming block.
    /// </summary>
    public void CompleteCurrentBlock(CodeBlock finalBlock)
    {
        if (CurrentStreamingBlock != null)
        {
            CurrentStreamingBlock.CompleteStreaming(finalBlock);
            CurrentStreamingBlock = null;
        }
        UpdateCodeBlockStats();
    }

    /// <summary>
    /// Get a code block by ID.
    /// </summary>
    public CodeBlockViewModel? GetCodeBlock(Guid blockId)
    {
        return CodeBlocks.FirstOrDefault(b => b.Id == blockId);
    }

    #endregion

    #region Statistics

    private void UpdateCodeBlockStats()
    {
        TotalBlockCount = CodeBlocks.Count;

        ApplicableBlockCount = CodeBlocks.Count(b =>
            b.BlockType is CodeBlockType.CompleteFile or CodeBlockType.Snippet
            && b.HasTargetPath);

        AppliedBlockCount = CodeBlocks.Count(b =>
            b.Status == CodeBlockStatus.Applied);

        HasCodeBlocks = TotalBlockCount > 0;
        HasApplicableCode = ApplicableBlockCount > 0;

        OnPropertyChanged(nameof(ApplyProgressText));
        OnPropertyChanged(nameof(IsFullyApplied));
        OnPropertyChanged(nameof(ShowCodeActions));
    }

    private void OnBlockPropertyChanged(object? sender, PropertyChangedEventArgs e)
    {
        if (e.PropertyName == nameof(CodeBlockViewModel.Status))
        {
            UpdateCodeBlockStats();
        }
    }

    #endregion

    #region Commands

    [RelayCommand]
    private void CopyAllCode()
    {
        var allCode = string.Join("\n\n", CodeBlocks.Select(b => b.Content));
        WeakReferenceMessenger.Default.Send(
            new CopyToClipboardRequestMessage(allCode)
            {
                SourceDescription = $"All code blocks ({CodeBlocks.Count})"
            });
    }

    [RelayCommand(CanExecute = nameof(HasApplicableCode))]
    private void ApplyAllCode()
    {
        WeakReferenceMessenger.Default.Send(
            new ApplyAllChangesRequestMessage(this) { SkipDiffPreview = false });
    }

    [RelayCommand(CanExecute = nameof(HasApplicableCode))]
    private void RejectAllCode()
    {
        foreach (var block in CodeBlocks.Where(b =>
            b.Status == CodeBlockStatus.Pending && b.IsApplicable))
        {
            block.Reject();
        }
        UpdateCodeBlockStats();
    }

    #endregion

    #region Model Conversion

    public ChatMessage ToChatMessage() => new()
    {
        Id = Id,
        Content = Content,
        Role = Role,
        Timestamp = Timestamp,
        IsComplete = !IsStreaming
    };

    #endregion
}
```

---

### Task 7: Update ChatViewModel

**File:** `src/SeniorIntern.Desktop/ViewModels/ChatViewModel.cs` (MODIFIED)

```csharp
namespace SeniorIntern.Desktop.ViewModels;

using System.Collections.ObjectModel;
using Avalonia.Threading;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using CommunityToolkit.Mvvm.Messaging;
using SeniorIntern.Core.Events;
using SeniorIntern.Core.Exceptions;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Desktop.Messages;
using SeniorIntern.Services.Factories;

public partial class ChatViewModel : ViewModelBase,
    IRecipient<CopyToClipboardRequestMessage>,
    IRecipient<CodeBlockStatusChangedMessage>
{
    #region Dependencies

    private readonly ILlmService _llmService;
    private readonly IConversationService _conversationService;
    private readonly ISettingsService _settingsService;
    private readonly IStreamingParserFactory _parserFactory;
    private readonly ICodeBlockParserService _codeBlockParser;
    private readonly IFilePathInferenceService _pathInferenceService;
    private readonly IClipboardService _clipboardService;

    #endregion

    #region State

    private CancellationTokenSource? _generationCts;
    private IStreamingCodeBlockParser? _currentParser;

    #endregion

    #region Observable Properties

    [ObservableProperty]
    private string _userInput = string.Empty;

    [ObservableProperty]
    private ObservableCollection<ChatMessageViewModel> _messages = new();

    [ObservableProperty]
    private bool _isGenerating;

    [ObservableProperty]
    private int _tokenCount;

    [ObservableProperty]
    private bool _canSend;

    [ObservableProperty]
    private string? _copyNotification;

    [ObservableProperty]
    private bool _showCopyNotification;

    /// <summary>
    /// Files currently attached to the conversation context.
    /// </summary>
    [ObservableProperty]
    private ObservableCollection<FileContext> _attachedFiles = new();

    #endregion

    #region Constructor

    public ChatViewModel(
        ILlmService llmService,
        IConversationService conversationService,
        ISettingsService settingsService,
        IStreamingParserFactory parserFactory,
        ICodeBlockParserService codeBlockParser,
        IFilePathInferenceService pathInferenceService,
        IClipboardService clipboardService)
    {
        _llmService = llmService;
        _conversationService = conversationService;
        _settingsService = settingsService;
        _parserFactory = parserFactory;
        _codeBlockParser = codeBlockParser;
        _pathInferenceService = pathInferenceService;
        _clipboardService = clipboardService;

        // Register for messages
        WeakReferenceMessenger.Default.Register<CopyToClipboardRequestMessage>(this);
        WeakReferenceMessenger.Default.Register<CodeBlockStatusChangedMessage>(this);

        // Update CanSend when dependencies change
        PropertyChanged += (_, e) =>
        {
            if (e.PropertyName is nameof(UserInput) or nameof(IsGenerating))
            {
                UpdateCanSend();
            }
        };

        _llmService.ModelStateChanged += (_, _) => UpdateCanSend();
    }

    #endregion

    #region Message Handlers

    public async void Receive(CopyToClipboardRequestMessage message)
    {
        await _clipboardService.SetTextAsync(message.Value);
        await ShowCopyNotificationAsync(message.SourceDescription ?? "Copied");
    }

    public void Receive(CodeBlockStatusChangedMessage message)
    {
        // Find the message containing this block and update stats
        var chatMessage = Messages.FirstOrDefault(m => m.Id == message.MessageId);
        // Stats update is handled by the ChatMessageViewModel internally
    }

    private async Task ShowCopyNotificationAsync(string text)
    {
        CopyNotification = text;
        ShowCopyNotification = true;

        await Task.Delay(2000);

        ShowCopyNotification = false;
    }

    #endregion

    #region Send Message

    private void UpdateCanSend()
    {
        CanSend = !string.IsNullOrWhiteSpace(UserInput)
                  && !IsGenerating
                  && _llmService.IsModelLoaded;
    }

    [RelayCommand(CanExecute = nameof(CanSend))]
    private async Task SendMessageAsync()
    {
        if (string.IsNullOrWhiteSpace(UserInput)) return;
        if (!_llmService.IsModelLoaded)
        {
            SetError("Please load a model first.");
            return;
        }

        ClearError();
        var userMessage = UserInput.Trim();
        UserInput = string.Empty;

        // Add user message
        var userMessageVm = new ChatMessageViewModel
        {
            Role = MessageRole.User,
            Content = userMessage
        };
        Messages.Add(userMessageVm);
        _conversationService.AddMessage(userMessageVm.ToChatMessage());

        // Create assistant message placeholder
        var assistantMessageVm = new ChatMessageViewModel
        {
            Role = MessageRole.Assistant,
            IsStreaming = true
        };
        Messages.Add(assistantMessageVm);

        // Create streaming parser for this message
        _currentParser = _parserFactory.Create(assistantMessageVm.Id);
        SubscribeToParserEvents(_currentParser, assistantMessageVm);

        _generationCts = new CancellationTokenSource();
        IsGenerating = true;
        TokenCount = 0;

        try
        {
            var settings = _settingsService.CurrentSettings;
            var options = new InferenceOptions(
                MaxTokens: settings.MaxTokens,
                Temperature: settings.Temperature,
                TopP: settings.TopP
            );

            var conversation = _conversationService.GetMessages();

            await foreach (var token in _llmService.GenerateStreamingAsync(
                conversation, options, _generationCts.Token))
            {
                // Update on UI thread
                await Dispatcher.UIThread.InvokeAsync(() =>
                {
                    assistantMessageVm.AppendContent(token);
                    TokenCount++;

                    // Feed token to parser
                    _currentParser?.FeedToken(token);
                });
            }

            // Finalize parsing
            _currentParser?.Complete();
            assistantMessageVm.CompleteStreaming();

            // Add completed message to conversation service
            _conversationService.AddMessage(assistantMessageVm.ToChatMessage());
        }
        catch (OperationCanceledException)
        {
            _currentParser?.Complete();
            assistantMessageVm.MarkAsCancelled();
        }
        catch (InferenceException ex)
        {
            SetError($"Generation failed: {ex.Message}");
            _currentParser?.Complete();
            assistantMessageVm.CompleteStreaming();
            if (string.IsNullOrEmpty(assistantMessageVm.Content))
            {
                assistantMessageVm.Content = "[Error: Generation failed]";
            }
        }
        catch (Exception ex)
        {
            SetError($"Unexpected error: {ex.Message}");
            _currentParser?.Complete();
            assistantMessageVm.CompleteStreaming();
            if (string.IsNullOrEmpty(assistantMessageVm.Content))
            {
                assistantMessageVm.Content = "[Error occurred]";
            }
        }
        finally
        {
            IsGenerating = false;
            UnsubscribeFromParserEvents(_currentParser);
            _currentParser?.Dispose();
            _currentParser = null;
            _generationCts?.Dispose();
            _generationCts = null;
        }
    }

    #endregion

    #region Parser Event Handling

    private void SubscribeToParserEvents(
        IStreamingCodeBlockParser parser,
        ChatMessageViewModel messageVm)
    {
        parser.BlockStarted += (s, e) =>
            Dispatcher.UIThread.Post(() => OnBlockStarted(e, messageVm));

        parser.ContentAdded += (s, e) =>
            Dispatcher.UIThread.Post(() => OnContentAdded(e, messageVm));

        parser.BlockCompleted += (s, e) =>
            Dispatcher.UIThread.Post(() => OnBlockCompleted(e, messageVm));
    }

    private void UnsubscribeFromParserEvents(IStreamingCodeBlockParser? parser)
    {
        // Events are automatically cleaned up when parser is disposed
        // due to using local delegates
    }

    private void OnBlockStarted(
        CodeBlockStartedEventArgs e,
        ChatMessageViewModel messageVm)
    {
        var blockVm = messageVm.BeginCodeBlock(e.Block);

        // If path is specified, set confidence high
        if (!string.IsNullOrEmpty(e.TargetFilePath))
        {
            blockVm.ConfidenceScore = 1.0f;
        }
    }

    private void OnContentAdded(
        CodeBlockContentEventArgs e,
        ChatMessageViewModel messageVm)
    {
        messageVm.UpdateStreamingBlock(e.Content);
    }

    private void OnBlockCompleted(
        CodeBlockCompletedEventArgs e,
        ChatMessageViewModel messageVm)
    {
        messageVm.CompleteCurrentBlock(e.Block);

        // Infer path if not already set
        var blockVm = messageVm.GetCodeBlock(e.Block.Id);
        if (blockVm != null && string.IsNullOrEmpty(blockVm.TargetFilePath))
        {
            InferPathForBlock(blockVm);
        }
    }

    private void InferPathForBlock(CodeBlockViewModel blockVm)
    {
        var block = blockVm.ToModel();
        var result = _pathInferenceService.InferTargetFilePath(
            block, AttachedFiles.ToList());

        if (result.IsSuccess)
        {
            blockVm.TargetFilePath = result.Path;
            blockVm.ConfidenceScore = result.Confidence;

            if (result.IsAmbiguous)
            {
                blockVm.IsPathAmbiguous = true;
                blockVm.AlternativePaths = result.AlternativePaths;
            }

            WeakReferenceMessenger.Default.Send(new PathInferenceCompletedMessage
            {
                BlockId = blockVm.Id,
                InferredPath = result.Path,
                Confidence = result.Confidence,
                IsAmbiguous = result.IsAmbiguous,
                AlternativePaths = result.AlternativePaths
            });
        }
    }

    #endregion

    #region Other Commands

    [RelayCommand]
    private void CancelGeneration()
    {
        _generationCts?.Cancel();
    }

    [RelayCommand]
    private void ClearChat()
    {
        Messages.Clear();
        _conversationService.ClearConversation();
        AttachedFiles.Clear();
        ClearError();
    }

    public void HandleEnterKey()
    {
        if (CanSend)
        {
            SendMessageCommand.Execute(null);
        }
    }

    #endregion

    #region Context Management

    /// <summary>
    /// Add a file to the conversation context.
    /// </summary>
    public void AttachFile(FileContext file)
    {
        if (!AttachedFiles.Any(f => f.FilePath == file.FilePath))
        {
            AttachedFiles.Add(file);
        }
    }

    /// <summary>
    /// Remove a file from the conversation context.
    /// </summary>
    public void DetachFile(string filePath)
    {
        var file = AttachedFiles.FirstOrDefault(f => f.FilePath == filePath);
        if (file != null)
        {
            AttachedFiles.Remove(file);
        }
    }

    /// <summary>
    /// Clear all attached files.
    /// </summary>
    public void ClearAttachedFiles()
    {
        AttachedFiles.Clear();
    }

    #endregion
}
```

---

### Task 8: Register Services in DI

**File to Modify:** `src/SeniorIntern.Desktop/Extensions/ServiceCollectionExtensions.cs`

**Changes Required:**

```csharp
// Add to the ConfigureServices method:

// v0.4.1g: ViewModel support services
services.AddSingleton<IClipboardService, ClipboardService>();

// Ensure these from earlier parts are registered:
// services.AddSingleton<IStreamingParserFactory, StreamingParserFactory>();
// services.AddSingleton<ICodeBlockParserService, CodeBlockParserService>();
// services.AddSingleton<IFilePathInferenceService, FilePathInferenceService>();
```

---

## Unit Testing Requirements

### Test File: `tests/SeniorIntern.Desktop.Tests/ViewModels/CodeBlockViewModelTests.cs`

```csharp
namespace SeniorIntern.Desktop.Tests.ViewModels;

using CommunityToolkit.Mvvm.Messaging;
using SeniorIntern.Core.Models;
using SeniorIntern.Desktop.Messages;
using SeniorIntern.Desktop.ViewModels;
using Xunit;

public class CodeBlockViewModelTests
{
    public CodeBlockViewModelTests()
    {
        // Reset messenger between tests
        WeakReferenceMessenger.Default.Reset();
    }

    #region Computed Properties

    [Theory]
    [InlineData(CodeBlockType.CompleteFile, true, true)]
    [InlineData(CodeBlockType.Snippet, true, true)]
    [InlineData(CodeBlockType.Example, true, false)]
    [InlineData(CodeBlockType.Command, true, false)]
    [InlineData(CodeBlockType.CompleteFile, false, false)]
    public void IsApplicable_ReturnsCorrectValue(
        CodeBlockType type, bool hasPath, bool expected)
    {
        var vm = new CodeBlockViewModel
        {
            BlockType = type,
            TargetFilePath = hasPath ? "test.cs" : null,
            Status = CodeBlockStatus.Pending
        };

        Assert.Equal(expected, vm.IsApplicable);
    }

    [Fact]
    public void LineCount_CalculatesCorrectly()
    {
        var vm = new CodeBlockViewModel
        {
            Content = "line1\nline2\nline3"
        };

        Assert.Equal(3, vm.LineCount);
    }

    [Fact]
    public void FileName_ExtractsFromPath()
    {
        var vm = new CodeBlockViewModel
        {
            TargetFilePath = "src/Models/User.cs"
        };

        Assert.Equal("User.cs", vm.FileName);
    }

    [Theory]
    [InlineData(CodeBlockStatus.Applied, "Applied")]
    [InlineData(CodeBlockStatus.Rejected, "Rejected")]
    [InlineData(CodeBlockStatus.Pending, "")]
    public void StatusText_ReturnsCorrectValue(
        CodeBlockStatus status, string expected)
    {
        var vm = new CodeBlockViewModel { Status = status };
        Assert.Equal(expected, vm.StatusText);
    }

    [Fact]
    public void ShowApplyButton_TrueWhenApplicableAndPending()
    {
        var vm = new CodeBlockViewModel
        {
            BlockType = CodeBlockType.CompleteFile,
            TargetFilePath = "test.cs",
            Status = CodeBlockStatus.Pending,
            IsStreaming = false
        };

        Assert.True(vm.ShowApplyButton);
    }

    [Fact]
    public void ShowApplyButton_FalseWhenStreaming()
    {
        var vm = new CodeBlockViewModel
        {
            BlockType = CodeBlockType.CompleteFile,
            TargetFilePath = "test.cs",
            Status = CodeBlockStatus.Pending,
            IsStreaming = true
        };

        Assert.False(vm.ShowApplyButton);
    }

    #endregion

    #region Commands

    [Fact]
    public void CopyToClipboard_SendsMessage()
    {
        CopyToClipboardRequestMessage? received = null;
        WeakReferenceMessenger.Default.Register<CopyToClipboardRequestMessage>(
            this, (r, m) => received = m);

        var vm = new CodeBlockViewModel { Content = "test content" };
        vm.CopyToClipboardCommand.Execute(null);

        Assert.NotNull(received);
        Assert.Equal("test content", received.Value);
    }

    [Fact]
    public void ShowDiff_SendsMessageAndSetsReviewing()
    {
        ShowDiffRequestMessage? received = null;
        WeakReferenceMessenger.Default.Register<ShowDiffRequestMessage>(
            this, (r, m) => received = m);

        var vm = new CodeBlockViewModel
        {
            TargetFilePath = "test.cs",
            Status = CodeBlockStatus.Pending
        };

        vm.ShowDiffCommand.Execute(null);

        Assert.NotNull(received);
        Assert.Equal(CodeBlockStatus.Reviewing, vm.Status);
    }

    [Fact]
    public void Reject_ChangesStatusAndSendsMessage()
    {
        CodeBlockStatusChangedMessage? received = null;
        WeakReferenceMessenger.Default.Register<CodeBlockStatusChangedMessage>(
            this, (r, m) => received = m);

        var vm = new CodeBlockViewModel
        {
            Status = CodeBlockStatus.Pending
        };

        vm.RejectCommand.Execute(null);

        Assert.Equal(CodeBlockStatus.Rejected, vm.Status);
        Assert.NotNull(received);
        Assert.Equal(CodeBlockStatus.Pending, received.OldStatus);
        Assert.Equal(CodeBlockStatus.Rejected, received.NewStatus);
    }

    #endregion

    #region Streaming

    [Fact]
    public void AppendContent_AddsToExistingContent()
    {
        var vm = new CodeBlockViewModel { Content = "Hello" };

        vm.AppendContent(" World");

        Assert.Equal("Hello World", vm.Content);
    }

    [Fact]
    public void CompleteStreaming_UpdatesAllProperties()
    {
        var vm = new CodeBlockViewModel
        {
            IsStreaming = true,
            Content = "partial"
        };

        var finalBlock = new CodeBlock
        {
            Content = "complete content",
            Language = "csharp",
            DisplayLanguage = "C#",
            BlockType = CodeBlockType.CompleteFile,
            ConfidenceScore = 0.95f
        };

        vm.CompleteStreaming(finalBlock);

        Assert.False(vm.IsStreaming);
        Assert.Equal("complete content", vm.Content);
        Assert.Equal("csharp", vm.Language);
        Assert.Equal("C#", vm.DisplayLanguage);
        Assert.Equal(CodeBlockType.CompleteFile, vm.BlockType);
        Assert.Equal(0.95f, vm.ConfidenceScore);
    }

    #endregion

    #region Status Updates

    [Fact]
    public void MarkAsApplied_SetsStatusAndSendsMessage()
    {
        CodeBlockStatusChangedMessage? received = null;
        WeakReferenceMessenger.Default.Register<CodeBlockStatusChangedMessage>(
            this, (r, m) => received = m);

        var vm = new CodeBlockViewModel { Status = CodeBlockStatus.Applying };

        vm.MarkAsApplied();

        Assert.Equal(CodeBlockStatus.Applied, vm.Status);
        Assert.Null(vm.ErrorMessage);
        Assert.NotNull(received);
    }

    [Fact]
    public void MarkAsError_SetsStatusAndErrorMessage()
    {
        var vm = new CodeBlockViewModel { Status = CodeBlockStatus.Applying };

        vm.MarkAsError("File not found");

        Assert.Equal(CodeBlockStatus.Error, vm.Status);
        Assert.Equal("File not found", vm.ErrorMessage);
    }

    [Fact]
    public void ResetToPending_ClearsErrorAndResetsStatus()
    {
        var vm = new CodeBlockViewModel
        {
            Status = CodeBlockStatus.Error,
            ErrorMessage = "Some error"
        };

        vm.ResetToPending();

        Assert.Equal(CodeBlockStatus.Pending, vm.Status);
        Assert.Null(vm.ErrorMessage);
    }

    #endregion

    #region Model Conversion

    [Fact]
    public void FromModel_CopiesAllProperties()
    {
        var block = new CodeBlock
        {
            Id = Guid.NewGuid(),
            MessageId = Guid.NewGuid(),
            SequenceNumber = 2,
            Content = "test",
            Language = "csharp",
            DisplayLanguage = "C#",
            TargetFilePath = "test.cs",
            BlockType = CodeBlockType.Snippet,
            Status = CodeBlockStatus.Applied,
            ConfidenceScore = 0.8f
        };

        var vm = new CodeBlockViewModel(block);

        Assert.Equal(block.Id, vm.Id);
        Assert.Equal(block.MessageId, vm.MessageId);
        Assert.Equal(block.SequenceNumber, vm.SequenceNumber);
        Assert.Equal(block.Content, vm.Content);
        Assert.Equal(block.Language, vm.Language);
        Assert.Equal(block.DisplayLanguage, vm.DisplayLanguage);
        Assert.Equal(block.TargetFilePath, vm.TargetFilePath);
        Assert.Equal(block.BlockType, vm.BlockType);
        Assert.Equal(block.Status, vm.Status);
        Assert.Equal(block.ConfidenceScore, vm.ConfidenceScore);
    }

    [Fact]
    public void ToModel_CreatesCorrectModel()
    {
        var vm = new CodeBlockViewModel
        {
            Id = Guid.NewGuid(),
            MessageId = Guid.NewGuid(),
            Content = "test",
            Language = "python",
            BlockType = CodeBlockType.Command
        };

        var model = vm.ToModel();

        Assert.Equal(vm.Id, model.Id);
        Assert.Equal(vm.Content, model.Content);
        Assert.Equal(vm.Language, model.Language);
        Assert.Equal(vm.BlockType, model.BlockType);
    }

    #endregion
}
```

### Test File: `tests/SeniorIntern.Desktop.Tests/ViewModels/CodeProposalViewModelTests.cs`

```csharp
namespace SeniorIntern.Desktop.Tests.ViewModels;

using SeniorIntern.Core.Models;
using SeniorIntern.Desktop.ViewModels;
using Xunit;

public class CodeProposalViewModelTests
{
    [Fact]
    public void ApplicableCount_ReturnsCorrectCount()
    {
        var vm = new CodeProposalViewModel();
        vm.CodeBlocks.Add(new CodeBlockViewModel
        {
            BlockType = CodeBlockType.CompleteFile,
            TargetFilePath = "a.cs"
        });
        vm.CodeBlocks.Add(new CodeBlockViewModel
        {
            BlockType = CodeBlockType.Example
        });
        vm.CodeBlocks.Add(new CodeBlockViewModel
        {
            BlockType = CodeBlockType.Snippet,
            TargetFilePath = "b.cs"
        });

        Assert.Equal(2, vm.ApplicableCount);
    }

    [Fact]
    public void IsFullyApplied_TrueWhenAllApplicableApplied()
    {
        var vm = new CodeProposalViewModel();
        vm.CodeBlocks.Add(new CodeBlockViewModel
        {
            BlockType = CodeBlockType.CompleteFile,
            TargetFilePath = "a.cs",
            Status = CodeBlockStatus.Applied
        });
        vm.CodeBlocks.Add(new CodeBlockViewModel
        {
            BlockType = CodeBlockType.Example,
            Status = CodeBlockStatus.Pending
        });

        Assert.True(vm.IsFullyApplied);
    }

    [Fact]
    public void IsPartiallyApplied_TrueWhenSomeApplied()
    {
        var vm = new CodeProposalViewModel();
        vm.CodeBlocks.Add(new CodeBlockViewModel
        {
            BlockType = CodeBlockType.CompleteFile,
            TargetFilePath = "a.cs",
            Status = CodeBlockStatus.Applied
        });
        vm.CodeBlocks.Add(new CodeBlockViewModel
        {
            BlockType = CodeBlockType.Snippet,
            TargetFilePath = "b.cs",
            Status = CodeBlockStatus.Pending
        });

        Assert.True(vm.IsPartiallyApplied);
    }

    [Fact]
    public void AffectedFiles_ReturnsDistinctPaths()
    {
        var vm = new CodeProposalViewModel();
        vm.CodeBlocks.Add(new CodeBlockViewModel { TargetFilePath = "a.cs" });
        vm.CodeBlocks.Add(new CodeBlockViewModel { TargetFilePath = "b.cs" });
        vm.CodeBlocks.Add(new CodeBlockViewModel { TargetFilePath = "a.cs" });
        vm.CodeBlocks.Add(new CodeBlockViewModel { TargetFilePath = null });

        var files = vm.AffectedFiles.ToList();

        Assert.Equal(2, files.Count);
        Assert.Contains("a.cs", files);
        Assert.Contains("b.cs", files);
    }

    [Fact]
    public void ProgressText_ShowsCorrectProgress()
    {
        var vm = new CodeProposalViewModel();
        vm.CodeBlocks.Add(new CodeBlockViewModel
        {
            BlockType = CodeBlockType.CompleteFile,
            TargetFilePath = "a.cs",
            Status = CodeBlockStatus.Applied
        });
        vm.CodeBlocks.Add(new CodeBlockViewModel
        {
            BlockType = CodeBlockType.CompleteFile,
            TargetFilePath = "b.cs",
            Status = CodeBlockStatus.Pending
        });

        Assert.Equal("1 of 2 applied", vm.ProgressText);
    }
}
```

---

## Test Count Summary

| Component | Test Count | Focus Areas |
|-----------|------------|-------------|
| CodeBlockViewModel - Computed | 7 | IsApplicable, LineCount, FileName, StatusText, ShowApplyButton |
| CodeBlockViewModel - Commands | 3 | Copy, ShowDiff, Reject |
| CodeBlockViewModel - Streaming | 2 | AppendContent, CompleteStreaming |
| CodeBlockViewModel - Status | 3 | MarkAsApplied, MarkAsError, ResetToPending |
| CodeBlockViewModel - Conversion | 2 | FromModel, ToModel |
| CodeProposalViewModel | 5 | ApplicableCount, IsFullyApplied, IsPartiallyApplied, AffectedFiles, ProgressText |
| ChatMessageViewModel | 6 | BeginCodeBlock, UpdateStreamingBlock, CompleteCurrentBlock, ParseCodeBlocks, Stats |
| ChatViewModel Streaming | 4 | ParserEvents, PathInference, MessageHandling |
| **Total** | **32** | |

---

## Files Summary

### Files to Create (5)

| File | Purpose | Lines (approx) |
|------|---------|----------------|
| `src/SeniorIntern.Core/Interfaces/IClipboardService.cs` | Clipboard abstraction | 30 |
| `src/SeniorIntern.Desktop/Services/ClipboardService.cs` | Avalonia clipboard impl | 50 |
| `src/SeniorIntern.Desktop/Messages/CodeBlockMessages.cs` | Messenger messages | 120 |
| `src/SeniorIntern.Desktop/ViewModels/CodeBlockViewModel.cs` | Code block ViewModel | 380 |
| `src/SeniorIntern.Desktop/ViewModels/CodeProposalViewModel.cs` | Proposal ViewModel | 180 |

### Files to Modify (2)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/ViewModels/ChatMessageViewModel.cs` | Add code block support |
| `src/SeniorIntern.Desktop/ViewModels/ChatViewModel.cs` | Wire streaming parser |

---

## Acceptance Criteria

| ID | Criterion | Verification |
|----|-----------|--------------|
| AC-1 | CodeBlockViewModel correctly binds all observable properties | Unit test |
| AC-2 | Computed properties (IsApplicable, ShowApplyButton, etc.) update correctly | Unit test |
| AC-3 | CopyToClipboard command sends message and copies content | Unit test |
| AC-4 | ShowDiff command sets status to Reviewing and sends message | Unit test |
| AC-5 | Reject command changes status and sends notification | Unit test |
| AC-6 | Streaming methods (AppendContent, CompleteStreaming) work correctly | Unit test |
| AC-7 | Status update methods send appropriate messages | Unit test |
| AC-8 | ChatMessageViewModel.BeginCodeBlock creates streaming block | Unit test |
| AC-9 | ChatMessageViewModel.CompleteCurrentBlock finalizes block | Unit test |
| AC-10 | ChatMessageViewModel statistics update on block changes | Unit test |
| AC-11 | ChatViewModel subscribes to parser events during generation | Manual test |
| AC-12 | Parser events marshal to UI thread correctly | Manual test |
| AC-13 | Path inference runs after block completion | Unit test |
| AC-14 | Clipboard service successfully copies text | Manual test |
| AC-15 | CodeProposalViewModel tracks aggregate statistics | Unit test |
| AC-16 | Messages sent via WeakReferenceMessenger reach recipients | Unit test |

---

## Design Decisions

| Decision | Rationale |
|----------|-----------|
| WeakReferenceMessenger for cross-VM communication | Decouples ViewModels, prevents memory leaks |
| Commands on CodeBlockViewModel | Enables direct binding from UI controls |
| Streaming block tracking via CurrentStreamingBlock | Simplifies content updates during streaming |
| Property change notifications cascade stats | Ensures UI always shows current counts |
| IClipboardService abstraction | Enables testing and platform flexibility |
| Status lifecycle with Reviewing state | Allows tracking when user is examining diff |
| Path inference post-completion | Content needed for type name extraction |

---

## Edge Cases and Error Handling

### Edge Case 1: Multiple Streaming Blocks Rapidly

```
// Scenario: LLM outputs two code blocks in quick succession
// Solution: Parser handles this via BlockCompleted before next BlockStarted
// CurrentStreamingBlock is set to null on complete, then new block assigned
```

### Edge Case 2: Cancelled Generation with Open Block

```
// Scenario: User cancels while code block is streaming
// Solution: parser.Complete() finalizes any open block
// ChatMessageViewModel.MarkAsCancelled() handles cleanup
```

### Edge Case 3: Empty Code Block

```
// Scenario: LLM outputs ``` ``` (empty block)
// Solution: Block is created but IsApplicable = false (no content)
// UI shows empty code block but no Apply button
```

### Error Handling

| Scenario | Handling |
|----------|----------|
| Clipboard unavailable | ClipboardService returns gracefully |
| Path inference fails | Block shows "Unknown file" state |
| Message recipient not registered | Messenger silently ignores |
| Parser event on disposed parser | Events not raised after dispose |

---

## Performance Considerations

| Aspect | Approach |
|--------|----------|
| UI thread marshaling | Use Dispatcher.UIThread.Post for fire-and-forget |
| Collection updates | ObservableCollection provides change notifications |
| Stats recalculation | Only on status property change, not every update |
| Content accumulation | Direct string concatenation (StringBuilder in model) |
| Message batching | ContentAdded could be throttled if needed |

---

## Dependencies

| Part | Dependency Description |
|------|------------------------|
| v0.4.1a | CodeBlock, CodeProposal, CodeBlockStatus models |
| v0.4.1b | ICodeBlockParserService for non-streaming parse |
| v0.4.1e | IFilePathInferenceService for path inference |
| v0.4.1f | IStreamingCodeBlockParser, streaming events |
| v0.1.0 | Existing ChatViewModel, ChatMessageViewModel |

---

## Integration Points

### Upstream Dependencies

| Component | Dependency |
|-----------|------------|
| v0.4.1f | IStreamingCodeBlockParser and events |
| v0.4.1e | IFilePathInferenceService |
| v0.4.1b | ICodeBlockParserService |
| v0.4.1a | Domain models |

### Downstream Consumers

| Component | Usage |
|-----------|-------|
| v0.4.1h | CodeBlockControl binds to CodeBlockViewModel |
| v0.4.2 | DiffViewer receives ShowDiffRequestMessage |
| v0.4.3 | ApplyChanges receives ApplyChangesRequestMessage |

---

## Next Steps

With v0.4.1g complete, the ViewModel layer is ready for UI binding. Proceed to:

| Part | Status | Description |
|------|--------|-------------|
| v0.4.1a | Complete | Core models |
| v0.4.1b | Complete | Parser service |
| v0.4.1c | Complete | Language detection |
| v0.4.1d | Complete | Block classification |
| v0.4.1e | Complete | File path inference |
| v0.4.1f | Complete | Streaming parser |
| v0.4.1g | **Complete** | ViewModel integration |
| v0.4.1h | Next | UI rendering |

**Proceed to v0.4.1h: UI Rendering**
- Create `CodeBlockControl` user control
- Implement syntax highlighting preview
- Add action buttons (Copy, Apply, Reject)
- Create status badges and streaming indicators
- Update `ChatMessageControl` to display code blocks
