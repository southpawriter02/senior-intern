# Design Specification: The Senior Intern v0.4.3 "Apply Changes Workflow"

**Status**: _IMPLEMENTED_

## Executive Summary

This document provides a comprehensive design specification for v0.4.3, which implements the complete workflow for applying proposed code changes to files. This includes confirmation dialogs, file backup, undo capability, conflict detection, and editor integration.

### Parent Version Reference
- **Parent**: v0.4.0 "Code Generation & Diffing"
- **Focus**: User approval flow, file writing, undo capability

### Dependencies
- v0.4.1 (Code Block Extraction) - Required for CodeBlock model
- v0.4.2 (Diff Engine) - Required for DiffResult and diff computation

---

## Sub-Part Breakdown

| Sub-Part | Name | Focus |
|----------|------|-------|
| v0.4.3a | Core Models | ApplyResult, ApplyOptions, FileChangeRecord models |
| v0.4.3b | File Change Service | IFileChangeService interface and implementation |
| v0.4.3c | Backup System | File backup creation, storage, and cleanup |
| v0.4.3d | Undo System | Undo stack, time-windowed undo capability |
| v0.4.3e | Conflict Detection | File change detection and conflict resolution |
| v0.4.3f | Apply Dialog | ApplyChangesDialog with diff preview |
| v0.4.3g | Conflict Dialog | ConflictWarningDialog with resolution options |
| v0.4.3h | Undo Toast | Toast notification with undo action |
| v0.4.3i | Editor Integration | Refresh editor on file changes |

---

## v0.4.3a: Core Models

### Objective
Define the data models for apply operations, results, and change tracking.

### ApplyOptions Model

```csharp
// src/SeniorIntern.Core/Models/ApplyOptions.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Options for applying code changes to files.
/// </summary>
public sealed record ApplyOptions
{
    /// <summary>
    /// Whether to create a backup before modifying the file.
    /// </summary>
    public bool CreateBackup { get; init; } = true;

    /// <summary>
    /// Whether to allow overwriting when a conflict is detected.
    /// </summary>
    public bool AllowConflictOverwrite { get; init; } = false;

    /// <summary>
    /// Whether to refresh the editor after applying changes.
    /// </summary>
    public bool RefreshEditorAfterApply { get; init; } = true;

    /// <summary>
    /// Time window during which undo is available.
    /// </summary>
    public TimeSpan UndoWindow { get; init; } = TimeSpan.FromMinutes(30);

    /// <summary>
    /// Whether to show a confirmation dialog before applying.
    /// </summary>
    public bool ShowConfirmationDialog { get; init; } = true;

    /// <summary>
    /// Whether to validate file encoding and line endings.
    /// </summary>
    public bool ValidateEncoding { get; init; } = true;

    /// <summary>
    /// Preserve the original file's line ending style.
    /// </summary>
    public bool PreserveLineEndings { get; init; } = true;

    /// <summary>
    /// Create parent directories if they don't exist.
    /// </summary>
    public bool CreateParentDirectories { get; init; } = true;

    /// <summary>
    /// Default options instance.
    /// </summary>
    public static ApplyOptions Default => new();

    /// <summary>
    /// Options for silent apply (no dialogs, no backup).
    /// </summary>
    public static ApplyOptions Silent => new()
    {
        CreateBackup = false,
        ShowConfirmationDialog = false
    };
}
```

### ApplyResult Model

```csharp
// src/SeniorIntern.Core/Models/ApplyResult.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Result of applying a code change to a file.
/// </summary>
public sealed class ApplyResult
{
    /// <summary>
    /// Whether the apply operation succeeded.
    /// </summary>
    public bool Success { get; init; }

    /// <summary>
    /// Full path to the affected file.
    /// </summary>
    public string FilePath { get; init; } = string.Empty;

    /// <summary>
    /// Relative path within the workspace.
    /// </summary>
    public string RelativePath { get; init; } = string.Empty;

    /// <summary>
    /// Path to the backup file (if created).
    /// </summary>
    public string? BackupPath { get; init; }

    /// <summary>
    /// Type of result.
    /// </summary>
    public ApplyResultType ResultType { get; init; }

    /// <summary>
    /// Error message (if failed).
    /// </summary>
    public string? ErrorMessage { get; init; }

    /// <summary>
    /// The diff that was applied.
    /// </summary>
    public DiffResult? AppliedDiff { get; init; }

    /// <summary>
    /// When the change was applied.
    /// </summary>
    public DateTime AppliedAt { get; init; } = DateTime.UtcNow;

    /// <summary>
    /// ID of the code block that was applied.
    /// </summary>
    public Guid? CodeBlockId { get; init; }

    /// <summary>
    /// Whether undo is available for this change.
    /// </summary>
    public bool CanUndo { get; init; }

    /// <summary>
    /// File size after apply (in bytes).
    /// </summary>
    public long? FileSizeBytes { get; init; }

    /// <summary>
    /// Creates a successful result.
    /// </summary>
    public static ApplyResult Succeeded(
        string filePath,
        string relativePath,
        ApplyResultType type,
        DiffResult? diff = null,
        string? backupPath = null) => new()
    {
        Success = true,
        FilePath = filePath,
        RelativePath = relativePath,
        ResultType = type,
        AppliedDiff = diff,
        BackupPath = backupPath,
        CanUndo = !string.IsNullOrEmpty(backupPath)
    };

    /// <summary>
    /// Creates a failed result.
    /// </summary>
    public static ApplyResult Failed(
        string filePath,
        ApplyResultType type,
        string errorMessage) => new()
    {
        Success = false,
        FilePath = filePath,
        ResultType = type,
        ErrorMessage = errorMessage
    };
}

/// <summary>
/// Type of apply result.
/// </summary>
public enum ApplyResultType
{
    /// <summary>
    /// Successfully applied changes to existing file.
    /// </summary>
    Success,

    /// <summary>
    /// Successfully created a new file.
    /// </summary>
    Created,

    /// <summary>
    /// Successfully modified an existing file.
    /// </summary>
    Modified,

    /// <summary>
    /// Conflict detected - file was modified since proposal.
    /// </summary>
    Conflict,

    /// <summary>
    /// Target file was not found.
    /// </summary>
    FileNotFound,

    /// <summary>
    /// Permission denied to write file.
    /// </summary>
    PermissionDenied,

    /// <summary>
    /// Validation failed (e.g., invalid path).
    /// </summary>
    ValidationFailed,

    /// <summary>
    /// Operation was cancelled by user.
    /// </summary>
    Cancelled,

    /// <summary>
    /// File is locked by another process.
    /// </summary>
    FileLocked,

    /// <summary>
    /// Disk is full or quota exceeded.
    /// </summary>
    DiskFull,

    /// <summary>
    /// Unknown error occurred.
    /// </summary>
    Error
}
```

### FileChangeRecord Model

```csharp
// src/SeniorIntern.Core/Models/FileChangeRecord.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Record of a file change for undo tracking.
/// </summary>
public sealed class FileChangeRecord
{
    /// <summary>
    /// Unique identifier for this change.
    /// </summary>
    public Guid Id { get; init; } = Guid.NewGuid();

    /// <summary>
    /// Full path to the changed file.
    /// </summary>
    public string FilePath { get; init; } = string.Empty;

    /// <summary>
    /// Relative path within workspace.
    /// </summary>
    public string RelativePath { get; init; } = string.Empty;

    /// <summary>
    /// Path to the backup file (for undo).
    /// </summary>
    public string BackupPath { get; init; } = string.Empty;

    /// <summary>
    /// When the change was made.
    /// </summary>
    public DateTime ChangedAt { get; init; } = DateTime.UtcNow;

    /// <summary>
    /// Type of change.
    /// </summary>
    public FileChangeType ChangeType { get; init; }

    /// <summary>
    /// ID of the code block that generated this change.
    /// </summary>
    public Guid? CodeBlockId { get; init; }

    /// <summary>
    /// ID of the message containing the code block.
    /// </summary>
    public Guid? MessageId { get; init; }

    /// <summary>
    /// Whether undo is still available.
    /// </summary>
    public bool CanUndo { get; init; }

    /// <summary>
    /// Hash of the original content (for verification).
    /// </summary>
    public string? OriginalContentHash { get; init; }

    /// <summary>
    /// Hash of the new content.
    /// </summary>
    public string? NewContentHash { get; init; }

    /// <summary>
    /// Description of the change.
    /// </summary>
    public string? Description { get; init; }

    /// <summary>
    /// Time remaining for undo (based on configured window).
    /// </summary>
    public TimeSpan GetUndoTimeRemaining(TimeSpan undoWindow)
    {
        var elapsed = DateTime.UtcNow - ChangedAt;
        var remaining = undoWindow - elapsed;
        return remaining > TimeSpan.Zero ? remaining : TimeSpan.Zero;
    }

    /// <summary>
    /// Whether undo has expired.
    /// </summary>
    public bool IsUndoExpired(TimeSpan undoWindow) =>
        DateTime.UtcNow - ChangedAt > undoWindow;
}

/// <summary>
/// Type of file change.
/// </summary>
public enum FileChangeType
{
    /// <summary>
    /// File was created.
    /// </summary>
    Created,

    /// <summary>
    /// File was modified.
    /// </summary>
    Modified,

    /// <summary>
    /// File was deleted.
    /// </summary>
    Deleted,

    /// <summary>
    /// File was renamed.
    /// </summary>
    Renamed
}
```

### Apply Events

```csharp
// src/SeniorIntern.Core/Events/ApplyEvents.cs
namespace SeniorIntern.Core.Events;

/// <summary>
/// Event args for successful file changes.
/// </summary>
public sealed class FileChangedEventArgs : EventArgs
{
    public required string FilePath { get; init; }
    public required string RelativePath { get; init; }
    public required FileChangeType ChangeType { get; init; }
    public Guid? CodeBlockId { get; init; }
    public Guid? MessageId { get; init; }
    public DateTime Timestamp { get; init; } = DateTime.UtcNow;
    public bool CanUndo { get; init; }
}

/// <summary>
/// Event args for failed file changes.
/// </summary>
public sealed class FileChangeFailedEventArgs : EventArgs
{
    public required string FilePath { get; init; }
    public required string ErrorMessage { get; init; }
    public required ApplyResultType FailureType { get; init; }
    public Exception? Exception { get; init; }
    public DateTime Timestamp { get; init; } = DateTime.UtcNow;
}

/// <summary>
/// Event args for undo operations.
/// </summary>
public sealed class FileChangeUndoneEventArgs : EventArgs
{
    public required string FilePath { get; init; }
    public required FileChangeRecord OriginalChange { get; init; }
    public DateTime Timestamp { get; init; } = DateTime.UtcNow;
}

/// <summary>
/// Event args for conflict detection.
/// </summary>
public sealed class FileConflictDetectedEventArgs : EventArgs
{
    public required string FilePath { get; init; }
    public required string ExpectedHash { get; init; }
    public required string ActualHash { get; init; }
    public required DateTime LastModified { get; init; }
}
```

### Files to Create (v0.4.3a)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Models/ApplyOptions.cs` | Apply configuration options |
| `src/SeniorIntern.Core/Models/ApplyResult.cs` | Apply operation result |
| `src/SeniorIntern.Core/Models/FileChangeRecord.cs` | Change tracking record |
| `src/SeniorIntern.Core/Events/ApplyEvents.cs` | Apply-related events |

### Testing Strategy (v0.4.3a)

```csharp
public class ApplyModelsTests
{
    [Fact]
    public void ApplyResult_Succeeded_SetsCorrectProperties()
    {
        var result = ApplyResult.Succeeded(
            "/path/to/file.cs",
            "src/file.cs",
            ApplyResultType.Modified,
            backupPath: "/backup/file.cs");

        Assert.True(result.Success);
        Assert.True(result.CanUndo);
        Assert.Equal(ApplyResultType.Modified, result.ResultType);
    }

    [Fact]
    public void FileChangeRecord_GetUndoTimeRemaining_CalculatesCorrectly()
    {
        var record = new FileChangeRecord
        {
            ChangedAt = DateTime.UtcNow.AddMinutes(-10)
        };

        var remaining = record.GetUndoTimeRemaining(TimeSpan.FromMinutes(30));

        Assert.True(remaining.TotalMinutes >= 19 && remaining.TotalMinutes <= 20);
    }

    [Fact]
    public void FileChangeRecord_IsUndoExpired_ReturnsTrueAfterWindow()
    {
        var record = new FileChangeRecord
        {
            ChangedAt = DateTime.UtcNow.AddMinutes(-35)
        };

        Assert.True(record.IsUndoExpired(TimeSpan.FromMinutes(30)));
    }
}
```

### Acceptance Criteria (v0.4.3a)

- [ ] ApplyOptions has all necessary configuration properties
- [ ] ApplyResult correctly represents success and failure states
- [ ] FileChangeRecord tracks all change metadata
- [ ] Events provide complete information for subscribers
- [ ] Undo time calculations are accurate

---

## v0.4.3b: File Change Service

### Objective
Implement the core service for applying code changes to files.

### IFileChangeService Interface

```csharp
// src/SeniorIntern.Core/Interfaces/IFileChangeService.cs
namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Service for applying code changes to files.
/// </summary>
public interface IFileChangeService
{
    /// <summary>
    /// Apply a single code block to its target file.
    /// </summary>
    Task<ApplyResult> ApplyCodeBlockAsync(
        CodeBlock block,
        string workspacePath,
        ApplyOptions? options = null,
        CancellationToken ct = default);

    /// <summary>
    /// Apply multiple code blocks (potentially to the same file).
    /// </summary>
    Task<IReadOnlyList<ApplyResult>> ApplyCodeBlocksAsync(
        IEnumerable<CodeBlock> blocks,
        string workspacePath,
        ApplyOptions? options = null,
        CancellationToken ct = default);

    /// <summary>
    /// Apply a diff result directly.
    /// </summary>
    Task<ApplyResult> ApplyDiffAsync(
        DiffResult diff,
        string workspacePath,
        ApplyOptions? options = null,
        CancellationToken ct = default);

    /// <summary>
    /// Preview what would happen when applying a code block.
    /// </summary>
    Task<ApplyPreview> PreviewApplyAsync(
        CodeBlock block,
        string workspacePath,
        CancellationToken ct = default);

    /// <summary>
    /// Undo the last applied change for a file.
    /// </summary>
    Task<bool> UndoLastChangeAsync(string filePath, CancellationToken ct = default);

    /// <summary>
    /// Undo a specific change by ID.
    /// </summary>
    Task<bool> UndoChangeAsync(Guid changeId, CancellationToken ct = default);

    /// <summary>
    /// Check if undo is available for a file.
    /// </summary>
    bool CanUndo(string filePath);

    /// <summary>
    /// Get change history for a file.
    /// </summary>
    IReadOnlyList<FileChangeRecord> GetChangeHistory(
        string filePath,
        int maxRecords = 10);

    /// <summary>
    /// Get all pending undos across all files.
    /// </summary>
    IReadOnlyList<FileChangeRecord> GetPendingUndos();

    /// <summary>
    /// Check for conflicts before applying.
    /// </summary>
    Task<ConflictCheckResult> CheckForConflictsAsync(
        CodeBlock block,
        string workspacePath,
        CancellationToken ct = default);

    /// <summary>
    /// Raised when a file is changed.
    /// </summary>
    event EventHandler<FileChangedEventArgs>? FileChanged;

    /// <summary>
    /// Raised when a change fails.
    /// </summary>
    event EventHandler<FileChangeFailedEventArgs>? ChangeFailed;

    /// <summary>
    /// Raised when a change is undone.
    /// </summary>
    event EventHandler<FileChangeUndoneEventArgs>? ChangeUndone;

    /// <summary>
    /// Raised when a conflict is detected.
    /// </summary>
    event EventHandler<FileConflictDetectedEventArgs>? ConflictDetected;
}

/// <summary>
/// Preview of what would happen when applying a code block.
/// </summary>
public sealed class ApplyPreview
{
    public bool WouldSucceed { get; init; }
    public ApplyResultType ExpectedResultType { get; init; }
    public bool FileExists { get; init; }
    public bool HasConflict { get; init; }
    public DiffResult? Diff { get; init; }
    public string? WarningMessage { get; init; }
    public IReadOnlyList<string> AffectedPaths { get; init; } = Array.Empty<string>();
}

/// <summary>
/// Result of conflict checking.
/// </summary>
public sealed class ConflictCheckResult
{
    public bool HasConflict { get; init; }
    public string? ConflictReason { get; init; }
    public DateTime? LastModified { get; init; }
    public string? CurrentContentHash { get; init; }
    public string? ExpectedContentHash { get; init; }
}
```

### FileChangeService Implementation

```csharp
// src/SeniorIntern.Services/FileChangeService.cs
namespace SeniorIntern.Services;

public sealed class FileChangeService : IFileChangeService, IDisposable
{
    private readonly IFileSystemService _fileSystem;
    private readonly IDiffService _diffService;
    private readonly IBackupService _backupService;
    private readonly ILogger<FileChangeService>? _logger;
    private readonly ApplyOptions _defaultOptions;

    private readonly ConcurrentDictionary<string, Stack<FileChangeRecord>> _changeHistory = new();
    private readonly object _historyLock = new();
    private readonly SemaphoreSlim _applyLock = new(1, 1);

    public event EventHandler<FileChangedEventArgs>? FileChanged;
    public event EventHandler<FileChangeFailedEventArgs>? ChangeFailed;
    public event EventHandler<FileChangeUndoneEventArgs>? ChangeUndone;
    public event EventHandler<FileConflictDetectedEventArgs>? ConflictDetected;

    public FileChangeService(
        IFileSystemService fileSystem,
        IDiffService diffService,
        IBackupService backupService,
        ILogger<FileChangeService>? logger = null,
        ApplyOptions? defaultOptions = null)
    {
        _fileSystem = fileSystem;
        _diffService = diffService;
        _backupService = backupService;
        _logger = logger;
        _defaultOptions = defaultOptions ?? ApplyOptions.Default;
    }

    public async Task<ApplyResult> ApplyCodeBlockAsync(
        CodeBlock block,
        string workspacePath,
        ApplyOptions? options = null,
        CancellationToken ct = default)
    {
        options ??= _defaultOptions;

        // Validate inputs
        if (string.IsNullOrEmpty(block.TargetFilePath))
        {
            return ApplyResult.Failed(
                string.Empty,
                ApplyResultType.ValidationFailed,
                "Code block does not have a target file path");
        }

        var fullPath = Path.Combine(workspacePath, block.TargetFilePath);
        var relativePath = block.TargetFilePath;

        await _applyLock.WaitAsync(ct);
        try
        {
            return await ApplyInternalAsync(
                block, fullPath, relativePath, workspacePath, options, ct);
        }
        finally
        {
            _applyLock.Release();
        }
    }

    private async Task<ApplyResult> ApplyInternalAsync(
        CodeBlock block,
        string fullPath,
        string relativePath,
        string workspacePath,
        ApplyOptions options,
        CancellationToken ct)
    {
        var fileExists = await _fileSystem.FileExistsAsync(fullPath, ct);

        try
        {
            // Check for conflicts
            if (fileExists && !options.AllowConflictOverwrite)
            {
                var conflictCheck = await CheckForConflictsAsync(block, workspacePath, ct);
                if (conflictCheck.HasConflict)
                {
                    ConflictDetected?.Invoke(this, new FileConflictDetectedEventArgs
                    {
                        FilePath = fullPath,
                        ExpectedHash = conflictCheck.ExpectedContentHash ?? string.Empty,
                        ActualHash = conflictCheck.CurrentContentHash ?? string.Empty,
                        LastModified = conflictCheck.LastModified ?? DateTime.UtcNow
                    });

                    return ApplyResult.Failed(
                        fullPath,
                        ApplyResultType.Conflict,
                        conflictCheck.ConflictReason ?? "File has been modified");
                }
            }

            // Create backup
            string? backupPath = null;
            string? originalHash = null;
            if (fileExists && options.CreateBackup)
            {
                var originalContent = await _fileSystem.ReadFileAsync(fullPath, ct);
                originalHash = ComputeHash(originalContent);
                backupPath = await _backupService.CreateBackupAsync(fullPath, ct);
                _logger?.LogDebug("Created backup at {BackupPath}", backupPath);
            }

            // Compute diff
            var diff = await _diffService.ComputeDiffForBlockAsync(block, workspacePath, ct);

            // Create parent directories if needed
            if (options.CreateParentDirectories)
            {
                var directory = Path.GetDirectoryName(fullPath);
                if (!string.IsNullOrEmpty(directory))
                {
                    Directory.CreateDirectory(directory);
                }
            }

            // Prepare content
            var contentToWrite = diff.ProposedContent;
            if (options.PreserveLineEndings && fileExists)
            {
                var originalContent = await _fileSystem.ReadFileAsync(fullPath, ct);
                contentToWrite = NormalizeLineEndings(contentToWrite, originalContent);
            }

            // Write the file
            await _fileSystem.WriteFileAsync(fullPath, contentToWrite, ct);

            var newHash = ComputeHash(contentToWrite);
            var changeType = fileExists ? FileChangeType.Modified : FileChangeType.Created;

            // Record for undo
            var record = new FileChangeRecord
            {
                FilePath = fullPath,
                RelativePath = relativePath,
                BackupPath = backupPath ?? string.Empty,
                ChangeType = changeType,
                CodeBlockId = block.Id,
                MessageId = block.MessageId,
                CanUndo = !string.IsNullOrEmpty(backupPath),
                OriginalContentHash = originalHash,
                NewContentHash = newHash,
                Description = $"Applied code block to {Path.GetFileName(fullPath)}"
            };

            RecordChange(fullPath, record);

            // Raise event
            FileChanged?.Invoke(this, new FileChangedEventArgs
            {
                FilePath = fullPath,
                RelativePath = relativePath,
                ChangeType = changeType,
                CodeBlockId = block.Id,
                MessageId = block.MessageId,
                CanUndo = record.CanUndo
            });

            _logger?.LogInformation(
                "Applied code block {BlockId} to {FilePath}",
                block.Id, relativePath);

            var fileInfo = new FileInfo(fullPath);
            return new ApplyResult
            {
                Success = true,
                FilePath = fullPath,
                RelativePath = relativePath,
                BackupPath = backupPath,
                ResultType = fileExists ? ApplyResultType.Modified : ApplyResultType.Created,
                AppliedDiff = diff,
                CodeBlockId = block.Id,
                CanUndo = record.CanUndo,
                FileSizeBytes = fileInfo.Length
            };
        }
        catch (UnauthorizedAccessException ex)
        {
            _logger?.LogWarning(ex, "Permission denied writing to {FilePath}", fullPath);
            RaiseChangeFailed(fullPath, "Permission denied", ApplyResultType.PermissionDenied, ex);
            return ApplyResult.Failed(fullPath, ApplyResultType.PermissionDenied, ex.Message);
        }
        catch (IOException ex) when (IsFileLocked(ex))
        {
            _logger?.LogWarning(ex, "File is locked: {FilePath}", fullPath);
            RaiseChangeFailed(fullPath, "File is locked by another process", ApplyResultType.FileLocked, ex);
            return ApplyResult.Failed(fullPath, ApplyResultType.FileLocked, ex.Message);
        }
        catch (IOException ex) when (IsDiskFull(ex))
        {
            _logger?.LogError(ex, "Disk full writing to {FilePath}", fullPath);
            RaiseChangeFailed(fullPath, "Disk is full", ApplyResultType.DiskFull, ex);
            return ApplyResult.Failed(fullPath, ApplyResultType.DiskFull, ex.Message);
        }
        catch (Exception ex)
        {
            _logger?.LogError(ex, "Error applying changes to {FilePath}", fullPath);
            RaiseChangeFailed(fullPath, ex.Message, ApplyResultType.Error, ex);
            return ApplyResult.Failed(fullPath, ApplyResultType.Error, ex.Message);
        }
    }

    public async Task<IReadOnlyList<ApplyResult>> ApplyCodeBlocksAsync(
        IEnumerable<CodeBlock> blocks,
        string workspacePath,
        ApplyOptions? options = null,
        CancellationToken ct = default)
    {
        var results = new List<ApplyResult>();
        var blockList = blocks.ToList();

        // Group by target file to handle multiple blocks targeting same file
        var groupedByFile = blockList
            .Where(b => !string.IsNullOrEmpty(b.TargetFilePath))
            .GroupBy(b => b.TargetFilePath!)
            .ToList();

        foreach (var group in groupedByFile)
        {
            var blocksForFile = group.ToList();

            if (blocksForFile.Count == 1)
            {
                var result = await ApplyCodeBlockAsync(blocksForFile[0], workspacePath, options, ct);
                results.Add(result);
            }
            else
            {
                // Multiple blocks targeting same file - merge and apply
                var mergedDiff = await _diffService.ComputeMergedDiffAsync(
                    blocksForFile, workspacePath, ct);
                var result = await ApplyDiffAsync(mergedDiff, workspacePath, options, ct);
                results.Add(result);
            }
        }

        return results;
    }

    public async Task<ApplyResult> ApplyDiffAsync(
        DiffResult diff,
        string workspacePath,
        ApplyOptions? options = null,
        CancellationToken ct = default)
    {
        options ??= _defaultOptions;

        var fullPath = Path.Combine(workspacePath, diff.OriginalFilePath);
        var fileExists = await _fileSystem.FileExistsAsync(fullPath, ct);

        await _applyLock.WaitAsync(ct);
        try
        {
            string? backupPath = null;
            if (fileExists && options.CreateBackup)
            {
                backupPath = await _backupService.CreateBackupAsync(fullPath, ct);
            }

            if (options.CreateParentDirectories)
            {
                var directory = Path.GetDirectoryName(fullPath);
                if (!string.IsNullOrEmpty(directory))
                {
                    Directory.CreateDirectory(directory);
                }
            }

            await _fileSystem.WriteFileAsync(fullPath, diff.ProposedContent, ct);

            var changeType = diff.IsNewFile ? FileChangeType.Created : FileChangeType.Modified;

            var record = new FileChangeRecord
            {
                FilePath = fullPath,
                RelativePath = diff.OriginalFilePath,
                BackupPath = backupPath ?? string.Empty,
                ChangeType = changeType,
                CanUndo = !string.IsNullOrEmpty(backupPath)
            };

            RecordChange(fullPath, record);

            FileChanged?.Invoke(this, new FileChangedEventArgs
            {
                FilePath = fullPath,
                RelativePath = diff.OriginalFilePath,
                ChangeType = changeType,
                CanUndo = record.CanUndo
            });

            return ApplyResult.Succeeded(
                fullPath,
                diff.OriginalFilePath,
                diff.IsNewFile ? ApplyResultType.Created : ApplyResultType.Modified,
                diff,
                backupPath);
        }
        finally
        {
            _applyLock.Release();
        }
    }

    public async Task<ApplyPreview> PreviewApplyAsync(
        CodeBlock block,
        string workspacePath,
        CancellationToken ct = default)
    {
        if (string.IsNullOrEmpty(block.TargetFilePath))
        {
            return new ApplyPreview
            {
                WouldSucceed = false,
                ExpectedResultType = ApplyResultType.ValidationFailed,
                WarningMessage = "Code block has no target file path"
            };
        }

        var fullPath = Path.Combine(workspacePath, block.TargetFilePath);
        var fileExists = await _fileSystem.FileExistsAsync(fullPath, ct);

        try
        {
            var diff = await _diffService.ComputeDiffForBlockAsync(block, workspacePath, ct);
            var conflictCheck = fileExists
                ? await CheckForConflictsAsync(block, workspacePath, ct)
                : new ConflictCheckResult { HasConflict = false };

            return new ApplyPreview
            {
                WouldSucceed = !conflictCheck.HasConflict,
                ExpectedResultType = fileExists
                    ? ApplyResultType.Modified
                    : ApplyResultType.Created,
                FileExists = fileExists,
                HasConflict = conflictCheck.HasConflict,
                Diff = diff,
                WarningMessage = conflictCheck.ConflictReason,
                AffectedPaths = new[] { block.TargetFilePath }
            };
        }
        catch (Exception ex)
        {
            return new ApplyPreview
            {
                WouldSucceed = false,
                ExpectedResultType = ApplyResultType.Error,
                WarningMessage = ex.Message
            };
        }
    }

    public async Task<bool> UndoLastChangeAsync(string filePath, CancellationToken ct = default)
    {
        if (!_changeHistory.TryGetValue(filePath, out var history) || history.Count == 0)
        {
            _logger?.LogDebug("No undo history for {FilePath}", filePath);
            return false;
        }

        FileChangeRecord lastChange;
        lock (_historyLock)
        {
            if (history.Count == 0)
                return false;
            lastChange = history.Peek();
        }

        if (!lastChange.CanUndo)
        {
            _logger?.LogDebug("Last change cannot be undone for {FilePath}", filePath);
            return false;
        }

        if (lastChange.IsUndoExpired(_defaultOptions.UndoWindow))
        {
            _logger?.LogDebug("Undo has expired for {FilePath}", filePath);
            return false;
        }

        return await UndoChangeAsync(lastChange.Id, ct);
    }

    public async Task<bool> UndoChangeAsync(Guid changeId, CancellationToken ct = default)
    {
        FileChangeRecord? record = null;
        string? filePath = null;

        lock (_historyLock)
        {
            foreach (var (path, history) in _changeHistory)
            {
                var found = history.FirstOrDefault(r => r.Id == changeId);
                if (found != null)
                {
                    record = found;
                    filePath = path;
                    break;
                }
            }
        }

        if (record == null || filePath == null)
        {
            return false;
        }

        try
        {
            await _applyLock.WaitAsync(ct);

            if (record.ChangeType == FileChangeType.Created)
            {
                // Delete the created file
                if (File.Exists(filePath))
                {
                    File.Delete(filePath);
                    _logger?.LogInformation("Undone file creation: {FilePath}", filePath);
                }
            }
            else
            {
                // Restore from backup
                if (!string.IsNullOrEmpty(record.BackupPath) && File.Exists(record.BackupPath))
                {
                    File.Copy(record.BackupPath, filePath, overwrite: true);
                    _logger?.LogInformation("Restored file from backup: {FilePath}", filePath);
                }
                else
                {
                    _logger?.LogWarning("Backup not found for undo: {BackupPath}", record.BackupPath);
                    return false;
                }
            }

            // Remove from history
            lock (_historyLock)
            {
                if (_changeHistory.TryGetValue(filePath, out var history))
                {
                    var list = history.ToList();
                    list.RemoveAll(r => r.Id == changeId);
                    _changeHistory[filePath] = new Stack<FileChangeRecord>(list.AsEnumerable().Reverse());
                }
            }

            ChangeUndone?.Invoke(this, new FileChangeUndoneEventArgs
            {
                FilePath = filePath,
                OriginalChange = record
            });

            return true;
        }
        catch (Exception ex)
        {
            _logger?.LogError(ex, "Failed to undo change for {FilePath}", filePath);
            return false;
        }
        finally
        {
            _applyLock.Release();
        }
    }

    public bool CanUndo(string filePath)
    {
        if (!_changeHistory.TryGetValue(filePath, out var history) || history.Count == 0)
            return false;

        var lastChange = history.Peek();
        return lastChange.CanUndo && !lastChange.IsUndoExpired(_defaultOptions.UndoWindow);
    }

    public IReadOnlyList<FileChangeRecord> GetChangeHistory(string filePath, int maxRecords = 10)
    {
        if (!_changeHistory.TryGetValue(filePath, out var history))
            return Array.Empty<FileChangeRecord>();

        return history.Take(maxRecords).ToList();
    }

    public IReadOnlyList<FileChangeRecord> GetPendingUndos()
    {
        var pending = new List<FileChangeRecord>();
        var window = _defaultOptions.UndoWindow;

        foreach (var (_, history) in _changeHistory)
        {
            foreach (var record in history)
            {
                if (record.CanUndo && !record.IsUndoExpired(window))
                {
                    pending.Add(record);
                }
            }
        }

        return pending.OrderByDescending(r => r.ChangedAt).ToList();
    }

    public async Task<ConflictCheckResult> CheckForConflictsAsync(
        CodeBlock block,
        string workspacePath,
        CancellationToken ct = default)
    {
        var fullPath = Path.Combine(workspacePath, block.TargetFilePath!);

        if (!await _fileSystem.FileExistsAsync(fullPath, ct))
        {
            return new ConflictCheckResult { HasConflict = false };
        }

        // For now, we compare current content hash with what we expected
        // In a full implementation, we'd track the original hash when the block was created
        var currentContent = await _fileSystem.ReadFileAsync(fullPath, ct);
        var currentHash = ComputeHash(currentContent);
        var fileInfo = new FileInfo(fullPath);

        // Simple heuristic: if file was modified very recently, might be a conflict
        var recentlyModified = DateTime.UtcNow - fileInfo.LastWriteTimeUtc < TimeSpan.FromSeconds(5);

        return new ConflictCheckResult
        {
            HasConflict = recentlyModified, // Simplified - real impl would compare hashes
            ConflictReason = recentlyModified
                ? "File was modified in the last 5 seconds"
                : null,
            LastModified = fileInfo.LastWriteTimeUtc,
            CurrentContentHash = currentHash
        };
    }

    private void RecordChange(string filePath, FileChangeRecord record)
    {
        lock (_historyLock)
        {
            var history = _changeHistory.GetOrAdd(filePath, _ => new Stack<FileChangeRecord>());
            history.Push(record);

            // Limit history size per file
            const int maxHistory = 50;
            while (history.Count > maxHistory)
            {
                var old = history.ToArray().Last();
                // Clean up old backup
                if (!string.IsNullOrEmpty(old.BackupPath) && File.Exists(old.BackupPath))
                {
                    try { File.Delete(old.BackupPath); }
                    catch { /* Ignore cleanup errors */ }
                }
            }
        }
    }

    private void RaiseChangeFailed(
        string filePath,
        string message,
        ApplyResultType type,
        Exception? ex = null)
    {
        ChangeFailed?.Invoke(this, new FileChangeFailedEventArgs
        {
            FilePath = filePath,
            ErrorMessage = message,
            FailureType = type,
            Exception = ex
        });
    }

    private static string ComputeHash(string content)
    {
        using var sha256 = SHA256.Create();
        var bytes = Encoding.UTF8.GetBytes(content);
        var hash = sha256.ComputeHash(bytes);
        return Convert.ToBase64String(hash);
    }

    private static string NormalizeLineEndings(string content, string reference)
    {
        // Detect line ending style from reference
        bool hasCrlf = reference.Contains("\r\n");
        bool hasCr = !hasCrlf && reference.Contains('\r');

        // Normalize to detected style
        var normalized = content.Replace("\r\n", "\n").Replace('\r', '\n');

        if (hasCrlf)
            return normalized.Replace("\n", "\r\n");
        if (hasCr)
            return normalized.Replace("\n", "\r");

        return normalized;
    }

    private static bool IsFileLocked(IOException ex) =>
        ex.HResult == -2147024864 || // ERROR_SHARING_VIOLATION
        ex.HResult == -2147024863;   // ERROR_LOCK_VIOLATION

    private static bool IsDiskFull(IOException ex) =>
        ex.HResult == -2147024784;   // ERROR_DISK_FULL

    public void Dispose()
    {
        _applyLock.Dispose();
    }
}
```

### Files to Create (v0.4.3b)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/IFileChangeService.cs` | Service interface |
| `src/SeniorIntern.Services/FileChangeService.cs` | Main implementation |

### Files to Modify (v0.4.3b)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/Extensions/ServiceCollectionExtensions.cs` | Register service |

### Testing Strategy (v0.4.3b)

```csharp
public class FileChangeServiceTests
{
    [Fact]
    public async Task ApplyCodeBlockAsync_NewFile_CreatesFile()
    {
        var service = CreateService();
        var block = CreateCodeBlock("src/NewFile.cs", "public class Test {}");

        var result = await service.ApplyCodeBlockAsync(block, _workspacePath);

        Assert.True(result.Success);
        Assert.Equal(ApplyResultType.Created, result.ResultType);
        Assert.True(File.Exists(Path.Combine(_workspacePath, "src/NewFile.cs")));
    }

    [Fact]
    public async Task ApplyCodeBlockAsync_ExistingFile_CreatesBackup()
    {
        var service = CreateService();
        var existingPath = CreateTestFile("src/Existing.cs", "original content");
        var block = CreateCodeBlock("src/Existing.cs", "new content");

        var result = await service.ApplyCodeBlockAsync(block, _workspacePath);

        Assert.True(result.Success);
        Assert.NotNull(result.BackupPath);
        Assert.True(File.Exists(result.BackupPath));
    }

    [Fact]
    public async Task UndoLastChangeAsync_RestoresFromBackup()
    {
        var service = CreateService();
        var existingPath = CreateTestFile("src/Test.cs", "original");
        var block = CreateCodeBlock("src/Test.cs", "modified");

        await service.ApplyCodeBlockAsync(block, _workspacePath);
        var undone = await service.UndoLastChangeAsync(existingPath);

        Assert.True(undone);
        Assert.Equal("original", File.ReadAllText(existingPath));
    }

    [Fact]
    public async Task ApplyCodeBlockAsync_PermissionDenied_ReturnsError()
    {
        var service = CreateService();
        var lockedFile = CreateLockedFile("src/Locked.cs");
        var block = CreateCodeBlock("src/Locked.cs", "content");

        var result = await service.ApplyCodeBlockAsync(block, _workspacePath);

        Assert.False(result.Success);
        Assert.Equal(ApplyResultType.PermissionDenied, result.ResultType);
    }
}
```

### Acceptance Criteria (v0.4.3b)

- [ ] ApplyCodeBlockAsync creates new files
- [ ] ApplyCodeBlockAsync modifies existing files
- [ ] Backups created when configured
- [ ] Undo restores from backup
- [ ] Undo window is enforced
- [ ] Permission errors handled gracefully
- [ ] File lock errors handled gracefully
- [ ] Events raised for all operations

---

## v0.4.3c: Backup System

### Objective
Implement a reliable file backup system for undo capability.

### IBackupService Interface

```csharp
// src/SeniorIntern.Core/Interfaces/IBackupService.cs
namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Service for managing file backups.
/// </summary>
public interface IBackupService
{
    /// <summary>
    /// Create a backup of a file.
    /// </summary>
    Task<string> CreateBackupAsync(string filePath, CancellationToken ct = default);

    /// <summary>
    /// Restore a file from backup.
    /// </summary>
    Task<bool> RestoreBackupAsync(string backupPath, string targetPath, CancellationToken ct = default);

    /// <summary>
    /// Delete a backup file.
    /// </summary>
    Task<bool> DeleteBackupAsync(string backupPath, CancellationToken ct = default);

    /// <summary>
    /// Get all backups for a file.
    /// </summary>
    IReadOnlyList<BackupInfo> GetBackupsForFile(string originalPath);

    /// <summary>
    /// Clean up old backups.
    /// </summary>
    Task<int> CleanupOldBackupsAsync(TimeSpan maxAge, CancellationToken ct = default);

    /// <summary>
    /// Get total backup storage size.
    /// </summary>
    long GetTotalBackupSize();

    /// <summary>
    /// Get backup directory path.
    /// </summary>
    string BackupDirectory { get; }
}

/// <summary>
/// Information about a backup file.
/// </summary>
public sealed class BackupInfo
{
    public string BackupPath { get; init; } = string.Empty;
    public string OriginalPath { get; init; } = string.Empty;
    public DateTime CreatedAt { get; init; }
    public long SizeBytes { get; init; }
    public string? ContentHash { get; init; }
}
```

### BackupService Implementation

```csharp
// src/SeniorIntern.Services/BackupService.cs
namespace SeniorIntern.Services;

public sealed class BackupService : IBackupService
{
    private readonly ILogger<BackupService>? _logger;
    private readonly string _backupDirectory;
    private const string BackupExtension = ".backup";
    private const string MetadataExtension = ".meta";

    public string BackupDirectory => _backupDirectory;

    public BackupService(ILogger<BackupService>? logger = null, string? customBackupDir = null)
    {
        _logger = logger;
        _backupDirectory = customBackupDir ?? GetDefaultBackupDirectory();
        Directory.CreateDirectory(_backupDirectory);
    }

    public async Task<string> CreateBackupAsync(string filePath, CancellationToken ct = default)
    {
        if (!File.Exists(filePath))
            throw new FileNotFoundException("File to backup not found", filePath);

        var fileName = Path.GetFileName(filePath);
        var timestamp = DateTime.UtcNow.ToString("yyyyMMdd_HHmmss_fff");
        var hash = ComputePathHash(filePath);
        var backupName = $"{Path.GetFileNameWithoutExtension(fileName)}_{timestamp}_{hash}{Path.GetExtension(fileName)}{BackupExtension}";
        var backupPath = Path.Combine(_backupDirectory, backupName);

        await Task.Run(() => File.Copy(filePath, backupPath, overwrite: true), ct);

        // Save metadata
        var metaPath = backupPath + MetadataExtension;
        var metadata = new BackupMetadata
        {
            OriginalPath = filePath,
            CreatedAt = DateTime.UtcNow,
            OriginalSize = new FileInfo(filePath).Length
        };
        await File.WriteAllTextAsync(metaPath, JsonSerializer.Serialize(metadata), ct);

        _logger?.LogDebug("Created backup: {BackupPath} for {OriginalPath}", backupPath, filePath);

        return backupPath;
    }

    public async Task<bool> RestoreBackupAsync(
        string backupPath,
        string targetPath,
        CancellationToken ct = default)
    {
        if (!File.Exists(backupPath))
        {
            _logger?.LogWarning("Backup file not found: {BackupPath}", backupPath);
            return false;
        }

        try
        {
            var directory = Path.GetDirectoryName(targetPath);
            if (!string.IsNullOrEmpty(directory) && !Directory.Exists(directory))
            {
                Directory.CreateDirectory(directory);
            }

            await Task.Run(() => File.Copy(backupPath, targetPath, overwrite: true), ct);
            _logger?.LogInformation("Restored backup to {TargetPath}", targetPath);
            return true;
        }
        catch (Exception ex)
        {
            _logger?.LogError(ex, "Failed to restore backup {BackupPath} to {TargetPath}",
                backupPath, targetPath);
            return false;
        }
    }

    public async Task<bool> DeleteBackupAsync(string backupPath, CancellationToken ct = default)
    {
        try
        {
            await Task.Run(() =>
            {
                if (File.Exists(backupPath))
                    File.Delete(backupPath);

                var metaPath = backupPath + MetadataExtension;
                if (File.Exists(metaPath))
                    File.Delete(metaPath);
            }, ct);

            _logger?.LogDebug("Deleted backup: {BackupPath}", backupPath);
            return true;
        }
        catch (Exception ex)
        {
            _logger?.LogWarning(ex, "Failed to delete backup: {BackupPath}", backupPath);
            return false;
        }
    }

    public IReadOnlyList<BackupInfo> GetBackupsForFile(string originalPath)
    {
        var hash = ComputePathHash(originalPath);
        var backups = new List<BackupInfo>();

        foreach (var file in Directory.EnumerateFiles(_backupDirectory, $"*_{hash}*{BackupExtension}"))
        {
            var metaPath = file + MetadataExtension;
            BackupMetadata? metadata = null;

            if (File.Exists(metaPath))
            {
                try
                {
                    var json = File.ReadAllText(metaPath);
                    metadata = JsonSerializer.Deserialize<BackupMetadata>(json);
                }
                catch { }
            }

            var fileInfo = new FileInfo(file);
            backups.Add(new BackupInfo
            {
                BackupPath = file,
                OriginalPath = metadata?.OriginalPath ?? originalPath,
                CreatedAt = metadata?.CreatedAt ?? fileInfo.CreationTimeUtc,
                SizeBytes = fileInfo.Length
            });
        }

        return backups.OrderByDescending(b => b.CreatedAt).ToList();
    }

    public async Task<int> CleanupOldBackupsAsync(TimeSpan maxAge, CancellationToken ct = default)
    {
        var cutoff = DateTime.UtcNow - maxAge;
        var deleted = 0;

        await Task.Run(() =>
        {
            foreach (var file in Directory.EnumerateFiles(_backupDirectory, $"*{BackupExtension}"))
            {
                var fileInfo = new FileInfo(file);
                if (fileInfo.CreationTimeUtc < cutoff)
                {
                    try
                    {
                        File.Delete(file);
                        var metaPath = file + MetadataExtension;
                        if (File.Exists(metaPath))
                            File.Delete(metaPath);
                        deleted++;
                    }
                    catch { }
                }
            }
        }, ct);

        _logger?.LogInformation("Cleaned up {Count} old backup(s)", deleted);
        return deleted;
    }

    public long GetTotalBackupSize()
    {
        return Directory.EnumerateFiles(_backupDirectory, $"*{BackupExtension}")
            .Sum(f => new FileInfo(f).Length);
    }

    private static string GetDefaultBackupDirectory()
    {
        var appData = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
        return Path.Combine(appData, "SeniorIntern", "backups");
    }

    private static string ComputePathHash(string path)
    {
        using var md5 = MD5.Create();
        var bytes = Encoding.UTF8.GetBytes(path.ToLowerInvariant());
        var hash = md5.ComputeHash(bytes);
        return Convert.ToHexString(hash)[..8];
    }

    private sealed class BackupMetadata
    {
        public string OriginalPath { get; set; } = string.Empty;
        public DateTime CreatedAt { get; set; }
        public long OriginalSize { get; set; }
    }
}
```

### Files to Create (v0.4.3c)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/IBackupService.cs` | Backup service interface |
| `src/SeniorIntern.Services/BackupService.cs` | Backup implementation |

### Acceptance Criteria (v0.4.3c)

- [ ] Backups created with unique names
- [ ] Metadata stored alongside backups
- [ ] Restore works correctly
- [ ] Cleanup removes old backups
- [ ] Backup size tracking works
- [ ] Hash-based file grouping works

---

## v0.4.3d: Undo System

### Objective
Implement a time-windowed undo system with UI integration.

### UndoManager

```csharp
// src/SeniorIntern.Services/UndoManager.cs
namespace SeniorIntern.Services;

/// <summary>
/// Manages undo operations with time-based expiration.
/// </summary>
public sealed class UndoManager : IDisposable
{
    private readonly IFileChangeService _changeService;
    private readonly ILogger<UndoManager>? _logger;
    private readonly TimeSpan _undoWindow;
    private readonly Timer _cleanupTimer;
    private readonly object _lock = new();

    public event EventHandler<UndoAvailableEventArgs>? UndoAvailable;
    public event EventHandler<UndoExpiredEventArgs>? UndoExpired;

    public UndoManager(
        IFileChangeService changeService,
        TimeSpan? undoWindow = null,
        ILogger<UndoManager>? logger = null)
    {
        _changeService = changeService;
        _undoWindow = undoWindow ?? TimeSpan.FromMinutes(30);
        _logger = logger;

        _changeService.FileChanged += OnFileChanged;

        // Check for expired undos every minute
        _cleanupTimer = new Timer(CheckExpiredUndos, null,
            TimeSpan.FromMinutes(1), TimeSpan.FromMinutes(1));
    }

    private void OnFileChanged(object? sender, FileChangedEventArgs e)
    {
        if (e.CanUndo)
        {
            UndoAvailable?.Invoke(this, new UndoAvailableEventArgs
            {
                FilePath = e.FilePath,
                RelativePath = e.RelativePath,
                ChangeType = e.ChangeType,
                ExpiresAt = DateTime.UtcNow + _undoWindow
            });
        }
    }

    private void CheckExpiredUndos(object? state)
    {
        var pending = _changeService.GetPendingUndos();
        foreach (var record in pending)
        {
            if (record.IsUndoExpired(_undoWindow))
            {
                UndoExpired?.Invoke(this, new UndoExpiredEventArgs
                {
                    FilePath = record.FilePath,
                    ChangeRecord = record
                });
            }
        }
    }

    public async Task<bool> UndoAsync(string filePath)
    {
        return await _changeService.UndoLastChangeAsync(filePath);
    }

    public TimeSpan GetTimeRemaining(string filePath)
    {
        var history = _changeService.GetChangeHistory(filePath, 1);
        if (history.Count == 0)
            return TimeSpan.Zero;

        return history[0].GetUndoTimeRemaining(_undoWindow);
    }

    public bool CanUndo(string filePath) => _changeService.CanUndo(filePath);

    public void Dispose()
    {
        _cleanupTimer.Dispose();
        _changeService.FileChanged -= OnFileChanged;
    }
}

public sealed class UndoAvailableEventArgs : EventArgs
{
    public required string FilePath { get; init; }
    public required string RelativePath { get; init; }
    public required FileChangeType ChangeType { get; init; }
    public required DateTime ExpiresAt { get; init; }
}

public sealed class UndoExpiredEventArgs : EventArgs
{
    public required string FilePath { get; init; }
    public required FileChangeRecord ChangeRecord { get; init; }
}
```

### Files to Create (v0.4.3d)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Services/UndoManager.cs` | Undo coordination |

### Acceptance Criteria (v0.4.3d)

- [ ] Undo available event raised after changes
- [ ] Undo expired event raised when window passes
- [ ] Time remaining calculated correctly
- [ ] Background cleanup runs periodically

---

## v0.4.3e: Conflict Detection

### Objective
Detect when a file has been modified between proposal generation and apply.

### ConflictDetector

```csharp
// src/SeniorIntern.Services/ConflictDetector.cs
namespace SeniorIntern.Services;

/// <summary>
/// Detects conflicts between proposed changes and current file state.
/// </summary>
public sealed class ConflictDetector
{
    private readonly IFileSystemService _fileSystem;
    private readonly ConcurrentDictionary<string, FileSnapshot> _snapshots = new();

    public ConflictDetector(IFileSystemService fileSystem)
    {
        _fileSystem = fileSystem;
    }

    /// <summary>
    /// Take a snapshot of a file for later conflict detection.
    /// </summary>
    public async Task TakeSnapshotAsync(string filePath, CancellationToken ct = default)
    {
        if (!await _fileSystem.FileExistsAsync(filePath, ct))
        {
            _snapshots[filePath] = new FileSnapshot
            {
                Path = filePath,
                Exists = false,
                TakenAt = DateTime.UtcNow
            };
            return;
        }

        var content = await _fileSystem.ReadFileAsync(filePath, ct);
        var fileInfo = new FileInfo(filePath);

        _snapshots[filePath] = new FileSnapshot
        {
            Path = filePath,
            Exists = true,
            ContentHash = ComputeHash(content),
            LastModified = fileInfo.LastWriteTimeUtc,
            Size = fileInfo.Length,
            TakenAt = DateTime.UtcNow
        };
    }

    /// <summary>
    /// Check if a file has changed since the snapshot.
    /// </summary>
    public async Task<ConflictInfo> CheckConflictAsync(
        string filePath,
        CancellationToken ct = default)
    {
        if (!_snapshots.TryGetValue(filePath, out var snapshot))
        {
            return new ConflictInfo
            {
                HasConflict = false,
                Reason = ConflictReason.NoSnapshot
            };
        }

        var exists = await _fileSystem.FileExistsAsync(filePath, ct);

        // File was created when we expected it not to exist
        if (!snapshot.Exists && exists)
        {
            return new ConflictInfo
            {
                HasConflict = true,
                Reason = ConflictReason.FileCreated,
                Message = "File was created after the proposal was generated"
            };
        }

        // File was deleted when we expected it to exist
        if (snapshot.Exists && !exists)
        {
            return new ConflictInfo
            {
                HasConflict = true,
                Reason = ConflictReason.FileDeleted,
                Message = "File was deleted after the proposal was generated"
            };
        }

        if (!exists)
        {
            return new ConflictInfo { HasConflict = false };
        }

        // Check content hash
        var content = await _fileSystem.ReadFileAsync(filePath, ct);
        var currentHash = ComputeHash(content);

        if (currentHash != snapshot.ContentHash)
        {
            var fileInfo = new FileInfo(filePath);
            return new ConflictInfo
            {
                HasConflict = true,
                Reason = ConflictReason.ContentModified,
                Message = "File content has been modified",
                LastModified = fileInfo.LastWriteTimeUtc,
                SnapshotTime = snapshot.TakenAt
            };
        }

        return new ConflictInfo { HasConflict = false };
    }

    /// <summary>
    /// Clear snapshot for a file.
    /// </summary>
    public void ClearSnapshot(string filePath)
    {
        _snapshots.TryRemove(filePath, out _);
    }

    /// <summary>
    /// Clear all snapshots.
    /// </summary>
    public void ClearAllSnapshots()
    {
        _snapshots.Clear();
    }

    private static string ComputeHash(string content)
    {
        using var sha256 = SHA256.Create();
        var bytes = Encoding.UTF8.GetBytes(content);
        var hash = sha256.ComputeHash(bytes);
        return Convert.ToBase64String(hash);
    }

    private sealed class FileSnapshot
    {
        public string Path { get; init; } = string.Empty;
        public bool Exists { get; init; }
        public string? ContentHash { get; init; }
        public DateTime LastModified { get; init; }
        public long Size { get; init; }
        public DateTime TakenAt { get; init; }
    }
}

public sealed class ConflictInfo
{
    public bool HasConflict { get; init; }
    public ConflictReason Reason { get; init; }
    public string? Message { get; init; }
    public DateTime? LastModified { get; init; }
    public DateTime? SnapshotTime { get; init; }
}

public enum ConflictReason
{
    None,
    NoSnapshot,
    FileCreated,
    FileDeleted,
    ContentModified,
    PermissionChanged
}
```

### Files to Create (v0.4.3e)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Services/ConflictDetector.cs` | Conflict detection |

### Acceptance Criteria (v0.4.3e)

- [ ] Snapshots capture file state
- [ ] Content changes detected via hash
- [ ] File creation detected
- [ ] File deletion detected
- [ ] Conflict reasons are specific

---

## v0.4.3f: Apply Dialog

### Objective
Create the confirmation dialog that shows a diff preview before applying changes.

### ApplyChangesDialogViewModel

```csharp
// src/SeniorIntern.Desktop/ViewModels/ApplyChangesDialogViewModel.cs
namespace SeniorIntern.Desktop.ViewModels;

public partial class ApplyChangesDialogViewModel : ViewModelBase
{
    private readonly IFileChangeService _changeService;
    private readonly Window _dialog;

    [ObservableProperty]
    private DiffViewerViewModel _diffViewModel;

    [ObservableProperty]
    private CodeBlock _codeBlock;

    [ObservableProperty]
    private string _fileName = string.Empty;

    [ObservableProperty]
    private string _filePath = string.Empty;

    [ObservableProperty]
    private bool _isNewFile;

    [ObservableProperty]
    private bool _createBackup = true;

    [ObservableProperty]
    private bool _isApplying;

    [ObservableProperty]
    private string? _errorMessage;

    [ObservableProperty]
    private ApplyResult? _result;

    public ApplyChangesDialogViewModel(
        IFileChangeService changeService,
        IDiffService diffService,
        IInlineDiffService inlineDiffService,
        CodeBlock codeBlock,
        DiffResult diff,
        Window dialog)
    {
        _changeService = changeService;
        _dialog = dialog;
        _codeBlock = codeBlock;

        FileName = Path.GetFileName(codeBlock.TargetFilePath ?? "Unknown");
        FilePath = codeBlock.TargetFilePath ?? string.Empty;
        IsNewFile = diff.IsNewFile;

        DiffViewModel = new DiffViewerViewModel(diffService, inlineDiffService);
        DiffViewModel.LoadDiff(diff);
    }

    [RelayCommand]
    private async Task ApplyAsync()
    {
        if (IsApplying) return;

        try
        {
            IsApplying = true;
            ErrorMessage = null;

            var options = new ApplyOptions
            {
                CreateBackup = CreateBackup,
                ShowConfirmationDialog = false // Already in dialog
            };

            Result = await _changeService.ApplyCodeBlockAsync(
                CodeBlock,
                GetWorkspacePath(),
                options);

            if (Result.Success)
            {
                _dialog.Close(Result);
            }
            else
            {
                ErrorMessage = Result.ErrorMessage ?? "Failed to apply changes";
            }
        }
        catch (Exception ex)
        {
            ErrorMessage = ex.Message;
        }
        finally
        {
            IsApplying = false;
        }
    }

    [RelayCommand]
    private void Cancel()
    {
        _dialog.Close(null);
    }

    private string GetWorkspacePath()
    {
        // Get from workspace service
        return Environment.CurrentDirectory; // Placeholder
    }
}
```

### ApplyChangesDialog.axaml

```xml
<!-- src/SeniorIntern.Desktop/Views/ApplyChangesDialog.axaml -->
<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:vm="using:SeniorIntern.Desktop.ViewModels"
        xmlns:views="using:SeniorIntern.Desktop.Views"
        x:Class="SeniorIntern.Desktop.Views.ApplyChangesDialog"
        x:DataType="vm:ApplyChangesDialogViewModel"
        Title="Apply Changes"
        Width="900" Height="650"
        MinWidth="600" MinHeight="400"
        WindowStartupLocation="CenterOwner"
        CanResize="True">

    <Grid RowDefinitions="*, Auto">
        <!-- Diff Preview -->
        <views:DiffViewerPanel Grid.Row="0"
                               DataContext="{Binding DiffViewModel}" />

        <!-- Footer -->
        <Border Grid.Row="1"
                Background="{DynamicResource SurfaceBackground}"
                BorderBrush="{DynamicResource BorderBrush}"
                BorderThickness="0,1,0,0"
                Padding="16,12">
            <Grid ColumnDefinitions="Auto, *, Auto">
                <!-- Options -->
                <StackPanel Orientation="Horizontal" Spacing="16">
                    <CheckBox Content="Create backup"
                              IsChecked="{Binding CreateBackup}"
                              ToolTip.Tip="Save a backup before modifying the file" />
                    <Border Classes="info-badge"
                            IsVisible="{Binding IsNewFile}"
                            Padding="8,4"
                            CornerRadius="4"
                            Background="{DynamicResource DiffAddedBackgroundBrush}">
                        <TextBlock Text="New file will be created"
                                   FontSize="12"
                                   Foreground="{DynamicResource DiffAddedForegroundBrush}" />
                    </Border>
                </StackPanel>

                <!-- Error Message -->
                <TextBlock Grid.Column="1"
                           Text="{Binding ErrorMessage}"
                           Foreground="{DynamicResource ErrorForeground}"
                           IsVisible="{Binding ErrorMessage, Converter={x:Static StringConverters.IsNotNullOrEmpty}}"
                           TextWrapping="Wrap"
                           Margin="16,0"
                           VerticalAlignment="Center" />

                <!-- Actions -->
                <StackPanel Grid.Column="2"
                            Orientation="Horizontal"
                            Spacing="8">
                    <Button Content="Cancel"
                            Command="{Binding CancelCommand}"
                            IsEnabled="{Binding !IsApplying}"
                            HotKey="Escape" />
                    <Button Content="Apply Changes"
                            Command="{Binding ApplyCommand}"
                            Classes="accent"
                            IsEnabled="{Binding !IsApplying}"
                            HotKey="Enter">
                        <Button.Content>
                            <StackPanel Orientation="Horizontal" Spacing="8">
                                <ProgressBar IsVisible="{Binding IsApplying}"
                                             IsIndeterminate="True"
                                             Width="16" Height="16" />
                                <TextBlock Text="{Binding IsApplying,
                                    Converter={StaticResource BoolToStringConverter},
                                    ConverterParameter='Applying...|Apply Changes'}" />
                            </StackPanel>
                        </Button.Content>
                    </Button>
                </StackPanel>
            </Grid>
        </Border>
    </Grid>
</Window>
```

### ApplyChangesDialog.axaml.cs

```csharp
// src/SeniorIntern.Desktop/Views/ApplyChangesDialog.axaml.cs
namespace SeniorIntern.Desktop.Views;

public partial class ApplyChangesDialog : Window
{
    public ApplyChangesDialog()
    {
        InitializeComponent();
    }

    public static async Task<ApplyResult?> ShowAsync(
        Window parent,
        CodeBlock codeBlock,
        DiffResult diff,
        IFileChangeService changeService,
        IDiffService diffService,
        IInlineDiffService inlineDiffService)
    {
        var dialog = new ApplyChangesDialog();
        dialog.DataContext = new ApplyChangesDialogViewModel(
            changeService,
            diffService,
            inlineDiffService,
            codeBlock,
            diff,
            dialog);

        return await dialog.ShowDialog<ApplyResult?>(parent);
    }
}
```

### Files to Create (v0.4.3f)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/ViewModels/ApplyChangesDialogViewModel.cs` | Dialog ViewModel |
| `src/SeniorIntern.Desktop/Views/ApplyChangesDialog.axaml` | Dialog UI |
| `src/SeniorIntern.Desktop/Views/ApplyChangesDialog.axaml.cs` | Dialog code-behind |

### Acceptance Criteria (v0.4.3f)

- [ ] Dialog shows diff preview
- [ ] Backup checkbox toggles option
- [ ] Apply button triggers operation
- [ ] Cancel closes without changes
- [ ] Error messages displayed
- [ ] Loading state shown during apply

---

## v0.4.3g: Conflict Dialog

### Objective
Create a dialog for resolving file conflicts.

### ConflictWarningDialogViewModel

```csharp
// src/SeniorIntern.Desktop/ViewModels/ConflictWarningDialogViewModel.cs
namespace SeniorIntern.Desktop.ViewModels;

public partial class ConflictWarningDialogViewModel : ViewModelBase
{
    private readonly Window _dialog;

    [ObservableProperty]
    private string _filePath = string.Empty;

    [ObservableProperty]
    private string _fileName = string.Empty;

    [ObservableProperty]
    private string _conflictMessage = string.Empty;

    [ObservableProperty]
    private DateTime _lastModified;

    [ObservableProperty]
    private ConflictResolution _selectedResolution = ConflictResolution.Cancel;

    public ConflictWarningDialogViewModel(
        ConflictInfo conflict,
        string filePath,
        Window dialog)
    {
        _dialog = dialog;
        FilePath = filePath;
        FileName = Path.GetFileName(filePath);
        ConflictMessage = conflict.Message ?? "File has been modified";
        LastModified = conflict.LastModified ?? DateTime.UtcNow;
    }

    [RelayCommand]
    private void RefreshDiff()
    {
        SelectedResolution = ConflictResolution.RefreshDiff;
        _dialog.Close(SelectedResolution);
    }

    [RelayCommand]
    private void ForceApply()
    {
        SelectedResolution = ConflictResolution.ForceApply;
        _dialog.Close(SelectedResolution);
    }

    [RelayCommand]
    private void Cancel()
    {
        SelectedResolution = ConflictResolution.Cancel;
        _dialog.Close(SelectedResolution);
    }
}

public enum ConflictResolution
{
    Cancel,
    RefreshDiff,
    ForceApply
}
```

### ConflictWarningDialog.axaml

```xml
<!-- src/SeniorIntern.Desktop/Views/ConflictWarningDialog.axaml -->
<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:vm="using:SeniorIntern.Desktop.ViewModels"
        x:Class="SeniorIntern.Desktop.Views.ConflictWarningDialog"
        x:DataType="vm:ConflictWarningDialogViewModel"
        Title="File Conflict Detected"
        Width="500" Height="300"
        WindowStartupLocation="CenterOwner"
        CanResize="False">

    <Grid RowDefinitions="Auto, *, Auto" Margin="24">
        <!-- Header -->
        <StackPanel Grid.Row="0" Spacing="16" HorizontalAlignment="Center">
            <PathIcon Data="{StaticResource WarningIcon}"
                      Width="48" Height="48"
                      Foreground="{DynamicResource WarningForeground}"
                      HorizontalAlignment="Center" />
            <TextBlock Text="File Conflict Detected"
                       FontSize="18"
                       FontWeight="SemiBold"
                       HorizontalAlignment="Center" />
        </StackPanel>

        <!-- Content -->
        <StackPanel Grid.Row="1" Spacing="12" Margin="0,24">
            <TextBlock Text="{Binding ConflictMessage}"
                       TextWrapping="Wrap"
                       TextAlignment="Center" />

            <Border Background="{DynamicResource SurfaceBackground}"
                    CornerRadius="4"
                    Padding="12"
                    Margin="0,8">
                <StackPanel Spacing="4">
                    <TextBlock Text="File:"
                               FontWeight="SemiBold"
                               Foreground="{DynamicResource TextMuted}" />
                    <TextBlock Text="{Binding FilePath}"
                               FontFamily="Cascadia Code, Consolas, monospace"
                               FontSize="12"
                               TextTrimming="CharacterEllipsis" />
                    <TextBlock Margin="0,8,0,0">
                        <TextBlock.Text>
                            <MultiBinding StringFormat="Last modified: {0:g}">
                                <Binding Path="LastModified" />
                            </MultiBinding>
                        </TextBlock.Text>
                    </TextBlock>
                </StackPanel>
            </Border>
        </StackPanel>

        <!-- Actions -->
        <StackPanel Grid.Row="2"
                    Orientation="Horizontal"
                    HorizontalAlignment="Center"
                    Spacing="12">
            <Button Content="Refresh Diff"
                    Command="{Binding RefreshDiffCommand}"
                    ToolTip.Tip="Recompute diff against current file content">
                <Button.Styles>
                    <Style Selector="Button">
                        <Setter Property="MinWidth" Value="100" />
                    </Style>
                </Button.Styles>
            </Button>
            <Button Content="Force Apply"
                    Command="{Binding ForceApplyCommand}"
                    Classes="warning"
                    ToolTip.Tip="Overwrite with proposed changes (may lose recent edits)" />
            <Button Content="Cancel"
                    Command="{Binding CancelCommand}" />
        </StackPanel>
    </Grid>
</Window>
```

### Files to Create (v0.4.3g)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/ViewModels/ConflictWarningDialogViewModel.cs` | Conflict dialog VM |
| `src/SeniorIntern.Desktop/Views/ConflictWarningDialog.axaml` | Conflict dialog UI |
| `src/SeniorIntern.Desktop/Views/ConflictWarningDialog.axaml.cs` | Dialog code-behind |

### Acceptance Criteria (v0.4.3g)

- [ ] Warning icon and message displayed
- [ ] File path and last modified shown
- [ ] Refresh Diff option works
- [ ] Force Apply option works
- [ ] Cancel closes dialog

---

## v0.4.3h: Undo Toast

### Objective
Show a temporary notification after applying changes with an undo option.

### UndoToastViewModel

```csharp
// src/SeniorIntern.Desktop/ViewModels/UndoToastViewModel.cs
namespace SeniorIntern.Desktop.ViewModels;

public partial class UndoToastViewModel : ViewModelBase
{
    private readonly UndoManager _undoManager;
    private CancellationTokenSource? _autoHideCts;
    private const int AutoHideDelayMs = 10000;

    [ObservableProperty]
    private bool _isVisible;

    [ObservableProperty]
    private string _message = string.Empty;

    [ObservableProperty]
    private string _filePath = string.Empty;

    [ObservableProperty]
    private string _fileName = string.Empty;

    [ObservableProperty]
    private TimeSpan _timeRemaining;

    [ObservableProperty]
    private bool _isUndoing;

    public UndoToastViewModel(UndoManager undoManager)
    {
        _undoManager = undoManager;
        _undoManager.UndoAvailable += OnUndoAvailable;
    }

    private void OnUndoAvailable(object? sender, UndoAvailableEventArgs e)
    {
        Dispatcher.UIThread.Post(() =>
        {
            FilePath = e.FilePath;
            FileName = Path.GetFileName(e.FilePath);
            Message = e.ChangeType switch
            {
                FileChangeType.Created => $"Created {FileName}",
                FileChangeType.Modified => $"Modified {FileName}",
                _ => $"Changed {FileName}"
            };
            TimeRemaining = e.ExpiresAt - DateTime.UtcNow;

            Show();
        });
    }

    public void Show()
    {
        _autoHideCts?.Cancel();
        _autoHideCts = new CancellationTokenSource();

        IsVisible = true;
        StartAutoHide(_autoHideCts.Token);
        StartTimeRemainingUpdates(_autoHideCts.Token);
    }

    private async void StartAutoHide(CancellationToken ct)
    {
        try
        {
            await Task.Delay(AutoHideDelayMs, ct);
            Hide();
        }
        catch (OperationCanceledException) { }
    }

    private async void StartTimeRemainingUpdates(CancellationToken ct)
    {
        try
        {
            while (!ct.IsCancellationRequested && IsVisible)
            {
                TimeRemaining = _undoManager.GetTimeRemaining(FilePath);
                await Task.Delay(1000, ct);
            }
        }
        catch (OperationCanceledException) { }
    }

    [RelayCommand]
    private async Task UndoAsync()
    {
        if (IsUndoing || string.IsNullOrEmpty(FilePath))
            return;

        try
        {
            IsUndoing = true;
            var success = await _undoManager.UndoAsync(FilePath);

            if (success)
            {
                Message = $"Undone changes to {FileName}";
                await Task.Delay(2000);
            }

            Hide();
        }
        finally
        {
            IsUndoing = false;
        }
    }

    [RelayCommand]
    private void Dismiss()
    {
        Hide();
    }

    private void Hide()
    {
        _autoHideCts?.Cancel();
        IsVisible = false;
    }
}
```

### UndoToast.axaml

```xml
<!-- src/SeniorIntern.Desktop/Controls/UndoToast.axaml -->
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:vm="using:SeniorIntern.Desktop.ViewModels"
             x:Class="SeniorIntern.Desktop.Controls.UndoToast"
             x:DataType="vm:UndoToastViewModel"
             IsVisible="{Binding IsVisible}">

    <Border Classes="undo-toast"
            Background="{DynamicResource ToastBackground}"
            BorderBrush="{DynamicResource ToastBorder}"
            BorderThickness="1"
            CornerRadius="8"
            Padding="16,12"
            Margin="0,0,0,20"
            BoxShadow="0 4 16 0 #40000000">
        <Grid ColumnDefinitions="Auto, *, Auto, Auto, Auto">
            <!-- Icon -->
            <PathIcon Grid.Column="0"
                      Data="{StaticResource CheckCircleIcon}"
                      Width="20" Height="20"
                      Foreground="{DynamicResource SuccessForeground}"
                      Margin="0,0,12,0" />

            <!-- Message -->
            <TextBlock Grid.Column="1"
                       Text="{Binding Message}"
                       VerticalAlignment="Center"
                       Foreground="{DynamicResource ToastForeground}" />

            <!-- Time Remaining -->
            <TextBlock Grid.Column="2"
                       VerticalAlignment="Center"
                       Foreground="{DynamicResource TextMuted}"
                       FontSize="12"
                       Margin="16,0">
                <TextBlock.Text>
                    <MultiBinding StringFormat="Undo available for {0:mm\\:ss}">
                        <Binding Path="TimeRemaining" />
                    </MultiBinding>
                </TextBlock.Text>
            </TextBlock>

            <!-- Undo Button -->
            <Button Grid.Column="3"
                    Content="Undo"
                    Command="{Binding UndoCommand}"
                    IsEnabled="{Binding !IsUndoing}"
                    Classes="link-button"
                    Foreground="{DynamicResource AccentBrush}"
                    Margin="0,0,8,0" />

            <!-- Dismiss Button -->
            <Button Grid.Column="4"
                    Command="{Binding DismissCommand}"
                    Classes="icon-button"
                    ToolTip.Tip="Dismiss">
                <PathIcon Data="{StaticResource CloseIcon}"
                          Width="12" Height="12" />
            </Button>
        </Grid>
    </Border>
</UserControl>
```

### Toast Styles

```xml
<!-- Add to Dark.axaml -->
<Color x:Key="ToastBackground">#2D2D2D</Color>
<Color x:Key="ToastBorder">#404040</Color>
<Color x:Key="ToastForeground">#E0E0E0</Color>

<SolidColorBrush x:Key="ToastBackgroundBrush" Color="{StaticResource ToastBackground}" />
<SolidColorBrush x:Key="ToastBorderBrush" Color="{StaticResource ToastBorder}" />
<SolidColorBrush x:Key="ToastForegroundBrush" Color="{StaticResource ToastForeground}" />

<Style Selector="Border.undo-toast">
    <Setter Property="Transitions">
        <Transitions>
            <DoubleTransition Property="Opacity" Duration="0:0:0.2" />
            <TransformOperationsTransition Property="RenderTransform" Duration="0:0:0.2" />
        </Transitions>
    </Setter>
</Style>
```

### Files to Create (v0.4.3h)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/ViewModels/UndoToastViewModel.cs` | Toast ViewModel |
| `src/SeniorIntern.Desktop/Controls/UndoToast.axaml` | Toast UI |
| `src/SeniorIntern.Desktop/Controls/UndoToast.axaml.cs` | Toast code-behind |

### Files to Modify (v0.4.3h)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/Views/MainWindow.axaml` | Add toast overlay |
| `src/SeniorIntern.Desktop/Themes/Dark.axaml` | Add toast styles |

### Acceptance Criteria (v0.4.3h)

- [ ] Toast appears after applying changes
- [ ] Message shows file name and action
- [ ] Time remaining updates live
- [ ] Undo button triggers undo
- [ ] Dismiss button hides toast
- [ ] Auto-hide after 10 seconds

---

## v0.4.3i: Editor Integration

### Objective
Refresh the editor when files are changed and handle open file conflicts.

### EditorRefreshService

```csharp
// src/SeniorIntern.Services/EditorRefreshService.cs
namespace SeniorIntern.Services;

/// <summary>
/// Coordinates editor refresh when files change.
/// </summary>
public sealed class EditorRefreshService : IDisposable
{
    private readonly IFileChangeService _changeService;
    private readonly ILogger<EditorRefreshService>? _logger;

    public event EventHandler<EditorRefreshEventArgs>? RefreshRequested;

    public EditorRefreshService(
        IFileChangeService changeService,
        ILogger<EditorRefreshService>? logger = null)
    {
        _changeService = changeService;
        _logger = logger;

        _changeService.FileChanged += OnFileChanged;
        _changeService.ChangeUndone += OnChangeUndone;
    }

    private void OnFileChanged(object? sender, FileChangedEventArgs e)
    {
        _logger?.LogDebug("File changed, requesting editor refresh: {FilePath}", e.FilePath);

        RefreshRequested?.Invoke(this, new EditorRefreshEventArgs
        {
            FilePath = e.FilePath,
            RelativePath = e.RelativePath,
            Reason = RefreshReason.FileModified
        });
    }

    private void OnChangeUndone(object? sender, FileChangeUndoneEventArgs e)
    {
        _logger?.LogDebug("Change undone, requesting editor refresh: {FilePath}", e.FilePath);

        RefreshRequested?.Invoke(this, new EditorRefreshEventArgs
        {
            FilePath = e.FilePath,
            RelativePath = e.OriginalChange.RelativePath,
            Reason = RefreshReason.Undone
        });
    }

    public void Dispose()
    {
        _changeService.FileChanged -= OnFileChanged;
        _changeService.ChangeUndone -= OnChangeUndone;
    }
}

public sealed class EditorRefreshEventArgs : EventArgs
{
    public required string FilePath { get; init; }
    public required string RelativePath { get; init; }
    public required RefreshReason Reason { get; init; }
}

public enum RefreshReason
{
    FileModified,
    Undone,
    ExternalChange
}
```

### Update EditorPanelViewModel

```csharp
// Add to EditorPanelViewModel.cs

private readonly EditorRefreshService _refreshService;

public EditorPanelViewModel(
    /* existing params */,
    EditorRefreshService refreshService)
{
    // existing init...
    _refreshService = refreshService;
    _refreshService.RefreshRequested += OnRefreshRequested;
}

private void OnRefreshRequested(object? sender, EditorRefreshEventArgs e)
{
    // Check if the changed file is currently open in a tab
    var tab = Tabs.FirstOrDefault(t => t.FilePath == e.FilePath);
    if (tab != null)
    {
        Dispatcher.UIThread.Post(async () =>
        {
            await RefreshTabContentAsync(tab);
        });
    }
}

private async Task RefreshTabContentAsync(EditorTabViewModel tab)
{
    try
    {
        var content = await _fileSystem.ReadFileAsync(tab.FilePath);
        tab.SetContent(content, fromDisk: true);
        tab.IsDirty = false;
    }
    catch (Exception ex)
    {
        _logger?.LogError(ex, "Failed to refresh tab: {FilePath}", tab.FilePath);
    }
}
```

### Files to Create (v0.4.3i)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Services/EditorRefreshService.cs` | Editor refresh coordination |

### Files to Modify (v0.4.3i)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/ViewModels/EditorPanelViewModel.cs` | Handle refresh events |

### Acceptance Criteria (v0.4.3i)

- [ ] Editor refreshes when file is modified externally
- [ ] Editor refreshes after undo
- [ ] Only open tabs are refreshed
- [ ] Dirty state handled correctly

---

## Architecture Summary

### Component Diagram

```

                         UI Layer                                 

        
   ApplyChanges      ConflictWarning      UndoToast       
      Dialog            Dialog                            
        
                                                              
                      
                                                                 
                                                                 
     
                   CodeBlockViewModel                           
     [Apply Button]  Shows Dialog  Triggers Apply        
     

                              
                              

                      Services Layer                              

           
   FileChangeService        UndoManager               
   - ApplyCodeBlock()        - Time-windowed undo           
   - UndoLastChange()        - Expiration tracking          
           
                                                                 
                                                                 
           
     BackupService              ConflictDetector            
   - CreateBackup()          - TakeSnapshot()               
   - RestoreBackup()         - CheckConflict()              
           
                                                                  
     
                 EditorRefreshService                           
   - Listens to FileChanged events                             
   - Notifies editor to refresh open tabs                      
     

```

### Apply Workflow Sequence

```
1. User clicks "Apply" on CodeBlock
              
              
2. ApplyChangesDialog.ShowAsync()
              
               DiffViewerPanel shows preview
              
               User reviews changes
                        
                        
3. User clicks "Apply Changes"
              
              
4. FileChangeService.ApplyCodeBlockAsync()
              
               ConflictDetector.CheckConflictAsync()
                       
                        No conflict: Continue
                       
                        Conflict: Show ConflictWarningDialog
                                 
                                  Refresh: Recompute diff
                                  Force: Continue with overwrite
                                  Cancel: Abort
              
               BackupService.CreateBackupAsync()
              
               FileSystem.WriteFileAsync()
              
               RecordChange() for undo
                        
                        
5. FileChanged event raised
              
               UndoManager shows UndoToast
              
               EditorRefreshService refreshes open tabs
```

---

## Files Summary

### Files to Create (Total: 17)

| File | Sub-Part |
|------|----------|
| `src/SeniorIntern.Core/Models/ApplyOptions.cs` | v0.4.3a |
| `src/SeniorIntern.Core/Models/ApplyResult.cs` | v0.4.3a |
| `src/SeniorIntern.Core/Models/FileChangeRecord.cs` | v0.4.3a |
| `src/SeniorIntern.Core/Events/ApplyEvents.cs` | v0.4.3a |
| `src/SeniorIntern.Core/Interfaces/IFileChangeService.cs` | v0.4.3b |
| `src/SeniorIntern.Services/FileChangeService.cs` | v0.4.3b |
| `src/SeniorIntern.Core/Interfaces/IBackupService.cs` | v0.4.3c |
| `src/SeniorIntern.Services/BackupService.cs` | v0.4.3c |
| `src/SeniorIntern.Services/UndoManager.cs` | v0.4.3d |
| `src/SeniorIntern.Services/ConflictDetector.cs` | v0.4.3e |
| `src/SeniorIntern.Desktop/ViewModels/ApplyChangesDialogViewModel.cs` | v0.4.3f |
| `src/SeniorIntern.Desktop/Views/ApplyChangesDialog.axaml` | v0.4.3f |
| `src/SeniorIntern.Desktop/Views/ApplyChangesDialog.axaml.cs` | v0.4.3f |
| `src/SeniorIntern.Desktop/ViewModels/ConflictWarningDialogViewModel.cs` | v0.4.3g |
| `src/SeniorIntern.Desktop/Views/ConflictWarningDialog.axaml` | v0.4.3g |
| `src/SeniorIntern.Desktop/Views/ConflictWarningDialog.axaml.cs` | v0.4.3g |
| `src/SeniorIntern.Desktop/ViewModels/UndoToastViewModel.cs` | v0.4.3h |
| `src/SeniorIntern.Desktop/Controls/UndoToast.axaml` | v0.4.3h |
| `src/SeniorIntern.Desktop/Controls/UndoToast.axaml.cs` | v0.4.3h |
| `src/SeniorIntern.Services/EditorRefreshService.cs` | v0.4.3i |

### Files to Modify (Total: 5)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/Extensions/ServiceCollectionExtensions.cs` | Register all new services |
| `src/SeniorIntern.Desktop/Views/MainWindow.axaml` | Add undo toast overlay |
| `src/SeniorIntern.Desktop/Themes/Dark.axaml` | Add toast and warning styles |
| `src/SeniorIntern.Desktop/ViewModels/EditorPanelViewModel.cs` | Handle refresh events |
| `src/SeniorIntern.Desktop/App.axaml` | Add new icons |

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Backup disk space exhaustion | Low | Medium | Automatic cleanup, size limits |
| Race condition in concurrent applies | Medium | High | Semaphore locks, queuing |
| Undo after file external modification | Medium | Medium | Hash verification before restore |
| Dialog blocks main thread | Low | Medium | Async operations throughout |
| Backup restore fails | Low | High | Verify backup before delete |

---

## References

- [v0.4.0 Code Generation & Diffing](v0.4.0-code-generation-diffing.md) - Parent specification
- [v0.4.1 Code Block Extraction](v0.4.1-code-block-extraction.md) - CodeBlock model
- [v0.4.2 Diff Engine](v0.4.2-diff-engine.md) - DiffResult and diff computation
