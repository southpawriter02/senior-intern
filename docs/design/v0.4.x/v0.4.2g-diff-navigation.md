# v0.4.2g: Diff Navigation - Design Specification

**Status**: _IMPLEMENTED_

## Executive Summary

This specification details the **Diff Navigation** system for The Senior Intern's diff viewer, enabling keyboard-driven navigation between hunks and providing essential shortcuts for common diff operations. The implementation creates a `DiffNavigationService` for tracking navigation state and integrates keyboard handling into the `DiffViewerPanel`.

### Key Deliverables

| Component | Type | Purpose |
|-----------|------|---------|
| `DiffNavigationService` | Service | Track current hunk index and provide navigation methods |
| Keyboard Handler | Code-behind | Process keyboard shortcuts in DiffViewerPanel |
| Navigation Commands | ViewModel | Expose navigation actions as commands |
| Focus Management | Behavior | Ensure keyboard events reach the diff viewer |

---

## Feature Overview

```
v0.4.2g: Diff Navigation
├── DiffNavigationService
│   ├── State Management
│   │   ├── CurrentIndex property
│   │   ├── TotalHunks property
│   │   └── CurrentHunk property
│   ├── Navigation Methods
│   │   ├── SetHunks() - Initialize with hunk collection
│   │   ├── MoveNext() - Navigate to next hunk
│   │   ├── MovePrevious() - Navigate to previous hunk
│   │   └── MoveTo() - Jump to specific hunk
│   └── Query Methods
│       └── FindHunkContainingLine() - Locate hunk by line number
├── Keyboard Shortcuts
│   ├── Ctrl+↑ - Previous hunk
│   ├── Ctrl+↓ - Next hunk
│   ├── Escape - Close/reject diff
│   ├── Ctrl+Enter - Apply changes
│   ├── Ctrl+C - Copy proposed content
│   ├── Ctrl+I - Toggle inline changes
│   └── Ctrl+W - Toggle word wrap
├── Keyboard Handler
│   ├── OnKeyDown override
│   ├── Modifier key detection
│   └── Event routing to ViewModel commands
└── Focus Management
    ├── Focusable property
    ├── Initial focus acquisition
    └── Focus retention during interactions
```

---

## Architecture Diagrams

### Keyboard Event Flow

```
┌─────────────────────────────────────────────────────────────────────┐
│                        User Keyboard Input                          │
└─────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│                      DiffViewerPanel                                │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                   OnKeyDown(KeyEventArgs)                    │   │
│  │  ┌─────────────────────────────────────────────────────────┐│   │
│  │  │  Check KeyModifiers                                     ││   │
│  │  │  ├── Control pressed?                                   ││   │
│  │  │  │   ├── Key.Up → PreviousHunkCommand                  ││   │
│  │  │  │   ├── Key.Down → NextHunkCommand                    ││   │
│  │  │  │   ├── Key.Enter → RequestApplyCommand               ││   │
│  │  │  │   ├── Key.C → CopyProposedCommand                   ││   │
│  │  │  │   ├── Key.I → ToggleInlineChangesCommand            ││   │
│  │  │  │   └── Key.W → ToggleWordWrapCommand                 ││   │
│  │  │  └── Key.Escape → RequestRejectCommand                  ││   │
│  │  └─────────────────────────────────────────────────────────┘│   │
│  └─────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│                     DiffViewerViewModel                             │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │  Navigation Commands                                         │   │
│  │  ├── PreviousHunkCommand → _navigationService.MovePrevious()│   │
│  │  ├── NextHunkCommand → _navigationService.MoveNext()        │   │
│  │  └── ScrollToCurrentHunk()                                   │   │
│  └─────────────────────────────────────────────────────────────────┘│
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │  Action Commands                                             │   │
│  │  ├── RequestApplyCommand → Raise ApplyRequested event       │   │
│  │  ├── RequestRejectCommand → Raise RejectRequested event     │   │
│  │  ├── CopyProposedCommand → Copy to clipboard                │   │
│  │  ├── ToggleInlineChangesCommand → Toggle ShowInlineChanges  │   │
│  │  └── ToggleWordWrapCommand → Toggle WordWrap                │   │
│  └─────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│                    DiffNavigationService                            │
│  ┌───────────────────┐  ┌───────────────────────────────────────┐  │
│  │  State            │  │  Methods                               │  │
│  │  ├── _hunks[]     │  │  ├── SetHunks(hunks)                  │  │
│  │  ├── _currentIndex│  │  ├── MoveNext() → bool                │  │
│  │  ├── CurrentIndex │  │  ├── MovePrevious() → bool            │  │
│  │  ├── TotalHunks   │  │  ├── MoveTo(index) → bool             │  │
│  │  └── CurrentHunk  │  │  └── FindHunkContainingLine() → int   │  │
│  └───────────────────┘  └───────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────┘
```

### Navigation State Machine

```
┌─────────────────────────────────────────────────────────────────────┐
│                     Navigation State Machine                        │
└─────────────────────────────────────────────────────────────────────┘

    SetHunks([])              SetHunks([h0, h1, h2, ...])
         │                              │
         ▼                              ▼
    ┌─────────┐                  ┌─────────────┐
    │  Empty  │                  │  Index = 0  │◄────────────────┐
    │ Index=-1│                  │  (First)    │                 │
    └─────────┘                  └─────────────┘                 │
                                   │       │                     │
                        MoveNext() │       │ MovePrevious()      │
                                   ▼       │ (no change)         │
                              ┌─────────────┐                    │
                              │  Index = 1  │                    │
                              │  (Middle)   │◄───────────────┐   │
                              └─────────────┘                │   │
                                 │       │                   │   │
                      MoveNext() │       │ MovePrevious()    │   │
                                 ▼       ▼                   │   │
                              ┌─────────────┐                │   │
                              │  Index = 2  │────────────────┘   │
                              │  (Middle)   │                    │
                              └─────────────┘                    │
                                 │       │                       │
                      MoveNext() │       │ MovePrevious()        │
                                 ▼       │                       │
                              ┌─────────────┐                    │
                              │  Index = N  │────────────────────┘
                              │  (Last)     │
                              └─────────────┘
                                     │
                          MoveNext() │ (no change)
                                     ▼
                              [stays at N]

Legend:
─── State transition
◄── Return transition
```

### Component Integration

```
┌─────────────────────────────────────────────────────────────────────┐
│                         MainWindow                                  │
│  ┌───────────────────────────────────────────────────────────────┐ │
│  │                      DiffViewerPanel                          │ │
│  │  Focusable="True"                                             │ │
│  │  ┌─────────────────────────────────────────────────────────┐ │ │
│  │  │  Header: Navigation Status                              │ │ │
│  │  │  "Hunk 2 of 5" ← CurrentIndex + 1 / TotalHunks         │ │ │
│  │  └─────────────────────────────────────────────────────────┘ │ │
│  │  ┌─────────────────────────────────────────────────────────┐ │ │
│  │  │  Content: Side-by-Side Panels                           │ │ │
│  │  │  ┌─────────────────┐    ┌─────────────────┐            │ │ │
│  │  │  │  Original       │    │  Proposed       │            │ │ │
│  │  │  │  ScrollViewer   │    │  ScrollViewer   │            │ │ │
│  │  │  │  ┌───────────┐  │    │  ┌───────────┐  │            │ │ │
│  │  │  │  │ Hunk 0    │  │    │  │ Hunk 0    │  │            │ │ │
│  │  │  │  ├───────────┤  │    │  ├───────────┤  │            │ │ │
│  │  │  │  │ Hunk 1    │  │    │  │ Hunk 1    │  │            │ │ │
│  │  │  │  ├───────────┤  │    │  ├───────────┤  │            │ │ │
│  │  │  │  │►Hunk 2◄   │←─┼────┼──│►Hunk 2◄   │  │ ← Current  │ │ │
│  │  │  │  │ (current) │  │    │  │ (current) │  │            │ │ │
│  │  │  │  ├───────────┤  │    │  ├───────────┤  │            │ │ │
│  │  │  │  │ Hunk 3    │  │    │  │ Hunk 3    │  │            │ │ │
│  │  │  │  └───────────┘  │    │  └───────────┘  │            │ │ │
│  │  │  └─────────────────┘    └─────────────────┘            │ │ │
│  │  └─────────────────────────────────────────────────────────┘ │ │
│  │  ┌─────────────────────────────────────────────────────────┐ │ │
│  │  │  Footer: Keyboard Hints                                 │ │ │
│  │  │  "Ctrl+↑↓ Navigate | Ctrl+Enter Apply | Esc Close"     │ │ │
│  │  └─────────────────────────────────────────────────────────┘ │ │
│  └───────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────┘
```

---

## Detailed Design

### DiffNavigationService

The `DiffNavigationService` is a stateful service that tracks the current position within a collection of diff hunks and provides navigation methods.

```csharp
// src/SeniorIntern.Desktop/Services/DiffNavigationService.cs
namespace SeniorIntern.Desktop.Services;

using SeniorIntern.Desktop.Models;
using System;
using System.Collections.Generic;

/// <summary>
/// Manages navigation state for diff hunks, tracking current position
/// and providing methods to navigate between hunks.
/// </summary>
public sealed class DiffNavigationService
{
    private readonly List<DiffHunk> _hunks = new();
    private int _currentIndex = -1;

    /// <summary>
    /// Event raised when the current hunk changes.
    /// </summary>
    public event EventHandler<HunkChangedEventArgs>? CurrentHunkChanged;

    /// <summary>
    /// Gets the zero-based index of the current hunk, or -1 if no hunks are loaded.
    /// </summary>
    public int CurrentIndex => _currentIndex;

    /// <summary>
    /// Gets the total number of hunks.
    /// </summary>
    public int TotalHunks => _hunks.Count;

    /// <summary>
    /// Gets whether there are any hunks to navigate.
    /// </summary>
    public bool HasHunks => _hunks.Count > 0;

    /// <summary>
    /// Gets the current hunk, or null if no hunks are loaded or index is invalid.
    /// </summary>
    public DiffHunk? CurrentHunk => _currentIndex >= 0 && _currentIndex < _hunks.Count
        ? _hunks[_currentIndex]
        : null;

    /// <summary>
    /// Gets whether navigation to the next hunk is possible.
    /// </summary>
    public bool CanMoveNext => _currentIndex < _hunks.Count - 1;

    /// <summary>
    /// Gets whether navigation to the previous hunk is possible.
    /// </summary>
    public bool CanMovePrevious => _currentIndex > 0;

    /// <summary>
    /// Initializes the navigation service with a collection of hunks.
    /// Resets the current index to the first hunk (0) if hunks exist, or -1 if empty.
    /// </summary>
    /// <param name="hunks">The hunks to navigate through.</param>
    public void SetHunks(IEnumerable<DiffHunk> hunks)
    {
        ArgumentNullException.ThrowIfNull(hunks);

        var previousIndex = _currentIndex;
        var previousHunk = CurrentHunk;

        _hunks.Clear();
        _hunks.AddRange(hunks);
        _currentIndex = _hunks.Count > 0 ? 0 : -1;

        if (_currentIndex != previousIndex || CurrentHunk != previousHunk)
        {
            OnCurrentHunkChanged(previousIndex, _currentIndex);
        }
    }

    /// <summary>
    /// Clears all hunks and resets navigation state.
    /// </summary>
    public void Clear()
    {
        var previousIndex = _currentIndex;

        _hunks.Clear();
        _currentIndex = -1;

        if (previousIndex != -1)
        {
            OnCurrentHunkChanged(previousIndex, -1);
        }
    }

    /// <summary>
    /// Navigates to the next hunk if available.
    /// </summary>
    /// <returns>True if navigation occurred, false if already at the last hunk.</returns>
    public bool MoveNext()
    {
        if (!CanMoveNext)
        {
            return false;
        }

        var previousIndex = _currentIndex;
        _currentIndex++;
        OnCurrentHunkChanged(previousIndex, _currentIndex);
        return true;
    }

    /// <summary>
    /// Navigates to the previous hunk if available.
    /// </summary>
    /// <returns>True if navigation occurred, false if already at the first hunk.</returns>
    public bool MovePrevious()
    {
        if (!CanMovePrevious)
        {
            return false;
        }

        var previousIndex = _currentIndex;
        _currentIndex--;
        OnCurrentHunkChanged(previousIndex, _currentIndex);
        return true;
    }

    /// <summary>
    /// Navigates directly to a specific hunk by index.
    /// </summary>
    /// <param name="index">The zero-based index of the hunk to navigate to.</param>
    /// <returns>True if navigation occurred, false if index is out of range.</returns>
    public bool MoveTo(int index)
    {
        if (index < 0 || index >= _hunks.Count)
        {
            return false;
        }

        if (index == _currentIndex)
        {
            return true; // Already at the target, but consider it a success
        }

        var previousIndex = _currentIndex;
        _currentIndex = index;
        OnCurrentHunkChanged(previousIndex, _currentIndex);
        return true;
    }

    /// <summary>
    /// Navigates to the first hunk.
    /// </summary>
    /// <returns>True if navigation occurred, false if no hunks exist.</returns>
    public bool MoveToFirst()
    {
        return MoveTo(0);
    }

    /// <summary>
    /// Navigates to the last hunk.
    /// </summary>
    /// <returns>True if navigation occurred, false if no hunks exist.</returns>
    public bool MoveToLast()
    {
        return MoveTo(_hunks.Count - 1);
    }

    /// <summary>
    /// Finds the index of the hunk containing the specified line number.
    /// </summary>
    /// <param name="lineNumber">The line number to search for.</param>
    /// <param name="side">Which side of the diff to search (Original or Proposed).</param>
    /// <returns>The index of the containing hunk, or -1 if not found.</returns>
    public int FindHunkContainingLine(int lineNumber, DiffSide side)
    {
        for (int i = 0; i < _hunks.Count; i++)
        {
            var hunk = _hunks[i];
            var start = side == DiffSide.Original
                ? hunk.OriginalStartLine
                : hunk.ProposedStartLine;
            var count = side == DiffSide.Original
                ? hunk.OriginalLineCount
                : hunk.ProposedLineCount;

            if (lineNumber >= start && lineNumber < start + count)
            {
                return i;
            }
        }
        return -1;
    }

    /// <summary>
    /// Navigates to the hunk containing the specified line number.
    /// </summary>
    /// <param name="lineNumber">The line number to navigate to.</param>
    /// <param name="side">Which side of the diff to search.</param>
    /// <returns>True if a containing hunk was found and navigated to, false otherwise.</returns>
    public bool MoveToLineNumber(int lineNumber, DiffSide side)
    {
        var index = FindHunkContainingLine(lineNumber, side);
        if (index >= 0)
        {
            return MoveTo(index);
        }
        return false;
    }

    /// <summary>
    /// Gets the hunk at the specified index without changing the current position.
    /// </summary>
    /// <param name="index">The zero-based index of the hunk.</param>
    /// <returns>The hunk at the specified index, or null if index is out of range.</returns>
    public DiffHunk? GetHunkAt(int index)
    {
        if (index >= 0 && index < _hunks.Count)
        {
            return _hunks[index];
        }
        return null;
    }

    private void OnCurrentHunkChanged(int previousIndex, int newIndex)
    {
        CurrentHunkChanged?.Invoke(this, new HunkChangedEventArgs(
            previousIndex,
            newIndex,
            GetHunkAt(previousIndex),
            GetHunkAt(newIndex)
        ));
    }
}

/// <summary>
/// Event arguments for when the current hunk changes.
/// </summary>
public sealed class HunkChangedEventArgs : EventArgs
{
    public int PreviousIndex { get; }
    public int NewIndex { get; }
    public DiffHunk? PreviousHunk { get; }
    public DiffHunk? NewHunk { get; }

    public HunkChangedEventArgs(
        int previousIndex,
        int newIndex,
        DiffHunk? previousHunk,
        DiffHunk? newHunk)
    {
        PreviousIndex = previousIndex;
        NewIndex = newIndex;
        PreviousHunk = previousHunk;
        NewHunk = newHunk;
    }
}

/// <summary>
/// Specifies which side of the diff to reference.
/// </summary>
public enum DiffSide
{
    /// <summary>
    /// The original (left) side showing the existing content.
    /// </summary>
    Original,

    /// <summary>
    /// The proposed (right) side showing the new content.
    /// </summary>
    Proposed
}
```

### ViewModel Navigation Commands

The `DiffViewerViewModel` integrates with the `DiffNavigationService` and exposes commands for keyboard shortcuts.

```csharp
// src/SeniorIntern.Desktop/ViewModels/DiffViewerViewModel.Navigation.cs
// (Partial class extending DiffViewerViewModel)
namespace SeniorIntern.Desktop.ViewModels;

using Avalonia.Input.Platform;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using SeniorIntern.Desktop.Services;
using System;
using System.Threading.Tasks;

public partial class DiffViewerViewModel
{
    private readonly DiffNavigationService _navigationService = new();
    private IClipboard? _clipboard;

    /// <summary>
    /// Event raised when the user requests to apply the proposed changes.
    /// </summary>
    public event EventHandler? ApplyRequested;

    /// <summary>
    /// Event raised when the user requests to reject/close the diff viewer.
    /// </summary>
    public event EventHandler? RejectRequested;

    /// <summary>
    /// Event raised when navigation should scroll to a specific hunk.
    /// </summary>
    public event EventHandler<ScrollToHunkEventArgs>? ScrollToHunkRequested;

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(NavigationStatusText))]
    [NotifyPropertyChangedFor(nameof(CanNavigatePrevious))]
    [NotifyPropertyChangedFor(nameof(CanNavigateNext))]
    private int _currentHunkIndex = -1;

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(NavigationStatusText))]
    private int _totalHunks;

    [ObservableProperty]
    private bool _showInlineChanges = true;

    [ObservableProperty]
    private bool _wordWrap = false;

    /// <summary>
    /// Gets the navigation status text for display (e.g., "Hunk 2 of 5").
    /// </summary>
    public string NavigationStatusText => TotalHunks > 0
        ? $"Hunk {CurrentHunkIndex + 1} of {TotalHunks}"
        : "No changes";

    /// <summary>
    /// Gets whether navigation to previous hunk is possible.
    /// </summary>
    public bool CanNavigatePrevious => _navigationService.CanMovePrevious;

    /// <summary>
    /// Gets whether navigation to next hunk is possible.
    /// </summary>
    public bool CanNavigateNext => _navigationService.CanMoveNext;

    /// <summary>
    /// Initializes navigation commands and event handlers.
    /// Call this from the main constructor.
    /// </summary>
    private void InitializeNavigation(IClipboard? clipboard = null)
    {
        _clipboard = clipboard;

        _navigationService.CurrentHunkChanged += (sender, args) =>
        {
            CurrentHunkIndex = args.NewIndex;
            TotalHunks = _navigationService.TotalHunks;

            if (args.NewHunk != null)
            {
                ScrollToHunkRequested?.Invoke(this, new ScrollToHunkEventArgs(args.NewIndex, args.NewHunk));
            }
        };
    }

    /// <summary>
    /// Sets the hunks for navigation when a diff is loaded.
    /// </summary>
    internal void SetNavigationHunks(IEnumerable<DiffHunk> hunks)
    {
        _navigationService.SetHunks(hunks);
        CurrentHunkIndex = _navigationService.CurrentIndex;
        TotalHunks = _navigationService.TotalHunks;
    }

    [RelayCommand]
    private void PreviousHunk()
    {
        _navigationService.MovePrevious();
    }

    [RelayCommand]
    private void NextHunk()
    {
        _navigationService.MoveNext();
    }

    [RelayCommand]
    private void GoToFirstHunk()
    {
        _navigationService.MoveToFirst();
    }

    [RelayCommand]
    private void GoToLastHunk()
    {
        _navigationService.MoveToLast();
    }

    [RelayCommand]
    private void GoToHunk(int index)
    {
        _navigationService.MoveTo(index);
    }

    [RelayCommand]
    private void RequestApply()
    {
        ApplyRequested?.Invoke(this, EventArgs.Empty);
    }

    [RelayCommand]
    private void RequestReject()
    {
        RejectRequested?.Invoke(this, EventArgs.Empty);
    }

    [RelayCommand]
    private async Task CopyProposedAsync()
    {
        if (_clipboard == null || ProposedContent == null)
        {
            return;
        }

        await _clipboard.SetTextAsync(ProposedContent);
    }

    [RelayCommand]
    private void ToggleInlineChanges()
    {
        ShowInlineChanges = !ShowInlineChanges;
    }

    [RelayCommand]
    private void ToggleWordWrap()
    {
        WordWrap = !WordWrap;
    }
}

/// <summary>
/// Event arguments for scroll-to-hunk requests.
/// </summary>
public sealed class ScrollToHunkEventArgs : EventArgs
{
    public int HunkIndex { get; }
    public DiffHunk Hunk { get; }

    public ScrollToHunkEventArgs(int hunkIndex, DiffHunk hunk)
    {
        HunkIndex = hunkIndex;
        Hunk = hunk;
    }
}
```

### Keyboard Handler

The keyboard handler is implemented in the `DiffViewerPanel` code-behind to intercept and route keyboard events.

```csharp
// src/SeniorIntern.Desktop/Views/DiffViewerPanel.axaml.cs (additions)
namespace SeniorIntern.Desktop.Views;

using Avalonia.Controls;
using Avalonia.Input;
using Avalonia.Interactivity;
using SeniorIntern.Desktop.ViewModels;

public partial class DiffViewerPanel : UserControl
{
    public DiffViewerPanel()
    {
        InitializeComponent();

        // Ensure the control can receive keyboard focus
        Focusable = true;

        // Acquire focus when the control is attached to the visual tree
        AttachedToVisualTree += OnAttachedToVisualTree;
    }

    private void OnAttachedToVisualTree(object? sender, VisualTreeAttachmentEventArgs e)
    {
        // Request focus when the panel becomes visible
        Focus();
    }

    /// <summary>
    /// Handles keyboard input for navigation and action shortcuts.
    /// </summary>
    protected override void OnKeyDown(KeyEventArgs e)
    {
        base.OnKeyDown(e);

        if (DataContext is not DiffViewerViewModel vm)
        {
            return;
        }

        var modifiers = e.KeyModifiers;
        var key = e.Key;

        // Handle Ctrl+Key combinations
        if (modifiers.HasFlag(KeyModifiers.Control))
        {
            switch (key)
            {
                case Key.Up:
                    // Navigate to previous hunk
                    if (vm.PreviousHunkCommand.CanExecute(null))
                    {
                        vm.PreviousHunkCommand.Execute(null);
                    }
                    e.Handled = true;
                    break;

                case Key.Down:
                    // Navigate to next hunk
                    if (vm.NextHunkCommand.CanExecute(null))
                    {
                        vm.NextHunkCommand.Execute(null);
                    }
                    e.Handled = true;
                    break;

                case Key.Enter:
                    // Apply the proposed changes
                    if (vm.RequestApplyCommand.CanExecute(null))
                    {
                        vm.RequestApplyCommand.Execute(null);
                    }
                    e.Handled = true;
                    break;

                case Key.C:
                    // Copy proposed content to clipboard
                    if (vm.CopyProposedCommand.CanExecute(null))
                    {
                        vm.CopyProposedCommand.Execute(null);
                    }
                    e.Handled = true;
                    break;

                case Key.I:
                    // Toggle inline change highlighting
                    if (vm.ToggleInlineChangesCommand.CanExecute(null))
                    {
                        vm.ToggleInlineChangesCommand.Execute(null);
                    }
                    e.Handled = true;
                    break;

                case Key.W:
                    // Toggle word wrap
                    if (vm.ToggleWordWrapCommand.CanExecute(null))
                    {
                        vm.ToggleWordWrapCommand.Execute(null);
                    }
                    e.Handled = true;
                    break;

                case Key.Home:
                    // Navigate to first hunk
                    if (vm.GoToFirstHunkCommand.CanExecute(null))
                    {
                        vm.GoToFirstHunkCommand.Execute(null);
                    }
                    e.Handled = true;
                    break;

                case Key.End:
                    // Navigate to last hunk
                    if (vm.GoToLastHunkCommand.CanExecute(null))
                    {
                        vm.GoToLastHunkCommand.Execute(null);
                    }
                    e.Handled = true;
                    break;
            }
        }
        // Handle non-modified keys
        else if (modifiers == KeyModifiers.None)
        {
            switch (key)
            {
                case Key.Escape:
                    // Close/reject the diff viewer
                    if (vm.RequestRejectCommand.CanExecute(null))
                    {
                        vm.RequestRejectCommand.Execute(null);
                    }
                    e.Handled = true;
                    break;
            }
        }
    }

    /// <summary>
    /// Ensures the panel retains focus after interactions.
    /// </summary>
    protected override void OnPointerPressed(PointerPressedEventArgs e)
    {
        base.OnPointerPressed(e);

        // Re-acquire focus when clicked to ensure keyboard events work
        if (!IsFocused)
        {
            Focus();
        }
    }
}
```

### XAML Updates for Focus and Keyboard Hints

```xml
<!-- src/SeniorIntern.Desktop/Views/DiffViewerPanel.axaml (additions) -->
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:vm="using:SeniorIntern.Desktop.ViewModels"
             x:Class="SeniorIntern.Desktop.Views.DiffViewerPanel"
             x:DataType="vm:DiffViewerViewModel"
             Focusable="True"
             IsTabStop="True">

    <!-- Root Grid -->
    <Grid RowDefinitions="Auto,*,Auto">

        <!-- Header with Navigation Status -->
        <Border Grid.Row="0"
                Background="{DynamicResource DiffHeaderBackground}"
                Padding="12,8">
            <Grid ColumnDefinitions="*,Auto,*">
                <!-- Left: File Path -->
                <TextBlock Grid.Column="0"
                           Text="{Binding FilePath}"
                           FontWeight="SemiBold"
                           VerticalAlignment="Center"/>

                <!-- Center: Navigation Status -->
                <StackPanel Grid.Column="1"
                            Orientation="Horizontal"
                            HorizontalAlignment="Center"
                            Spacing="8">
                    <Button Command="{Binding PreviousHunkCommand}"
                            IsEnabled="{Binding CanNavigatePrevious}"
                            ToolTip.Tip="Previous Hunk (Ctrl+Up)"
                            Classes="navigation">
                        <PathIcon Data="{StaticResource ChevronUpIcon}" Width="12" Height="12"/>
                    </Button>

                    <TextBlock Text="{Binding NavigationStatusText}"
                               VerticalAlignment="Center"
                               Foreground="{DynamicResource SecondaryTextBrush}"
                               MinWidth="80"
                               TextAlignment="Center"/>

                    <Button Command="{Binding NextHunkCommand}"
                            IsEnabled="{Binding CanNavigateNext}"
                            ToolTip.Tip="Next Hunk (Ctrl+Down)"
                            Classes="navigation">
                        <PathIcon Data="{StaticResource ChevronDownIcon}" Width="12" Height="12"/>
                    </Button>
                </StackPanel>

                <!-- Right: Toggle Buttons -->
                <StackPanel Grid.Column="2"
                            Orientation="Horizontal"
                            HorizontalAlignment="Right"
                            Spacing="4">
                    <ToggleButton IsChecked="{Binding ShowInlineChanges}"
                                  ToolTip.Tip="Toggle Inline Changes (Ctrl+I)"
                                  Classes="toolbar">
                        <PathIcon Data="{StaticResource InlineChangesIcon}" Width="14" Height="14"/>
                    </ToggleButton>

                    <ToggleButton IsChecked="{Binding WordWrap}"
                                  ToolTip.Tip="Toggle Word Wrap (Ctrl+W)"
                                  Classes="toolbar">
                        <PathIcon Data="{StaticResource WordWrapIcon}" Width="14" Height="14"/>
                    </ToggleButton>
                </StackPanel>
            </Grid>
        </Border>

        <!-- Content: Side-by-Side Diff Panels -->
        <Grid Grid.Row="1" ColumnDefinitions="*,Auto,*">
            <!-- Original Panel -->
            <ScrollViewer Grid.Column="0"
                          Name="OriginalScrollViewer"
                          HorizontalScrollBarVisibility="Auto"
                          VerticalScrollBarVisibility="Auto">
                <ItemsControl ItemsSource="{Binding OriginalHunks}"
                              ItemTemplate="{StaticResource DiffHunkTemplate}"/>
            </ScrollViewer>

            <!-- Splitter -->
            <GridSplitter Grid.Column="1"
                          Width="4"
                          Background="{DynamicResource DiffSplitterBackground}"/>

            <!-- Proposed Panel -->
            <ScrollViewer Grid.Column="2"
                          Name="ProposedScrollViewer"
                          HorizontalScrollBarVisibility="Auto"
                          VerticalScrollBarVisibility="Auto">
                <ItemsControl ItemsSource="{Binding ProposedHunks}"
                              ItemTemplate="{StaticResource DiffHunkTemplate}"/>
            </ScrollViewer>
        </Grid>

        <!-- Footer: Action Buttons and Keyboard Hints -->
        <Border Grid.Row="2"
                Background="{DynamicResource DiffFooterBackground}"
                Padding="12,8">
            <Grid ColumnDefinitions="*,Auto">
                <!-- Left: Keyboard Hints -->
                <TextBlock Grid.Column="0"
                           VerticalAlignment="Center"
                           Foreground="{DynamicResource TertiaryTextBrush}"
                           FontSize="11">
                    <Run Text="Ctrl+↑↓"/>
                    <Run Text=" Navigate" Foreground="{DynamicResource SecondaryTextBrush}"/>
                    <Run Text="  |  "/>
                    <Run Text="Ctrl+Enter"/>
                    <Run Text=" Apply" Foreground="{DynamicResource SecondaryTextBrush}"/>
                    <Run Text="  |  "/>
                    <Run Text="Esc"/>
                    <Run Text=" Close" Foreground="{DynamicResource SecondaryTextBrush}"/>
                    <Run Text="  |  "/>
                    <Run Text="Ctrl+C"/>
                    <Run Text=" Copy" Foreground="{DynamicResource SecondaryTextBrush}"/>
                </TextBlock>

                <!-- Right: Action Buttons -->
                <StackPanel Grid.Column="1"
                            Orientation="Horizontal"
                            Spacing="8">
                    <Button Command="{Binding CopyProposedCommand}"
                            ToolTip.Tip="Copy Proposed Content (Ctrl+C)"
                            Classes="secondary">
                        <StackPanel Orientation="Horizontal" Spacing="6">
                            <PathIcon Data="{StaticResource CopyIcon}" Width="14" Height="14"/>
                            <TextBlock Text="Copy"/>
                        </StackPanel>
                    </Button>

                    <Button Command="{Binding RequestRejectCommand}"
                            ToolTip.Tip="Close Without Applying (Escape)"
                            Classes="secondary">
                        <TextBlock Text="Cancel"/>
                    </Button>

                    <Button Command="{Binding RequestApplyCommand}"
                            ToolTip.Tip="Apply Changes (Ctrl+Enter)"
                            Classes="primary">
                        <StackPanel Orientation="Horizontal" Spacing="6">
                            <PathIcon Data="{StaticResource CheckIcon}" Width="14" Height="14"/>
                            <TextBlock Text="Apply"/>
                        </StackPanel>
                    </Button>
                </StackPanel>
            </Grid>
        </Border>
    </Grid>
</UserControl>
```

### Scroll-to-Hunk Implementation

```csharp
// src/SeniorIntern.Desktop/Views/DiffViewerPanel.axaml.cs (additions for scrolling)
namespace SeniorIntern.Desktop.Views;

using Avalonia;
using Avalonia.Controls;
using Avalonia.VisualTree;
using SeniorIntern.Desktop.ViewModels;
using System.Linq;

public partial class DiffViewerPanel : UserControl
{
    private ScrollViewer? _originalScrollViewer;
    private ScrollViewer? _proposedScrollViewer;

    protected override void OnDataContextChanged(EventArgs e)
    {
        base.OnDataContextChanged(e);

        // Unsubscribe from previous ViewModel
        if (e.OldValue is DiffViewerViewModel oldVm)
        {
            oldVm.ScrollToHunkRequested -= OnScrollToHunkRequested;
        }

        // Subscribe to new ViewModel
        if (DataContext is DiffViewerViewModel newVm)
        {
            newVm.ScrollToHunkRequested += OnScrollToHunkRequested;
        }
    }

    protected override void OnApplyTemplate(TemplateAppliedEventArgs e)
    {
        base.OnApplyTemplate(e);

        // Cache references to scroll viewers
        _originalScrollViewer = this.FindDescendantOfType<ScrollViewer>("OriginalScrollViewer");
        _proposedScrollViewer = this.FindDescendantOfType<ScrollViewer>("ProposedScrollViewer");
    }

    private void OnScrollToHunkRequested(object? sender, ScrollToHunkEventArgs e)
    {
        // Find the visual element for the hunk at the specified index
        var hunkControl = FindHunkControlByIndex(e.HunkIndex);
        if (hunkControl == null)
        {
            return;
        }

        // Get the position of the hunk control relative to the scroll viewer
        var position = hunkControl.TranslatePoint(new Point(0, 0), _originalScrollViewer);
        if (position.HasValue)
        {
            // Calculate target offset with some padding above
            var targetOffset = Math.Max(0, position.Value.Y - 50);

            // Scroll both panels to the same offset (synchronized)
            ScrollToOffset(targetOffset);
        }
    }

    private Control? FindHunkControlByIndex(int index)
    {
        // Find the ItemsControl containing hunks
        var itemsControl = _originalScrollViewer?
            .GetVisualDescendants()
            .OfType<ItemsControl>()
            .FirstOrDefault();

        if (itemsControl == null || index < 0)
        {
            return null;
        }

        // Get the container for the specified index
        return itemsControl.ContainerFromIndex(index) as Control;
    }

    private void ScrollToOffset(double offset)
    {
        _originalScrollViewer?.ScrollToVerticalOffset(offset);
        _proposedScrollViewer?.ScrollToVerticalOffset(offset);
    }
}

// Extension method for finding named descendants
internal static class VisualTreeExtensions
{
    public static T? FindDescendantOfType<T>(this Visual visual, string? name = null) where T : Visual
    {
        foreach (var child in visual.GetVisualDescendants())
        {
            if (child is T typed)
            {
                if (name == null || (child is Control control && control.Name == name))
                {
                    return typed;
                }
            }
        }
        return null;
    }
}
```

---

## Keyboard Shortcuts Reference

| Shortcut | Action | Command | Description |
|----------|--------|---------|-------------|
| `Ctrl+↑` | Previous Hunk | `PreviousHunkCommand` | Navigate to the previous diff hunk |
| `Ctrl+↓` | Next Hunk | `NextHunkCommand` | Navigate to the next diff hunk |
| `Ctrl+Home` | First Hunk | `GoToFirstHunkCommand` | Jump to the first diff hunk |
| `Ctrl+End` | Last Hunk | `GoToLastHunkCommand` | Jump to the last diff hunk |
| `Escape` | Close/Reject | `RequestRejectCommand` | Close the diff viewer without applying |
| `Ctrl+Enter` | Apply | `RequestApplyCommand` | Apply the proposed changes |
| `Ctrl+C` | Copy | `CopyProposedCommand` | Copy proposed content to clipboard |
| `Ctrl+I` | Toggle Inline | `ToggleInlineChangesCommand` | Toggle inline change highlighting |
| `Ctrl+W` | Toggle Wrap | `ToggleWordWrapCommand` | Toggle word wrap mode |

---

## Data Binding Specifications

### DiffViewerViewModel Navigation Properties

| Property | Type | Binding Mode | Description |
|----------|------|--------------|-------------|
| `CurrentHunkIndex` | `int` | OneWay | Zero-based index of current hunk |
| `TotalHunks` | `int` | OneWay | Total number of hunks |
| `NavigationStatusText` | `string` | OneWay | Formatted status (e.g., "Hunk 2 of 5") |
| `CanNavigatePrevious` | `bool` | OneWay | Whether previous navigation is available |
| `CanNavigateNext` | `bool` | OneWay | Whether next navigation is available |
| `ShowInlineChanges` | `bool` | TwoWay | Toggle for inline change display |
| `WordWrap` | `bool` | TwoWay | Toggle for word wrap mode |

### DiffViewerViewModel Commands

| Command | Parameter | Can Execute | Description |
|---------|-----------|-------------|-------------|
| `PreviousHunkCommand` | None | `CanNavigatePrevious` | Navigate to previous hunk |
| `NextHunkCommand` | None | `CanNavigateNext` | Navigate to next hunk |
| `GoToFirstHunkCommand` | None | `HasHunks` | Jump to first hunk |
| `GoToLastHunkCommand` | None | `HasHunks` | Jump to last hunk |
| `GoToHunkCommand` | `int` | Index valid | Jump to specific hunk |
| `RequestApplyCommand` | None | Always | Request to apply changes |
| `RequestRejectCommand` | None | Always | Request to reject/close |
| `CopyProposedCommand` | None | Has content | Copy proposed to clipboard |
| `ToggleInlineChangesCommand` | None | Always | Toggle inline changes |
| `ToggleWordWrapCommand` | None | Always | Toggle word wrap |

### DiffViewerViewModel Events

| Event | Args Type | Description |
|-------|-----------|-------------|
| `ApplyRequested` | `EventArgs` | User requested to apply changes |
| `RejectRequested` | `EventArgs` | User requested to reject/close |
| `ScrollToHunkRequested` | `ScrollToHunkEventArgs` | Navigation requires scroll |

---

## Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/Services/DiffNavigationService.cs` | Navigation state management and methods |

## Files to Modify

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/ViewModels/DiffViewerViewModel.cs` | Add navigation commands, properties, and events |
| `src/SeniorIntern.Desktop/Views/DiffViewerPanel.axaml.cs` | Add keyboard handler and scroll-to-hunk |
| `src/SeniorIntern.Desktop/Views/DiffViewerPanel.axaml` | Add Focusable, navigation UI, keyboard hints |

---

## Testing Strategy

### Unit Tests

```csharp
// tests/SeniorIntern.Desktop.Tests/Services/DiffNavigationServiceTests.cs
namespace SeniorIntern.Desktop.Tests.Services;

using SeniorIntern.Desktop.Models;
using SeniorIntern.Desktop.Services;
using Xunit;

public class DiffNavigationServiceTests
{
    private readonly DiffNavigationService _service = new();

    private static List<DiffHunk> CreateTestHunks(int count)
    {
        return Enumerable.Range(0, count)
            .Select(i => new DiffHunk
            {
                OriginalStartLine = i * 10,
                OriginalLineCount = 5,
                ProposedStartLine = i * 10,
                ProposedLineCount = 5
            })
            .ToList();
    }

    [Fact]
    public void SetHunks_WithEmptyCollection_SetsIndexToMinusOne()
    {
        _service.SetHunks(Array.Empty<DiffHunk>());

        Assert.Equal(-1, _service.CurrentIndex);
        Assert.Equal(0, _service.TotalHunks);
        Assert.Null(_service.CurrentHunk);
        Assert.False(_service.HasHunks);
    }

    [Fact]
    public void SetHunks_WithHunks_SetsIndexToZero()
    {
        var hunks = CreateTestHunks(3);

        _service.SetHunks(hunks);

        Assert.Equal(0, _service.CurrentIndex);
        Assert.Equal(3, _service.TotalHunks);
        Assert.NotNull(_service.CurrentHunk);
        Assert.True(_service.HasHunks);
    }

    [Fact]
    public void MoveNext_AtFirstHunk_MovesToSecond()
    {
        _service.SetHunks(CreateTestHunks(3));

        var result = _service.MoveNext();

        Assert.True(result);
        Assert.Equal(1, _service.CurrentIndex);
    }

    [Fact]
    public void MoveNext_AtLastHunk_ReturnsFalse()
    {
        _service.SetHunks(CreateTestHunks(3));
        _service.MoveTo(2);

        var result = _service.MoveNext();

        Assert.False(result);
        Assert.Equal(2, _service.CurrentIndex);
    }

    [Fact]
    public void MovePrevious_AtSecondHunk_MovesToFirst()
    {
        _service.SetHunks(CreateTestHunks(3));
        _service.MoveNext();

        var result = _service.MovePrevious();

        Assert.True(result);
        Assert.Equal(0, _service.CurrentIndex);
    }

    [Fact]
    public void MovePrevious_AtFirstHunk_ReturnsFalse()
    {
        _service.SetHunks(CreateTestHunks(3));

        var result = _service.MovePrevious();

        Assert.False(result);
        Assert.Equal(0, _service.CurrentIndex);
    }

    [Fact]
    public void MoveTo_ValidIndex_ReturnsTrue()
    {
        _service.SetHunks(CreateTestHunks(5));

        var result = _service.MoveTo(3);

        Assert.True(result);
        Assert.Equal(3, _service.CurrentIndex);
    }

    [Fact]
    public void MoveTo_InvalidIndex_ReturnsFalse()
    {
        _service.SetHunks(CreateTestHunks(3));

        Assert.False(_service.MoveTo(-1));
        Assert.False(_service.MoveTo(5));
        Assert.Equal(0, _service.CurrentIndex);
    }

    [Fact]
    public void MoveToFirst_NavigatesToIndexZero()
    {
        _service.SetHunks(CreateTestHunks(5));
        _service.MoveTo(3);

        var result = _service.MoveToFirst();

        Assert.True(result);
        Assert.Equal(0, _service.CurrentIndex);
    }

    [Fact]
    public void MoveToLast_NavigatesToLastIndex()
    {
        _service.SetHunks(CreateTestHunks(5));

        var result = _service.MoveToLast();

        Assert.True(result);
        Assert.Equal(4, _service.CurrentIndex);
    }

    [Fact]
    public void FindHunkContainingLine_FindsCorrectHunk_Original()
    {
        _service.SetHunks(CreateTestHunks(3)); // Lines 0-4, 10-14, 20-24

        Assert.Equal(0, _service.FindHunkContainingLine(2, DiffSide.Original));
        Assert.Equal(1, _service.FindHunkContainingLine(12, DiffSide.Original));
        Assert.Equal(2, _service.FindHunkContainingLine(22, DiffSide.Original));
    }

    [Fact]
    public void FindHunkContainingLine_ReturnsMinusOne_WhenNotFound()
    {
        _service.SetHunks(CreateTestHunks(3)); // Lines 0-4, 10-14, 20-24

        Assert.Equal(-1, _service.FindHunkContainingLine(7, DiffSide.Original));
        Assert.Equal(-1, _service.FindHunkContainingLine(100, DiffSide.Original));
    }

    [Fact]
    public void CurrentHunkChanged_RaisedOnNavigation()
    {
        _service.SetHunks(CreateTestHunks(3));
        HunkChangedEventArgs? eventArgs = null;
        _service.CurrentHunkChanged += (s, e) => eventArgs = e;

        _service.MoveNext();

        Assert.NotNull(eventArgs);
        Assert.Equal(0, eventArgs.PreviousIndex);
        Assert.Equal(1, eventArgs.NewIndex);
    }

    [Fact]
    public void CanMoveNext_ReflectsState()
    {
        _service.SetHunks(CreateTestHunks(2));

        Assert.True(_service.CanMoveNext);

        _service.MoveNext();

        Assert.False(_service.CanMoveNext);
    }

    [Fact]
    public void CanMovePrevious_ReflectsState()
    {
        _service.SetHunks(CreateTestHunks(2));

        Assert.False(_service.CanMovePrevious);

        _service.MoveNext();

        Assert.True(_service.CanMovePrevious);
    }

    [Fact]
    public void Clear_ResetsState()
    {
        _service.SetHunks(CreateTestHunks(3));
        _service.MoveNext();

        _service.Clear();

        Assert.Equal(-1, _service.CurrentIndex);
        Assert.Equal(0, _service.TotalHunks);
        Assert.False(_service.HasHunks);
    }

    [Fact]
    public void GetHunkAt_ReturnsCorrectHunk()
    {
        var hunks = CreateTestHunks(3);
        _service.SetHunks(hunks);

        Assert.Equal(hunks[1], _service.GetHunkAt(1));
        Assert.Null(_service.GetHunkAt(-1));
        Assert.Null(_service.GetHunkAt(10));
    }
}
```

### Integration Tests

```csharp
// tests/SeniorIntern.Desktop.Tests/ViewModels/DiffViewerViewModelNavigationTests.cs
namespace SeniorIntern.Desktop.Tests.ViewModels;

using SeniorIntern.Desktop.Models;
using SeniorIntern.Desktop.ViewModels;
using Xunit;

public class DiffViewerViewModelNavigationTests
{
    private readonly DiffViewerViewModel _viewModel = new();

    private static List<DiffHunk> CreateTestHunks(int count)
    {
        return Enumerable.Range(0, count)
            .Select(i => new DiffHunk
            {
                OriginalStartLine = i * 10,
                OriginalLineCount = 5,
                ProposedStartLine = i * 10,
                ProposedLineCount = 5
            })
            .ToList();
    }

    [Fact]
    public void NavigationStatusText_FormatsCorrectly()
    {
        _viewModel.SetNavigationHunks(CreateTestHunks(5));

        Assert.Equal("Hunk 1 of 5", _viewModel.NavigationStatusText);

        _viewModel.NextHunkCommand.Execute(null);

        Assert.Equal("Hunk 2 of 5", _viewModel.NavigationStatusText);
    }

    [Fact]
    public void NavigationStatusText_ShowsNoChanges_WhenEmpty()
    {
        Assert.Equal("No changes", _viewModel.NavigationStatusText);
    }

    [Fact]
    public void ScrollToHunkRequested_RaisedOnNavigation()
    {
        _viewModel.SetNavigationHunks(CreateTestHunks(3));
        ScrollToHunkEventArgs? eventArgs = null;
        _viewModel.ScrollToHunkRequested += (s, e) => eventArgs = e;

        _viewModel.NextHunkCommand.Execute(null);

        Assert.NotNull(eventArgs);
        Assert.Equal(1, eventArgs.HunkIndex);
    }

    [Fact]
    public void ApplyRequested_RaisedOnCommand()
    {
        var raised = false;
        _viewModel.ApplyRequested += (s, e) => raised = true;

        _viewModel.RequestApplyCommand.Execute(null);

        Assert.True(raised);
    }

    [Fact]
    public void RejectRequested_RaisedOnCommand()
    {
        var raised = false;
        _viewModel.RejectRequested += (s, e) => raised = true;

        _viewModel.RequestRejectCommand.Execute(null);

        Assert.True(raised);
    }

    [Fact]
    public void ToggleInlineChanges_TogglesProperty()
    {
        Assert.True(_viewModel.ShowInlineChanges); // Default

        _viewModel.ToggleInlineChangesCommand.Execute(null);

        Assert.False(_viewModel.ShowInlineChanges);

        _viewModel.ToggleInlineChangesCommand.Execute(null);

        Assert.True(_viewModel.ShowInlineChanges);
    }

    [Fact]
    public void ToggleWordWrap_TogglesProperty()
    {
        Assert.False(_viewModel.WordWrap); // Default

        _viewModel.ToggleWordWrapCommand.Execute(null);

        Assert.True(_viewModel.WordWrap);
    }
}
```

### UI Tests

```csharp
// tests/SeniorIntern.Desktop.Tests/Views/DiffViewerPanelKeyboardTests.cs
namespace SeniorIntern.Desktop.Tests.Views;

using Avalonia.Headless.XUnit;
using Avalonia.Input;
using SeniorIntern.Desktop.ViewModels;
using SeniorIntern.Desktop.Views;
using Xunit;

public class DiffViewerPanelKeyboardTests
{
    [AvaloniaFact]
    public void CtrlUp_ExecutesPreviousHunkCommand()
    {
        var viewModel = new DiffViewerViewModel();
        viewModel.SetNavigationHunks(CreateTestHunks(3));
        viewModel.NextHunkCommand.Execute(null); // Move to hunk 1

        var panel = new DiffViewerPanel { DataContext = viewModel };

        // Simulate Ctrl+Up
        var keyEventArgs = new KeyEventArgs
        {
            Key = Key.Up,
            KeyModifiers = KeyModifiers.Control
        };
        panel.RaiseEvent(keyEventArgs);

        Assert.Equal(0, viewModel.CurrentHunkIndex);
    }

    [AvaloniaFact]
    public void CtrlDown_ExecutesNextHunkCommand()
    {
        var viewModel = new DiffViewerViewModel();
        viewModel.SetNavigationHunks(CreateTestHunks(3));

        var panel = new DiffViewerPanel { DataContext = viewModel };

        // Simulate Ctrl+Down
        var keyEventArgs = new KeyEventArgs
        {
            Key = Key.Down,
            KeyModifiers = KeyModifiers.Control
        };
        panel.RaiseEvent(keyEventArgs);

        Assert.Equal(1, viewModel.CurrentHunkIndex);
    }

    [AvaloniaFact]
    public void Escape_ExecutesRejectCommand()
    {
        var viewModel = new DiffViewerViewModel();
        var rejected = false;
        viewModel.RejectRequested += (s, e) => rejected = true;

        var panel = new DiffViewerPanel { DataContext = viewModel };

        // Simulate Escape
        var keyEventArgs = new KeyEventArgs
        {
            Key = Key.Escape,
            KeyModifiers = KeyModifiers.None
        };
        panel.RaiseEvent(keyEventArgs);

        Assert.True(rejected);
    }

    [AvaloniaFact]
    public void CtrlEnter_ExecutesApplyCommand()
    {
        var viewModel = new DiffViewerViewModel();
        var applied = false;
        viewModel.ApplyRequested += (s, e) => applied = true;

        var panel = new DiffViewerPanel { DataContext = viewModel };

        // Simulate Ctrl+Enter
        var keyEventArgs = new KeyEventArgs
        {
            Key = Key.Enter,
            KeyModifiers = KeyModifiers.Control
        };
        panel.RaiseEvent(keyEventArgs);

        Assert.True(applied);
    }

    [AvaloniaFact]
    public void Panel_IsFocusable()
    {
        var panel = new DiffViewerPanel();

        Assert.True(panel.Focusable);
    }

    private static List<DiffHunk> CreateTestHunks(int count)
    {
        return Enumerable.Range(0, count)
            .Select(i => new DiffHunk
            {
                OriginalStartLine = i * 10,
                OriginalLineCount = 5,
                ProposedStartLine = i * 10,
                ProposedLineCount = 5
            })
            .ToList();
    }
}
```

---

## Acceptance Criteria

- [ ] `Ctrl+Up` navigates to the previous hunk
- [ ] `Ctrl+Down` navigates to the next hunk
- [ ] `Ctrl+Home` navigates to the first hunk
- [ ] `Ctrl+End` navigates to the last hunk
- [ ] `Escape` closes/rejects the diff viewer
- [ ] `Ctrl+Enter` applies the proposed changes
- [ ] `Ctrl+C` copies proposed content to clipboard
- [ ] `Ctrl+I` toggles inline change highlighting
- [ ] `Ctrl+W` toggles word wrap mode
- [ ] Keyboard focus is acquired automatically when panel is shown
- [ ] Navigation status displays "Hunk X of Y" correctly
- [ ] Navigation buttons are disabled at boundaries (first/last)
- [ ] Scroll position synchronizes when navigating to a hunk
- [ ] `CurrentHunkChanged` event fires on every navigation
- [ ] All keyboard shortcuts have tooltip hints on corresponding buttons
- [ ] Footer displays keyboard shortcut hints

---

## Design Decisions

### 1. Stateful Navigation Service vs. Index Property

**Decision:** Use a dedicated `DiffNavigationService` class rather than simple index properties on the ViewModel.

**Rationale:**
- Encapsulates navigation logic in a testable unit
- Provides clear boundary semantics (can't go past first/last)
- Enables reuse across different diff viewers
- Supports future features like bookmarks or history

### 2. Event-Driven Scrolling vs. Direct Binding

**Decision:** Use `ScrollToHunkRequested` event rather than binding scroll offset directly.

**Rationale:**
- Scroll offset calculation requires visual tree traversal
- Events allow View-specific implementation details
- Cleaner separation between ViewModel and View
- Easier to handle edge cases (element not visible yet)

### 3. OnKeyDown Override vs. KeyBindings

**Decision:** Override `OnKeyDown` in code-behind rather than using XAML KeyBindings.

**Rationale:**
- More control over event handling order
- Easier to conditionally handle based on focus state
- KeyBindings can conflict with nested controls
- Simpler debugging and testing

### 4. Focus Management Strategy

**Decision:** Set `Focusable="True"` and acquire focus on `AttachedToVisualTree`.

**Rationale:**
- Ensures immediate keyboard interaction without clicking
- `AttachedToVisualTree` fires when panel becomes visible
- Automatic focus is expected UX for modal-like diff viewers
- Re-focus on click maintains keyboard functionality

### 5. Copy Behavior (Ctrl+C)

**Decision:** Copy the entire proposed content, not just the current hunk.

**Rationale:**
- Users typically want the complete proposed file content
- Per-hunk copy would be confusing with partial content
- Full copy is more useful for manual patching scenarios
- Aligns with VSCode diff viewer behavior

### 6. Navigation Boundary Behavior

**Decision:** Stop at boundaries rather than wrapping around.

**Rationale:**
- Wrapping can be disorienting in long diffs
- Users expect navigation to have clear start/end points
- Visual feedback (disabled buttons) indicates boundaries
- More predictable behavior for keyboard users

---

## Dependencies

### From Previous v0.4.2 Sub-parts

| Sub-part | Dependency |
|----------|------------|
| v0.4.2a | `DiffHunk` model with line number properties |
| v0.4.2d | `DiffViewerViewModel` base implementation |
| v0.4.2e | `DiffViewerPanel` with synchronized scroll viewers |
| v0.4.2f | `DiffHunkControl` for visual hunk containers |

### External Dependencies

| Package | Purpose |
|---------|---------|
| `CommunityToolkit.Mvvm` | `[RelayCommand]`, `[ObservableProperty]` |
| `Avalonia.Input` | `KeyEventArgs`, `KeyModifiers`, `Key` |
| `Avalonia.Input.Platform` | `IClipboard` for copy functionality |

---

## Implementation Notes

### Focus Considerations

1. **Initial Focus:** The panel should acquire focus immediately when shown to enable keyboard navigation without requiring a mouse click.

2. **Focus Retention:** After button clicks or other interactions, focus should return to the panel to maintain keyboard functionality.

3. **Nested Focusable Elements:** If the panel contains text boxes or other focusable elements, keyboard shortcuts should still work when focus is on child elements.

### Clipboard Integration

The `IClipboard` interface is obtained through Avalonia's `TopLevel.GetTopLevel(this)?.Clipboard` pattern:

```csharp
// In DiffViewerPanel.axaml.cs
protected override void OnAttachedToVisualTree(VisualTreeAttachmentEventArgs e)
{
    base.OnAttachedToVisualTree(e);

    if (DataContext is DiffViewerViewModel vm)
    {
        var clipboard = TopLevel.GetTopLevel(this)?.Clipboard;
        vm.InitializeNavigation(clipboard);
    }
}
```

### Scroll Animation (Optional Enhancement)

For smoother navigation UX, consider adding animated scrolling:

```csharp
// Optional: Animate scroll to hunk
private async Task AnimateScrollToOffset(double targetOffset)
{
    var currentOffset = _originalScrollViewer!.Offset.Y;
    var steps = 10;
    var increment = (targetOffset - currentOffset) / steps;

    for (int i = 0; i < steps; i++)
    {
        currentOffset += increment;
        ScrollToOffset(currentOffset);
        await Task.Delay(16); // ~60fps
    }

    ScrollToOffset(targetOffset); // Ensure exact final position
}
```
