# Design Specification: The Senior Intern v0.4.2b "Diff Service"

**Status**: _IMPLEMENTED_

## Executive Summary

This document provides a comprehensive implementation specification for v0.4.2b, which implements the core diff computation service using the DiffPlex library. This service transforms original and proposed content into structured `DiffResult` objects with hunks, statistics, and metadata for visualization in the diff viewer UI.

### v0.4.2b Scope

- Create `IDiffService` interface for diff computation operations
- Create `DiffOptions` model for configurable diff behavior
- Implement `DiffService` using DiffPlex for line-level diff computation
- Handle special cases: new files, deleted files, binary files, identical content
- Implement hunk construction with configurable context lines
- Integrate with file system for reading original content
- Integrate with CodeBlock model for block-to-diff conversion

### Key Deliverables

| Deliverable | Description |
|-------------|-------------|
| IDiffService | Interface defining diff computation operations |
| DiffOptions | Configuration model for diff behavior |
| DiffService | DiffPlex-based implementation |
| IFileSystemService | Interface for file operations (dependency) |
| FileSystemService | Implementation for reading file content |

---

## Prerequisites

Before implementing v0.4.2b, ensure:

- v0.4.2a is complete (DiffResult, DiffHunk, DiffLine, DiffStats models)
- v0.4.1a is complete (CodeBlock, CodeBlockType models)
- DiffPlex NuGet package is available (1.7.2+)

---

## Feature Overview

```
┌───────────────────────────────────────────────────────────────────────┐
│                     v0.4.2b Feature Tree                               │
├───────────────────────────────────────────────────────────────────────┤
│                                                                        │
│  IDiffService                                                          │
│  ├── Synchronous Methods                                               │
│  │   ├── ComputeDiff(original, proposed) → DiffResult                 │
│  │   │   └── Basic diff between two strings                           │
│  │   │                                                                 │
│  │   ├── ComputeDiff(original, proposed, filePath) → DiffResult       │
│  │   │   └── Diff with file path context for display                  │
│  │   │                                                                 │
│  │   ├── ComputeDiff(original, proposed, filePath, options)           │
│  │   │   └── Diff with custom options                                 │
│  │   │                                                                 │
│  │   ├── ComputeNewFileDiff(proposed, filePath) → DiffResult          │
│  │   │   └── All lines marked as Added, IsNewFile=true                │
│  │   │                                                                 │
│  │   └── ComputeDeleteFileDiff(original, filePath) → DiffResult       │
│  │       └── All lines marked as Removed, IsDeleteFile=true           │
│  │                                                                     │
│  ├── Asynchronous Methods                                              │
│  │   ├── ComputeDiffForBlockAsync(block, workspacePath, ct)           │
│  │   │   ├── Reads original file from disk                            │
│  │   │   ├── Handles new file (original doesn't exist)                │
│  │   │   ├── Handles CompleteFile blocks (full replacement)           │
│  │   │   └── Handles Snippet blocks (partial replacement)             │
│  │   │                                                                 │
│  │   └── ComputeMergedDiffAsync(blocks[], workspacePath, ct)          │
│  │       ├── Multiple blocks targeting same file                      │
│  │       └── Merges changes from multiple code blocks                 │
│  │                                                                     │
│  └── Utility Methods                                                   │
│      ├── IsBinaryFile(filePath) → bool                                │
│      └── DetectLineEnding(content) → LineEnding                       │
│                                                                        │
│  DiffOptions                                                           │
│  ├── ContextLines (int) → lines around changes (default: 3)           │
│  ├── ComputeInlineDiffs (bool) → char-level diffs (default: true)     │
│  ├── IgnoreWhitespace (bool) → skip whitespace diffs (default: false) │
│  ├── IgnoreCase (bool) → case-insensitive (default: false)            │
│  ├── TrimTrailingWhitespace (bool) → normalize trailing (default: true)│
│  ├── HunkSeparationThreshold (int) → min unchanged to split (default: 6)│
│  └── MaxInlineDiffLineLength (int) → skip inline for long (default: 500)│
│                                                                        │
│  DiffService (Implementation)                                          │
│  ├── Dependencies                                                      │
│  │   ├── IFileSystemService → read original files                     │
│  │   ├── ILogger<DiffService> → optional logging                      │
│  │   └── DiffPlex.Differ → diff engine                                │
│  │                                                                     │
│  ├── Internal Methods                                                  │
│  │   ├── NormalizeLineEndings(content) → string                       │
│  │   ├── TrimTrailingWhitespace(content) → string                     │
│  │   ├── BuildHunks(diffModel, options) → List<DiffHunk>              │
│  │   ├── CreateDiffLine(origPiece, propPiece) → DiffLine              │
│  │   ├── AddLeadingContext(lines, index, count)                       │
│  │   ├── TrimTrailingContext(lines, count)                            │
│  │   ├── ComputeStats(hunks) → DiffStats                              │
│  │   └── ReplaceLines(content, start, end, replacement) → string      │
│  │                                                                     │
│  └── DiffPlex Integration                                              │
│      ├── Differ → line-level diff computation                         │
│      ├── SideBySideDiffBuilder → aligned line pairs                   │
│      └── LineChunker → split content into lines                       │
│                                                                        │
│  IFileSystemService                                                    │
│  ├── FileExistsAsync(path, ct) → bool                                 │
│  ├── ReadFileAsync(path, ct) → string                                 │
│  ├── ReadFileBytesAsync(path, ct) → byte[]                            │
│  ├── WriteFileAsync(path, content, ct)                                │
│  └── IsBinaryFile(path) → bool                                        │
│                                                                        │
└───────────────────────────────────────────────────────────────────────┘
```

---

## Architecture Diagrams

### Service Dependency Diagram

```
┌─────────────────────────────────────────────────────────────────────────┐
│                          Consumers                                       │
│  ┌─────────────────────┐    ┌─────────────────────┐                     │
│  │ DiffViewerViewModel │    │ CodeBlockViewModel  │                     │
│  │ (v0.4.2d)           │    │ (v0.4.1g)           │                     │
│  └──────────┬──────────┘    └──────────┬──────────┘                     │
│             │                          │                                 │
│             └──────────┬───────────────┘                                 │
│                        │                                                 │
│                        ▼                                                 │
│              ┌─────────────────┐                                        │
│              │  IDiffService   │                                        │
│              └────────┬────────┘                                        │
└───────────────────────┼─────────────────────────────────────────────────┘
                        │
                        │ implements
                        ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                        DiffService                                       │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                         Dependencies                              │   │
│  │  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐  │   │
│  │  │IFileSystemService│  │ DiffOptions     │  │ ILogger         │  │   │
│  │  │ (injected)      │  │ (injected/def)  │  │ (optional)      │  │   │
│  │  └────────┬────────┘  └─────────────────┘  └─────────────────┘  │   │
│  │           │                                                       │   │
│  └───────────┼───────────────────────────────────────────────────────┘   │
│              │                                                           │
│              ▼                                                           │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                    DiffPlex Library                               │   │
│  │  ┌─────────────────┐  ┌─────────────────────────────────────┐   │   │
│  │  │     Differ      │  │    SideBySideDiffBuilder            │   │   │
│  │  │ CreateDiffs()   │  │    BuildDiffModel()                 │   │   │
│  │  └─────────────────┘  └─────────────────────────────────────┘   │   │
│  └─────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────┘
                        │
                        │ produces
                        ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                    DiffResult (v0.4.2a)                                  │
│  ┌──────────────────┐  ┌───────────────────────────────────────────┐   │
│  │    DiffStats     │  │ Hunks: IReadOnlyList<DiffHunk>            │   │
│  │    +5 -2 ~1      │  │  ┌─────────────────────────────────────┐  │   │
│  └──────────────────┘  │  │ DiffHunk[0]                          │  │   │
│                        │  │  Lines: [DiffLine, DiffLine, ...]    │  │   │
│                        │  └─────────────────────────────────────┘  │   │
│                        └───────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────┘
```

### Diff Computation Flow

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    ComputeDiff() Flow                                    │
└─────────────────────────────────────────────────────────────────────────┘

Input: originalContent, proposedContent, filePath, options
                        │
                        ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 1: Preprocessing                                          │
│ ┌─────────────────────────────────────────────────────────┐   │
│ │ NormalizeLineEndings()                                   │   │
│ │   \r\n → \n                                              │   │
│ │   \r → \n                                                │   │
│ └─────────────────────────────────────────────────────────┘   │
│ ┌─────────────────────────────────────────────────────────┐   │
│ │ TrimTrailingWhitespace() (if options.TrimTrailing)      │   │
│ │   "line1   \n" → "line1\n"                               │   │
│ └─────────────────────────────────────────────────────────┘   │
└───────────────────────────────────────────────────────────────┘
                        │
                        ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 2: Quick Identity Check                                   │
│ ┌─────────────────────────────────────────────────────────┐   │
│ │ if (original == proposed)                                │   │
│ │   return DiffResult.NoChanges(filePath, content)        │   │
│ └─────────────────────────────────────────────────────────┘   │
└───────────────────────────────────────────────────────────────┘
                        │
                        ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 3: DiffPlex Line Diff                                     │
│ ┌─────────────────────────────────────────────────────────┐   │
│ │ SideBySideDiffBuilder.BuildDiffModel(original, proposed)│   │
│ │                                                          │   │
│ │ Returns:                                                 │   │
│ │   OldText.Lines[] ←→ NewText.Lines[]                    │   │
│ │   Each line has: Position, Text, Type, SubPieces        │   │
│ └─────────────────────────────────────────────────────────┘   │
└───────────────────────────────────────────────────────────────┘
                        │
                        ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 4: Build Hunks                                            │
│ ┌─────────────────────────────────────────────────────────┐   │
│ │ Iterate through aligned lines:                           │   │
│ │                                                          │   │
│ │ for each (origLine, propLine) pair:                     │   │
│ │   type = DetermineLineType(origLine, propLine)          │   │
│ │                                                          │   │
│ │   if type != Unchanged:                                  │   │
│ │     if !inHunk:                                          │   │
│ │       Start new hunk                                     │   │
│ │       Add leading context (options.ContextLines)        │   │
│ │     Add line to current hunk                            │   │
│ │     unchangedRun = 0                                     │   │
│ │                                                          │   │
│ │   else if inHunk:                                        │   │
│ │     Add unchanged line                                   │   │
│ │     unchangedRun++                                       │   │
│ │                                                          │   │
│ │     if unchangedRun >= HunkSeparationThreshold:         │   │
│ │       Trim trailing context                             │   │
│ │       Close hunk                                         │   │
│ │       Reset for next hunk                               │   │
│ └─────────────────────────────────────────────────────────┘   │
└───────────────────────────────────────────────────────────────┘
                        │
                        ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 5: Compute Statistics                                     │
│ ┌─────────────────────────────────────────────────────────┐   │
│ │ Count lines by type across all hunks:                    │   │
│ │   added = count(DiffLineType.Added)                      │   │
│ │   removed = count(DiffLineType.Removed)                  │   │
│ │   modified = count(DiffLineType.Modified)                │   │
│ │   unchanged = count(DiffLineType.Unchanged)              │   │
│ │                                                          │   │
│ │ Return DiffStats.FromCounts(added, removed, mod, unch)  │   │
│ └─────────────────────────────────────────────────────────┘   │
└───────────────────────────────────────────────────────────────┘
                        │
                        ▼
┌───────────────────────────────────────────────────────────────┐
│ Step 6: Assemble Result                                        │
│ ┌─────────────────────────────────────────────────────────┐   │
│ │ return new DiffResult                                    │   │
│ │ {                                                        │   │
│ │   OriginalFilePath = filePath,                           │   │
│ │   OriginalContent = original,                            │   │
│ │   ProposedContent = proposed,                            │   │
│ │   Hunks = hunks,                                         │   │
│ │   Stats = stats,                                         │   │
│ │   IsNewFile = string.IsNullOrEmpty(original),           │   │
│ │   IsDeleteFile = string.IsNullOrEmpty(proposed)         │   │
│ │ }                                                        │   │
│ └─────────────────────────────────────────────────────────┘   │
└───────────────────────────────────────────────────────────────┘
                        │
                        ▼
                   DiffResult
```

### Hunk Construction Visualization

```
Original Lines                    Proposed Lines                 Hunk State
──────────────────────────────────────────────────────────────────────────────
Line 1: "public class Foo"        Line 1: "public class Foo"     [ ] Unchanged
Line 2: "{"                       Line 2: "{"                    [ ] Unchanged
Line 3: "    int x = 1;"          Line 3: "    int x = 1;"       [ ] Unchanged
Line 4: "    int y = 2;"          Line 4: "    int y = 2;"       [ ] Unchanged
Line 5: "    int z = 3;"          Line 5: "    int z = 3;"       [ ] Unchanged
Line 6: ""                        Line 6: ""                     [ ] Unchanged
Line 7: "    void Old()"          ---                            [-] START HUNK
---                               Line 7: "    void New()"       [+]
Line 8: "    {"                   Line 8: "    {"                [ ] context
Line 9: "        // old"          ---                            [-]
---                               Line 9: "        // new"       [+]
Line 10: "    }"                  Line 10: "    }"               [ ] context
Line 11: ""                       Line 11: ""                    [ ] context → END HUNK
Line 12: "    void Other()"       Line 12: "    void Other()"    [ ] (gap > threshold)
...                               ...
Line 20: "    int a = 0;"         Line 20: "    int a = 1;"      [~] START HUNK 2
Line 21: "}"                      Line 21: "}"                   [ ] context → END HUNK 2

Resulting Hunks:
┌─────────────────────────────────────────────────────────────────┐
│ Hunk 0: @@ -4,8 +4,8 @@                                          │
│   Lines[0]: [ ] "    int y = 2;"      (context, line 4/4)      │
│   Lines[1]: [ ] "    int z = 3;"      (context, line 5/5)      │
│   Lines[2]: [ ] ""                    (context, line 6/6)      │
│   Lines[3]: [-] "    void Old()"      (removed, line 7/-)      │
│   Lines[4]: [+] "    void New()"      (added, line -/7)        │
│   Lines[5]: [ ] "    {"               (context, line 8/8)      │
│   Lines[6]: [-] "        // old"      (removed, line 9/-)      │
│   Lines[7]: [+] "        // new"      (added, line -/9)        │
│   Lines[8]: [ ] "    }"               (context, line 10/10)    │
│   Lines[9]: [ ] ""                    (context, line 11/11)    │
└─────────────────────────────────────────────────────────────────┘
┌─────────────────────────────────────────────────────────────────┐
│ Hunk 1: @@ -17,5 +17,5 @@                                        │
│   Lines[0]: [ ] "    // previous"     (context, line 17/17)    │
│   Lines[1]: [ ] "    // context"      (context, line 18/18)    │
│   Lines[2]: [ ] "    // lines"        (context, line 19/19)    │
│   Lines[3]: [~] "    int a = 0/1;"    (modified, line 20/20)   │
│   Lines[4]: [ ] "}"                   (context, line 21/21)    │
└─────────────────────────────────────────────────────────────────┘
```

### ComputeDiffForBlockAsync Flow

```
┌─────────────────────────────────────────────────────────────────────────┐
│            ComputeDiffForBlockAsync(block, workspacePath, ct)            │
└─────────────────────────────────────────────────────────────────────────┘
                        │
                        ▼
              ┌─────────────────────┐
              │ Validate block has  │
              │ TargetFilePath      │
              └──────────┬──────────┘
                         │
                         ▼
              ┌─────────────────────┐
              │ fullPath = Combine  │
              │ (workspace, target) │
              └──────────┬──────────┘
                         │
                         ▼
              ┌─────────────────────┐
              │ FileExistsAsync?    │
              └──────────┬──────────┘
                         │
           ┌─────────────┴─────────────┐
           │                           │
           ▼ No                        ▼ Yes
┌──────────────────────┐    ┌──────────────────────┐
│ ComputeNewFileDiff   │    │ ReadFileAsync        │
│ (block.Content,      │    │ originalContent      │
│  block.TargetPath)   │    └──────────┬───────────┘
│                      │               │
│ Return DiffResult    │               ▼
│ with IsNewFile=true  │    ┌──────────────────────┐
└──────────────────────┘    │ block.BlockType?     │
                            └──────────┬───────────┘
                                       │
                  ┌────────────────────┼────────────────────┐
                  │                    │                    │
                  ▼ CompleteFile       ▼ Snippet w/Range    ▼ Snippet no Range
       ┌──────────────────┐  ┌──────────────────┐  ┌──────────────────┐
       │ ComputeDiff      │  │ ReplaceLines     │  │ ComputeDiff      │
       │ (original,       │  │ (original,       │  │ (original,       │
       │  block.Content,  │  │  start, end,     │  │  block.Content,  │
       │  filePath)       │  │  block.Content)  │  │  filePath)       │
       │                  │  │                  │  │                  │
       │ Full replacement │  │ Then ComputeDiff │  │ Full replacement │
       └──────────────────┘  │ on merged result │  │ (fallback)       │
                             └──────────────────┘  └──────────────────┘
```

---

## Implementation Details

### 1. IDiffService Interface

```csharp
// src/SeniorIntern.Core/Interfaces/IDiffService.cs

using SeniorIntern.Core.Models;

namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Service for computing diffs between text content.
/// Used to generate side-by-side diff views for code changes.
/// </summary>
public interface IDiffService
{
    /// <summary>
    /// Compute diff between original and proposed content.
    /// </summary>
    /// <param name="originalContent">The original content before changes.</param>
    /// <param name="proposedContent">The proposed content after changes.</param>
    /// <returns>A DiffResult containing hunks and statistics.</returns>
    DiffResult ComputeDiff(string originalContent, string proposedContent);

    /// <summary>
    /// Compute diff with file path context for display.
    /// </summary>
    /// <param name="originalContent">The original content before changes.</param>
    /// <param name="proposedContent">The proposed content after changes.</param>
    /// <param name="filePath">The file path for context (used in DiffResult.OriginalFilePath).</param>
    /// <returns>A DiffResult containing hunks and statistics.</returns>
    DiffResult ComputeDiff(string originalContent, string proposedContent, string filePath);

    /// <summary>
    /// Compute diff with custom options.
    /// </summary>
    /// <param name="originalContent">The original content before changes.</param>
    /// <param name="proposedContent">The proposed content after changes.</param>
    /// <param name="filePath">The file path for context.</param>
    /// <param name="options">Custom diff options.</param>
    /// <returns>A DiffResult containing hunks and statistics.</returns>
    DiffResult ComputeDiff(
        string originalContent,
        string proposedContent,
        string filePath,
        DiffOptions options);

    /// <summary>
    /// Compute diff for a new file (all lines marked as added).
    /// </summary>
    /// <param name="proposedContent">The content of the new file.</param>
    /// <param name="filePath">The target file path.</param>
    /// <returns>A DiffResult with IsNewFile=true and all lines as Added.</returns>
    DiffResult ComputeNewFileDiff(string proposedContent, string filePath);

    /// <summary>
    /// Compute diff for file deletion (all lines marked as removed).
    /// </summary>
    /// <param name="originalContent">The content of the file being deleted.</param>
    /// <param name="filePath">The file path being deleted.</param>
    /// <returns>A DiffResult with IsDeleteFile=true and all lines as Removed.</returns>
    DiffResult ComputeDeleteFileDiff(string originalContent, string filePath);

    /// <summary>
    /// Compute diff for a code block against its target file.
    /// Reads the original file from disk and computes the diff.
    /// </summary>
    /// <param name="block">The code block containing proposed changes.</param>
    /// <param name="workspacePath">The workspace root path.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>A DiffResult comparing the file's current content to the block's proposed content.</returns>
    /// <exception cref="ArgumentException">If block.TargetFilePath is null or empty.</exception>
    Task<DiffResult> ComputeDiffForBlockAsync(
        CodeBlock block,
        string workspacePath,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Compute merged diff for multiple code blocks targeting the same file.
    /// </summary>
    /// <param name="blocks">The code blocks to merge.</param>
    /// <param name="workspacePath">The workspace root path.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>A DiffResult representing all merged changes.</returns>
    /// <exception cref="ArgumentException">If blocks is empty or blocks target different files.</exception>
    Task<DiffResult> ComputeMergedDiffAsync(
        IReadOnlyList<CodeBlock> blocks,
        string workspacePath,
        CancellationToken cancellationToken = default);
}
```

### 2. DiffOptions Model

```csharp
// src/SeniorIntern.Core/Models/DiffOptions.cs

namespace SeniorIntern.Core.Models;

/// <summary>
/// Configuration options for diff computation.
/// </summary>
public sealed class DiffOptions
{
    /// <summary>
    /// Number of unchanged context lines to include around changes.
    /// These lines help provide context for understanding the changes.
    /// </summary>
    /// <remarks>
    /// Standard Git default is 3. Increase for more context, decrease for compact diffs.
    /// </remarks>
    public int ContextLines { get; init; } = 3;

    /// <summary>
    /// Whether to compute inline character-level diffs for modified lines.
    /// When enabled, modified lines will have InlineChanges populated.
    /// </summary>
    /// <remarks>
    /// Inline diffs are computed in v0.4.2c. This option is passed through
    /// to enable/disable that functionality.
    /// </remarks>
    public bool ComputeInlineDiffs { get; init; } = true;

    /// <summary>
    /// Whether to ignore whitespace-only differences.
    /// When true, lines differing only in whitespace are treated as unchanged.
    /// </summary>
    public bool IgnoreWhitespace { get; init; } = false;

    /// <summary>
    /// Whether to ignore case differences.
    /// When true, lines differing only in case are treated as unchanged.
    /// </summary>
    public bool IgnoreCase { get; init; } = false;

    /// <summary>
    /// Whether to trim trailing whitespace before comparison.
    /// Helps normalize files with inconsistent trailing whitespace.
    /// </summary>
    public bool TrimTrailingWhitespace { get; init; } = true;

    /// <summary>
    /// Minimum number of unchanged lines required to separate hunks.
    /// When there are more than this many unchanged lines between changes,
    /// a new hunk is started instead of including all the unchanged lines.
    /// </summary>
    /// <remarks>
    /// Value should be at least (2 * ContextLines) for proper separation.
    /// Default of 6 means changes must be 6+ lines apart to be in separate hunks.
    /// </remarks>
    public int HunkSeparationThreshold { get; init; } = 6;

    /// <summary>
    /// Maximum line length for inline diff computation.
    /// Lines longer than this skip inline diff for performance.
    /// </summary>
    public int MaxInlineDiffLineLength { get; init; } = 500;

    /// <summary>
    /// Minimum similarity ratio (0.0-1.0) for computing inline diffs.
    /// Lines that differ by more than (1 - ratio) are not inline-diffed.
    /// </summary>
    /// <remarks>
    /// At 0.3, lines must be at least 30% similar to get inline diffs.
    /// Lower values produce more inline diffs, higher values fewer.
    /// </remarks>
    public double InlineDiffSimilarityThreshold { get; init; } = 0.3;

    /// <summary>
    /// Default options instance with standard values.
    /// </summary>
    public static DiffOptions Default => new();

    /// <summary>
    /// Options optimized for compact display (fewer context lines).
    /// </summary>
    public static DiffOptions Compact => new()
    {
        ContextLines = 1,
        HunkSeparationThreshold = 4
    };

    /// <summary>
    /// Options optimized for maximum context.
    /// </summary>
    public static DiffOptions Full => new()
    {
        ContextLines = 10,
        HunkSeparationThreshold = 20
    };

    /// <summary>
    /// Options that ignore whitespace differences.
    /// </summary>
    public static DiffOptions IgnoreWhitespaceOptions => new()
    {
        IgnoreWhitespace = true,
        TrimTrailingWhitespace = true
    };
}
```

### 3. IFileSystemService Interface

```csharp
// src/SeniorIntern.Core/Interfaces/IFileSystemService.cs

namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Abstraction for file system operations.
/// Enables testing and potential virtualization of file access.
/// </summary>
public interface IFileSystemService
{
    /// <summary>
    /// Checks if a file exists at the specified path.
    /// </summary>
    /// <param name="path">The absolute file path.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>True if the file exists, false otherwise.</returns>
    Task<bool> FileExistsAsync(string path, CancellationToken cancellationToken = default);

    /// <summary>
    /// Reads the entire content of a text file.
    /// </summary>
    /// <param name="path">The absolute file path.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>The file content as a string.</returns>
    /// <exception cref="FileNotFoundException">If the file does not exist.</exception>
    Task<string> ReadFileAsync(string path, CancellationToken cancellationToken = default);

    /// <summary>
    /// Reads the entire content of a file as bytes.
    /// </summary>
    /// <param name="path">The absolute file path.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>The file content as a byte array.</returns>
    Task<byte[]> ReadFileBytesAsync(string path, CancellationToken cancellationToken = default);

    /// <summary>
    /// Writes content to a file, creating it if it doesn't exist.
    /// </summary>
    /// <param name="path">The absolute file path.</param>
    /// <param name="content">The content to write.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    Task WriteFileAsync(string path, string content, CancellationToken cancellationToken = default);

    /// <summary>
    /// Checks if a file appears to be binary (non-text).
    /// </summary>
    /// <param name="path">The absolute file path.</param>
    /// <returns>True if the file appears to be binary.</returns>
    bool IsBinaryFile(string path);

    /// <summary>
    /// Gets all files matching a pattern in a directory.
    /// </summary>
    /// <param name="directory">The directory to search.</param>
    /// <param name="pattern">The search pattern (e.g., "*.cs").</param>
    /// <param name="recursive">Whether to search subdirectories.</param>
    /// <returns>Collection of matching file paths.</returns>
    IEnumerable<string> GetFiles(string directory, string pattern, bool recursive = false);
}
```

### 4. FileSystemService Implementation

```csharp
// src/SeniorIntern.Services/FileSystemService.cs

using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;

namespace SeniorIntern.Services;

/// <summary>
/// File system operations implementation.
/// </summary>
public sealed class FileSystemService : IFileSystemService
{
    private readonly ILogger<FileSystemService>? _logger;

    // Binary file signatures (magic bytes)
    private static readonly byte[][] BinarySignatures =
    [
        [0x89, 0x50, 0x4E, 0x47], // PNG
        [0xFF, 0xD8, 0xFF],       // JPEG
        [0x47, 0x49, 0x46],       // GIF
        [0x50, 0x4B, 0x03, 0x04], // ZIP/DOCX/etc
        [0x25, 0x50, 0x44, 0x46], // PDF
        [0x7F, 0x45, 0x4C, 0x46], // ELF
        [0x4D, 0x5A],             // EXE/DLL
    ];

    // Binary file extensions
    private static readonly HashSet<string> BinaryExtensions = new(StringComparer.OrdinalIgnoreCase)
    {
        ".png", ".jpg", ".jpeg", ".gif", ".bmp", ".ico", ".webp",
        ".zip", ".tar", ".gz", ".7z", ".rar",
        ".pdf", ".doc", ".docx", ".xls", ".xlsx", ".ppt", ".pptx",
        ".exe", ".dll", ".so", ".dylib",
        ".bin", ".dat", ".db", ".sqlite",
        ".mp3", ".mp4", ".wav", ".avi", ".mkv",
        ".ttf", ".otf", ".woff", ".woff2"
    };

    public FileSystemService(ILogger<FileSystemService>? logger = null)
    {
        _logger = logger;
    }

    public Task<bool> FileExistsAsync(string path, CancellationToken cancellationToken = default)
    {
        cancellationToken.ThrowIfCancellationRequested();
        return Task.FromResult(File.Exists(path));
    }

    public async Task<string> ReadFileAsync(string path, CancellationToken cancellationToken = default)
    {
        _logger?.LogDebug("Reading file: {Path}", path);
        return await File.ReadAllTextAsync(path, cancellationToken);
    }

    public async Task<byte[]> ReadFileBytesAsync(string path, CancellationToken cancellationToken = default)
    {
        _logger?.LogDebug("Reading file bytes: {Path}", path);
        return await File.ReadAllBytesAsync(path, cancellationToken);
    }

    public async Task WriteFileAsync(string path, string content, CancellationToken cancellationToken = default)
    {
        _logger?.LogDebug("Writing file: {Path}", path);

        // Ensure directory exists
        var directory = Path.GetDirectoryName(path);
        if (!string.IsNullOrEmpty(directory) && !Directory.Exists(directory))
        {
            Directory.CreateDirectory(directory);
        }

        await File.WriteAllTextAsync(path, content, cancellationToken);
    }

    public bool IsBinaryFile(string path)
    {
        // Check extension first (fast path)
        var extension = Path.GetExtension(path);
        if (BinaryExtensions.Contains(extension))
        {
            return true;
        }

        // Check file content if it exists
        if (!File.Exists(path))
        {
            return false;
        }

        try
        {
            // Read first few bytes to check for binary signatures
            using var stream = File.OpenRead(path);
            var buffer = new byte[8];
            var bytesRead = stream.Read(buffer, 0, buffer.Length);

            if (bytesRead == 0)
            {
                return false; // Empty file, treat as text
            }

            // Check for known binary signatures
            foreach (var signature in BinarySignatures)
            {
                if (bytesRead >= signature.Length)
                {
                    bool matches = true;
                    for (int i = 0; i < signature.Length; i++)
                    {
                        if (buffer[i] != signature[i])
                        {
                            matches = false;
                            break;
                        }
                    }
                    if (matches) return true;
                }
            }

            // Check for null bytes in first 8KB (common binary indicator)
            stream.Position = 0;
            var checkBuffer = new byte[8192];
            bytesRead = stream.Read(checkBuffer, 0, checkBuffer.Length);

            for (int i = 0; i < bytesRead; i++)
            {
                if (checkBuffer[i] == 0)
                {
                    return true;
                }
            }

            return false;
        }
        catch (Exception ex)
        {
            _logger?.LogWarning(ex, "Error checking if file is binary: {Path}", path);
            return false;
        }
    }

    public IEnumerable<string> GetFiles(string directory, string pattern, bool recursive = false)
    {
        var option = recursive ? SearchOption.AllDirectories : SearchOption.TopDirectoryOnly;
        return Directory.EnumerateFiles(directory, pattern, option);
    }
}
```

### 5. DiffService Implementation

```csharp
// src/SeniorIntern.Services/DiffService.cs

using DiffPlex;
using DiffPlex.DiffBuilder;
using DiffPlex.DiffBuilder.Model;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;

namespace SeniorIntern.Services;

/// <summary>
/// Computes diffs between text content using DiffPlex.
/// </summary>
public sealed class DiffService : IDiffService
{
    private readonly IFileSystemService _fileSystemService;
    private readonly ILogger<DiffService>? _logger;
    private readonly DiffOptions _defaultOptions;

    private readonly Differ _differ;
    private readonly SideBySideDiffBuilder _sideBySideDiffBuilder;

    public DiffService(
        IFileSystemService fileSystemService,
        ILogger<DiffService>? logger = null,
        DiffOptions? defaultOptions = null)
    {
        _fileSystemService = fileSystemService ?? throw new ArgumentNullException(nameof(fileSystemService));
        _logger = logger;
        _defaultOptions = defaultOptions ?? DiffOptions.Default;

        _differ = new Differ();
        _sideBySideDiffBuilder = new SideBySideDiffBuilder(_differ);
    }

    // ═══════════════════════════════════════════════════════════════
    // Public Interface Methods
    // ═══════════════════════════════════════════════════════════════

    public DiffResult ComputeDiff(string originalContent, string proposedContent)
    {
        return ComputeDiff(originalContent, proposedContent, string.Empty, _defaultOptions);
    }

    public DiffResult ComputeDiff(string originalContent, string proposedContent, string filePath)
    {
        return ComputeDiff(originalContent, proposedContent, filePath, _defaultOptions);
    }

    public DiffResult ComputeDiff(
        string originalContent,
        string proposedContent,
        string filePath,
        DiffOptions options)
    {
        _logger?.LogDebug("Computing diff for {FilePath}", filePath);

        // Handle null inputs
        originalContent ??= string.Empty;
        proposedContent ??= string.Empty;

        // Normalize line endings
        originalContent = NormalizeLineEndings(originalContent);
        proposedContent = NormalizeLineEndings(proposedContent);

        // Apply preprocessing options
        if (options.TrimTrailingWhitespace)
        {
            originalContent = TrimTrailingWhitespaceFromLines(originalContent);
            proposedContent = TrimTrailingWhitespaceFromLines(proposedContent);
        }

        // Quick identity check
        if (originalContent == proposedContent)
        {
            _logger?.LogDebug("Content identical, returning no changes");
            return DiffResult.NoChanges(filePath, originalContent);
        }

        // Compute the diff using DiffPlex
        var diffModel = _sideBySideDiffBuilder.BuildDiffModel(originalContent, proposedContent);

        // Convert to our model with hunks
        var hunks = BuildHunks(diffModel, options);

        // Calculate statistics
        var stats = ComputeStats(hunks);

        _logger?.LogDebug("Diff computed: {Stats}", stats.Summary);

        return new DiffResult
        {
            OriginalFilePath = filePath,
            OriginalContent = originalContent,
            ProposedContent = proposedContent,
            Hunks = hunks,
            Stats = stats,
            IsNewFile = string.IsNullOrEmpty(originalContent),
            IsDeleteFile = string.IsNullOrEmpty(proposedContent)
        };
    }

    public DiffResult ComputeNewFileDiff(string proposedContent, string filePath)
    {
        _logger?.LogDebug("Computing new file diff for {FilePath}", filePath);

        proposedContent = NormalizeLineEndings(proposedContent ?? string.Empty);
        var lines = SplitLines(proposedContent);

        var diffLines = lines
            .Select((line, i) => DiffLine.Added(i + 1, line))
            .ToList();

        var hunk = new DiffHunk
        {
            OriginalStartLine = 0,
            OriginalLineCount = 0,
            ProposedStartLine = 1,
            ProposedLineCount = lines.Length,
            Lines = diffLines,
            Index = 0
        };

        return new DiffResult
        {
            OriginalFilePath = filePath,
            OriginalContent = string.Empty,
            ProposedContent = proposedContent,
            Hunks = [hunk],
            Stats = DiffStats.FromCounts(added: lines.Length, removed: 0, modified: 0, unchanged: 0),
            IsNewFile = true
        };
    }

    public DiffResult ComputeDeleteFileDiff(string originalContent, string filePath)
    {
        _logger?.LogDebug("Computing delete file diff for {FilePath}", filePath);

        originalContent = NormalizeLineEndings(originalContent ?? string.Empty);
        var lines = SplitLines(originalContent);

        var diffLines = lines
            .Select((line, i) => DiffLine.Removed(i + 1, line))
            .ToList();

        var hunk = new DiffHunk
        {
            OriginalStartLine = 1,
            OriginalLineCount = lines.Length,
            ProposedStartLine = 0,
            ProposedLineCount = 0,
            Lines = diffLines,
            Index = 0
        };

        return new DiffResult
        {
            OriginalFilePath = filePath,
            OriginalContent = originalContent,
            ProposedContent = string.Empty,
            Hunks = [hunk],
            Stats = DiffStats.FromCounts(added: 0, removed: lines.Length, modified: 0, unchanged: 0),
            IsDeleteFile = true
        };
    }

    public async Task<DiffResult> ComputeDiffForBlockAsync(
        CodeBlock block,
        string workspacePath,
        CancellationToken cancellationToken = default)
    {
        if (string.IsNullOrEmpty(block.TargetFilePath))
        {
            throw new ArgumentException("Code block must have a target file path", nameof(block));
        }

        var fullPath = Path.Combine(workspacePath, block.TargetFilePath);
        _logger?.LogDebug("Computing diff for block targeting {FilePath}", block.TargetFilePath);

        // Check if target file exists
        if (!await _fileSystemService.FileExistsAsync(fullPath, cancellationToken))
        {
            _logger?.LogDebug("Target file does not exist, creating new file diff");
            var result = ComputeNewFileDiff(block.Content, block.TargetFilePath);
            return result with { SourceBlockId = block.Id };
        }

        // Check for binary file
        if (_fileSystemService.IsBinaryFile(fullPath))
        {
            _logger?.LogWarning("Cannot diff binary file: {FilePath}", block.TargetFilePath);
            return DiffResult.BinaryFile(block.TargetFilePath) with { SourceBlockId = block.Id };
        }

        // Read original content
        var originalContent = await _fileSystemService.ReadFileAsync(fullPath, cancellationToken);

        // Determine proposed content based on block type
        string proposedContent;

        if (block.BlockType == CodeBlockType.CompleteFile)
        {
            // Complete file replacement
            proposedContent = block.Content;
        }
        else if (block.ReplacementRange is { } range && range.IsValid)
        {
            // Snippet with specific replacement range
            proposedContent = ReplaceLines(
                originalContent,
                range.StartLine,
                range.EndLine,
                block.Content);
        }
        else
        {
            // Snippet without range - use content as-is (full replacement fallback)
            _logger?.LogDebug("Snippet without replacement range, using full replacement");
            proposedContent = block.Content;
        }

        var diffResult = ComputeDiff(originalContent, proposedContent, block.TargetFilePath);
        return diffResult with { SourceBlockId = block.Id };
    }

    public async Task<DiffResult> ComputeMergedDiffAsync(
        IReadOnlyList<CodeBlock> blocks,
        string workspacePath,
        CancellationToken cancellationToken = default)
    {
        if (blocks.Count == 0)
        {
            throw new ArgumentException("At least one code block is required", nameof(blocks));
        }

        // Single block - just compute directly
        if (blocks.Count == 1)
        {
            return await ComputeDiffForBlockAsync(blocks[0], workspacePath, cancellationToken);
        }

        // Validate all blocks target the same file
        var targetPath = blocks[0].TargetFilePath;
        if (blocks.Any(b => b.TargetFilePath != targetPath))
        {
            throw new ArgumentException("All blocks must target the same file", nameof(blocks));
        }

        _logger?.LogDebug("Computing merged diff for {Count} blocks targeting {FilePath}",
            blocks.Count, targetPath);

        // Strategy: Use the last CompleteFile block if present, otherwise use first block
        // TODO: Implement proper multi-block merging in future version
        var completeFileBlock = blocks.LastOrDefault(b => b.BlockType == CodeBlockType.CompleteFile);
        if (completeFileBlock != null)
        {
            return await ComputeDiffForBlockAsync(completeFileBlock, workspacePath, cancellationToken);
        }

        // Fallback to first block
        _logger?.LogDebug("No CompleteFile block found, using first block");
        return await ComputeDiffForBlockAsync(blocks[0], workspacePath, cancellationToken);
    }

    // ═══════════════════════════════════════════════════════════════
    // Private Helper Methods
    // ═══════════════════════════════════════════════════════════════

    private List<DiffHunk> BuildHunks(SideBySideDiffModel diffModel, DiffOptions options)
    {
        var hunks = new List<DiffHunk>();
        var currentHunkLines = new List<DiffLine>();

        int hunkOrigStart = 1;
        int hunkPropStart = 1;
        int unchangedRun = 0;
        bool inHunk = false;
        int hunkIndex = 0;

        var originalLines = diffModel.OldText.Lines;
        var proposedLines = diffModel.NewText.Lines;
        int maxLines = Math.Max(originalLines.Count, proposedLines.Count);

        for (int i = 0; i < maxLines; i++)
        {
            var origPiece = i < originalLines.Count ? originalLines[i] : null;
            var propPiece = i < proposedLines.Count ? proposedLines[i] : null;

            var lineType = DetermineLineType(origPiece, propPiece);
            var diffLine = CreateDiffLine(origPiece, propPiece, lineType);

            if (lineType != DiffLineType.Unchanged)
            {
                // Start or continue a hunk
                if (!inHunk)
                {
                    inHunk = true;

                    // Calculate hunk start positions
                    hunkOrigStart = Math.Max(1, (diffLine.OriginalLineNumber ?? diffLine.ProposedLineNumber ?? 1) - options.ContextLines);
                    hunkPropStart = Math.Max(1, (diffLine.ProposedLineNumber ?? diffLine.OriginalLineNumber ?? 1) - options.ContextLines);

                    // Add leading context lines
                    AddLeadingContext(currentHunkLines, originalLines, proposedLines, i, options.ContextLines);
                }

                currentHunkLines.Add(diffLine);
                unchangedRun = 0;
            }
            else if (inHunk)
            {
                currentHunkLines.Add(diffLine);
                unchangedRun++;

                // Check if we should close the hunk
                if (unchangedRun >= options.HunkSeparationThreshold)
                {
                    // Trim trailing context and close hunk
                    TrimTrailingContext(currentHunkLines, options.ContextLines);

                    if (currentHunkLines.Any(l => l.Type != DiffLineType.Unchanged))
                    {
                        hunks.Add(CreateHunk(hunkOrigStart, hunkPropStart, currentHunkLines, hunkIndex++));
                    }

                    currentHunkLines = [];
                    inHunk = false;
                    unchangedRun = 0;
                }
            }
        }

        // Close any remaining hunk
        if (currentHunkLines.Count > 0 && currentHunkLines.Any(l => l.Type != DiffLineType.Unchanged))
        {
            TrimTrailingContext(currentHunkLines, options.ContextLines);
            hunks.Add(CreateHunk(hunkOrigStart, hunkPropStart, currentHunkLines, hunkIndex));
        }

        return hunks;
    }

    private static DiffLineType DetermineLineType(DiffPiece? origPiece, DiffPiece? propPiece)
    {
        // Handle null cases (lines that only exist on one side)
        if (origPiece?.Type == ChangeType.Imaginary && propPiece?.Type == ChangeType.Inserted)
            return DiffLineType.Added;

        if (origPiece?.Type == ChangeType.Deleted && propPiece?.Type == ChangeType.Imaginary)
            return DiffLineType.Removed;

        // Handle explicit change types
        if (origPiece?.Type == ChangeType.Deleted)
            return DiffLineType.Removed;

        if (propPiece?.Type == ChangeType.Inserted)
            return DiffLineType.Added;

        if (origPiece?.Type == ChangeType.Modified || propPiece?.Type == ChangeType.Modified)
            return DiffLineType.Modified;

        return DiffLineType.Unchanged;
    }

    private static DiffLine CreateDiffLine(DiffPiece? origPiece, DiffPiece? propPiece, DiffLineType type)
    {
        var content = type switch
        {
            DiffLineType.Removed => origPiece?.Text ?? string.Empty,
            DiffLineType.Added => propPiece?.Text ?? string.Empty,
            _ => origPiece?.Text ?? propPiece?.Text ?? string.Empty
        };

        int? origLineNum = origPiece?.Type != ChangeType.Imaginary ? origPiece?.Position : null;
        int? propLineNum = propPiece?.Type != ChangeType.Imaginary ? propPiece?.Position : null;

        return new DiffLine
        {
            OriginalLineNumber = origLineNum,
            ProposedLineNumber = propLineNum,
            Content = content,
            Type = type
        };
    }

    private static void AddLeadingContext(
        List<DiffLine> hunkLines,
        IList<DiffPiece> originalLines,
        IList<DiffPiece> proposedLines,
        int currentIndex,
        int contextLines)
    {
        int startIndex = Math.Max(0, currentIndex - contextLines);

        for (int i = startIndex; i < currentIndex; i++)
        {
            var origPiece = i < originalLines.Count ? originalLines[i] : null;
            var propPiece = i < proposedLines.Count ? proposedLines[i] : null;

            // Only add if it's actually an unchanged line
            if (origPiece?.Type == ChangeType.Unchanged)
            {
                hunkLines.Add(DiffLine.Unchanged(
                    origPiece.Position ?? i + 1,
                    propPiece?.Position ?? i + 1,
                    origPiece.Text ?? string.Empty));
            }
        }
    }

    private static void TrimTrailingContext(List<DiffLine> hunkLines, int maxContext)
    {
        int trailingUnchanged = 0;
        for (int i = hunkLines.Count - 1; i >= 0; i--)
        {
            if (hunkLines[i].Type == DiffLineType.Unchanged)
                trailingUnchanged++;
            else
                break;
        }

        int toRemove = Math.Max(0, trailingUnchanged - maxContext);
        if (toRemove > 0)
        {
            hunkLines.RemoveRange(hunkLines.Count - toRemove, toRemove);
        }
    }

    private static DiffHunk CreateHunk(int origStart, int propStart, List<DiffLine> lines, int index)
    {
        // Count lines that appear on each side
        int origCount = lines.Count(l => l.Type is DiffLineType.Unchanged or DiffLineType.Removed or DiffLineType.Modified);
        int propCount = lines.Count(l => l.Type is DiffLineType.Unchanged or DiffLineType.Added or DiffLineType.Modified);

        return new DiffHunk
        {
            OriginalStartLine = origStart,
            OriginalLineCount = origCount,
            ProposedStartLine = propStart,
            ProposedLineCount = propCount,
            Lines = lines.ToList(),
            Index = index
        };
    }

    private static DiffStats ComputeStats(IReadOnlyList<DiffHunk> hunks)
    {
        int added = 0, removed = 0, modified = 0, unchanged = 0;

        foreach (var hunk in hunks)
        {
            foreach (var line in hunk.Lines)
            {
                switch (line.Type)
                {
                    case DiffLineType.Added: added++; break;
                    case DiffLineType.Removed: removed++; break;
                    case DiffLineType.Modified: modified++; break;
                    case DiffLineType.Unchanged: unchanged++; break;
                }
            }
        }

        return DiffStats.FromCounts(added, removed, modified, unchanged);
    }

    private static string ReplaceLines(string content, int startLine, int endLine, string replacement)
    {
        var lines = SplitLines(content).ToList();
        var replacementLines = SplitLines(replacement);

        // Validate range (1-based line numbers)
        if (startLine < 1)
            throw new ArgumentOutOfRangeException(nameof(startLine), "Start line must be >= 1");
        if (startLine > lines.Count + 1)
            throw new ArgumentOutOfRangeException(nameof(startLine), "Start line exceeds file length");
        if (endLine < startLine)
            throw new ArgumentOutOfRangeException(nameof(endLine), "End line must be >= start line");

        // Clamp end line to file length
        endLine = Math.Min(endLine, lines.Count);

        // Remove old lines (convert to 0-based index)
        int removeCount = endLine - startLine + 1;
        if (removeCount > 0 && startLine <= lines.Count)
        {
            lines.RemoveRange(startLine - 1, Math.Min(removeCount, lines.Count - startLine + 1));
        }

        // Insert new lines
        lines.InsertRange(startLine - 1, replacementLines);

        return string.Join("\n", lines);
    }

    // ═══════════════════════════════════════════════════════════════
    // Text Processing Utilities
    // ═══════════════════════════════════════════════════════════════

    private static string NormalizeLineEndings(string text)
    {
        return text.Replace("\r\n", "\n").Replace("\r", "\n");
    }

    private static string TrimTrailingWhitespaceFromLines(string text)
    {
        var lines = SplitLines(text);
        return string.Join("\n", lines.Select(l => l.TrimEnd()));
    }

    private static string[] SplitLines(string text)
    {
        return text.Split('\n');
    }
}
```

---

## Files Summary

### Files to Create

| File | Purpose | Lines (Est.) |
|------|---------|--------------|
| `src/SeniorIntern.Core/Interfaces/IDiffService.cs` | Diff service interface | ~80 |
| `src/SeniorIntern.Core/Interfaces/IFileSystemService.cs` | File system abstraction | ~60 |
| `src/SeniorIntern.Core/Models/DiffOptions.cs` | Configuration options | ~90 |
| `src/SeniorIntern.Services/DiffService.cs` | DiffPlex-based implementation | ~350 |
| `src/SeniorIntern.Services/FileSystemService.cs` | File system implementation | ~120 |

### Files to Modify

| File | Changes |
|------|---------|
| `Directory.Packages.props` | Add DiffPlex 1.7.2 package reference |
| `src/SeniorIntern.Services/SeniorIntern.Services.csproj` | Add DiffPlex PackageReference |
| `src/SeniorIntern.Desktop/Extensions/ServiceCollectionExtensions.cs` | Register IDiffService, IFileSystemService |

---

## Testing Strategy

### Unit Tests

```csharp
// tests/SeniorIntern.Services.Tests/DiffServiceTests.cs

namespace SeniorIntern.Services.Tests;

public class DiffServiceTests
{
    private readonly Mock<IFileSystemService> _fileSystemMock;
    private readonly DiffService _service;

    public DiffServiceTests()
    {
        _fileSystemMock = new Mock<IFileSystemService>();
        _service = new DiffService(_fileSystemMock.Object);
    }

    // ═══════════════════════════════════════════════════════════════
    // ComputeDiff - Basic Tests
    // ═══════════════════════════════════════════════════════════════

    [Fact]
    public void ComputeDiff_IdenticalContent_ReturnsNoChanges()
    {
        var content = "line1\nline2\nline3";
        var result = _service.ComputeDiff(content, content);

        Assert.False(result.HasChanges);
        Assert.Empty(result.Hunks);
        Assert.Equal(0, result.Stats.AddedLines);
        Assert.Equal(0, result.Stats.RemovedLines);
    }

    [Fact]
    public void ComputeDiff_EmptyToContent_MarksAllAsAdded()
    {
        var result = _service.ComputeDiff("", "line1\nline2");

        Assert.True(result.HasChanges);
        Assert.Equal(2, result.Stats.AddedLines);
        Assert.True(result.IsNewFile);
    }

    [Fact]
    public void ComputeDiff_ContentToEmpty_MarksAllAsRemoved()
    {
        var result = _service.ComputeDiff("line1\nline2", "");

        Assert.True(result.HasChanges);
        Assert.Equal(2, result.Stats.RemovedLines);
        Assert.True(result.IsDeleteFile);
    }

    [Fact]
    public void ComputeDiff_WithFilePath_SetsOriginalFilePath()
    {
        var result = _service.ComputeDiff("old", "new", "test.cs");

        Assert.Equal("test.cs", result.OriginalFilePath);
    }

    // ═══════════════════════════════════════════════════════════════
    // ComputeDiff - Addition Tests
    // ═══════════════════════════════════════════════════════════════

    [Fact]
    public void ComputeDiff_AddedLines_ReturnsCorrectStats()
    {
        var original = "line1\nline2";
        var proposed = "line1\nline2\nline3\nline4";

        var result = _service.ComputeDiff(original, proposed);

        Assert.True(result.HasChanges);
        Assert.Equal(2, result.Stats.AddedLines);
        Assert.Equal(0, result.Stats.RemovedLines);
    }

    [Fact]
    public void ComputeDiff_AddedLineInMiddle_CreatesHunk()
    {
        var original = "line1\nline3";
        var proposed = "line1\nline2\nline3";

        var result = _service.ComputeDiff(original, proposed);

        Assert.Single(result.Hunks);
        Assert.Equal(1, result.Stats.AddedLines);
    }

    // ═══════════════════════════════════════════════════════════════
    // ComputeDiff - Removal Tests
    // ═══════════════════════════════════════════════════════════════

    [Fact]
    public void ComputeDiff_RemovedLines_ReturnsCorrectStats()
    {
        var original = "line1\nline2\nline3";
        var proposed = "line1";

        var result = _service.ComputeDiff(original, proposed);

        Assert.True(result.HasChanges);
        Assert.Equal(2, result.Stats.RemovedLines);
    }

    [Fact]
    public void ComputeDiff_RemovedLineInMiddle_CreatesHunk()
    {
        var original = "line1\nline2\nline3";
        var proposed = "line1\nline3";

        var result = _service.ComputeDiff(original, proposed);

        Assert.Single(result.Hunks);
        Assert.Equal(1, result.Stats.RemovedLines);
    }

    // ═══════════════════════════════════════════════════════════════
    // ComputeDiff - Hunk Tests
    // ═══════════════════════════════════════════════════════════════

    [Fact]
    public void ComputeDiff_CreatesHunksWithContext()
    {
        var original = string.Join("\n", Enumerable.Range(1, 20).Select(i => $"line{i}"));
        var proposed = original.Replace("line10", "modified10");

        var result = _service.ComputeDiff(original, proposed);

        Assert.Single(result.Hunks);
        var hunk = result.Hunks[0];

        // Should include context lines around the change
        Assert.True(hunk.Lines.Count >= 4); // At least change + some context
        Assert.Contains(hunk.Lines, l => l.Type == DiffLineType.Unchanged);
    }

    [Fact]
    public void ComputeDiff_DistantChanges_CreatesSeparateHunks()
    {
        var lines = Enumerable.Range(1, 30).Select(i => $"line{i}").ToList();
        lines[5] = "modified5";  // Change at line 6
        lines[25] = "modified25"; // Change at line 26

        var original = string.Join("\n", Enumerable.Range(1, 30).Select(i => $"line{i}"));
        var proposed = string.Join("\n", lines);

        var result = _service.ComputeDiff(original, proposed);

        // Changes are far apart (20 lines), should create separate hunks
        Assert.Equal(2, result.Hunks.Count);
    }

    [Fact]
    public void ComputeDiff_CloseChanges_CreatesSingleHunk()
    {
        var lines = Enumerable.Range(1, 20).Select(i => $"line{i}").ToList();
        lines[5] = "modified5";   // Change at line 6
        lines[8] = "modified8";   // Change at line 9 (only 3 lines apart)

        var original = string.Join("\n", Enumerable.Range(1, 20).Select(i => $"line{i}"));
        var proposed = string.Join("\n", lines);

        var result = _service.ComputeDiff(original, proposed);

        // Changes are close together, should be in same hunk
        Assert.Single(result.Hunks);
    }

    [Fact]
    public void ComputeDiff_HunkHeader_FormatsCorrectly()
    {
        var original = string.Join("\n", Enumerable.Range(1, 10).Select(i => $"line{i}"));
        var proposed = original.Replace("line5", "modified5");

        var result = _service.ComputeDiff(original, proposed);

        Assert.Single(result.Hunks);
        Assert.Contains("@@", result.Hunks[0].Header);
    }

    // ═══════════════════════════════════════════════════════════════
    // ComputeDiff - Line Ending Tests
    // ═══════════════════════════════════════════════════════════════

    [Fact]
    public void ComputeDiff_NormalizesLineEndings_CRLF()
    {
        var original = "line1\r\nline2";
        var proposed = "line1\nline2";

        var result = _service.ComputeDiff(original, proposed);

        // Should be identical after normalization
        Assert.False(result.HasChanges);
    }

    [Fact]
    public void ComputeDiff_NormalizesLineEndings_CR()
    {
        var original = "line1\rline2";
        var proposed = "line1\nline2";

        var result = _service.ComputeDiff(original, proposed);

        Assert.False(result.HasChanges);
    }

    // ═══════════════════════════════════════════════════════════════
    // ComputeDiff - Whitespace Tests
    // ═══════════════════════════════════════════════════════════════

    [Fact]
    public void ComputeDiff_TrimsTrailingWhitespace_ByDefault()
    {
        var original = "line1   \nline2  ";
        var proposed = "line1\nline2";

        var result = _service.ComputeDiff(original, proposed);

        // Should be identical after trimming
        Assert.False(result.HasChanges);
    }

    [Fact]
    public void ComputeDiff_PreservesTrailingWhitespace_WhenOptionDisabled()
    {
        var original = "line1   \nline2";
        var proposed = "line1\nline2";
        var options = new DiffOptions { TrimTrailingWhitespace = false };

        var result = _service.ComputeDiff(original, proposed, "", options);

        // Should detect the whitespace difference
        Assert.True(result.HasChanges);
    }

    // ═══════════════════════════════════════════════════════════════
    // ComputeNewFileDiff Tests
    // ═══════════════════════════════════════════════════════════════

    [Fact]
    public void ComputeNewFileDiff_AllLinesAdded()
    {
        var result = _service.ComputeNewFileDiff("line1\nline2\nline3", "new.cs");

        Assert.True(result.IsNewFile);
        Assert.Equal(3, result.Stats.AddedLines);
        Assert.Equal(0, result.Stats.RemovedLines);
        Assert.Single(result.Hunks);
        Assert.All(result.Hunks[0].Lines, l => Assert.Equal(DiffLineType.Added, l.Type));
    }

    [Fact]
    public void ComputeNewFileDiff_SetsFilePath()
    {
        var result = _service.ComputeNewFileDiff("content", "path/to/file.cs");

        Assert.Equal("path/to/file.cs", result.OriginalFilePath);
    }

    [Fact]
    public void ComputeNewFileDiff_EmptyContent_CreatesEmptyHunk()
    {
        var result = _service.ComputeNewFileDiff("", "empty.cs");

        Assert.True(result.IsNewFile);
        Assert.Single(result.Hunks);
    }

    // ═══════════════════════════════════════════════════════════════
    // ComputeDeleteFileDiff Tests
    // ═══════════════════════════════════════════════════════════════

    [Fact]
    public void ComputeDeleteFileDiff_AllLinesRemoved()
    {
        var result = _service.ComputeDeleteFileDiff("line1\nline2\nline3", "deleted.cs");

        Assert.True(result.IsDeleteFile);
        Assert.Equal(3, result.Stats.RemovedLines);
        Assert.Equal(0, result.Stats.AddedLines);
        Assert.Single(result.Hunks);
        Assert.All(result.Hunks[0].Lines, l => Assert.Equal(DiffLineType.Removed, l.Type));
    }

    // ═══════════════════════════════════════════════════════════════
    // ComputeDiffForBlockAsync Tests
    // ═══════════════════════════════════════════════════════════════

    [Fact]
    public async Task ComputeDiffForBlockAsync_ThrowsIfNoTargetPath()
    {
        var block = new CodeBlock { TargetFilePath = null };

        await Assert.ThrowsAsync<ArgumentException>(() =>
            _service.ComputeDiffForBlockAsync(block, "/workspace"));
    }

    [Fact]
    public async Task ComputeDiffForBlockAsync_NewFile_ReturnsNewFileDiff()
    {
        var block = new CodeBlock
        {
            TargetFilePath = "new.cs",
            Content = "new content",
            BlockType = CodeBlockType.CompleteFile
        };

        _fileSystemMock.Setup(f => f.FileExistsAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(false);

        var result = await _service.ComputeDiffForBlockAsync(block, "/workspace");

        Assert.True(result.IsNewFile);
        Assert.Equal(block.Id, result.SourceBlockId);
    }

    [Fact]
    public async Task ComputeDiffForBlockAsync_ExistingFile_ComputesDiff()
    {
        var block = new CodeBlock
        {
            TargetFilePath = "existing.cs",
            Content = "new content",
            BlockType = CodeBlockType.CompleteFile
        };

        _fileSystemMock.Setup(f => f.FileExistsAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(true);
        _fileSystemMock.Setup(f => f.IsBinaryFile(It.IsAny<string>()))
            .Returns(false);
        _fileSystemMock.Setup(f => f.ReadFileAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync("old content");

        var result = await _service.ComputeDiffForBlockAsync(block, "/workspace");

        Assert.True(result.HasChanges);
        Assert.Equal(block.Id, result.SourceBlockId);
    }

    [Fact]
    public async Task ComputeDiffForBlockAsync_BinaryFile_ReturnsBinaryResult()
    {
        var block = new CodeBlock
        {
            TargetFilePath = "image.png",
            Content = "data",
            BlockType = CodeBlockType.CompleteFile
        };

        _fileSystemMock.Setup(f => f.FileExistsAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(true);
        _fileSystemMock.Setup(f => f.IsBinaryFile(It.IsAny<string>()))
            .Returns(true);

        var result = await _service.ComputeDiffForBlockAsync(block, "/workspace");

        Assert.True(result.IsBinaryFile);
        Assert.False(result.IsApplicable);
    }

    // ═══════════════════════════════════════════════════════════════
    // ComputeMergedDiffAsync Tests
    // ═══════════════════════════════════════════════════════════════

    [Fact]
    public async Task ComputeMergedDiffAsync_ThrowsOnEmptyList()
    {
        await Assert.ThrowsAsync<ArgumentException>(() =>
            _service.ComputeMergedDiffAsync([], "/workspace"));
    }

    [Fact]
    public async Task ComputeMergedDiffAsync_ThrowsOnDifferentTargets()
    {
        var blocks = new[]
        {
            new CodeBlock { TargetFilePath = "file1.cs" },
            new CodeBlock { TargetFilePath = "file2.cs" }
        };

        await Assert.ThrowsAsync<ArgumentException>(() =>
            _service.ComputeMergedDiffAsync(blocks, "/workspace"));
    }

    [Fact]
    public async Task ComputeMergedDiffAsync_SingleBlock_DelegatesToComputeDiffForBlock()
    {
        var block = new CodeBlock
        {
            TargetFilePath = "test.cs",
            Content = "content",
            BlockType = CodeBlockType.CompleteFile
        };

        _fileSystemMock.Setup(f => f.FileExistsAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(false);

        var result = await _service.ComputeMergedDiffAsync([block], "/workspace");

        Assert.True(result.IsNewFile);
    }
}
```

```csharp
// tests/SeniorIntern.Services.Tests/FileSystemServiceTests.cs

namespace SeniorIntern.Services.Tests;

public class FileSystemServiceTests
{
    private readonly FileSystemService _service;

    public FileSystemServiceTests()
    {
        _service = new FileSystemService();
    }

    [Theory]
    [InlineData(".png", true)]
    [InlineData(".jpg", true)]
    [InlineData(".exe", true)]
    [InlineData(".zip", true)]
    [InlineData(".cs", false)]
    [InlineData(".txt", false)]
    [InlineData(".json", false)]
    public void IsBinaryFile_ChecksExtension(string extension, bool expected)
    {
        var path = $"test{extension}";
        // Note: Only checks extension when file doesn't exist
        var result = _service.IsBinaryFile(path);
        Assert.Equal(expected, result);
    }
}
```

```csharp
// tests/SeniorIntern.Core.Tests/Models/DiffOptionsTests.cs

namespace SeniorIntern.Core.Tests.Models;

public class DiffOptionsTests
{
    [Fact]
    public void Default_HasExpectedValues()
    {
        var options = DiffOptions.Default;

        Assert.Equal(3, options.ContextLines);
        Assert.True(options.ComputeInlineDiffs);
        Assert.False(options.IgnoreWhitespace);
        Assert.False(options.IgnoreCase);
        Assert.True(options.TrimTrailingWhitespace);
        Assert.Equal(6, options.HunkSeparationThreshold);
        Assert.Equal(500, options.MaxInlineDiffLineLength);
    }

    [Fact]
    public void Compact_HasFewerContextLines()
    {
        var options = DiffOptions.Compact;

        Assert.Equal(1, options.ContextLines);
        Assert.Equal(4, options.HunkSeparationThreshold);
    }

    [Fact]
    public void Full_HasMoreContextLines()
    {
        var options = DiffOptions.Full;

        Assert.Equal(10, options.ContextLines);
        Assert.Equal(20, options.HunkSeparationThreshold);
    }

    [Fact]
    public void IgnoreWhitespaceOptions_IgnoresWhitespace()
    {
        var options = DiffOptions.IgnoreWhitespaceOptions;

        Assert.True(options.IgnoreWhitespace);
        Assert.True(options.TrimTrailingWhitespace);
    }
}
```

### Test Summary

| Test Class | Test Count |
|------------|------------|
| DiffServiceTests | 25 |
| FileSystemServiceTests | 1 (parameterized with 7 cases) |
| DiffOptionsTests | 4 |
| **Total** | **30+** |

---

## Acceptance Criteria

### Must Have

- [ ] IDiffService interface defines all required methods
- [ ] DiffService computes correct diffs for additions
- [ ] DiffService computes correct diffs for removals
- [ ] DiffService computes correct diffs for modifications
- [ ] Identical content returns HasChanges=false with empty hunks
- [ ] Line endings are normalized (CRLF/CR → LF)
- [ ] Trailing whitespace trimming works when enabled
- [ ] Hunks include correct context lines (default 3)
- [ ] Multiple distant changes create separate hunks
- [ ] Close changes are grouped into single hunk
- [ ] ComputeNewFileDiff marks all lines as Added, sets IsNewFile=true
- [ ] ComputeDeleteFileDiff marks all lines as Removed, sets IsDeleteFile=true
- [ ] ComputeDiffForBlockAsync reads original file from disk
- [ ] ComputeDiffForBlockAsync handles non-existent files (new file)
- [ ] ComputeDiffForBlockAsync handles binary files correctly
- [ ] ComputeDiffForBlockAsync sets SourceBlockId on result
- [ ] DiffStats are accurately calculated
- [ ] IFileSystemService abstraction enables testing
- [ ] DiffPlex package is properly integrated

### Should Have

- [ ] DiffOptions.IgnoreWhitespace option works
- [ ] DiffOptions.IgnoreCase option works
- [ ] ComputeMergedDiffAsync handles multiple blocks
- [ ] Context header extraction for hunks (function names)
- [ ] Logging at appropriate levels

### Could Have

- [ ] Caching of computed diffs
- [ ] Parallel diff computation for multiple files
- [ ] Custom chunker support (word-level, character-level)

---

## Dependencies

### NuGet Packages

| Package | Version | Purpose |
|---------|---------|---------|
| DiffPlex | 1.7.2+ | Line-level and character-level diff computation |

### Package Installation

Add to `Directory.Packages.props`:
```xml
<PackageVersion Include="DiffPlex" Version="1.7.2" />
```

Add to `SeniorIntern.Services.csproj`:
```xml
<PackageReference Include="DiffPlex" />
```

---

## Integration Points

### Upstream (Dependencies)

| Component | Usage |
|-----------|-------|
| DiffResult (v0.4.2a) | Output model for computed diffs |
| DiffHunk (v0.4.2a) | Hunk grouping model |
| DiffLine (v0.4.2a) | Line diff model |
| DiffStats (v0.4.2a) | Statistics model |
| CodeBlock (v0.4.1a) | Input for ComputeDiffForBlockAsync |
| CodeBlockType (v0.4.1a) | Determines diff computation strategy |

### Downstream (Consumers)

| Component | Usage |
|-----------|-------|
| IInlineDiffService (v0.4.2c) | Extends DiffService with inline diffs |
| DiffViewerViewModel (v0.4.2d) | Consumes DiffResult for UI |
| CodeBlockViewModel (v0.4.1g) | Calls ComputeDiffForBlockAsync |

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| DiffPlex version incompatibility | Low | Medium | Pin version, test thoroughly |
| Large file performance | Medium | Medium | Add size limits, async processing |
| Hunk boundary edge cases | Medium | Low | Comprehensive test coverage |
| Line number off-by-one | Medium | High | Clear 1-based documentation, tests |
| Binary file detection false positives | Low | Low | Multiple detection strategies |
| Memory pressure with large diffs | Low | Medium | Stream processing for huge files |

---

## Future Enhancements

The following are explicitly out of scope for v0.4.2b but documented for future consideration:

1. **Semantic diff** (v0.5.x) - Understand code structure for better diff grouping
2. **Three-way merge** (v0.5.x) - Support for merge conflicts
3. **Diff caching** (v0.5.x) - Cache computed diffs for performance
4. **Custom chunkers** (v0.5.x) - Word-level or token-level diff options
5. **Ignore patterns** (v0.5.x) - Ignore comments, whitespace patterns

---

## References

- [v0.4.2-diff-engine.md](v0.4.2-diff-engine.md) - Parent specification
- [v0.4.2a-diff-models.md](v0.4.2a-diff-models.md) - Data model specification
- [DiffPlex GitHub](https://github.com/mmanela/diffplex) - Diff library
- [Unified diff format](https://www.gnu.org/software/diffutils/manual/html_node/Detailed-Unified.html) - Format reference

---

**Proceed to v0.4.2c: Inline Diff**
- Create IInlineDiffService interface
- Implement character-level diff computation
- Compute inline changes for modified line pairs
- Integrate with DiffService hunk building
