# v0.4.3e: Conflict Detection - Design Specification

**Status**: _IMPLEMENTED_

## Executive Summary

This specification details the implementation of the **Conflict Detection** system for The Senior Intern's Apply Changes Workflow. The ConflictDetector provides snapshot-based file state tracking to detect when files have been modified between proposal generation and apply time, preventing accidental overwrites of user changes.

### Key Deliverables
- `ConflictDetector` class with file snapshot management
- `FileSnapshot` internal class for capturing file state
- `ConflictInfo` model for conflict detection results
- `ConflictReason` enumeration for specific conflict types
- SHA-256 content hashing for reliable change detection
- Thread-safe snapshot storage with `ConcurrentDictionary`

---

## Feature Overview

```
v0.4.3e: Conflict Detection
├── Core Components
│   ├── ConflictDetector (snapshot management and conflict checking)
│   ├── FileSnapshot (internal file state capture)
│   ├── ConflictInfo (conflict detection result)
│   └── ConflictReason (enumeration of conflict types)
├── Operations
│   ├── TakeSnapshotAsync (capture current file state)
│   ├── CheckConflictAsync (compare snapshot to current state)
│   ├── ClearSnapshot (remove single snapshot)
│   └── ClearAllSnapshots (remove all snapshots)
├── Detection Scenarios
│   ├── Content Modified (hash mismatch)
│   ├── File Created (non-existent → exists)
│   ├── File Deleted (exists → non-existent)
│   └── No Snapshot (missing baseline)
└── Thread Safety
    └── ConcurrentDictionary for snapshot storage
```

---

## Architecture Diagrams

### Component Interaction

```
┌─────────────────────────────────────────────────────────────────┐
│                     Apply Changes Workflow                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌──────────────────┐    ┌─────────────────────┐                │
│  │ FileChangeService│───▶│  ConflictDetector   │                │
│  └──────────────────┘    └─────────────────────┘                │
│           │                       │                              │
│           │                       ▼                              │
│           │              ┌─────────────────────┐                │
│           │              │ ConcurrentDictionary │                │
│           │              │  <string, Snapshot>  │                │
│           │              └─────────────────────┘                │
│           │                       │                              │
│           ▼                       ▼                              │
│  ┌──────────────────┐    ┌─────────────────────┐                │
│  │ IFileSystemService│◀──│    FileSnapshot     │                │
│  └──────────────────┘    └─────────────────────┘                │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Snapshot Lifecycle

```
┌─────────────────────────────────────────────────────────────────┐
│                     Snapshot Lifecycle                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   Proposal Generated          User Edits File         Apply      │
│          │                          │                    │       │
│          ▼                          ▼                    ▼       │
│   ┌──────────────┐           ┌──────────────┐    ┌───────────┐  │
│   │ Take Snapshot │           │ File Modified│    │Check      │  │
│   │ (Hash: abc123)│           │ (Hash: xyz789)│   │Conflict   │  │
│   └──────────────┘           └──────────────┘    └───────────┘  │
│          │                          │                    │       │
│          │                          │                    ▼       │
│          │                          │            ┌───────────┐  │
│          └──────────────────────────┴───────────▶│ CONFLICT! │  │
│                     Hash Mismatch                │ abc ≠ xyz │  │
│                                                  └───────────┘  │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Conflict Detection Flow

```
┌─────────────────────────────────────────────────────────────────┐
│                   Conflict Detection Flow                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│              CheckConflictAsync(filePath)                        │
│                          │                                       │
│                          ▼                                       │
│                 ┌─────────────────┐                             │
│                 │ Snapshot exists?│                             │
│                 └────────┬────────┘                             │
│                    No    │    Yes                               │
│              ┌───────────┴───────────┐                          │
│              ▼                       ▼                          │
│    ┌──────────────────┐    ┌─────────────────┐                 │
│    │ Return NoSnapshot│    │ Check file exists│                 │
│    │ (No conflict)    │    └────────┬────────┘                 │
│    └──────────────────┘             │                           │
│                          ┌──────────┴──────────┐                │
│                          ▼                     ▼                │
│               Snapshot.Exists=false   Snapshot.Exists=true      │
│                     │                         │                  │
│              ┌──────┴──────┐          ┌───────┴───────┐         │
│              ▼             ▼          ▼               ▼         │
│         File exists?  File exists?  File exists?  File exists?  │
│           Yes   No      No   Yes      No    Yes     No    Yes   │
│            │    │       │     │       │      │      │      │    │
│            ▼    ▼       ▼     ▼       ▼      ▼      ▼      ▼    │
│       FileCreated  OK   OK  N/A   FileDeleted  ─────┘   Compare │
│       (conflict)            (impossible)                Hash    │
│                                    │                      │     │
│                                    ▼                      ▼     │
│                             ContentModified?        Same = OK   │
│                             (hash mismatch)         Diff = ⚠    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## Detailed Design

### 1. ConflictReason Enumeration

```csharp
// src/SeniorIntern.Services/Enums/ConflictReason.cs
namespace SeniorIntern.Services.Enums;

/// <summary>
/// Specifies the reason for a file conflict.
/// </summary>
public enum ConflictReason
{
    /// <summary>
    /// No conflict detected.
    /// </summary>
    None = 0,

    /// <summary>
    /// No snapshot was taken for this file, so conflict cannot be determined.
    /// This is not considered a conflict state.
    /// </summary>
    NoSnapshot = 1,

    /// <summary>
    /// File was created after the snapshot was taken.
    /// Snapshot indicated file did not exist, but it now exists.
    /// </summary>
    FileCreated = 2,

    /// <summary>
    /// File was deleted after the snapshot was taken.
    /// Snapshot indicated file existed, but it no longer exists.
    /// </summary>
    FileDeleted = 3,

    /// <summary>
    /// File content was modified after the snapshot was taken.
    /// Detected via SHA-256 content hash comparison.
    /// </summary>
    ContentModified = 4,

    /// <summary>
    /// File permissions changed making it inaccessible.
    /// Reserved for future implementation.
    /// </summary>
    PermissionChanged = 5
}
```

### 2. ConflictInfo Model

```csharp
// src/SeniorIntern.Services/Models/ConflictInfo.cs
namespace SeniorIntern.Services.Models;

/// <summary>
/// Contains information about a detected file conflict.
/// </summary>
public sealed class ConflictInfo
{
    /// <summary>
    /// Gets whether a conflict was detected.
    /// </summary>
    public bool HasConflict { get; init; }

    /// <summary>
    /// Gets the reason for the conflict.
    /// </summary>
    public ConflictReason Reason { get; init; }

    /// <summary>
    /// Gets a human-readable message describing the conflict.
    /// </summary>
    public string? Message { get; init; }

    /// <summary>
    /// Gets the file's last modification time (if available).
    /// </summary>
    public DateTime? LastModified { get; init; }

    /// <summary>
    /// Gets the time when the snapshot was taken.
    /// </summary>
    public DateTime? SnapshotTime { get; init; }

    /// <summary>
    /// Creates a ConflictInfo indicating no conflict.
    /// </summary>
    public static ConflictInfo NoConflict() => new()
    {
        HasConflict = false,
        Reason = ConflictReason.None
    };

    /// <summary>
    /// Creates a ConflictInfo indicating no snapshot exists.
    /// </summary>
    public static ConflictInfo NoSnapshotExists() => new()
    {
        HasConflict = false,
        Reason = ConflictReason.NoSnapshot
    };

    /// <summary>
    /// Creates a ConflictInfo for file creation conflict.
    /// </summary>
    public static ConflictInfo FileWasCreated(DateTime snapshotTime) => new()
    {
        HasConflict = true,
        Reason = ConflictReason.FileCreated,
        Message = "File was created after the proposal was generated",
        SnapshotTime = snapshotTime
    };

    /// <summary>
    /// Creates a ConflictInfo for file deletion conflict.
    /// </summary>
    public static ConflictInfo FileWasDeleted(DateTime snapshotTime) => new()
    {
        HasConflict = true,
        Reason = ConflictReason.FileDeleted,
        Message = "File was deleted after the proposal was generated",
        SnapshotTime = snapshotTime
    };

    /// <summary>
    /// Creates a ConflictInfo for content modification conflict.
    /// </summary>
    public static ConflictInfo ContentWasModified(
        DateTime lastModified,
        DateTime snapshotTime) => new()
    {
        HasConflict = true,
        Reason = ConflictReason.ContentModified,
        Message = "File content has been modified",
        LastModified = lastModified,
        SnapshotTime = snapshotTime
    };

    /// <summary>
    /// Creates a ConflictInfo for permission change conflict.
    /// </summary>
    public static ConflictInfo PermissionsChanged(DateTime snapshotTime) => new()
    {
        HasConflict = true,
        Reason = ConflictReason.PermissionChanged,
        Message = "File permissions have changed",
        SnapshotTime = snapshotTime
    };
}
```

### 3. IConflictDetector Interface

```csharp
// src/SeniorIntern.Services/Interfaces/IConflictDetector.cs
namespace SeniorIntern.Services.Interfaces;

/// <summary>
/// Provides file conflict detection through snapshot comparison.
/// </summary>
public interface IConflictDetector
{
    /// <summary>
    /// Takes a snapshot of a file's current state for later conflict detection.
    /// </summary>
    /// <param name="filePath">The absolute path to the file.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>A task that completes when the snapshot is taken.</returns>
    Task TakeSnapshotAsync(string filePath, CancellationToken ct = default);

    /// <summary>
    /// Takes snapshots of multiple files for later conflict detection.
    /// </summary>
    /// <param name="filePaths">The absolute paths to the files.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>A task that completes when all snapshots are taken.</returns>
    Task TakeSnapshotsAsync(IEnumerable<string> filePaths, CancellationToken ct = default);

    /// <summary>
    /// Checks if a file has changed since its snapshot was taken.
    /// </summary>
    /// <param name="filePath">The absolute path to the file.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>Information about any detected conflict.</returns>
    Task<ConflictInfo> CheckConflictAsync(string filePath, CancellationToken ct = default);

    /// <summary>
    /// Checks multiple files for conflicts.
    /// </summary>
    /// <param name="filePaths">The absolute paths to the files.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>A dictionary mapping file paths to their conflict info.</returns>
    Task<IReadOnlyDictionary<string, ConflictInfo>> CheckConflictsAsync(
        IEnumerable<string> filePaths,
        CancellationToken ct = default);

    /// <summary>
    /// Clears the snapshot for a specific file.
    /// </summary>
    /// <param name="filePath">The absolute path to the file.</param>
    void ClearSnapshot(string filePath);

    /// <summary>
    /// Clears all stored snapshots.
    /// </summary>
    void ClearAllSnapshots();

    /// <summary>
    /// Gets whether a snapshot exists for the specified file.
    /// </summary>
    /// <param name="filePath">The absolute path to the file.</param>
    /// <returns>True if a snapshot exists; otherwise, false.</returns>
    bool HasSnapshot(string filePath);

    /// <summary>
    /// Gets the time when a snapshot was taken for the specified file.
    /// </summary>
    /// <param name="filePath">The absolute path to the file.</param>
    /// <returns>The snapshot time, or null if no snapshot exists.</returns>
    DateTime? GetSnapshotTime(string filePath);

    /// <summary>
    /// Gets the count of stored snapshots.
    /// </summary>
    int SnapshotCount { get; }
}
```

### 4. ConflictDetector Implementation

```csharp
// src/SeniorIntern.Services/ConflictDetector.cs
using System.Collections.Concurrent;
using System.Security.Cryptography;
using System.Text;
using SeniorIntern.Services.Enums;
using SeniorIntern.Services.Interfaces;
using SeniorIntern.Services.Models;

namespace SeniorIntern.Services;

/// <summary>
/// Detects conflicts between proposed changes and current file state.
/// Uses snapshot-based comparison with SHA-256 content hashing.
/// </summary>
public sealed class ConflictDetector : IConflictDetector, IDisposable
{
    private readonly IFileSystemService _fileSystem;
    private readonly ConcurrentDictionary<string, FileSnapshot> _snapshots = new(StringComparer.OrdinalIgnoreCase);
    private bool _disposed;

    /// <summary>
    /// Initializes a new instance of the ConflictDetector class.
    /// </summary>
    /// <param name="fileSystem">The file system service for file operations.</param>
    public ConflictDetector(IFileSystemService fileSystem)
    {
        _fileSystem = fileSystem ?? throw new ArgumentNullException(nameof(fileSystem));
    }

    /// <inheritdoc/>
    public int SnapshotCount => _snapshots.Count;

    /// <inheritdoc/>
    public async Task TakeSnapshotAsync(string filePath, CancellationToken ct = default)
    {
        ThrowIfDisposed();
        ArgumentException.ThrowIfNullOrWhiteSpace(filePath);

        var normalizedPath = NormalizePath(filePath);

        if (!await _fileSystem.FileExistsAsync(normalizedPath, ct))
        {
            // File doesn't exist - snapshot records this state
            _snapshots[normalizedPath] = new FileSnapshot
            {
                Path = normalizedPath,
                Exists = false,
                ContentHash = null,
                LastModified = default,
                Size = 0,
                TakenAt = DateTime.UtcNow
            };
            return;
        }

        // File exists - capture full state
        var content = await _fileSystem.ReadFileAsync(normalizedPath, ct);
        var fileInfo = new FileInfo(normalizedPath);

        _snapshots[normalizedPath] = new FileSnapshot
        {
            Path = normalizedPath,
            Exists = true,
            ContentHash = ComputeContentHash(content),
            LastModified = fileInfo.LastWriteTimeUtc,
            Size = fileInfo.Length,
            TakenAt = DateTime.UtcNow
        };
    }

    /// <inheritdoc/>
    public async Task TakeSnapshotsAsync(IEnumerable<string> filePaths, CancellationToken ct = default)
    {
        ThrowIfDisposed();
        ArgumentNullException.ThrowIfNull(filePaths);

        var tasks = filePaths.Select(path => TakeSnapshotAsync(path, ct));
        await Task.WhenAll(tasks);
    }

    /// <inheritdoc/>
    public async Task<ConflictInfo> CheckConflictAsync(string filePath, CancellationToken ct = default)
    {
        ThrowIfDisposed();
        ArgumentException.ThrowIfNullOrWhiteSpace(filePath);

        var normalizedPath = NormalizePath(filePath);

        // Check if snapshot exists
        if (!_snapshots.TryGetValue(normalizedPath, out var snapshot))
        {
            return ConflictInfo.NoSnapshotExists();
        }

        // Check current file existence
        bool currentlyExists;
        try
        {
            currentlyExists = await _fileSystem.FileExistsAsync(normalizedPath, ct);
        }
        catch (UnauthorizedAccessException)
        {
            return ConflictInfo.PermissionsChanged(snapshot.TakenAt);
        }

        // File was created when we expected it not to exist
        if (!snapshot.Exists && currentlyExists)
        {
            return ConflictInfo.FileWasCreated(snapshot.TakenAt);
        }

        // File was deleted when we expected it to exist
        if (snapshot.Exists && !currentlyExists)
        {
            return ConflictInfo.FileWasDeleted(snapshot.TakenAt);
        }

        // File didn't exist and still doesn't - no conflict
        if (!currentlyExists)
        {
            return ConflictInfo.NoConflict();
        }

        // File exists - compare content hash
        string currentContent;
        try
        {
            currentContent = await _fileSystem.ReadFileAsync(normalizedPath, ct);
        }
        catch (UnauthorizedAccessException)
        {
            return ConflictInfo.PermissionsChanged(snapshot.TakenAt);
        }

        var currentHash = ComputeContentHash(currentContent);

        if (!string.Equals(currentHash, snapshot.ContentHash, StringComparison.Ordinal))
        {
            var fileInfo = new FileInfo(normalizedPath);
            return ConflictInfo.ContentWasModified(fileInfo.LastWriteTimeUtc, snapshot.TakenAt);
        }

        // Content matches - no conflict
        return ConflictInfo.NoConflict();
    }

    /// <inheritdoc/>
    public async Task<IReadOnlyDictionary<string, ConflictInfo>> CheckConflictsAsync(
        IEnumerable<string> filePaths,
        CancellationToken ct = default)
    {
        ThrowIfDisposed();
        ArgumentNullException.ThrowIfNull(filePaths);

        var pathList = filePaths.ToList();
        var results = new ConcurrentDictionary<string, ConflictInfo>(StringComparer.OrdinalIgnoreCase);

        await Parallel.ForEachAsync(
            pathList,
            new ParallelOptions { CancellationToken = ct, MaxDegreeOfParallelism = 4 },
            async (path, token) =>
            {
                var conflict = await CheckConflictAsync(path, token);
                results[path] = conflict;
            });

        return results;
    }

    /// <inheritdoc/>
    public void ClearSnapshot(string filePath)
    {
        ThrowIfDisposed();
        ArgumentException.ThrowIfNullOrWhiteSpace(filePath);

        var normalizedPath = NormalizePath(filePath);
        _snapshots.TryRemove(normalizedPath, out _);
    }

    /// <inheritdoc/>
    public void ClearAllSnapshots()
    {
        ThrowIfDisposed();
        _snapshots.Clear();
    }

    /// <inheritdoc/>
    public bool HasSnapshot(string filePath)
    {
        ThrowIfDisposed();
        ArgumentException.ThrowIfNullOrWhiteSpace(filePath);

        var normalizedPath = NormalizePath(filePath);
        return _snapshots.ContainsKey(normalizedPath);
    }

    /// <inheritdoc/>
    public DateTime? GetSnapshotTime(string filePath)
    {
        ThrowIfDisposed();
        ArgumentException.ThrowIfNullOrWhiteSpace(filePath);

        var normalizedPath = NormalizePath(filePath);
        return _snapshots.TryGetValue(normalizedPath, out var snapshot)
            ? snapshot.TakenAt
            : null;
    }

    /// <summary>
    /// Computes SHA-256 hash of content.
    /// </summary>
    private static string ComputeContentHash(string content)
    {
        var bytes = Encoding.UTF8.GetBytes(content);
        var hash = SHA256.HashData(bytes);
        return Convert.ToBase64String(hash);
    }

    /// <summary>
    /// Normalizes file path for consistent dictionary keys.
    /// </summary>
    private static string NormalizePath(string path)
    {
        return Path.GetFullPath(path);
    }

    /// <summary>
    /// Throws if this instance has been disposed.
    /// </summary>
    private void ThrowIfDisposed()
    {
        ObjectDisposedException.ThrowIf(_disposed, this);
    }

    /// <inheritdoc/>
    public void Dispose()
    {
        if (_disposed) return;
        _snapshots.Clear();
        _disposed = true;
    }

    /// <summary>
    /// Internal class representing a file state snapshot.
    /// </summary>
    private sealed class FileSnapshot
    {
        /// <summary>
        /// Gets the normalized file path.
        /// </summary>
        public required string Path { get; init; }

        /// <summary>
        /// Gets whether the file existed when the snapshot was taken.
        /// </summary>
        public required bool Exists { get; init; }

        /// <summary>
        /// Gets the SHA-256 hash of file content (null if file didn't exist).
        /// </summary>
        public string? ContentHash { get; init; }

        /// <summary>
        /// Gets the file's last modification time when snapshot was taken.
        /// </summary>
        public DateTime LastModified { get; init; }

        /// <summary>
        /// Gets the file size in bytes when snapshot was taken.
        /// </summary>
        public long Size { get; init; }

        /// <summary>
        /// Gets when this snapshot was taken.
        /// </summary>
        public required DateTime TakenAt { get; init; }
    }
}
```

### 5. Integration with FileChangeService

```csharp
// Integration example - shows how FileChangeService uses ConflictDetector
// This would be added to the existing FileChangeService implementation

public partial class FileChangeService
{
    private readonly IConflictDetector _conflictDetector;

    // In ApplyCodeBlockAsync:
    public async Task<ApplyResult> ApplyCodeBlockAsync(
        CodeBlock codeBlock,
        string workspacePath,
        ApplyOptions? options = null,
        CancellationToken ct = default)
    {
        var opts = options ?? ApplyOptions.Default;
        var filePath = ResolveFilePath(codeBlock.TargetFilePath, workspacePath);

        // Check for conflicts before applying
        if (opts.CheckForConflicts)
        {
            var conflict = await _conflictDetector.CheckConflictAsync(filePath, ct);

            if (conflict.HasConflict)
            {
                return ApplyResult.Conflict(
                    conflict.Reason,
                    conflict.Message,
                    conflict.LastModified,
                    conflict.SnapshotTime);
            }
        }

        // Proceed with apply...
        // After successful apply, clear the snapshot
        _conflictDetector.ClearSnapshot(filePath);

        return result;
    }
}
```

### 6. ApplyOptions Extension

```csharp
// Extension to ApplyOptions to include conflict checking
// src/SeniorIntern.Services/Models/ApplyOptions.cs (addition)

public sealed record ApplyOptions
{
    // ... existing properties ...

    /// <summary>
    /// Gets whether to check for conflicts before applying.
    /// Default: true
    /// </summary>
    public bool CheckForConflicts { get; init; } = true;

    /// <summary>
    /// Gets the conflict resolution strategy when a conflict is detected.
    /// Default: Prompt (show conflict dialog)
    /// </summary>
    public ConflictResolutionStrategy ConflictStrategy { get; init; } = ConflictResolutionStrategy.Prompt;
}

/// <summary>
/// Specifies how to handle conflicts when detected.
/// </summary>
public enum ConflictResolutionStrategy
{
    /// <summary>
    /// Show conflict dialog to user for manual resolution.
    /// </summary>
    Prompt = 0,

    /// <summary>
    /// Abort the operation when conflict detected.
    /// </summary>
    Abort = 1,

    /// <summary>
    /// Force overwrite regardless of conflict.
    /// </summary>
    ForceOverwrite = 2,

    /// <summary>
    /// Automatically refresh diff and re-check.
    /// </summary>
    RefreshDiff = 3
}
```

### 7. ApplyResult Extension for Conflicts

```csharp
// Extension to ApplyResult to include conflict information
// src/SeniorIntern.Services/Models/ApplyResult.cs (additions)

public sealed class ApplyResult
{
    // ... existing properties ...

    /// <summary>
    /// Gets the conflict reason if a conflict was detected.
    /// </summary>
    public ConflictReason? ConflictReason { get; init; }

    /// <summary>
    /// Gets the file's last modification time if conflict detected.
    /// </summary>
    public DateTime? ConflictLastModified { get; init; }

    /// <summary>
    /// Gets when the snapshot was taken for conflict comparison.
    /// </summary>
    public DateTime? ConflictSnapshotTime { get; init; }

    /// <summary>
    /// Gets whether this result represents a conflict.
    /// </summary>
    public bool IsConflict => ConflictReason.HasValue && ConflictReason != Enums.ConflictReason.None;

    /// <summary>
    /// Creates a conflict result.
    /// </summary>
    public static ApplyResult Conflict(
        ConflictReason reason,
        string? message,
        DateTime? lastModified,
        DateTime? snapshotTime) => new()
    {
        Success = false,
        Type = ApplyResultType.Conflict,
        ErrorMessage = message ?? "File has been modified since the proposal was generated",
        ConflictReason = reason,
        ConflictLastModified = lastModified,
        ConflictSnapshotTime = snapshotTime
    };
}

// Addition to ApplyResultType enum
public enum ApplyResultType
{
    // ... existing values ...

    /// <summary>
    /// File has been modified since proposal generation.
    /// </summary>
    Conflict = 7
}
```

---

## Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Services/Enums/ConflictReason.cs` | Enumeration of conflict types |
| `src/SeniorIntern.Services/Models/ConflictInfo.cs` | Conflict detection result model |
| `src/SeniorIntern.Services/Interfaces/IConflictDetector.cs` | Conflict detector interface |
| `src/SeniorIntern.Services/ConflictDetector.cs` | Conflict detector implementation |

## Files to Modify

| File | Changes |
|------|---------|
| `src/SeniorIntern.Services/Models/ApplyOptions.cs` | Add `CheckForConflicts` and `ConflictStrategy` properties |
| `src/SeniorIntern.Services/Models/ApplyResult.cs` | Add conflict-related properties and `Conflict()` factory method |
| `src/SeniorIntern.Services/Enums/ApplyResultType.cs` | Add `Conflict` value |
| `src/SeniorIntern.Services/FileChangeService.cs` | Integrate conflict detection before apply |
| `src/SeniorIntern.Services/DependencyInjection.cs` | Register `IConflictDetector` |

---

## Testing Strategy

### Unit Tests

```csharp
// tests/SeniorIntern.Services.Tests/ConflictDetectorTests.cs
namespace SeniorIntern.Services.Tests;

public class ConflictDetectorTests
{
    private readonly Mock<IFileSystemService> _mockFileSystem;
    private readonly ConflictDetector _detector;

    public ConflictDetectorTests()
    {
        _mockFileSystem = new Mock<IFileSystemService>();
        _detector = new ConflictDetector(_mockFileSystem.Object);
    }

    #region TakeSnapshotAsync Tests

    [Fact]
    public async Task TakeSnapshotAsync_ExistingFile_CapturesState()
    {
        // Arrange
        const string filePath = "/test/file.txt";
        const string content = "Hello, World!";
        _mockFileSystem.Setup(fs => fs.FileExistsAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(true);
        _mockFileSystem.Setup(fs => fs.ReadFileAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(content);

        // Act
        await _detector.TakeSnapshotAsync(filePath);

        // Assert
        Assert.True(_detector.HasSnapshot(filePath));
        Assert.NotNull(_detector.GetSnapshotTime(filePath));
        Assert.Equal(1, _detector.SnapshotCount);
    }

    [Fact]
    public async Task TakeSnapshotAsync_NonExistentFile_RecordsNotExists()
    {
        // Arrange
        const string filePath = "/test/missing.txt";
        _mockFileSystem.Setup(fs => fs.FileExistsAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(false);

        // Act
        await _detector.TakeSnapshotAsync(filePath);

        // Assert
        Assert.True(_detector.HasSnapshot(filePath));
    }

    [Fact]
    public async Task TakeSnapshotAsync_NullPath_ThrowsArgumentException()
    {
        // Act & Assert
        await Assert.ThrowsAsync<ArgumentException>(() => _detector.TakeSnapshotAsync(null!));
    }

    [Fact]
    public async Task TakeSnapshotAsync_EmptyPath_ThrowsArgumentException()
    {
        // Act & Assert
        await Assert.ThrowsAsync<ArgumentException>(() => _detector.TakeSnapshotAsync(""));
    }

    [Fact]
    public async Task TakeSnapshotAsync_UpdatesExistingSnapshot()
    {
        // Arrange
        const string filePath = "/test/file.txt";
        _mockFileSystem.Setup(fs => fs.FileExistsAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(true);
        _mockFileSystem.Setup(fs => fs.ReadFileAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync("content v1");

        await _detector.TakeSnapshotAsync(filePath);
        var firstTime = _detector.GetSnapshotTime(filePath);

        await Task.Delay(10); // Ensure time difference

        _mockFileSystem.Setup(fs => fs.ReadFileAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync("content v2");

        // Act
        await _detector.TakeSnapshotAsync(filePath);

        // Assert
        var secondTime = _detector.GetSnapshotTime(filePath);
        Assert.True(secondTime > firstTime);
        Assert.Equal(1, _detector.SnapshotCount);
    }

    #endregion

    #region TakeSnapshotsAsync Tests

    [Fact]
    public async Task TakeSnapshotsAsync_MultipleFiles_TakesAllSnapshots()
    {
        // Arrange
        var files = new[] { "/test/a.txt", "/test/b.txt", "/test/c.txt" };
        _mockFileSystem.Setup(fs => fs.FileExistsAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(true);
        _mockFileSystem.Setup(fs => fs.ReadFileAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync("content");

        // Act
        await _detector.TakeSnapshotsAsync(files);

        // Assert
        Assert.Equal(3, _detector.SnapshotCount);
        foreach (var file in files)
        {
            Assert.True(_detector.HasSnapshot(file));
        }
    }

    [Fact]
    public async Task TakeSnapshotsAsync_EmptyCollection_DoesNothing()
    {
        // Act
        await _detector.TakeSnapshotsAsync(Array.Empty<string>());

        // Assert
        Assert.Equal(0, _detector.SnapshotCount);
    }

    #endregion

    #region CheckConflictAsync Tests

    [Fact]
    public async Task CheckConflictAsync_NoSnapshot_ReturnsNoSnapshotReason()
    {
        // Arrange
        const string filePath = "/test/file.txt";

        // Act
        var result = await _detector.CheckConflictAsync(filePath);

        // Assert
        Assert.False(result.HasConflict);
        Assert.Equal(ConflictReason.NoSnapshot, result.Reason);
    }

    [Fact]
    public async Task CheckConflictAsync_UnchangedFile_ReturnsNoConflict()
    {
        // Arrange
        const string filePath = "/test/file.txt";
        const string content = "unchanged content";

        _mockFileSystem.Setup(fs => fs.FileExistsAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(true);
        _mockFileSystem.Setup(fs => fs.ReadFileAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(content);

        await _detector.TakeSnapshotAsync(filePath);

        // Act
        var result = await _detector.CheckConflictAsync(filePath);

        // Assert
        Assert.False(result.HasConflict);
        Assert.Equal(ConflictReason.None, result.Reason);
    }

    [Fact]
    public async Task CheckConflictAsync_ContentModified_ReturnsConflict()
    {
        // Arrange
        const string filePath = "/test/file.txt";

        _mockFileSystem.Setup(fs => fs.FileExistsAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(true);
        _mockFileSystem.SetupSequence(fs => fs.ReadFileAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync("original content")
            .ReturnsAsync("modified content");

        await _detector.TakeSnapshotAsync(filePath);

        // Act
        var result = await _detector.CheckConflictAsync(filePath);

        // Assert
        Assert.True(result.HasConflict);
        Assert.Equal(ConflictReason.ContentModified, result.Reason);
        Assert.NotNull(result.Message);
        Assert.NotNull(result.SnapshotTime);
    }

    [Fact]
    public async Task CheckConflictAsync_FileCreated_ReturnsConflict()
    {
        // Arrange
        const string filePath = "/test/newfile.txt";

        _mockFileSystem.SetupSequence(fs => fs.FileExistsAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(false)  // When taking snapshot
            .ReturnsAsync(true);  // When checking conflict

        await _detector.TakeSnapshotAsync(filePath);

        // Act
        var result = await _detector.CheckConflictAsync(filePath);

        // Assert
        Assert.True(result.HasConflict);
        Assert.Equal(ConflictReason.FileCreated, result.Reason);
        Assert.Contains("created", result.Message, StringComparison.OrdinalIgnoreCase);
    }

    [Fact]
    public async Task CheckConflictAsync_FileDeleted_ReturnsConflict()
    {
        // Arrange
        const string filePath = "/test/deletedfile.txt";

        _mockFileSystem.SetupSequence(fs => fs.FileExistsAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(true)   // When taking snapshot
            .ReturnsAsync(false); // When checking conflict
        _mockFileSystem.Setup(fs => fs.ReadFileAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync("content");

        await _detector.TakeSnapshotAsync(filePath);

        // Act
        var result = await _detector.CheckConflictAsync(filePath);

        // Assert
        Assert.True(result.HasConflict);
        Assert.Equal(ConflictReason.FileDeleted, result.Reason);
        Assert.Contains("deleted", result.Message, StringComparison.OrdinalIgnoreCase);
    }

    [Fact]
    public async Task CheckConflictAsync_PermissionDenied_ReturnsPermissionChanged()
    {
        // Arrange
        const string filePath = "/test/locked.txt";

        _mockFileSystem.Setup(fs => fs.FileExistsAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(true);
        _mockFileSystem.SetupSequence(fs => fs.ReadFileAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync("content")
            .ThrowsAsync(new UnauthorizedAccessException());

        await _detector.TakeSnapshotAsync(filePath);

        // Act
        var result = await _detector.CheckConflictAsync(filePath);

        // Assert
        Assert.True(result.HasConflict);
        Assert.Equal(ConflictReason.PermissionChanged, result.Reason);
    }

    [Fact]
    public async Task CheckConflictAsync_NonExistentStaysNonExistent_NoConflict()
    {
        // Arrange
        const string filePath = "/test/missing.txt";

        _mockFileSystem.Setup(fs => fs.FileExistsAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(false);

        await _detector.TakeSnapshotAsync(filePath);

        // Act
        var result = await _detector.CheckConflictAsync(filePath);

        // Assert
        Assert.False(result.HasConflict);
    }

    #endregion

    #region CheckConflictsAsync Tests

    [Fact]
    public async Task CheckConflictsAsync_MultipleFiles_ReturnsAllResults()
    {
        // Arrange
        var files = new[] { "/test/a.txt", "/test/b.txt" };
        _mockFileSystem.Setup(fs => fs.FileExistsAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(true);
        _mockFileSystem.Setup(fs => fs.ReadFileAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync("content");

        await _detector.TakeSnapshotsAsync(files);

        // Act
        var results = await _detector.CheckConflictsAsync(files);

        // Assert
        Assert.Equal(2, results.Count);
        Assert.All(results.Values, r => Assert.False(r.HasConflict));
    }

    #endregion

    #region ClearSnapshot Tests

    [Fact]
    public async Task ClearSnapshot_ExistingSnapshot_RemovesIt()
    {
        // Arrange
        const string filePath = "/test/file.txt";
        _mockFileSystem.Setup(fs => fs.FileExistsAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(true);
        _mockFileSystem.Setup(fs => fs.ReadFileAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync("content");

        await _detector.TakeSnapshotAsync(filePath);
        Assert.True(_detector.HasSnapshot(filePath));

        // Act
        _detector.ClearSnapshot(filePath);

        // Assert
        Assert.False(_detector.HasSnapshot(filePath));
        Assert.Equal(0, _detector.SnapshotCount);
    }

    [Fact]
    public void ClearSnapshot_NonExistentSnapshot_NoError()
    {
        // Act & Assert (should not throw)
        _detector.ClearSnapshot("/test/nonexistent.txt");
    }

    #endregion

    #region ClearAllSnapshots Tests

    [Fact]
    public async Task ClearAllSnapshots_RemovesAllSnapshots()
    {
        // Arrange
        _mockFileSystem.Setup(fs => fs.FileExistsAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(true);
        _mockFileSystem.Setup(fs => fs.ReadFileAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync("content");

        await _detector.TakeSnapshotAsync("/test/a.txt");
        await _detector.TakeSnapshotAsync("/test/b.txt");
        await _detector.TakeSnapshotAsync("/test/c.txt");
        Assert.Equal(3, _detector.SnapshotCount);

        // Act
        _detector.ClearAllSnapshots();

        // Assert
        Assert.Equal(0, _detector.SnapshotCount);
    }

    #endregion

    #region HasSnapshot Tests

    [Fact]
    public async Task HasSnapshot_ExistingSnapshot_ReturnsTrue()
    {
        // Arrange
        const string filePath = "/test/file.txt";
        _mockFileSystem.Setup(fs => fs.FileExistsAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(false);

        await _detector.TakeSnapshotAsync(filePath);

        // Assert
        Assert.True(_detector.HasSnapshot(filePath));
    }

    [Fact]
    public void HasSnapshot_NoSnapshot_ReturnsFalse()
    {
        Assert.False(_detector.HasSnapshot("/test/nonexistent.txt"));
    }

    #endregion

    #region GetSnapshotTime Tests

    [Fact]
    public async Task GetSnapshotTime_ExistingSnapshot_ReturnsTime()
    {
        // Arrange
        const string filePath = "/test/file.txt";
        var beforeSnapshot = DateTime.UtcNow;

        _mockFileSystem.Setup(fs => fs.FileExistsAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(false);

        await _detector.TakeSnapshotAsync(filePath);
        var afterSnapshot = DateTime.UtcNow;

        // Act
        var snapshotTime = _detector.GetSnapshotTime(filePath);

        // Assert
        Assert.NotNull(snapshotTime);
        Assert.True(snapshotTime >= beforeSnapshot);
        Assert.True(snapshotTime <= afterSnapshot);
    }

    [Fact]
    public void GetSnapshotTime_NoSnapshot_ReturnsNull()
    {
        Assert.Null(_detector.GetSnapshotTime("/test/nonexistent.txt"));
    }

    #endregion

    #region Path Normalization Tests

    [Fact]
    public async Task PathNormalization_DifferentCases_TreatedAsSameFile()
    {
        // Arrange
        _mockFileSystem.Setup(fs => fs.FileExistsAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(true);
        _mockFileSystem.Setup(fs => fs.ReadFileAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync("content");

        await _detector.TakeSnapshotAsync("/test/File.txt");

        // Act & Assert (case-insensitive on Windows, may differ on Unix)
        Assert.True(_detector.HasSnapshot("/test/FILE.TXT") || _detector.HasSnapshot("/test/file.txt"));
    }

    #endregion

    #region Dispose Tests

    [Fact]
    public void Dispose_ClearsSnapshots()
    {
        // Arrange
        _mockFileSystem.Setup(fs => fs.FileExistsAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(false);
        _detector.TakeSnapshotAsync("/test/file.txt").Wait();

        // Act
        _detector.Dispose();

        // Assert
        Assert.Equal(0, _detector.SnapshotCount);
    }

    [Fact]
    public async Task Dispose_SubsequentCalls_ThrowObjectDisposedException()
    {
        // Arrange
        _detector.Dispose();

        // Act & Assert
        await Assert.ThrowsAsync<ObjectDisposedException>(() => _detector.TakeSnapshotAsync("/test/file.txt"));
        Assert.Throws<ObjectDisposedException>(() => _detector.HasSnapshot("/test/file.txt"));
    }

    #endregion

    #region Content Hash Tests

    [Fact]
    public async Task ContentHash_SameContent_ProducesNoConflict()
    {
        // Arrange
        const string content = "The quick brown fox jumps over the lazy dog";
        _mockFileSystem.Setup(fs => fs.FileExistsAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(true);
        _mockFileSystem.Setup(fs => fs.ReadFileAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(content);

        await _detector.TakeSnapshotAsync("/test/file.txt");

        // Act
        var result = await _detector.CheckConflictAsync("/test/file.txt");

        // Assert
        Assert.False(result.HasConflict);
    }

    [Fact]
    public async Task ContentHash_WhitespaceChange_DetectsConflict()
    {
        // Arrange
        _mockFileSystem.Setup(fs => fs.FileExistsAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(true);
        _mockFileSystem.SetupSequence(fs => fs.ReadFileAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync("line1\nline2")
            .ReturnsAsync("line1\n line2"); // Added space

        await _detector.TakeSnapshotAsync("/test/file.txt");

        // Act
        var result = await _detector.CheckConflictAsync("/test/file.txt");

        // Assert
        Assert.True(result.HasConflict);
        Assert.Equal(ConflictReason.ContentModified, result.Reason);
    }

    #endregion
}
```

### Integration Tests

```csharp
// tests/SeniorIntern.Services.Tests/Integration/ConflictDetectorIntegrationTests.cs
namespace SeniorIntern.Services.Tests.Integration;

public class ConflictDetectorIntegrationTests : IDisposable
{
    private readonly string _testDir;
    private readonly IFileSystemService _fileSystem;
    private readonly ConflictDetector _detector;

    public ConflictDetectorIntegrationTests()
    {
        _testDir = Path.Combine(Path.GetTempPath(), $"conflict_test_{Guid.NewGuid():N}");
        Directory.CreateDirectory(_testDir);

        _fileSystem = new FileSystemService(); // Real implementation
        _detector = new ConflictDetector(_fileSystem);
    }

    [Fact]
    public async Task RealFile_ModificationDetected()
    {
        // Arrange
        var filePath = Path.Combine(_testDir, "test.txt");
        await File.WriteAllTextAsync(filePath, "original content");

        await _detector.TakeSnapshotAsync(filePath);

        // Modify the file
        await File.WriteAllTextAsync(filePath, "modified content");

        // Act
        var result = await _detector.CheckConflictAsync(filePath);

        // Assert
        Assert.True(result.HasConflict);
        Assert.Equal(ConflictReason.ContentModified, result.Reason);
    }

    [Fact]
    public async Task RealFile_DeletionDetected()
    {
        // Arrange
        var filePath = Path.Combine(_testDir, "todelete.txt");
        await File.WriteAllTextAsync(filePath, "content");

        await _detector.TakeSnapshotAsync(filePath);

        // Delete the file
        File.Delete(filePath);

        // Act
        var result = await _detector.CheckConflictAsync(filePath);

        // Assert
        Assert.True(result.HasConflict);
        Assert.Equal(ConflictReason.FileDeleted, result.Reason);
    }

    [Fact]
    public async Task RealFile_CreationDetected()
    {
        // Arrange
        var filePath = Path.Combine(_testDir, "newfile.txt");

        // File doesn't exist yet
        await _detector.TakeSnapshotAsync(filePath);

        // Create the file
        await File.WriteAllTextAsync(filePath, "new content");

        // Act
        var result = await _detector.CheckConflictAsync(filePath);

        // Assert
        Assert.True(result.HasConflict);
        Assert.Equal(ConflictReason.FileCreated, result.Reason);
    }

    public void Dispose()
    {
        _detector.Dispose();
        if (Directory.Exists(_testDir))
        {
            Directory.Delete(_testDir, recursive: true);
        }
    }
}
```

---

## Acceptance Criteria

### Functional Requirements

- [ ] **Snapshot capture** - `TakeSnapshotAsync` captures file existence, content hash, modification time, and size
- [ ] **Non-existent file snapshots** - Can take snapshot of non-existent file to detect creation
- [ ] **Content modification detection** - SHA-256 hash comparison detects any content change
- [ ] **File creation detection** - Detects when file is created after snapshot showed non-existence
- [ ] **File deletion detection** - Detects when file is deleted after snapshot showed existence
- [ ] **Permission change detection** - Detects when file becomes inaccessible
- [ ] **Multiple file support** - `TakeSnapshotsAsync` and `CheckConflictsAsync` handle multiple files
- [ ] **Snapshot management** - `ClearSnapshot` and `ClearAllSnapshots` properly remove snapshots
- [ ] **Snapshot queries** - `HasSnapshot`, `GetSnapshotTime`, and `SnapshotCount` provide snapshot info

### Non-Functional Requirements

- [ ] **Thread safety** - `ConcurrentDictionary` ensures safe concurrent access
- [ ] **Case handling** - Path normalization handles case-insensitive file systems
- [ ] **Performance** - Parallel conflict checking with `MaxDegreeOfParallelism = 4`
- [ ] **Memory efficiency** - Only stores hash, not full content
- [ ] **Disposable pattern** - Implements `IDisposable` for cleanup

### Integration Requirements

- [ ] **FileChangeService integration** - Conflict check before apply operations
- [ ] **ApplyOptions support** - `CheckForConflicts` flag to enable/disable
- [ ] **ApplyResult extension** - Conflict-specific result information
- [ ] **DI registration** - Registered as scoped service

---

## Design Decisions

### 1. SHA-256 Content Hashing

**Decision**: Use SHA-256 to hash file content for conflict detection.

**Rationale**:
- Cryptographically secure with negligible collision probability
- Consistent with other parts of the system (BackupService)
- More reliable than timestamp-based detection (which can fail with fast edits)
- Base64 encoding produces compact string representation

**Alternatives Considered**:
- MD5: Faster but less secure, not recommended for integrity checks
- Timestamp comparison: Unreliable with fast successive edits
- Full content comparison: Memory-intensive for large files

### 2. ConcurrentDictionary for Snapshot Storage

**Decision**: Store snapshots in `ConcurrentDictionary<string, FileSnapshot>`.

**Rationale**:
- Thread-safe without explicit locking
- Efficient for concurrent read/write operations
- Built-in atomic operations (`TryGetValue`, `TryRemove`)
- Scales well with multiple files

**Trade-offs**:
- Slightly higher memory overhead than regular Dictionary
- No ordering guarantees (not needed for this use case)

### 3. Path Normalization with Case-Insensitive Comparison

**Decision**: Normalize paths using `Path.GetFullPath` and use `StringComparer.OrdinalIgnoreCase`.

**Rationale**:
- Handles relative vs absolute path comparisons
- Works correctly on case-insensitive file systems (Windows, macOS by default)
- Prevents duplicate snapshots for same file with different path representations

**Considerations**:
- Linux file systems are case-sensitive; may need platform-specific handling in future

### 4. NoSnapshot Returns No Conflict

**Decision**: When no snapshot exists, return `HasConflict = false` with `Reason = NoSnapshot`.

**Rationale**:
- Missing snapshot is an informational state, not a conflict
- Allows calling code to handle appropriately (e.g., take snapshot first)
- Distinguishes from actual conflict scenarios

**Alternative Considered**:
- Treating no snapshot as conflict would be overly restrictive

### 5. Interface Abstraction (IConflictDetector)

**Decision**: Define `IConflictDetector` interface for the conflict detector.

**Rationale**:
- Enables dependency injection
- Facilitates unit testing with mocks
- Supports alternative implementations if needed
- Follows established patterns in the codebase

### 6. Factory Methods for ConflictInfo

**Decision**: Use static factory methods on `ConflictInfo` for creating instances.

**Rationale**:
- Provides semantic clarity (`ConflictInfo.FileWasDeleted()` vs `new ConflictInfo { ... }`)
- Ensures consistent initialization of related properties
- Reduces error potential from incorrect property combinations
- Follows pattern established in `ApplyResult`

### 7. Parallel Conflict Checking with Throttling

**Decision**: `CheckConflictsAsync` uses `Parallel.ForEachAsync` with `MaxDegreeOfParallelism = 4`.

**Rationale**:
- File I/O can be parallelized for performance
- Throttling prevents excessive disk access
- Reasonable default for most systems
- ConcurrentDictionary handles safe result collection

---

## Performance Considerations

### Memory Usage

| Component | Memory Impact |
|-----------|---------------|
| FileSnapshot (per file) | ~100-200 bytes (path string + hash + metadata) |
| Content hash (Base64) | 44 bytes per hash |
| 100 tracked files | ~15-20 KB |
| 1000 tracked files | ~150-200 KB |

### Time Complexity

| Operation | Complexity |
|-----------|------------|
| TakeSnapshotAsync | O(n) where n = file size (for hashing) |
| CheckConflictAsync | O(n) where n = file size |
| HasSnapshot | O(1) dictionary lookup |
| ClearSnapshot | O(1) dictionary removal |
| ClearAllSnapshots | O(n) where n = snapshot count |

### Recommendations

1. **Take snapshots lazily**: Only snapshot files that may be modified
2. **Clear snapshots after apply**: Remove snapshots for successfully applied files
3. **Batch operations**: Use `TakeSnapshotsAsync` and `CheckConflictsAsync` for multiple files
4. **Consider file size**: Very large files will take longer to hash

---

## Future Enhancements

1. **Permission change detection**: Check Unix permissions or Windows ACLs
2. **Partial content hashing**: For very large files, hash first/last N bytes
3. **Snapshot expiration**: Automatic cleanup of old snapshots
4. **Snapshot persistence**: Save/restore snapshots across sessions
5. **Change type detection**: Detect specific types of changes (append, modify, etc.)
