# v0.4.4h: Chat Integration - Design Specification

**Status**: _IMPLEMENTED_

## Executive Summary

This specification details the **Chat Integration** layer for The Senior Intern's Multi-File Creation system. This component bridges the file tree proposal subsystem (v0.4.4a-g) with the existing chat UI (v0.4.1), enabling automatic detection of multi-file proposals in assistant messages, displaying the proposal panel inline within chat messages, and coordinating the apply workflow with progress overlay and undo toast. This is the capstone integration that makes the entire v0.4.4 feature accessible to users.

### Key Deliverables

| Component | Type | Purpose |
|-----------|------|---------|
| `ChatMessageViewModel` (updated) | ViewModel | Add file tree proposal detection and ViewModel |
| `ChatViewModel` (updated) | ViewModel | Wire up parsing, progress overlay, and dialog hosting |
| `ChatMessageControl.axaml` (updated) | UserControl | Add FileTreeProposalPanel placement |
| `IProposalDetectionService` | Interface | Contract for proposal detection logic |
| `ProposalDetectionService` | Service | Orchestrates parser and threshold checks |
| `ChatProposalCoordinator` | Service | Coordinates dialogs, overlay, and undo |

---

## Feature Overview

```
v0.4.4h: Chat Integration
â”œâ”€â”€ ChatMessageViewModel Updates
â”‚   â”œâ”€â”€ New Properties
â”‚   â”‚   â”œâ”€â”€ FileTreeProposal (FileTreeProposal?)
â”‚   â”‚   â”œâ”€â”€ FileTreeProposalViewModel (FileTreeProposalViewModel?)
â”‚   â”‚   â”œâ”€â”€ HasFileTreeProposal (bool)
â”‚   â”‚   â”œâ”€â”€ ShowFileTreeProposal (bool)
â”‚   â”‚   â””â”€â”€ ProposalStatus (FileTreeProposalStatus?)
â”‚   â”œâ”€â”€ New Methods
â”‚   â”‚   â”œâ”€â”€ ParseFileTreeProposal(IFileTreeParser, IWorkspaceService)
â”‚   â”‚   â”œâ”€â”€ CreateProposalViewModel()
â”‚   â”‚   â”œâ”€â”€ UpdateProposalStatus(FileTreeProposalStatus)
â”‚   â”‚   â””â”€â”€ ClearProposal()
â”‚   â””â”€â”€ Event Handlers
â”‚       â”œâ”€â”€ OnProposalApplyRequested
â”‚       â”œâ”€â”€ OnProposalPreviewRequested
â”‚       â””â”€â”€ OnProposalUndoRequested
â”œâ”€â”€ ChatViewModel Updates
â”‚   â”œâ”€â”€ New Dependencies
â”‚   â”‚   â”œâ”€â”€ IFileTreeParser
â”‚   â”‚   â”œâ”€â”€ IFileTreeProposalService
â”‚   â”‚   â”œâ”€â”€ IProposalDetectionService
â”‚   â”‚   â””â”€â”€ ChatProposalCoordinator
â”‚   â”œâ”€â”€ Message Processing
â”‚   â”‚   â”œâ”€â”€ ParseProposalsForMessage(ChatMessageViewModel)
â”‚   â”‚   â”œâ”€â”€ OnStreamingComplete â†’ Trigger proposal detection
â”‚   â”‚   â””â”€â”€ OnMessageAdded â†’ Check for existing proposals
â”‚   â”œâ”€â”€ Dialog Management
â”‚   â”‚   â”œâ”€â”€ ShowBatchPreviewDialog(IReadOnlyList<(FileOperation, DiffResult)>)
â”‚   â”‚   â”œâ”€â”€ ShowConflictDialog(IReadOnlyList<ValidationIssue>)
â”‚   â”‚   â””â”€â”€ GetDialogOwner() â†’ Window reference
â”‚   â”œâ”€â”€ Progress Management
â”‚   â”‚   â”œâ”€â”€ ApplyProgressViewModel (owned instance)
â”‚   â”‚   â”œâ”€â”€ StartApplyProgress(CancellationTokenSource, int)
â”‚   â”‚   â””â”€â”€ CompleteApplyProgress()
â”‚   â””â”€â”€ Undo Support
â”‚       â”œâ”€â”€ LastApplyResult (BatchApplyResult?)
â”‚       â”œâ”€â”€ ShowUndoToast(BatchApplyResult)
â”‚       â””â”€â”€ UndoLastApplyCommand
â”œâ”€â”€ ChatMessageControl.axaml Updates
â”‚   â”œâ”€â”€ Layout Changes
â”‚   â”‚   â”œâ”€â”€ Insert FileTreeProposalPanel after code blocks
â”‚   â”‚   â”œâ”€â”€ Conditional visibility based on HasFileTreeProposal
â”‚   â”‚   â””â”€â”€ Margin and spacing for visual separation
â”‚   â””â”€â”€ DataContext Binding
â”‚       â””â”€â”€ Bind to FileTreeProposalViewModel
â”œâ”€â”€ IProposalDetectionService
â”‚   â”œâ”€â”€ DetectProposal(ChatMessage, IEnumerable<CodeBlock>)
â”‚   â”œâ”€â”€ ShouldShowProposalPanel(FileTreeProposal) â†’ bool
â”‚   â””â”€â”€ Configuration
â”‚       â”œâ”€â”€ MinimumFilesForPanel (default: 2)
â”‚       â”œâ”€â”€ EnableAutoDetection (default: true)
â”‚       â””â”€â”€ IgnoredLanguages (e.g., "output", "text")
â”œâ”€â”€ ProposalDetectionService
â”‚   â”œâ”€â”€ Dependencies
â”‚   â”‚   â”œâ”€â”€ IFileTreeParser
â”‚   â”‚   â”œâ”€â”€ IWorkspaceService
â”‚   â”‚   â””â”€â”€ ILogger
â”‚   â”œâ”€â”€ Detection Logic
â”‚   â”‚   â”œâ”€â”€ Filter applicable code blocks
â”‚   â”‚   â”œâ”€â”€ Check minimum file count threshold
â”‚   â”‚   â”œâ”€â”€ Parse with IFileTreeParser
â”‚   â”‚   â”œâ”€â”€ Validate paths exist in workspace
â”‚   â”‚   â””â”€â”€ Return FileTreeProposal or null
â”‚   â””â”€â”€ Caching
â”‚       â””â”€â”€ Cache proposals by MessageId
â”œâ”€â”€ ChatProposalCoordinator
â”‚   â”œâ”€â”€ Dependencies
â”‚   â”‚   â”œâ”€â”€ IFileTreeProposalService
â”‚   â”‚   â”œâ”€â”€ IDialogService (or direct Window access)
â”‚   â”‚   â”œâ”€â”€ ApplyProgressViewModel
â”‚   â”‚   â””â”€â”€ IUndoToastService
â”‚   â”œâ”€â”€ Workflow Orchestration
â”‚   â”‚   â”œâ”€â”€ PreviewAsync(FileTreeProposalViewModel) â†’ Show BatchPreviewDialog
â”‚   â”‚   â”œâ”€â”€ ApplyAsync(FileTreeProposalViewModel, ApplyOptions) â†’ Execute with progress
â”‚   â”‚   â”œâ”€â”€ UndoAsync(BatchApplyResult) â†’ Reverse last apply
â”‚   â”‚   â””â”€â”€ CancelAsync() â†’ Cancel in-progress operation
â”‚   â”œâ”€â”€ Event Handling
â”‚   â”‚   â”œâ”€â”€ Subscribe to FileTreeProposalPanel routed events
â”‚   â”‚   â”œâ”€â”€ Handle PreviewRequested
â”‚   â”‚   â”œâ”€â”€ Handle ApplyRequested
â”‚   â”‚   â””â”€â”€ Handle UndoCancelled
â”‚   â””â”€â”€ State Management
â”‚       â”œâ”€â”€ CurrentOperation (apply/preview/undo)
â”‚       â”œâ”€â”€ CancellationTokenSource
â”‚       â””â”€â”€ LastApplyResult
â””â”€â”€ Service Registration
    â”œâ”€â”€ AddProposalDetectionService()
    â”œâ”€â”€ AddChatProposalCoordinator()
    â””â”€â”€ Configure lifetime (Scoped per chat session)
```

---

## Architecture Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                           Chat Integration Layer                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                          ChatViewModel                                 â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚  â”‚  â”‚                    Existing Dependencies                         â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚ILlmService â”‚ â”‚IConversation â”‚ â”‚IStreamingParserFactory     â”‚ â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚            â”‚ â”‚   Service    â”‚ â”‚        (v0.4.1)            â”‚ â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚  â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚  â”‚  â”‚                    NEW Dependencies (v0.4.4h)                    â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚IProposalDetectionâ”‚ â”‚ChatProposal      â”‚ â”‚ApplyProgress    â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚    Service       â”‚ â”‚   Coordinator    â”‚ â”‚   ViewModel     â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚  â”‚                                    â”‚                                   â”‚  â”‚
â”‚  â”‚                                    â–¼                                   â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚  â”‚  â”‚              Messages: ObservableCollection                      â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚                  ChatMessageViewModel                      â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  â”‚ Existing Properties                                   â”‚â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  â”‚ â€¢ Id, Content, Role, Timestamp                        â”‚â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  â”‚ â€¢ CodeBlocks (ObservableCollection<CodeBlockViewModel>â”‚â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  â”‚ â€¢ HasCodeBlocks, HasApplicableCode                    â”‚â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  â”‚ NEW Properties (v0.4.4h)                              â”‚â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  â”‚ â€¢ FileTreeProposal (FileTreeProposal?)                â”‚â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  â”‚ â€¢ FileTreeProposalViewModel                           â”‚â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  â”‚ â€¢ HasFileTreeProposal (bool)                          â”‚â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  â”‚ â€¢ ShowFileTreeProposal (bool)                         â”‚â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         UI Integration                                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                       ChatMessageControl                               â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚  â”‚  â”‚ StackPanel                                                       â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚ TextBlock (Role Label)                                      â”‚â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚ SelectableTextBlock (Message Content)                       â”‚â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚ ItemsControl (CodeBlocks)                                   â”‚â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  â””â”€â”€ CodeBlockControl (for each block)                     â”‚â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚ FileTreeProposalPanel (NEW - v0.4.4h)                       â”‚â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚   IsVisible="{Binding ShowFileTreeProposal}"                â”‚â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚   DataContext="{Binding FileTreeProposalViewModel}"         â”‚â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  â”‚ TreeView with FileTreeItemViewModels                  â”‚  â”‚â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  â”‚  ğŸ“ src/                                              â”‚  â”‚â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  â”‚    â˜‘ ğŸ“„ Models/User.cs           [C#]                â”‚  â”‚â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  â”‚    â˜‘ ğŸ“„ Services/UserService.cs  [C#] [exists]       â”‚  â”‚â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  [Select All] [Deselect All]  2 of 2 selected               â”‚â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  â˜‘ Create backups                                           â”‚â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  [Preview] [Create Files]                                   â”‚â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚ StackPanel (Streaming Indicator)                            â”‚â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚  â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Message Processing Flow

```
                     LLM Response Streaming Complete
                                  â”‚
                                  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         Proposal Detection Flow                              â”‚
â”‚                                                                             â”‚
â”‚  ChatViewModel.OnStreamingComplete(ChatMessageViewModel messageVm)          â”‚
â”‚                                  â”‚                                          â”‚
â”‚                                  â–¼                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  1. Check if message has code blocks                                   â”‚  â”‚
â”‚  â”‚     if (!messageVm.HasCodeBlocks) return;                              â”‚  â”‚
â”‚  â”‚                                                                       â”‚  â”‚
â”‚  â”‚  2. Check minimum threshold                                            â”‚  â”‚
â”‚  â”‚     var applicableBlocks = messageVm.CodeBlocks                       â”‚  â”‚
â”‚  â”‚         .Where(b => b.BlockType == CodeBlockType.Implementation)      â”‚  â”‚
â”‚  â”‚         .Where(b => !string.IsNullOrEmpty(b.TargetFilePath))          â”‚  â”‚
â”‚  â”‚         .ToList();                                                    â”‚  â”‚
â”‚  â”‚     if (applicableBlocks.Count < 2) return;  // Single file, no panel â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                  â”‚                                          â”‚
â”‚                                  â–¼                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  3. Parse file tree proposal                                           â”‚  â”‚
â”‚  â”‚     var codeBlocks = applicableBlocks.Select(vm => vm.ToModel());     â”‚  â”‚
â”‚  â”‚     var proposal = _proposalDetectionService.DetectProposal(          â”‚  â”‚
â”‚  â”‚         messageVm.Content, messageVm.Id, codeBlocks);                 â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                  â”‚                                          â”‚
â”‚               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                       â”‚
â”‚               â–¼                                      â–¼                      â”‚
â”‚        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚        â”‚ proposal    â”‚                       â”‚ proposal    â”‚                â”‚
â”‚        â”‚ == null     â”‚                       â”‚ != null     â”‚                â”‚
â”‚        â”‚ (no match)  â”‚                       â”‚ (detected!) â”‚                â”‚
â”‚        â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                       â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”‚               â”‚                                      â”‚                      â”‚
â”‚               â–¼                                      â–¼                      â”‚
â”‚         [No panel]                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚                                       â”‚ 4. Create ViewModel        â”‚         â”‚
â”‚                                       â”‚                            â”‚         â”‚
â”‚                                       â”‚ messageVm.FileTreeProposal â”‚         â”‚
â”‚                                       â”‚     = proposal;            â”‚         â”‚
â”‚                                       â”‚ messageVm                  â”‚         â”‚
â”‚                                       â”‚     .CreateProposalViewModel();â”‚     â”‚
â”‚                                       â”‚ messageVm.HasFileTreeProposal â”‚      â”‚
â”‚                                       â”‚     = true;                â”‚         â”‚
â”‚                                       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚                                              â”‚                              â”‚
â”‚                                              â–¼                              â”‚
â”‚                                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚                                  â”‚ 5. Validate against       â”‚              â”‚
â”‚                                  â”‚    workspace              â”‚              â”‚
â”‚                                  â”‚                            â”‚              â”‚
â”‚                                  â”‚ await messageVm            â”‚              â”‚
â”‚                                  â”‚   .FileTreeProposalViewModelâ”‚             â”‚
â”‚                                  â”‚   .ValidateAsync(          â”‚              â”‚
â”‚                                  â”‚       _workspacePath);     â”‚              â”‚
â”‚                                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚                                              â”‚                              â”‚
â”‚                                              â–¼                              â”‚
â”‚                                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚                                  â”‚ 6. Show proposal panel    â”‚              â”‚
â”‚                                  â”‚                            â”‚              â”‚
â”‚                                  â”‚ messageVm                  â”‚              â”‚
â”‚                                  â”‚   .ShowFileTreeProposal    â”‚              â”‚
â”‚                                  â”‚   = true;                  â”‚              â”‚
â”‚                                  â”‚                            â”‚              â”‚
â”‚                                  â”‚ // UI updates via binding  â”‚              â”‚
â”‚                                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Apply Workflow Flow

```
                     User Clicks "Create Files" Button
                                  â”‚
                                  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                            Apply Workflow                                    â”‚
â”‚                                                                             â”‚
â”‚  FileTreeProposalPanel raises ApplyRequested routed event                   â”‚
â”‚                                  â”‚                                          â”‚
â”‚                                  â–¼                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  ChatProposalCoordinator.HandleApplyRequested                          â”‚  â”‚
â”‚  â”‚                                                                       â”‚  â”‚
â”‚  â”‚  1. Get the proposal ViewModel from event args                        â”‚  â”‚
â”‚  â”‚  2. Check for validation errors                                        â”‚  â”‚
â”‚  â”‚     if (proposalVm.HasErrors)                                         â”‚  â”‚
â”‚  â”‚     {                                                                  â”‚  â”‚
â”‚  â”‚         ShowValidationErrorDialog(proposalVm.ValidationResult);       â”‚  â”‚
â”‚  â”‚         return;                                                        â”‚  â”‚
â”‚  â”‚     }                                                                  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                  â”‚                                          â”‚
â”‚                                  â–¼                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  3. Show confirmation if files will be overwritten                     â”‚  â”‚
â”‚  â”‚                                                                       â”‚  â”‚
â”‚  â”‚  var existingFiles = proposalVm.GetExistingFileOperations();          â”‚  â”‚
â”‚  â”‚  if (existingFiles.Any())                                              â”‚  â”‚
â”‚  â”‚  {                                                                     â”‚  â”‚
â”‚  â”‚      var confirmed = await ShowOverwriteConfirmationDialog(            â”‚  â”‚
â”‚  â”‚          existingFiles);                                               â”‚  â”‚
â”‚  â”‚      if (!confirmed) return;                                           â”‚  â”‚
â”‚  â”‚  }                                                                     â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                  â”‚                                          â”‚
â”‚                                  â–¼                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  4. Start progress overlay                                             â”‚  â”‚
â”‚  â”‚                                                                       â”‚  â”‚
â”‚  â”‚  var cts = new CancellationTokenSource();                              â”‚  â”‚
â”‚  â”‚  _progressViewModel.Start(cts, proposalVm.SelectedCount);              â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                  â”‚                                          â”‚
â”‚                                  â–¼                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  5. Execute apply with progress                                        â”‚  â”‚
â”‚  â”‚                                                                       â”‚  â”‚
â”‚  â”‚  var progress = new ProgressReporterAdapter(_progressViewModel);       â”‚  â”‚
â”‚  â”‚  var result = await _proposalService.ApplyProposalAsync(               â”‚  â”‚
â”‚  â”‚      proposalVm.Proposal,                                              â”‚  â”‚
â”‚  â”‚      _workspacePath,                                                   â”‚  â”‚
â”‚  â”‚      new ApplyOptions { CreateBackup = proposalVm.CreateBackups },     â”‚  â”‚
â”‚  â”‚      progress,                                                         â”‚  â”‚
â”‚  â”‚      cts.Token);                                                       â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                  â”‚                                          â”‚
â”‚               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                       â”‚
â”‚               â–¼                  â–¼                  â–¼                       â”‚
â”‚        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚        â”‚ AllSucceededâ”‚   â”‚  Partial    â”‚   â”‚ Cancelled/  â”‚                  â”‚
â”‚        â”‚   = true    â”‚   â”‚  Success    â”‚   â”‚   Error     â”‚                  â”‚
â”‚        â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                  â”‚
â”‚               â”‚                 â”‚                 â”‚                         â”‚
â”‚               â–¼                 â–¼                 â–¼                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  6. Handle result                                                      â”‚ â”‚
â”‚  â”‚                                                                        â”‚ â”‚
â”‚  â”‚  if (result.AllSucceeded)                                              â”‚ â”‚
â”‚  â”‚  {                                                                     â”‚ â”‚
â”‚  â”‚      _progressViewModel.Complete();                                    â”‚ â”‚
â”‚  â”‚      proposalVm.UpdateStatus(FileTreeProposalStatus.FullyApplied);     â”‚ â”‚
â”‚  â”‚      _lastApplyResult = result;                                        â”‚ â”‚
â”‚  â”‚      ShowUndoToast(result);  // "Created 3 files. Undo?"               â”‚ â”‚
â”‚  â”‚  }                                                                     â”‚ â”‚
â”‚  â”‚  else if (result.WasCancelled)                                         â”‚ â”‚
â”‚  â”‚  {                                                                     â”‚ â”‚
â”‚  â”‚      _progressViewModel.RollbackComplete();                            â”‚ â”‚
â”‚  â”‚      proposalVm.UpdateStatus(FileTreeProposalStatus.Cancelled);        â”‚ â”‚
â”‚  â”‚  }                                                                     â”‚ â”‚
â”‚  â”‚  else                                                                  â”‚ â”‚
â”‚  â”‚  {                                                                     â”‚ â”‚
â”‚  â”‚      var failedFile = result.FailedResults.First().FilePath;           â”‚ â”‚
â”‚  â”‚      _progressViewModel.Error($"Failed: {failedFile}");                â”‚ â”‚
â”‚  â”‚      proposalVm.UpdateStatus(FileTreeProposalStatus.PartiallyApplied); â”‚ â”‚
â”‚  â”‚      ShowErrorDetails(result);                                         â”‚ â”‚
â”‚  â”‚  }                                                                     â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Detailed Design

### 1. ChatMessageViewModel Updates

Updates to support file tree proposal detection and display.

```csharp
// src/SeniorIntern.Desktop/ViewModels/ChatMessageViewModel.cs
namespace SeniorIntern.Desktop.ViewModels;

using CommunityToolkit.Mvvm.ComponentModel;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;

/// <summary>
/// ViewModel for a single chat message.
/// Extended in v0.4.4h to support multi-file tree proposals.
/// </summary>
public partial class ChatMessageViewModel : ViewModelBase
{
    #region Existing Properties (from v0.4.1g)

    [ObservableProperty]
    private Guid _id;

    [ObservableProperty]
    private string _content = string.Empty;

    [ObservableProperty]
    private MessageRole _role;

    [ObservableProperty]
    private DateTime _timestamp;

    [ObservableProperty]
    private bool _isStreaming;

    [ObservableProperty]
    private ObservableCollection<CodeBlockViewModel> _codeBlocks = new();

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(HasApplicableCode))]
    private bool _hasCodeBlocks;

    #endregion

    #region NEW: File Tree Proposal Properties (v0.4.4h)

    /// <summary>
    /// The file tree proposal parsed from this message.
    /// Null if no multi-file proposal was detected.
    /// </summary>
    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(HasFileTreeProposal))]
    [NotifyPropertyChangedFor(nameof(ShowFileTreeProposal))]
    private FileTreeProposal? _fileTreeProposal;

    /// <summary>
    /// The ViewModel for the file tree proposal panel.
    /// Created lazily when a proposal is detected.
    /// </summary>
    [ObservableProperty]
    private FileTreeProposalViewModel? _fileTreeProposalViewModel;

    /// <summary>
    /// Whether this message contains a multi-file tree proposal.
    /// </summary>
    public bool HasFileTreeProposal => FileTreeProposal != null;

    /// <summary>
    /// Whether to show the file tree proposal panel.
    /// False if proposal is null, fully applied, or rejected.
    /// </summary>
    public bool ShowFileTreeProposal =>
        HasFileTreeProposal &&
        FileTreeProposal!.Status != FileTreeProposalStatus.FullyApplied &&
        FileTreeProposal.Status != FileTreeProposalStatus.Rejected;

    /// <summary>
    /// Current status of the proposal for display.
    /// </summary>
    public FileTreeProposalStatus? ProposalStatus =>
        FileTreeProposal?.Status;

    #endregion

    #region NEW: Proposal Detection Methods (v0.4.4h)

    /// <summary>
    /// Parse file tree proposal from this message's content and code blocks.
    /// Called after streaming completes or when loading existing messages.
    /// </summary>
    /// <param name="parser">The file tree parser service.</param>
    /// <param name="workspacePath">Current workspace path for validation.</param>
    /// <returns>True if a proposal was detected.</returns>
    public bool ParseFileTreeProposal(IFileTreeParser parser, string? workspacePath)
    {
        // Only assistant messages can have proposals
        if (Role != MessageRole.Assistant)
        {
            return false;
        }

        // Need at least 2 code blocks for a multi-file proposal
        if (CodeBlocks.Count < 2)
        {
            return false;
        }

        // Filter to applicable blocks with file paths
        var applicableBlocks = CodeBlocks
            .Where(b => b.BlockType == CodeBlockType.Implementation)
            .Where(b => !string.IsNullOrEmpty(b.TargetFilePath))
            .Select(b => b.ToModel())
            .ToList();

        if (applicableBlocks.Count < 2)
        {
            return false;
        }

        // Parse the proposal
        FileTreeProposal = parser.ParseProposal(Content, Id, applicableBlocks);

        if (FileTreeProposal == null)
        {
            return false;
        }

        // Create the ViewModel
        CreateProposalViewModel(workspacePath);

        return true;
    }

    /// <summary>
    /// Create the proposal ViewModel from the detected proposal.
    /// </summary>
    /// <param name="workspacePath">Workspace path for validation.</param>
    private void CreateProposalViewModel(string? workspacePath)
    {
        if (FileTreeProposal == null)
        {
            FileTreeProposalViewModel = null;
            return;
        }

        FileTreeProposalViewModel = new FileTreeProposalViewModel(
            FileTreeProposal,
            workspacePath);

        // Subscribe to status changes
        FileTreeProposalViewModel.PropertyChanged += (s, e) =>
        {
            if (e.PropertyName == nameof(FileTreeProposalViewModel.ProposalStatus))
            {
                OnPropertyChanged(nameof(ProposalStatus));
                OnPropertyChanged(nameof(ShowFileTreeProposal));
            }
        };
    }

    /// <summary>
    /// Update the proposal status after apply/reject.
    /// </summary>
    /// <param name="status">The new status.</param>
    public void UpdateProposalStatus(FileTreeProposalStatus status)
    {
        if (FileTreeProposal != null)
        {
            FileTreeProposal.Status = status;
            OnPropertyChanged(nameof(ProposalStatus));
            OnPropertyChanged(nameof(ShowFileTreeProposal));
        }
    }

    /// <summary>
    /// Clear the proposal (used when re-parsing or on error).
    /// </summary>
    public void ClearProposal()
    {
        FileTreeProposal = null;
        FileTreeProposalViewModel = null;
    }

    #endregion
}
```

### 2. IProposalDetectionService Interface

Contract for the proposal detection logic.

```csharp
// src/SeniorIntern.Core/Interfaces/IProposalDetectionService.cs
namespace SeniorIntern.Core.Interfaces;

using SeniorIntern.Core.Models;

/// <summary>
/// Service for detecting multi-file proposals in chat messages.
/// Abstracts the detection logic for testability.
/// </summary>
public interface IProposalDetectionService
{
    /// <summary>
    /// Detect a file tree proposal from message content and code blocks.
    /// </summary>
    /// <param name="messageContent">The full message text.</param>
    /// <param name="messageId">The message ID for linking.</param>
    /// <param name="codeBlocks">The code blocks extracted from the message.</param>
    /// <returns>A FileTreeProposal if detected, null otherwise.</returns>
    FileTreeProposal? DetectProposal(
        string messageContent,
        Guid messageId,
        IEnumerable<CodeBlock> codeBlocks);

    /// <summary>
    /// Check if a proposal should show the panel UI.
    /// Considers minimum file count and other thresholds.
    /// </summary>
    /// <param name="proposal">The proposal to check.</param>
    /// <returns>True if the panel should be shown.</returns>
    bool ShouldShowProposalPanel(FileTreeProposal? proposal);

    /// <summary>
    /// Get or create a cached proposal for a message.
    /// Used to avoid re-parsing on scroll/re-render.
    /// </summary>
    /// <param name="messageId">The message ID.</param>
    /// <returns>The cached proposal, or null if not cached.</returns>
    FileTreeProposal? GetCachedProposal(Guid messageId);

    /// <summary>
    /// Clear the proposal cache.
    /// </summary>
    void ClearCache();
}
```

### 3. ProposalDetectionService Implementation

```csharp
// src/SeniorIntern.Services/ProposalDetectionService.cs
namespace SeniorIntern.Services;

using System.Collections.Concurrent;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;

/// <summary>
/// Service for detecting multi-file proposals in chat messages.
/// Uses the FileTreeParser and applies detection thresholds.
/// </summary>
public class ProposalDetectionService : IProposalDetectionService
{
    private readonly IFileTreeParser _parser;
    private readonly ILogger<ProposalDetectionService> _logger;
    private readonly ProposalDetectionOptions _options;
    private readonly ConcurrentDictionary<Guid, FileTreeProposal?> _cache = new();

    /// <summary>
    /// Create a new proposal detection service.
    /// </summary>
    public ProposalDetectionService(
        IFileTreeParser parser,
        IOptions<ProposalDetectionOptions> options,
        ILogger<ProposalDetectionService> logger)
    {
        _parser = parser ?? throw new ArgumentNullException(nameof(parser));
        _options = options?.Value ?? new ProposalDetectionOptions();
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <inheritdoc/>
    public FileTreeProposal? DetectProposal(
        string messageContent,
        Guid messageId,
        IEnumerable<CodeBlock> codeBlocks)
    {
        // Check cache first
        if (_cache.TryGetValue(messageId, out var cached))
        {
            _logger.LogDebug("Returning cached proposal for message {MessageId}", messageId);
            return cached;
        }

        // Filter to applicable blocks
        var applicableBlocks = codeBlocks
            .Where(b => IsApplicableBlock(b))
            .ToList();

        // Check minimum threshold
        if (applicableBlocks.Count < _options.MinimumFilesForPanel)
        {
            _logger.LogDebug(
                "Message {MessageId} has {Count} applicable blocks, below threshold of {Threshold}",
                messageId, applicableBlocks.Count, _options.MinimumFilesForPanel);

            _cache.TryAdd(messageId, null);
            return null;
        }

        try
        {
            // Parse the proposal
            var proposal = _parser.ParseProposal(
                messageContent,
                messageId,
                applicableBlocks);

            if (proposal == null)
            {
                _logger.LogDebug("No proposal detected for message {MessageId}", messageId);
                _cache.TryAdd(messageId, null);
                return null;
            }

            _logger.LogInformation(
                "Detected multi-file proposal with {Count} files for message {MessageId}",
                proposal.FileCount, messageId);

            _cache.TryAdd(messageId, proposal);
            return proposal;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error detecting proposal for message {MessageId}", messageId);
            _cache.TryAdd(messageId, null);
            return null;
        }
    }

    /// <inheritdoc/>
    public bool ShouldShowProposalPanel(FileTreeProposal? proposal)
    {
        if (proposal == null)
        {
            return false;
        }

        // Must meet minimum file count
        if (proposal.FileCount < _options.MinimumFilesForPanel)
        {
            return false;
        }

        // Don't show for fully applied or rejected
        if (proposal.Status == FileTreeProposalStatus.FullyApplied ||
            proposal.Status == FileTreeProposalStatus.Rejected)
        {
            return false;
        }

        return true;
    }

    /// <inheritdoc/>
    public FileTreeProposal? GetCachedProposal(Guid messageId)
    {
        _cache.TryGetValue(messageId, out var proposal);
        return proposal;
    }

    /// <inheritdoc/>
    public void ClearCache()
    {
        _cache.Clear();
        _logger.LogDebug("Proposal cache cleared");
    }

    /// <summary>
    /// Check if a code block is applicable for multi-file proposals.
    /// </summary>
    private bool IsApplicableBlock(CodeBlock block)
    {
        // Must be implementation type
        if (block.BlockType != CodeBlockType.Implementation)
        {
            return false;
        }

        // Must have a file path
        if (string.IsNullOrEmpty(block.TargetFilePath))
        {
            return false;
        }

        // Check ignored languages
        if (_options.IgnoredLanguages.Contains(
            block.Language ?? string.Empty,
            StringComparer.OrdinalIgnoreCase))
        {
            return false;
        }

        return true;
    }
}

/// <summary>
/// Configuration options for proposal detection.
/// </summary>
public class ProposalDetectionOptions
{
    /// <summary>
    /// Minimum number of files required to show the proposal panel.
    /// Default: 2 (single files use the existing code block UI).
    /// </summary>
    public int MinimumFilesForPanel { get; set; } = 2;

    /// <summary>
    /// Whether to automatically detect proposals.
    /// </summary>
    public bool EnableAutoDetection { get; set; } = true;

    /// <summary>
    /// Languages to ignore when detecting proposals.
    /// These are typically output/display languages.
    /// </summary>
    public HashSet<string> IgnoredLanguages { get; set; } = new(StringComparer.OrdinalIgnoreCase)
    {
        "output",
        "text",
        "plaintext",
        "console",
        "log",
        "stdout",
        "stderr"
    };

    /// <summary>
    /// Maximum number of proposals to cache.
    /// </summary>
    public int MaxCacheSize { get; set; } = 100;
}
```

### 4. ChatProposalCoordinator

Orchestrates dialogs, progress overlay, and undo functionality.

```csharp
// src/SeniorIntern.Desktop/Services/ChatProposalCoordinator.cs
namespace SeniorIntern.Desktop.Services;

using Avalonia.Controls;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Desktop.ViewModels;
using SeniorIntern.Desktop.Views;

/// <summary>
/// Coordinates multi-file proposal workflows within the chat context.
/// Manages dialogs, progress overlay, and undo operations.
/// </summary>
public class ChatProposalCoordinator : IDisposable
{
    private readonly IFileTreeProposalService _proposalService;
    private readonly ApplyProgressViewModel _progressViewModel;
    private readonly ILogger<ChatProposalCoordinator> _logger;

    private CancellationTokenSource? _cts;
    private BatchApplyResult? _lastApplyResult;
    private FileTreeProposalViewModel? _lastAppliedProposal;

    /// <summary>
    /// Event raised when the undo toast should be shown.
    /// </summary>
    public event EventHandler<UndoToastEventArgs>? UndoToastRequested;

    /// <summary>
    /// Event raised when undo completes.
    /// </summary>
    public event EventHandler<UndoCompletedEventArgs>? UndoCompleted;

    /// <summary>
    /// The progress ViewModel for the overlay.
    /// Should be bound to ApplyProgressOverlay in the main window.
    /// </summary>
    public ApplyProgressViewModel ProgressViewModel => _progressViewModel;

    /// <summary>
    /// Whether an operation is currently in progress.
    /// </summary>
    public bool IsOperationInProgress => _progressViewModel.IsVisible;

    /// <summary>
    /// Create a new chat proposal coordinator.
    /// </summary>
    public ChatProposalCoordinator(
        IFileTreeProposalService proposalService,
        ApplyProgressViewModel progressViewModel,
        ILogger<ChatProposalCoordinator> logger)
    {
        _proposalService = proposalService ?? throw new ArgumentNullException(nameof(proposalService));
        _progressViewModel = progressViewModel ?? throw new ArgumentNullException(nameof(progressViewModel));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    #region Preview Workflow

    /// <summary>
    /// Show the batch preview dialog for the selected files.
    /// </summary>
    /// <param name="proposalVm">The proposal ViewModel.</param>
    /// <param name="workspacePath">The workspace root path.</param>
    /// <param name="owner">The owner window for the dialog.</param>
    /// <returns>True if user confirmed, false if cancelled.</returns>
    public async Task<bool> PreviewAsync(
        FileTreeProposalViewModel proposalVm,
        string workspacePath,
        Window owner)
    {
        _logger.LogDebug("Opening batch preview dialog for {Count} files", proposalVm.SelectedCount);

        try
        {
            // Generate diff previews for selected operations
            var previews = await _proposalService.PreviewProposalAsync(
                proposalVm.Proposal,
                workspacePath);

            if (!previews.Any())
            {
                _logger.LogWarning("No previews generated for proposal");
                return false;
            }

            // Create and show the dialog
            var dialogVm = new BatchPreviewDialogViewModel(previews.ToList());
            var dialog = new BatchPreviewDialog
            {
                DataContext = dialogVm
            };

            var result = await dialog.ShowDialog<bool>(owner);

            _logger.LogDebug("Batch preview dialog result: {Result}", result);
            return result;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error showing batch preview dialog");
            return false;
        }
    }

    #endregion

    #region Apply Workflow

    /// <summary>
    /// Apply the selected files from a proposal.
    /// Shows progress overlay during operation.
    /// </summary>
    /// <param name="proposalVm">The proposal ViewModel.</param>
    /// <param name="workspacePath">The workspace root path.</param>
    /// <param name="createBackups">Whether to create backup files.</param>
    /// <returns>The apply result.</returns>
    public async Task<BatchApplyResult> ApplyAsync(
        FileTreeProposalViewModel proposalVm,
        string workspacePath,
        bool createBackups = true)
    {
        if (IsOperationInProgress)
        {
            throw new InvalidOperationException("An operation is already in progress");
        }

        _logger.LogInformation(
            "Applying proposal with {Count} selected files",
            proposalVm.SelectedCount);

        _cts = new CancellationTokenSource();

        try
        {
            // Start progress overlay
            _progressViewModel.Start(_cts, proposalVm.SelectedCount);

            // Create progress adapter
            var progress = new ProgressReporterAdapter(_progressViewModel);

            // Execute apply
            var result = await _proposalService.ApplyProposalAsync(
                proposalVm.Proposal,
                workspacePath,
                new ApplyOptions { CreateBackup = createBackups },
                progress,
                _cts.Token);

            // Handle result
            if (result.AllSucceeded)
            {
                _progressViewModel.Complete();
                proposalVm.UpdateStatus(FileTreeProposalStatus.FullyApplied);
                _lastApplyResult = result;
                _lastAppliedProposal = proposalVm;

                // Request undo toast
                UndoToastRequested?.Invoke(this, new UndoToastEventArgs(result));

                _logger.LogInformation(
                    "Successfully applied {Count} files in {Duration:F1}s",
                    result.SuccessCount, result.Duration.TotalSeconds);
            }
            else if (result.WasCancelled)
            {
                _progressViewModel.RollbackComplete();
                proposalVm.UpdateStatus(FileTreeProposalStatus.Cancelled);

                _logger.LogInformation("Apply cancelled by user, rolled back");
            }
            else
            {
                var firstFailed = result.FailedResults.FirstOrDefault();
                _progressViewModel.Error(
                    $"Failed: {firstFailed?.FilePath ?? "Unknown error"}");

                proposalVm.UpdateStatus(FileTreeProposalStatus.PartiallyApplied);

                _logger.LogWarning(
                    "Apply completed with {FailedCount} failures",
                    result.FailedCount);
            }

            return result;
        }
        catch (OperationCanceledException)
        {
            _progressViewModel.RollbackComplete();
            proposalVm.UpdateStatus(FileTreeProposalStatus.Cancelled);

            _logger.LogInformation("Apply cancelled");

            return BatchApplyResult.Cancelled(
                Array.Empty<ApplyResult>(),
                DateTime.UtcNow);
        }
        catch (Exception ex)
        {
            _progressViewModel.Error(ex.Message);
            _logger.LogError(ex, "Error during apply");

            return BatchApplyResult.RolledBack(ex.Message, DateTime.UtcNow);
        }
        finally
        {
            _cts?.Dispose();
            _cts = null;
        }
    }

    /// <summary>
    /// Cancel the current apply operation.
    /// </summary>
    public void CancelApply()
    {
        if (_cts != null && !_cts.IsCancellationRequested)
        {
            _logger.LogInformation("Cancelling apply operation");
            _cts.Cancel();
        }
    }

    #endregion

    #region Undo Workflow

    /// <summary>
    /// Undo the last apply operation.
    /// </summary>
    /// <param name="workspacePath">The workspace root path.</param>
    /// <returns>True if undo succeeded.</returns>
    public async Task<bool> UndoLastApplyAsync(string workspacePath)
    {
        if (_lastApplyResult == null || !_lastApplyResult.CanUndoAll)
        {
            _logger.LogWarning("No undo available");
            return false;
        }

        _logger.LogInformation("Undoing last apply with {Count} files", _lastApplyResult.SuccessCount);

        try
        {
            await _proposalService.UndoBatchApplyAsync(_lastApplyResult, workspacePath);

            // Reset proposal status
            _lastAppliedProposal?.UpdateStatus(FileTreeProposalStatus.Pending);

            UndoCompleted?.Invoke(this, new UndoCompletedEventArgs(true, null));

            _lastApplyResult = null;
            _lastAppliedProposal = null;

            _logger.LogInformation("Undo completed successfully");
            return true;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error during undo");
            UndoCompleted?.Invoke(this, new UndoCompletedEventArgs(false, ex.Message));
            return false;
        }
    }

    /// <summary>
    /// Whether undo is available for the last operation.
    /// </summary>
    public bool CanUndo => _lastApplyResult?.CanUndoAll == true;

    /// <summary>
    /// Clear the undo state (e.g., after timeout or dismissal).
    /// </summary>
    public void ClearUndoState()
    {
        _lastApplyResult = null;
        _lastAppliedProposal = null;
    }

    #endregion

    #region IDisposable

    /// <summary>
    /// Clean up resources.
    /// </summary>
    public void Dispose()
    {
        _cts?.Cancel();
        _cts?.Dispose();
        _cts = null;
    }

    #endregion
}

/// <summary>
/// Event args for undo toast request.
/// </summary>
public class UndoToastEventArgs : EventArgs
{
    public BatchApplyResult Result { get; }
    public string Message => $"Created {Result.SuccessCount} file(s). Undo?";

    public UndoToastEventArgs(BatchApplyResult result)
    {
        Result = result;
    }
}

/// <summary>
/// Event args for undo completed.
/// </summary>
public class UndoCompletedEventArgs : EventArgs
{
    public bool Success { get; }
    public string? ErrorMessage { get; }

    public UndoCompletedEventArgs(bool success, string? errorMessage)
    {
        Success = success;
        ErrorMessage = errorMessage;
    }
}
```

### 5. ChatViewModel Updates

```csharp
// src/SeniorIntern.Desktop/ViewModels/ChatViewModel.cs (Partial - New additions for v0.4.4h)
namespace SeniorIntern.Desktop.ViewModels;

/// <summary>
/// Additions to ChatViewModel for v0.4.4h multi-file proposal integration.
/// </summary>
public partial class ChatViewModel
{
    #region NEW Dependencies (v0.4.4h)

    private readonly IProposalDetectionService _proposalDetectionService;
    private readonly ChatProposalCoordinator _proposalCoordinator;

    #endregion

    #region NEW Properties (v0.4.4h)

    /// <summary>
    /// The progress overlay ViewModel.
    /// Bound to ApplyProgressOverlay in the main window.
    /// </summary>
    public ApplyProgressViewModel ApplyProgressViewModel =>
        _proposalCoordinator.ProgressViewModel;

    /// <summary>
    /// Whether undo is available for the last apply.
    /// </summary>
    [ObservableProperty]
    [NotifyCanExecuteChangedFor(nameof(UndoLastApplyCommand))]
    private bool _canUndoLastApply;

    #endregion

    #region NEW Constructor Parameters (v0.4.4h)

    // Add these to the existing constructor:
    // IProposalDetectionService proposalDetectionService,
    // ChatProposalCoordinator proposalCoordinator

    private void InitializeProposalIntegration(
        IProposalDetectionService proposalDetectionService,
        ChatProposalCoordinator proposalCoordinator)
    {
        _proposalDetectionService = proposalDetectionService;
        _proposalCoordinator = proposalCoordinator;

        // Subscribe to coordinator events
        _proposalCoordinator.UndoToastRequested += OnUndoToastRequested;
        _proposalCoordinator.UndoCompleted += OnUndoCompleted;
    }

    #endregion

    #region NEW Methods (v0.4.4h)

    /// <summary>
    /// Called when streaming completes for a message.
    /// Triggers proposal detection.
    /// </summary>
    private async Task OnStreamingCompleteAsync(ChatMessageViewModel messageVm)
    {
        // Parse file tree proposal (existing code blocks should already be parsed)
        var hasProposal = messageVm.ParseFileTreeProposal(
            _proposalDetectionService,
            _workspacePath);

        if (hasProposal && messageVm.FileTreeProposalViewModel != null)
        {
            // Validate against workspace
            await messageVm.FileTreeProposalViewModel.ValidateAsync(_workspacePath);

            // Subscribe to proposal events
            SubscribeToProposalEvents(messageVm.FileTreeProposalViewModel);
        }
    }

    /// <summary>
    /// Subscribe to events from a proposal ViewModel.
    /// </summary>
    private void SubscribeToProposalEvents(FileTreeProposalViewModel proposalVm)
    {
        proposalVm.PreviewRequested += async (s, e) =>
        {
            var owner = GetDialogOwner();
            if (owner != null)
            {
                await _proposalCoordinator.PreviewAsync(proposalVm, _workspacePath!, owner);
            }
        };

        proposalVm.ApplyRequested += async (s, e) =>
        {
            await _proposalCoordinator.ApplyAsync(
                proposalVm,
                _workspacePath!,
                proposalVm.CreateBackups);
        };
    }

    /// <summary>
    /// Handle undo toast request from coordinator.
    /// </summary>
    private void OnUndoToastRequested(object? sender, UndoToastEventArgs e)
    {
        CanUndoLastApply = true;

        // Show undo toast via messenger or direct UI update
        WeakReferenceMessenger.Default.Send(new ShowUndoToastMessage(
            e.Message,
            UndoLastApplyCommand));

        // Auto-clear after timeout
        _ = ClearUndoAfterDelayAsync();
    }

    /// <summary>
    /// Handle undo completed from coordinator.
    /// </summary>
    private void OnUndoCompleted(object? sender, UndoCompletedEventArgs e)
    {
        CanUndoLastApply = false;

        if (e.Success)
        {
            // Show success notification
            WeakReferenceMessenger.Default.Send(new ShowNotificationMessage(
                "Undo complete. Files restored."));
        }
        else
        {
            // Show error notification
            WeakReferenceMessenger.Default.Send(new ShowNotificationMessage(
                $"Undo failed: {e.ErrorMessage}",
                NotificationType.Error));
        }
    }

    /// <summary>
    /// Clear undo state after timeout.
    /// </summary>
    private async Task ClearUndoAfterDelayAsync()
    {
        await Task.Delay(TimeSpan.FromSeconds(10));

        if (CanUndoLastApply)
        {
            CanUndoLastApply = false;
            _proposalCoordinator.ClearUndoState();
        }
    }

    /// <summary>
    /// Get the dialog owner window.
    /// </summary>
    private Window? GetDialogOwner()
    {
        // Implementation depends on how window reference is managed
        // Could use IWindowService or direct reference
        return Application.Current?.ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop
            ? desktop.MainWindow
            : null;
    }

    #endregion

    #region NEW Commands (v0.4.4h)

    /// <summary>
    /// Undo the last apply operation.
    /// </summary>
    [RelayCommand(CanExecute = nameof(CanUndoLastApply))]
    private async Task UndoLastApplyAsync()
    {
        if (!CanUndoLastApply || string.IsNullOrEmpty(_workspacePath))
        {
            return;
        }

        await _proposalCoordinator.UndoLastApplyAsync(_workspacePath);
    }

    #endregion
}
```

### 6. ChatMessageControl.axaml Updates

```xml
<!-- src/SeniorIntern.Desktop/Views/ChatMessageControl.axaml -->
<!-- Add this section after the CodeBlocks ItemsControl and before the Loading Indicator -->

<!-- Multi-File Proposal Panel (v0.4.4h) -->
<controls:FileTreeProposalPanel
    Grid.Row="4"
    IsVisible="{Binding ShowFileTreeProposal}"
    DataContext="{Binding FileTreeProposalViewModel}"
    Margin="0,12,0,0"
    AutomationProperties.Name="Multi-file proposal panel" />

<!-- Updated Grid layout showing the full structure -->
<!--
<Border x:Name="MessageBorder" ...>
    <StackPanel Spacing="8">
        Grid.Row="0": Role Label (TextBlock)
        Grid.Row="1": Content (SelectableTextBlock)
        Grid.Row="2": Code Blocks (ItemsControl)
        Grid.Row="3": Code Summary Panel (Border, if multiple applicable)
        Grid.Row="4": FileTreeProposalPanel (NEW - v0.4.4h)
        Grid.Row="5": Loading Indicator (StackPanel)
    </StackPanel>
</Border>
-->
```

### 7. Service Registration

```csharp
// src/SeniorIntern.Desktop/Extensions/ServiceCollectionExtensions.cs
namespace SeniorIntern.Desktop.Extensions;

using Microsoft.Extensions.DependencyInjection;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Desktop.Services;
using SeniorIntern.Desktop.ViewModels;
using SeniorIntern.Services;

/// <summary>
/// Service collection extensions for v0.4.4 multi-file creation.
/// </summary>
public static partial class ServiceCollectionExtensions
{
    /// <summary>
    /// Add v0.4.4 multi-file creation services.
    /// </summary>
    public static IServiceCollection AddMultiFileCreationServices(
        this IServiceCollection services)
    {
        // Core models are POCOs, no registration needed

        // v0.4.4b: File Tree Parser
        services.AddSingleton<IFileTreeParser, FileTreeParser>();

        // v0.4.4c: Proposal Service
        services.AddScoped<IFileTreeProposalService, FileTreeProposalService>();

        // v0.4.4d: Tree Building Service
        services.AddSingleton<ITreeBuildingService, TreeBuildingService>();

        // v0.4.4g: Progress ViewModel (singleton for global overlay)
        services.AddSingleton<ApplyProgressViewModel>();

        // v0.4.4h: Chat Integration
        services.AddSingleton<IProposalDetectionService, ProposalDetectionService>();
        services.AddScoped<ChatProposalCoordinator>();

        // Configure options
        services.Configure<ProposalDetectionOptions>(options =>
        {
            options.MinimumFilesForPanel = 2;
            options.EnableAutoDetection = true;
        });

        return services;
    }
}
```

### 8. MainWindow Integration

```xml
<!-- src/SeniorIntern.Desktop/Views/MainWindow.axaml -->
<!-- Add ApplyProgressOverlay to the main window content -->

<Window ...>
    <Grid>
        <!-- Main content grid -->
        <Grid x:Name="MainContent">
            <!-- Existing layout: sidebar, chat panel, etc. -->
        </Grid>

        <!-- Progress Overlay (v0.4.4h) - Above all content -->
        <controls:ApplyProgressOverlay
            DataContext="{Binding ChatViewModel.ApplyProgressViewModel}"
            Panel.ZIndex="100" />

        <!-- Undo Toast (v0.4.4h) - Above progress overlay -->
        <controls:UndoToast
            x:Name="UndoToast"
            Panel.ZIndex="101"
            VerticalAlignment="Bottom"
            HorizontalAlignment="Right"
            Margin="16" />
    </Grid>
</Window>
```

---

## Unit Tests

### ProposalDetectionServiceTests

```csharp
// tests/SeniorIntern.Services.Tests/ProposalDetectionServiceTests.cs
namespace SeniorIntern.Services.Tests;

using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.Extensions.Options;
using Moq;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Services;
using Xunit;

public class ProposalDetectionServiceTests
{
    private readonly Mock<IFileTreeParser> _mockParser;
    private readonly ProposalDetectionService _service;
    private readonly ProposalDetectionOptions _options;

    public ProposalDetectionServiceTests()
    {
        _mockParser = new Mock<IFileTreeParser>();
        _options = new ProposalDetectionOptions();
        _service = new ProposalDetectionService(
            _mockParser.Object,
            Options.Create(_options),
            NullLogger<ProposalDetectionService>.Instance);
    }

    [Fact]
    public void DetectProposal_ReturnsNull_WhenBelowThreshold()
    {
        // Arrange
        var blocks = new List<CodeBlock>
        {
            CreateCodeBlock("file1.cs") // Only 1 block, threshold is 2
        };

        // Act
        var result = _service.DetectProposal("content", Guid.NewGuid(), blocks);

        // Assert
        Assert.Null(result);
        _mockParser.Verify(
            p => p.ParseProposal(It.IsAny<string>(), It.IsAny<Guid>(), It.IsAny<IEnumerable<CodeBlock>>()),
            Times.Never);
    }

    [Fact]
    public void DetectProposal_CallsParser_WhenAboveThreshold()
    {
        // Arrange
        var messageId = Guid.NewGuid();
        var blocks = new List<CodeBlock>
        {
            CreateCodeBlock("file1.cs"),
            CreateCodeBlock("file2.cs")
        };

        var expectedProposal = new FileTreeProposal
        {
            Id = Guid.NewGuid(),
            MessageId = messageId
        };

        _mockParser
            .Setup(p => p.ParseProposal("content", messageId, It.IsAny<IEnumerable<CodeBlock>>()))
            .Returns(expectedProposal);

        // Act
        var result = _service.DetectProposal("content", messageId, blocks);

        // Assert
        Assert.Equal(expectedProposal, result);
    }

    [Fact]
    public void DetectProposal_FiltersIgnoredLanguages()
    {
        // Arrange
        var blocks = new List<CodeBlock>
        {
            CreateCodeBlock("file1.cs", "csharp"),
            CreateCodeBlock("output", "output") // Should be ignored
        };

        // Act
        var result = _service.DetectProposal("content", Guid.NewGuid(), blocks);

        // Assert
        Assert.Null(result); // Only 1 applicable block after filtering
    }

    [Fact]
    public void DetectProposal_CachesResults()
    {
        // Arrange
        var messageId = Guid.NewGuid();
        var blocks = new List<CodeBlock>
        {
            CreateCodeBlock("file1.cs"),
            CreateCodeBlock("file2.cs")
        };

        _mockParser
            .Setup(p => p.ParseProposal(It.IsAny<string>(), messageId, It.IsAny<IEnumerable<CodeBlock>>()))
            .Returns(new FileTreeProposal { Id = Guid.NewGuid() });

        // Act
        _service.DetectProposal("content", messageId, blocks);
        _service.DetectProposal("content", messageId, blocks);

        // Assert - Parser should only be called once
        _mockParser.Verify(
            p => p.ParseProposal(It.IsAny<string>(), It.IsAny<Guid>(), It.IsAny<IEnumerable<CodeBlock>>()),
            Times.Once);
    }

    [Fact]
    public void ShouldShowProposalPanel_ReturnsTrue_ForValidProposal()
    {
        // Arrange
        var proposal = new FileTreeProposal
        {
            Operations = new List<FileOperation>
            {
                new() { Path = "file1.cs" },
                new() { Path = "file2.cs" }
            }
        };

        // Act
        var result = _service.ShouldShowProposalPanel(proposal);

        // Assert
        Assert.True(result);
    }

    [Fact]
    public void ShouldShowProposalPanel_ReturnsFalse_ForFullyApplied()
    {
        // Arrange
        var proposal = new FileTreeProposal
        {
            Status = FileTreeProposalStatus.FullyApplied,
            Operations = new List<FileOperation>
            {
                new() { Path = "file1.cs" },
                new() { Path = "file2.cs" }
            }
        };

        // Act
        var result = _service.ShouldShowProposalPanel(proposal);

        // Assert
        Assert.False(result);
    }

    [Fact]
    public void GetCachedProposal_ReturnsNull_WhenNotCached()
    {
        // Act
        var result = _service.GetCachedProposal(Guid.NewGuid());

        // Assert
        Assert.Null(result);
    }

    [Fact]
    public void ClearCache_RemovesAllCachedProposals()
    {
        // Arrange
        var messageId = Guid.NewGuid();
        var blocks = new List<CodeBlock>
        {
            CreateCodeBlock("file1.cs"),
            CreateCodeBlock("file2.cs")
        };

        _mockParser
            .Setup(p => p.ParseProposal(It.IsAny<string>(), messageId, It.IsAny<IEnumerable<CodeBlock>>()))
            .Returns(new FileTreeProposal { Id = Guid.NewGuid() });

        _service.DetectProposal("content", messageId, blocks);

        // Act
        _service.ClearCache();

        // Assert
        var cached = _service.GetCachedProposal(messageId);
        Assert.Null(cached);
    }

    private static CodeBlock CreateCodeBlock(string path, string language = "csharp")
    {
        return new CodeBlock
        {
            Id = Guid.NewGuid(),
            TargetFilePath = path,
            Language = language,
            BlockType = CodeBlockType.Implementation,
            Content = "// code"
        };
    }
}
```

### ChatProposalCoordinatorTests

```csharp
// tests/SeniorIntern.Desktop.Tests/Services/ChatProposalCoordinatorTests.cs
namespace SeniorIntern.Desktop.Tests.Services;

using Microsoft.Extensions.Logging.Abstractions;
using Moq;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Desktop.Services;
using SeniorIntern.Desktop.ViewModels;
using Xunit;

public class ChatProposalCoordinatorTests
{
    private readonly Mock<IFileTreeProposalService> _mockProposalService;
    private readonly ApplyProgressViewModel _progressViewModel;
    private readonly ChatProposalCoordinator _coordinator;

    public ChatProposalCoordinatorTests()
    {
        _mockProposalService = new Mock<IFileTreeProposalService>();
        _progressViewModel = new ApplyProgressViewModel();
        _coordinator = new ChatProposalCoordinator(
            _mockProposalService.Object,
            _progressViewModel,
            NullLogger<ChatProposalCoordinator>.Instance);
    }

    [Fact]
    public void ProgressViewModel_ReturnsInjectedInstance()
    {
        // Assert
        Assert.Same(_progressViewModel, _coordinator.ProgressViewModel);
    }

    [Fact]
    public void IsOperationInProgress_IsFalse_Initially()
    {
        // Assert
        Assert.False(_coordinator.IsOperationInProgress);
    }

    [Fact]
    public void CanUndo_IsFalse_Initially()
    {
        // Assert
        Assert.False(_coordinator.CanUndo);
    }

    [Fact]
    public async Task ApplyAsync_CallsProposalService()
    {
        // Arrange
        var proposal = CreateTestProposal();
        var proposalVm = new FileTreeProposalViewModel(proposal, "/workspace");

        var expectedResult = BatchApplyResult.Success(
            new List<ApplyResult>
            {
                new() { Success = true, FilePath = "file1.cs" }
            },
            DateTime.UtcNow);

        _mockProposalService
            .Setup(s => s.ApplyProposalAsync(
                proposal,
                "/workspace",
                It.IsAny<ApplyOptions>(),
                It.IsAny<IProgress<BatchApplyProgress>>(),
                It.IsAny<CancellationToken>()))
            .ReturnsAsync(expectedResult);

        // Act
        var result = await _coordinator.ApplyAsync(proposalVm, "/workspace");

        // Assert
        Assert.True(result.AllSucceeded);
        _mockProposalService.Verify(
            s => s.ApplyProposalAsync(
                proposal,
                "/workspace",
                It.IsAny<ApplyOptions>(),
                It.IsAny<IProgress<BatchApplyProgress>>(),
                It.IsAny<CancellationToken>()),
            Times.Once);
    }

    [Fact]
    public async Task ApplyAsync_RaisesUndoToastRequested_OnSuccess()
    {
        // Arrange
        var proposal = CreateTestProposal();
        var proposalVm = new FileTreeProposalViewModel(proposal, "/workspace");

        var expectedResult = BatchApplyResult.Success(
            new List<ApplyResult>
            {
                new() { Success = true, FilePath = "file1.cs", CanUndo = true }
            },
            DateTime.UtcNow);

        _mockProposalService
            .Setup(s => s.ApplyProposalAsync(
                It.IsAny<FileTreeProposal>(),
                It.IsAny<string>(),
                It.IsAny<ApplyOptions>(),
                It.IsAny<IProgress<BatchApplyProgress>>(),
                It.IsAny<CancellationToken>()))
            .ReturnsAsync(expectedResult);

        UndoToastEventArgs? eventArgs = null;
        _coordinator.UndoToastRequested += (s, e) => eventArgs = e;

        // Act
        await _coordinator.ApplyAsync(proposalVm, "/workspace");

        // Assert
        Assert.NotNull(eventArgs);
        Assert.Equal(expectedResult, eventArgs!.Result);
    }

    [Fact]
    public async Task UndoLastApplyAsync_ReturnsTrue_OnSuccess()
    {
        // Arrange
        var proposal = CreateTestProposal();
        var proposalVm = new FileTreeProposalViewModel(proposal, "/workspace");

        var applyResult = BatchApplyResult.Success(
            new List<ApplyResult>
            {
                new() { Success = true, FilePath = "file1.cs", CanUndo = true }
            },
            DateTime.UtcNow);

        _mockProposalService
            .Setup(s => s.ApplyProposalAsync(
                It.IsAny<FileTreeProposal>(),
                It.IsAny<string>(),
                It.IsAny<ApplyOptions>(),
                It.IsAny<IProgress<BatchApplyProgress>>(),
                It.IsAny<CancellationToken>()))
            .ReturnsAsync(applyResult);

        _mockProposalService
            .Setup(s => s.UndoBatchApplyAsync(applyResult, "/workspace"))
            .Returns(Task.CompletedTask);

        await _coordinator.ApplyAsync(proposalVm, "/workspace");

        // Act
        var result = await _coordinator.UndoLastApplyAsync("/workspace");

        // Assert
        Assert.True(result);
        Assert.False(_coordinator.CanUndo);
    }

    [Fact]
    public void ClearUndoState_ClearsCanUndo()
    {
        // Arrange - simulate having undo state
        // (In real tests, would need to set up the state properly)

        // Act
        _coordinator.ClearUndoState();

        // Assert
        Assert.False(_coordinator.CanUndo);
    }

    private static FileTreeProposal CreateTestProposal()
    {
        return new FileTreeProposal
        {
            Id = Guid.NewGuid(),
            MessageId = Guid.NewGuid(),
            Operations = new List<FileOperation>
            {
                new() { Path = "file1.cs", Type = FileOperationType.Create, IsSelected = true }
            }
        };
    }
}
```

### ChatMessageViewModelProposalTests

```csharp
// tests/SeniorIntern.Desktop.Tests/ViewModels/ChatMessageViewModelProposalTests.cs
namespace SeniorIntern.Desktop.Tests.ViewModels;

using Moq;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Desktop.ViewModels;
using Xunit;

public class ChatMessageViewModelProposalTests
{
    [Fact]
    public void ParseFileTreeProposal_ReturnsFalse_ForUserMessages()
    {
        // Arrange
        var vm = new ChatMessageViewModel { Role = MessageRole.User };
        var mockParser = new Mock<IFileTreeParser>();

        // Act
        var result = vm.ParseFileTreeProposal(mockParser.Object, "/workspace");

        // Assert
        Assert.False(result);
        Assert.False(vm.HasFileTreeProposal);
    }

    [Fact]
    public void ParseFileTreeProposal_ReturnsFalse_WithLessThanTwoBlocks()
    {
        // Arrange
        var vm = new ChatMessageViewModel { Role = MessageRole.Assistant };
        vm.CodeBlocks.Add(CreateCodeBlockViewModel("file1.cs"));
        var mockParser = new Mock<IFileTreeParser>();

        // Act
        var result = vm.ParseFileTreeProposal(mockParser.Object, "/workspace");

        // Assert
        Assert.False(result);
    }

    [Fact]
    public void ParseFileTreeProposal_ReturnsTrue_WhenProposalDetected()
    {
        // Arrange
        var vm = new ChatMessageViewModel
        {
            Id = Guid.NewGuid(),
            Role = MessageRole.Assistant,
            Content = "Here are the files..."
        };
        vm.CodeBlocks.Add(CreateCodeBlockViewModel("file1.cs"));
        vm.CodeBlocks.Add(CreateCodeBlockViewModel("file2.cs"));

        var mockParser = new Mock<IFileTreeParser>();
        mockParser
            .Setup(p => p.ParseProposal(
                It.IsAny<string>(),
                It.IsAny<Guid>(),
                It.IsAny<IEnumerable<CodeBlock>>()))
            .Returns(new FileTreeProposal { Id = Guid.NewGuid() });

        // Act
        var result = vm.ParseFileTreeProposal(mockParser.Object, "/workspace");

        // Assert
        Assert.True(result);
        Assert.True(vm.HasFileTreeProposal);
        Assert.NotNull(vm.FileTreeProposal);
        Assert.NotNull(vm.FileTreeProposalViewModel);
    }

    [Fact]
    public void ShowFileTreeProposal_ReturnsFalse_WhenFullyApplied()
    {
        // Arrange
        var vm = new ChatMessageViewModel { Role = MessageRole.Assistant };
        vm.CodeBlocks.Add(CreateCodeBlockViewModel("file1.cs"));
        vm.CodeBlocks.Add(CreateCodeBlockViewModel("file2.cs"));

        var mockParser = new Mock<IFileTreeParser>();
        mockParser
            .Setup(p => p.ParseProposal(
                It.IsAny<string>(),
                It.IsAny<Guid>(),
                It.IsAny<IEnumerable<CodeBlock>>()))
            .Returns(new FileTreeProposal
            {
                Id = Guid.NewGuid(),
                Status = FileTreeProposalStatus.FullyApplied
            });

        vm.ParseFileTreeProposal(mockParser.Object, "/workspace");

        // Assert
        Assert.False(vm.ShowFileTreeProposal);
    }

    [Fact]
    public void UpdateProposalStatus_UpdatesShowFileTreeProposal()
    {
        // Arrange
        var vm = new ChatMessageViewModel { Role = MessageRole.Assistant };
        vm.CodeBlocks.Add(CreateCodeBlockViewModel("file1.cs"));
        vm.CodeBlocks.Add(CreateCodeBlockViewModel("file2.cs"));

        var mockParser = new Mock<IFileTreeParser>();
        mockParser
            .Setup(p => p.ParseProposal(
                It.IsAny<string>(),
                It.IsAny<Guid>(),
                It.IsAny<IEnumerable<CodeBlock>>()))
            .Returns(new FileTreeProposal { Id = Guid.NewGuid() });

        vm.ParseFileTreeProposal(mockParser.Object, "/workspace");

        // Pre-condition
        Assert.True(vm.ShowFileTreeProposal);

        // Act
        vm.UpdateProposalStatus(FileTreeProposalStatus.FullyApplied);

        // Assert
        Assert.False(vm.ShowFileTreeProposal);
    }

    [Fact]
    public void ClearProposal_RemovesProposalAndViewModel()
    {
        // Arrange
        var vm = new ChatMessageViewModel { Role = MessageRole.Assistant };
        vm.CodeBlocks.Add(CreateCodeBlockViewModel("file1.cs"));
        vm.CodeBlocks.Add(CreateCodeBlockViewModel("file2.cs"));

        var mockParser = new Mock<IFileTreeParser>();
        mockParser
            .Setup(p => p.ParseProposal(
                It.IsAny<string>(),
                It.IsAny<Guid>(),
                It.IsAny<IEnumerable<CodeBlock>>()))
            .Returns(new FileTreeProposal { Id = Guid.NewGuid() });

        vm.ParseFileTreeProposal(mockParser.Object, "/workspace");

        // Act
        vm.ClearProposal();

        // Assert
        Assert.Null(vm.FileTreeProposal);
        Assert.Null(vm.FileTreeProposalViewModel);
        Assert.False(vm.HasFileTreeProposal);
    }

    private static CodeBlockViewModel CreateCodeBlockViewModel(string path)
    {
        return new CodeBlockViewModel
        {
            Id = Guid.NewGuid(),
            TargetFilePath = path,
            BlockType = CodeBlockType.Implementation,
            Content = "// code"
        };
    }
}
```

---

## Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/IProposalDetectionService.cs` | Detection service contract |
| `src/SeniorIntern.Services/ProposalDetectionService.cs` | Detection service implementation |
| `src/SeniorIntern.Desktop/Services/ChatProposalCoordinator.cs` | Workflow coordinator |
| `tests/SeniorIntern.Services.Tests/ProposalDetectionServiceTests.cs` | Detection service tests |
| `tests/SeniorIntern.Desktop.Tests/Services/ChatProposalCoordinatorTests.cs` | Coordinator tests |
| `tests/SeniorIntern.Desktop.Tests/ViewModels/ChatMessageViewModelProposalTests.cs` | ViewModel tests |

---

## Files to Modify

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/ViewModels/ChatMessageViewModel.cs` | Add proposal properties and methods |
| `src/SeniorIntern.Desktop/ViewModels/ChatViewModel.cs` | Add coordinator integration and commands |
| `src/SeniorIntern.Desktop/Views/ChatMessageControl.axaml` | Add FileTreeProposalPanel placement |
| `src/SeniorIntern.Desktop/Views/MainWindow.axaml` | Add ApplyProgressOverlay |
| `src/SeniorIntern.Desktop/Extensions/ServiceCollectionExtensions.cs` | Register new services |
| `src/SeniorIntern.Desktop/App.axaml` | Add namespace imports if needed |

---

## Acceptance Criteria

- [ ] Multi-file proposals are automatically detected when assistant message streaming completes
- [ ] Proposals with 2+ applicable files show the FileTreeProposalPanel inline
- [ ] Proposals with only 1 file continue to use existing CodeBlock UI (no panel)
- [ ] Proposal panel appears after code blocks but before streaming indicator
- [ ] Preview button opens BatchPreviewDialog with all selected file diffs
- [ ] Create Files button starts apply with progress overlay
- [ ] Progress overlay blocks interaction during apply
- [ ] Cancel button on progress overlay cancels and rolls back
- [ ] Success shows undo toast for 10 seconds
- [ ] Undo button reverts all created files
- [ ] Panel hides after proposal is fully applied or rejected
- [ ] Proposal status persists when scrolling chat
- [ ] Detection results are cached per message ID
- [ ] Output/text blocks are excluded from proposal detection
- [ ] Workspace path is validated before apply
- [ ] All unit tests pass

---

## Design Decisions

### 1. Proposal Detection Threshold

**Decision**: Require minimum 2 applicable files to show proposal panel.

**Rationale**:
- Single-file changes use existing CodeBlock "Apply" button
- Multi-file panel adds value for batch operations
- Avoids clutter for simple code examples
- User can still use individual code block actions

### 2. Lazy ViewModel Creation

**Decision**: Create FileTreeProposalViewModel only when proposal is detected.

**Rationale**:
- Avoids unnecessary allocations
- Most messages won't have proposals
- Reduces memory footprint
- ViewModel creation triggers validation

### 3. Coordinator Pattern

**Decision**: Use ChatProposalCoordinator to orchestrate workflows.

**Rationale**:
- Separates workflow logic from ViewModel
- Easier to test independently
- Single responsibility principle
- Manages cross-cutting concerns (dialogs, progress, undo)

### 4. Event-Based Undo Toast

**Decision**: Use events for undo toast requests rather than direct UI coupling.

**Rationale**:
- Keeps coordinator UI-agnostic
- Allows different toast implementations
- Enables testing without UI
- Follows MVVM principles

### 5. Detection Caching

**Decision**: Cache proposal detection results by message ID.

**Rationale**:
- Avoids re-parsing on scroll/re-render
- Parser is potentially expensive
- Message content is immutable
- Clear on cache invalidation scenarios

---

## Accessibility Considerations

1. **Screen Reader Support**
   - Proposal panel has AutomationProperties.Name
   - Status changes announced via live regions
   - Progress updates are accessible

2. **Keyboard Navigation**
   - Proposal panel is focusable via Tab
   - All buttons have keyboard access
   - TreeView supports arrow key navigation
   - Escape cancels operations

3. **Focus Management**
   - Focus moves to progress overlay when shown
   - Focus returns to trigger element after dialog close
   - Undo toast is focusable and dismissible

---

## Performance Considerations

1. **Detection Performance**
   - Caching prevents repeated parsing
   - Minimum threshold avoids unnecessary work
   - Language filtering is done early

2. **Memory Efficiency**
   - Proposals created lazily
   - ViewModels disposed when messages removed
   - Cache has configurable size limit

3. **UI Responsiveness**
   - Detection runs after streaming completes
   - Progress updates are throttled
   - Validation runs asynchronously

---

## Future Enhancements

1. **Proposal Editing**
   - Edit file paths in proposal
   - Reorder files
   - Add/remove files manually

2. **Template Proposals**
   - Save proposals as templates
   - Apply templates to new projects
   - Share templates between workspaces

3. **Proposal History**
   - View previously applied proposals
   - Compare proposal versions
   - Restore from history

4. **Smart Detection**
   - ML-based proposal grouping
   - Auto-detect project structure
   - Suggest missing files

5. **Diff-Only Preview**
   - Show only changed lines
   - Collapse unchanged sections
   - Inline diff editing
