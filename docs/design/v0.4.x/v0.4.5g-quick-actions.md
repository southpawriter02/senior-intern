# v0.4.5g: Quick Actions - Design Specification

**Status**: _PLANNED_

## Executive Summary

This specification details the **Quick Actions** feature for The Senior Intern, providing inline action buttons on code blocks for rapid apply, copy, diff preview, and editor operations. Quick Actions enable users to interact with code snippets directly from the chat interface without navigating through menus, significantly improving workflow efficiency.

### Key Deliverables

| Component | Type | Purpose |
|-----------|------|---------|
| `QuickAction` | Record | Defines a single quick action with metadata |
| `QuickActionType` | Enum | Categorizes action types (Apply, Copy, Diff, etc.) |
| `IQuickActionService` | Interface | Contract for executing quick actions |
| `QuickActionService` | Class | Coordinates action execution with services |
| `CodeBlockQuickActionsViewModel` | ViewModel | Manages state and commands for quick action bar |
| `CodeBlockQuickActionsView` | View | AXAML view for the action button bar |
| `QuickActionButton` | UserControl | Reusable action button with state feedback |
| `QuickActionResult` | Record | Result of executing a quick action |

---

## Feature Overview

```
v0.4.5g: Quick Actions
â”œâ”€â”€ Core Models
â”‚   â”œâ”€â”€ QuickAction (record)
â”‚   â”‚   â”œâ”€â”€ Id (string) - Unique action identifier
â”‚   â”‚   â”œâ”€â”€ Type (QuickActionType) - Action category
â”‚   â”‚   â”œâ”€â”€ Label (string) - Display text
â”‚   â”‚   â”œâ”€â”€ Icon (string) - Icon resource key
â”‚   â”‚   â”œâ”€â”€ Tooltip (string) - Full description
â”‚   â”‚   â”œâ”€â”€ Shortcut (KeyboardShortcut?) - Optional keyboard shortcut
â”‚   â”‚   â”œâ”€â”€ IsEnabled (Func<CodeBlock, bool>) - Availability predicate
â”‚   â”‚   â””â”€â”€ Priority (int) - Display order (lower = first)
â”‚   â”œâ”€â”€ QuickActionType (enum)
â”‚   â”‚   â”œâ”€â”€ Apply - Apply code to file
â”‚   â”‚   â”œâ”€â”€ Copy - Copy to clipboard
â”‚   â”‚   â”œâ”€â”€ ShowDiff - Open diff viewer
â”‚   â”‚   â”œâ”€â”€ OpenFile - Open target file in editor
â”‚   â”‚   â”œâ”€â”€ ApplyWithOptions - Open options popup
â”‚   â”‚   â”œâ”€â”€ Reject - Mark as rejected
â”‚   â”‚   â”œâ”€â”€ RunCommand - Execute shell command
â”‚   â”‚   â””â”€â”€ InsertAtCursor - Insert at editor cursor
â”‚   â””â”€â”€ QuickActionResult (record)
â”‚       â”œâ”€â”€ IsSuccess (bool)
â”‚       â”œâ”€â”€ ActionType (QuickActionType)
â”‚       â”œâ”€â”€ Message (string?) - Success/error message
â”‚       â”œâ”€â”€ Data (object?) - Action-specific result data
â”‚       â””â”€â”€ Duration (TimeSpan) - Execution time
â”œâ”€â”€ Service Layer
â”‚   â”œâ”€â”€ IQuickActionService (interface)
â”‚   â”‚   â”œâ”€â”€ GetAvailableActions(CodeBlock) â†’ IEnumerable<QuickAction>
â”‚   â”‚   â”œâ”€â”€ ExecuteAsync(QuickAction, CodeBlock) â†’ QuickActionResult
â”‚   â”‚   â”œâ”€â”€ RegisterAction(QuickAction) â†’ void
â”‚   â”‚   â”œâ”€â”€ UnregisterAction(string actionId) â†’ void
â”‚   â”‚   â””â”€â”€ Events
â”‚   â”‚       â”œâ”€â”€ ActionExecuting
â”‚   â”‚       â””â”€â”€ ActionExecuted
â”‚   â””â”€â”€ QuickActionService (implementation)
â”‚       â”œâ”€â”€ Dependencies
â”‚       â”‚   â”œâ”€â”€ IFileChangeService
â”‚       â”‚   â”œâ”€â”€ IClipboardService
â”‚       â”‚   â”œâ”€â”€ IDiffService
â”‚       â”‚   â”œâ”€â”€ IEditorService
â”‚       â”‚   â”œâ”€â”€ ISettingsService
â”‚       â”‚   â””â”€â”€ IWorkspaceService
â”‚       â”œâ”€â”€ Default Actions
â”‚       â”‚   â”œâ”€â”€ apply - Apply code block
â”‚       â”‚   â”œâ”€â”€ copy - Copy to clipboard
â”‚       â”‚   â”œâ”€â”€ diff - Show diff preview
â”‚       â”‚   â”œâ”€â”€ open - Open file in editor
â”‚       â”‚   â”œâ”€â”€ options - Apply with options
â”‚       â”‚   â””â”€â”€ reject - Mark rejected
â”‚       â””â”€â”€ Action Execution
â”‚           â”œâ”€â”€ Validates action availability
â”‚           â”œâ”€â”€ Executes via appropriate service
â”‚           â”œâ”€â”€ Tracks execution metrics
â”‚           â””â”€â”€ Raises events
â”œâ”€â”€ ViewModel Layer
â”‚   â””â”€â”€ CodeBlockQuickActionsViewModel
â”‚       â”œâ”€â”€ Observable Properties
â”‚       â”‚   â”œâ”€â”€ CodeBlock (CodeBlock?)
â”‚       â”‚   â”œâ”€â”€ AvailableActions (ObservableCollection<QuickActionViewModel>)
â”‚       â”‚   â”œâ”€â”€ IsExecuting (bool)
â”‚       â”‚   â”œâ”€â”€ CurrentAction (QuickActionType?)
â”‚       â”‚   â”œâ”€â”€ StatusMessage (string?)
â”‚       â”‚   â”œâ”€â”€ HasError (bool)
â”‚       â”‚   â”œâ”€â”€ ShowStatus (bool)
â”‚       â”‚   â””â”€â”€ IsExpanded (bool) - For overflow menu
â”‚       â”œâ”€â”€ Computed Properties
â”‚       â”‚   â”œâ”€â”€ PrimaryActions â†’ First N visible actions
â”‚       â”‚   â”œâ”€â”€ OverflowActions â†’ Remaining actions
â”‚       â”‚   â”œâ”€â”€ HasOverflow (bool)
â”‚       â”‚   â”œâ”€â”€ CanApply (bool)
â”‚       â”‚   â”œâ”€â”€ CanShowDiff (bool)
â”‚       â”‚   â””â”€â”€ CanOpenFile (bool)
â”‚       â”œâ”€â”€ Commands
â”‚       â”‚   â”œâ”€â”€ ExecuteActionCommand (QuickAction)
â”‚       â”‚   â”œâ”€â”€ ApplyCommand
â”‚       â”‚   â”œâ”€â”€ CopyCommand
â”‚       â”‚   â”œâ”€â”€ ShowDiffCommand
â”‚       â”‚   â”œâ”€â”€ OpenInEditorCommand
â”‚       â”‚   â”œâ”€â”€ ShowOptionsCommand
â”‚       â”‚   â””â”€â”€ ToggleOverflowCommand
â”‚       â”œâ”€â”€ Events
â”‚       â”‚   â”œâ”€â”€ ShowDiffRequested
â”‚       â”‚   â”œâ”€â”€ ShowOptionsRequested
â”‚       â”‚   â””â”€â”€ StatusChanged
â”‚       â””â”€â”€ Methods
â”‚           â”œâ”€â”€ InitializeAsync(CodeBlock)
â”‚           â”œâ”€â”€ RefreshAvailability()
â”‚           â””â”€â”€ ClearStatusAfterDelay()
â”œâ”€â”€ View Layer
â”‚   â”œâ”€â”€ CodeBlockQuickActionsView.axaml
â”‚   â”‚   â”œâ”€â”€ Layout
â”‚   â”‚   â”‚   â”œâ”€â”€ Horizontal StackPanel for primary actions
â”‚   â”‚   â”‚   â”œâ”€â”€ Separator (when overflow exists)
â”‚   â”‚   â”‚   â””â”€â”€ Overflow dropdown button
â”‚   â”‚   â”œâ”€â”€ Primary Action Buttons
â”‚   â”‚   â”‚   â”œâ”€â”€ Apply (checkmark icon)
â”‚   â”‚   â”‚   â”œâ”€â”€ Copy (clipboard icon)
â”‚   â”‚   â”‚   â”œâ”€â”€ Diff (compare icon)
â”‚   â”‚   â”‚   â””â”€â”€ Open (external link icon)
â”‚   â”‚   â”œâ”€â”€ Overflow Menu
â”‚   â”‚   â”‚   â”œâ”€â”€ Apply with Options...
â”‚   â”‚   â”‚   â”œâ”€â”€ Reject
â”‚   â”‚   â”‚   â””â”€â”€ Run Command (if command block)
â”‚   â”‚   â””â”€â”€ Status Indicator
â”‚   â”‚       â”œâ”€â”€ Success checkmark
â”‚   â”‚       â”œâ”€â”€ Error icon
â”‚   â”‚       â””â”€â”€ Status message text
â”‚   â”œâ”€â”€ CodeBlockQuickActionsView.axaml.cs
â”‚   â”‚   â””â”€â”€ Code-behind with event handlers
â”‚   â””â”€â”€ QuickActionButton.axaml
â”‚       â”œâ”€â”€ Icon display
â”‚       â”œâ”€â”€ Loading spinner overlay
â”‚       â”œâ”€â”€ Success/error state
â”‚       â””â”€â”€ Tooltip with shortcut
â”œâ”€â”€ Integration
â”‚   â”œâ”€â”€ CodeBlockControl Integration
â”‚   â”‚   â”œâ”€â”€ Quick actions bar below code
â”‚   â”‚   â”œâ”€â”€ Hover to reveal (optional)
â”‚   â”‚   â””â”€â”€ Always visible setting
â”‚   â””â”€â”€ Keyboard Shortcut Integration
â”‚       â”œâ”€â”€ Context: CodeBlock
â”‚       â”œâ”€â”€ Ctrl+Enter â†’ Apply
â”‚       â”œâ”€â”€ Ctrl+C â†’ Copy (when block focused)
â”‚       â”œâ”€â”€ Ctrl+D â†’ Show Diff
â”‚       â””â”€â”€ Ctrl+Shift+Enter â†’ Apply with Options
â””â”€â”€ Styling
    â”œâ”€â”€ quick-actions-bar (container style)
    â”œâ”€â”€ quick-action-button (base button style)
    â”œâ”€â”€ quick-action-button:executing (loading state)
    â”œâ”€â”€ quick-action-button:success (success state)
    â”œâ”€â”€ quick-action-button:error (error state)
    â””â”€â”€ overflow-menu (dropdown style)
```

---

## Architecture

### Component Interaction Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         ChatMessageControl                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                        CodeBlockControl                             â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚  â”‚  â”‚                     Code Content Area                         â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  // Code displayed here with syntax highlighting       â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  public class Example { ... }                          â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚  â”‚                                                                     â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚  â”‚  â”‚              CodeBlockQuickActionsView                        â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚ [âœ“ Apply] [ğŸ“‹ Copy] [âŠ• Diff] [â†— Open] â”‚ [...] â”‚ status â”‚ â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚  â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    CodeBlockQuickActionsViewModel                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  State                          â”‚  Commands                         â”‚  â”‚
â”‚  â”‚  â”œâ”€ CodeBlock                   â”‚  â”œâ”€ ApplyCommand                  â”‚  â”‚
â”‚  â”‚  â”œâ”€ AvailableActions            â”‚  â”œâ”€ CopyCommand                   â”‚  â”‚
â”‚  â”‚  â”œâ”€ IsExecuting                 â”‚  â”œâ”€ ShowDiffCommand               â”‚  â”‚
â”‚  â”‚  â”œâ”€ CurrentAction               â”‚  â”œâ”€ OpenInEditorCommand           â”‚  â”‚
â”‚  â”‚  â”œâ”€ StatusMessage               â”‚  â”œâ”€ ShowOptionsCommand            â”‚  â”‚
â”‚  â”‚  â””â”€ HasError                    â”‚  â””â”€ ExecuteActionCommand          â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         IQuickActionService                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                      QuickActionService                             â”‚  â”‚
â”‚  â”‚                                                                     â”‚  â”‚
â”‚  â”‚  GetAvailableActions(block) â”€â”€â–º Filters by IsEnabled predicate     â”‚  â”‚
â”‚  â”‚  ExecuteAsync(action, block) â”€â”€â–º Routes to appropriate service     â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚                       â”‚                       â”‚
            â–¼                       â–¼                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ IFileChangeService â”‚  â”‚  IClipboardService â”‚  â”‚    IDiffService    â”‚
â”‚                    â”‚  â”‚                    â”‚  â”‚                    â”‚
â”‚ ApplyCodeBlockAsyncâ”‚  â”‚    SetTextAsync    â”‚  â”‚    ComputeDiff     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚                       â”‚                       â”‚
            â–¼                       â–¼                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   IEditorService   â”‚  â”‚  IWorkspaceService â”‚  â”‚  ISettingsService  â”‚
â”‚                    â”‚  â”‚                    â”‚  â”‚                    â”‚
â”‚    OpenFileAsync   â”‚  â”‚  CurrentWorkspace  â”‚  â”‚    GetSettings     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Quick Action Execution Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Quick Action Execution Flow                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  User clicks action button (e.g., "Apply")
         â”‚
         â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ ExecuteAction    â”‚â—„â”€â”€â”€ Triggered by button Command binding
  â”‚ Command invoked  â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ Check IsExecutingâ”‚â—„â”€â”€â”€ Prevent concurrent executions
  â”‚                  â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚ (Not executing)
           â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ Set IsExecuting  â”‚
  â”‚ = true           â”‚â—„â”€â”€â”€ Shows spinner on button
  â”‚ CurrentAction    â”‚
  â”‚ = actionType     â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ Call             â”‚
  â”‚ QuickActionServiceâ”‚
  â”‚ .ExecuteAsync()  â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ Route to         â”‚â”€â”€â”€â”€â–¶â”‚ Action Type Routing:                       â”‚
  â”‚ appropriate      â”‚     â”‚   Apply â†’ IFileChangeService.ApplyAsync()  â”‚
  â”‚ service          â”‚     â”‚   Copy â†’ IClipboardService.SetTextAsync()  â”‚
  â”‚                  â”‚     â”‚   Diff â†’ Raise ShowDiffRequested event     â”‚
  â”‚                  â”‚     â”‚   Open â†’ IEditorService.OpenFileAsync()    â”‚
  â”‚                  â”‚     â”‚   Options â†’ Raise ShowOptionsRequested     â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ Create           â”‚
  â”‚ QuickActionResultâ”‚â—„â”€â”€â”€ Success or failure with message
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚ Success                                     â”‚ Failure
           â–¼                                             â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ StatusMessage =  â”‚                        â”‚ StatusMessage =  â”‚
  â”‚ "Applied!" or    â”‚                        â”‚ error.Message    â”‚
  â”‚ "Copied!" etc.   â”‚                        â”‚ HasError = true  â”‚
  â”‚ HasError = false â”‚                        â”‚                  â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚                                           â”‚
           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ Update CodeBlock â”‚â—„â”€â”€â”€ If Apply: Status = Applied
  â”‚ Status           â”‚     If Reject: Status = Rejected
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ IsExecuting      â”‚
  â”‚ = false          â”‚
  â”‚ CurrentAction    â”‚
  â”‚ = null           â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ ClearStatus      â”‚â—„â”€â”€â”€ After 2 second delay
  â”‚ AfterDelay()     â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Action Availability Logic

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Action Availability Matrix                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  Action              â”‚ Availability Condition
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  Apply               â”‚ block.IsApplicable == true
                      â”‚ && block.Status == Pending
                      â”‚ && block.TargetFilePath != null
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  Copy                â”‚ Always available (block.Content not empty)
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  Show Diff           â”‚ block.IsApplicable == true
                      â”‚ && block.TargetFilePath != null
                      â”‚ && targetFile exists
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  Open in Editor      â”‚ block.TargetFilePath != null
                      â”‚ && targetFile exists
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  Apply with Options  â”‚ block.IsApplicable == true
                      â”‚ && block.Status == Pending
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  Reject              â”‚ block.Status == Pending
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  Run Command         â”‚ block.BlockType == Command
                      â”‚ && settings.AllowCommandExecution == true
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  Insert at Cursor    â”‚ editorService.HasActiveEditor == true
                      â”‚ && editorService.HasSelection == true


  Status-Based Visibility:

  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚   Pending    â”‚   â”‚   Applied    â”‚   â”‚   Rejected   â”‚
  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                  â”‚                  â”‚
         â–¼                  â–¼                  â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ Apply        â”‚   â”‚ Copy (only)  â”‚   â”‚ Copy (only)  â”‚
  â”‚ Copy         â”‚   â”‚ Open         â”‚   â”‚ Open         â”‚
  â”‚ Diff         â”‚   â”‚ View Diff    â”‚   â”‚              â”‚
  â”‚ Open         â”‚   â”‚              â”‚   â”‚              â”‚
  â”‚ Options...   â”‚   â”‚              â”‚   â”‚              â”‚
  â”‚ Reject       â”‚   â”‚              â”‚   â”‚              â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Detailed Design

### Core Models

#### QuickAction Record

```csharp
// src/SeniorIntern.Core/Models/QuickAction.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Defines a quick action that can be performed on a code block.
/// </summary>
/// <param name="Id">Unique identifier for the action</param>
/// <param name="Type">Category of the action</param>
/// <param name="Label">Short display text</param>
/// <param name="Icon">Icon resource key</param>
/// <param name="Tooltip">Full description for tooltip</param>
/// <param name="Shortcut">Optional keyboard shortcut</param>
/// <param name="IsEnabled">Predicate determining if action is available for a block</param>
/// <param name="Priority">Display order (lower values appear first)</param>
public sealed record QuickAction(
    string Id,
    QuickActionType Type,
    string Label,
    string Icon,
    string Tooltip,
    KeyboardShortcut? Shortcut,
    Func<CodeBlock, bool> IsEnabled,
    int Priority = 100)
{
    /// <summary>
    /// Creates the standard "Apply" action.
    /// </summary>
    public static QuickAction Apply() => new(
        Id: "apply",
        Type: QuickActionType.Apply,
        Label: "Apply",
        Icon: "CheckIcon",
        Tooltip: "Apply this code to the target file",
        Shortcut: KeyboardShortcut.Ctrl(Key.Enter),
        IsEnabled: block => block.IsApplicable &&
                           block.Status == CodeBlockStatus.Pending &&
                           !string.IsNullOrEmpty(block.TargetFilePath),
        Priority: 10);

    /// <summary>
    /// Creates the standard "Copy" action.
    /// </summary>
    public static QuickAction Copy() => new(
        Id: "copy",
        Type: QuickActionType.Copy,
        Label: "Copy",
        Icon: "CopyIcon",
        Tooltip: "Copy code to clipboard",
        Shortcut: KeyboardShortcut.Ctrl(Key.C),
        IsEnabled: block => !string.IsNullOrEmpty(block.Content),
        Priority: 20);

    /// <summary>
    /// Creates the standard "Show Diff" action.
    /// </summary>
    public static QuickAction ShowDiff() => new(
        Id: "diff",
        Type: QuickActionType.ShowDiff,
        Label: "Diff",
        Icon: "DiffIcon",
        Tooltip: "Show diff preview",
        Shortcut: KeyboardShortcut.Ctrl(Key.D),
        IsEnabled: block => block.IsApplicable &&
                           !string.IsNullOrEmpty(block.TargetFilePath),
        Priority: 30);

    /// <summary>
    /// Creates the standard "Open in Editor" action.
    /// </summary>
    public static QuickAction OpenInEditor() => new(
        Id: "open",
        Type: QuickActionType.OpenFile,
        Label: "Open",
        Icon: "ExternalLinkIcon",
        Tooltip: "Open target file in editor",
        Shortcut: null,
        IsEnabled: block => !string.IsNullOrEmpty(block.TargetFilePath),
        Priority: 40);

    /// <summary>
    /// Creates the standard "Apply with Options" action.
    /// </summary>
    public static QuickAction ApplyWithOptions() => new(
        Id: "options",
        Type: QuickActionType.ApplyWithOptions,
        Label: "Options...",
        Icon: "SettingsIcon",
        Tooltip: "Apply with custom options",
        Shortcut: KeyboardShortcut.CtrlShift(Key.Enter),
        IsEnabled: block => block.IsApplicable &&
                           block.Status == CodeBlockStatus.Pending,
        Priority: 50);

    /// <summary>
    /// Creates the standard "Reject" action.
    /// </summary>
    public static QuickAction Reject() => new(
        Id: "reject",
        Type: QuickActionType.Reject,
        Label: "Reject",
        Icon: "CrossIcon",
        Tooltip: "Mark this code block as rejected",
        Shortcut: null,
        IsEnabled: block => block.Status == CodeBlockStatus.Pending,
        Priority: 60);

    /// <summary>
    /// Creates the "Run Command" action for command blocks.
    /// </summary>
    public static QuickAction RunCommand() => new(
        Id: "run",
        Type: QuickActionType.RunCommand,
        Label: "Run",
        Icon: "PlayIcon",
        Tooltip: "Execute this command in terminal",
        Shortcut: KeyboardShortcut.Ctrl(Key.R),
        IsEnabled: block => block.BlockType == CodeBlockType.Command,
        Priority: 15);

    /// <summary>
    /// Creates the "Insert at Cursor" action.
    /// </summary>
    public static QuickAction InsertAtCursor() => new(
        Id: "insert",
        Type: QuickActionType.InsertAtCursor,
        Label: "Insert",
        Icon: "InsertIcon",
        Tooltip: "Insert code at editor cursor position",
        Shortcut: KeyboardShortcut.CtrlShift(Key.I),
        IsEnabled: block => !string.IsNullOrEmpty(block.Content),
        Priority: 45);
}
```

#### QuickActionType Enum

```csharp
// src/SeniorIntern.Core/Models/QuickActionType.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Categories of quick actions available on code blocks.
/// </summary>
public enum QuickActionType
{
    /// <summary>
    /// Apply the code block to the target file using default options.
    /// </summary>
    Apply,

    /// <summary>
    /// Copy the code content to the system clipboard.
    /// </summary>
    Copy,

    /// <summary>
    /// Open the diff viewer showing changes.
    /// </summary>
    ShowDiff,

    /// <summary>
    /// Open the target file in the default editor.
    /// </summary>
    OpenFile,

    /// <summary>
    /// Open the apply options popup for custom configuration.
    /// </summary>
    ApplyWithOptions,

    /// <summary>
    /// Mark the code block as rejected by the user.
    /// </summary>
    Reject,

    /// <summary>
    /// Execute a command block in the terminal.
    /// </summary>
    RunCommand,

    /// <summary>
    /// Insert code at the current editor cursor position.
    /// </summary>
    InsertAtCursor
}
```

#### QuickActionResult Record

```csharp
// src/SeniorIntern.Core/Models/QuickActionResult.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Result of executing a quick action.
/// </summary>
/// <param name="IsSuccess">Whether the action completed successfully</param>
/// <param name="ActionType">The type of action that was executed</param>
/// <param name="Message">Success message or error description</param>
/// <param name="Data">Action-specific result data</param>
/// <param name="Duration">Time taken to execute the action</param>
public sealed record QuickActionResult(
    bool IsSuccess,
    QuickActionType ActionType,
    string? Message = null,
    object? Data = null,
    TimeSpan Duration = default)
{
    /// <summary>
    /// Creates a successful result.
    /// </summary>
    public static QuickActionResult Success(
        QuickActionType actionType,
        string? message = null,
        object? data = null,
        TimeSpan duration = default) => new(
            IsSuccess: true,
            ActionType: actionType,
            Message: message,
            Data: data,
            Duration: duration);

    /// <summary>
    /// Creates a failed result.
    /// </summary>
    public static QuickActionResult Failure(
        QuickActionType actionType,
        string message,
        TimeSpan duration = default) => new(
            IsSuccess: false,
            ActionType: actionType,
            Message: message,
            Duration: duration);

    /// <summary>
    /// User-friendly message based on action type and result.
    /// </summary>
    public string DisplayMessage => IsSuccess
        ? ActionType switch
        {
            QuickActionType.Apply => "Applied!",
            QuickActionType.Copy => "Copied!",
            QuickActionType.ShowDiff => "Showing diff...",
            QuickActionType.OpenFile => "Opened!",
            QuickActionType.ApplyWithOptions => "Options opened",
            QuickActionType.Reject => "Rejected",
            QuickActionType.RunCommand => "Running...",
            QuickActionType.InsertAtCursor => "Inserted!",
            _ => Message ?? "Done!"
        }
        : Message ?? "Action failed";
}
```

### Service Layer

#### IQuickActionService Interface

```csharp
// src/SeniorIntern.Core/Interfaces/IQuickActionService.cs
using SeniorIntern.Core.Models;

namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Service for managing and executing quick actions on code blocks.
/// </summary>
public interface IQuickActionService
{
    /// <summary>
    /// Gets all actions available for the specified code block.
    /// </summary>
    /// <param name="block">The code block to get actions for</param>
    /// <returns>Available actions sorted by priority</returns>
    IEnumerable<QuickAction> GetAvailableActions(CodeBlock block);

    /// <summary>
    /// Gets all registered actions regardless of availability.
    /// </summary>
    IEnumerable<QuickAction> GetAllActions();

    /// <summary>
    /// Executes the specified action on a code block.
    /// </summary>
    /// <param name="action">The action to execute</param>
    /// <param name="block">The target code block</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>Result of the action execution</returns>
    Task<QuickActionResult> ExecuteAsync(
        QuickAction action,
        CodeBlock block,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Executes an action by its ID.
    /// </summary>
    /// <param name="actionId">The action identifier</param>
    /// <param name="block">The target code block</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>Result of the action execution</returns>
    Task<QuickActionResult> ExecuteByIdAsync(
        string actionId,
        CodeBlock block,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Registers a custom action.
    /// </summary>
    /// <param name="action">The action to register</param>
    void RegisterAction(QuickAction action);

    /// <summary>
    /// Unregisters an action by its ID.
    /// </summary>
    /// <param name="actionId">The action ID to remove</param>
    /// <returns>True if the action was removed</returns>
    bool UnregisterAction(string actionId);

    /// <summary>
    /// Gets an action by its ID.
    /// </summary>
    /// <param name="actionId">The action identifier</param>
    /// <returns>The action or null if not found</returns>
    QuickAction? GetAction(string actionId);

    /// <summary>
    /// Raised before an action is executed.
    /// </summary>
    event EventHandler<QuickActionExecutingEventArgs>? ActionExecuting;

    /// <summary>
    /// Raised after an action is executed.
    /// </summary>
    event EventHandler<QuickActionExecutedEventArgs>? ActionExecuted;
}

/// <summary>
/// Event args for ActionExecuting event.
/// </summary>
public sealed class QuickActionExecutingEventArgs : EventArgs
{
    public required QuickAction Action { get; init; }
    public required CodeBlock Block { get; init; }
    public bool Cancel { get; set; }
}

/// <summary>
/// Event args for ActionExecuted event.
/// </summary>
public sealed class QuickActionExecutedEventArgs : EventArgs
{
    public required QuickAction Action { get; init; }
    public required CodeBlock Block { get; init; }
    public required QuickActionResult Result { get; init; }
}
```

#### QuickActionService Implementation

```csharp
// src/SeniorIntern.Services/QuickActionService.cs
using System.Collections.Concurrent;
using System.Diagnostics;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;

namespace SeniorIntern.Services;

/// <summary>
/// Implements quick action management and execution.
/// </summary>
public sealed class QuickActionService : IQuickActionService
{
    private readonly IFileChangeService _fileChangeService;
    private readonly IClipboardService _clipboardService;
    private readonly IDiffService _diffService;
    private readonly IEditorService _editorService;
    private readonly IWorkspaceService _workspaceService;
    private readonly ISettingsService _settingsService;
    private readonly ITerminalService? _terminalService;

    private readonly ConcurrentDictionary<string, QuickAction> _actions = new();

    public event EventHandler<QuickActionExecutingEventArgs>? ActionExecuting;
    public event EventHandler<QuickActionExecutedEventArgs>? ActionExecuted;

    public QuickActionService(
        IFileChangeService fileChangeService,
        IClipboardService clipboardService,
        IDiffService diffService,
        IEditorService editorService,
        IWorkspaceService workspaceService,
        ISettingsService settingsService,
        ITerminalService? terminalService = null)
    {
        _fileChangeService = fileChangeService;
        _clipboardService = clipboardService;
        _diffService = diffService;
        _editorService = editorService;
        _workspaceService = workspaceService;
        _settingsService = settingsService;
        _terminalService = terminalService;

        RegisterDefaultActions();
    }

    /// <summary>
    /// Registers all built-in quick actions.
    /// </summary>
    private void RegisterDefaultActions()
    {
        RegisterAction(QuickAction.Apply());
        RegisterAction(QuickAction.Copy());
        RegisterAction(QuickAction.ShowDiff());
        RegisterAction(QuickAction.OpenInEditor());
        RegisterAction(QuickAction.ApplyWithOptions());
        RegisterAction(QuickAction.Reject());
        RegisterAction(QuickAction.RunCommand());
        RegisterAction(QuickAction.InsertAtCursor());
    }

    public IEnumerable<QuickAction> GetAvailableActions(CodeBlock block)
    {
        ArgumentNullException.ThrowIfNull(block);

        return _actions.Values
            .Where(action => action.IsEnabled(block))
            .OrderBy(action => action.Priority);
    }

    public IEnumerable<QuickAction> GetAllActions() =>
        _actions.Values.OrderBy(a => a.Priority);

    public async Task<QuickActionResult> ExecuteAsync(
        QuickAction action,
        CodeBlock block,
        CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(action);
        ArgumentNullException.ThrowIfNull(block);

        var stopwatch = Stopwatch.StartNew();

        // Raise executing event
        var executingArgs = new QuickActionExecutingEventArgs
        {
            Action = action,
            Block = block
        };
        ActionExecuting?.Invoke(this, executingArgs);

        if (executingArgs.Cancel)
        {
            return QuickActionResult.Failure(
                action.Type,
                "Action was cancelled",
                stopwatch.Elapsed);
        }

        QuickActionResult result;
        try
        {
            result = action.Type switch
            {
                QuickActionType.Apply => await ExecuteApplyAsync(block, cancellationToken),
                QuickActionType.Copy => await ExecuteCopyAsync(block, cancellationToken),
                QuickActionType.ShowDiff => ExecuteShowDiff(block),
                QuickActionType.OpenFile => await ExecuteOpenFileAsync(block, cancellationToken),
                QuickActionType.ApplyWithOptions => ExecuteApplyWithOptions(block),
                QuickActionType.Reject => ExecuteReject(block),
                QuickActionType.RunCommand => await ExecuteRunCommandAsync(block, cancellationToken),
                QuickActionType.InsertAtCursor => await ExecuteInsertAtCursorAsync(block, cancellationToken),
                _ => QuickActionResult.Failure(action.Type, $"Unknown action type: {action.Type}")
            };
        }
        catch (OperationCanceledException)
        {
            result = QuickActionResult.Failure(
                action.Type,
                "Operation was cancelled",
                stopwatch.Elapsed);
        }
        catch (Exception ex)
        {
            result = QuickActionResult.Failure(
                action.Type,
                ex.Message,
                stopwatch.Elapsed);
        }

        stopwatch.Stop();
        result = result with { Duration = stopwatch.Elapsed };

        // Raise executed event
        ActionExecuted?.Invoke(this, new QuickActionExecutedEventArgs
        {
            Action = action,
            Block = block,
            Result = result
        });

        return result;
    }

    public async Task<QuickActionResult> ExecuteByIdAsync(
        string actionId,
        CodeBlock block,
        CancellationToken cancellationToken = default)
    {
        var action = GetAction(actionId);
        if (action is null)
        {
            return QuickActionResult.Failure(
                QuickActionType.Apply, // Default type for unknown
                $"Unknown action: {actionId}");
        }

        return await ExecuteAsync(action, block, cancellationToken);
    }

    public void RegisterAction(QuickAction action)
    {
        ArgumentNullException.ThrowIfNull(action);
        _actions[action.Id] = action;
    }

    public bool UnregisterAction(string actionId) =>
        _actions.TryRemove(actionId, out _);

    public QuickAction? GetAction(string actionId) =>
        _actions.TryGetValue(actionId, out var action) ? action : null;

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Action Implementations
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    private async Task<QuickActionResult> ExecuteApplyAsync(
        CodeBlock block,
        CancellationToken cancellationToken)
    {
        if (string.IsNullOrEmpty(block.TargetFilePath))
        {
            return QuickActionResult.Failure(
                QuickActionType.Apply,
                "No target file path specified");
        }

        var workspace = _workspaceService.CurrentWorkspace;
        if (workspace is null)
        {
            return QuickActionResult.Failure(
                QuickActionType.Apply,
                "No workspace is open");
        }

        var fullPath = Path.Combine(workspace.RootPath, block.TargetFilePath);

        var result = await _fileChangeService.ApplyCodeBlockAsync(
            block,
            ApplyOptions.Default,
            cancellationToken);

        if (result.Success)
        {
            block.Status = CodeBlockStatus.Applied;
            return QuickActionResult.Success(
                QuickActionType.Apply,
                "Applied successfully",
                data: result);
        }

        return QuickActionResult.Failure(
            QuickActionType.Apply,
            result.ErrorMessage ?? "Apply failed");
    }

    private async Task<QuickActionResult> ExecuteCopyAsync(
        CodeBlock block,
        CancellationToken cancellationToken)
    {
        if (string.IsNullOrEmpty(block.Content))
        {
            return QuickActionResult.Failure(
                QuickActionType.Copy,
                "Code block is empty");
        }

        await _clipboardService.SetTextAsync(block.Content);

        return QuickActionResult.Success(QuickActionType.Copy);
    }

    private QuickActionResult ExecuteShowDiff(CodeBlock block)
    {
        // This action raises an event that the ViewModel handles
        // to show the diff panel. The service just validates.
        if (string.IsNullOrEmpty(block.TargetFilePath))
        {
            return QuickActionResult.Failure(
                QuickActionType.ShowDiff,
                "No target file to compare against");
        }

        // Return success - the ViewModel will handle showing the diff
        return QuickActionResult.Success(
            QuickActionType.ShowDiff,
            data: block);
    }

    private async Task<QuickActionResult> ExecuteOpenFileAsync(
        CodeBlock block,
        CancellationToken cancellationToken)
    {
        if (string.IsNullOrEmpty(block.TargetFilePath))
        {
            return QuickActionResult.Failure(
                QuickActionType.OpenFile,
                "No target file specified");
        }

        var workspace = _workspaceService.CurrentWorkspace;
        if (workspace is null)
        {
            return QuickActionResult.Failure(
                QuickActionType.OpenFile,
                "No workspace is open");
        }

        var fullPath = Path.Combine(workspace.RootPath, block.TargetFilePath);

        if (!File.Exists(fullPath))
        {
            return QuickActionResult.Failure(
                QuickActionType.OpenFile,
                "File does not exist");
        }

        await _editorService.OpenFileAsync(fullPath);

        return QuickActionResult.Success(QuickActionType.OpenFile);
    }

    private QuickActionResult ExecuteApplyWithOptions(CodeBlock block)
    {
        // This action raises an event that the ViewModel handles
        // to show the options popup. The service just validates.
        if (!block.IsApplicable)
        {
            return QuickActionResult.Failure(
                QuickActionType.ApplyWithOptions,
                "Block is not applicable");
        }

        // Return success - the ViewModel will handle showing the popup
        return QuickActionResult.Success(
            QuickActionType.ApplyWithOptions,
            data: block);
    }

    private QuickActionResult ExecuteReject(CodeBlock block)
    {
        if (block.Status != CodeBlockStatus.Pending)
        {
            return QuickActionResult.Failure(
                QuickActionType.Reject,
                "Block is not pending");
        }

        block.Status = CodeBlockStatus.Rejected;

        return QuickActionResult.Success(QuickActionType.Reject);
    }

    private async Task<QuickActionResult> ExecuteRunCommandAsync(
        CodeBlock block,
        CancellationToken cancellationToken)
    {
        if (block.BlockType != CodeBlockType.Command)
        {
            return QuickActionResult.Failure(
                QuickActionType.RunCommand,
                "Block is not a command");
        }

        if (_terminalService is null)
        {
            return QuickActionResult.Failure(
                QuickActionType.RunCommand,
                "Terminal service is not available");
        }

        var settings = await _settingsService.GetSettingsAsync();

        // Security check - could be expanded based on settings
        // For now, we just execute the command
        await _terminalService.ExecuteCommandAsync(
            block.Content,
            cancellationToken);

        return QuickActionResult.Success(
            QuickActionType.RunCommand,
            "Command sent to terminal");
    }

    private async Task<QuickActionResult> ExecuteInsertAtCursorAsync(
        CodeBlock block,
        CancellationToken cancellationToken)
    {
        if (string.IsNullOrEmpty(block.Content))
        {
            return QuickActionResult.Failure(
                QuickActionType.InsertAtCursor,
                "Code block is empty");
        }

        var hasActiveEditor = await _editorService.HasActiveEditorAsync();
        if (!hasActiveEditor)
        {
            return QuickActionResult.Failure(
                QuickActionType.InsertAtCursor,
                "No active editor");
        }

        await _editorService.InsertAtCursorAsync(block.Content);

        return QuickActionResult.Success(QuickActionType.InsertAtCursor);
    }
}
```

### ViewModel Layer

#### CodeBlockQuickActionsViewModel

```csharp
// src/SeniorIntern.Desktop/ViewModels/CodeBlockQuickActionsViewModel.cs
using System.Collections.ObjectModel;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;

namespace SeniorIntern.Desktop.ViewModels;

/// <summary>
/// ViewModel for the code block quick actions bar.
/// </summary>
public partial class CodeBlockQuickActionsViewModel : ViewModelBase
{
    private readonly IQuickActionService _quickActionService;
    private readonly ISettingsService _settingsService;

    private const int MaxVisibleActions = 4;
    private const int StatusDisplayDurationMs = 2000;
    private CancellationTokenSource? _statusClearCts;

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Observable Properties
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(CanApply))]
    [NotifyPropertyChangedFor(nameof(CanShowDiff))]
    [NotifyPropertyChangedFor(nameof(CanOpenFile))]
    [NotifyPropertyChangedFor(nameof(HasTargetFile))]
    [NotifyPropertyChangedFor(nameof(TargetFileName))]
    private CodeBlock? _codeBlock;

    [ObservableProperty]
    private ObservableCollection<QuickActionViewModel> _availableActions = new();

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(ShowStatus))]
    private bool _isExecuting;

    [ObservableProperty]
    private QuickActionType? _currentAction;

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(ShowStatus))]
    private string? _statusMessage;

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(ShowStatus))]
    private bool _hasError;

    [ObservableProperty]
    private bool _isExpanded;

    [ObservableProperty]
    private bool _isCopied;

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Computed Properties
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /// <summary>
    /// Actions visible in the main button bar.
    /// </summary>
    public IEnumerable<QuickActionViewModel> PrimaryActions =>
        AvailableActions.Take(MaxVisibleActions);

    /// <summary>
    /// Actions shown in the overflow menu.
    /// </summary>
    public IEnumerable<QuickActionViewModel> OverflowActions =>
        AvailableActions.Skip(MaxVisibleActions);

    /// <summary>
    /// Whether there are overflow actions to show.
    /// </summary>
    public bool HasOverflow => AvailableActions.Count > MaxVisibleActions;

    /// <summary>
    /// Whether the Apply action is available.
    /// </summary>
    public bool CanApply => CodeBlock?.IsApplicable == true &&
                            CodeBlock?.Status == CodeBlockStatus.Pending &&
                            !string.IsNullOrEmpty(CodeBlock?.TargetFilePath);

    /// <summary>
    /// Whether the Show Diff action is available.
    /// </summary>
    public bool CanShowDiff => CodeBlock?.IsApplicable == true &&
                               !string.IsNullOrEmpty(CodeBlock?.TargetFilePath);

    /// <summary>
    /// Whether the Open in Editor action is available.
    /// </summary>
    public bool CanOpenFile => !string.IsNullOrEmpty(CodeBlock?.TargetFilePath);

    /// <summary>
    /// Whether the code block has a target file.
    /// </summary>
    public bool HasTargetFile => !string.IsNullOrEmpty(CodeBlock?.TargetFilePath);

    /// <summary>
    /// Display name of the target file.
    /// </summary>
    public string? TargetFileName => CodeBlock?.TargetFilePath is { } path
        ? Path.GetFileName(path)
        : null;

    /// <summary>
    /// Whether to show the status indicator.
    /// </summary>
    public bool ShowStatus => IsExecuting ||
                              !string.IsNullOrEmpty(StatusMessage);

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Events
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /// <summary>
    /// Raised when the diff viewer should be shown.
    /// </summary>
    public event EventHandler<CodeBlock>? ShowDiffRequested;

    /// <summary>
    /// Raised when the options popup should be shown.
    /// </summary>
    public event EventHandler<CodeBlock>? ShowOptionsRequested;

    /// <summary>
    /// Raised when the code block status changes.
    /// </summary>
    public event EventHandler<CodeBlockStatus>? StatusChanged;

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Constructor
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    public CodeBlockQuickActionsViewModel(
        IQuickActionService quickActionService,
        ISettingsService settingsService)
    {
        _quickActionService = quickActionService;
        _settingsService = settingsService;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Initialization
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /// <summary>
    /// Initializes the view model with a code block.
    /// </summary>
    public void Initialize(CodeBlock block)
    {
        CodeBlock = block;
        RefreshAvailableActions();
    }

    /// <summary>
    /// Refreshes the list of available actions.
    /// </summary>
    public void RefreshAvailableActions()
    {
        AvailableActions.Clear();

        if (CodeBlock is null) return;

        var actions = _quickActionService.GetAvailableActions(CodeBlock);
        foreach (var action in actions)
        {
            AvailableActions.Add(new QuickActionViewModel(action));
        }

        OnPropertyChanged(nameof(PrimaryActions));
        OnPropertyChanged(nameof(OverflowActions));
        OnPropertyChanged(nameof(HasOverflow));
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Commands
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    [RelayCommand(CanExecute = nameof(CanExecuteAction))]
    private async Task ExecuteActionAsync(QuickAction action)
    {
        if (CodeBlock is null || IsExecuting) return;

        IsExecuting = true;
        CurrentAction = action.Type;
        HasError = false;
        StatusMessage = null;

        try
        {
            var result = await _quickActionService.ExecuteAsync(action, CodeBlock);

            // Handle special actions that need ViewModel coordination
            if (result.IsSuccess)
            {
                switch (action.Type)
                {
                    case QuickActionType.ShowDiff:
                        ShowDiffRequested?.Invoke(this, CodeBlock);
                        break;
                    case QuickActionType.ApplyWithOptions:
                        ShowOptionsRequested?.Invoke(this, CodeBlock);
                        break;
                    case QuickActionType.Copy:
                        IsCopied = true;
                        break;
                }
            }

            HasError = !result.IsSuccess;
            StatusMessage = result.DisplayMessage;

            // Notify if status changed
            if (result.IsSuccess &&
                (action.Type == QuickActionType.Apply || action.Type == QuickActionType.Reject))
            {
                StatusChanged?.Invoke(this, CodeBlock.Status);
                RefreshAvailableActions();
            }
        }
        catch (Exception ex)
        {
            HasError = true;
            StatusMessage = ex.Message;
        }
        finally
        {
            IsExecuting = false;
            CurrentAction = null;
            await ClearStatusAfterDelayAsync();
        }
    }

    private bool CanExecuteAction(QuickAction? action) =>
        action is not null && CodeBlock is not null && !IsExecuting;

    [RelayCommand(CanExecute = nameof(CanApply))]
    private async Task ApplyAsync()
    {
        var action = _quickActionService.GetAction("apply");
        if (action is not null)
        {
            await ExecuteActionAsync(action);
        }
    }

    [RelayCommand]
    private async Task CopyAsync()
    {
        var action = _quickActionService.GetAction("copy");
        if (action is not null)
        {
            await ExecuteActionAsync(action);
        }
    }

    [RelayCommand(CanExecute = nameof(CanShowDiff))]
    private async Task ShowDiffAsync()
    {
        var action = _quickActionService.GetAction("diff");
        if (action is not null)
        {
            await ExecuteActionAsync(action);
        }
    }

    [RelayCommand(CanExecute = nameof(CanOpenFile))]
    private async Task OpenInEditorAsync()
    {
        var action = _quickActionService.GetAction("open");
        if (action is not null)
        {
            await ExecuteActionAsync(action);
        }
    }

    [RelayCommand]
    private async Task ShowOptionsAsync()
    {
        var action = _quickActionService.GetAction("options");
        if (action is not null)
        {
            await ExecuteActionAsync(action);
        }
    }

    [RelayCommand]
    private void ToggleOverflow()
    {
        IsExpanded = !IsExpanded;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Private Methods
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    private async Task ClearStatusAfterDelayAsync()
    {
        // Cancel any pending clear
        _statusClearCts?.Cancel();
        _statusClearCts = new CancellationTokenSource();

        try
        {
            await Task.Delay(StatusDisplayDurationMs, _statusClearCts.Token);
            StatusMessage = null;
            HasError = false;
            IsCopied = false;
        }
        catch (TaskCanceledException)
        {
            // Ignored - a new status message was set
        }
    }

    partial void OnCodeBlockChanged(CodeBlock? value)
    {
        RefreshAvailableActions();
        ApplyCommand.NotifyCanExecuteChanged();
        ShowDiffCommand.NotifyCanExecuteChanged();
        OpenInEditorCommand.NotifyCanExecuteChanged();
    }
}

/// <summary>
/// ViewModel wrapper for a single quick action.
/// </summary>
public sealed class QuickActionViewModel : ViewModelBase
{
    public QuickAction Action { get; }

    public string Id => Action.Id;
    public QuickActionType Type => Action.Type;
    public string Label => Action.Label;
    public string Icon => Action.Icon;
    public string Tooltip => BuildTooltip();
    public int Priority => Action.Priority;

    public QuickActionViewModel(QuickAction action)
    {
        Action = action;
    }

    private string BuildTooltip()
    {
        var tooltip = Action.Tooltip;
        if (Action.Shortcut is { } shortcut)
        {
            tooltip += $" ({shortcut.ToDisplayString()})";
        }
        return tooltip;
    }
}
```

### View Layer

#### CodeBlockQuickActionsView.axaml

```xml
<!-- src/SeniorIntern.Desktop/Views/CodeBlockQuickActionsView.axaml -->
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:vm="using:SeniorIntern.Desktop.ViewModels"
             xmlns:converters="using:SeniorIntern.Desktop.Converters"
             x:Class="SeniorIntern.Desktop.Views.CodeBlockQuickActionsView"
             x:DataType="vm:CodeBlockQuickActionsViewModel">

    <UserControl.Resources>
        <converters:BoolToIconConverter x:Key="BoolToIconConverter" />
        <converters:BoolToBrushConverter x:Key="BoolToBrushConverter" />
        <converters:ActionTypeToIconConverter x:Key="ActionTypeToIconConverter" />
    </UserControl.Resources>

    <UserControl.Styles>
        <!-- Quick Action Button Base Style -->
        <Style Selector="Button.quick-action">
            <Setter Property="Background" Value="Transparent" />
            <Setter Property="BorderThickness" Value="0" />
            <Setter Property="Padding" Value="6" />
            <Setter Property="MinWidth" Value="28" />
            <Setter Property="MinHeight" Value="28" />
            <Setter Property="CornerRadius" Value="4" />
            <Setter Property="Cursor" Value="Hand" />
        </Style>
        <Style Selector="Button.quick-action:pointerover">
            <Setter Property="Background" Value="{DynamicResource ButtonBackgroundPointerOver}" />
        </Style>
        <Style Selector="Button.quick-action:pressed">
            <Setter Property="Background" Value="{DynamicResource ButtonBackgroundPressed}" />
        </Style>
        <Style Selector="Button.quick-action:disabled">
            <Setter Property="Opacity" Value="0.5" />
        </Style>

        <!-- Primary Action Button (with label) -->
        <Style Selector="Button.quick-action-primary">
            <Setter Property="Background" Value="{DynamicResource AccentButtonBackground}" />
            <Setter Property="Foreground" Value="{DynamicResource AccentButtonForeground}" />
            <Setter Property="Padding" Value="8,4" />
        </Style>
        <Style Selector="Button.quick-action-primary:pointerover">
            <Setter Property="Background" Value="{DynamicResource AccentButtonBackgroundPointerOver}" />
        </Style>

        <!-- Status Message Style -->
        <Style Selector="TextBlock.status-message">
            <Setter Property="FontSize" Value="11" />
            <Setter Property="VerticalAlignment" Value="Center" />
            <Setter Property="Margin" Value="4,0" />
        </Style>
        <Style Selector="TextBlock.status-message.error">
            <Setter Property="Foreground" Value="{DynamicResource ErrorBrush}" />
        </Style>
        <Style Selector="TextBlock.status-message.success">
            <Setter Property="Foreground" Value="{DynamicResource SuccessBrush}" />
        </Style>
    </UserControl.Styles>

    <Border Classes="quick-actions-container"
            Background="{DynamicResource CodeBlockFooterBackground}"
            BorderBrush="{DynamicResource CodeBlockBorder}"
            BorderThickness="0,1,0,0"
            Padding="6,4">
        <Grid ColumnDefinitions="Auto,*,Auto">

            <!-- File Path Display -->
            <StackPanel Grid.Column="0"
                        Orientation="Horizontal"
                        Spacing="4"
                        VerticalAlignment="Center"
                        IsVisible="{Binding HasTargetFile}">
                <PathIcon Data="{StaticResource FileIcon}"
                          Width="12" Height="12"
                          Foreground="{DynamicResource TextMuted}" />
                <TextBlock Text="{Binding TargetFileName}"
                           FontSize="11"
                           Foreground="{DynamicResource TextMuted}"
                           TextTrimming="CharacterEllipsis"
                           MaxWidth="150"
                           VerticalAlignment="Center" />
            </StackPanel>

            <!-- Status Indicator -->
            <StackPanel Grid.Column="1"
                        Orientation="Horizontal"
                        Spacing="4"
                        HorizontalAlignment="Center"
                        VerticalAlignment="Center"
                        IsVisible="{Binding ShowStatus}">

                <!-- Loading Spinner -->
                <ProgressRing IsVisible="{Binding IsExecuting}"
                              Width="14" Height="14"
                              IsActive="{Binding IsExecuting}" />

                <!-- Success/Error Icon -->
                <PathIcon IsVisible="{Binding !IsExecuting}"
                          Width="12" Height="12"
                          Data="{Binding HasError,
                              Converter={StaticResource BoolToIconConverter},
                              ConverterParameter=ErrorCircleIcon|CheckCircleIcon}"
                          Foreground="{Binding HasError,
                              Converter={StaticResource BoolToBrushConverter},
                              ConverterParameter=ErrorBrush|SuccessBrush}" />

                <!-- Status Message -->
                <TextBlock Text="{Binding StatusMessage}"
                           Classes="status-message"
                           Classes.error="{Binding HasError}"
                           Classes.success="{Binding !HasError}" />
            </StackPanel>

            <!-- Action Buttons -->
            <StackPanel Grid.Column="2"
                        Orientation="Horizontal"
                        Spacing="2">

                <!-- Apply Button -->
                <Button Classes="quick-action-primary"
                        Command="{Binding ApplyCommand}"
                        IsVisible="{Binding CanApply}"
                        ToolTip.Tip="Apply (Ctrl+Enter)">
                    <StackPanel Orientation="Horizontal" Spacing="4">
                        <Panel Width="14" Height="14">
                            <ProgressRing IsVisible="{Binding CurrentAction,
                                              Converter={x:Static ObjectConverters.IsNotNull}}"
                                          Width="14" Height="14"
                                          IsActive="True" />
                            <PathIcon IsVisible="{Binding CurrentAction,
                                          Converter={x:Static ObjectConverters.IsNull}}"
                                      Data="{StaticResource CheckIcon}"
                                      Width="14" Height="14" />
                        </Panel>
                        <TextBlock Text="Apply" FontSize="12" />
                    </StackPanel>
                </Button>

                <!-- Copy Button -->
                <Button Classes="quick-action"
                        Command="{Binding CopyCommand}"
                        ToolTip.Tip="Copy code">
                    <PathIcon Width="14" Height="14">
                        <PathIcon.Data>
                            <Binding Path="IsCopied"
                                     Converter="{StaticResource BoolToIconConverter}"
                                     ConverterParameter="CheckIcon|CopyIcon" />
                        </PathIcon.Data>
                        <PathIcon.Foreground>
                            <Binding Path="IsCopied"
                                     Converter="{StaticResource BoolToBrushConverter}"
                                     ConverterParameter="SuccessBrush|ForegroundBrush" />
                        </PathIcon.Foreground>
                    </PathIcon>
                </Button>

                <!-- Diff Button -->
                <Button Classes="quick-action"
                        Command="{Binding ShowDiffCommand}"
                        IsEnabled="{Binding CanShowDiff}"
                        ToolTip.Tip="Show diff (Ctrl+D)">
                    <PathIcon Data="{StaticResource DiffIcon}"
                              Width="14" Height="14" />
                </Button>

                <!-- Open in Editor Button -->
                <Button Classes="quick-action"
                        Command="{Binding OpenInEditorCommand}"
                        IsEnabled="{Binding CanOpenFile}"
                        ToolTip.Tip="Open file in editor">
                    <PathIcon Data="{StaticResource ExternalLinkIcon}"
                              Width="14" Height="14" />
                </Button>

                <!-- Separator -->
                <Rectangle Width="1"
                           Height="16"
                           Fill="{DynamicResource DividerBrush}"
                           Margin="4,0"
                           IsVisible="{Binding HasOverflow}" />

                <!-- Overflow Menu Button -->
                <Button Classes="quick-action"
                        Command="{Binding ToggleOverflowCommand}"
                        IsVisible="{Binding HasOverflow}"
                        ToolTip.Tip="More actions">
                    <PathIcon Data="{StaticResource MoreHorizontalIcon}"
                              Width="14" Height="14" />

                    <Button.Flyout>
                        <MenuFlyout Placement="BottomEdgeAlignedRight">
                            <MenuItem Header="Apply with Options..."
                                      Command="{Binding ShowOptionsCommand}">
                                <MenuItem.Icon>
                                    <PathIcon Data="{StaticResource SettingsIcon}"
                                              Width="14" Height="14" />
                                </MenuItem.Icon>
                            </MenuItem>
                            <Separator />
                            <MenuItem Header="Reject"
                                      Command="{Binding ExecuteActionCommand}"
                                      CommandParameter="{Binding AvailableActions[5].Action}">
                                <MenuItem.Icon>
                                    <PathIcon Data="{StaticResource CrossIcon}"
                                              Width="14" Height="14" />
                                </MenuItem.Icon>
                            </MenuItem>
                        </MenuFlyout>
                    </Button.Flyout>
                </Button>
            </StackPanel>
        </Grid>
    </Border>
</UserControl>
```

#### CodeBlockQuickActionsView.axaml.cs

```csharp
// src/SeniorIntern.Desktop/Views/CodeBlockQuickActionsView.axaml.cs
using Avalonia.Controls;

namespace SeniorIntern.Desktop.Views;

/// <summary>
/// Code-behind for the code block quick actions view.
/// </summary>
public partial class CodeBlockQuickActionsView : UserControl
{
    public CodeBlockQuickActionsView()
    {
        InitializeComponent();
    }
}
```

#### QuickActionButton.axaml

```xml
<!-- src/SeniorIntern.Desktop/Views/Controls/QuickActionButton.axaml -->
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:vm="using:SeniorIntern.Desktop.ViewModels"
             x:Class="SeniorIntern.Desktop.Views.Controls.QuickActionButton"
             x:DataType="vm:QuickActionViewModel">

    <UserControl.Styles>
        <Style Selector="Button.action-btn">
            <Setter Property="Background" Value="Transparent" />
            <Setter Property="BorderThickness" Value="0" />
            <Setter Property="Padding" Value="6" />
            <Setter Property="MinWidth" Value="28" />
            <Setter Property="MinHeight" Value="28" />
            <Setter Property="CornerRadius" Value="4" />
            <Setter Property="Cursor" Value="Hand" />
        </Style>
        <Style Selector="Button.action-btn:pointerover">
            <Setter Property="Background" Value="{DynamicResource ButtonBackgroundPointerOver}" />
        </Style>
        <Style Selector="Button.action-btn:pressed">
            <Setter Property="Background" Value="{DynamicResource ButtonBackgroundPressed}" />
        </Style>
        <Style Selector="Button.action-btn:disabled">
            <Setter Property="Opacity" Value="0.5" />
        </Style>

        <!-- Executing state -->
        <Style Selector="Button.action-btn.executing">
            <Setter Property="IsEnabled" Value="False" />
        </Style>

        <!-- Success state animation -->
        <Style Selector="Button.action-btn.success PathIcon">
            <Setter Property="Foreground" Value="{DynamicResource SuccessBrush}" />
        </Style>

        <!-- Error state -->
        <Style Selector="Button.action-btn.error PathIcon">
            <Setter Property="Foreground" Value="{DynamicResource ErrorBrush}" />
        </Style>
    </UserControl.Styles>

    <Button Classes="action-btn"
            ToolTip.Tip="{Binding Tooltip}">
        <Panel>
            <!-- Loading Spinner (shown during execution) -->
            <ProgressRing x:Name="LoadingRing"
                          IsVisible="False"
                          Width="14" Height="14"
                          IsActive="True" />

            <!-- Action Icon -->
            <PathIcon x:Name="ActionIcon"
                      Width="14" Height="14"
                      Data="{Binding Icon, Converter={StaticResource IconKeyToGeometryConverter}}" />
        </Panel>
    </Button>
</UserControl>
```

#### QuickActionButton.axaml.cs

```csharp
// src/SeniorIntern.Desktop/Views/Controls/QuickActionButton.axaml.cs
using Avalonia;
using Avalonia.Controls;
using SeniorIntern.Core.Models;

namespace SeniorIntern.Desktop.Views.Controls;

/// <summary>
/// A button control for executing a quick action with loading and state feedback.
/// </summary>
public partial class QuickActionButton : UserControl
{
    public static readonly StyledProperty<bool> IsExecutingProperty =
        AvaloniaProperty.Register<QuickActionButton, bool>(nameof(IsExecuting));

    public static readonly StyledProperty<bool> IsSuccessProperty =
        AvaloniaProperty.Register<QuickActionButton, bool>(nameof(IsSuccess));

    public static readonly StyledProperty<bool> HasErrorProperty =
        AvaloniaProperty.Register<QuickActionButton, bool>(nameof(HasError));

    public bool IsExecuting
    {
        get => GetValue(IsExecutingProperty);
        set => SetValue(IsExecutingProperty, value);
    }

    public bool IsSuccess
    {
        get => GetValue(IsSuccessProperty);
        set => SetValue(IsSuccessProperty, value);
    }

    public bool HasError
    {
        get => GetValue(HasErrorProperty);
        set => SetValue(HasErrorProperty, value);
    }

    public QuickActionButton()
    {
        InitializeComponent();
    }

    protected override void OnPropertyChanged(AvaloniaPropertyChangedEventArgs change)
    {
        base.OnPropertyChanged(change);

        if (change.Property == IsExecutingProperty)
        {
            UpdateVisualState();
        }
        else if (change.Property == IsSuccessProperty || change.Property == HasErrorProperty)
        {
            UpdateVisualState();
        }
    }

    private void UpdateVisualState()
    {
        var loadingRing = this.FindControl<ProgressRing>("LoadingRing");
        var actionIcon = this.FindControl<PathIcon>("ActionIcon");

        if (loadingRing is not null)
        {
            loadingRing.IsVisible = IsExecuting;
        }

        if (actionIcon is not null)
        {
            actionIcon.IsVisible = !IsExecuting;
        }

        // Update CSS classes based on state
        Classes.Set("executing", IsExecuting);
        Classes.Set("success", IsSuccess && !IsExecuting);
        Classes.Set("error", HasError && !IsExecuting);
    }
}
```

### Value Converters

#### ActionTypeToIconConverter

```csharp
// src/SeniorIntern.Desktop/Converters/ActionTypeToIconConverter.cs
using System.Globalization;
using Avalonia.Data.Converters;
using SeniorIntern.Core.Models;

namespace SeniorIntern.Desktop.Converters;

/// <summary>
/// Converts QuickActionType to icon resource key.
/// </summary>
public sealed class ActionTypeToIconConverter : IValueConverter
{
    public static readonly ActionTypeToIconConverter Instance = new();

    public object? Convert(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        if (value is not QuickActionType actionType)
            return null;

        return actionType switch
        {
            QuickActionType.Apply => "CheckIcon",
            QuickActionType.Copy => "CopyIcon",
            QuickActionType.ShowDiff => "DiffIcon",
            QuickActionType.OpenFile => "ExternalLinkIcon",
            QuickActionType.ApplyWithOptions => "SettingsIcon",
            QuickActionType.Reject => "CrossIcon",
            QuickActionType.RunCommand => "PlayIcon",
            QuickActionType.InsertAtCursor => "InsertIcon",
            _ => "QuestionIcon"
        };
    }

    public object? ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        throw new NotSupportedException();
    }
}
```

#### IconKeyToGeometryConverter

```csharp
// src/SeniorIntern.Desktop/Converters/IconKeyToGeometryConverter.cs
using System.Globalization;
using Avalonia;
using Avalonia.Data.Converters;
using Avalonia.Media;

namespace SeniorIntern.Desktop.Converters;

/// <summary>
/// Converts an icon resource key to a StreamGeometry.
/// </summary>
public sealed class IconKeyToGeometryConverter : IValueConverter
{
    public static readonly IconKeyToGeometryConverter Instance = new();

    public object? Convert(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        if (value is not string iconKey)
            return null;

        if (Application.Current?.Resources.TryGetResource(iconKey, null, out var resource) == true)
        {
            return resource as StreamGeometry;
        }

        return null;
    }

    public object? ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        throw new NotSupportedException();
    }
}
```

### Integration with CodeBlockControl

#### Updated CodeBlockControl.axaml

```xml
<!-- src/SeniorIntern.Desktop/Views/Controls/CodeBlockControl.axaml (additions) -->
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:vm="using:SeniorIntern.Desktop.ViewModels"
             xmlns:views="using:SeniorIntern.Desktop.Views"
             x:Class="SeniorIntern.Desktop.Views.Controls.CodeBlockControl"
             x:DataType="vm:CodeBlockViewModel">

    <Border Classes="code-block-container"
            Background="{DynamicResource CodeBlockBackground}"
            BorderBrush="{DynamicResource CodeBlockBorder}"
            BorderThickness="1"
            CornerRadius="6">
        <Grid RowDefinitions="Auto,*,Auto">

            <!-- Header: Language + Target File -->
            <Border Grid.Row="0"
                    Classes="code-block-header"
                    Background="{DynamicResource CodeBlockHeaderBackground}"
                    Padding="8,4">
                <Grid ColumnDefinitions="*,Auto">
                    <StackPanel Orientation="Horizontal" Spacing="8">
                        <TextBlock Text="{Binding DisplayLanguage}"
                                   FontSize="11"
                                   FontWeight="SemiBold"
                                   Foreground="{DynamicResource TextMuted}" />
                        <TextBlock Text="{Binding TargetFilePath}"
                                   FontSize="11"
                                   Foreground="{DynamicResource TextSecondary}"
                                   IsVisible="{Binding HasTargetFile}" />
                    </StackPanel>

                    <!-- Status Badge -->
                    <Border Grid.Column="1"
                            Classes="status-badge"
                            IsVisible="{Binding ShowStatusBadge}">
                        <TextBlock Text="{Binding StatusText}"
                                   FontSize="10" />
                    </Border>
                </Grid>
            </Border>

            <!-- Code Content with Syntax Highlighting -->
            <ScrollViewer Grid.Row="1"
                          HorizontalScrollBarVisibility="Auto"
                          VerticalScrollBarVisibility="Auto"
                          MaxHeight="400">
                <SelectableTextBlock Text="{Binding Content}"
                                     FontFamily="{StaticResource MonospaceFont}"
                                     FontSize="13"
                                     Padding="12,8"
                                     TextWrapping="NoWrap" />
            </ScrollViewer>

            <!-- Quick Actions Bar -->
            <views:CodeBlockQuickActionsView
                Grid.Row="2"
                DataContext="{Binding QuickActionsViewModel}"
                IsVisible="{Binding ShowQuickActions}" />

        </Grid>
    </Border>
</UserControl>
```

---

## Unit Tests

### QuickActionTests

```csharp
// tests/SeniorIntern.Core.Tests/Models/QuickActionTests.cs
using SeniorIntern.Core.Models;
using Xunit;

namespace SeniorIntern.Core.Tests.Models;

public class QuickActionTests
{
    [Fact]
    public void Apply_CreatesActionWithCorrectDefaults()
    {
        // Act
        var action = QuickAction.Apply();

        // Assert
        Assert.Equal("apply", action.Id);
        Assert.Equal(QuickActionType.Apply, action.Type);
        Assert.Equal("Apply", action.Label);
        Assert.Equal("CheckIcon", action.Icon);
        Assert.NotNull(action.Shortcut);
        Assert.Equal(10, action.Priority);
    }

    [Fact]
    public void Copy_CreatesActionWithCorrectDefaults()
    {
        // Act
        var action = QuickAction.Copy();

        // Assert
        Assert.Equal("copy", action.Id);
        Assert.Equal(QuickActionType.Copy, action.Type);
        Assert.Equal("Copy", action.Label);
        Assert.Equal(20, action.Priority);
    }

    [Fact]
    public void Apply_IsEnabled_ReturnsTrueForApplicablePendingBlock()
    {
        // Arrange
        var action = QuickAction.Apply();
        var block = new CodeBlock
        {
            Id = Guid.NewGuid(),
            Content = "public class Test { }",
            BlockType = CodeBlockType.CompleteFile,
            TargetFilePath = "src/Test.cs",
            Status = CodeBlockStatus.Pending
        };

        // Act
        var isEnabled = action.IsEnabled(block);

        // Assert
        Assert.True(isEnabled);
    }

    [Fact]
    public void Apply_IsEnabled_ReturnsFalseForAppliedBlock()
    {
        // Arrange
        var action = QuickAction.Apply();
        var block = new CodeBlock
        {
            Id = Guid.NewGuid(),
            Content = "public class Test { }",
            BlockType = CodeBlockType.CompleteFile,
            TargetFilePath = "src/Test.cs",
            Status = CodeBlockStatus.Applied
        };

        // Act
        var isEnabled = action.IsEnabled(block);

        // Assert
        Assert.False(isEnabled);
    }

    [Fact]
    public void Apply_IsEnabled_ReturnsFalseWhenNoTargetPath()
    {
        // Arrange
        var action = QuickAction.Apply();
        var block = new CodeBlock
        {
            Id = Guid.NewGuid(),
            Content = "public class Test { }",
            BlockType = CodeBlockType.CompleteFile,
            TargetFilePath = null,
            Status = CodeBlockStatus.Pending
        };

        // Act
        var isEnabled = action.IsEnabled(block);

        // Assert
        Assert.False(isEnabled);
    }

    [Fact]
    public void Copy_IsEnabled_ReturnsTrueWhenContentNotEmpty()
    {
        // Arrange
        var action = QuickAction.Copy();
        var block = new CodeBlock
        {
            Id = Guid.NewGuid(),
            Content = "console.log('hello')",
            BlockType = CodeBlockType.Example
        };

        // Act
        var isEnabled = action.IsEnabled(block);

        // Assert
        Assert.True(isEnabled);
    }

    [Fact]
    public void Copy_IsEnabled_ReturnsFalseWhenContentEmpty()
    {
        // Arrange
        var action = QuickAction.Copy();
        var block = new CodeBlock
        {
            Id = Guid.NewGuid(),
            Content = "",
            BlockType = CodeBlockType.Example
        };

        // Act
        var isEnabled = action.IsEnabled(block);

        // Assert
        Assert.False(isEnabled);
    }

    [Fact]
    public void RunCommand_IsEnabled_OnlyForCommandBlocks()
    {
        // Arrange
        var action = QuickAction.RunCommand();
        var commandBlock = new CodeBlock
        {
            Id = Guid.NewGuid(),
            Content = "npm install",
            BlockType = CodeBlockType.Command
        };
        var codeBlock = new CodeBlock
        {
            Id = Guid.NewGuid(),
            Content = "public class Test { }",
            BlockType = CodeBlockType.CompleteFile
        };

        // Act & Assert
        Assert.True(action.IsEnabled(commandBlock));
        Assert.False(action.IsEnabled(codeBlock));
    }
}
```

### QuickActionResultTests

```csharp
// tests/SeniorIntern.Core.Tests/Models/QuickActionResultTests.cs
using SeniorIntern.Core.Models;
using Xunit;

namespace SeniorIntern.Core.Tests.Models;

public class QuickActionResultTests
{
    [Fact]
    public void Success_CreatesSuccessfulResult()
    {
        // Act
        var result = QuickActionResult.Success(QuickActionType.Apply, "Applied!");

        // Assert
        Assert.True(result.IsSuccess);
        Assert.Equal(QuickActionType.Apply, result.ActionType);
        Assert.Equal("Applied!", result.Message);
    }

    [Fact]
    public void Failure_CreatesFailedResult()
    {
        // Act
        var result = QuickActionResult.Failure(QuickActionType.Apply, "File not found");

        // Assert
        Assert.False(result.IsSuccess);
        Assert.Equal(QuickActionType.Apply, result.ActionType);
        Assert.Equal("File not found", result.Message);
    }

    [Theory]
    [InlineData(QuickActionType.Apply, "Applied!")]
    [InlineData(QuickActionType.Copy, "Copied!")]
    [InlineData(QuickActionType.ShowDiff, "Showing diff...")]
    [InlineData(QuickActionType.OpenFile, "Opened!")]
    [InlineData(QuickActionType.Reject, "Rejected")]
    public void DisplayMessage_ReturnsCorrectMessageForSuccessfulActions(
        QuickActionType actionType, string expectedMessage)
    {
        // Arrange
        var result = QuickActionResult.Success(actionType);

        // Act & Assert
        Assert.Equal(expectedMessage, result.DisplayMessage);
    }

    [Fact]
    public void DisplayMessage_ReturnsErrorMessageForFailedActions()
    {
        // Arrange
        var result = QuickActionResult.Failure(QuickActionType.Apply, "Permission denied");

        // Act & Assert
        Assert.Equal("Permission denied", result.DisplayMessage);
    }

    [Fact]
    public void Duration_CanBeSetViaWithExpression()
    {
        // Arrange
        var result = QuickActionResult.Success(QuickActionType.Copy);

        // Act
        var withDuration = result with { Duration = TimeSpan.FromMilliseconds(150) };

        // Assert
        Assert.Equal(TimeSpan.FromMilliseconds(150), withDuration.Duration);
    }
}
```

### QuickActionServiceTests

```csharp
// tests/SeniorIntern.Services.Tests/QuickActionServiceTests.cs
using Moq;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Services;
using Xunit;

namespace SeniorIntern.Services.Tests;

public class QuickActionServiceTests
{
    private readonly Mock<IFileChangeService> _fileChangeServiceMock;
    private readonly Mock<IClipboardService> _clipboardServiceMock;
    private readonly Mock<IDiffService> _diffServiceMock;
    private readonly Mock<IEditorService> _editorServiceMock;
    private readonly Mock<IWorkspaceService> _workspaceServiceMock;
    private readonly Mock<ISettingsService> _settingsServiceMock;
    private readonly QuickActionService _service;

    public QuickActionServiceTests()
    {
        _fileChangeServiceMock = new Mock<IFileChangeService>();
        _clipboardServiceMock = new Mock<IClipboardService>();
        _diffServiceMock = new Mock<IDiffService>();
        _editorServiceMock = new Mock<IEditorService>();
        _workspaceServiceMock = new Mock<IWorkspaceService>();
        _settingsServiceMock = new Mock<ISettingsService>();

        _service = new QuickActionService(
            _fileChangeServiceMock.Object,
            _clipboardServiceMock.Object,
            _diffServiceMock.Object,
            _editorServiceMock.Object,
            _workspaceServiceMock.Object,
            _settingsServiceMock.Object);
    }

    [Fact]
    public void GetAllActions_ReturnsDefaultActions()
    {
        // Act
        var actions = _service.GetAllActions().ToList();

        // Assert
        Assert.True(actions.Count >= 6);
        Assert.Contains(actions, a => a.Id == "apply");
        Assert.Contains(actions, a => a.Id == "copy");
        Assert.Contains(actions, a => a.Id == "diff");
        Assert.Contains(actions, a => a.Id == "open");
        Assert.Contains(actions, a => a.Id == "options");
        Assert.Contains(actions, a => a.Id == "reject");
    }

    [Fact]
    public void GetAvailableActions_FiltersBasedOnBlockState()
    {
        // Arrange
        var block = new CodeBlock
        {
            Id = Guid.NewGuid(),
            Content = "public class Test { }",
            BlockType = CodeBlockType.CompleteFile,
            TargetFilePath = "src/Test.cs",
            Status = CodeBlockStatus.Pending
        };

        // Act
        var actions = _service.GetAvailableActions(block).ToList();

        // Assert
        Assert.Contains(actions, a => a.Id == "apply");
        Assert.Contains(actions, a => a.Id == "copy");
        Assert.Contains(actions, a => a.Id == "diff");
    }

    [Fact]
    public void GetAvailableActions_ExcludesApplyForAppliedBlock()
    {
        // Arrange
        var block = new CodeBlock
        {
            Id = Guid.NewGuid(),
            Content = "public class Test { }",
            BlockType = CodeBlockType.CompleteFile,
            TargetFilePath = "src/Test.cs",
            Status = CodeBlockStatus.Applied
        };

        // Act
        var actions = _service.GetAvailableActions(block).ToList();

        // Assert
        Assert.DoesNotContain(actions, a => a.Id == "apply");
        Assert.Contains(actions, a => a.Id == "copy"); // Copy always available
    }

    [Fact]
    public void GetAvailableActions_ReturnsSortedByPriority()
    {
        // Arrange
        var block = new CodeBlock
        {
            Id = Guid.NewGuid(),
            Content = "public class Test { }",
            BlockType = CodeBlockType.CompleteFile,
            TargetFilePath = "src/Test.cs",
            Status = CodeBlockStatus.Pending
        };

        // Act
        var actions = _service.GetAvailableActions(block).ToList();

        // Assert
        for (int i = 1; i < actions.Count; i++)
        {
            Assert.True(actions[i - 1].Priority <= actions[i].Priority);
        }
    }

    [Fact]
    public async Task ExecuteAsync_CopyAction_CallsClipboardService()
    {
        // Arrange
        var action = QuickAction.Copy();
        var block = new CodeBlock
        {
            Id = Guid.NewGuid(),
            Content = "console.log('test')",
            BlockType = CodeBlockType.Example
        };

        // Act
        var result = await _service.ExecuteAsync(action, block);

        // Assert
        Assert.True(result.IsSuccess);
        _clipboardServiceMock.Verify(
            c => c.SetTextAsync(block.Content),
            Times.Once);
    }

    [Fact]
    public async Task ExecuteAsync_ApplyAction_CallsFileChangeService()
    {
        // Arrange
        var action = QuickAction.Apply();
        var block = new CodeBlock
        {
            Id = Guid.NewGuid(),
            Content = "public class Test { }",
            BlockType = CodeBlockType.CompleteFile,
            TargetFilePath = "src/Test.cs",
            Status = CodeBlockStatus.Pending
        };

        var workspace = new Workspace { RootPath = "/test/project" };
        _workspaceServiceMock.Setup(w => w.CurrentWorkspace).Returns(workspace);
        _fileChangeServiceMock
            .Setup(f => f.ApplyCodeBlockAsync(block, It.IsAny<ApplyOptions>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(new ApplyResult { Success = true });

        // Act
        var result = await _service.ExecuteAsync(action, block);

        // Assert
        Assert.True(result.IsSuccess);
        Assert.Equal(CodeBlockStatus.Applied, block.Status);
    }

    [Fact]
    public async Task ExecuteAsync_ApplyAction_FailsWhenNoWorkspace()
    {
        // Arrange
        var action = QuickAction.Apply();
        var block = new CodeBlock
        {
            Id = Guid.NewGuid(),
            Content = "public class Test { }",
            BlockType = CodeBlockType.CompleteFile,
            TargetFilePath = "src/Test.cs",
            Status = CodeBlockStatus.Pending
        };

        _workspaceServiceMock.Setup(w => w.CurrentWorkspace).Returns((Workspace?)null);

        // Act
        var result = await _service.ExecuteAsync(action, block);

        // Assert
        Assert.False(result.IsSuccess);
        Assert.Contains("workspace", result.Message, StringComparison.OrdinalIgnoreCase);
    }

    [Fact]
    public async Task ExecuteAsync_RejectAction_UpdatesBlockStatus()
    {
        // Arrange
        var action = QuickAction.Reject();
        var block = new CodeBlock
        {
            Id = Guid.NewGuid(),
            Content = "public class Test { }",
            BlockType = CodeBlockType.CompleteFile,
            Status = CodeBlockStatus.Pending
        };

        // Act
        var result = await _service.ExecuteAsync(action, block);

        // Assert
        Assert.True(result.IsSuccess);
        Assert.Equal(CodeBlockStatus.Rejected, block.Status);
    }

    [Fact]
    public void RegisterAction_AddsCustomAction()
    {
        // Arrange
        var customAction = new QuickAction(
            Id: "custom",
            Type: QuickActionType.Copy,
            Label: "Custom",
            Icon: "CustomIcon",
            Tooltip: "Custom action",
            Shortcut: null,
            IsEnabled: _ => true,
            Priority: 1000);

        // Act
        _service.RegisterAction(customAction);
        var retrieved = _service.GetAction("custom");

        // Assert
        Assert.NotNull(retrieved);
        Assert.Equal("custom", retrieved.Id);
    }

    [Fact]
    public void UnregisterAction_RemovesAction()
    {
        // Arrange
        var customAction = new QuickAction(
            Id: "to-remove",
            Type: QuickActionType.Copy,
            Label: "Remove Me",
            Icon: "Icon",
            Tooltip: "Will be removed",
            Shortcut: null,
            IsEnabled: _ => true,
            Priority: 1000);
        _service.RegisterAction(customAction);

        // Act
        var removed = _service.UnregisterAction("to-remove");
        var retrieved = _service.GetAction("to-remove");

        // Assert
        Assert.True(removed);
        Assert.Null(retrieved);
    }

    [Fact]
    public async Task ExecuteAsync_RaisesActionExecutingEvent()
    {
        // Arrange
        var action = QuickAction.Copy();
        var block = new CodeBlock
        {
            Id = Guid.NewGuid(),
            Content = "test",
            BlockType = CodeBlockType.Example
        };

        QuickActionExecutingEventArgs? capturedArgs = null;
        _service.ActionExecuting += (_, args) => capturedArgs = args;

        // Act
        await _service.ExecuteAsync(action, block);

        // Assert
        Assert.NotNull(capturedArgs);
        Assert.Equal(action, capturedArgs.Action);
        Assert.Equal(block, capturedArgs.Block);
    }

    [Fact]
    public async Task ExecuteAsync_RaisesActionExecutedEvent()
    {
        // Arrange
        var action = QuickAction.Copy();
        var block = new CodeBlock
        {
            Id = Guid.NewGuid(),
            Content = "test",
            BlockType = CodeBlockType.Example
        };

        QuickActionExecutedEventArgs? capturedArgs = null;
        _service.ActionExecuted += (_, args) => capturedArgs = args;

        // Act
        await _service.ExecuteAsync(action, block);

        // Assert
        Assert.NotNull(capturedArgs);
        Assert.Equal(action, capturedArgs.Action);
        Assert.Equal(block, capturedArgs.Block);
        Assert.True(capturedArgs.Result.IsSuccess);
    }

    [Fact]
    public async Task ExecuteAsync_CanBeCancelledViaEvent()
    {
        // Arrange
        var action = QuickAction.Copy();
        var block = new CodeBlock
        {
            Id = Guid.NewGuid(),
            Content = "test",
            BlockType = CodeBlockType.Example
        };

        _service.ActionExecuting += (_, args) => args.Cancel = true;

        // Act
        var result = await _service.ExecuteAsync(action, block);

        // Assert
        Assert.False(result.IsSuccess);
        Assert.Contains("cancelled", result.Message, StringComparison.OrdinalIgnoreCase);
        _clipboardServiceMock.Verify(c => c.SetTextAsync(It.IsAny<string>()), Times.Never);
    }
}
```

### CodeBlockQuickActionsViewModelTests

```csharp
// tests/SeniorIntern.Desktop.Tests/ViewModels/CodeBlockQuickActionsViewModelTests.cs
using Moq;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Desktop.ViewModels;
using Xunit;

namespace SeniorIntern.Desktop.Tests.ViewModels;

public class CodeBlockQuickActionsViewModelTests
{
    private readonly Mock<IQuickActionService> _quickActionServiceMock;
    private readonly Mock<ISettingsService> _settingsServiceMock;
    private readonly CodeBlockQuickActionsViewModel _viewModel;

    public CodeBlockQuickActionsViewModelTests()
    {
        _quickActionServiceMock = new Mock<IQuickActionService>();
        _settingsServiceMock = new Mock<ISettingsService>();

        // Setup default actions
        _quickActionServiceMock
            .Setup(s => s.GetAvailableActions(It.IsAny<CodeBlock>()))
            .Returns(new[]
            {
                QuickAction.Apply(),
                QuickAction.Copy(),
                QuickAction.ShowDiff(),
                QuickAction.OpenInEditor()
            });

        _viewModel = new CodeBlockQuickActionsViewModel(
            _quickActionServiceMock.Object,
            _settingsServiceMock.Object);
    }

    [Fact]
    public void Initialize_PopulatesAvailableActions()
    {
        // Arrange
        var block = CreateTestBlock();

        // Act
        _viewModel.Initialize(block);

        // Assert
        Assert.Equal(4, _viewModel.AvailableActions.Count);
    }

    [Fact]
    public void Initialize_SetsCodeBlock()
    {
        // Arrange
        var block = CreateTestBlock();

        // Act
        _viewModel.Initialize(block);

        // Assert
        Assert.Equal(block, _viewModel.CodeBlock);
    }

    [Fact]
    public void CanApply_ReturnsTrueForApplicablePendingBlock()
    {
        // Arrange
        var block = CreateTestBlock();
        _viewModel.Initialize(block);

        // Assert
        Assert.True(_viewModel.CanApply);
    }

    [Fact]
    public void CanApply_ReturnsFalseForAppliedBlock()
    {
        // Arrange
        var block = CreateTestBlock();
        block.Status = CodeBlockStatus.Applied;
        _viewModel.Initialize(block);

        // Assert
        Assert.False(_viewModel.CanApply);
    }

    [Fact]
    public void TargetFileName_ReturnsFileNameFromPath()
    {
        // Arrange
        var block = CreateTestBlock();
        _viewModel.Initialize(block);

        // Assert
        Assert.Equal("Test.cs", _viewModel.TargetFileName);
    }

    [Fact]
    public void PrimaryActions_ReturnsFirst4Actions()
    {
        // Arrange
        var block = CreateTestBlock();
        _viewModel.Initialize(block);

        // Act
        var primaryActions = _viewModel.PrimaryActions.ToList();

        // Assert
        Assert.Equal(4, primaryActions.Count);
    }

    [Fact]
    public void HasOverflow_ReturnsFalseWhen4OrFewerActions()
    {
        // Arrange
        var block = CreateTestBlock();
        _viewModel.Initialize(block);

        // Assert
        Assert.False(_viewModel.HasOverflow);
    }

    [Fact]
    public void HasOverflow_ReturnsTrueWhenMoreThan4Actions()
    {
        // Arrange
        _quickActionServiceMock
            .Setup(s => s.GetAvailableActions(It.IsAny<CodeBlock>()))
            .Returns(new[]
            {
                QuickAction.Apply(),
                QuickAction.Copy(),
                QuickAction.ShowDiff(),
                QuickAction.OpenInEditor(),
                QuickAction.ApplyWithOptions(),
                QuickAction.Reject()
            });

        var block = CreateTestBlock();
        _viewModel.Initialize(block);

        // Assert
        Assert.True(_viewModel.HasOverflow);
    }

    [Fact]
    public async Task ApplyCommand_ExecutesApplyAction()
    {
        // Arrange
        var block = CreateTestBlock();
        _viewModel.Initialize(block);

        var applyAction = QuickAction.Apply();
        _quickActionServiceMock.Setup(s => s.GetAction("apply")).Returns(applyAction);
        _quickActionServiceMock
            .Setup(s => s.ExecuteAsync(applyAction, block, It.IsAny<CancellationToken>()))
            .ReturnsAsync(QuickActionResult.Success(QuickActionType.Apply));

        // Act
        await _viewModel.ApplyCommand.ExecuteAsync(null);

        // Assert
        _quickActionServiceMock.Verify(
            s => s.ExecuteAsync(applyAction, block, It.IsAny<CancellationToken>()),
            Times.Once);
    }

    [Fact]
    public async Task CopyCommand_SetsIsCopiedToTrue()
    {
        // Arrange
        var block = CreateTestBlock();
        _viewModel.Initialize(block);

        var copyAction = QuickAction.Copy();
        _quickActionServiceMock.Setup(s => s.GetAction("copy")).Returns(copyAction);
        _quickActionServiceMock
            .Setup(s => s.ExecuteAsync(copyAction, block, It.IsAny<CancellationToken>()))
            .ReturnsAsync(QuickActionResult.Success(QuickActionType.Copy));

        // Act
        await _viewModel.CopyCommand.ExecuteAsync(null);

        // Assert
        Assert.True(_viewModel.IsCopied);
    }

    [Fact]
    public async Task ShowDiffCommand_RaisesShowDiffRequestedEvent()
    {
        // Arrange
        var block = CreateTestBlock();
        _viewModel.Initialize(block);

        var diffAction = QuickAction.ShowDiff();
        _quickActionServiceMock.Setup(s => s.GetAction("diff")).Returns(diffAction);
        _quickActionServiceMock
            .Setup(s => s.ExecuteAsync(diffAction, block, It.IsAny<CancellationToken>()))
            .ReturnsAsync(QuickActionResult.Success(QuickActionType.ShowDiff, data: block));

        CodeBlock? receivedBlock = null;
        _viewModel.ShowDiffRequested += (_, b) => receivedBlock = b;

        // Act
        await _viewModel.ShowDiffCommand.ExecuteAsync(null);

        // Assert
        Assert.Equal(block, receivedBlock);
    }

    [Fact]
    public async Task ExecuteAction_SetsIsExecutingDuringExecution()
    {
        // Arrange
        var block = CreateTestBlock();
        _viewModel.Initialize(block);

        var copyAction = QuickAction.Copy();
        _quickActionServiceMock.Setup(s => s.GetAction("copy")).Returns(copyAction);

        var executingStates = new List<bool>();
        _viewModel.PropertyChanged += (_, e) =>
        {
            if (e.PropertyName == nameof(_viewModel.IsExecuting))
            {
                executingStates.Add(_viewModel.IsExecuting);
            }
        };

        _quickActionServiceMock
            .Setup(s => s.ExecuteAsync(copyAction, block, It.IsAny<CancellationToken>()))
            .ReturnsAsync(QuickActionResult.Success(QuickActionType.Copy));

        // Act
        await _viewModel.CopyCommand.ExecuteAsync(null);

        // Assert
        Assert.Contains(true, executingStates); // Was executing at some point
        Assert.False(_viewModel.IsExecuting); // No longer executing
    }

    [Fact]
    public async Task ExecuteAction_SetsStatusMessageOnSuccess()
    {
        // Arrange
        var block = CreateTestBlock();
        _viewModel.Initialize(block);

        var copyAction = QuickAction.Copy();
        _quickActionServiceMock.Setup(s => s.GetAction("copy")).Returns(copyAction);
        _quickActionServiceMock
            .Setup(s => s.ExecuteAsync(copyAction, block, It.IsAny<CancellationToken>()))
            .ReturnsAsync(QuickActionResult.Success(QuickActionType.Copy));

        // Act
        await _viewModel.CopyCommand.ExecuteAsync(null);

        // Assert
        Assert.Equal("Copied!", _viewModel.StatusMessage);
        Assert.False(_viewModel.HasError);
    }

    [Fact]
    public async Task ExecuteAction_SetsErrorStateOnFailure()
    {
        // Arrange
        var block = CreateTestBlock();
        _viewModel.Initialize(block);

        var applyAction = QuickAction.Apply();
        _quickActionServiceMock.Setup(s => s.GetAction("apply")).Returns(applyAction);
        _quickActionServiceMock
            .Setup(s => s.ExecuteAsync(applyAction, block, It.IsAny<CancellationToken>()))
            .ReturnsAsync(QuickActionResult.Failure(QuickActionType.Apply, "File not found"));

        // Act
        await _viewModel.ApplyCommand.ExecuteAsync(null);

        // Assert
        Assert.Equal("File not found", _viewModel.StatusMessage);
        Assert.True(_viewModel.HasError);
    }

    [Fact]
    public void ToggleOverflowCommand_TogglesIsExpanded()
    {
        // Arrange
        Assert.False(_viewModel.IsExpanded);

        // Act
        _viewModel.ToggleOverflowCommand.Execute(null);

        // Assert
        Assert.True(_viewModel.IsExpanded);

        // Act again
        _viewModel.ToggleOverflowCommand.Execute(null);

        // Assert
        Assert.False(_viewModel.IsExpanded);
    }

    private static CodeBlock CreateTestBlock() => new()
    {
        Id = Guid.NewGuid(),
        Content = "public class Test { }",
        BlockType = CodeBlockType.CompleteFile,
        TargetFilePath = "src/Test.cs",
        Status = CodeBlockStatus.Pending
    };
}
```

---

## Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Models/QuickAction.cs` | Quick action record with factory methods |
| `src/SeniorIntern.Core/Models/QuickActionType.cs` | Enum for action types |
| `src/SeniorIntern.Core/Models/QuickActionResult.cs` | Action execution result record |
| `src/SeniorIntern.Core/Interfaces/IQuickActionService.cs` | Service interface |
| `src/SeniorIntern.Services/QuickActionService.cs` | Service implementation |
| `src/SeniorIntern.Desktop/ViewModels/CodeBlockQuickActionsViewModel.cs` | Quick actions ViewModel |
| `src/SeniorIntern.Desktop/Views/CodeBlockQuickActionsView.axaml` | Quick actions bar view |
| `src/SeniorIntern.Desktop/Views/CodeBlockQuickActionsView.axaml.cs` | View code-behind |
| `src/SeniorIntern.Desktop/Views/Controls/QuickActionButton.axaml` | Reusable action button |
| `src/SeniorIntern.Desktop/Views/Controls/QuickActionButton.axaml.cs` | Button code-behind |
| `src/SeniorIntern.Desktop/Converters/ActionTypeToIconConverter.cs` | Action type to icon converter |
| `src/SeniorIntern.Desktop/Converters/IconKeyToGeometryConverter.cs` | Icon key to geometry converter |
| `tests/SeniorIntern.Core.Tests/Models/QuickActionTests.cs` | QuickAction unit tests |
| `tests/SeniorIntern.Core.Tests/Models/QuickActionResultTests.cs` | QuickActionResult unit tests |
| `tests/SeniorIntern.Services.Tests/QuickActionServiceTests.cs` | Service unit tests |
| `tests/SeniorIntern.Desktop.Tests/ViewModels/CodeBlockQuickActionsViewModelTests.cs` | ViewModel tests |

## Files to Modify

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/Views/Controls/CodeBlockControl.axaml` | Add quick actions bar integration |
| `src/SeniorIntern.Desktop/ViewModels/CodeBlockViewModel.cs` | Add QuickActionsViewModel property |
| `src/SeniorIntern.Desktop/App.axaml` | Register icon resources |
| `src/SeniorIntern.Desktop/ServiceCollectionExtensions.cs` | Register IQuickActionService |

---

## Acceptance Criteria

### Functional Requirements

- [ ] Quick action buttons appear below code blocks in chat
- [ ] Apply button applies code to target file with default options
- [ ] Copy button copies code content to clipboard with visual feedback
- [ ] Diff button opens diff viewer for the code block
- [ ] Open button opens target file in external editor
- [ ] More options button reveals overflow menu
- [ ] Actions show loading state during execution
- [ ] Success/error status displays briefly after action completes
- [ ] Actions respect code block status (e.g., can't apply already-applied blocks)
- [ ] Keyboard shortcuts work when code block has focus

### Visual Requirements

- [ ] Actions bar is visually integrated with code block container
- [ ] Button icons are clear and recognizable
- [ ] Loading spinners appear during execution
- [ ] Success state shows green checkmark
- [ ] Error state shows red icon with message
- [ ] Tooltips show action description and shortcut
- [ ] Overflow menu appears on click
- [ ] Target file path displays when available

### Performance Requirements

- [ ] Actions execute without blocking UI
- [ ] Status message clears after 2 seconds
- [ ] No memory leaks from event subscriptions

---

## Design Decisions

### Why a Service Pattern for Quick Actions?

**Decision**: Create IQuickActionService to manage action registration and execution.

**Rationale**:
1. **Extensibility**: Custom actions can be registered without modifying core code
2. **Testability**: Service can be mocked in ViewModel tests
3. **Separation of Concerns**: ViewModel handles UI state, service handles execution
4. **Event System**: Service events enable logging, analytics, and cross-cutting concerns

**Alternatives Considered**:
- Direct execution in ViewModel - rejected due to poor testability
- Command pattern - too heavyweight for simple actions

### Why Fixed Primary Action Count?

**Decision**: Show 4 primary actions, rest in overflow menu.

**Rationale**:
1. **Space**: 4 buttons fit comfortably in typical code block width
2. **Cognitive Load**: Too many buttons overwhelms users
3. **Priority**: Most common actions (Apply, Copy, Diff, Open) get primary placement
4. **Flexibility**: Overflow menu handles edge cases

### Why Status Auto-Clear?

**Decision**: Clear status message after 2 seconds automatically.

**Rationale**:
1. **Clean UI**: Avoids cluttered interface with stale messages
2. **Feedback**: Provides enough time to read success/error
3. **Flow**: Doesn't interrupt user workflow
4. **Cancelable**: New actions cancel pending clear

---

## Future Considerations

1. **Custom Actions**: Allow extensions to register custom quick actions
2. **Action History**: Track recently used actions for analytics
3. **Batch Actions**: Apply/reject multiple code blocks at once
4. **Contextual Actions**: Actions based on code block language/type
5. **Drag and Drop**: Drag code block to file tree to apply
6. **Preview on Hover**: Show diff preview on Apply button hover
7. **Undo Integration**: Quick undo button appears after apply
8. **Animation**: Smooth transitions for status changes

---

## Dependencies

### Internal Dependencies

| Dependency | Version | Purpose |
|------------|---------|---------|
| v0.4.1a (Core Models) | Required | CodeBlock, CodeBlockStatus, CodeBlockType |
| v0.4.3b (File Change Service) | Required | IFileChangeService for applying code |
| v0.4.5d (Snippet Apply Service) | Optional | For ApplyWithOptions action |
| v0.4.5e (Snippet Options UI) | Optional | Options popup integration |
| v0.4.5f (Keyboard Shortcuts) | Required | KeyboardShortcut model |

### External Dependencies

| Package | Purpose |
|---------|---------|
| CommunityToolkit.Mvvm | ObservableProperty, RelayCommand |
| Avalonia.Controls | UI controls |

---

## Appendix: Icon Resources

The following icon resources should be defined in `App.axaml`:

```xml
<!-- Icon Resources for Quick Actions -->
<StreamGeometry x:Key="CheckIcon">M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z</StreamGeometry>
<StreamGeometry x:Key="CopyIcon">M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z</StreamGeometry>
<StreamGeometry x:Key="DiffIcon">M9 7h6v2H9V7zm0 4h6v2H9v-2zm0 4h6v2H9v-2zM5 3h14c1.1 0 2 .9 2 2v14c0 1.1-.9 2-2 2H5c-1.1 0-2-.9-2-2V5c0-1.1.9-2 2-2zm0 16h14V5H5v14z</StreamGeometry>
<StreamGeometry x:Key="ExternalLinkIcon">M19 19H5V5h7V3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z</StreamGeometry>
<StreamGeometry x:Key="SettingsIcon">M19.14 12.94c.04-.31.06-.63.06-.94 0-.31-.02-.63-.06-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.04.31-.06.63-.06.94s.02.63.06.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z</StreamGeometry>
<StreamGeometry x:Key="CrossIcon">M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z</StreamGeometry>
<StreamGeometry x:Key="PlayIcon">M8 5v14l11-7z</StreamGeometry>
<StreamGeometry x:Key="InsertIcon">M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z</StreamGeometry>
<StreamGeometry x:Key="MoreHorizontalIcon">M6 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm12 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm-6 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z</StreamGeometry>
<StreamGeometry x:Key="FileIcon">M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z</StreamGeometry>
<StreamGeometry x:Key="CheckCircleIcon">M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z</StreamGeometry>
<StreamGeometry x:Key="ErrorCircleIcon">M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z</StreamGeometry>
```
