# v0.4.3b: File Change Service - Design Specification

**Status**: _IMPLEMENTED_

## Executive Summary

This specification details the **File Change Service** for The Senior Intern's Apply Changes Workflow. The `FileChangeService` is the central orchestrator that applies code blocks to the filesystem, manages change history, handles conflicts, and coordinates with the backup and diff services. It provides thread-safe operations with proper locking, comprehensive error handling, and event-driven notifications for UI updates.

### Key Deliverables

| Component | Type | Purpose |
|-----------|------|---------|
| `IFileChangeService` | Interface | Contract for file change operations |
| `FileChangeService` | Class | Main implementation with full functionality |
| `ApplyCodeBlockAsync` | Method | Apply single code block to filesystem |
| `ApplyCodeBlocksAsync` | Method | Apply multiple code blocks with batching |
| `ApplyDiffAsync` | Method | Apply a computed diff directly |
| `PreviewApplyAsync` | Method | Preview what would happen on apply |
| `UndoLastChangeAsync` | Method | Undo most recent change to a file |
| `UndoChangeAsync` | Method | Undo specific change by ID |
| `CheckForConflictsAsync` | Method | Check for file modification conflicts |
| Change History Management | Methods | Track and query change history |

---

## Feature Overview

```
v0.4.3b: File Change Service
├── Service Interface (IFileChangeService)
│   ├── Apply Operations
│   │   ├── ApplyCodeBlockAsync
│   │   ├── ApplyCodeBlocksAsync
│   │   └── ApplyDiffAsync
│   ├── Preview Operations
│   │   └── PreviewApplyAsync
│   ├── Undo Operations
│   │   ├── UndoLastChangeAsync
│   │   ├── UndoChangeAsync
│   │   └── CanUndo
│   ├── History Operations
│   │   ├── GetChangeHistory
│   │   └── GetPendingUndos
│   ├── Conflict Detection
│   │   └── CheckForConflictsAsync
│   └── Events
│       ├── FileChanged
│       ├── ChangeFailed
│       ├── ChangeUndone
│       └── ConflictDetected
├── Service Implementation (FileChangeService)
│   ├── Dependencies
│   │   ├── IFileSystemService (file I/O)
│   │   ├── IDiffService (diff computation)
│   │   ├── IBackupService (backup management)
│   │   └── ILogger<FileChangeService> (optional)
│   ├── Thread Safety
│   │   ├── SemaphoreSlim for apply lock
│   │   ├── ConcurrentDictionary for history
│   │   └── Object lock for history mutations
│   ├── Apply Pipeline
│   │   ├── Input validation
│   │   ├── Conflict checking
│   │   ├── Backup creation
│   │   ├── Diff computation
│   │   ├── Directory creation
│   │   ├── Line ending preservation
│   │   ├── File write
│   │   ├── History recording
│   │   └── Event notification
│   ├── Error Handling
│   │   ├── UnauthorizedAccessException → PermissionDenied
│   │   ├── IOException (locked) → FileLocked
│   │   ├── IOException (disk full) → DiskFull
│   │   └── Generic Exception → Error
│   └── Utility Methods
│       ├── ComputeHash (SHA-256)
│       ├── NormalizeLineEndings
│       ├── IsFileLocked
│       └── IsDiskFull
└── Multi-Block Handling
    ├── Group by target file
    ├── Single block → direct apply
    └── Multiple blocks → merge and apply
```

---

## Architecture Diagrams

### Service Interaction Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           File Change Service Flow                           │
└─────────────────────────────────────────────────────────────────────────────┘

                            ┌──────────────┐
                            │  CodeBlock   │
                            │  or Blocks   │
                            └──────┬───────┘
                                   │
                                   ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                          FileChangeService                                   │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │                        ApplyCodeBlockAsync                             │  │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐   │  │
│  │  │  Validate   │─▶│   Check     │─▶│   Create    │─▶│   Compute   │   │  │
│  │  │   Inputs    │  │  Conflicts  │  │   Backup    │  │    Diff     │   │  │
│  │  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘   │  │
│  │         │                │                │                │          │  │
│  │         │                │                │                │          │  │
│  │         ▼                ▼                ▼                ▼          │  │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐   │  │
│  │  │   Create    │─▶│  Preserve   │─▶│   Write     │─▶│   Record    │   │  │
│  │  │   Dirs      │  │  LineEnds   │  │    File     │  │   Change    │   │  │
│  │  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘   │  │
│  │                                                            │          │  │
│  │                                                            ▼          │  │
│  │                                                     ┌─────────────┐   │  │
│  │                                                     │   Raise     │   │  │
│  │                                                     │   Events    │   │  │
│  │                                                     └─────────────┘   │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────┘
                                   │
                                   ▼
                            ┌──────────────┐
                            │ ApplyResult  │
                            └──────────────┘
```

### Service Dependencies

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        FileChangeService Dependencies                        │
└─────────────────────────────────────────────────────────────────────────────┘

                         ┌──────────────────────┐
                         │  FileChangeService   │
                         │    (orchestrator)    │
                         └──────────┬───────────┘
                                    │
           ┌────────────────────────┼────────────────────────┐
           │                        │                        │
           ▼                        ▼                        ▼
┌──────────────────┐    ┌──────────────────┐    ┌──────────────────┐
│ IFileSystemService│    │   IDiffService   │    │  IBackupService  │
│                  │    │                  │    │                  │
│ • FileExistsAsync│    │ • ComputeDiff    │    │ • CreateBackup   │
│ • ReadFileAsync  │    │   ForBlockAsync  │    │ • RestoreBackup  │
│ • WriteFileAsync │    │ • ComputeMerged  │    │ • DeleteBackup   │
│                  │    │   DiffAsync      │    │                  │
└──────────────────┘    └──────────────────┘    └──────────────────┘
           │                        │                        │
           └────────────────────────┼────────────────────────┘
                                    │
                                    ▼
                         ┌──────────────────────┐
                         │     File System      │
                         │    (actual I/O)      │
                         └──────────────────────┘
```

### Thread Safety Architecture

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         Thread Safety Design                                 │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│                          FileChangeService                                   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                     _applyLock (SemaphoreSlim)                       │   │
│  │  • Ensures only one apply operation at a time                       │   │
│  │  • Prevents concurrent writes to same file                          │   │
│  │  • Used by ApplyCodeBlockAsync, ApplyDiffAsync, Undo methods        │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │           _changeHistory (ConcurrentDictionary<string, Stack>)       │   │
│  │  • Thread-safe key-value store for history per file                 │   │
│  │  • Keys: file paths                                                 │   │
│  │  • Values: Stack<FileChangeRecord>                                  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                  _historyLock (object)                               │   │
│  │  • Protects stack mutations within ConcurrentDictionary             │   │
│  │  • Used when Push/Pop on history stacks                             │   │
│  │  • Prevents race conditions on individual file histories            │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Error Handling Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          Error Handling Flow                                 │
└─────────────────────────────────────────────────────────────────────────────┘

                            File Write Attempt
                                   │
                                   ▼
                          ┌───────────────┐
                          │  Exception?   │
                          └───────┬───────┘
                                  │
          ┌───────────────────────┼───────────────────────┐
          │                       │                       │
          ▼                       ▼                       ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│ Unauthorized    │    │   IOException   │    │    Generic      │
│ AccessException │    │                 │    │   Exception     │
└────────┬────────┘    └────────┬────────┘    └────────┬────────┘
         │                      │                      │
         ▼                      ▼                      ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│ PermissionDenied│    │  Check HResult  │    │     Error       │
│   ApplyResult   │    │                 │    │   ApplyResult   │
└─────────────────┘    └────────┬────────┘    └─────────────────┘
                                │
                ┌───────────────┴───────────────┐
                ▼                               ▼
     ┌─────────────────┐             ┌─────────────────┐
     │  0x80070020 or  │             │   0x80070070    │
     │  0x80070021     │             │  (Disk Full)    │
     │  (File Locked)  │             │                 │
     └────────┬────────┘             └────────┬────────┘
              │                               │
              ▼                               ▼
     ┌─────────────────┐             ┌─────────────────┐
     │   FileLocked    │             │    DiskFull     │
     │   ApplyResult   │             │   ApplyResult   │
     └─────────────────┘             └─────────────────┘

All Error Paths:
  1. Log the error (if logger available)
  2. Raise ChangeFailed event
  3. Return ApplyResult.Failed() with appropriate type
```

---

## Detailed Design

### IFileChangeService Interface

```csharp
// src/SeniorIntern.Core/Interfaces/IFileChangeService.cs
namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Service for applying code changes to the filesystem with undo support.
/// </summary>
/// <remarks>
/// The file change service is the central orchestrator for all file modifications
/// in the apply workflow. It coordinates with diff, backup, and filesystem services
/// to provide a safe, undoable apply operation.
/// </remarks>
public interface IFileChangeService
{
    /// <summary>
    /// Apply a single code block to the filesystem.
    /// </summary>
    /// <param name="block">The code block containing the content to apply.</param>
    /// <param name="workspacePath">The root path of the workspace.</param>
    /// <param name="options">Optional configuration for the apply operation.</param>
    /// <param name="ct">Cancellation token for the operation.</param>
    /// <returns>Result indicating success or failure with details.</returns>
    /// <remarks>
    /// This method:
    /// <list type="bullet">
    ///   <item>Validates the code block has a target path</item>
    ///   <item>Checks for conflicts if the file exists</item>
    ///   <item>Creates a backup if configured</item>
    ///   <item>Computes the diff using IDiffService</item>
    ///   <item>Creates parent directories if needed</item>
    ///   <item>Preserves line endings if configured</item>
    ///   <item>Writes the file to disk</item>
    ///   <item>Records the change for undo</item>
    ///   <item>Raises the FileChanged event</item>
    /// </list>
    /// </remarks>
    Task<ApplyResult> ApplyCodeBlockAsync(
        CodeBlock block,
        string workspacePath,
        ApplyOptions? options = null,
        CancellationToken ct = default);

    /// <summary>
    /// Apply multiple code blocks to the filesystem.
    /// </summary>
    /// <param name="blocks">The code blocks to apply.</param>
    /// <param name="workspacePath">The root path of the workspace.</param>
    /// <param name="options">Optional configuration for the apply operations.</param>
    /// <param name="ct">Cancellation token for the operation.</param>
    /// <returns>List of results, one per applied block/file.</returns>
    /// <remarks>
    /// When multiple blocks target the same file, they are merged into a single
    /// diff operation to prevent conflicts and ensure atomic application.
    /// </remarks>
    Task<IReadOnlyList<ApplyResult>> ApplyCodeBlocksAsync(
        IEnumerable<CodeBlock> blocks,
        string workspacePath,
        ApplyOptions? options = null,
        CancellationToken ct = default);

    /// <summary>
    /// Apply a pre-computed diff to the filesystem.
    /// </summary>
    /// <param name="diff">The diff result to apply.</param>
    /// <param name="workspacePath">The root path of the workspace.</param>
    /// <param name="options">Optional configuration for the apply operation.</param>
    /// <param name="ct">Cancellation token for the operation.</param>
    /// <returns>Result indicating success or failure with details.</returns>
    /// <remarks>
    /// Use this method when you already have a computed diff (e.g., from a merged
    /// operation or user-edited content). Skips the diff computation step.
    /// </remarks>
    Task<ApplyResult> ApplyDiffAsync(
        DiffResult diff,
        string workspacePath,
        ApplyOptions? options = null,
        CancellationToken ct = default);

    /// <summary>
    /// Preview what would happen when applying a code block.
    /// </summary>
    /// <param name="block">The code block to preview.</param>
    /// <param name="workspacePath">The root path of the workspace.</param>
    /// <param name="ct">Cancellation token for the operation.</param>
    /// <returns>Preview information without making any changes.</returns>
    /// <remarks>
    /// This is a read-only operation that checks for conflicts, computes the diff,
    /// and returns preview information. No files are modified.
    /// </remarks>
    Task<ApplyPreview> PreviewApplyAsync(
        CodeBlock block,
        string workspacePath,
        CancellationToken ct = default);

    /// <summary>
    /// Undo the last change made to a specific file.
    /// </summary>
    /// <param name="filePath">The absolute path to the file.</param>
    /// <param name="ct">Cancellation token for the operation.</param>
    /// <returns>True if undo succeeded, false otherwise.</returns>
    /// <remarks>
    /// Undo will fail if:
    /// <list type="bullet">
    ///   <item>No history exists for the file</item>
    ///   <item>The last change cannot be undone (no backup)</item>
    ///   <item>The undo window has expired</item>
    ///   <item>The backup file is missing</item>
    /// </list>
    /// </remarks>
    Task<bool> UndoLastChangeAsync(string filePath, CancellationToken ct = default);

    /// <summary>
    /// Undo a specific change by its unique identifier.
    /// </summary>
    /// <param name="changeId">The GUID of the change to undo.</param>
    /// <param name="ct">Cancellation token for the operation.</param>
    /// <returns>True if undo succeeded, false otherwise.</returns>
    /// <remarks>
    /// This method searches all file histories to find the specified change.
    /// Use this when you need to undo a specific change rather than just the last one.
    /// </remarks>
    Task<bool> UndoChangeAsync(Guid changeId, CancellationToken ct = default);

    /// <summary>
    /// Check if undo is available for a specific file.
    /// </summary>
    /// <param name="filePath">The absolute path to the file.</param>
    /// <returns>True if undo is available and not expired.</returns>
    bool CanUndo(string filePath);

    /// <summary>
    /// Get the change history for a specific file.
    /// </summary>
    /// <param name="filePath">The absolute path to the file.</param>
    /// <param name="maxRecords">Maximum number of records to return (default: 10).</param>
    /// <returns>List of change records, most recent first.</returns>
    IReadOnlyList<FileChangeRecord> GetChangeHistory(string filePath, int maxRecords = 10);

    /// <summary>
    /// Get all pending undos across all files.
    /// </summary>
    /// <returns>List of undoable changes that haven't expired, ordered by time.</returns>
    IReadOnlyList<FileChangeRecord> GetPendingUndos();

    /// <summary>
    /// Check for conflicts before applying a code block.
    /// </summary>
    /// <param name="block">The code block to check.</param>
    /// <param name="workspacePath">The root path of the workspace.</param>
    /// <param name="ct">Cancellation token for the operation.</param>
    /// <returns>Conflict check result with details if conflict detected.</returns>
    Task<ConflictCheckResult> CheckForConflictsAsync(
        CodeBlock block,
        string workspacePath,
        CancellationToken ct = default);

    /// <summary>
    /// Raised when a file is successfully changed.
    /// </summary>
    event EventHandler<FileChangedEventArgs>? FileChanged;

    /// <summary>
    /// Raised when a file change operation fails.
    /// </summary>
    event EventHandler<FileChangeFailedEventArgs>? ChangeFailed;

    /// <summary>
    /// Raised when a change is successfully undone.
    /// </summary>
    event EventHandler<FileChangeUndoneEventArgs>? ChangeUndone;

    /// <summary>
    /// Raised when a conflict is detected during apply.
    /// </summary>
    event EventHandler<FileConflictDetectedEventArgs>? ConflictDetected;
}
```

### FileChangeService Implementation

```csharp
// src/SeniorIntern.Services/FileChangeService.cs
using System.Collections.Concurrent;
using System.Security.Cryptography;
using System.Text;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;

namespace SeniorIntern.Services;

/// <summary>
/// Service for applying code changes to the filesystem with undo support.
/// </summary>
/// <remarks>
/// This service provides thread-safe file modification operations with:
/// <list type="bullet">
///   <item>Conflict detection to prevent overwriting concurrent changes</item>
///   <item>Automatic backup creation for undo capability</item>
///   <item>Change history tracking per file</item>
///   <item>Time-windowed undo support</item>
///   <item>Event notifications for UI updates</item>
///   <item>Comprehensive error handling with specific result types</item>
/// </list>
/// </remarks>
public sealed class FileChangeService : IFileChangeService, IDisposable
{
    private readonly IFileSystemService _fileSystem;
    private readonly IDiffService _diffService;
    private readonly IBackupService _backupService;
    private readonly ILogger<FileChangeService>? _logger;
    private readonly ApplyOptions _defaultOptions;

    // Thread-safe change history storage: file path -> stack of changes
    private readonly ConcurrentDictionary<string, Stack<FileChangeRecord>> _changeHistory = new();

    // Lock for history stack mutations (Push/Pop operations)
    private readonly object _historyLock = new();

    // Semaphore to ensure only one apply operation at a time
    private readonly SemaphoreSlim _applyLock = new(1, 1);

    // Maximum number of history records to keep per file
    private const int MaxHistoryPerFile = 50;

    /// <inheritdoc />
    public event EventHandler<FileChangedEventArgs>? FileChanged;

    /// <inheritdoc />
    public event EventHandler<FileChangeFailedEventArgs>? ChangeFailed;

    /// <inheritdoc />
    public event EventHandler<FileChangeUndoneEventArgs>? ChangeUndone;

    /// <inheritdoc />
    public event EventHandler<FileConflictDetectedEventArgs>? ConflictDetected;

    /// <summary>
    /// Initializes a new instance of the FileChangeService.
    /// </summary>
    /// <param name="fileSystem">Service for file system operations.</param>
    /// <param name="diffService">Service for computing diffs.</param>
    /// <param name="backupService">Service for managing backups.</param>
    /// <param name="logger">Optional logger for diagnostics.</param>
    /// <param name="defaultOptions">Default options for apply operations.</param>
    public FileChangeService(
        IFileSystemService fileSystem,
        IDiffService diffService,
        IBackupService backupService,
        ILogger<FileChangeService>? logger = null,
        ApplyOptions? defaultOptions = null)
    {
        _fileSystem = fileSystem ?? throw new ArgumentNullException(nameof(fileSystem));
        _diffService = diffService ?? throw new ArgumentNullException(nameof(diffService));
        _backupService = backupService ?? throw new ArgumentNullException(nameof(backupService));
        _logger = logger;
        _defaultOptions = defaultOptions ?? ApplyOptions.Default;
    }

    /// <inheritdoc />
    public async Task<ApplyResult> ApplyCodeBlockAsync(
        CodeBlock block,
        string workspacePath,
        ApplyOptions? options = null,
        CancellationToken ct = default)
    {
        options ??= _defaultOptions;

        // Validate inputs
        if (block == null)
        {
            return ApplyResult.Failed(
                string.Empty,
                ApplyResultType.ValidationFailed,
                "Code block cannot be null");
        }

        if (string.IsNullOrEmpty(block.TargetFilePath))
        {
            return ApplyResult.Failed(
                string.Empty,
                ApplyResultType.ValidationFailed,
                "Code block does not have a target file path");
        }

        if (string.IsNullOrEmpty(workspacePath))
        {
            return ApplyResult.Failed(
                block.TargetFilePath,
                ApplyResultType.ValidationFailed,
                "Workspace path cannot be empty");
        }

        var fullPath = Path.Combine(workspacePath, block.TargetFilePath);
        var relativePath = block.TargetFilePath;

        // Acquire apply lock to ensure thread safety
        await _applyLock.WaitAsync(ct);
        try
        {
            return await ApplyInternalAsync(
                block, fullPath, relativePath, workspacePath, options, ct);
        }
        finally
        {
            _applyLock.Release();
        }
    }

    /// <summary>
    /// Internal implementation of apply logic.
    /// </summary>
    private async Task<ApplyResult> ApplyInternalAsync(
        CodeBlock block,
        string fullPath,
        string relativePath,
        string workspacePath,
        ApplyOptions options,
        CancellationToken ct)
    {
        var fileExists = await _fileSystem.FileExistsAsync(fullPath, ct);

        try
        {
            // Check for conflicts if file exists and conflict overwrite not allowed
            if (fileExists && !options.AllowConflictOverwrite)
            {
                var conflictCheck = await CheckForConflictsAsync(block, workspacePath, ct);
                if (conflictCheck.HasConflict)
                {
                    _logger?.LogWarning(
                        "Conflict detected for {FilePath}: {Reason}",
                        relativePath,
                        conflictCheck.ConflictReason);

                    ConflictDetected?.Invoke(this, new FileConflictDetectedEventArgs
                    {
                        FilePath = fullPath,
                        ExpectedHash = conflictCheck.ExpectedContentHash ?? string.Empty,
                        ActualHash = conflictCheck.CurrentContentHash ?? string.Empty,
                        LastModified = conflictCheck.LastModified ?? DateTime.UtcNow
                    });

                    return ApplyResult.Conflict(
                        fullPath,
                        relativePath,
                        conflictCheck.ConflictReason ?? "File has been modified");
                }
            }

            // Create backup for existing files if configured
            string? backupPath = null;
            string? originalHash = null;
            if (fileExists && options.CreateBackup)
            {
                var originalContent = await _fileSystem.ReadFileAsync(fullPath, ct);
                originalHash = ComputeHash(originalContent);
                backupPath = await _backupService.CreateBackupAsync(fullPath, ct);
                _logger?.LogDebug("Created backup at {BackupPath}", backupPath);
            }

            // Compute diff for the code block
            var diff = await _diffService.ComputeDiffForBlockAsync(block, workspacePath, ct);

            // Create parent directories if needed and configured
            if (options.CreateParentDirectories)
            {
                var directory = Path.GetDirectoryName(fullPath);
                if (!string.IsNullOrEmpty(directory) && !Directory.Exists(directory))
                {
                    Directory.CreateDirectory(directory);
                    _logger?.LogDebug("Created directory {Directory}", directory);
                }
            }

            // Prepare content to write
            var contentToWrite = diff.ProposedContent;

            // Preserve line endings from original file if configured
            if (options.PreserveLineEndings && fileExists)
            {
                var originalContent = await _fileSystem.ReadFileAsync(fullPath, ct);
                contentToWrite = NormalizeLineEndings(contentToWrite, originalContent);
            }

            // Write the file
            await _fileSystem.WriteFileAsync(fullPath, contentToWrite, ct);

            var newHash = ComputeHash(contentToWrite);
            var changeType = fileExists ? FileChangeType.Modified : FileChangeType.Created;

            // Record change for undo
            var record = new FileChangeRecord
            {
                FilePath = fullPath,
                RelativePath = relativePath,
                BackupPath = backupPath ?? string.Empty,
                ChangeType = changeType,
                CodeBlockId = block.Id,
                MessageId = block.MessageId,
                CanUndo = !string.IsNullOrEmpty(backupPath) || changeType == FileChangeType.Created,
                OriginalContentHash = originalHash,
                NewContentHash = newHash,
                Description = $"Applied code block to {Path.GetFileName(fullPath)}"
            };

            RecordChange(fullPath, record);

            // Raise success event
            FileChanged?.Invoke(this, new FileChangedEventArgs
            {
                FilePath = fullPath,
                RelativePath = relativePath,
                ChangeType = changeType,
                CodeBlockId = block.Id,
                MessageId = block.MessageId,
                CanUndo = record.CanUndo
            });

            _logger?.LogInformation(
                "Applied code block {BlockId} to {FilePath} ({ChangeType})",
                block.Id, relativePath, changeType);

            // Build success result
            var fileInfo = new FileInfo(fullPath);
            return new ApplyResult
            {
                Success = true,
                FilePath = fullPath,
                RelativePath = relativePath,
                BackupPath = backupPath,
                ResultType = changeType == FileChangeType.Created
                    ? ApplyResultType.Created
                    : ApplyResultType.Modified,
                AppliedDiff = diff,
                CodeBlockId = block.Id,
                CanUndo = record.CanUndo,
                FileSizeBytes = fileInfo.Length
            };
        }
        catch (UnauthorizedAccessException ex)
        {
            _logger?.LogWarning(ex, "Permission denied writing to {FilePath}", fullPath);
            RaiseChangeFailed(fullPath, "Permission denied", ApplyResultType.PermissionDenied, ex);
            return ApplyResult.Failed(fullPath, ApplyResultType.PermissionDenied, ex.Message);
        }
        catch (IOException ex) when (IsFileLocked(ex))
        {
            _logger?.LogWarning(ex, "File is locked: {FilePath}", fullPath);
            RaiseChangeFailed(fullPath, "File is locked by another process", ApplyResultType.FileLocked, ex);
            return ApplyResult.Failed(fullPath, ApplyResultType.FileLocked, ex.Message);
        }
        catch (IOException ex) when (IsDiskFull(ex))
        {
            _logger?.LogError(ex, "Disk full writing to {FilePath}", fullPath);
            RaiseChangeFailed(fullPath, "Disk is full", ApplyResultType.DiskFull, ex);
            return ApplyResult.Failed(fullPath, ApplyResultType.DiskFull, ex.Message);
        }
        catch (Exception ex)
        {
            _logger?.LogError(ex, "Error applying changes to {FilePath}", fullPath);
            RaiseChangeFailed(fullPath, ex.Message, ApplyResultType.Error, ex);
            return ApplyResult.Failed(fullPath, ApplyResultType.Error, ex.Message);
        }
    }

    /// <inheritdoc />
    public async Task<IReadOnlyList<ApplyResult>> ApplyCodeBlocksAsync(
        IEnumerable<CodeBlock> blocks,
        string workspacePath,
        ApplyOptions? options = null,
        CancellationToken ct = default)
    {
        var results = new List<ApplyResult>();
        var blockList = blocks?.ToList() ?? new List<CodeBlock>();

        if (blockList.Count == 0)
        {
            return results;
        }

        // Group by target file to handle multiple blocks targeting same file
        var groupedByFile = blockList
            .Where(b => !string.IsNullOrEmpty(b.TargetFilePath))
            .GroupBy(b => b.TargetFilePath!)
            .ToList();

        foreach (var group in groupedByFile)
        {
            ct.ThrowIfCancellationRequested();

            var blocksForFile = group.ToList();

            if (blocksForFile.Count == 1)
            {
                // Single block - apply directly
                var result = await ApplyCodeBlockAsync(blocksForFile[0], workspacePath, options, ct);
                results.Add(result);
            }
            else
            {
                // Multiple blocks targeting same file - merge and apply
                _logger?.LogDebug(
                    "Merging {Count} blocks for file {FilePath}",
                    blocksForFile.Count,
                    group.Key);

                var mergedDiff = await _diffService.ComputeMergedDiffAsync(
                    blocksForFile, workspacePath, ct);
                var result = await ApplyDiffAsync(mergedDiff, workspacePath, options, ct);
                results.Add(result);
            }
        }

        return results;
    }

    /// <inheritdoc />
    public async Task<ApplyResult> ApplyDiffAsync(
        DiffResult diff,
        string workspacePath,
        ApplyOptions? options = null,
        CancellationToken ct = default)
    {
        options ??= _defaultOptions;

        if (diff == null)
        {
            return ApplyResult.Failed(
                string.Empty,
                ApplyResultType.ValidationFailed,
                "Diff cannot be null");
        }

        var fullPath = Path.Combine(workspacePath, diff.OriginalFilePath);
        var fileExists = await _fileSystem.FileExistsAsync(fullPath, ct);

        await _applyLock.WaitAsync(ct);
        try
        {
            string? backupPath = null;
            string? originalHash = null;

            // Create backup for existing files if configured
            if (fileExists && options.CreateBackup)
            {
                var originalContent = await _fileSystem.ReadFileAsync(fullPath, ct);
                originalHash = ComputeHash(originalContent);
                backupPath = await _backupService.CreateBackupAsync(fullPath, ct);
            }

            // Create parent directories if needed
            if (options.CreateParentDirectories)
            {
                var directory = Path.GetDirectoryName(fullPath);
                if (!string.IsNullOrEmpty(directory) && !Directory.Exists(directory))
                {
                    Directory.CreateDirectory(directory);
                }
            }

            // Write the file
            await _fileSystem.WriteFileAsync(fullPath, diff.ProposedContent, ct);

            var changeType = diff.IsNewFile ? FileChangeType.Created : FileChangeType.Modified;
            var newHash = ComputeHash(diff.ProposedContent);

            // Record change for undo
            var record = new FileChangeRecord
            {
                FilePath = fullPath,
                RelativePath = diff.OriginalFilePath,
                BackupPath = backupPath ?? string.Empty,
                ChangeType = changeType,
                CanUndo = !string.IsNullOrEmpty(backupPath) || changeType == FileChangeType.Created,
                OriginalContentHash = originalHash,
                NewContentHash = newHash,
                Description = $"Applied diff to {Path.GetFileName(fullPath)}"
            };

            RecordChange(fullPath, record);

            // Raise success event
            FileChanged?.Invoke(this, new FileChangedEventArgs
            {
                FilePath = fullPath,
                RelativePath = diff.OriginalFilePath,
                ChangeType = changeType,
                CanUndo = record.CanUndo
            });

            _logger?.LogInformation(
                "Applied diff to {FilePath} ({ChangeType})",
                diff.OriginalFilePath, changeType);

            return ApplyResult.Succeeded(
                fullPath,
                diff.OriginalFilePath,
                diff.IsNewFile ? ApplyResultType.Created : ApplyResultType.Modified,
                diff,
                backupPath);
        }
        catch (Exception ex)
        {
            _logger?.LogError(ex, "Error applying diff to {FilePath}", fullPath);
            RaiseChangeFailed(fullPath, ex.Message, ApplyResultType.Error, ex);
            return ApplyResult.Failed(fullPath, ApplyResultType.Error, ex.Message);
        }
        finally
        {
            _applyLock.Release();
        }
    }

    /// <inheritdoc />
    public async Task<ApplyPreview> PreviewApplyAsync(
        CodeBlock block,
        string workspacePath,
        CancellationToken ct = default)
    {
        if (block == null || string.IsNullOrEmpty(block.TargetFilePath))
        {
            return new ApplyPreview
            {
                WouldSucceed = false,
                ExpectedResultType = ApplyResultType.ValidationFailed,
                WarningMessage = "Code block has no target file path"
            };
        }

        var fullPath = Path.Combine(workspacePath, block.TargetFilePath);
        var fileExists = await _fileSystem.FileExistsAsync(fullPath, ct);

        try
        {
            // Compute diff without writing anything
            var diff = await _diffService.ComputeDiffForBlockAsync(block, workspacePath, ct);

            // Check for conflicts if file exists
            var conflictCheck = fileExists
                ? await CheckForConflictsAsync(block, workspacePath, ct)
                : new ConflictCheckResult { HasConflict = false };

            // Check write permissions
            bool hasWritePermission = true;
            if (fileExists)
            {
                try
                {
                    var fileInfo = new FileInfo(fullPath);
                    hasWritePermission = !fileInfo.IsReadOnly;
                }
                catch
                {
                    hasWritePermission = false;
                }
            }

            return new ApplyPreview
            {
                WouldSucceed = !conflictCheck.HasConflict && hasWritePermission,
                ExpectedResultType = fileExists
                    ? ApplyResultType.Modified
                    : ApplyResultType.Created,
                FileExists = fileExists,
                HasConflict = conflictCheck.HasConflict,
                Diff = diff,
                WarningMessage = conflictCheck.HasConflict
                    ? conflictCheck.ConflictReason
                    : (!hasWritePermission ? "File is read-only" : null),
                AffectedPaths = new[] { block.TargetFilePath }
            };
        }
        catch (Exception ex)
        {
            _logger?.LogWarning(ex, "Error previewing apply for {FilePath}", block.TargetFilePath);
            return new ApplyPreview
            {
                WouldSucceed = false,
                ExpectedResultType = ApplyResultType.Error,
                WarningMessage = ex.Message
            };
        }
    }

    /// <inheritdoc />
    public async Task<bool> UndoLastChangeAsync(string filePath, CancellationToken ct = default)
    {
        if (string.IsNullOrEmpty(filePath))
        {
            return false;
        }

        if (!_changeHistory.TryGetValue(filePath, out var history) || history.Count == 0)
        {
            _logger?.LogDebug("No undo history for {FilePath}", filePath);
            return false;
        }

        FileChangeRecord lastChange;
        lock (_historyLock)
        {
            if (history.Count == 0)
                return false;
            lastChange = history.Peek();
        }

        if (!lastChange.CanUndo)
        {
            _logger?.LogDebug("Last change cannot be undone for {FilePath}", filePath);
            return false;
        }

        if (lastChange.IsUndoExpired(_defaultOptions.UndoWindow))
        {
            _logger?.LogDebug("Undo has expired for {FilePath}", filePath);
            return false;
        }

        return await UndoChangeAsync(lastChange.Id, ct);
    }

    /// <inheritdoc />
    public async Task<bool> UndoChangeAsync(Guid changeId, CancellationToken ct = default)
    {
        FileChangeRecord? record = null;
        string? filePath = null;

        // Find the change record across all file histories
        lock (_historyLock)
        {
            foreach (var (path, history) in _changeHistory)
            {
                var found = history.FirstOrDefault(r => r.Id == changeId);
                if (found != null)
                {
                    record = found;
                    filePath = path;
                    break;
                }
            }
        }

        if (record == null || filePath == null)
        {
            _logger?.LogDebug("Change record {ChangeId} not found", changeId);
            return false;
        }

        // Verify undo is still valid
        if (record.IsUndoExpired(_defaultOptions.UndoWindow))
        {
            _logger?.LogDebug("Undo has expired for change {ChangeId}", changeId);
            return false;
        }

        await _applyLock.WaitAsync(ct);
        try
        {
            if (record.ChangeType == FileChangeType.Created)
            {
                // Undo file creation by deleting the file
                if (File.Exists(filePath))
                {
                    File.Delete(filePath);
                    _logger?.LogInformation("Undone file creation: {FilePath}", filePath);
                }
            }
            else
            {
                // Undo modification by restoring from backup
                if (string.IsNullOrEmpty(record.BackupPath))
                {
                    _logger?.LogWarning("No backup path for undo: {FilePath}", filePath);
                    return false;
                }

                if (!File.Exists(record.BackupPath))
                {
                    _logger?.LogWarning("Backup file not found: {BackupPath}", record.BackupPath);
                    return false;
                }

                File.Copy(record.BackupPath, filePath, overwrite: true);
                _logger?.LogInformation("Restored file from backup: {FilePath}", filePath);
            }

            // Remove from history
            lock (_historyLock)
            {
                if (_changeHistory.TryGetValue(filePath, out var history))
                {
                    var list = history.ToList();
                    list.RemoveAll(r => r.Id == changeId);
                    _changeHistory[filePath] = new Stack<FileChangeRecord>(list.AsEnumerable().Reverse());
                }
            }

            // Raise undo event
            ChangeUndone?.Invoke(this, new FileChangeUndoneEventArgs
            {
                FilePath = filePath,
                OriginalChange = record
            });

            return true;
        }
        catch (Exception ex)
        {
            _logger?.LogError(ex, "Failed to undo change for {FilePath}", filePath);
            return false;
        }
        finally
        {
            _applyLock.Release();
        }
    }

    /// <inheritdoc />
    public bool CanUndo(string filePath)
    {
        if (string.IsNullOrEmpty(filePath))
            return false;

        if (!_changeHistory.TryGetValue(filePath, out var history) || history.Count == 0)
            return false;

        var lastChange = history.Peek();
        return lastChange.CanUndo && !lastChange.IsUndoExpired(_defaultOptions.UndoWindow);
    }

    /// <inheritdoc />
    public IReadOnlyList<FileChangeRecord> GetChangeHistory(string filePath, int maxRecords = 10)
    {
        if (string.IsNullOrEmpty(filePath))
            return Array.Empty<FileChangeRecord>();

        if (!_changeHistory.TryGetValue(filePath, out var history))
            return Array.Empty<FileChangeRecord>();

        return history.Take(maxRecords).ToList();
    }

    /// <inheritdoc />
    public IReadOnlyList<FileChangeRecord> GetPendingUndos()
    {
        var pending = new List<FileChangeRecord>();
        var window = _defaultOptions.UndoWindow;

        foreach (var (_, history) in _changeHistory)
        {
            foreach (var record in history)
            {
                if (record.CanUndo && !record.IsUndoExpired(window))
                {
                    pending.Add(record);
                }
            }
        }

        return pending.OrderByDescending(r => r.ChangedAt).ToList();
    }

    /// <inheritdoc />
    public async Task<ConflictCheckResult> CheckForConflictsAsync(
        CodeBlock block,
        string workspacePath,
        CancellationToken ct = default)
    {
        if (block == null || string.IsNullOrEmpty(block.TargetFilePath))
        {
            return new ConflictCheckResult { HasConflict = false };
        }

        var fullPath = Path.Combine(workspacePath, block.TargetFilePath);

        if (!await _fileSystem.FileExistsAsync(fullPath, ct))
        {
            return new ConflictCheckResult { HasConflict = false };
        }

        try
        {
            var currentContent = await _fileSystem.ReadFileAsync(fullPath, ct);
            var currentHash = ComputeHash(currentContent);
            var fileInfo = new FileInfo(fullPath);

            // Check if file was modified very recently (possible concurrent edit)
            var timeSinceModified = DateTime.UtcNow - fileInfo.LastWriteTimeUtc;
            var recentlyModified = timeSinceModified < TimeSpan.FromSeconds(5);

            // Check if we have a recorded hash for this file to compare against
            string? expectedHash = null;
            if (_changeHistory.TryGetValue(fullPath, out var history) && history.Count > 0)
            {
                var lastRecord = history.Peek();
                expectedHash = lastRecord.NewContentHash;
            }

            // Conflict if file was modified and hash doesn't match our last known state
            var hashMismatch = expectedHash != null && expectedHash != currentHash;

            return new ConflictCheckResult
            {
                HasConflict = recentlyModified || hashMismatch,
                ConflictReason = recentlyModified
                    ? $"File was modified {timeSinceModified.TotalSeconds:F1} seconds ago"
                    : (hashMismatch ? "File content has changed since last apply" : null),
                LastModified = fileInfo.LastWriteTimeUtc,
                CurrentContentHash = currentHash,
                ExpectedContentHash = expectedHash
            };
        }
        catch (Exception ex)
        {
            _logger?.LogWarning(ex, "Error checking for conflicts: {FilePath}", fullPath);
            return new ConflictCheckResult
            {
                HasConflict = true,
                ConflictReason = $"Error checking file: {ex.Message}"
            };
        }
    }

    /// <summary>
    /// Records a change in the history for undo support.
    /// </summary>
    private void RecordChange(string filePath, FileChangeRecord record)
    {
        lock (_historyLock)
        {
            var history = _changeHistory.GetOrAdd(filePath, _ => new Stack<FileChangeRecord>());
            history.Push(record);

            // Limit history size per file and cleanup old backups
            while (history.Count > MaxHistoryPerFile)
            {
                var oldRecords = history.ToArray();
                var oldest = oldRecords.Last();

                // Clean up old backup file
                if (!string.IsNullOrEmpty(oldest.BackupPath) && File.Exists(oldest.BackupPath))
                {
                    try
                    {
                        File.Delete(oldest.BackupPath);
                        _logger?.LogDebug("Cleaned up old backup: {BackupPath}", oldest.BackupPath);
                    }
                    catch (Exception ex)
                    {
                        _logger?.LogWarning(ex, "Failed to cleanup backup: {BackupPath}", oldest.BackupPath);
                    }
                }

                // Rebuild stack without oldest
                var remaining = oldRecords.Take(MaxHistoryPerFile).Reverse();
                _changeHistory[filePath] = new Stack<FileChangeRecord>(remaining);
            }
        }
    }

    /// <summary>
    /// Raises the ChangeFailed event.
    /// </summary>
    private void RaiseChangeFailed(
        string filePath,
        string message,
        ApplyResultType type,
        Exception? ex = null)
    {
        ChangeFailed?.Invoke(this, new FileChangeFailedEventArgs
        {
            FilePath = filePath,
            ErrorMessage = message,
            FailureType = type,
            Exception = ex
        });
    }

    /// <summary>
    /// Computes SHA-256 hash of content for conflict detection.
    /// </summary>
    private static string ComputeHash(string content)
    {
        using var sha256 = SHA256.Create();
        var bytes = Encoding.UTF8.GetBytes(content);
        var hash = sha256.ComputeHash(bytes);
        return Convert.ToBase64String(hash);
    }

    /// <summary>
    /// Normalizes line endings in content to match reference file.
    /// </summary>
    private static string NormalizeLineEndings(string content, string reference)
    {
        // Detect line ending style from reference
        bool hasCrlf = reference.Contains("\r\n");
        bool hasCr = !hasCrlf && reference.Contains('\r');

        // Normalize content to LF first
        var normalized = content.Replace("\r\n", "\n").Replace('\r', '\n');

        // Convert to detected style
        if (hasCrlf)
            return normalized.Replace("\n", "\r\n");
        if (hasCr)
            return normalized.Replace("\n", "\r");

        return normalized;
    }

    /// <summary>
    /// Checks if IOException indicates file is locked.
    /// </summary>
    private static bool IsFileLocked(IOException ex)
    {
        // ERROR_SHARING_VIOLATION (0x80070020) = -2147024864
        // ERROR_LOCK_VIOLATION (0x80070021) = -2147024863
        return ex.HResult == -2147024864 || ex.HResult == -2147024863;
    }

    /// <summary>
    /// Checks if IOException indicates disk is full.
    /// </summary>
    private static bool IsDiskFull(IOException ex)
    {
        // ERROR_DISK_FULL (0x80070070) = -2147024784
        return ex.HResult == -2147024784;
    }

    /// <summary>
    /// Disposes resources used by the service.
    /// </summary>
    public void Dispose()
    {
        _applyLock.Dispose();
    }
}
```

### Supporting Interface: IFileSystemService

```csharp
// src/SeniorIntern.Core/Interfaces/IFileSystemService.cs
namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Abstraction for file system operations to enable testing.
/// </summary>
public interface IFileSystemService
{
    /// <summary>
    /// Check if a file exists.
    /// </summary>
    Task<bool> FileExistsAsync(string path, CancellationToken ct = default);

    /// <summary>
    /// Read file content as string.
    /// </summary>
    Task<string> ReadFileAsync(string path, CancellationToken ct = default);

    /// <summary>
    /// Write content to file.
    /// </summary>
    Task WriteFileAsync(string path, string content, CancellationToken ct = default);

    /// <summary>
    /// Delete a file.
    /// </summary>
    Task DeleteFileAsync(string path, CancellationToken ct = default);

    /// <summary>
    /// Check if a directory exists.
    /// </summary>
    Task<bool> DirectoryExistsAsync(string path, CancellationToken ct = default);

    /// <summary>
    /// Create a directory (and parents).
    /// </summary>
    Task CreateDirectoryAsync(string path, CancellationToken ct = default);
}
```

### FileSystemService Implementation

```csharp
// src/SeniorIntern.Services/FileSystemService.cs
namespace SeniorIntern.Services;

/// <summary>
/// Default implementation of IFileSystemService using System.IO.
/// </summary>
public sealed class FileSystemService : IFileSystemService
{
    /// <inheritdoc />
    public Task<bool> FileExistsAsync(string path, CancellationToken ct = default)
    {
        return Task.FromResult(File.Exists(path));
    }

    /// <inheritdoc />
    public async Task<string> ReadFileAsync(string path, CancellationToken ct = default)
    {
        return await File.ReadAllTextAsync(path, ct);
    }

    /// <inheritdoc />
    public async Task WriteFileAsync(string path, string content, CancellationToken ct = default)
    {
        await File.WriteAllTextAsync(path, content, ct);
    }

    /// <inheritdoc />
    public Task DeleteFileAsync(string path, CancellationToken ct = default)
    {
        if (File.Exists(path))
        {
            File.Delete(path);
        }
        return Task.CompletedTask;
    }

    /// <inheritdoc />
    public Task<bool> DirectoryExistsAsync(string path, CancellationToken ct = default)
    {
        return Task.FromResult(Directory.Exists(path));
    }

    /// <inheritdoc />
    public Task CreateDirectoryAsync(string path, CancellationToken ct = default)
    {
        Directory.CreateDirectory(path);
        return Task.CompletedTask;
    }
}
```

### Dependency Injection Registration

```csharp
// src/SeniorIntern.Desktop/Extensions/ServiceCollectionExtensions.cs
using Microsoft.Extensions.DependencyInjection;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Services;

namespace SeniorIntern.Desktop.Extensions;

public static partial class ServiceCollectionExtensions
{
    /// <summary>
    /// Registers apply workflow services.
    /// </summary>
    public static IServiceCollection AddApplyServices(this IServiceCollection services)
    {
        // Register file system abstraction
        services.AddSingleton<IFileSystemService, FileSystemService>();

        // Register file change service
        services.AddSingleton<IFileChangeService, FileChangeService>();

        // Register backup service (from v0.4.3c)
        services.AddSingleton<IBackupService, BackupService>();

        return services;
    }
}
```

---

## Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/IFileChangeService.cs` | Service interface definition |
| `src/SeniorIntern.Core/Interfaces/IFileSystemService.cs` | File system abstraction interface |
| `src/SeniorIntern.Services/FileChangeService.cs` | Main service implementation |
| `src/SeniorIntern.Services/FileSystemService.cs` | File system implementation |

## Files to Modify

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/Extensions/ServiceCollectionExtensions.cs` | Register services in DI container |

---

## Testing Strategy

### Unit Tests

```csharp
// tests/SeniorIntern.Services.Tests/FileChangeServiceTests.cs
using System.IO;
using Moq;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Services;
using Xunit;

namespace SeniorIntern.Services.Tests;

public class FileChangeServiceTests : IDisposable
{
    private readonly string _workspacePath;
    private readonly Mock<IFileSystemService> _fileSystemMock;
    private readonly Mock<IDiffService> _diffServiceMock;
    private readonly Mock<IBackupService> _backupServiceMock;
    private readonly FileChangeService _service;

    public FileChangeServiceTests()
    {
        _workspacePath = Path.Combine(Path.GetTempPath(), $"FileChangeServiceTests_{Guid.NewGuid()}");
        Directory.CreateDirectory(_workspacePath);

        _fileSystemMock = new Mock<IFileSystemService>();
        _diffServiceMock = new Mock<IDiffService>();
        _backupServiceMock = new Mock<IBackupService>();

        _service = new FileChangeService(
            _fileSystemMock.Object,
            _diffServiceMock.Object,
            _backupServiceMock.Object);
    }

    public void Dispose()
    {
        _service.Dispose();
        if (Directory.Exists(_workspacePath))
        {
            Directory.Delete(_workspacePath, recursive: true);
        }
    }

    #region ApplyCodeBlockAsync Tests

    [Fact]
    public async Task ApplyCodeBlockAsync_NullBlock_ReturnsValidationFailed()
    {
        // Act
        var result = await _service.ApplyCodeBlockAsync(null!, _workspacePath);

        // Assert
        Assert.False(result.Success);
        Assert.Equal(ApplyResultType.ValidationFailed, result.ResultType);
        Assert.Contains("null", result.ErrorMessage);
    }

    [Fact]
    public async Task ApplyCodeBlockAsync_NoTargetPath_ReturnsValidationFailed()
    {
        // Arrange
        var block = new CodeBlock { TargetFilePath = null };

        // Act
        var result = await _service.ApplyCodeBlockAsync(block, _workspacePath);

        // Assert
        Assert.False(result.Success);
        Assert.Equal(ApplyResultType.ValidationFailed, result.ResultType);
        Assert.Contains("target file path", result.ErrorMessage);
    }

    [Fact]
    public async Task ApplyCodeBlockAsync_EmptyWorkspace_ReturnsValidationFailed()
    {
        // Arrange
        var block = new CodeBlock { TargetFilePath = "test.cs" };

        // Act
        var result = await _service.ApplyCodeBlockAsync(block, string.Empty);

        // Assert
        Assert.False(result.Success);
        Assert.Equal(ApplyResultType.ValidationFailed, result.ResultType);
    }

    [Fact]
    public async Task ApplyCodeBlockAsync_NewFile_CreatesFileAndReturnsCreated()
    {
        // Arrange
        var block = new CodeBlock
        {
            Id = Guid.NewGuid(),
            TargetFilePath = "src/NewFile.cs",
            Content = "public class Test {}"
        };

        var diff = new DiffResult
        {
            OriginalFilePath = block.TargetFilePath,
            ProposedContent = block.Content,
            IsNewFile = true
        };

        _fileSystemMock.Setup(f => f.FileExistsAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(false);
        _diffServiceMock.Setup(d => d.ComputeDiffForBlockAsync(block, _workspacePath, It.IsAny<CancellationToken>()))
            .ReturnsAsync(diff);
        _fileSystemMock.Setup(f => f.WriteFileAsync(It.IsAny<string>(), It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .Returns(Task.CompletedTask);

        // Act
        var result = await _service.ApplyCodeBlockAsync(block, _workspacePath);

        // Assert
        Assert.True(result.Success);
        Assert.Equal(ApplyResultType.Created, result.ResultType);
        Assert.Equal(block.Id, result.CodeBlockId);
        _fileSystemMock.Verify(f => f.WriteFileAsync(
            It.Is<string>(p => p.EndsWith("NewFile.cs")),
            block.Content,
            It.IsAny<CancellationToken>()), Times.Once);
    }

    [Fact]
    public async Task ApplyCodeBlockAsync_ExistingFile_CreatesBackupAndReturnsModified()
    {
        // Arrange
        var block = new CodeBlock
        {
            Id = Guid.NewGuid(),
            TargetFilePath = "src/Existing.cs",
            Content = "new content"
        };

        var originalContent = "original content";
        var backupPath = "/backups/Existing.cs.backup";
        var diff = new DiffResult
        {
            OriginalFilePath = block.TargetFilePath,
            ProposedContent = block.Content,
            IsNewFile = false
        };

        _fileSystemMock.Setup(f => f.FileExistsAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(true);
        _fileSystemMock.Setup(f => f.ReadFileAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(originalContent);
        _backupServiceMock.Setup(b => b.CreateBackupAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(backupPath);
        _diffServiceMock.Setup(d => d.ComputeDiffForBlockAsync(block, _workspacePath, It.IsAny<CancellationToken>()))
            .ReturnsAsync(diff);
        _fileSystemMock.Setup(f => f.WriteFileAsync(It.IsAny<string>(), It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .Returns(Task.CompletedTask);

        // Act
        var result = await _service.ApplyCodeBlockAsync(block, _workspacePath);

        // Assert
        Assert.True(result.Success);
        Assert.Equal(ApplyResultType.Modified, result.ResultType);
        Assert.Equal(backupPath, result.BackupPath);
        Assert.True(result.CanUndo);
        _backupServiceMock.Verify(b => b.CreateBackupAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()), Times.Once);
    }

    [Fact]
    public async Task ApplyCodeBlockAsync_ConflictDetected_ReturnsConflict()
    {
        // Arrange
        var block = new CodeBlock
        {
            TargetFilePath = "src/Conflicted.cs",
            Content = "new content"
        };

        _fileSystemMock.Setup(f => f.FileExistsAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(true);
        _fileSystemMock.Setup(f => f.ReadFileAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync("current content");

        // Simulate recent modification by setting up the file info check
        // In real test, would mock FileInfo or use actual file system

        // Act - using options that don't allow conflict overwrite
        var options = ApplyOptions.Default;
        var result = await _service.ApplyCodeBlockAsync(block, _workspacePath, options);

        // Behavior depends on conflict detection implementation
        // This tests the path where conflict is detected
    }

    [Fact]
    public async Task ApplyCodeBlockAsync_RaisesFileChangedEvent()
    {
        // Arrange
        var block = new CodeBlock
        {
            Id = Guid.NewGuid(),
            TargetFilePath = "src/Test.cs",
            Content = "content"
        };

        var diff = new DiffResult
        {
            OriginalFilePath = block.TargetFilePath,
            ProposedContent = block.Content,
            IsNewFile = true
        };

        _fileSystemMock.Setup(f => f.FileExistsAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(false);
        _diffServiceMock.Setup(d => d.ComputeDiffForBlockAsync(block, _workspacePath, It.IsAny<CancellationToken>()))
            .ReturnsAsync(diff);
        _fileSystemMock.Setup(f => f.WriteFileAsync(It.IsAny<string>(), It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .Returns(Task.CompletedTask);

        FileChangedEventArgs? eventArgs = null;
        _service.FileChanged += (s, e) => eventArgs = e;

        // Act
        await _service.ApplyCodeBlockAsync(block, _workspacePath);

        // Assert
        Assert.NotNull(eventArgs);
        Assert.Equal(block.Id, eventArgs.CodeBlockId);
        Assert.Equal(FileChangeType.Created, eventArgs.ChangeType);
    }

    #endregion

    #region ApplyCodeBlocksAsync Tests

    [Fact]
    public async Task ApplyCodeBlocksAsync_EmptyList_ReturnsEmptyResults()
    {
        // Act
        var results = await _service.ApplyCodeBlocksAsync(
            Enumerable.Empty<CodeBlock>(),
            _workspacePath);

        // Assert
        Assert.Empty(results);
    }

    [Fact]
    public async Task ApplyCodeBlocksAsync_MultipleBlocksSameFile_MergesAndApplies()
    {
        // Arrange
        var blocks = new[]
        {
            new CodeBlock { TargetFilePath = "src/File.cs", Content = "part1" },
            new CodeBlock { TargetFilePath = "src/File.cs", Content = "part2" }
        };

        var mergedDiff = new DiffResult
        {
            OriginalFilePath = "src/File.cs",
            ProposedContent = "merged content",
            IsNewFile = true
        };

        _fileSystemMock.Setup(f => f.FileExistsAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(false);
        _diffServiceMock.Setup(d => d.ComputeMergedDiffAsync(
            It.IsAny<IEnumerable<CodeBlock>>(),
            _workspacePath,
            It.IsAny<CancellationToken>()))
            .ReturnsAsync(mergedDiff);
        _fileSystemMock.Setup(f => f.WriteFileAsync(It.IsAny<string>(), It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .Returns(Task.CompletedTask);

        // Act
        var results = await _service.ApplyCodeBlocksAsync(blocks, _workspacePath);

        // Assert
        Assert.Single(results);
        _diffServiceMock.Verify(d => d.ComputeMergedDiffAsync(
            It.IsAny<IEnumerable<CodeBlock>>(),
            _workspacePath,
            It.IsAny<CancellationToken>()), Times.Once);
    }

    [Fact]
    public async Task ApplyCodeBlocksAsync_DifferentFiles_AppliesIndividually()
    {
        // Arrange
        var blocks = new[]
        {
            new CodeBlock { TargetFilePath = "src/File1.cs", Content = "content1" },
            new CodeBlock { TargetFilePath = "src/File2.cs", Content = "content2" }
        };

        _fileSystemMock.Setup(f => f.FileExistsAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(false);
        _diffServiceMock.Setup(d => d.ComputeDiffForBlockAsync(
            It.IsAny<CodeBlock>(),
            _workspacePath,
            It.IsAny<CancellationToken>()))
            .ReturnsAsync((CodeBlock b, string w, CancellationToken c) => new DiffResult
            {
                OriginalFilePath = b.TargetFilePath!,
                ProposedContent = b.Content,
                IsNewFile = true
            });
        _fileSystemMock.Setup(f => f.WriteFileAsync(It.IsAny<string>(), It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .Returns(Task.CompletedTask);

        // Act
        var results = await _service.ApplyCodeBlocksAsync(blocks, _workspacePath);

        // Assert
        Assert.Equal(2, results.Count);
        _diffServiceMock.Verify(d => d.ComputeDiffForBlockAsync(
            It.IsAny<CodeBlock>(),
            _workspacePath,
            It.IsAny<CancellationToken>()), Times.Exactly(2));
    }

    #endregion

    #region Undo Tests

    [Fact]
    public async Task UndoLastChangeAsync_NoHistory_ReturnsFalse()
    {
        // Act
        var result = await _service.UndoLastChangeAsync("/nonexistent/file.cs");

        // Assert
        Assert.False(result);
    }

    [Fact]
    public async Task UndoLastChangeAsync_CreatedFile_DeletesFile()
    {
        // Arrange - First apply a new file
        var block = new CodeBlock
        {
            Id = Guid.NewGuid(),
            TargetFilePath = "src/Created.cs",
            Content = "content"
        };

        var diff = new DiffResult
        {
            OriginalFilePath = block.TargetFilePath,
            ProposedContent = block.Content,
            IsNewFile = true
        };

        _fileSystemMock.Setup(f => f.FileExistsAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(false);
        _diffServiceMock.Setup(d => d.ComputeDiffForBlockAsync(block, _workspacePath, It.IsAny<CancellationToken>()))
            .ReturnsAsync(diff);
        _fileSystemMock.Setup(f => f.WriteFileAsync(It.IsAny<string>(), It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .Returns(Task.CompletedTask);

        await _service.ApplyCodeBlockAsync(block, _workspacePath);

        var fullPath = Path.Combine(_workspacePath, block.TargetFilePath);

        // Create the actual file for undo to delete
        Directory.CreateDirectory(Path.GetDirectoryName(fullPath)!);
        await File.WriteAllTextAsync(fullPath, block.Content);

        // Act
        var result = await _service.UndoLastChangeAsync(fullPath);

        // Assert
        Assert.True(result);
        Assert.False(File.Exists(fullPath));
    }

    [Fact]
    public async Task UndoLastChangeAsync_ModifiedFile_RestoresFromBackup()
    {
        // This test requires actual file system for backup restore
        // Implementation would create temp files and verify restoration
    }

    [Fact]
    public void CanUndo_NoHistory_ReturnsFalse()
    {
        // Act
        var result = _service.CanUndo("/nonexistent/file.cs");

        // Assert
        Assert.False(result);
    }

    #endregion

    #region History Tests

    [Fact]
    public void GetChangeHistory_NoHistory_ReturnsEmpty()
    {
        // Act
        var history = _service.GetChangeHistory("/nonexistent/file.cs");

        // Assert
        Assert.Empty(history);
    }

    [Fact]
    public async Task GetChangeHistory_AfterApply_ReturnsRecord()
    {
        // Arrange
        var block = new CodeBlock
        {
            Id = Guid.NewGuid(),
            TargetFilePath = "src/Test.cs",
            Content = "content"
        };

        var diff = new DiffResult
        {
            OriginalFilePath = block.TargetFilePath,
            ProposedContent = block.Content,
            IsNewFile = true
        };

        _fileSystemMock.Setup(f => f.FileExistsAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(false);
        _diffServiceMock.Setup(d => d.ComputeDiffForBlockAsync(block, _workspacePath, It.IsAny<CancellationToken>()))
            .ReturnsAsync(diff);
        _fileSystemMock.Setup(f => f.WriteFileAsync(It.IsAny<string>(), It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .Returns(Task.CompletedTask);

        await _service.ApplyCodeBlockAsync(block, _workspacePath);

        var fullPath = Path.Combine(_workspacePath, block.TargetFilePath);

        // Act
        var history = _service.GetChangeHistory(fullPath);

        // Assert
        Assert.Single(history);
        Assert.Equal(block.Id, history[0].CodeBlockId);
        Assert.Equal(FileChangeType.Created, history[0].ChangeType);
    }

    [Fact]
    public void GetPendingUndos_NoChanges_ReturnsEmpty()
    {
        // Act
        var pending = _service.GetPendingUndos();

        // Assert
        Assert.Empty(pending);
    }

    #endregion

    #region Preview Tests

    [Fact]
    public async Task PreviewApplyAsync_NoTargetPath_ReturnsValidationFailed()
    {
        // Arrange
        var block = new CodeBlock { TargetFilePath = null };

        // Act
        var preview = await _service.PreviewApplyAsync(block, _workspacePath);

        // Assert
        Assert.False(preview.WouldSucceed);
        Assert.Equal(ApplyResultType.ValidationFailed, preview.ExpectedResultType);
    }

    [Fact]
    public async Task PreviewApplyAsync_NewFile_ReturnsWouldCreate()
    {
        // Arrange
        var block = new CodeBlock
        {
            TargetFilePath = "src/New.cs",
            Content = "content"
        };

        var diff = new DiffResult
        {
            OriginalFilePath = block.TargetFilePath,
            ProposedContent = block.Content,
            IsNewFile = true
        };

        _fileSystemMock.Setup(f => f.FileExistsAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(false);
        _diffServiceMock.Setup(d => d.ComputeDiffForBlockAsync(block, _workspacePath, It.IsAny<CancellationToken>()))
            .ReturnsAsync(diff);

        // Act
        var preview = await _service.PreviewApplyAsync(block, _workspacePath);

        // Assert
        Assert.True(preview.WouldSucceed);
        Assert.Equal(ApplyResultType.Created, preview.ExpectedResultType);
        Assert.False(preview.FileExists);
        Assert.False(preview.HasConflict);
    }

    #endregion

    #region Error Handling Tests

    [Fact]
    public async Task ApplyCodeBlockAsync_PermissionDenied_ReturnsError()
    {
        // Arrange
        var block = new CodeBlock
        {
            TargetFilePath = "src/Locked.cs",
            Content = "content"
        };

        var diff = new DiffResult
        {
            OriginalFilePath = block.TargetFilePath,
            ProposedContent = block.Content,
            IsNewFile = true
        };

        _fileSystemMock.Setup(f => f.FileExistsAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(false);
        _diffServiceMock.Setup(d => d.ComputeDiffForBlockAsync(block, _workspacePath, It.IsAny<CancellationToken>()))
            .ReturnsAsync(diff);
        _fileSystemMock.Setup(f => f.WriteFileAsync(It.IsAny<string>(), It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ThrowsAsync(new UnauthorizedAccessException("Access denied"));

        // Act
        var result = await _service.ApplyCodeBlockAsync(block, _workspacePath);

        // Assert
        Assert.False(result.Success);
        Assert.Equal(ApplyResultType.PermissionDenied, result.ResultType);
    }

    [Fact]
    public async Task ApplyCodeBlockAsync_RaisesChangeFailedEvent()
    {
        // Arrange
        var block = new CodeBlock
        {
            TargetFilePath = "src/Test.cs",
            Content = "content"
        };

        var diff = new DiffResult
        {
            OriginalFilePath = block.TargetFilePath,
            ProposedContent = block.Content,
            IsNewFile = true
        };

        _fileSystemMock.Setup(f => f.FileExistsAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(false);
        _diffServiceMock.Setup(d => d.ComputeDiffForBlockAsync(block, _workspacePath, It.IsAny<CancellationToken>()))
            .ReturnsAsync(diff);
        _fileSystemMock.Setup(f => f.WriteFileAsync(It.IsAny<string>(), It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ThrowsAsync(new IOException("Disk error"));

        FileChangeFailedEventArgs? eventArgs = null;
        _service.ChangeFailed += (s, e) => eventArgs = e;

        // Act
        await _service.ApplyCodeBlockAsync(block, _workspacePath);

        // Assert
        Assert.NotNull(eventArgs);
        Assert.NotNull(eventArgs.Exception);
    }

    #endregion

    #region Thread Safety Tests

    [Fact]
    public async Task ApplyCodeBlockAsync_ConcurrentCalls_SerializesOperations()
    {
        // Arrange
        var blocks = Enumerable.Range(1, 10).Select(i => new CodeBlock
        {
            Id = Guid.NewGuid(),
            TargetFilePath = $"src/File{i}.cs",
            Content = $"content{i}"
        }).ToList();

        var callOrder = new List<int>();
        var callLock = new object();

        _fileSystemMock.Setup(f => f.FileExistsAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(false);
        _diffServiceMock.Setup(d => d.ComputeDiffForBlockAsync(
            It.IsAny<CodeBlock>(),
            _workspacePath,
            It.IsAny<CancellationToken>()))
            .ReturnsAsync((CodeBlock b, string w, CancellationToken c) => new DiffResult
            {
                OriginalFilePath = b.TargetFilePath!,
                ProposedContent = b.Content,
                IsNewFile = true
            });
        _fileSystemMock.Setup(f => f.WriteFileAsync(It.IsAny<string>(), It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .Returns(async (string p, string c, CancellationToken ct) =>
            {
                var index = int.Parse(Path.GetFileNameWithoutExtension(p).Replace("File", ""));
                lock (callLock)
                {
                    callOrder.Add(index);
                }
                await Task.Delay(10, ct); // Simulate I/O
            });

        // Act - Start all applies concurrently
        var tasks = blocks.Select(b => _service.ApplyCodeBlockAsync(b, _workspacePath));
        await Task.WhenAll(tasks);

        // Assert - All operations should complete
        Assert.Equal(10, callOrder.Count);
        // Due to semaphore, operations are serialized (exact order may vary)
    }

    #endregion
}
```

### Integration Tests

```csharp
// tests/SeniorIntern.Services.Tests/FileChangeServiceIntegrationTests.cs
namespace SeniorIntern.Services.Tests;

/// <summary>
/// Integration tests using real file system.
/// </summary>
public class FileChangeServiceIntegrationTests : IDisposable
{
    private readonly string _workspacePath;
    private readonly FileChangeService _service;

    public FileChangeServiceIntegrationTests()
    {
        _workspacePath = Path.Combine(Path.GetTempPath(), $"FCSIntegration_{Guid.NewGuid()}");
        Directory.CreateDirectory(_workspacePath);

        var fileSystem = new FileSystemService();
        var diffService = new DiffService(); // Assume implementation exists
        var backupService = new BackupService();

        _service = new FileChangeService(fileSystem, diffService, backupService);
    }

    public void Dispose()
    {
        _service.Dispose();
        if (Directory.Exists(_workspacePath))
        {
            Directory.Delete(_workspacePath, recursive: true);
        }
    }

    [Fact]
    public async Task FullWorkflow_CreateModifyUndo()
    {
        // 1. Create a new file
        var createBlock = new CodeBlock
        {
            Id = Guid.NewGuid(),
            TargetFilePath = "test/Example.cs",
            Content = "public class Example { }"
        };

        var createResult = await _service.ApplyCodeBlockAsync(createBlock, _workspacePath);
        Assert.True(createResult.Success);
        Assert.Equal(ApplyResultType.Created, createResult.ResultType);

        var filePath = Path.Combine(_workspacePath, createBlock.TargetFilePath);
        Assert.True(File.Exists(filePath));
        Assert.Equal(createBlock.Content, await File.ReadAllTextAsync(filePath));

        // 2. Modify the file
        var modifyBlock = new CodeBlock
        {
            Id = Guid.NewGuid(),
            TargetFilePath = "test/Example.cs",
            Content = "public class Example { public int Id { get; set; } }"
        };

        var modifyResult = await _service.ApplyCodeBlockAsync(modifyBlock, _workspacePath);
        Assert.True(modifyResult.Success);
        Assert.Equal(ApplyResultType.Modified, modifyResult.ResultType);
        Assert.NotNull(modifyResult.BackupPath);

        Assert.Equal(modifyBlock.Content, await File.ReadAllTextAsync(filePath));

        // 3. Undo the modification
        var undone = await _service.UndoLastChangeAsync(filePath);
        Assert.True(undone);

        // Content should be restored to original
        Assert.Equal(createBlock.Content, await File.ReadAllTextAsync(filePath));
    }

    [Fact]
    public async Task LineEndingPreservation_CrLfFile()
    {
        // Create file with CRLF line endings
        var filePath = Path.Combine(_workspacePath, "crlf.cs");
        Directory.CreateDirectory(Path.GetDirectoryName(filePath)!);
        await File.WriteAllTextAsync(filePath, "line1\r\nline2\r\nline3\r\n");

        var block = new CodeBlock
        {
            TargetFilePath = "crlf.cs",
            Content = "newline1\nnewline2\nnewline3\n" // LF only
        };

        var options = ApplyOptions.Default with { PreserveLineEndings = true };
        await _service.ApplyCodeBlockAsync(block, _workspacePath, options);

        var content = await File.ReadAllTextAsync(filePath);
        Assert.Contains("\r\n", content); // Should be converted to CRLF
        Assert.DoesNotContain("\n\n", content.Replace("\r\n", "")); // No double newlines
    }
}
```

---

## Acceptance Criteria

### Functional Requirements

- [ ] `ApplyCodeBlockAsync` creates new files when target doesn't exist
- [ ] `ApplyCodeBlockAsync` modifies existing files with backup creation
- [ ] `ApplyCodeBlockAsync` validates inputs and returns appropriate errors
- [ ] `ApplyCodeBlocksAsync` handles multiple blocks for different files
- [ ] `ApplyCodeBlocksAsync` merges multiple blocks targeting same file
- [ ] `ApplyDiffAsync` applies pre-computed diffs correctly
- [ ] `PreviewApplyAsync` returns preview without making changes
- [ ] Conflict detection identifies recently modified files
- [ ] Conflict detection uses hash comparison for tracked files
- [ ] `UndoLastChangeAsync` restores from backup for modifications
- [ ] `UndoLastChangeAsync` deletes file for created files
- [ ] `UndoChangeAsync` finds and undos specific change by ID
- [ ] `CanUndo` correctly reports undo availability
- [ ] Undo window expiration is enforced
- [ ] `GetChangeHistory` returns records in correct order
- [ ] `GetPendingUndos` returns all undoable changes

### Event Requirements

- [ ] `FileChanged` raised on successful apply
- [ ] `ChangeFailed` raised on apply failure
- [ ] `ChangeUndone` raised on successful undo
- [ ] `ConflictDetected` raised when conflict found

### Error Handling Requirements

- [ ] `UnauthorizedAccessException` → `PermissionDenied` result
- [ ] `IOException` (file locked) → `FileLocked` result
- [ ] `IOException` (disk full) → `DiskFull` result
- [ ] Generic exceptions → `Error` result with message
- [ ] All errors logged appropriately
- [ ] No unhandled exceptions escape service methods

### Thread Safety Requirements

- [ ] Concurrent apply calls are serialized via semaphore
- [ ] Change history is thread-safe via `ConcurrentDictionary`
- [ ] Stack mutations protected by lock
- [ ] No race conditions in undo operations

### Configuration Requirements

- [ ] `CreateBackup` option controls backup creation
- [ ] `AllowConflictOverwrite` option controls conflict behavior
- [ ] `PreserveLineEndings` option controls line ending normalization
- [ ] `CreateParentDirectories` option controls directory creation
- [ ] Default options work correctly

### Performance Requirements

- [ ] Single file apply completes in < 100ms (excluding I/O)
- [ ] History limited to prevent memory growth
- [ ] Old backups cleaned up automatically

---

## Design Decisions

### Decision 1: Semaphore vs Lock for Apply Operations

**Choice**: `SemaphoreSlim` with async wait

**Rationale**:
- Allows async/await pattern throughout the apply pipeline
- Prevents thread pool starvation during high concurrency
- Single-permit semaphore ensures serialized operations
- Regular `lock` doesn't support async operations

**Alternatives Considered**:
- `lock` statement: Doesn't support async, would require sync-over-async
- `AsyncLock` from external library: Adds dependency
- Per-file locks: Complex to manage, potential deadlocks

### Decision 2: History Storage Structure

**Choice**: `ConcurrentDictionary<string, Stack<FileChangeRecord>>`

**Rationale**:
- Thread-safe dictionary for file path keys
- Stack provides natural LIFO ordering for undo
- Inner stack protected by separate lock for mutations
- Efficient O(1) lookup by file path

**Alternatives Considered**:
- Single list with all records: Slower per-file queries
- Immutable collections: More allocation on updates
- Database/persistence: Overkill for in-memory undo

### Decision 3: Conflict Detection Strategy

**Choice**: Time-based + hash-based hybrid

**Rationale**:
- Time-based catches concurrent edits (within 5 seconds)
- Hash-based catches content changes since last apply
- Combines best of both approaches
- Simple to implement and understand

**Alternatives Considered**:
- File watcher: Complex, platform-specific issues
- Git integration: Adds dependency, not all projects use git
- Timestamp only: Can miss fast sequential edits

### Decision 4: Line Ending Preservation

**Choice**: Detect from original file and normalize new content

**Rationale**:
- Respects project conventions (Windows vs Unix)
- Prevents unnecessary diffs in version control
- Simple detection from first occurrence
- Handles CR, LF, and CRLF

**Alternatives Considered**:
- Always use system default: May cause unwanted changes
- EditorConfig integration: Adds complexity
- No normalization: May cause issues in mixed environments

### Decision 5: Error Type Classification

**Choice**: Specific `ApplyResultType` enum values for common errors

**Rationale**:
- `PermissionDenied`, `FileLocked`, `DiskFull` are actionable
- UI can show appropriate messages/actions
- HResult checking works cross-platform (mostly)
- Generic `Error` catches unexpected failures

**Alternatives Considered**:
- Just success/failure: Not enough information for UI
- Exception types only: Lost after catching
- Error codes: Less readable than enum

### Decision 6: Undo for Created Files

**Choice**: Delete the file on undo (no backup needed)

**Rationale**:
- Created files didn't exist before, so "undo" means remove
- No backup storage needed for creates
- Simple and intuitive behavior
- Matches user expectations

**Alternatives Considered**:
- Keep file in "created but undone" state: Confusing
- Move to trash: Platform-specific complexity
- No undo for creates: Limits functionality

---

## Dependencies

### Required Services

| Service | Interface | Purpose |
|---------|-----------|---------|
| File System | `IFileSystemService` | File I/O operations |
| Diff | `IDiffService` | Compute diffs for code blocks |
| Backup | `IBackupService` | Create and restore backups |
| Logger | `ILogger<FileChangeService>` | Diagnostic logging (optional) |

### NuGet Packages

| Package | Version | Purpose |
|---------|---------|---------|
| `Microsoft.Extensions.Logging.Abstractions` | 8.0+ | ILogger interface |
| `System.Collections.Concurrent` | (built-in) | ConcurrentDictionary |

---

## Future Considerations

1. **Batch undo**: Undo multiple changes in a single operation
2. **Redo support**: Re-apply undone changes
3. **Persistent history**: Save history across sessions
4. **Conflict resolution UI**: Interactive merge for conflicts
5. **File watcher integration**: Auto-detect external changes
6. **Progress reporting**: IProgress<T> for large operations
7. **Partial application**: Apply specific hunks from a diff
