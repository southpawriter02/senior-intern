# v0.4.4c: Proposal Service - Design Specification

**Status**: _IMPLEMENTED_

## Executive Summary

This specification details the **Proposal Service** for The Senior Intern's Multi-File Creation system. The service is responsible for validating file tree proposals against the workspace state, applying batch file operations with progress tracking, generating diff previews, managing backups, and supporting undo/rollback functionality. This component orchestrates the entire apply workflow from validation through completion.

### Key Deliverables

| Component | Type | Purpose |
|-----------|------|---------|
| `IFileTreeProposalService` | Interface | Contract for proposal operations |
| `FileTreeProposalService` | Class | Implementation of proposal handling |
| `ProposalServiceOptions` | Record | Configuration for service behavior |
| `ApplyContext` | Class | State tracking during batch apply |
| `RollbackManager` | Class | Manages rollback on failure |

---

## Feature Overview

```
v0.4.4c: Proposal Service
├── IFileTreeProposalService Interface
│   ├── ValidateProposalAsync
│   │   ├── Check duplicate paths
│   │   ├── Check invalid paths
│   │   ├── Check workspace boundaries
│   │   ├── Check path length limits
│   │   ├── Check file existence (warnings)
│   │   ├── Check empty content (warnings)
│   │   └── Check write permissions
│   ├── ApplyProposalAsync
│   │   ├── Phase: Validation
│   │   ├── Phase: Creating Directories
│   │   ├── Phase: Creating Backups
│   │   ├── Phase: Writing Files
│   │   ├── Phase: Finalizing
│   │   ├── Progress Reporting
│   │   └── Cancellation Support
│   ├── PreviewProposalAsync
│   │   ├── Generate DiffResults
│   │   ├── Handle new files
│   │   └── Handle modifications
│   ├── UndoBatchApplyAsync
│   │   ├── Reverse order undo
│   │   └── Restore from backups
│   ├── CheckExistingFilesAsync
│   │   └── Map paths to existence
│   └── Events
│       └── ProgressChanged
├── FileTreeProposalService Implementation
│   ├── Dependencies
│   │   ├── IFileSystemService
│   │   ├── IFileChangeService (v0.4.3)
│   │   ├── IDiffService (v0.4.2)
│   │   ├── IBackupService (v0.4.3)
│   │   └── ILogger
│   ├── Validation Logic
│   │   ├── ValidateOperationAsync
│   │   ├── IsValidPath
│   │   ├── IsWithinWorkspace
│   │   └── CheckPermissions
│   ├── Apply Logic
│   │   ├── ApplyOperationAsync
│   │   ├── WriteFileAsync
│   │   ├── DeleteFileAsync
│   │   ├── RenameFileAsync
│   │   └── MoveFileAsync
│   └── Helper Methods
│       ├── ReportProgress
│       ├── CreateDirectoriesAsync
│       └── CreateBackupsAsync
├── ApplyContext
│   ├── StartedAt
│   ├── Results collection
│   ├── BackupPaths collection
│   ├── CreatedDirectories
│   ├── CancellationToken
│   └── RollbackManager reference
├── RollbackManager
│   ├── RegisterCreatedFile
│   ├── RegisterModifiedFile
│   ├── RegisterCreatedDirectory
│   ├── RollbackAsync
│   └── Commit (clear tracking)
└── ProposalServiceOptions
    ├── EnableBackups (default: true)
    ├── EnableRollback (default: true)
    ├── MaxParallelOperations (default: 4)
    ├── PathLengthLimit (default: 260)
    └── ValidateBeforeApply (default: true)
```

---

## Architecture Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          FileTreeProposalService                             │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │                         ValidateProposalAsync                          │  │
│  │                                                                       │  │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐                │  │
│  │  │ Check Paths  │  │ Check Files  │  │  Check Perms │                │  │
│  │  │  • Duplicates│  │  • Existence │  │  • Write     │                │  │
│  │  │  • Invalid   │  │  • Content   │  │  • Create    │                │  │
│  │  │  • Outside   │  │  • Length    │  │              │                │  │
│  │  └──────────────┘  └──────────────┘  └──────────────┘                │  │
│  │                           │                                           │  │
│  │                           ▼                                           │  │
│  │               ┌─────────────────────┐                                │  │
│  │               │ProposalValidation   │                                │  │
│  │               │    Result           │                                │  │
│  │               └─────────────────────┘                                │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │                          ApplyProposalAsync                            │  │
│  │                                                                       │  │
│  │  ┌─────────────────────────────────────────────────────────────────┐ │  │
│  │  │                        ApplyContext                              │ │  │
│  │  │  ┌───────────┐ ┌────────────┐ ┌─────────────┐ ┌──────────────┐  │ │  │
│  │  │  │ Results   │ │BackupPaths │ │ CreatedDirs │ │RollbackMgr   │  │ │  │
│  │  │  └───────────┘ └────────────┘ └─────────────┘ └──────────────┘  │ │  │
│  │  └─────────────────────────────────────────────────────────────────┘ │  │
│  │                                                                       │  │
│  │  Phase 1           Phase 2              Phase 3           Phase 4    │  │
│  │  ┌──────────┐      ┌──────────┐         ┌──────────┐     ┌────────┐  │  │
│  │  │Validation│──────│Create    │─────────│Create    │─────│Write   │  │  │
│  │  │          │      │  Dirs    │         │ Backups  │     │ Files  │  │  │
│  │  └──────────┘      └──────────┘         └──────────┘     └────────┘  │  │
│  │                                                               │      │  │
│  │                                                               ▼      │  │
│  │  Phase 5                                                             │  │
│  │  ┌──────────┐      ┌─────────────────────────────────────────────┐   │  │
│  │  │Finalize  │◀─────│              BatchApplyResult               │   │  │
│  │  └──────────┘      └─────────────────────────────────────────────┘   │  │
│  │                                                                       │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
│  ┌────────────────────┐  ┌────────────────────┐  ┌─────────────────────┐   │
│  │ PreviewProposalAsync│  │UndoBatchApplyAsync │  │CheckExistingFiles   │   │
│  │                    │  │                    │  │       Async         │   │
│  │ • Generate diffs   │  │ • Reverse order    │  │                     │   │
│  │ • New file diffs   │  │ • Restore backups  │  │ • Map path→exists   │   │
│  │ • Modification     │  │ • Delete created   │  │                     │   │
│  │   diffs            │  │                    │  │                     │   │
│  └────────────────────┘  └────────────────────┘  └─────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
            ┌───────────────────────┼───────────────────────┐
            ▼                       ▼                       ▼
  ┌──────────────────┐   ┌──────────────────┐   ┌──────────────────┐
  │IFileSystemService│   │ IBackupService   │   │IFileChangeService│
  │                  │   │   (v0.4.3)       │   │    (v0.4.3)      │
  │ • ReadFileAsync  │   │                  │   │                  │
  │ • WriteFileAsync │   │ • CreateBackup   │   │ • ApplyChange    │
  │ • FileExistsAsync│   │ • RestoreBackup  │   │ • UndoChange     │
  │ • DeleteFileAsync│   │                  │   │                  │
  └──────────────────┘   └──────────────────┘   └──────────────────┘
```

---

## Apply Phase Flow Diagram

```
                            ApplyProposalAsync
                                   │
                                   ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                         Phase 1: VALIDATION                                  │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  ValidateProposalAsync(proposal, workspacePath)                      │   │
│  │                                                                      │   │
│  │  For each operation:                                                 │   │
│  │  ├── Check path validity (invalid chars, format)                     │   │
│  │  ├── Check workspace boundaries (escape attempts)                    │   │
│  │  ├── Check path length (< 260 chars)                                 │   │
│  │  ├── Check file existence (warning for creates)                      │   │
│  │  └── Check content (warning if empty)                                │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                   │                                         │
│               ┌───────────────────┴───────────────────┐                     │
│               ▼                                       ▼                     │
│        ┌─────────────┐                        ┌─────────────┐               │
│        │ Has Errors  │                        │   Valid     │               │
│        │ (blocking)  │                        │ (proceed)   │               │
│        └──────┬──────┘                        └──────┬──────┘               │
│               │                                      │                      │
│               ▼                                      │                      │
│    Mark operations failed                            │                      │
│    Continue with valid ops                           │                      │
└──────────────────────────────────────────────────────┼──────────────────────┘
                                                       │
                                                       ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                     Phase 2: CREATE DIRECTORIES                              │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  Extract unique directories from Create operations                   │   │
│  │  Sort by path length (shortest first = parents first)               │   │
│  │                                                                      │   │
│  │  For each directory:                                                 │   │
│  │  ├── Check if exists                                                 │   │
│  │  ├── Create if missing                                               │   │
│  │  └── Register with RollbackManager                                   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  Progress: "Creating directories..."                                        │
└─────────────────────────────────────────────────────────────────────────────┘
                                   │
                                   ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                       Phase 3: CREATE BACKUPS                                │
│                         (if options.CreateBackup)                            │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  For each Modify operation with existing file:                       │   │
│  │  ├── Create backup via IBackupService                                │   │
│  │  └── Store backup path for rollback                                  │   │
│  │                                                                      │   │
│  │  For each Create operation with existing file (overwrite):           │   │
│  │  ├── Create backup via IBackupService                                │   │
│  │  └── Store backup path for rollback                                  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  Progress: "Creating backups..."                                            │
└─────────────────────────────────────────────────────────────────────────────┘
                                   │
                                   ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                        Phase 4: WRITE FILES                                  │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  For each selected operation (ordered by op.Order):                  │   │
│  │                                                                      │   │
│  │  1. Check cancellation token                                         │   │
│  │  2. Report progress (current file, phase, %)                         │   │
│  │  3. Set operation status = InProgress                                │   │
│  │  4. Apply operation:                                                 │   │
│  │     ├── Create/Modify → WriteFileAsync                               │   │
│  │     ├── Delete → DeleteFileAsync                                     │   │
│  │     ├── Rename → RenameFileAsync                                     │   │
│  │     └── Move → MoveFileAsync                                         │   │
│  │  5. Record result                                                    │   │
│  │  6. Update operation status (Applied/Failed)                         │   │
│  │  7. Register with RollbackManager                                    │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                   │                                         │
│               ┌───────────────────┼───────────────────┐                     │
│               ▼                   ▼                   ▼                     │
│        ┌─────────────┐    ┌─────────────┐    ┌─────────────┐                │
│        │  Success    │    │  Failure    │    │ Cancelled   │                │
│        │  (continue) │    │  (handle)   │    │ (rollback)  │                │
│        └─────────────┘    └──────┬──────┘    └──────┬──────┘                │
│                                  │                  │                       │
│                                  ▼                  ▼                       │
│                          Log error,          RollbackManager                │
│                          continue or         .RollbackAsync()               │
│                          rollback                                           │
└─────────────────────────────────────────────────────────────────────────────┘
                                   │
                                   ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                         Phase 5: FINALIZE                                    │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  1. Calculate success/failure counts                                 │   │
│  │  2. Update proposal status:                                          │   │
│  │     ├── All succeeded → FullyApplied                                 │   │
│  │     ├── Some succeeded → PartiallyApplied                            │   │
│  │     └── None succeeded → Pending (unchanged)                         │   │
│  │  3. Commit RollbackManager (clear tracking)                          │   │
│  │  4. Build BatchApplyResult                                           │   │
│  │  5. Report completion progress                                       │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  Progress: Phase = Completed, "Complete"                                    │
└─────────────────────────────────────────────────────────────────────────────┘
                                   │
                                   ▼
                        ┌─────────────────────┐
                        │  BatchApplyResult   │
                        │                     │
                        │  • AllSucceeded     │
                        │  • SuccessCount     │
                        │  • FailedCount      │
                        │  • Results[]        │
                        │  • BackupPaths[]    │
                        │  • Duration         │
                        └─────────────────────┘
```

---

## Rollback Flow Diagram

```
                         Rollback Triggered
                    (Cancellation or Critical Failure)
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                           RollbackManager                                    │
│                                                                             │
│  Tracked Operations (in order applied):                                     │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 1. CreatedDirectory: "src/Models"                                    │   │
│  │ 2. CreatedDirectory: "src/Services"                                  │   │
│  │ 3. CreatedFile: "src/Models/User.cs" (new)                           │   │
│  │ 4. ModifiedFile: "src/Program.cs" (backup: ".backup/...")            │   │
│  │ 5. CreatedFile: "src/Services/UserService.cs" (new)                  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│                           RollbackAsync()                                   │
│                                 │                                           │
│                                 ▼                                           │
│  Process in REVERSE order:                                                  │
│                                                                             │
│  ┌──────────────────────────────────────────────────────────────────────┐  │
│  │ 5. CreatedFile "src/Services/UserService.cs"                          │  │
│  │    Action: Delete file                                                │  │
│  │    Result: ✓ File deleted                                             │  │
│  ├──────────────────────────────────────────────────────────────────────┤  │
│  │ 4. ModifiedFile "src/Program.cs"                                      │  │
│  │    Action: Restore from backup                                        │  │
│  │    Result: ✓ Original content restored                                │  │
│  ├──────────────────────────────────────────────────────────────────────┤  │
│  │ 3. CreatedFile "src/Models/User.cs"                                   │  │
│  │    Action: Delete file                                                │  │
│  │    Result: ✓ File deleted                                             │  │
│  ├──────────────────────────────────────────────────────────────────────┤  │
│  │ 2. CreatedDirectory "src/Services"                                    │  │
│  │    Check: Is directory empty?                                         │  │
│  │    Action: Delete if empty                                            │  │
│  │    Result: ✓ Directory deleted (was empty)                            │  │
│  ├──────────────────────────────────────────────────────────────────────┤  │
│  │ 1. CreatedDirectory "src/Models"                                      │  │
│  │    Check: Is directory empty?                                         │  │
│  │    Action: Delete if empty                                            │  │
│  │    Result: ✓ Directory deleted (was empty)                            │  │
│  └──────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
│                                 │                                           │
│                                 ▼                                           │
│  Rollback Complete                                                          │
│  • All created files deleted                                                │
│  • All modified files restored                                              │
│  • Empty created directories removed                                        │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Detailed Design

### 1. IFileTreeProposalService Interface

```csharp
// src/SeniorIntern.Core/Interfaces/IFileTreeProposalService.cs
namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Service for validating and applying multi-file proposals.
/// </summary>
/// <remarks>
/// Coordinates the entire apply workflow including validation,
/// backup creation, file operations, and rollback on failure.
/// </remarks>
public interface IFileTreeProposalService
{
    #region Validation

    /// <summary>
    /// Validate a proposal against the current workspace state.
    /// </summary>
    /// <param name="proposal">The proposal to validate.</param>
    /// <param name="workspacePath">Absolute path to the workspace root.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>Validation result with any errors and warnings.</returns>
    /// <remarks>
    /// Validation checks include:
    /// - Duplicate paths within the proposal
    /// - Invalid path characters or format
    /// - Paths outside workspace boundaries
    /// - Path length limits (OS-specific)
    /// - File existence (warnings for creates)
    /// - Empty content (warnings)
    /// - Write permissions
    /// </remarks>
    Task<ProposalValidationResult> ValidateProposalAsync(
        FileTreeProposal proposal,
        string workspacePath,
        CancellationToken ct = default);

    /// <summary>
    /// Validate a single operation.
    /// </summary>
    /// <param name="operation">The operation to validate.</param>
    /// <param name="workspacePath">Absolute path to the workspace root.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>List of validation issues for this operation.</returns>
    Task<IReadOnlyList<ValidationIssue>> ValidateOperationAsync(
        FileOperation operation,
        string workspacePath,
        CancellationToken ct = default);

    #endregion

    #region Apply

    /// <summary>
    /// Apply selected operations from a proposal.
    /// </summary>
    /// <param name="proposal">The proposal to apply.</param>
    /// <param name="workspacePath">Absolute path to the workspace root.</param>
    /// <param name="options">Apply options (backup, etc.).</param>
    /// <param name="progress">Progress reporter.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>Result of the batch apply operation.</returns>
    /// <remarks>
    /// The apply process follows these phases:
    /// 1. Validation - Check all operations
    /// 2. Create directories - Ensure parent directories exist
    /// 3. Create backups - Backup existing files (if configured)
    /// 4. Write files - Apply each operation in order
    /// 5. Finalize - Update statuses and build result
    ///
    /// Cancellation triggers rollback of completed operations.
    /// </remarks>
    Task<BatchApplyResult> ApplyProposalAsync(
        FileTreeProposal proposal,
        string workspacePath,
        ApplyOptions? options = null,
        IProgress<BatchApplyProgress>? progress = null,
        CancellationToken ct = default);

    /// <summary>
    /// Apply a single operation.
    /// </summary>
    /// <param name="operation">The operation to apply.</param>
    /// <param name="workspacePath">Absolute path to the workspace root.</param>
    /// <param name="options">Apply options.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>Result of the operation.</returns>
    Task<ApplyResult> ApplyOperationAsync(
        FileOperation operation,
        string workspacePath,
        ApplyOptions? options = null,
        CancellationToken ct = default);

    #endregion

    #region Preview

    /// <summary>
    /// Preview what changes will be made by a proposal.
    /// </summary>
    /// <param name="proposal">The proposal to preview.</param>
    /// <param name="workspacePath">Absolute path to the workspace root.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>List of diff results for each operation.</returns>
    /// <remarks>
    /// Generates diffs for Create and Modify operations.
    /// New files show full content as additions.
    /// Modifications show line-by-line differences.
    /// </remarks>
    Task<IReadOnlyList<DiffResult>> PreviewProposalAsync(
        FileTreeProposal proposal,
        string workspacePath,
        CancellationToken ct = default);

    /// <summary>
    /// Preview a single operation.
    /// </summary>
    /// <param name="operation">The operation to preview.</param>
    /// <param name="workspacePath">Absolute path to the workspace root.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>Diff result for the operation.</returns>
    Task<DiffResult?> PreviewOperationAsync(
        FileOperation operation,
        string workspacePath,
        CancellationToken ct = default);

    #endregion

    #region Undo

    /// <summary>
    /// Undo all changes from a batch apply.
    /// </summary>
    /// <param name="result">The batch apply result to undo.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>True if all operations were undone successfully.</returns>
    /// <remarks>
    /// Undoes operations in reverse order.
    /// Uses backups to restore modified files.
    /// Deletes newly created files.
    /// </remarks>
    Task<bool> UndoBatchApplyAsync(
        BatchApplyResult result,
        CancellationToken ct = default);

    /// <summary>
    /// Undo a single apply result.
    /// </summary>
    /// <param name="result">The apply result to undo.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>True if the operation was undone successfully.</returns>
    Task<bool> UndoApplyResultAsync(
        ApplyResult result,
        CancellationToken ct = default);

    #endregion

    #region Utility

    /// <summary>
    /// Check which files in a proposal already exist.
    /// </summary>
    /// <param name="proposal">The proposal to check.</param>
    /// <param name="workspacePath">Absolute path to the workspace root.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>Dictionary mapping relative paths to existence.</returns>
    Task<IReadOnlyDictionary<string, bool>> CheckExistingFilesAsync(
        FileTreeProposal proposal,
        string workspacePath,
        CancellationToken ct = default);

    /// <summary>
    /// Check if a path is within the workspace boundaries.
    /// </summary>
    /// <param name="path">The path to check (relative or absolute).</param>
    /// <param name="workspacePath">Absolute path to the workspace root.</param>
    /// <returns>True if the path is within the workspace.</returns>
    bool IsWithinWorkspace(string path, string workspacePath);

    /// <summary>
    /// Estimate the time required to apply a proposal.
    /// </summary>
    /// <param name="proposal">The proposal to estimate.</param>
    /// <returns>Estimated time span.</returns>
    TimeSpan EstimateApplyTime(FileTreeProposal proposal);

    #endregion

    #region Events

    /// <summary>
    /// Event raised when batch apply progress updates.
    /// </summary>
    event EventHandler<BatchApplyProgress>? ProgressChanged;

    /// <summary>
    /// Event raised when an individual operation completes.
    /// </summary>
    event EventHandler<OperationCompletedEventArgs>? OperationCompleted;

    /// <summary>
    /// Event raised when validation completes.
    /// </summary>
    event EventHandler<ProposalValidationResult>? ValidationCompleted;

    #endregion
}

/// <summary>
/// Event args for operation completion.
/// </summary>
public sealed class OperationCompletedEventArgs : EventArgs
{
    /// <summary>
    /// The operation that completed.
    /// </summary>
    public FileOperation Operation { get; init; } = null!;

    /// <summary>
    /// The result of the operation.
    /// </summary>
    public ApplyResult Result { get; init; } = null!;

    /// <summary>
    /// Index of this operation in the batch.
    /// </summary>
    public int OperationIndex { get; init; }

    /// <summary>
    /// Total operations in the batch.
    /// </summary>
    public int TotalOperations { get; init; }
}
```

### 2. ProposalServiceOptions

```csharp
// src/SeniorIntern.Core/Models/ProposalServiceOptions.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Configuration options for the proposal service.
/// </summary>
public sealed record ProposalServiceOptions
{
    /// <summary>
    /// Whether to create backups before modifying files.
    /// </summary>
    public bool EnableBackups { get; init; } = true;

    /// <summary>
    /// Whether to enable automatic rollback on failure.
    /// </summary>
    public bool EnableRollback { get; init; } = true;

    /// <summary>
    /// Whether to rollback on partial failure (some ops fail).
    /// If false, partial success is allowed.
    /// </summary>
    public bool RollbackOnPartialFailure { get; init; } = false;

    /// <summary>
    /// Maximum number of parallel file operations.
    /// </summary>
    /// <remarks>
    /// Set to 1 for strictly sequential operations.
    /// Higher values may improve performance for many small files.
    /// </remarks>
    public int MaxParallelOperations { get; init; } = 1;

    /// <summary>
    /// Maximum path length (characters).
    /// </summary>
    public int PathLengthLimit { get; init; } = 260;

    /// <summary>
    /// Whether to validate before applying.
    /// </summary>
    public bool ValidateBeforeApply { get; init; } = true;

    /// <summary>
    /// Whether to continue applying after individual failures.
    /// </summary>
    public bool ContinueOnFailure { get; init; } = true;

    /// <summary>
    /// Whether to create parent directories automatically.
    /// </summary>
    public bool CreateParentDirectories { get; init; } = true;

    /// <summary>
    /// Whether to preserve file timestamps on modify.
    /// </summary>
    public bool PreserveTimestamps { get; init; } = false;

    /// <summary>
    /// File encoding to use for writing.
    /// </summary>
    public string FileEncoding { get; init; } = "utf-8";

    /// <summary>
    /// Whether to use BOM for UTF-8 files.
    /// </summary>
    public bool UseUtf8Bom { get; init; } = false;

    /// <summary>
    /// Progress update interval during batch operations.
    /// </summary>
    public TimeSpan ProgressUpdateInterval { get; init; } = TimeSpan.FromMilliseconds(100);

    /// <summary>
    /// Default options.
    /// </summary>
    public static ProposalServiceOptions Default { get; } = new();

    /// <summary>
    /// Safe options with rollback and validation.
    /// </summary>
    public static ProposalServiceOptions Safe { get; } = new()
    {
        EnableBackups = true,
        EnableRollback = true,
        ValidateBeforeApply = true,
        ContinueOnFailure = false,
        RollbackOnPartialFailure = true
    };

    /// <summary>
    /// Fast options for trusted operations.
    /// </summary>
    public static ProposalServiceOptions Fast { get; } = new()
    {
        EnableBackups = false,
        EnableRollback = false,
        ValidateBeforeApply = false,
        MaxParallelOperations = 4
    };
}
```

### 3. ApplyContext

```csharp
// src/SeniorIntern.Services/ApplyContext.cs
namespace SeniorIntern.Services;

/// <summary>
/// Context for tracking state during a batch apply operation.
/// </summary>
internal sealed class ApplyContext : IDisposable
{
    /// <summary>
    /// When the apply operation started.
    /// </summary>
    public DateTime StartedAt { get; } = DateTime.UtcNow;

    /// <summary>
    /// Results of individual operations.
    /// </summary>
    public List<ApplyResult> Results { get; } = new();

    /// <summary>
    /// Paths to backup files created.
    /// </summary>
    public List<string> BackupPaths { get; } = new();

    /// <summary>
    /// Directories created during this operation.
    /// </summary>
    public HashSet<string> CreatedDirectories { get; } = new(StringComparer.OrdinalIgnoreCase);

    /// <summary>
    /// Files created during this operation.
    /// </summary>
    public HashSet<string> CreatedFiles { get; } = new(StringComparer.OrdinalIgnoreCase);

    /// <summary>
    /// Files modified during this operation (with backup paths).
    /// </summary>
    public Dictionary<string, string> ModifiedFiles { get; } = new(StringComparer.OrdinalIgnoreCase);

    /// <summary>
    /// The cancellation token for this operation.
    /// </summary>
    public CancellationToken CancellationToken { get; init; }

    /// <summary>
    /// The rollback manager for this operation.
    /// </summary>
    public RollbackManager RollbackManager { get; }

    /// <summary>
    /// The proposal being applied.
    /// </summary>
    public FileTreeProposal Proposal { get; init; } = null!;

    /// <summary>
    /// The workspace path.
    /// </summary>
    public string WorkspacePath { get; init; } = string.Empty;

    /// <summary>
    /// The apply options.
    /// </summary>
    public ApplyOptions Options { get; init; } = ApplyOptions.Default;

    /// <summary>
    /// Progress reporter.
    /// </summary>
    public IProgress<BatchApplyProgress>? Progress { get; init; }

    /// <summary>
    /// Current phase of the operation.
    /// </summary>
    public BatchApplyPhase CurrentPhase { get; set; }

    /// <summary>
    /// Number of completed operations.
    /// </summary>
    public int CompletedOperations { get; set; }

    /// <summary>
    /// Total operations to apply.
    /// </summary>
    public int TotalOperations { get; set; }

    /// <summary>
    /// Current file being processed.
    /// </summary>
    public string CurrentFile { get; set; } = string.Empty;

    /// <summary>
    /// Whether the operation has been cancelled.
    /// </summary>
    public bool IsCancelled { get; set; }

    /// <summary>
    /// Whether rollback has been triggered.
    /// </summary>
    public bool IsRollingBack { get; set; }

    public ApplyContext(IFileSystemService fileSystem, IBackupService backupService)
    {
        RollbackManager = new RollbackManager(fileSystem, backupService);
    }

    /// <summary>
    /// Report progress to the reporter and event.
    /// </summary>
    public void ReportProgress(Action<BatchApplyProgress>? additionalHandler = null)
    {
        var progress = new BatchApplyProgress
        {
            TotalOperations = TotalOperations,
            CompletedOperations = CompletedOperations,
            Phase = CurrentPhase,
            CurrentFile = CurrentFile,
            CanCancel = !IsRollingBack,
            CancellationRequested = IsCancelled,
            Elapsed = DateTime.UtcNow - StartedAt
        };

        Progress?.Report(progress);
        additionalHandler?.Invoke(progress);
    }

    /// <summary>
    /// Build the final result.
    /// </summary>
    public BatchApplyResult BuildResult()
    {
        var successCount = Results.Count(r => r.Success);
        var failedCount = Results.Count(r => !r.Success);

        return new BatchApplyResult
        {
            AllSucceeded = failedCount == 0 && successCount == TotalOperations,
            SuccessCount = successCount,
            FailedCount = failedCount,
            SkippedCount = TotalOperations - successCount - failedCount,
            Results = Results.ToList(),
            StartedAt = StartedAt,
            CompletedAt = DateTime.UtcNow,
            BackupPaths = BackupPaths.ToList(),
            WasCancelled = IsCancelled,
            WasRolledBack = IsRollingBack
        };
    }

    public void Dispose()
    {
        RollbackManager.Dispose();
    }
}
```

### 4. RollbackManager

```csharp
// src/SeniorIntern.Services/RollbackManager.cs
namespace SeniorIntern.Services;

/// <summary>
/// Manages rollback of file operations on failure or cancellation.
/// </summary>
internal sealed class RollbackManager : IDisposable
{
    private readonly IFileSystemService _fileSystem;
    private readonly IBackupService _backupService;
    private readonly List<RollbackAction> _actions = new();
    private readonly object _lock = new();
    private bool _committed;
    private bool _disposed;

    public RollbackManager(IFileSystemService fileSystem, IBackupService backupService)
    {
        _fileSystem = fileSystem;
        _backupService = backupService;
    }

    /// <summary>
    /// Register a newly created file for potential deletion.
    /// </summary>
    public void RegisterCreatedFile(string filePath)
    {
        lock (_lock)
        {
            if (_committed) return;

            _actions.Add(new RollbackAction
            {
                Type = RollbackActionType.DeleteCreatedFile,
                FilePath = filePath,
                Order = _actions.Count
            });
        }
    }

    /// <summary>
    /// Register a modified file for potential restoration.
    /// </summary>
    public void RegisterModifiedFile(string filePath, string backupPath)
    {
        lock (_lock)
        {
            if (_committed) return;

            _actions.Add(new RollbackAction
            {
                Type = RollbackActionType.RestoreModifiedFile,
                FilePath = filePath,
                BackupPath = backupPath,
                Order = _actions.Count
            });
        }
    }

    /// <summary>
    /// Register a created directory for potential deletion.
    /// </summary>
    public void RegisterCreatedDirectory(string directoryPath)
    {
        lock (_lock)
        {
            if (_committed) return;

            _actions.Add(new RollbackAction
            {
                Type = RollbackActionType.DeleteCreatedDirectory,
                FilePath = directoryPath,
                Order = _actions.Count
            });
        }
    }

    /// <summary>
    /// Register a deleted file for potential restoration.
    /// </summary>
    public void RegisterDeletedFile(string filePath, string backupPath)
    {
        lock (_lock)
        {
            if (_committed) return;

            _actions.Add(new RollbackAction
            {
                Type = RollbackActionType.RestoreDeletedFile,
                FilePath = filePath,
                BackupPath = backupPath,
                Order = _actions.Count
            });
        }
    }

    /// <summary>
    /// Register a renamed file for potential restoration.
    /// </summary>
    public void RegisterRenamedFile(string originalPath, string newPath)
    {
        lock (_lock)
        {
            if (_committed) return;

            _actions.Add(new RollbackAction
            {
                Type = RollbackActionType.UndoRename,
                FilePath = newPath,
                OriginalPath = originalPath,
                Order = _actions.Count
            });
        }
    }

    /// <summary>
    /// Execute rollback of all registered actions.
    /// </summary>
    /// <param name="logger">Optional logger for rollback progress.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>True if all rollback actions succeeded.</returns>
    public async Task<bool> RollbackAsync(
        ILogger? logger = null,
        CancellationToken ct = default)
    {
        List<RollbackAction> actionsToRollback;

        lock (_lock)
        {
            if (_committed)
            {
                logger?.LogWarning("Cannot rollback: already committed");
                return false;
            }

            // Copy and reverse for LIFO order
            actionsToRollback = _actions.OrderByDescending(a => a.Order).ToList();
        }

        var allSuccess = true;

        foreach (var action in actionsToRollback)
        {
            try
            {
                ct.ThrowIfCancellationRequested();

                var success = await ExecuteRollbackActionAsync(action, logger, ct);
                if (!success)
                {
                    allSuccess = false;
                    logger?.LogWarning(
                        "Rollback action failed: {Type} for {Path}",
                        action.Type, action.FilePath);
                }
            }
            catch (Exception ex) when (ex is not OperationCanceledException)
            {
                allSuccess = false;
                logger?.LogError(ex,
                    "Exception during rollback action: {Type} for {Path}",
                    action.Type, action.FilePath);
            }
        }

        return allSuccess;
    }

    private async Task<bool> ExecuteRollbackActionAsync(
        RollbackAction action,
        ILogger? logger,
        CancellationToken ct)
    {
        logger?.LogDebug(
            "Executing rollback: {Type} for {Path}",
            action.Type, action.FilePath);

        switch (action.Type)
        {
            case RollbackActionType.DeleteCreatedFile:
                if (await _fileSystem.FileExistsAsync(action.FilePath, ct))
                {
                    await _fileSystem.DeleteFileAsync(action.FilePath, ct);
                    logger?.LogDebug("Deleted created file: {Path}", action.FilePath);
                }
                return true;

            case RollbackActionType.RestoreModifiedFile:
                if (!string.IsNullOrEmpty(action.BackupPath))
                {
                    await _backupService.RestoreBackupAsync(
                        action.BackupPath, action.FilePath, ct);
                    logger?.LogDebug(
                        "Restored modified file: {Path} from {Backup}",
                        action.FilePath, action.BackupPath);
                }
                return true;

            case RollbackActionType.DeleteCreatedDirectory:
                var dirPath = action.FilePath;
                if (Directory.Exists(dirPath) && IsDirectoryEmpty(dirPath))
                {
                    Directory.Delete(dirPath);
                    logger?.LogDebug("Deleted created directory: {Path}", dirPath);
                }
                return true;

            case RollbackActionType.RestoreDeletedFile:
                if (!string.IsNullOrEmpty(action.BackupPath))
                {
                    await _backupService.RestoreBackupAsync(
                        action.BackupPath, action.FilePath, ct);
                    logger?.LogDebug(
                        "Restored deleted file: {Path} from {Backup}",
                        action.FilePath, action.BackupPath);
                }
                return true;

            case RollbackActionType.UndoRename:
                if (!string.IsNullOrEmpty(action.OriginalPath) &&
                    await _fileSystem.FileExistsAsync(action.FilePath, ct))
                {
                    File.Move(action.FilePath, action.OriginalPath);
                    logger?.LogDebug(
                        "Undid rename: {NewPath} → {OriginalPath}",
                        action.FilePath, action.OriginalPath);
                }
                return true;

            default:
                logger?.LogWarning("Unknown rollback action type: {Type}", action.Type);
                return false;
        }
    }

    private static bool IsDirectoryEmpty(string path)
    {
        return !Directory.EnumerateFileSystemEntries(path).Any();
    }

    /// <summary>
    /// Commit the changes (prevent future rollback).
    /// </summary>
    public void Commit()
    {
        lock (_lock)
        {
            _committed = true;
            _actions.Clear();
        }
    }

    /// <summary>
    /// Clear all tracked actions without executing rollback.
    /// </summary>
    public void Clear()
    {
        lock (_lock)
        {
            _actions.Clear();
        }
    }

    /// <summary>
    /// Number of registered rollback actions.
    /// </summary>
    public int ActionCount
    {
        get
        {
            lock (_lock) { return _actions.Count; }
        }
    }

    public void Dispose()
    {
        if (_disposed) return;
        _disposed = true;

        lock (_lock)
        {
            _actions.Clear();
        }
    }

    /// <summary>
    /// A rollback action to execute.
    /// </summary>
    private sealed class RollbackAction
    {
        public RollbackActionType Type { get; init; }
        public string FilePath { get; init; } = string.Empty;
        public string? BackupPath { get; init; }
        public string? OriginalPath { get; init; }
        public int Order { get; init; }
    }

    /// <summary>
    /// Type of rollback action.
    /// </summary>
    private enum RollbackActionType
    {
        DeleteCreatedFile,
        RestoreModifiedFile,
        DeleteCreatedDirectory,
        RestoreDeletedFile,
        UndoRename
    }
}
```

### 5. FileTreeProposalService Implementation

```csharp
// src/SeniorIntern.Services/FileTreeProposalService.cs
namespace SeniorIntern.Services;

using System.Text;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;

/// <summary>
/// Service for validating and applying multi-file proposals.
/// </summary>
public sealed class FileTreeProposalService : IFileTreeProposalService
{
    private readonly IFileSystemService _fileSystem;
    private readonly IFileChangeService _changeService;
    private readonly IDiffService _diffService;
    private readonly IBackupService _backupService;
    private readonly ProposalServiceOptions _options;
    private readonly ILogger<FileTreeProposalService>? _logger;

    public event EventHandler<BatchApplyProgress>? ProgressChanged;
    public event EventHandler<OperationCompletedEventArgs>? OperationCompleted;
    public event EventHandler<ProposalValidationResult>? ValidationCompleted;

    public FileTreeProposalService(
        IFileSystemService fileSystem,
        IFileChangeService changeService,
        IDiffService diffService,
        IBackupService backupService,
        ProposalServiceOptions? options = null,
        ILogger<FileTreeProposalService>? logger = null)
    {
        _fileSystem = fileSystem ?? throw new ArgumentNullException(nameof(fileSystem));
        _changeService = changeService ?? throw new ArgumentNullException(nameof(changeService));
        _diffService = diffService ?? throw new ArgumentNullException(nameof(diffService));
        _backupService = backupService ?? throw new ArgumentNullException(nameof(backupService));
        _options = options ?? ProposalServiceOptions.Default;
        _logger = logger;
    }

    #region Validation

    public async Task<ProposalValidationResult> ValidateProposalAsync(
        FileTreeProposal proposal,
        string workspacePath,
        CancellationToken ct = default)
    {
        ArgumentNullException.ThrowIfNull(proposal);
        ArgumentException.ThrowIfNullOrEmpty(workspacePath);

        var issues = new List<ValidationIssue>();

        _logger?.LogDebug(
            "Validating proposal {Id} with {Count} operations",
            proposal.Id, proposal.Operations.Count);

        // Check for duplicate paths
        var duplicates = proposal.Operations
            .GroupBy(o => o.Path.ToLowerInvariant())
            .Where(g => g.Count() > 1)
            .Select(g => g.Key);

        foreach (var dup in duplicates)
        {
            issues.Add(ValidationIssue.DuplicatePath(dup));
        }

        // Validate each operation
        foreach (var op in proposal.Operations)
        {
            ct.ThrowIfCancellationRequested();

            var opIssues = await ValidateOperationAsync(op, workspacePath, ct);
            issues.AddRange(opIssues);
        }

        var result = issues.Any(i => i.Severity == ValidationSeverity.Error)
            ? ProposalValidationResult.Invalid(issues)
            : issues.Any()
                ? ProposalValidationResult.ValidWithWarnings(issues.ToArray())
                : ProposalValidationResult.Valid();

        ValidationCompleted?.Invoke(this, result);

        _logger?.LogDebug(
            "Validation complete: {Valid}, {ErrorCount} errors, {WarnCount} warnings",
            result.IsValid, result.ErrorCount, result.WarningCount);

        return result;
    }

    public async Task<IReadOnlyList<ValidationIssue>> ValidateOperationAsync(
        FileOperation op,
        string workspacePath,
        CancellationToken ct = default)
    {
        var issues = new List<ValidationIssue>();
        var fullPath = Path.Combine(workspacePath, op.Path);

        // Check path validity
        if (!IsValidPath(op.Path))
        {
            issues.Add(ValidationIssue.InvalidPath(op.Path, "Contains invalid characters", op.Id));
            return issues; // Can't continue validation
        }

        // Check if path is within workspace
        if (!IsWithinWorkspace(fullPath, workspacePath))
        {
            issues.Add(ValidationIssue.OutsideWorkspace(op.Path, op.Id));
            return issues;
        }

        // Check path length
        if (fullPath.Length > _options.PathLengthLimit)
        {
            issues.Add(ValidationIssue.PathTooLong(op.Path, _options.PathLengthLimit, op.Id));
        }

        // Operation-specific validation
        switch (op.Type)
        {
            case FileOperationType.Create:
                if (await _fileSystem.FileExistsAsync(fullPath, ct))
                {
                    issues.Add(ValidationIssue.FileExists(op.Path, op.Id));
                }
                if (string.IsNullOrWhiteSpace(op.Content))
                {
                    issues.Add(ValidationIssue.EmptyContent(op.Path, op.Id));
                }
                break;

            case FileOperationType.Modify:
                if (!await _fileSystem.FileExistsAsync(fullPath, ct))
                {
                    issues.Add(new ValidationIssue
                    {
                        OperationId = op.Id,
                        Path = op.Path,
                        Type = ValidationIssueType.InvalidPath,
                        Severity = ValidationSeverity.Error,
                        Message = "Cannot modify: file does not exist"
                    });
                }
                break;

            case FileOperationType.Delete:
                if (!await _fileSystem.FileExistsAsync(fullPath, ct))
                {
                    issues.Add(new ValidationIssue
                    {
                        OperationId = op.Id,
                        Path = op.Path,
                        Type = ValidationIssueType.InvalidPath,
                        Severity = ValidationSeverity.Warning,
                        Message = "File to delete does not exist"
                    });
                }
                break;

            case FileOperationType.Rename:
            case FileOperationType.Move:
                if (!await _fileSystem.FileExistsAsync(fullPath, ct))
                {
                    issues.Add(new ValidationIssue
                    {
                        OperationId = op.Id,
                        Path = op.Path,
                        Type = ValidationIssueType.InvalidPath,
                        Severity = ValidationSeverity.Error,
                        Message = "Source file does not exist"
                    });
                }
                if (!string.IsNullOrEmpty(op.NewPath))
                {
                    var newFullPath = Path.Combine(workspacePath, op.NewPath);
                    if (await _fileSystem.FileExistsAsync(newFullPath, ct))
                    {
                        issues.Add(new ValidationIssue
                        {
                            OperationId = op.Id,
                            Path = op.NewPath,
                            Type = ValidationIssueType.FileExists,
                            Severity = ValidationSeverity.Error,
                            Message = "Target path already exists"
                        });
                    }
                }
                break;
        }

        // Check write permissions (best effort)
        await CheckWritePermissionsAsync(op, fullPath, issues, ct);

        return issues;
    }

    private async Task CheckWritePermissionsAsync(
        FileOperation op,
        string fullPath,
        List<ValidationIssue> issues,
        CancellationToken ct)
    {
        try
        {
            var directory = Path.GetDirectoryName(fullPath);
            if (!string.IsNullOrEmpty(directory) && Directory.Exists(directory))
            {
                // Try to create a temp file to check write access
                var tempPath = Path.Combine(directory, $".write_test_{Guid.NewGuid():N}");
                try
                {
                    await File.WriteAllTextAsync(tempPath, "", ct);
                    File.Delete(tempPath);
                }
                catch (UnauthorizedAccessException)
                {
                    issues.Add(ValidationIssue.PermissionDenied(op.Path, op.Id));
                }
            }
        }
        catch
        {
            // Ignore permission check errors
        }
    }

    #endregion

    #region Apply

    public async Task<BatchApplyResult> ApplyProposalAsync(
        FileTreeProposal proposal,
        string workspacePath,
        ApplyOptions? options = null,
        IProgress<BatchApplyProgress>? progress = null,
        CancellationToken ct = default)
    {
        ArgumentNullException.ThrowIfNull(proposal);
        ArgumentException.ThrowIfNullOrEmpty(workspacePath);

        options ??= ApplyOptions.Default;

        using var context = new ApplyContext(_fileSystem, _backupService)
        {
            Proposal = proposal,
            WorkspacePath = workspacePath,
            Options = options,
            Progress = progress,
            CancellationToken = ct
        };

        var selectedOps = proposal.SelectedOperations.OrderBy(o => o.Order).ToList();
        context.TotalOperations = selectedOps.Count;

        _logger?.LogInformation(
            "Starting batch apply of {Count} operations for proposal {Id}",
            selectedOps.Count, proposal.Id);

        try
        {
            // Phase 1: Validation
            if (_options.ValidateBeforeApply)
            {
                context.CurrentPhase = BatchApplyPhase.Validating;
                context.CurrentFile = "Validating proposal...";
                ReportProgress(context);

                var validation = await ValidateProposalAsync(proposal, workspacePath, ct);
                if (!validation.IsValid)
                {
                    _logger?.LogWarning(
                        "Proposal validation failed with {Count} errors",
                        validation.ErrorCount);

                    // Mark operations with errors
                    foreach (var error in validation.Errors)
                    {
                        var op = selectedOps.FirstOrDefault(o => o.Id == error.OperationId);
                        if (op != null)
                        {
                            op.Status = FileOperationStatus.Failed;
                            op.ErrorMessage = error.Message;
                            context.Results.Add(ApplyResult.Failed(
                                Path.Combine(workspacePath, op.Path),
                                ApplyResultType.ValidationFailed,
                                error.Message));
                        }
                    }

                    // Remove failed operations from processing
                    selectedOps = selectedOps
                        .Where(o => o.Status != FileOperationStatus.Failed)
                        .ToList();

                    if (selectedOps.Count == 0)
                    {
                        proposal.Status = FileTreeProposalStatus.Invalid;
                        return context.BuildResult();
                    }
                }
            }

            // Phase 2: Create directories
            context.CurrentPhase = BatchApplyPhase.CreatingDirectories;
            context.CurrentFile = "Creating directories...";
            ReportProgress(context);

            await CreateDirectoriesAsync(selectedOps, workspacePath, context, ct);

            // Phase 3: Create backups
            if (options.CreateBackup && _options.EnableBackups)
            {
                context.CurrentPhase = BatchApplyPhase.CreatingBackups;
                context.CurrentFile = "Creating backups...";
                ReportProgress(context);

                await CreateBackupsAsync(selectedOps, workspacePath, context, ct);
            }

            // Phase 4: Apply operations
            context.CurrentPhase = BatchApplyPhase.WritingFiles;

            foreach (var op in selectedOps)
            {
                ct.ThrowIfCancellationRequested();

                context.CurrentFile = op.Path;
                ReportProgress(context);

                op.Status = FileOperationStatus.InProgress;

                try
                {
                    var result = await ApplyOperationInternalAsync(op, workspacePath, context, ct);
                    context.Results.Add(result);

                    op.Status = result.Success
                        ? FileOperationStatus.Applied
                        : FileOperationStatus.Failed;
                    op.ErrorMessage = result.ErrorMessage;

                    OperationCompleted?.Invoke(this, new OperationCompletedEventArgs
                    {
                        Operation = op,
                        Result = result,
                        OperationIndex = context.CompletedOperations,
                        TotalOperations = context.TotalOperations
                    });
                }
                catch (Exception ex) when (ex is not OperationCanceledException)
                {
                    op.Status = FileOperationStatus.Failed;
                    op.ErrorMessage = ex.Message;

                    var result = ApplyResult.Failed(
                        Path.Combine(workspacePath, op.Path),
                        ApplyResultType.Error,
                        ex.Message);
                    context.Results.Add(result);

                    _logger?.LogError(ex,
                        "Error applying operation {OpId} for {Path}",
                        op.Id, op.Path);

                    if (!_options.ContinueOnFailure)
                    {
                        throw;
                    }
                }

                context.CompletedOperations++;
            }

            // Phase 5: Finalize
            context.CurrentPhase = BatchApplyPhase.Completed;
            context.CurrentFile = "Complete";
            ReportProgress(context);

            // Update proposal status
            var successCount = context.Results.Count(r => r.Success);
            proposal.Status = successCount == selectedOps.Count
                ? FileTreeProposalStatus.FullyApplied
                : successCount > 0
                    ? FileTreeProposalStatus.PartiallyApplied
                    : FileTreeProposalStatus.Pending;

            // Commit (prevent rollback)
            context.RollbackManager.Commit();

            _logger?.LogInformation(
                "Batch apply complete: {Success}/{Total} succeeded",
                successCount, selectedOps.Count);

            return context.BuildResult();
        }
        catch (OperationCanceledException)
        {
            context.IsCancelled = true;
            proposal.Status = FileTreeProposalStatus.Cancelled;

            _logger?.LogWarning("Batch apply cancelled, initiating rollback");

            // Rollback
            if (_options.EnableRollback)
            {
                context.IsRollingBack = true;
                context.CurrentPhase = BatchApplyPhase.RollingBack;
                context.CurrentFile = "Rolling back...";
                ReportProgress(context);

                await context.RollbackManager.RollbackAsync(_logger, CancellationToken.None);
            }

            return context.BuildResult();
        }
        catch (Exception ex)
        {
            _logger?.LogError(ex, "Batch apply failed");

            if (_options.EnableRollback && _options.RollbackOnPartialFailure)
            {
                context.IsRollingBack = true;
                context.CurrentPhase = BatchApplyPhase.RollingBack;
                context.CurrentFile = "Rolling back...";
                ReportProgress(context);

                await context.RollbackManager.RollbackAsync(_logger, CancellationToken.None);
            }

            throw;
        }
    }

    public async Task<ApplyResult> ApplyOperationAsync(
        FileOperation operation,
        string workspacePath,
        ApplyOptions? options = null,
        CancellationToken ct = default)
    {
        using var context = new ApplyContext(_fileSystem, _backupService)
        {
            WorkspacePath = workspacePath,
            Options = options ?? ApplyOptions.Default,
            CancellationToken = ct
        };

        return await ApplyOperationInternalAsync(operation, workspacePath, context, ct);
    }

    private async Task<ApplyResult> ApplyOperationInternalAsync(
        FileOperation op,
        string workspacePath,
        ApplyContext context,
        CancellationToken ct)
    {
        var fullPath = Path.Combine(workspacePath, op.Path);

        _logger?.LogDebug(
            "Applying operation {Type} for {Path}",
            op.Type, op.Path);

        return op.Type switch
        {
            FileOperationType.Create => await WriteFileAsync(op, fullPath, context, ct),
            FileOperationType.Modify => await WriteFileAsync(op, fullPath, context, ct),
            FileOperationType.Delete => await DeleteFileAsync(op, fullPath, context, ct),
            FileOperationType.Rename when op.NewPath != null =>
                await RenameFileAsync(op, fullPath, Path.Combine(workspacePath, op.NewPath), context, ct),
            FileOperationType.Move when op.NewPath != null =>
                await MoveFileAsync(op, fullPath, Path.Combine(workspacePath, op.NewPath), context, ct),
            FileOperationType.CreateDirectory =>
                await CreateDirectoryAsync(op, fullPath, context, ct),
            _ => ApplyResult.Failed(fullPath, ApplyResultType.ValidationFailed,
                $"Unsupported operation type: {op.Type}")
        };
    }

    private async Task<ApplyResult> WriteFileAsync(
        FileOperation op,
        string fullPath,
        ApplyContext context,
        CancellationToken ct)
    {
        var fileExists = await _fileSystem.FileExistsAsync(fullPath, ct);
        var resultType = fileExists ? ApplyResultType.Modified : ApplyResultType.Created;

        // Create backup for existing file
        string? backupPath = null;
        if (fileExists && context.Options.CreateBackup && _options.EnableBackups)
        {
            backupPath = await _backupService.CreateBackupAsync(fullPath, ct);
            context.BackupPaths.Add(backupPath);
            context.RollbackManager.RegisterModifiedFile(fullPath, backupPath);
        }

        // Write the file
        var encoding = GetEncoding();
        await _fileSystem.WriteFileAsync(fullPath, op.Content ?? string.Empty, ct);

        // Track for rollback
        if (!fileExists)
        {
            context.CreatedFiles.Add(fullPath);
            context.RollbackManager.RegisterCreatedFile(fullPath);
        }

        return ApplyResult.Succeeded(fullPath, op.Path, resultType, backupPath);
    }

    private async Task<ApplyResult> DeleteFileAsync(
        FileOperation op,
        string fullPath,
        ApplyContext context,
        CancellationToken ct)
    {
        if (!await _fileSystem.FileExistsAsync(fullPath, ct))
        {
            return ApplyResult.Failed(fullPath, ApplyResultType.FileNotFound, "File not found");
        }

        // Create backup before deletion
        string? backupPath = null;
        if (context.Options.CreateBackup && _options.EnableBackups)
        {
            backupPath = await _backupService.CreateBackupAsync(fullPath, ct);
            context.BackupPaths.Add(backupPath);
            context.RollbackManager.RegisterDeletedFile(fullPath, backupPath);
        }

        await _fileSystem.DeleteFileAsync(fullPath, ct);

        return ApplyResult.Succeeded(fullPath, op.Path, ApplyResultType.Success, backupPath);
    }

    private async Task<ApplyResult> RenameFileAsync(
        FileOperation op,
        string oldPath,
        string newPath,
        ApplyContext context,
        CancellationToken ct)
    {
        if (!await _fileSystem.FileExistsAsync(oldPath, ct))
        {
            return ApplyResult.Failed(oldPath, ApplyResultType.FileNotFound, "Source file not found");
        }

        if (await _fileSystem.FileExistsAsync(newPath, ct))
        {
            return ApplyResult.Failed(newPath, ApplyResultType.Conflict, "Target file already exists");
        }

        await Task.Run(() => File.Move(oldPath, newPath), ct);

        context.RollbackManager.RegisterRenamedFile(oldPath, newPath);

        return ApplyResult.Succeeded(newPath, op.NewPath ?? op.Path, ApplyResultType.Success);
    }

    private async Task<ApplyResult> MoveFileAsync(
        FileOperation op,
        string oldPath,
        string newPath,
        ApplyContext context,
        CancellationToken ct)
    {
        // Ensure target directory exists
        var targetDir = Path.GetDirectoryName(newPath);
        if (!string.IsNullOrEmpty(targetDir) && !Directory.Exists(targetDir))
        {
            Directory.CreateDirectory(targetDir);
            context.CreatedDirectories.Add(targetDir);
            context.RollbackManager.RegisterCreatedDirectory(targetDir);
        }

        return await RenameFileAsync(op, oldPath, newPath, context, ct);
    }

    private Task<ApplyResult> CreateDirectoryAsync(
        FileOperation op,
        string fullPath,
        ApplyContext context,
        CancellationToken ct)
    {
        if (Directory.Exists(fullPath))
        {
            return Task.FromResult(ApplyResult.Succeeded(
                fullPath, op.Path, ApplyResultType.Success));
        }

        Directory.CreateDirectory(fullPath);
        context.CreatedDirectories.Add(fullPath);
        context.RollbackManager.RegisterCreatedDirectory(fullPath);

        return Task.FromResult(ApplyResult.Succeeded(
            fullPath, op.Path, ApplyResultType.Created));
    }

    #endregion

    #region Preview

    public async Task<IReadOnlyList<DiffResult>> PreviewProposalAsync(
        FileTreeProposal proposal,
        string workspacePath,
        CancellationToken ct = default)
    {
        var diffs = new List<DiffResult>();

        foreach (var op in proposal.SelectedOperations)
        {
            var diff = await PreviewOperationAsync(op, workspacePath, ct);
            if (diff != null)
            {
                diffs.Add(diff);
            }
        }

        return diffs;
    }

    public async Task<DiffResult?> PreviewOperationAsync(
        FileOperation operation,
        string workspacePath,
        CancellationToken ct = default)
    {
        if (operation.Type is not (FileOperationType.Create or FileOperationType.Modify))
        {
            return null;
        }

        var fullPath = Path.Combine(workspacePath, operation.Path);
        var exists = await _fileSystem.FileExistsAsync(fullPath, ct);

        if (exists)
        {
            var original = await _fileSystem.ReadFileAsync(fullPath, ct);
            return _diffService.ComputeDiff(original, operation.Content ?? "", operation.Path);
        }
        else
        {
            return _diffService.ComputeNewFileDiff(operation.Content ?? "", operation.Path);
        }
    }

    #endregion

    #region Undo

    public async Task<bool> UndoBatchApplyAsync(
        BatchApplyResult result,
        CancellationToken ct = default)
    {
        if (!result.CanUndoAll)
        {
            _logger?.LogWarning("Cannot undo batch: not all operations are undoable");
            return false;
        }

        var allSuccess = true;

        // Undo in reverse order
        foreach (var applyResult in result.Results.AsEnumerable().Reverse())
        {
            ct.ThrowIfCancellationRequested();

            if (applyResult.CanUndo)
            {
                var success = await UndoApplyResultAsync(applyResult, ct);
                if (!success)
                {
                    allSuccess = false;
                    _logger?.LogWarning(
                        "Failed to undo operation for {Path}",
                        applyResult.FilePath);
                }
            }
        }

        return allSuccess;
    }

    public async Task<bool> UndoApplyResultAsync(
        ApplyResult result,
        CancellationToken ct = default)
    {
        try
        {
            return await _changeService.UndoLastChangeAsync(result.FilePath, ct);
        }
        catch (Exception ex)
        {
            _logger?.LogError(ex, "Error undoing change for {Path}", result.FilePath);
            return false;
        }
    }

    #endregion

    #region Utility

    public async Task<IReadOnlyDictionary<string, bool>> CheckExistingFilesAsync(
        FileTreeProposal proposal,
        string workspacePath,
        CancellationToken ct = default)
    {
        var results = new Dictionary<string, bool>();

        foreach (var op in proposal.Operations)
        {
            var fullPath = Path.Combine(workspacePath, op.Path);
            results[op.Path] = await _fileSystem.FileExistsAsync(fullPath, ct);
        }

        return results;
    }

    public bool IsWithinWorkspace(string path, string workspacePath)
    {
        try
        {
            var fullPath = Path.IsPathRooted(path)
                ? path
                : Path.Combine(workspacePath, path);

            var normalizedFull = Path.GetFullPath(fullPath);
            var normalizedWorkspace = Path.GetFullPath(workspacePath);

            return normalizedFull.StartsWith(
                normalizedWorkspace + Path.DirectorySeparatorChar,
                StringComparison.OrdinalIgnoreCase) ||
                normalizedFull.Equals(normalizedWorkspace, StringComparison.OrdinalIgnoreCase);
        }
        catch
        {
            return false;
        }
    }

    public TimeSpan EstimateApplyTime(FileTreeProposal proposal)
    {
        // Rough estimate: 50ms per operation + 100ms per MB of content
        var opTime = proposal.SelectedCount * 50;
        var contentTime = (proposal.TotalSizeBytes / (1024 * 1024)) * 100;

        return TimeSpan.FromMilliseconds(opTime + contentTime + 500); // +500ms overhead
    }

    #endregion

    #region Private Helpers

    private async Task CreateDirectoriesAsync(
        List<FileOperation> operations,
        string workspacePath,
        ApplyContext context,
        CancellationToken ct)
    {
        var directories = operations
            .Where(o => o.Type == FileOperationType.Create)
            .Select(o => Path.GetDirectoryName(Path.Combine(workspacePath, o.Path)))
            .Where(d => !string.IsNullOrEmpty(d))
            .Distinct()
            .OrderBy(d => d!.Length) // Create parents first
            .ToList();

        foreach (var dir in directories)
        {
            ct.ThrowIfCancellationRequested();

            if (!Directory.Exists(dir))
            {
                Directory.CreateDirectory(dir!);
                context.CreatedDirectories.Add(dir!);
                context.RollbackManager.RegisterCreatedDirectory(dir!);

                _logger?.LogDebug("Created directory: {Dir}", dir);
            }
        }
    }

    private async Task CreateBackupsAsync(
        List<FileOperation> operations,
        string workspacePath,
        ApplyContext context,
        CancellationToken ct)
    {
        var filesToBackup = operations
            .Where(o => o.Type is FileOperationType.Modify or FileOperationType.Delete)
            .ToList();

        // Also backup files being overwritten by Create
        foreach (var op in operations.Where(o => o.Type == FileOperationType.Create))
        {
            var fullPath = Path.Combine(workspacePath, op.Path);
            if (await _fileSystem.FileExistsAsync(fullPath, ct))
            {
                filesToBackup.Add(op);
            }
        }

        foreach (var op in filesToBackup)
        {
            ct.ThrowIfCancellationRequested();

            var fullPath = Path.Combine(workspacePath, op.Path);
            if (await _fileSystem.FileExistsAsync(fullPath, ct))
            {
                var backupPath = await _backupService.CreateBackupAsync(fullPath, ct);
                context.BackupPaths.Add(backupPath);
                context.ModifiedFiles[fullPath] = backupPath;

                _logger?.LogDebug("Created backup: {Path} → {Backup}", fullPath, backupPath);
            }
        }
    }

    private void ReportProgress(ApplyContext context)
    {
        context.ReportProgress(p => ProgressChanged?.Invoke(this, p));
    }

    private static bool IsValidPath(string path)
    {
        if (string.IsNullOrWhiteSpace(path))
            return false;

        // Check for path traversal
        if (path.Contains(".."))
            return false;

        // Check for invalid characters
        var invalidChars = Path.GetInvalidPathChars();
        if (path.Any(c => invalidChars.Contains(c)))
            return false;

        // Check for absolute paths (should be relative)
        if (Path.IsPathRooted(path))
            return false;

        return true;
    }

    private Encoding GetEncoding()
    {
        var encoding = Encoding.GetEncoding(_options.FileEncoding);

        if (encoding is UTF8Encoding && !_options.UseUtf8Bom)
        {
            return new UTF8Encoding(false);
        }

        return encoding;
    }

    #endregion
}
```

### 6. Dependency Injection Registration

```csharp
// src/SeniorIntern.Services/ServiceCollectionExtensions.cs (partial)
namespace SeniorIntern.Services;

public static partial class ServiceCollectionExtensions
{
    /// <summary>
    /// Register file tree proposal services.
    /// </summary>
    public static IServiceCollection AddFileTreeProposalService(
        this IServiceCollection services,
        Action<ProposalServiceOptions>? configureOptions = null)
    {
        var options = ProposalServiceOptions.Default;
        configureOptions?.Invoke(options);

        services.AddSingleton(options);
        services.AddSingleton<IFileTreeProposalService, FileTreeProposalService>();

        return services;
    }
}
```

---

## Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/IFileTreeProposalService.cs` | Service interface |
| `src/SeniorIntern.Core/Models/ProposalServiceOptions.cs` | Configuration options |
| `src/SeniorIntern.Services/FileTreeProposalService.cs` | Service implementation |
| `src/SeniorIntern.Services/ApplyContext.cs` | Apply state tracking |
| `src/SeniorIntern.Services/RollbackManager.cs` | Rollback handling |

---

## Files to Modify

| File | Modification |
|------|--------------|
| `src/SeniorIntern.Services/ServiceCollectionExtensions.cs` | Add `AddFileTreeProposalService` |

---

## Dependencies

| Dependency | Purpose |
|------------|---------|
| `IFileSystemService` | File read/write/exists operations |
| `IFileChangeService` | From v0.4.3 for change tracking |
| `IDiffService` | From v0.4.2 for diff generation |
| `IBackupService` | From v0.4.3 for backup creation |
| `Microsoft.Extensions.Logging` | Logging infrastructure |
| `SeniorIntern.Core.Models.*` | From v0.4.4a for models |

---

## Testing Strategy

### Unit Tests

```csharp
// tests/SeniorIntern.Services.Tests/FileTreeProposalServiceTests.cs
namespace SeniorIntern.Services.Tests;

public class FileTreeProposalServiceTests
{
    private readonly Mock<IFileSystemService> _fileSystemMock;
    private readonly Mock<IFileChangeService> _changeServiceMock;
    private readonly Mock<IDiffService> _diffServiceMock;
    private readonly Mock<IBackupService> _backupServiceMock;
    private readonly FileTreeProposalService _service;
    private readonly string _workspacePath;

    public FileTreeProposalServiceTests()
    {
        _fileSystemMock = new Mock<IFileSystemService>();
        _changeServiceMock = new Mock<IFileChangeService>();
        _diffServiceMock = new Mock<IDiffService>();
        _backupServiceMock = new Mock<IBackupService>();
        _workspacePath = Path.Combine(Path.GetTempPath(), "test-workspace");

        _service = new FileTreeProposalService(
            _fileSystemMock.Object,
            _changeServiceMock.Object,
            _diffServiceMock.Object,
            _backupServiceMock.Object);
    }

    #region Validation Tests

    [Fact]
    public async Task ValidateProposalAsync_ValidProposal_ReturnsValid()
    {
        // Arrange
        var proposal = CreateValidProposal();
        _fileSystemMock.Setup(f => f.FileExistsAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(false);

        // Act
        var result = await _service.ValidateProposalAsync(proposal, _workspacePath);

        // Assert
        Assert.True(result.IsValid);
        Assert.False(result.HasErrors);
    }

    [Fact]
    public async Task ValidateProposalAsync_DuplicatePaths_ReturnsError()
    {
        // Arrange
        var proposal = new FileTreeProposal
        {
            Operations = new[]
            {
                new FileOperation { Path = "src/File.cs", Type = FileOperationType.Create },
                new FileOperation { Path = "src/File.cs", Type = FileOperationType.Create }
            }
        };

        // Act
        var result = await _service.ValidateProposalAsync(proposal, _workspacePath);

        // Assert
        Assert.False(result.IsValid);
        Assert.Contains(result.Issues, i => i.Type == ValidationIssueType.DuplicatePath);
    }

    [Fact]
    public async Task ValidateProposalAsync_PathOutsideWorkspace_ReturnsError()
    {
        // Arrange
        var proposal = new FileTreeProposal
        {
            Operations = new[]
            {
                new FileOperation { Path = "../outside/file.cs", Type = FileOperationType.Create }
            }
        };

        // Act
        var result = await _service.ValidateProposalAsync(proposal, _workspacePath);

        // Assert
        Assert.False(result.IsValid);
        Assert.Contains(result.Issues,
            i => i.Type == ValidationIssueType.InvalidPath ||
                 i.Type == ValidationIssueType.OutsideWorkspace);
    }

    [Fact]
    public async Task ValidateProposalAsync_ExistingFile_ReturnsWarning()
    {
        // Arrange
        var proposal = new FileTreeProposal
        {
            Operations = new[]
            {
                new FileOperation
                {
                    Path = "src/Existing.cs",
                    Type = FileOperationType.Create,
                    Content = "content"
                }
            }
        };

        _fileSystemMock.Setup(f => f.FileExistsAsync(
            It.Is<string>(p => p.Contains("Existing.cs")),
            It.IsAny<CancellationToken>()))
            .ReturnsAsync(true);

        // Act
        var result = await _service.ValidateProposalAsync(proposal, _workspacePath);

        // Assert
        Assert.True(result.IsValid); // Warning doesn't block
        Assert.True(result.HasWarnings);
        Assert.Contains(result.Issues, i => i.Type == ValidationIssueType.FileExists);
    }

    [Fact]
    public async Task ValidateProposalAsync_EmptyContent_ReturnsWarning()
    {
        // Arrange
        var proposal = new FileTreeProposal
        {
            Operations = new[]
            {
                new FileOperation
                {
                    Path = "src/Empty.cs",
                    Type = FileOperationType.Create,
                    Content = ""
                }
            }
        };

        _fileSystemMock.Setup(f => f.FileExistsAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(false);

        // Act
        var result = await _service.ValidateProposalAsync(proposal, _workspacePath);

        // Assert
        Assert.True(result.IsValid);
        Assert.Contains(result.Issues, i => i.Type == ValidationIssueType.EmptyContent);
    }

    #endregion

    #region Apply Tests

    [Fact]
    public async Task ApplyProposalAsync_CreatesAllFiles()
    {
        // Arrange
        var proposal = CreateValidProposal();
        _fileSystemMock.Setup(f => f.FileExistsAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(false);
        _fileSystemMock.Setup(f => f.WriteFileAsync(It.IsAny<string>(), It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .Returns(Task.CompletedTask);

        // Act
        var result = await _service.ApplyProposalAsync(proposal, _workspacePath);

        // Assert
        Assert.True(result.AllSucceeded);
        Assert.Equal(proposal.FileCount, result.SuccessCount);
        Assert.Equal(0, result.FailedCount);
    }

    [Fact]
    public async Task ApplyProposalAsync_ReportsProgress()
    {
        // Arrange
        var proposal = CreateValidProposal();
        var progressReports = new List<BatchApplyProgress>();
        var progress = new Progress<BatchApplyProgress>(p => progressReports.Add(p));

        _fileSystemMock.Setup(f => f.FileExistsAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(false);
        _fileSystemMock.Setup(f => f.WriteFileAsync(It.IsAny<string>(), It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .Returns(Task.CompletedTask);

        // Act
        await _service.ApplyProposalAsync(proposal, _workspacePath, progress: progress);

        // Allow async progress to complete
        await Task.Delay(100);

        // Assert
        Assert.NotEmpty(progressReports);
        Assert.Contains(progressReports, p => p.Phase == BatchApplyPhase.Validating);
        Assert.Contains(progressReports, p => p.Phase == BatchApplyPhase.WritingFiles);
        Assert.Contains(progressReports, p => p.Phase == BatchApplyPhase.Completed);
    }

    [Fact]
    public async Task ApplyProposalAsync_CreateBackups_WhenConfigured()
    {
        // Arrange
        var proposal = new FileTreeProposal
        {
            Operations = new[]
            {
                new FileOperation
                {
                    Path = "src/Modify.cs",
                    Type = FileOperationType.Modify,
                    Content = "new content",
                    IsSelected = true
                }
            }
        };

        _fileSystemMock.Setup(f => f.FileExistsAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(true);
        _fileSystemMock.Setup(f => f.WriteFileAsync(It.IsAny<string>(), It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .Returns(Task.CompletedTask);
        _backupServiceMock.Setup(b => b.CreateBackupAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync("/backup/path");

        var options = new ApplyOptions { CreateBackup = true };

        // Act
        var result = await _service.ApplyProposalAsync(proposal, _workspacePath, options);

        // Assert
        Assert.NotEmpty(result.BackupPaths);
        _backupServiceMock.Verify(b => b.CreateBackupAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()), Times.Once);
    }

    [Fact]
    public async Task ApplyProposalAsync_Cancellation_TriggersRollback()
    {
        // Arrange
        var proposal = CreateValidProposal();
        var cts = new CancellationTokenSource();

        _fileSystemMock.Setup(f => f.FileExistsAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(false);
        _fileSystemMock.Setup(f => f.WriteFileAsync(It.IsAny<string>(), It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .Returns(async (string _, string _, CancellationToken ct) =>
            {
                cts.Cancel(); // Cancel during first write
                ct.ThrowIfCancellationRequested();
            });

        // Act & Assert
        await Assert.ThrowsAsync<OperationCanceledException>(() =>
            _service.ApplyProposalAsync(proposal, _workspacePath, ct: cts.Token));

        Assert.Equal(FileTreeProposalStatus.Cancelled, proposal.Status);
    }

    [Fact]
    public async Task ApplyProposalAsync_PartialFailure_ContinuesWithOthers()
    {
        // Arrange
        var proposal = new FileTreeProposal
        {
            Operations = new[]
            {
                new FileOperation
                {
                    Path = "src/Good.cs",
                    Type = FileOperationType.Create,
                    Content = "good",
                    IsSelected = true
                },
                new FileOperation
                {
                    Path = "src/Bad.cs",
                    Type = FileOperationType.Modify, // Will fail - file doesn't exist
                    Content = "bad",
                    IsSelected = true
                }
            }
        };

        _fileSystemMock.Setup(f => f.FileExistsAsync(
            It.Is<string>(p => p.Contains("Good.cs")),
            It.IsAny<CancellationToken>()))
            .ReturnsAsync(false);
        _fileSystemMock.Setup(f => f.FileExistsAsync(
            It.Is<string>(p => p.Contains("Bad.cs")),
            It.IsAny<CancellationToken>()))
            .ReturnsAsync(false); // Modify requires existing file
        _fileSystemMock.Setup(f => f.WriteFileAsync(It.IsAny<string>(), It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .Returns(Task.CompletedTask);

        // Act
        var result = await _service.ApplyProposalAsync(proposal, _workspacePath);

        // Assert
        Assert.False(result.AllSucceeded);
        Assert.Equal(FileTreeProposalStatus.PartiallyApplied, proposal.Status);
    }

    #endregion

    #region Preview Tests

    [Fact]
    public async Task PreviewProposalAsync_GeneratesDiffsForSelectedOperations()
    {
        // Arrange
        var proposal = new FileTreeProposal
        {
            Operations = new[]
            {
                new FileOperation
                {
                    Path = "src/New.cs",
                    Type = FileOperationType.Create,
                    Content = "new file content",
                    IsSelected = true
                },
                new FileOperation
                {
                    Path = "src/Modify.cs",
                    Type = FileOperationType.Modify,
                    Content = "modified content",
                    IsSelected = true
                }
            }
        };

        _fileSystemMock.Setup(f => f.FileExistsAsync(
            It.Is<string>(p => p.Contains("New.cs")),
            It.IsAny<CancellationToken>()))
            .ReturnsAsync(false);
        _fileSystemMock.Setup(f => f.FileExistsAsync(
            It.Is<string>(p => p.Contains("Modify.cs")),
            It.IsAny<CancellationToken>()))
            .ReturnsAsync(true);
        _fileSystemMock.Setup(f => f.ReadFileAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync("original content");

        _diffServiceMock.Setup(d => d.ComputeNewFileDiff(It.IsAny<string>(), It.IsAny<string>()))
            .Returns(new DiffResult { TargetFilePath = "src/New.cs" });
        _diffServiceMock.Setup(d => d.ComputeDiff(It.IsAny<string>(), It.IsAny<string>(), It.IsAny<string>()))
            .Returns(new DiffResult { TargetFilePath = "src/Modify.cs" });

        // Act
        var diffs = await _service.PreviewProposalAsync(proposal, _workspacePath);

        // Assert
        Assert.Equal(2, diffs.Count);
    }

    #endregion

    #region Undo Tests

    [Fact]
    public async Task UndoBatchApplyAsync_UndoesInReverseOrder()
    {
        // Arrange
        var result = new BatchApplyResult
        {
            Results = new[]
            {
                ApplyResult.Succeeded("/path/a.cs", "a.cs", ApplyResultType.Created),
                ApplyResult.Succeeded("/path/b.cs", "b.cs", ApplyResultType.Created),
                ApplyResult.Succeeded("/path/c.cs", "c.cs", ApplyResultType.Created)
            }
        };

        var undoOrder = new List<string>();
        _changeServiceMock.Setup(c => c.UndoLastChangeAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .Returns((string path, CancellationToken _) =>
            {
                undoOrder.Add(path);
                return Task.FromResult(true);
            });

        // Act
        await _service.UndoBatchApplyAsync(result);

        // Assert
        Assert.Equal(3, undoOrder.Count);
        Assert.Equal("/path/c.cs", undoOrder[0]); // Reverse order
        Assert.Equal("/path/b.cs", undoOrder[1]);
        Assert.Equal("/path/a.cs", undoOrder[2]);
    }

    #endregion

    #region Utility Tests

    [Theory]
    [InlineData("src/file.cs", true)]
    [InlineData("../outside.cs", false)]
    [InlineData("..\\outside.cs", false)]
    [InlineData("/absolute/path.cs", false)]
    public void IsWithinWorkspace_ValidatesPaths(string path, bool expected)
    {
        // Act
        var result = _service.IsWithinWorkspace(path, _workspacePath);

        // Assert
        Assert.Equal(expected, result);
    }

    [Fact]
    public async Task CheckExistingFilesAsync_ReturnsCorrectMapping()
    {
        // Arrange
        var proposal = new FileTreeProposal
        {
            Operations = new[]
            {
                new FileOperation { Path = "src/Exists.cs" },
                new FileOperation { Path = "src/NotExists.cs" }
            }
        };

        _fileSystemMock.Setup(f => f.FileExistsAsync(
            It.Is<string>(p => p.Contains("Exists.cs")),
            It.IsAny<CancellationToken>()))
            .ReturnsAsync(true);
        _fileSystemMock.Setup(f => f.FileExistsAsync(
            It.Is<string>(p => p.Contains("NotExists.cs")),
            It.IsAny<CancellationToken>()))
            .ReturnsAsync(false);

        // Act
        var result = await _service.CheckExistingFilesAsync(proposal, _workspacePath);

        // Assert
        Assert.True(result["src/Exists.cs"]);
        Assert.False(result["src/NotExists.cs"]);
    }

    #endregion

    #region Helper Methods

    private static FileTreeProposal CreateValidProposal()
    {
        return new FileTreeProposal
        {
            Operations = new[]
            {
                new FileOperation
                {
                    Path = "src/File1.cs",
                    Type = FileOperationType.Create,
                    Content = "class File1 { }",
                    IsSelected = true
                },
                new FileOperation
                {
                    Path = "src/File2.cs",
                    Type = FileOperationType.Create,
                    Content = "class File2 { }",
                    IsSelected = true
                }
            }
        };
    }

    #endregion
}

// tests/SeniorIntern.Services.Tests/RollbackManagerTests.cs
namespace SeniorIntern.Services.Tests;

public class RollbackManagerTests
{
    [Fact]
    public async Task RollbackAsync_DeletesCreatedFiles()
    {
        // Arrange
        var fileSystemMock = new Mock<IFileSystemService>();
        var backupServiceMock = new Mock<IBackupService>();
        var manager = new RollbackManager(fileSystemMock.Object, backupServiceMock.Object);

        fileSystemMock.Setup(f => f.FileExistsAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(true);
        fileSystemMock.Setup(f => f.DeleteFileAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .Returns(Task.CompletedTask);

        manager.RegisterCreatedFile("/path/to/file.cs");

        // Act
        var result = await manager.RollbackAsync();

        // Assert
        Assert.True(result);
        fileSystemMock.Verify(f => f.DeleteFileAsync("/path/to/file.cs", It.IsAny<CancellationToken>()), Times.Once);
    }

    [Fact]
    public async Task RollbackAsync_RestoresModifiedFiles()
    {
        // Arrange
        var fileSystemMock = new Mock<IFileSystemService>();
        var backupServiceMock = new Mock<IBackupService>();
        var manager = new RollbackManager(fileSystemMock.Object, backupServiceMock.Object);

        backupServiceMock.Setup(b => b.RestoreBackupAsync(It.IsAny<string>(), It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .Returns(Task.CompletedTask);

        manager.RegisterModifiedFile("/path/to/modified.cs", "/backup/path");

        // Act
        var result = await manager.RollbackAsync();

        // Assert
        Assert.True(result);
        backupServiceMock.Verify(b => b.RestoreBackupAsync("/backup/path", "/path/to/modified.cs", It.IsAny<CancellationToken>()), Times.Once);
    }

    [Fact]
    public async Task RollbackAsync_ProcessesInReverseOrder()
    {
        // Arrange
        var fileSystemMock = new Mock<IFileSystemService>();
        var backupServiceMock = new Mock<IBackupService>();
        var manager = new RollbackManager(fileSystemMock.Object, backupServiceMock.Object);

        var deleteOrder = new List<string>();
        fileSystemMock.Setup(f => f.FileExistsAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(true);
        fileSystemMock.Setup(f => f.DeleteFileAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .Returns((string path, CancellationToken _) =>
            {
                deleteOrder.Add(path);
                return Task.CompletedTask;
            });

        manager.RegisterCreatedFile("/first.cs");
        manager.RegisterCreatedFile("/second.cs");
        manager.RegisterCreatedFile("/third.cs");

        // Act
        await manager.RollbackAsync();

        // Assert
        Assert.Equal("/third.cs", deleteOrder[0]);
        Assert.Equal("/second.cs", deleteOrder[1]);
        Assert.Equal("/first.cs", deleteOrder[2]);
    }

    [Fact]
    public void Commit_PreventsRollback()
    {
        // Arrange
        var fileSystemMock = new Mock<IFileSystemService>();
        var backupServiceMock = new Mock<IBackupService>();
        var manager = new RollbackManager(fileSystemMock.Object, backupServiceMock.Object);

        manager.RegisterCreatedFile("/path/to/file.cs");
        manager.Commit();

        // Assert
        Assert.Equal(0, manager.ActionCount);
    }
}
```

---

## Acceptance Criteria

- [ ] Validation detects duplicate paths in proposal
- [ ] Validation detects invalid path characters
- [ ] Validation detects paths outside workspace (path traversal)
- [ ] Validation detects path length exceeding limit
- [ ] Validation warns about existing files (for Create operations)
- [ ] Validation warns about empty content
- [ ] Validation checks write permissions (best effort)
- [ ] Directories created before files in correct order
- [ ] Backups created when configured (for Modify/Delete operations)
- [ ] Backups created for existing files before overwrite
- [ ] Progress reported through all phases
- [ ] Progress includes current file and phase information
- [ ] Cancellation triggers rollback of completed operations
- [ ] Rollback deletes created files
- [ ] Rollback restores modified files from backups
- [ ] Rollback removes empty created directories
- [ ] Undo batch processes in reverse order
- [ ] Partial failure continues with remaining operations (configurable)
- [ ] Proposal status updated correctly (FullyApplied, PartiallyApplied, etc.)
- [ ] Preview generates diffs for Create and Modify operations
- [ ] CheckExistingFiles returns correct mapping

---

## Design Decisions

| Decision | Rationale | Alternatives Considered |
|----------|-----------|------------------------|
| Sequential apply by default | Ensures proper ordering and simpler rollback | Parallel apply (risk of ordering issues) |
| Rollback manager pattern | Clean separation of rollback concerns | Inline rollback in service |
| Continue on failure (configurable) | Allow partial success for large proposals | Stop on first failure |
| Backup before overwrite | User data protection | Skip backup for creates |
| Validation before apply | Catch issues early | Validate during apply |
| Phase-based progress | Clear communication of operation stage | Simple percentage only |
| LIFO rollback order | Proper dependency handling | FIFO (could break dependencies) |
| ApplyContext internal class | Encapsulate apply state | Pass many parameters |
| Best-effort permission check | Avoid false negatives | Strict permission check |

---

## Accessibility Considerations

- Progress phase descriptions use complete sentences
- Error messages provide actionable information
- Validation issues include suggested fixes where possible
- Event args provide complete context for screen readers

---

## Performance Considerations

| Concern | Mitigation |
|---------|------------|
| Many files to process | Sequential by default, parallel option available |
| Large file content | Streaming writes if needed (future) |
| Backup creation | Only backup files being modified |
| Directory creation | Sorted by length to minimize calls |
| Progress updates | Configurable throttle interval |
| Validation I/O | Early exit on blocking errors |

---

## Future Enhancements

1. **Parallel Apply**: Option to apply independent operations in parallel
2. **Dry Run Mode**: Simulate apply without writing files
3. **Conflict Resolution UI**: Interactive resolution for file conflicts
4. **Atomic Operations**: Transactional apply with full rollback
5. **Progress Estimation**: ML-based time estimation
6. **Resumable Apply**: Continue from last successful operation
7. **Template Variables**: Support for placeholders in content

---

## Related Specifications

| Specification | Relationship |
|---------------|--------------|
| v0.4.3 (Apply Changes Workflow) | Provides IFileChangeService, IBackupService |
| v0.4.2 (Diff Engine) | Provides IDiffService for preview |
| v0.4.4a (Core Models) | Provides FileTreeProposal, FileOperation |
| v0.4.4b (File Tree Parser) | Creates proposals consumed by this service |
| v0.4.4d (Tree ViewModels) | Consumes this service for apply operations |
| v0.4.4g (Progress Overlay) | Displays progress from this service |
