# v0.4.4d: Tree ViewModels - Design Specification

**Status**: _IMPLEMENTED_

## Executive Summary

This specification details the **Tree ViewModels** for The Senior Intern's Multi-File Creation system, defining the presentation logic that bridges the core models (v0.4.4a) with the UI components (v0.4.4e). These ViewModels handle tree structure building, selection state management, validation display, and apply operation orchestration while following the MVVM pattern with CommunityToolkit.Mvvm source generators.

### Key Deliverables

| Component | Type | Purpose |
|-----------|------|---------|
| `FileTreeProposalViewModel` | ViewModel | Main ViewModel for displaying and managing a file tree proposal |
| `FileTreeItemViewModel` | ViewModel | Individual tree item representing a file or directory |
| `TreeBuildingService` | Service | Builds hierarchical tree structure from flat operations |
| `ITreeBuildingService` | Interface | Contract for tree building operations |
| `TreeNodeSelectionBehavior` | Enum | Selection propagation behavior options |

---

## Feature Overview

```
v0.4.4d: Tree ViewModels
â”œâ”€â”€ FileTreeProposalViewModel
â”‚   â”œâ”€â”€ Bound Properties
â”‚   â”‚   â”œâ”€â”€ Proposal (FileTreeProposal)
â”‚   â”‚   â”œâ”€â”€ TreeItems (ObservableCollection<FileTreeItemViewModel>)
â”‚   â”‚   â”œâ”€â”€ SelectedItem (FileTreeItemViewModel?)
â”‚   â”‚   â”œâ”€â”€ Description (string?)
â”‚   â”‚   â”œâ”€â”€ FileCount, DirectoryCount (int)
â”‚   â”‚   â”œâ”€â”€ SelectedCount (int)
â”‚   â”‚   â”œâ”€â”€ HasSelectedFiles (bool)
â”‚   â”‚   â”œâ”€â”€ CreateBackups (bool, default true)
â”‚   â”‚   â”œâ”€â”€ IsApplying (bool)
â”‚   â”‚   â”œâ”€â”€ ApplyProgress (double, 0-100)
â”‚   â”‚   â”œâ”€â”€ CurrentFile (string)
â”‚   â”‚   â”œâ”€â”€ ValidationResult (ProposalValidationResult?)
â”‚   â”‚   â”œâ”€â”€ HasWarnings, HasErrors (bool)
â”‚   â”‚   â””â”€â”€ CanApply (computed)
â”‚   â”œâ”€â”€ Commands
â”‚   â”‚   â”œâ”€â”€ SelectAllCommand
â”‚   â”‚   â”œâ”€â”€ DeselectAllCommand
â”‚   â”‚   â”œâ”€â”€ PreviewCommand
â”‚   â”‚   â”œâ”€â”€ ApplyCommand
â”‚   â”‚   â”œâ”€â”€ CancelCommand
â”‚   â”‚   â”œâ”€â”€ ToggleItemSelectionCommand
â”‚   â”‚   â””â”€â”€ ExpandAllCommand, CollapseAllCommand
â”‚   â”œâ”€â”€ Events
â”‚   â”‚   â”œâ”€â”€ PreviewRequested (IReadOnlyList<DiffResult>)
â”‚   â”‚   â”œâ”€â”€ ApplyCompleted (BatchApplyResult)
â”‚   â”‚   â””â”€â”€ ApplyCancelled
â”‚   â”œâ”€â”€ Tree Building
â”‚   â”‚   â”œâ”€â”€ BuildTree() - Creates hierarchy from flat operations
â”‚   â”‚   â”œâ”€â”€ RebuildTree() - Refreshes tree structure
â”‚   â”‚   â””â”€â”€ FindItemByPath(string) - Locates item in tree
â”‚   â”œâ”€â”€ Selection Management
â”‚   â”‚   â”œâ”€â”€ OnFileItemPropertyChanged() - Syncs selection
â”‚   â”‚   â”œâ”€â”€ UpdateSelectedCount() - Recalculates counts
â”‚   â”‚   â”œâ”€â”€ SetAllSelected(bool) - Bulk selection
â”‚   â”‚   â””â”€â”€ PropagateSelectionToChildren() - Cascade selection
â”‚   â”œâ”€â”€ Validation Integration
â”‚   â”‚   â”œâ”€â”€ ValidateAsync() - Triggers validation
â”‚   â”‚   â”œâ”€â”€ UpdateValidationDisplay() - Maps issues to items
â”‚   â”‚   â””â”€â”€ ClearValidationIssues() - Resets validation state
â”‚   â””â”€â”€ Apply Operations
â”‚       â”œâ”€â”€ ApplyAsync() - Executes file creation
â”‚       â”œâ”€â”€ OnProgressUpdate() - Handles progress events
â”‚       â””â”€â”€ CancelApply() - Cancels in-progress operation
â”œâ”€â”€ FileTreeItemViewModel
â”‚   â”œâ”€â”€ Identity Properties
â”‚   â”‚   â”œâ”€â”€ Name (string)
â”‚   â”‚   â”œâ”€â”€ Path (string)
â”‚   â”‚   â”œâ”€â”€ IsDirectory (bool)
â”‚   â”‚   â””â”€â”€ Operation (FileOperation?)
â”‚   â”œâ”€â”€ State Properties
â”‚   â”‚   â”œâ”€â”€ IsExpanded (bool, default true)
â”‚   â”‚   â”œâ”€â”€ IsSelected (bool, default true)
â”‚   â”‚   â”œâ”€â”€ IsEnabled (bool, default true)
â”‚   â”‚   â””â”€â”€ IsHighlighted (bool)
â”‚   â”œâ”€â”€ Display Properties
â”‚   â”‚   â”œâ”€â”€ Language (string?)
â”‚   â”‚   â”œâ”€â”€ FileExists (bool)
â”‚   â”‚   â”œâ”€â”€ ValidationIssue (ValidationIssue?)
â”‚   â”‚   â””â”€â”€ OperationStatus (FileOperationStatus?)
â”‚   â”œâ”€â”€ Computed Properties
â”‚   â”‚   â”œâ”€â”€ IsFile (bool)
â”‚   â”‚   â”œâ”€â”€ HasChildren (bool)
â”‚   â”‚   â”œâ”€â”€ HasWarning, HasError (bool)
â”‚   â”‚   â”œâ”€â”€ Icon (string)
â”‚   â”‚   â”œâ”€â”€ StatusText (string)
â”‚   â”‚   â”œâ”€â”€ StatusIcon (string?)
â”‚   â”‚   â”œâ”€â”€ Tooltip (string)
â”‚   â”‚   â””â”€â”€ SelectionState (SelectionState enum)
â”‚   â”œâ”€â”€ Children
â”‚   â”‚   â””â”€â”€ Children (ObservableCollection<FileTreeItemViewModel>)
â”‚   â””â”€â”€ Methods
â”‚       â”œâ”€â”€ GetFileIcon() - Returns icon based on extension
â”‚       â”œâ”€â”€ UpdateFromOperation() - Syncs with FileOperation
â”‚       â””â”€â”€ ClearValidation() - Removes validation state
â”œâ”€â”€ TreeBuildingService
â”‚   â”œâ”€â”€ Interface (ITreeBuildingService)
â”‚   â”‚   â”œâ”€â”€ BuildTree(FileTreeProposal) -> IReadOnlyList<FileTreeItemViewModel>
â”‚   â”‚   â”œâ”€â”€ BuildTreeFromOperations(IEnumerable<FileOperation>) -> IReadOnlyList<FileTreeItemViewModel>
â”‚   â”‚   â””â”€â”€ FlattenTree(IEnumerable<FileTreeItemViewModel>) -> IEnumerable<FileTreeItemViewModel>
â”‚   â”œâ”€â”€ Implementation
â”‚   â”‚   â”œâ”€â”€ GroupByDirectory() - Groups operations by parent directory
â”‚   â”‚   â”œâ”€â”€ CreateDirectoryNodes() - Builds intermediate directory nodes
â”‚   â”‚   â”œâ”€â”€ AttachFileNodes() - Attaches file items to directories
â”‚   â”‚   â””â”€â”€ SortTree() - Sorts directories first, then files alphabetically
â”‚   â””â”€â”€ Configuration
â”‚       â””â”€â”€ TreeBuildingOptions
â”‚           â”œâ”€â”€ SortDirectoriesFirst (bool, default true)
â”‚           â”œâ”€â”€ ExpandByDefault (bool, default true)
â”‚           â””â”€â”€ HideCommonRootPath (bool, default false)
â””â”€â”€ Supporting Types
    â”œâ”€â”€ SelectionState (Enum)
    â”‚   â”œâ”€â”€ None - No children selected
    â”‚   â”œâ”€â”€ Some - Partial selection
    â”‚   â””â”€â”€ All - All children selected
    â””â”€â”€ TreeNodeSelectionBehavior (Enum)
        â”œâ”€â”€ Independent - Items select independently
        â”œâ”€â”€ CascadeToChildren - Parent selection cascades down
        â””â”€â”€ CascadeToParent - Child selection updates parent state
```

---

## Architecture Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                           ViewModel Layer                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                    FileTreeProposalViewModel                           â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚  â”‚  â”‚                    Observable Properties                         â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚ Proposal â”‚ â”‚TreeItems â”‚ â”‚FileCount â”‚ â”‚  ValidationResult    â”‚â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚  â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚  â”‚  â”‚                         Commands                                 â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚SelectAll â”‚ â”‚DeselectAll â”‚ â”‚ Preview â”‚ â”‚      Apply        â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                      â”‚                                       â”‚
â”‚                                      â–¼                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                     FileTreeItemViewModel                              â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  â”‚
â”‚  â”‚  â”‚  Name   â”‚  â”‚   Path   â”‚  â”‚ IsDirectoryâ”‚  â”‚     Operation       â”‚   â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  â”‚
â”‚  â”‚  â”‚IsExpandedâ”‚ â”‚IsSelectedâ”‚  â”‚ValidationIssueâ”‚ â”‚     Children      â”‚   â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â–¼                 â–¼                 â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  FileTreeProposal â”‚ â”‚  ProposalService â”‚ â”‚   DiffService    â”‚
        â”‚    (v0.4.4a)      â”‚ â”‚    (v0.4.4c)     â”‚ â”‚   (existing)     â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Tree Building Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         Tree Building Process                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  FileTreeProposal.Operations (flat list)                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ [0] src/Services/UserService.cs                                        â”‚ â”‚
â”‚  â”‚ [1] src/Services/AuthService.cs                                        â”‚ â”‚
â”‚  â”‚ [2] src/Models/User.cs                                                 â”‚ â”‚
â”‚  â”‚ [3] src/Models/Auth/Token.cs                                           â”‚ â”‚
â”‚  â”‚ [4] tests/Services/UserServiceTests.cs                                 â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                      â”‚                                       â”‚
â”‚                                      â–¼                                       â”‚
â”‚                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                            â”‚
â”‚                          â”‚  TreeBuildingService â”‚                            â”‚
â”‚                          â”‚    GroupByDirectory  â”‚                            â”‚
â”‚                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                            â”‚
â”‚                                      â”‚                                       â”‚
â”‚                                      â–¼                                       â”‚
â”‚  Grouped Operations                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ "src/Services"    â†’ [UserService.cs, AuthService.cs]                   â”‚ â”‚
â”‚  â”‚ "src/Models"      â†’ [User.cs]                                          â”‚ â”‚
â”‚  â”‚ "src/Models/Auth" â†’ [Token.cs]                                         â”‚ â”‚
â”‚  â”‚ "tests/Services"  â†’ [UserServiceTests.cs]                              â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                      â”‚                                       â”‚
â”‚                                      â–¼                                       â”‚
â”‚                         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                             â”‚
â”‚                         â”‚ CreateDirectoryNodes â”‚                             â”‚
â”‚                         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                             â”‚
â”‚                                      â”‚                                       â”‚
â”‚                                      â–¼                                       â”‚
â”‚  Hierarchical Tree Structure                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  ğŸ“ src                                                                â”‚ â”‚
â”‚  â”‚  â”œâ”€â”€ ğŸ“ Services                                                       â”‚ â”‚
â”‚  â”‚  â”‚   â”œâ”€â”€ ğŸ“„ UserService.cs                                             â”‚ â”‚
â”‚  â”‚  â”‚   â””â”€â”€ ğŸ“„ AuthService.cs                                             â”‚ â”‚
â”‚  â”‚  â””â”€â”€ ğŸ“ Models                                                         â”‚ â”‚
â”‚  â”‚      â”œâ”€â”€ ğŸ“„ User.cs                                                    â”‚ â”‚
â”‚  â”‚      â””â”€â”€ ğŸ“ Auth                                                       â”‚ â”‚
â”‚  â”‚          â””â”€â”€ ğŸ“„ Token.cs                                               â”‚ â”‚
â”‚  â”‚  ğŸ“ tests                                                              â”‚ â”‚
â”‚  â”‚  â””â”€â”€ ğŸ“ Services                                                       â”‚ â”‚
â”‚  â”‚      â””â”€â”€ ğŸ“„ UserServiceTests.cs                                        â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Selection State Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       Selection State Synchronization                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  User Action: Click checkbox on FileTreeItemViewModel                       â”‚
â”‚                                      â”‚                                       â”‚
â”‚                                      â–¼                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  FileTreeItemViewModel.IsSelected = true                               â”‚  â”‚
â”‚  â”‚                      â”‚                                                 â”‚  â”‚
â”‚  â”‚                      â–¼                                                 â”‚  â”‚
â”‚  â”‚  PropertyChanged event fires                                           â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                      â”‚                                       â”‚
â”‚                                      â–¼                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  FileTreeProposalViewModel.OnFileItemPropertyChanged()                 â”‚  â”‚
â”‚  â”‚                      â”‚                                                 â”‚  â”‚
â”‚  â”‚                      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚  â”‚
â”‚  â”‚                      â”‚                                      â”‚         â”‚  â”‚
â”‚  â”‚                      â–¼                                      â–¼         â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚  â”‚
â”‚  â”‚  â”‚ Sync to FileOperation model  â”‚   â”‚   UpdateSelectedCount()      â”‚ â”‚  â”‚
â”‚  â”‚  â”‚ item.Operation.IsSelected =  â”‚   â”‚   SelectedCount = Proposal   â”‚ â”‚  â”‚
â”‚  â”‚  â”‚     item.IsSelected          â”‚   â”‚       .SelectedCount         â”‚ â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚  â”‚
â”‚  â”‚                                      â”‚                               â”‚  â”‚
â”‚  â”‚                                      â–¼                               â”‚  â”‚
â”‚  â”‚                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚  â”‚
â”‚  â”‚                      â”‚  HasSelectedFiles updated    â”‚                â”‚  â”‚
â”‚  â”‚                      â”‚  ApplyCommand.CanExecute     â”‚                â”‚  â”‚
â”‚  â”‚                      â”‚  recalculated                â”‚                â”‚  â”‚
â”‚  â”‚                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Detailed Design

### FileTreeProposalViewModel

```csharp
// src/SeniorIntern.Desktop/ViewModels/FileTreeProposalViewModel.cs
using System.Collections.ObjectModel;
using System.ComponentModel;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using SeniorIntern.Core.Models;
using SeniorIntern.Core.Services;

namespace SeniorIntern.Desktop.ViewModels;

/// <summary>
/// ViewModel for displaying and managing a multi-file creation proposal.
/// Coordinates between the FileTreeProposal model, proposal service, and UI.
/// </summary>
public partial class FileTreeProposalViewModel : ViewModelBase
{
    private readonly IFileTreeProposalService _proposalService;
    private readonly IDiffService _diffService;
    private readonly ITreeBuildingService _treeBuildingService;
    private readonly string _workspacePath;
    private CancellationTokenSource? _applyCancellation;

    #region Observable Properties

    /// <summary>
    /// The underlying proposal model.
    /// </summary>
    [ObservableProperty]
    private FileTreeProposal _proposal;

    /// <summary>
    /// Hierarchical tree structure built from the proposal's operations.
    /// </summary>
    [ObservableProperty]
    private ObservableCollection<FileTreeItemViewModel> _treeItems = new();

    /// <summary>
    /// Currently selected item in the tree.
    /// </summary>
    [ObservableProperty]
    private FileTreeItemViewModel? _selectedItem;

    /// <summary>
    /// Human-readable description of the proposal.
    /// </summary>
    [ObservableProperty]
    private string? _description;

    /// <summary>
    /// Total number of files in the proposal.
    /// </summary>
    [ObservableProperty]
    private int _fileCount;

    /// <summary>
    /// Total number of directories in the proposal.
    /// </summary>
    [ObservableProperty]
    private int _directoryCount;

    /// <summary>
    /// Number of currently selected files.
    /// </summary>
    [ObservableProperty]
    private int _selectedCount;

    /// <summary>
    /// Whether any files are selected for creation.
    /// </summary>
    [ObservableProperty]
    [NotifyCanExecuteChangedFor(nameof(ApplyCommand))]
    [NotifyCanExecuteChangedFor(nameof(PreviewCommand))]
    private bool _hasSelectedFiles;

    /// <summary>
    /// Whether to create backups of existing files before overwriting.
    /// </summary>
    [ObservableProperty]
    private bool _createBackups = true;

    /// <summary>
    /// Whether an apply operation is currently in progress.
    /// </summary>
    [ObservableProperty]
    [NotifyCanExecuteChangedFor(nameof(ApplyCommand))]
    [NotifyCanExecuteChangedFor(nameof(PreviewCommand))]
    [NotifyCanExecuteChangedFor(nameof(SelectAllCommand))]
    [NotifyCanExecuteChangedFor(nameof(DeselectAllCommand))]
    [NotifyCanExecuteChangedFor(nameof(CancelCommand))]
    private bool _isApplying;

    /// <summary>
    /// Progress percentage of the current apply operation (0-100).
    /// </summary>
    [ObservableProperty]
    private double _applyProgress;

    /// <summary>
    /// Path of the file currently being processed.
    /// </summary>
    [ObservableProperty]
    private string _currentFile = string.Empty;

    /// <summary>
    /// Result of the most recent validation.
    /// </summary>
    [ObservableProperty]
    private ProposalValidationResult? _validationResult;

    /// <summary>
    /// Whether the validation found any warnings.
    /// </summary>
    [ObservableProperty]
    private bool _hasWarnings;

    /// <summary>
    /// Whether the validation found any errors.
    /// </summary>
    [ObservableProperty]
    [NotifyCanExecuteChangedFor(nameof(ApplyCommand))]
    private bool _hasErrors;

    #endregion

    #region Computed Properties

    /// <summary>
    /// Whether the apply operation can be executed.
    /// </summary>
    public bool CanApply => HasSelectedFiles && !IsApplying && !HasErrors;

    /// <summary>
    /// Summary text for the selection state.
    /// </summary>
    public string SelectionSummary => $"{SelectedCount} of {FileCount} files selected";

    /// <summary>
    /// Whether all files are currently selected.
    /// </summary>
    public bool AllFilesSelected => SelectedCount == FileCount && FileCount > 0;

    /// <summary>
    /// Whether no files are currently selected.
    /// </summary>
    public bool NoFilesSelected => SelectedCount == 0;

    #endregion

    #region Constructor

    /// <summary>
    /// Creates a new FileTreeProposalViewModel.
    /// </summary>
    /// <param name="proposal">The proposal to display.</param>
    /// <param name="proposalService">Service for validating and applying proposals.</param>
    /// <param name="diffService">Service for generating diffs.</param>
    /// <param name="treeBuildingService">Service for building tree structures.</param>
    /// <param name="workspacePath">The workspace root path.</param>
    public FileTreeProposalViewModel(
        FileTreeProposal proposal,
        IFileTreeProposalService proposalService,
        IDiffService diffService,
        ITreeBuildingService treeBuildingService,
        string workspacePath)
    {
        _proposal = proposal;
        _proposalService = proposalService;
        _diffService = diffService;
        _treeBuildingService = treeBuildingService;
        _workspacePath = workspacePath;

        Description = proposal.Description;
        FileCount = proposal.FileCount;
        DirectoryCount = proposal.DirectoryCount;

        BuildTree();
        UpdateSelectedCount();

        // Trigger async validation without blocking constructor
        _ = ValidateAsync();
    }

    #endregion

    #region Tree Building

    /// <summary>
    /// Builds the hierarchical tree structure from the proposal's flat operations list.
    /// </summary>
    private void BuildTree()
    {
        // Unsubscribe from existing items
        foreach (var item in GetAllItemsRecursive(TreeItems))
        {
            item.PropertyChanged -= OnFileItemPropertyChanged;
        }

        TreeItems.Clear();

        // Use the tree building service to create the hierarchy
        var treeItems = _treeBuildingService.BuildTree(Proposal);

        foreach (var item in treeItems)
        {
            TreeItems.Add(item);
        }

        // Subscribe to property changes for selection sync
        foreach (var item in GetAllItemsRecursive(TreeItems))
        {
            item.PropertyChanged += OnFileItemPropertyChanged;
        }
    }

    /// <summary>
    /// Rebuilds the tree structure, preserving expansion state where possible.
    /// </summary>
    public void RebuildTree()
    {
        // Capture current expansion state
        var expandedPaths = GetAllItemsRecursive(TreeItems)
            .Where(i => i.IsDirectory && i.IsExpanded)
            .Select(i => i.Path)
            .ToHashSet(StringComparer.OrdinalIgnoreCase);

        BuildTree();

        // Restore expansion state
        foreach (var item in GetAllItemsRecursive(TreeItems).Where(i => i.IsDirectory))
        {
            item.IsExpanded = expandedPaths.Contains(item.Path);
        }
    }

    /// <summary>
    /// Finds a tree item by its path.
    /// </summary>
    /// <param name="path">The relative path to search for.</param>
    /// <returns>The matching item, or null if not found.</returns>
    public FileTreeItemViewModel? FindItemByPath(string path)
    {
        return FindItemRecursive(TreeItems, path);
    }

    private FileTreeItemViewModel? FindItemRecursive(
        IEnumerable<FileTreeItemViewModel> items,
        string path)
    {
        foreach (var item in items)
        {
            if (item.Path.Equals(path, StringComparison.OrdinalIgnoreCase))
                return item;

            var found = FindItemRecursive(item.Children, path);
            if (found != null)
                return found;
        }
        return null;
    }

    /// <summary>
    /// Recursively enumerates all items in the tree.
    /// </summary>
    private IEnumerable<FileTreeItemViewModel> GetAllItemsRecursive(
        IEnumerable<FileTreeItemViewModel> items)
    {
        foreach (var item in items)
        {
            yield return item;
            foreach (var child in GetAllItemsRecursive(item.Children))
            {
                yield return child;
            }
        }
    }

    /// <summary>
    /// Gets all file items (non-directory) in the tree.
    /// </summary>
    private IEnumerable<FileTreeItemViewModel> GetAllFileItems()
    {
        return GetAllItemsRecursive(TreeItems).Where(i => !i.IsDirectory);
    }

    #endregion

    #region Selection Management

    /// <summary>
    /// Handles property changes on tree items, syncing selection state.
    /// </summary>
    private void OnFileItemPropertyChanged(object? sender, PropertyChangedEventArgs e)
    {
        if (e.PropertyName == nameof(FileTreeItemViewModel.IsSelected))
        {
            var item = (FileTreeItemViewModel)sender!;
            if (item.Operation != null)
            {
                item.Operation.IsSelected = item.IsSelected;
            }
            UpdateSelectedCount();
        }
    }

    /// <summary>
    /// Updates the selected count and related properties.
    /// </summary>
    private void UpdateSelectedCount()
    {
        SelectedCount = Proposal.SelectedCount;
        HasSelectedFiles = SelectedCount > 0;
        OnPropertyChanged(nameof(SelectionSummary));
        OnPropertyChanged(nameof(AllFilesSelected));
        OnPropertyChanged(nameof(NoFilesSelected));
    }

    /// <summary>
    /// Sets the selection state of all file items.
    /// </summary>
    /// <param name="selected">Whether items should be selected.</param>
    private void SetAllSelected(bool selected)
    {
        foreach (var item in GetAllFileItems())
        {
            item.IsSelected = selected;
        }
    }

    /// <summary>
    /// Propagates selection state from a parent to all its children.
    /// </summary>
    /// <param name="parent">The parent item.</param>
    /// <param name="selected">The selection state to propagate.</param>
    public void PropagateSelectionToChildren(FileTreeItemViewModel parent, bool selected)
    {
        foreach (var child in parent.Children)
        {
            if (!child.IsDirectory)
            {
                child.IsSelected = selected;
            }
            else
            {
                PropagateSelectionToChildren(child, selected);
            }
        }
    }

    /// <summary>
    /// Updates a directory's selection state based on its children.
    /// </summary>
    /// <param name="directory">The directory item to update.</param>
    public void UpdateDirectorySelectionState(FileTreeItemViewModel directory)
    {
        if (!directory.IsDirectory)
            return;

        var fileChildren = GetAllItemsRecursive(directory.Children)
            .Where(i => !i.IsDirectory)
            .ToList();

        if (fileChildren.Count == 0)
        {
            directory.SelectionState = SelectionState.None;
        }
        else if (fileChildren.All(f => f.IsSelected))
        {
            directory.SelectionState = SelectionState.All;
        }
        else if (fileChildren.Any(f => f.IsSelected))
        {
            directory.SelectionState = SelectionState.Some;
        }
        else
        {
            directory.SelectionState = SelectionState.None;
        }
    }

    #endregion

    #region Validation

    /// <summary>
    /// Validates the proposal asynchronously.
    /// </summary>
    private async Task ValidateAsync()
    {
        try
        {
            ValidationResult = await _proposalService.ValidateProposalAsync(
                Proposal, _workspacePath);

            HasWarnings = ValidationResult.HasWarnings;
            HasErrors = ValidationResult.HasErrors;

            UpdateValidationDisplay();
        }
        catch (Exception ex)
        {
            // Create an error result if validation itself fails
            ValidationResult = ProposalValidationResult.Invalid(
                new ValidationIssue
                {
                    Type = ValidationIssueType.Unknown,
                    Severity = ValidationSeverity.Error,
                    Message = $"Validation failed: {ex.Message}"
                });
            HasErrors = true;
        }
    }

    /// <summary>
    /// Updates tree items with validation issue information.
    /// </summary>
    private void UpdateValidationDisplay()
    {
        if (ValidationResult == null)
            return;

        // Clear existing validation issues
        foreach (var item in GetAllItemsRecursive(TreeItems))
        {
            item.ValidationIssue = null;
        }

        // Map issues to tree items
        foreach (var issue in ValidationResult.Issues)
        {
            var item = FindItemByPath(issue.Path);
            if (item != null)
            {
                item.ValidationIssue = issue;
            }
        }

        // Update file exists flags
        foreach (var item in GetAllFileItems())
        {
            item.FileExists = ValidationResult.Issues.Any(
                i => i.Path == item.Path && i.Type == ValidationIssueType.FileExists);
        }
    }

    /// <summary>
    /// Clears all validation issues from the tree.
    /// </summary>
    public void ClearValidationIssues()
    {
        foreach (var item in GetAllItemsRecursive(TreeItems))
        {
            item.ValidationIssue = null;
            item.FileExists = false;
        }
        ValidationResult = null;
        HasWarnings = false;
        HasErrors = false;
    }

    /// <summary>
    /// Re-validates the proposal.
    /// </summary>
    [RelayCommand]
    private async Task RevalidateAsync()
    {
        ClearValidationIssues();
        await ValidateAsync();
    }

    #endregion

    #region Commands

    /// <summary>
    /// Selects all files in the proposal.
    /// </summary>
    [RelayCommand(CanExecute = nameof(CanSelectOrDeselect))]
    private void SelectAll()
    {
        SetAllSelected(true);
    }

    /// <summary>
    /// Deselects all files in the proposal.
    /// </summary>
    [RelayCommand(CanExecute = nameof(CanSelectOrDeselect))]
    private void DeselectAll()
    {
        SetAllSelected(false);
    }

    private bool CanSelectOrDeselect() => !IsApplying;

    /// <summary>
    /// Toggles the selection state of a specific item.
    /// </summary>
    /// <param name="item">The item to toggle.</param>
    [RelayCommand]
    private void ToggleItemSelection(FileTreeItemViewModel? item)
    {
        if (item == null || IsApplying)
            return;

        if (item.IsDirectory)
        {
            // Toggle all children
            var newState = item.SelectionState != SelectionState.All;
            PropagateSelectionToChildren(item, newState);
            UpdateDirectorySelectionState(item);
        }
        else
        {
            item.IsSelected = !item.IsSelected;
        }
    }

    /// <summary>
    /// Expands all directory nodes in the tree.
    /// </summary>
    [RelayCommand]
    private void ExpandAll()
    {
        foreach (var item in GetAllItemsRecursive(TreeItems).Where(i => i.IsDirectory))
        {
            item.IsExpanded = true;
        }
    }

    /// <summary>
    /// Collapses all directory nodes in the tree.
    /// </summary>
    [RelayCommand]
    private void CollapseAll()
    {
        foreach (var item in GetAllItemsRecursive(TreeItems).Where(i => i.IsDirectory))
        {
            item.IsExpanded = false;
        }
    }

    /// <summary>
    /// Opens the batch preview dialog with diffs for all selected files.
    /// </summary>
    [RelayCommand(CanExecute = nameof(CanPreview))]
    private async Task PreviewAsync()
    {
        var diffs = await _proposalService.PreviewProposalAsync(Proposal, _workspacePath);
        PreviewRequested?.Invoke(this, diffs);
    }

    private bool CanPreview() => HasSelectedFiles && !IsApplying;

    /// <summary>
    /// Applies the proposal, creating all selected files.
    /// </summary>
    [RelayCommand(CanExecute = nameof(CanExecuteApply))]
    private async Task ApplyAsync()
    {
        if (!HasSelectedFiles || IsApplying)
            return;

        try
        {
            IsApplying = true;
            ApplyProgress = 0;
            CurrentFile = string.Empty;

            _applyCancellation = new CancellationTokenSource();

            var options = new ApplyOptions { CreateBackup = CreateBackups };
            var progress = new Progress<BatchApplyProgress>(OnProgressUpdate);

            var result = await _proposalService.ApplyProposalAsync(
                Proposal,
                _workspacePath,
                options,
                progress,
                _applyCancellation.Token);

            // Update tree items with operation results
            UpdateTreeWithResults(result);

            ApplyCompleted?.Invoke(this, result);
        }
        catch (OperationCanceledException)
        {
            ApplyCancelled?.Invoke(this, EventArgs.Empty);
        }
        finally
        {
            IsApplying = false;
            _applyCancellation?.Dispose();
            _applyCancellation = null;
        }
    }

    private bool CanExecuteApply() => CanApply;

    /// <summary>
    /// Cancels the in-progress apply operation.
    /// </summary>
    [RelayCommand(CanExecute = nameof(CanCancel))]
    private void Cancel()
    {
        _applyCancellation?.Cancel();
    }

    private bool CanCancel() => IsApplying;

    /// <summary>
    /// Handles progress updates during apply.
    /// </summary>
    private void OnProgressUpdate(BatchApplyProgress progress)
    {
        ApplyProgress = progress.ProgressPercent;
        CurrentFile = progress.CurrentFile;

        // Update the current item's status
        var item = FindItemByPath(progress.CurrentFile);
        if (item != null)
        {
            item.OperationStatus = FileOperationStatus.InProgress;
        }
    }

    /// <summary>
    /// Updates tree items with the results of the apply operation.
    /// </summary>
    private void UpdateTreeWithResults(BatchApplyResult result)
    {
        foreach (var opResult in result.Results)
        {
            var item = FindItemByPath(opResult.Path);
            if (item != null)
            {
                item.OperationStatus = opResult.Status;
                if (opResult.Status == FileOperationStatus.Failed)
                {
                    item.ValidationIssue = new ValidationIssue
                    {
                        Path = opResult.Path,
                        Type = ValidationIssueType.Unknown,
                        Severity = ValidationSeverity.Error,
                        Message = opResult.ErrorMessage ?? "Operation failed"
                    };
                }
            }
        }
    }

    #endregion

    #region Events

    /// <summary>
    /// Raised when the user requests to preview the changes.
    /// </summary>
    public event EventHandler<IReadOnlyList<DiffResult>>? PreviewRequested;

    /// <summary>
    /// Raised when the apply operation completes.
    /// </summary>
    public event EventHandler<BatchApplyResult>? ApplyCompleted;

    /// <summary>
    /// Raised when the apply operation is cancelled.
    /// </summary>
    public event EventHandler? ApplyCancelled;

    #endregion

    #region Cleanup

    /// <summary>
    /// Cleans up resources and event handlers.
    /// </summary>
    public void Dispose()
    {
        foreach (var item in GetAllItemsRecursive(TreeItems))
        {
            item.PropertyChanged -= OnFileItemPropertyChanged;
        }

        _applyCancellation?.Dispose();
    }

    #endregion
}
```

### FileTreeItemViewModel

```csharp
// src/SeniorIntern.Desktop/ViewModels/FileTreeItemViewModel.cs
using System.Collections.ObjectModel;
using CommunityToolkit.Mvvm.ComponentModel;
using SeniorIntern.Core.Models;

namespace SeniorIntern.Desktop.ViewModels;

/// <summary>
/// ViewModel representing a single item (file or directory) in the file tree.
/// </summary>
public partial class FileTreeItemViewModel : ViewModelBase
{
    #region Identity Properties

    /// <summary>
    /// Display name of the item (file or directory name without path).
    /// </summary>
    [ObservableProperty]
    private string _name = string.Empty;

    /// <summary>
    /// Relative path from the workspace root.
    /// </summary>
    [ObservableProperty]
    private string _path = string.Empty;

    /// <summary>
    /// Whether this item represents a directory.
    /// </summary>
    [ObservableProperty]
    private bool _isDirectory;

    /// <summary>
    /// The underlying FileOperation for file items. Null for directory items.
    /// </summary>
    [ObservableProperty]
    private FileOperation? _operation;

    #endregion

    #region State Properties

    /// <summary>
    /// Whether a directory node is expanded in the tree view.
    /// </summary>
    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(Icon))]
    private bool _isExpanded = true;

    /// <summary>
    /// Whether a file is selected for creation/modification.
    /// </summary>
    [ObservableProperty]
    private bool _isSelected = true;

    /// <summary>
    /// Whether the item is enabled for interaction.
    /// </summary>
    [ObservableProperty]
    private bool _isEnabled = true;

    /// <summary>
    /// Whether the item should be visually highlighted.
    /// </summary>
    [ObservableProperty]
    private bool _isHighlighted;

    /// <summary>
    /// Selection state for directory items (None, Some, All).
    /// </summary>
    [ObservableProperty]
    private SelectionState _selectionState = SelectionState.All;

    #endregion

    #region Display Properties

    /// <summary>
    /// Programming language identifier for syntax highlighting indication.
    /// </summary>
    [ObservableProperty]
    private string? _language;

    /// <summary>
    /// Whether a file with this path already exists in the workspace.
    /// </summary>
    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(StatusText))]
    private bool _fileExists;

    /// <summary>
    /// Validation issue associated with this item.
    /// </summary>
    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(HasWarning))]
    [NotifyPropertyChangedFor(nameof(HasError))]
    [NotifyPropertyChangedFor(nameof(Tooltip))]
    private ValidationIssue? _validationIssue;

    /// <summary>
    /// Current status of the file operation (during/after apply).
    /// </summary>
    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(StatusText))]
    [NotifyPropertyChangedFor(nameof(StatusIcon))]
    private FileOperationStatus? _operationStatus;

    /// <summary>
    /// Child items (files and subdirectories).
    /// </summary>
    [ObservableProperty]
    private ObservableCollection<FileTreeItemViewModel> _children = new();

    #endregion

    #region Computed Properties

    /// <summary>
    /// Whether this item represents a file (not a directory).
    /// </summary>
    public bool IsFile => !IsDirectory;

    /// <summary>
    /// Whether this item has child items.
    /// </summary>
    public bool HasChildren => Children.Count > 0;

    /// <summary>
    /// Whether the validation issue is a warning.
    /// </summary>
    public bool HasWarning => ValidationIssue?.Severity == ValidationSeverity.Warning;

    /// <summary>
    /// Whether the validation issue is an error.
    /// </summary>
    public bool HasError => ValidationIssue?.Severity == ValidationSeverity.Error;

    /// <summary>
    /// Whether there is any validation issue.
    /// </summary>
    public bool HasValidationIssue => ValidationIssue != null;

    /// <summary>
    /// Icon resource name based on item type and state.
    /// </summary>
    public string Icon => IsDirectory
        ? (IsExpanded ? "FolderOpenIcon" : "FolderIcon")
        : GetFileIcon();

    /// <summary>
    /// Status text displayed next to the item.
    /// </summary>
    public string StatusText => OperationStatus switch
    {
        FileOperationStatus.Applied => "Created",
        FileOperationStatus.Failed => "Failed",
        FileOperationStatus.Skipped => "Skipped",
        FileOperationStatus.InProgress => "Creating...",
        _ => FileExists ? "Exists" : ""
    };

    /// <summary>
    /// Status icon resource name based on operation status.
    /// </summary>
    public string? StatusIcon => OperationStatus switch
    {
        FileOperationStatus.Applied => "CheckIcon",
        FileOperationStatus.Failed => "ErrorIcon",
        FileOperationStatus.Skipped => "SkipIcon",
        FileOperationStatus.InProgress => "SpinnerIcon",
        _ => null
    };

    /// <summary>
    /// Tooltip text with path and any validation messages.
    /// </summary>
    public string Tooltip
    {
        get
        {
            var lines = new List<string> { Path };

            if (ValidationIssue != null)
            {
                lines.Add(string.Empty);
                lines.Add(ValidationIssue.Message);
                if (!string.IsNullOrEmpty(ValidationIssue.SuggestedFix))
                {
                    lines.Add($"Suggestion: {ValidationIssue.SuggestedFix}");
                }
            }

            if (Operation != null)
            {
                lines.Add(string.Empty);
                lines.Add($"Lines: {Operation.LineCount}");
                lines.Add($"Size: {FormatSize(Operation.ContentSizeBytes)}");
            }

            return string.Join(Environment.NewLine, lines);
        }
    }

    /// <summary>
    /// File extension without the dot.
    /// </summary>
    public string Extension => System.IO.Path.GetExtension(Path).TrimStart('.');

    /// <summary>
    /// Whether this is a new file (Create operation) vs modification.
    /// </summary>
    public bool IsNewFile => Operation?.Type == FileOperationType.Create;

    /// <summary>
    /// Whether this is a modification of an existing file.
    /// </summary>
    public bool IsModification => Operation?.Type == FileOperationType.Modify;

    /// <summary>
    /// Depth level in the tree (0 = root).
    /// </summary>
    public int Depth => Path.Count(c => c == '/' || c == '\\');

    #endregion

    #region Methods

    /// <summary>
    /// Gets the appropriate icon resource name based on file extension.
    /// </summary>
    private string GetFileIcon()
    {
        return System.IO.Path.GetExtension(_path).ToLowerInvariant() switch
        {
            ".cs" => "CSharpIcon",
            ".ts" or ".tsx" => "TypeScriptIcon",
            ".js" or ".jsx" or ".mjs" => "JavaScriptIcon",
            ".py" => "PythonIcon",
            ".json" => "JsonIcon",
            ".xml" or ".axaml" or ".xaml" => "XmlIcon",
            ".md" or ".markdown" => "MarkdownIcon",
            ".html" or ".htm" => "HtmlIcon",
            ".css" or ".scss" or ".sass" or ".less" => "CssIcon",
            ".yaml" or ".yml" => "YamlIcon",
            ".sql" => "SqlIcon",
            ".sh" or ".bash" => "BashIcon",
            ".ps1" => "PowerShellIcon",
            ".java" => "JavaIcon",
            ".rb" => "RubyIcon",
            ".go" => "GoIcon",
            ".rs" => "RustIcon",
            ".cpp" or ".cc" or ".cxx" or ".c" or ".h" or ".hpp" => "CppIcon",
            ".swift" => "SwiftIcon",
            ".kt" or ".kts" => "KotlinIcon",
            ".php" => "PhpIcon",
            ".vue" => "VueIcon",
            ".svelte" => "SvelteIcon",
            ".razor" => "RazorIcon",
            ".sln" or ".csproj" or ".fsproj" or ".vbproj" => "ProjectIcon",
            ".gitignore" or ".gitattributes" => "GitIcon",
            ".dockerfile" or ".dockerignore" => "DockerIcon",
            ".env" or ".env.example" => "EnvIcon",
            _ => "FileIcon"
        };
    }

    /// <summary>
    /// Formats a byte size as a human-readable string.
    /// </summary>
    private static string FormatSize(long bytes)
    {
        string[] suffixes = { "B", "KB", "MB", "GB" };
        int suffixIndex = 0;
        double size = bytes;

        while (size >= 1024 && suffixIndex < suffixes.Length - 1)
        {
            size /= 1024;
            suffixIndex++;
        }

        return $"{size:0.##} {suffixes[suffixIndex]}";
    }

    /// <summary>
    /// Updates the ViewModel state from the associated FileOperation.
    /// </summary>
    public void UpdateFromOperation()
    {
        if (Operation == null)
            return;

        IsSelected = Operation.IsSelected;
        OperationStatus = Operation.Status;
        Language = Operation.DisplayLanguage;
    }

    /// <summary>
    /// Clears validation state from this item.
    /// </summary>
    public void ClearValidation()
    {
        ValidationIssue = null;
        FileExists = false;
    }

    /// <summary>
    /// Resets the operation status to pending.
    /// </summary>
    public void ResetStatus()
    {
        OperationStatus = null;
    }

    #endregion

    #region Partial Methods

    partial void OnIsExpandedChanged(bool value)
    {
        OnPropertyChanged(nameof(Icon));
    }

    partial void OnIsSelectedChanged(bool value)
    {
        // Update parent directory selection state if needed
        // This is typically handled by the parent ViewModel
    }

    #endregion
}

/// <summary>
/// Represents the selection state of a directory based on its children.
/// </summary>
public enum SelectionState
{
    /// <summary>
    /// No children are selected.
    /// </summary>
    None,

    /// <summary>
    /// Some (but not all) children are selected.
    /// </summary>
    Some,

    /// <summary>
    /// All children are selected.
    /// </summary>
    All
}
```

### ITreeBuildingService Interface

```csharp
// src/SeniorIntern.Core/Services/ITreeBuildingService.cs
using SeniorIntern.Core.Models;
using SeniorIntern.Desktop.ViewModels;

namespace SeniorIntern.Core.Services;

/// <summary>
/// Service for building hierarchical tree structures from flat file operation lists.
/// </summary>
public interface ITreeBuildingService
{
    /// <summary>
    /// Builds a tree structure from a FileTreeProposal.
    /// </summary>
    /// <param name="proposal">The proposal containing file operations.</param>
    /// <param name="options">Optional tree building configuration.</param>
    /// <returns>A list of root-level tree items.</returns>
    IReadOnlyList<FileTreeItemViewModel> BuildTree(
        FileTreeProposal proposal,
        TreeBuildingOptions? options = null);

    /// <summary>
    /// Builds a tree structure from a collection of file operations.
    /// </summary>
    /// <param name="operations">The file operations to organize.</param>
    /// <param name="options">Optional tree building configuration.</param>
    /// <returns>A list of root-level tree items.</returns>
    IReadOnlyList<FileTreeItemViewModel> BuildTreeFromOperations(
        IEnumerable<FileOperation> operations,
        TreeBuildingOptions? options = null);

    /// <summary>
    /// Flattens a tree structure into a sequential enumeration.
    /// </summary>
    /// <param name="items">The root items to flatten.</param>
    /// <param name="includeDirectories">Whether to include directory nodes.</param>
    /// <returns>A flat enumeration of all items.</returns>
    IEnumerable<FileTreeItemViewModel> FlattenTree(
        IEnumerable<FileTreeItemViewModel> items,
        bool includeDirectories = true);

    /// <summary>
    /// Finds all items matching a predicate.
    /// </summary>
    /// <param name="items">The root items to search.</param>
    /// <param name="predicate">The matching condition.</param>
    /// <returns>All matching items.</returns>
    IEnumerable<FileTreeItemViewModel> FindAll(
        IEnumerable<FileTreeItemViewModel> items,
        Func<FileTreeItemViewModel, bool> predicate);
}

/// <summary>
/// Configuration options for tree building.
/// </summary>
/// <param name="SortDirectoriesFirst">Whether to sort directories before files. Default: true.</param>
/// <param name="ExpandByDefault">Whether directories are expanded by default. Default: true.</param>
/// <param name="HideCommonRootPath">Whether to hide the common root path. Default: false.</param>
/// <param name="SelectByDefault">Whether files are selected by default. Default: true.</param>
/// <param name="SortAlphabetically">Whether to sort items alphabetically. Default: true.</param>
public record TreeBuildingOptions(
    bool SortDirectoriesFirst = true,
    bool ExpandByDefault = true,
    bool HideCommonRootPath = false,
    bool SelectByDefault = true,
    bool SortAlphabetically = true);
```

### TreeBuildingService Implementation

```csharp
// src/SeniorIntern.Core/Services/TreeBuildingService.cs
using SeniorIntern.Core.Models;
using SeniorIntern.Desktop.ViewModels;

namespace SeniorIntern.Core.Services;

/// <summary>
/// Default implementation of ITreeBuildingService.
/// Builds hierarchical tree structures from flat file operation lists.
/// </summary>
public class TreeBuildingService : ITreeBuildingService
{
    private static readonly TreeBuildingOptions DefaultOptions = new();

    /// <inheritdoc />
    public IReadOnlyList<FileTreeItemViewModel> BuildTree(
        FileTreeProposal proposal,
        TreeBuildingOptions? options = null)
    {
        return BuildTreeFromOperations(proposal.Operations, options);
    }

    /// <inheritdoc />
    public IReadOnlyList<FileTreeItemViewModel> BuildTreeFromOperations(
        IEnumerable<FileOperation> operations,
        TreeBuildingOptions? options = null)
    {
        options ??= DefaultOptions;

        var operationsList = operations.ToList();
        if (operationsList.Count == 0)
            return Array.Empty<FileTreeItemViewModel>();

        var result = new List<FileTreeItemViewModel>();
        var directoryNodes = new Dictionary<string, FileTreeItemViewModel>(
            StringComparer.OrdinalIgnoreCase);

        // Group operations by directory
        var grouped = operationsList
            .GroupBy(o => GetDirectoryPath(o.Path))
            .OrderBy(g => g.Key);

        foreach (var group in grouped)
        {
            // Create directory nodes for the path
            var parent = EnsureDirectoryPath(
                group.Key,
                directoryNodes,
                result,
                options);

            // Add file nodes
            var fileItems = group
                .OrderBy(o => o.FileName)
                .Select(op => CreateFileItem(op, options));

            foreach (var fileItem in fileItems)
            {
                if (parent != null)
                {
                    parent.Children.Add(fileItem);
                }
                else
                {
                    result.Add(fileItem);
                }
            }
        }

        // Sort the result
        if (options.SortAlphabetically)
        {
            SortTree(result, options.SortDirectoriesFirst);
        }

        return result.AsReadOnly();
    }

    /// <inheritdoc />
    public IEnumerable<FileTreeItemViewModel> FlattenTree(
        IEnumerable<FileTreeItemViewModel> items,
        bool includeDirectories = true)
    {
        foreach (var item in items)
        {
            if (includeDirectories || !item.IsDirectory)
            {
                yield return item;
            }

            foreach (var child in FlattenTree(item.Children, includeDirectories))
            {
                yield return child;
            }
        }
    }

    /// <inheritdoc />
    public IEnumerable<FileTreeItemViewModel> FindAll(
        IEnumerable<FileTreeItemViewModel> items,
        Func<FileTreeItemViewModel, bool> predicate)
    {
        return FlattenTree(items).Where(predicate);
    }

    /// <summary>
    /// Gets the directory path from a file path.
    /// </summary>
    private static string GetDirectoryPath(string filePath)
    {
        return Path.GetDirectoryName(filePath)?.Replace('\\', '/') ?? string.Empty;
    }

    /// <summary>
    /// Ensures all directory nodes exist for a path, creating them as needed.
    /// </summary>
    private FileTreeItemViewModel? EnsureDirectoryPath(
        string directoryPath,
        Dictionary<string, FileTreeItemViewModel> directoryNodes,
        List<FileTreeItemViewModel> rootItems,
        TreeBuildingOptions options)
    {
        if (string.IsNullOrEmpty(directoryPath))
            return null;

        // Normalize path separators
        directoryPath = directoryPath.Replace('\\', '/');

        // Check if already exists
        if (directoryNodes.TryGetValue(directoryPath, out var existingNode))
            return existingNode;

        // Split path into parts
        var parts = directoryPath.Split('/')
            .Where(p => !string.IsNullOrEmpty(p))
            .ToList();

        FileTreeItemViewModel? parent = null;

        // Create directory nodes for each path segment
        for (int i = 0; i < parts.Count; i++)
        {
            var partPath = string.Join("/", parts.Take(i + 1));

            if (!directoryNodes.TryGetValue(partPath, out var dirItem))
            {
                dirItem = new FileTreeItemViewModel
                {
                    Name = parts[i],
                    Path = partPath,
                    IsDirectory = true,
                    IsExpanded = options.ExpandByDefault,
                    IsSelected = options.SelectByDefault
                };

                directoryNodes[partPath] = dirItem;

                if (parent == null)
                {
                    rootItems.Add(dirItem);
                }
                else
                {
                    parent.Children.Add(dirItem);
                }
            }

            parent = dirItem;
        }

        return parent;
    }

    /// <summary>
    /// Creates a file item ViewModel from a FileOperation.
    /// </summary>
    private static FileTreeItemViewModel CreateFileItem(
        FileOperation operation,
        TreeBuildingOptions options)
    {
        return new FileTreeItemViewModel
        {
            Name = operation.FileName,
            Path = operation.Path,
            IsDirectory = false,
            Operation = operation,
            Language = operation.DisplayLanguage,
            IsSelected = options.SelectByDefault && operation.IsSelected,
            IsExpanded = false
        };
    }

    /// <summary>
    /// Recursively sorts a tree structure.
    /// </summary>
    private static void SortTree(List<FileTreeItemViewModel> items, bool directoriesFirst)
    {
        items.Sort((a, b) =>
        {
            if (directoriesFirst)
            {
                if (a.IsDirectory != b.IsDirectory)
                    return a.IsDirectory ? -1 : 1;
            }
            return string.Compare(a.Name, b.Name, StringComparison.OrdinalIgnoreCase);
        });

        foreach (var item in items.Where(i => i.IsDirectory))
        {
            var childList = item.Children.ToList();
            SortTree(childList, directoriesFirst);
            item.Children.Clear();
            foreach (var child in childList)
            {
                item.Children.Add(child);
            }
        }
    }
}
```

### TreeNodeSelectionBehavior Enum

```csharp
// src/SeniorIntern.Core/Models/TreeNodeSelectionBehavior.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Defines how selection state propagates between parent and child nodes.
/// </summary>
public enum TreeNodeSelectionBehavior
{
    /// <summary>
    /// Each item's selection is independent of others.
    /// </summary>
    Independent,

    /// <summary>
    /// Selecting a parent automatically selects all children.
    /// </summary>
    CascadeToChildren,

    /// <summary>
    /// Child selection updates parent state (None/Some/All).
    /// </summary>
    CascadeToParent,

    /// <summary>
    /// Selection cascades both directions.
    /// </summary>
    CascadeBoth
}
```

---

## Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/ViewModels/FileTreeProposalViewModel.cs` | Main proposal ViewModel |
| `src/SeniorIntern.Desktop/ViewModels/FileTreeItemViewModel.cs` | Tree item ViewModel |
| `src/SeniorIntern.Core/Services/ITreeBuildingService.cs` | Tree building interface |
| `src/SeniorIntern.Core/Services/TreeBuildingService.cs` | Tree building implementation |
| `src/SeniorIntern.Core/Models/TreeNodeSelectionBehavior.cs` | Selection behavior enum |
| `tests/SeniorIntern.Desktop.Tests/ViewModels/FileTreeProposalViewModelTests.cs` | Proposal VM tests |
| `tests/SeniorIntern.Desktop.Tests/ViewModels/FileTreeItemViewModelTests.cs` | Item VM tests |
| `tests/SeniorIntern.Core.Tests/Services/TreeBuildingServiceTests.cs` | Tree building tests |

---

## Files to Modify

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/ViewModels/ViewModelBase.cs` | Ensure base class exists with INotifyPropertyChanged |
| `src/SeniorIntern.Core/DependencyInjection.cs` | Register ITreeBuildingService |

---

## Testing Strategy

### Unit Tests

```csharp
// tests/SeniorIntern.Desktop.Tests/ViewModels/FileTreeProposalViewModelTests.cs
using Moq;
using Xunit;
using SeniorIntern.Core.Models;
using SeniorIntern.Core.Services;
using SeniorIntern.Desktop.ViewModels;

namespace SeniorIntern.Desktop.Tests.ViewModels;

public class FileTreeProposalViewModelTests
{
    private readonly Mock<IFileTreeProposalService> _proposalServiceMock;
    private readonly Mock<IDiffService> _diffServiceMock;
    private readonly Mock<ITreeBuildingService> _treeBuildingServiceMock;
    private readonly string _workspacePath = "/test/workspace";

    public FileTreeProposalViewModelTests()
    {
        _proposalServiceMock = new Mock<IFileTreeProposalService>();
        _diffServiceMock = new Mock<IDiffService>();
        _treeBuildingServiceMock = new Mock<ITreeBuildingService>();

        // Setup default returns
        _treeBuildingServiceMock
            .Setup(x => x.BuildTree(It.IsAny<FileTreeProposal>(), It.IsAny<TreeBuildingOptions?>()))
            .Returns((FileTreeProposal p, TreeBuildingOptions? o) =>
            {
                var service = new TreeBuildingService();
                return service.BuildTree(p, o);
            });

        _proposalServiceMock
            .Setup(x => x.ValidateProposalAsync(It.IsAny<FileTreeProposal>(), It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(ProposalValidationResult.Valid());
    }

    private FileTreeProposalViewModel CreateViewModel(FileTreeProposal proposal)
    {
        return new FileTreeProposalViewModel(
            proposal,
            _proposalServiceMock.Object,
            _diffServiceMock.Object,
            _treeBuildingServiceMock.Object,
            _workspacePath);
    }

    [Fact]
    public void Constructor_SetsDescriptionFromProposal()
    {
        var proposal = new FileTreeProposal
        {
            Description = "Test proposal description",
            Operations = new List<FileOperation>()
        };

        var viewModel = CreateViewModel(proposal);

        Assert.Equal("Test proposal description", viewModel.Description);
    }

    [Fact]
    public void Constructor_SetsFileCountFromProposal()
    {
        var proposal = new FileTreeProposal
        {
            Operations = new List<FileOperation>
            {
                new FileOperation { Path = "src/File1.cs", Type = FileOperationType.Create },
                new FileOperation { Path = "src/File2.cs", Type = FileOperationType.Create },
                new FileOperation { Path = "src/File3.cs", Type = FileOperationType.Create }
            }
        };

        var viewModel = CreateViewModel(proposal);

        Assert.Equal(3, viewModel.FileCount);
    }

    [Fact]
    public void Constructor_BuildsTreeStructure()
    {
        var proposal = new FileTreeProposal
        {
            Operations = new List<FileOperation>
            {
                new FileOperation { Path = "src/Services/UserService.cs" },
                new FileOperation { Path = "src/Services/AuthService.cs" }
            }
        };

        var viewModel = CreateViewModel(proposal);

        Assert.NotEmpty(viewModel.TreeItems);
    }

    [Fact]
    public void SelectAll_SelectsAllFiles()
    {
        var proposal = new FileTreeProposal
        {
            Operations = new List<FileOperation>
            {
                new FileOperation { Path = "file1.cs", IsSelected = false },
                new FileOperation { Path = "file2.cs", IsSelected = false }
            }
        };

        var viewModel = CreateViewModel(proposal);
        viewModel.SelectAllCommand.Execute(null);

        Assert.True(viewModel.Proposal.Operations.All(o => o.IsSelected));
    }

    [Fact]
    public void DeselectAll_DeselectsAllFiles()
    {
        var proposal = new FileTreeProposal
        {
            Operations = new List<FileOperation>
            {
                new FileOperation { Path = "file1.cs", IsSelected = true },
                new FileOperation { Path = "file2.cs", IsSelected = true }
            }
        };

        var viewModel = CreateViewModel(proposal);
        viewModel.DeselectAllCommand.Execute(null);

        Assert.True(viewModel.Proposal.Operations.All(o => !o.IsSelected));
    }

    [Fact]
    public void SelectedCount_UpdatesWhenSelectionChanges()
    {
        var proposal = new FileTreeProposal
        {
            Operations = new List<FileOperation>
            {
                new FileOperation { Path = "file1.cs", IsSelected = true },
                new FileOperation { Path = "file2.cs", IsSelected = true }
            }
        };

        var viewModel = CreateViewModel(proposal);

        Assert.Equal(2, viewModel.SelectedCount);

        var fileItem = viewModel.FindItemByPath("file1.cs");
        fileItem!.IsSelected = false;

        Assert.Equal(1, viewModel.SelectedCount);
    }

    [Fact]
    public void HasSelectedFiles_TrueWhenFilesSelected()
    {
        var proposal = new FileTreeProposal
        {
            Operations = new List<FileOperation>
            {
                new FileOperation { Path = "file1.cs", IsSelected = true }
            }
        };

        var viewModel = CreateViewModel(proposal);

        Assert.True(viewModel.HasSelectedFiles);
    }

    [Fact]
    public void HasSelectedFiles_FalseWhenNoFilesSelected()
    {
        var proposal = new FileTreeProposal
        {
            Operations = new List<FileOperation>
            {
                new FileOperation { Path = "file1.cs", IsSelected = false }
            }
        };

        var viewModel = CreateViewModel(proposal);

        Assert.False(viewModel.HasSelectedFiles);
    }

    [Fact]
    public void FindItemByPath_FindsExistingItem()
    {
        var proposal = new FileTreeProposal
        {
            Operations = new List<FileOperation>
            {
                new FileOperation { Path = "src/Services/UserService.cs" }
            }
        };

        var viewModel = CreateViewModel(proposal);

        var item = viewModel.FindItemByPath("src/Services/UserService.cs");

        Assert.NotNull(item);
        Assert.Equal("UserService.cs", item.Name);
    }

    [Fact]
    public void FindItemByPath_ReturnsNullForNonExistent()
    {
        var proposal = new FileTreeProposal
        {
            Operations = new List<FileOperation>
            {
                new FileOperation { Path = "src/Services/UserService.cs" }
            }
        };

        var viewModel = CreateViewModel(proposal);

        var item = viewModel.FindItemByPath("nonexistent/path.cs");

        Assert.Null(item);
    }

    [Fact]
    public async Task ApplyAsync_SetsIsApplyingDuringOperation()
    {
        var proposal = new FileTreeProposal
        {
            Operations = new List<FileOperation>
            {
                new FileOperation { Path = "file.cs", IsSelected = true }
            }
        };

        var tcs = new TaskCompletionSource<BatchApplyResult>();
        _proposalServiceMock
            .Setup(x => x.ApplyProposalAsync(
                It.IsAny<FileTreeProposal>(),
                It.IsAny<string>(),
                It.IsAny<ApplyOptions>(),
                It.IsAny<IProgress<BatchApplyProgress>>(),
                It.IsAny<CancellationToken>()))
            .Returns(tcs.Task);

        var viewModel = CreateViewModel(proposal);

        var applyTask = viewModel.ApplyCommand.ExecuteAsync(null);

        Assert.True(viewModel.IsApplying);

        tcs.SetResult(BatchApplyResult.Success(new List<ApplyResult>(), DateTime.UtcNow));
        await applyTask;

        Assert.False(viewModel.IsApplying);
    }

    [Fact]
    public async Task ApplyAsync_RaisesApplyCompletedEvent()
    {
        var proposal = new FileTreeProposal
        {
            Operations = new List<FileOperation>
            {
                new FileOperation { Path = "file.cs", IsSelected = true }
            }
        };

        var expectedResult = BatchApplyResult.Success(new List<ApplyResult>(), DateTime.UtcNow);
        _proposalServiceMock
            .Setup(x => x.ApplyProposalAsync(
                It.IsAny<FileTreeProposal>(),
                It.IsAny<string>(),
                It.IsAny<ApplyOptions>(),
                It.IsAny<IProgress<BatchApplyProgress>>(),
                It.IsAny<CancellationToken>()))
            .ReturnsAsync(expectedResult);

        var viewModel = CreateViewModel(proposal);
        BatchApplyResult? receivedResult = null;
        viewModel.ApplyCompleted += (_, result) => receivedResult = result;

        await viewModel.ApplyCommand.ExecuteAsync(null);

        Assert.NotNull(receivedResult);
        Assert.True(receivedResult.AllSucceeded);
    }

    [Fact]
    public void ApplyCommand_CannotExecuteWhenNoFilesSelected()
    {
        var proposal = new FileTreeProposal
        {
            Operations = new List<FileOperation>
            {
                new FileOperation { Path = "file.cs", IsSelected = false }
            }
        };

        var viewModel = CreateViewModel(proposal);

        Assert.False(viewModel.ApplyCommand.CanExecute(null));
    }

    [Fact]
    public async Task PreviewAsync_RaisesPreviewRequestedEvent()
    {
        var proposal = new FileTreeProposal
        {
            Operations = new List<FileOperation>
            {
                new FileOperation { Path = "file.cs", IsSelected = true }
            }
        };

        var expectedDiffs = new List<DiffResult>();
        _proposalServiceMock
            .Setup(x => x.PreviewProposalAsync(It.IsAny<FileTreeProposal>(), It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(expectedDiffs);

        var viewModel = CreateViewModel(proposal);
        IReadOnlyList<DiffResult>? receivedDiffs = null;
        viewModel.PreviewRequested += (_, diffs) => receivedDiffs = diffs;

        await viewModel.PreviewCommand.ExecuteAsync(null);

        Assert.NotNull(receivedDiffs);
    }

    [Fact]
    public void ExpandAll_ExpandsAllDirectories()
    {
        var proposal = new FileTreeProposal
        {
            Operations = new List<FileOperation>
            {
                new FileOperation { Path = "src/Services/UserService.cs" },
                new FileOperation { Path = "tests/Services/UserServiceTests.cs" }
            }
        };

        var viewModel = CreateViewModel(proposal);

        // Collapse all first
        viewModel.CollapseAllCommand.Execute(null);

        // Expand all
        viewModel.ExpandAllCommand.Execute(null);

        var directories = viewModel.TreeItems
            .SelectMany(item => GetAllItems(item))
            .Where(i => i.IsDirectory);

        Assert.All(directories, d => Assert.True(d.IsExpanded));
    }

    private IEnumerable<FileTreeItemViewModel> GetAllItems(FileTreeItemViewModel item)
    {
        yield return item;
        foreach (var child in item.Children.SelectMany(GetAllItems))
        {
            yield return child;
        }
    }
}
```

### FileTreeItemViewModel Tests

```csharp
// tests/SeniorIntern.Desktop.Tests/ViewModels/FileTreeItemViewModelTests.cs
using Xunit;
using SeniorIntern.Core.Models;
using SeniorIntern.Desktop.ViewModels;

namespace SeniorIntern.Desktop.Tests.ViewModels;

public class FileTreeItemViewModelTests
{
    [Fact]
    public void IsFile_TrueWhenNotDirectory()
    {
        var item = new FileTreeItemViewModel
        {
            IsDirectory = false
        };

        Assert.True(item.IsFile);
    }

    [Fact]
    public void IsFile_FalseWhenDirectory()
    {
        var item = new FileTreeItemViewModel
        {
            IsDirectory = true
        };

        Assert.False(item.IsFile);
    }

    [Fact]
    public void HasChildren_TrueWhenChildrenExist()
    {
        var item = new FileTreeItemViewModel();
        item.Children.Add(new FileTreeItemViewModel());

        Assert.True(item.HasChildren);
    }

    [Fact]
    public void HasChildren_FalseWhenEmpty()
    {
        var item = new FileTreeItemViewModel();

        Assert.False(item.HasChildren);
    }

    [Theory]
    [InlineData(".cs", "CSharpIcon")]
    [InlineData(".ts", "TypeScriptIcon")]
    [InlineData(".tsx", "TypeScriptIcon")]
    [InlineData(".js", "JavaScriptIcon")]
    [InlineData(".py", "PythonIcon")]
    [InlineData(".json", "JsonIcon")]
    [InlineData(".md", "MarkdownIcon")]
    [InlineData(".unknown", "FileIcon")]
    public void Icon_ReturnsCorrectIconForExtension(string extension, string expectedIcon)
    {
        var item = new FileTreeItemViewModel
        {
            Path = $"test{extension}",
            IsDirectory = false
        };

        Assert.Equal(expectedIcon, item.Icon);
    }

    [Fact]
    public void Icon_ReturnsFolderIconForCollapsedDirectory()
    {
        var item = new FileTreeItemViewModel
        {
            IsDirectory = true,
            IsExpanded = false
        };

        Assert.Equal("FolderIcon", item.Icon);
    }

    [Fact]
    public void Icon_ReturnsFolderOpenIconForExpandedDirectory()
    {
        var item = new FileTreeItemViewModel
        {
            IsDirectory = true,
            IsExpanded = true
        };

        Assert.Equal("FolderOpenIcon", item.Icon);
    }

    [Fact]
    public void HasWarning_TrueWhenValidationIssueIsWarning()
    {
        var item = new FileTreeItemViewModel
        {
            ValidationIssue = new ValidationIssue
            {
                Severity = ValidationSeverity.Warning
            }
        };

        Assert.True(item.HasWarning);
        Assert.False(item.HasError);
    }

    [Fact]
    public void HasError_TrueWhenValidationIssueIsError()
    {
        var item = new FileTreeItemViewModel
        {
            ValidationIssue = new ValidationIssue
            {
                Severity = ValidationSeverity.Error
            }
        };

        Assert.True(item.HasError);
        Assert.False(item.HasWarning);
    }

    [Theory]
    [InlineData(FileOperationStatus.Applied, "Created")]
    [InlineData(FileOperationStatus.Failed, "Failed")]
    [InlineData(FileOperationStatus.Skipped, "Skipped")]
    [InlineData(FileOperationStatus.InProgress, "Creating...")]
    public void StatusText_ReturnsCorrectTextForOperationStatus(
        FileOperationStatus status,
        string expectedText)
    {
        var item = new FileTreeItemViewModel
        {
            OperationStatus = status
        };

        Assert.Equal(expectedText, item.StatusText);
    }

    [Fact]
    public void StatusText_ReturnsExistsWhenFileExists()
    {
        var item = new FileTreeItemViewModel
        {
            FileExists = true,
            OperationStatus = null
        };

        Assert.Equal("Exists", item.StatusText);
    }

    [Fact]
    public void StatusText_ReturnsEmptyWhenNoStatusAndFileNotExists()
    {
        var item = new FileTreeItemViewModel
        {
            FileExists = false,
            OperationStatus = null
        };

        Assert.Equal("", item.StatusText);
    }

    [Fact]
    public void Tooltip_IncludesPath()
    {
        var item = new FileTreeItemViewModel
        {
            Path = "src/Services/UserService.cs"
        };

        Assert.Contains("src/Services/UserService.cs", item.Tooltip);
    }

    [Fact]
    public void Tooltip_IncludesValidationMessage()
    {
        var item = new FileTreeItemViewModel
        {
            Path = "file.cs",
            ValidationIssue = new ValidationIssue
            {
                Message = "File already exists"
            }
        };

        Assert.Contains("File already exists", item.Tooltip);
    }

    [Fact]
    public void UpdateFromOperation_SyncsProperties()
    {
        var operation = new FileOperation
        {
            Path = "test.cs",
            IsSelected = false,
            Status = FileOperationStatus.Applied,
            Language = "csharp",
            DisplayLanguage = "C#"
        };

        var item = new FileTreeItemViewModel
        {
            Operation = operation,
            IsSelected = true
        };

        item.UpdateFromOperation();

        Assert.False(item.IsSelected);
        Assert.Equal(FileOperationStatus.Applied, item.OperationStatus);
        Assert.Equal("C#", item.Language);
    }

    [Fact]
    public void ClearValidation_RemovesValidationState()
    {
        var item = new FileTreeItemViewModel
        {
            ValidationIssue = new ValidationIssue { Message = "Error" },
            FileExists = true
        };

        item.ClearValidation();

        Assert.Null(item.ValidationIssue);
        Assert.False(item.FileExists);
    }

    [Fact]
    public void Extension_ReturnsFileExtensionWithoutDot()
    {
        var item = new FileTreeItemViewModel
        {
            Path = "src/Services/UserService.cs"
        };

        Assert.Equal("cs", item.Extension);
    }

    [Fact]
    public void Depth_ReturnsCorrectDepthLevel()
    {
        var item = new FileTreeItemViewModel
        {
            Path = "src/Services/Auth/TokenService.cs"
        };

        Assert.Equal(3, item.Depth);
    }
}
```

### TreeBuildingService Tests

```csharp
// tests/SeniorIntern.Core.Tests/Services/TreeBuildingServiceTests.cs
using Xunit;
using SeniorIntern.Core.Models;
using SeniorIntern.Core.Services;

namespace SeniorIntern.Core.Tests.Services;

public class TreeBuildingServiceTests
{
    private readonly TreeBuildingService _service;

    public TreeBuildingServiceTests()
    {
        _service = new TreeBuildingService();
    }

    [Fact]
    public void BuildTree_EmptyOperations_ReturnsEmptyList()
    {
        var proposal = new FileTreeProposal
        {
            Operations = new List<FileOperation>()
        };

        var result = _service.BuildTree(proposal);

        Assert.Empty(result);
    }

    [Fact]
    public void BuildTree_SingleFile_ReturnsFileItem()
    {
        var proposal = new FileTreeProposal
        {
            Operations = new List<FileOperation>
            {
                new FileOperation { Path = "file.cs" }
            }
        };

        var result = _service.BuildTree(proposal);

        Assert.Single(result);
        Assert.Equal("file.cs", result[0].Name);
        Assert.False(result[0].IsDirectory);
    }

    [Fact]
    public void BuildTree_FileInDirectory_CreatesDirectoryStructure()
    {
        var proposal = new FileTreeProposal
        {
            Operations = new List<FileOperation>
            {
                new FileOperation { Path = "src/Services/UserService.cs" }
            }
        };

        var result = _service.BuildTree(proposal);

        Assert.Single(result);
        Assert.Equal("src", result[0].Name);
        Assert.True(result[0].IsDirectory);

        var services = result[0].Children.Single();
        Assert.Equal("Services", services.Name);
        Assert.True(services.IsDirectory);

        var file = services.Children.Single();
        Assert.Equal("UserService.cs", file.Name);
        Assert.False(file.IsDirectory);
    }

    [Fact]
    public void BuildTree_MultipleFilesInSameDirectory_GroupsCorrectly()
    {
        var proposal = new FileTreeProposal
        {
            Operations = new List<FileOperation>
            {
                new FileOperation { Path = "src/Services/UserService.cs" },
                new FileOperation { Path = "src/Services/AuthService.cs" }
            }
        };

        var result = _service.BuildTree(proposal);

        var servicesDir = result[0].Children.Single();
        Assert.Equal(2, servicesDir.Children.Count);
    }

    [Fact]
    public void BuildTree_SortsDirectoriesFirst()
    {
        var proposal = new FileTreeProposal
        {
            Operations = new List<FileOperation>
            {
                new FileOperation { Path = "src/file.cs" },
                new FileOperation { Path = "src/Services/UserService.cs" }
            }
        };

        var options = new TreeBuildingOptions(SortDirectoriesFirst: true);
        var result = _service.BuildTree(proposal, options);

        var srcDir = result[0];
        Assert.True(srcDir.Children[0].IsDirectory); // Services directory first
        Assert.False(srcDir.Children[1].IsDirectory); // file.cs second
    }

    [Fact]
    public void BuildTree_SortsAlphabetically()
    {
        var proposal = new FileTreeProposal
        {
            Operations = new List<FileOperation>
            {
                new FileOperation { Path = "src/Zebra.cs" },
                new FileOperation { Path = "src/Alpha.cs" },
                new FileOperation { Path = "src/Beta.cs" }
            }
        };

        var result = _service.BuildTree(proposal);

        var srcDir = result[0];
        Assert.Equal("Alpha.cs", srcDir.Children[0].Name);
        Assert.Equal("Beta.cs", srcDir.Children[1].Name);
        Assert.Equal("Zebra.cs", srcDir.Children[2].Name);
    }

    [Fact]
    public void BuildTree_SetsExpandByDefault()
    {
        var proposal = new FileTreeProposal
        {
            Operations = new List<FileOperation>
            {
                new FileOperation { Path = "src/Services/UserService.cs" }
            }
        };

        var options = new TreeBuildingOptions(ExpandByDefault: true);
        var result = _service.BuildTree(proposal, options);

        Assert.True(result[0].IsExpanded);
        Assert.True(result[0].Children[0].IsExpanded);
    }

    [Fact]
    public void BuildTree_SetsSelectByDefault()
    {
        var proposal = new FileTreeProposal
        {
            Operations = new List<FileOperation>
            {
                new FileOperation { Path = "file.cs" }
            }
        };

        var options = new TreeBuildingOptions(SelectByDefault: true);
        var result = _service.BuildTree(proposal, options);

        Assert.True(result[0].IsSelected);
    }

    [Fact]
    public void BuildTree_PreservesOperationReference()
    {
        var operation = new FileOperation { Path = "file.cs", Content = "test content" };
        var proposal = new FileTreeProposal
        {
            Operations = new List<FileOperation> { operation }
        };

        var result = _service.BuildTree(proposal);

        Assert.Same(operation, result[0].Operation);
    }

    [Fact]
    public void BuildTree_HandlesNestedDirectories()
    {
        var proposal = new FileTreeProposal
        {
            Operations = new List<FileOperation>
            {
                new FileOperation { Path = "src/Models/Auth/Token.cs" },
                new FileOperation { Path = "src/Models/User.cs" }
            }
        };

        var result = _service.BuildTree(proposal);

        var modelsDir = result[0].Children.Single();
        Assert.Equal(2, modelsDir.Children.Count);

        var authDir = modelsDir.Children.FirstOrDefault(c => c.Name == "Auth");
        Assert.NotNull(authDir);
        Assert.True(authDir.IsDirectory);
    }

    [Fact]
    public void FlattenTree_ReturnsAllItems()
    {
        var proposal = new FileTreeProposal
        {
            Operations = new List<FileOperation>
            {
                new FileOperation { Path = "src/Services/UserService.cs" },
                new FileOperation { Path = "src/Models/User.cs" }
            }
        };

        var tree = _service.BuildTree(proposal);
        var flattened = _service.FlattenTree(tree).ToList();

        // src, Services, UserService.cs, Models, User.cs = 5 items
        Assert.Equal(5, flattened.Count);
    }

    [Fact]
    public void FlattenTree_ExcludesDirectories_WhenSpecified()
    {
        var proposal = new FileTreeProposal
        {
            Operations = new List<FileOperation>
            {
                new FileOperation { Path = "src/Services/UserService.cs" },
                new FileOperation { Path = "src/Models/User.cs" }
            }
        };

        var tree = _service.BuildTree(proposal);
        var flattened = _service.FlattenTree(tree, includeDirectories: false).ToList();

        Assert.Equal(2, flattened.Count);
        Assert.All(flattened, item => Assert.False(item.IsDirectory));
    }

    [Fact]
    public void FindAll_ReturnsMatchingItems()
    {
        var proposal = new FileTreeProposal
        {
            Operations = new List<FileOperation>
            {
                new FileOperation { Path = "src/Services/UserService.cs" },
                new FileOperation { Path = "src/Models/User.cs" }
            }
        };

        var tree = _service.BuildTree(proposal);
        var csFiles = _service.FindAll(tree, item => item.Path.EndsWith(".cs")).ToList();

        Assert.Equal(2, csFiles.Count);
    }

    [Fact]
    public void BuildTree_HandlesRootLevelFiles()
    {
        var proposal = new FileTreeProposal
        {
            Operations = new List<FileOperation>
            {
                new FileOperation { Path = "README.md" },
                new FileOperation { Path = ".gitignore" }
            }
        };

        var result = _service.BuildTree(proposal);

        Assert.Equal(2, result.Count);
        Assert.All(result, item => Assert.False(item.IsDirectory));
    }

    [Fact]
    public void BuildTree_HandlesMixedPathSeparators()
    {
        var proposal = new FileTreeProposal
        {
            Operations = new List<FileOperation>
            {
                new FileOperation { Path = "src\\Services\\UserService.cs" },
                new FileOperation { Path = "src/Models/User.cs" }
            }
        };

        var result = _service.BuildTree(proposal);

        // Should combine under same src directory
        Assert.Single(result);
        Assert.Equal(2, result[0].Children.Count);
    }

    [Fact]
    public void BuildTree_SetsLanguageFromOperation()
    {
        var proposal = new FileTreeProposal
        {
            Operations = new List<FileOperation>
            {
                new FileOperation
                {
                    Path = "file.cs",
                    Language = "csharp",
                    DisplayLanguage = "C#"
                }
            }
        };

        var result = _service.BuildTree(proposal);

        Assert.Equal("C#", result[0].Language);
    }
}
```

---

## Acceptance Criteria

### FileTreeProposalViewModel

- [ ] Tree structure built correctly from flat operations list
- [ ] Directory nodes group files by their parent directory
- [ ] Selection state syncs bidirectionally with FileOperation.IsSelected
- [ ] SelectedCount updates when individual items are toggled
- [ ] HasSelectedFiles reflects current selection state
- [ ] SelectAll/DeselectAll commands work correctly
- [ ] Validation issues displayed on corresponding tree items
- [ ] FileExists flag set for files that already exist
- [ ] HasWarnings/HasErrors reflect validation result
- [ ] ApplyCommand only enabled when files selected and no errors
- [ ] PreviewCommand only enabled when files selected
- [ ] Progress updates during apply operation
- [ ] Apply can be cancelled
- [ ] ApplyCompleted event raised with result
- [ ] PreviewRequested event raised with diffs
- [ ] ExpandAll/CollapseAll toggle directory expansion
- [ ] FindItemByPath locates items in tree
- [ ] Event handlers cleaned up on dispose

### FileTreeItemViewModel

- [ ] Name and Path properties set correctly
- [ ] IsDirectory distinguishes files from directories
- [ ] IsFile computed property is inverse of IsDirectory
- [ ] Icon returns appropriate icon based on file extension
- [ ] Icon changes between FolderIcon/FolderOpenIcon based on expansion
- [ ] HasWarning/HasError reflect ValidationIssue severity
- [ ] StatusText reflects OperationStatus or FileExists
- [ ] Tooltip includes path and validation messages
- [ ] Children collection supports hierarchical structure
- [ ] UpdateFromOperation syncs with FileOperation
- [ ] ClearValidation resets validation state
- [ ] SelectionState tracks child selection for directories

### TreeBuildingService

- [ ] Empty operations return empty list
- [ ] Single file creates single item
- [ ] Files in directories create directory hierarchy
- [ ] Multiple files in same directory grouped correctly
- [ ] Directories sorted before files (when enabled)
- [ ] Items sorted alphabetically
- [ ] ExpandByDefault option respected
- [ ] SelectByDefault option respected
- [ ] Operation reference preserved in item
- [ ] Nested directories handled correctly
- [ ] FlattenTree returns all items
- [ ] FlattenTree can exclude directories
- [ ] FindAll returns matching items
- [ ] Mixed path separators handled
- [ ] Language property copied from operation

---

## Design Decisions

### Decision 1: Separate TreeBuildingService

**Context:** Tree building logic could be inline in the ViewModel or extracted to a service.

**Options:**
1. Inline tree building in FileTreeProposalViewModel
2. Extract to dedicated TreeBuildingService

**Decision:** Option 2 - Extract to TreeBuildingService

**Rationale:**
- Single Responsibility: ViewModel handles presentation logic, service handles tree construction
- Testability: Tree building algorithms can be unit tested independently
- Reusability: Service could be reused for other tree displays (e.g., workspace explorer)
- Configurability: TreeBuildingOptions allows customization without ViewModel changes

### Decision 2: SelectionState Enum for Directories

**Context:** Directory items need to show partial selection state (none/some/all).

**Options:**
1. Use nullable bool (null = partial)
2. Use dedicated SelectionState enum
3. Use CheckBox's built-in tri-state

**Decision:** Option 2 - Dedicated SelectionState enum

**Rationale:**
- Explicit semantics: Clear naming of states (None, Some, All)
- Type safety: Enum prevents invalid states
- Binding friendly: Easy to convert to visual representation
- Extensible: Can add more states if needed

### Decision 3: Event-Based Completion Notification

**Context:** Need to notify parent components when apply/preview completes.

**Options:**
1. Return Task with result from commands
2. Callback delegates
3. Event-based notification

**Decision:** Option 3 - Event-based notification

**Rationale:**
- MVVM pattern: Events are standard for ViewModel-to-View communication
- Multiple subscribers: Multiple handlers can respond to completion
- Loose coupling: View doesn't need to await command completion
- Consistent with existing patterns in the codebase

### Decision 4: Progress via IProgress<T>

**Context:** Need to report progress during batch apply operations.

**Options:**
1. Direct property updates
2. IProgress<T> interface
3. Custom progress callback

**Decision:** Option 2 - IProgress<T> interface

**Rationale:**
- Framework standard: IProgress<T> is the .NET standard for progress reporting
- Thread safety: Progress<T> handles marshalling to UI thread
- Flexibility: Service doesn't need to know about UI thread concerns
- Testability: Easy to mock in unit tests

---

## Accessibility Considerations

### Keyboard Navigation

- Tree items must be navigable with arrow keys
- Space/Enter toggles selection on focused item
- Tab moves between tree and action buttons
- Escape cancels in-progress operations

### Screen Reader Support

- TreeView announces expanded/collapsed state changes
- Selection changes announced
- Progress updates announced periodically
- Validation issues read when item receives focus

### Visual Accessibility

- Icons have text alternatives in tooltips
- Selection state visible without color alone (checkboxes)
- Error/warning states use icons in addition to color
- Sufficient contrast for status badges

---

## Performance Considerations

### Tree Building

- Operations grouped and sorted in single pass where possible
- Dictionary used for O(1) directory node lookup
- Tree built lazily if dealing with very large proposals

### Selection Updates

- Selection count computed from model, not recalculated from tree
- PropertyChanged only fires when values actually change
- Batch selection uses direct property assignment, not commands

### Memory

- Event handlers properly unsubscribed on disposal
- CancellationTokenSource disposed after use
- Tree items don't hold strong references to disposed ViewModels

### UI Responsiveness

- Validation runs asynchronously without blocking UI
- Apply operation reports granular progress
- Long operations can be cancelled

---

## Future Enhancements

### Potential Improvements

1. **Virtual Scrolling** - For very large file trees, implement virtualized TreeView
2. **Search/Filter** - Add ability to filter tree items by name or path
3. **Drag-and-Drop** - Allow reordering files or moving between directories
4. **Context Menu** - Right-click actions (exclude, rename, view diff)
5. **Multi-Select** - Shift+click range selection, Ctrl+click toggle
6. **Keyboard Shortcuts** - Ctrl+A select all, Ctrl+D deselect all
7. **Persist Expansion State** - Remember which directories were expanded
8. **Group by Type** - Option to group files by extension/language
9. **Show File Size** - Display size in tree items
10. **Preview on Hover** - Show file content preview on hover

---

## Dependencies

### Internal Dependencies

| Component | Version | Purpose |
|-----------|---------|---------|
| v0.4.4a Core Models | v0.4.4 | FileTreeProposal, FileOperation, ValidationIssue |
| v0.4.4c Proposal Service | v0.4.4 | IFileTreeProposalService for validation/apply |
| Existing DiffService | Current | IDiffService for preview generation |
| ViewModelBase | Current | Base class with INotifyPropertyChanged |

### External Dependencies

| Package | Version | Purpose |
|---------|---------|---------|
| CommunityToolkit.Mvvm | 8.x | ObservableProperty, RelayCommand attributes |
| Avalonia | 11.x | UI framework for TreeView binding |

---

## Glossary

| Term | Definition |
|------|------------|
| TreeItem | A node in the hierarchical file tree (file or directory) |
| SelectionState | Tri-state selection indicator for directories (None/Some/All) |
| Flat Operations | The original list of FileOperation objects without hierarchy |
| Tree Building | Converting flat operations into hierarchical tree structure |
| Cascade Selection | Propagating selection changes from parent to children |
| Progress Reporting | Notifying UI of operation progress via IProgress<T> |
