# Design Specification: The Senior Intern v0.4.1b "Parser Service"

**Status**: _IMPLEMENTED_

## Executive Summary

This document provides a detailed implementation specification for v0.4.1b, which implements the core parsing logic to extract code blocks from markdown-formatted LLM responses. This service is the central component that identifies fenced code blocks, extracts their content, and prepares them for further processing by downstream services.

### v0.4.1b Scope

- Create `ICodeBlockParserService` interface with ParseMessage and CreateProposal methods
- Implement `CodeBlockParserService` with regex-based markdown fence parsing
- Support standard fence syntax: `` ```lang ``
- Support extended fence syntax with file path: `` ```lang:path/to/file ``
- Extract file paths from first-line comments (e.g., `// File: path/to/file`)
- Remove file path comments from extracted content
- Calculate source ranges for each extracted block
- Create event classes for parsing notifications
- Handle edge cases (empty blocks, nested fences, malformed syntax)

### Key Deliverables

| Deliverable | Description |
|-------------|-------------|
| ICodeBlockParserService | Interface for parsing operations |
| CodeBlockParserService | Main implementation with regex patterns |
| CodeBlockEvents | Event argument classes |
| Fence parsing regex | Compiled regex for performance |
| Path extraction | From fence and comments |
| Proposal creation | Enhanced blocks with inferred metadata |

---

## Feature Overview

```
┌──────────────────────────────────────────────────────────────────┐
│                     v0.4.1b Feature Tree                          │
├──────────────────────────────────────────────────────────────────┤
│                                                                   │
│  ICodeBlockParserService                                          │
│  ├── ParseMessage(content, messageId)                            │
│  │   ├── Input: full message markdown content                   │
│  │   ├── Output: IReadOnlyList<CodeBlock>                       │
│  │   └── Extracts all fenced code blocks                        │
│  │                                                                │
│  ├── CreateProposal(content, messageId, attachedContext)         │
│  │   ├── Calls ParseMessage internally                          │
│  │   ├── Enhances blocks with inferred metadata                 │
│  │   └── Returns CodeProposal                                   │
│  │                                                                │
│  └── ParseSingleBlock(fenceContent, messageId, sequenceNumber)   │
│      ├── Parses one fence block                                 │
│      └── Returns CodeBlock or null                              │
│                                                                   │
│  CodeBlockParserService                                           │
│  ├── Dependencies                                                │
│  │   ├── ILanguageDetectionService (v0.4.1c)                    │
│  │   ├── IBlockClassificationService (v0.4.1d)                  │
│  │   └── IFilePathInferenceService (v0.4.1e)                    │
│  │                                                                │
│  ├── Regex Patterns (source-generated)                           │
│  │   ├── FencedBlockPattern                                     │
│  │   │   └── ```(?<lang>[\w\-+#]+)?(?::(?<path>[^\n\r]+))?\r?\n │
│  │   │       (?<code>[\s\S]*?)```                               │
│  │   │                                                           │
│  │   └── FileCommentPattern                                     │
│  │       └── ^(?://|#|--|/\*|<!--)\s*(?:File|Path|Filename):    │
│  │           \s*(?<path>.+?)(?:\s*\*/|-->)?$                    │
│  │                                                                │
│  ├── ParseMessage(content, messageId)                            │
│  │   ├── Match all FencedBlockPattern occurrences               │
│  │   ├── For each match: ExtractBlockFromMatch()                │
│  │   └── Return list of extracted blocks                        │
│  │                                                                │
│  ├── ExtractBlockFromMatch(match, messageId, seq, fullContent)   │
│  │   ├── Extract raw code from named group                      │
│  │   ├── Extract lang spec from fence                           │
│  │   ├── Extract path from fence (:path syntax)                 │
│  │   ├── Extract path from first-line comment if not in fence  │
│  │   ├── Remove path comment from content                       │
│  │   ├── Call language detection service                        │
│  │   ├── Call classification service                            │
│  │   ├── Calculate confidence score                             │
│  │   └── Build and return CodeBlock                             │
│  │                                                                │
│  ├── ExtractPathFromComment(code)                                │
│  │   ├── Check first 3 lines for path comment                  │
│  │   └── Return path or null                                    │
│  │                                                                │
│  ├── RemovePathComment(code)                                     │
│  │   ├── Find and skip path comment line                        │
│  │   └── Return cleaned code                                    │
│  │                                                                │
│  ├── NormalizePath(path)                                         │
│  │   ├── Replace backslashes with forward slashes               │
│  │   └── Trim leading/trailing whitespace and slashes           │
│  │                                                                │
│  └── CalculateConfidence(langSpec, targetPath, blockType)        │
│      ├── Start at 1.0                                           │
│      ├── -0.1 if no explicit language                           │
│      ├── -0.2 if Example type                                   │
│      ├── -0.3 if no target path                                 │
│      └── Minimum 0.1                                            │
│                                                                   │
│  CodeBlockEvents                                                  │
│  ├── CodeBlockExtractedEventArgs                                 │
│  │   ├── CodeBlock: CodeBlock                                   │
│  │   ├── MessageId: Guid                                        │
│  │   └── TotalBlocksInMessage: int                              │
│  │                                                                │
│  ├── CodeProposalCreatedEventArgs                                │
│  │   └── Proposal: CodeProposal                                 │
│  │                                                                │
│  └── CodeBlockParseErrorEventArgs                                │
│      ├── Content: string                                        │
│      ├── ErrorMessage: string                                   │
│      └── Location: TextRange                                    │
│                                                                   │
└──────────────────────────────────────────────────────────────────┘
```

---

## Architecture Diagrams

### Parsing Flow

```
┌─────────────────────────────────────────────────────────────────┐
│                    Code Block Parsing Flow                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  LLM Response Content                                            │
│  ┌───────────────────────────────────────────────────────────┐   │
│  │ Here's the implementation:                                │   │
│  │                                                            │   │
│  │ ```csharp:src/Models/User.cs                              │   │
│  │ public class User                                         │   │
│  │ {                                                          │   │
│  │     public string Name { get; set; }                      │   │
│  │ }                                                          │   │
│  │ ```                                                        │   │
│  │                                                            │   │
│  │ And the interface:                                        │   │
│  │                                                            │   │
│  │ ```csharp                                                 │   │
│  │ // File: src/Interfaces/IUserService.cs                   │   │
│  │ public interface IUserService { }                         │   │
│  │ ```                                                        │   │
│  └───────────────────────────────────────────────────────────┘   │
│         │                                                        │
│         ▼                                                        │
│  ┌────────────────────────────────────────────────────────────┐  │
│  │ CodeBlockParserService.ParseMessage()                      │  │
│  │                                                             │  │
│  │ 1. Apply FencedBlockPattern regex                          │  │
│  │ 2. Find 2 matches                                          │  │
│  └────────────────────────────────────────────────────────────┘  │
│         │                                                        │
│    ┌────┴────┐                                                   │
│    ▼         ▼                                                   │
│ [Match 1]  [Match 2]                                             │
│    │         │                                                   │
│    ▼         ▼                                                   │
│  ┌─────────────────────────────────────────────────────────────┐ │
│  │ ExtractBlockFromMatch()                                     │ │
│  │                                                              │ │
│  │ Match 1:                          Match 2:                  │ │
│  │ ├─ lang: "csharp"                ├─ lang: "csharp"          │ │
│  │ ├─ path (fence): src/Models/     ├─ path (fence): null      │ │
│  │ │   User.cs                      ├─ path (comment): src/    │ │
│  │ ├─ code: "public class..."       │   Interfaces/IUser...    │ │
│  │ └─ sequenceNumber: 0             └─ sequenceNumber: 1       │ │
│  └─────────────────────────────────────────────────────────────┘ │
│         │                                                        │
│         ▼                                                        │
│  ┌────────────────────────────────────────────────────────────┐  │
│  │ Output: List<CodeBlock>                                    │  │
│  │                                                             │  │
│  │ [0] CodeBlock {                                            │  │
│  │       Language: "csharp",                                  │  │
│  │       DisplayLanguage: "C#",                               │  │
│  │       TargetFilePath: "src/Models/User.cs",                │  │
│  │       Content: "public class User...",                     │  │
│  │       BlockType: CompleteFile,                             │  │
│  │       SequenceNumber: 0,                                   │  │
│  │       ConfidenceScore: 1.0                                 │  │
│  │     }                                                       │  │
│  │                                                             │  │
│  │ [1] CodeBlock {                                            │  │
│  │       Language: "csharp",                                  │  │
│  │       TargetFilePath: "src/Interfaces/IUserService.cs",    │  │
│  │       Content: "public interface IUserService { }",        │  │
│  │       BlockType: CompleteFile,                             │  │
│  │       SequenceNumber: 1,                                   │  │
│  │       ConfidenceScore: 1.0                                 │  │
│  │     }                                                       │  │
│  └────────────────────────────────────────────────────────────┘  │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Fence Syntax Variations

```
┌─────────────────────────────────────────────────────────────────┐
│                    Fence Syntax Variations                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌─────────────────────────────────────────────────────────────┐ │
│  │ Standard Fence (language only)                              │ │
│  │                                                              │ │
│  │ ```csharp                                                   │ │
│  │ public class Foo { }                                        │ │
│  │ ```                                                          │ │
│  │                                                              │ │
│  │ Extracted:                                                  │ │
│  │   lang: "csharp"                                            │ │
│  │   path: null                                                │ │
│  │   code: "public class Foo { }"                              │ │
│  └─────────────────────────────────────────────────────────────┘ │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────────┐ │
│  │ Extended Fence (language + path)                            │ │
│  │                                                              │ │
│  │ ```csharp:src/Models/Foo.cs                                 │ │
│  │ public class Foo { }                                        │ │
│  │ ```                                                          │ │
│  │                                                              │ │
│  │ Extracted:                                                  │ │
│  │   lang: "csharp"                                            │ │
│  │   path: "src/Models/Foo.cs"                                 │ │
│  │   code: "public class Foo { }"                              │ │
│  └─────────────────────────────────────────────────────────────┘ │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────────┐ │
│  │ Path in Comment (various comment styles)                    │ │
│  │                                                              │ │
│  │ ```csharp                                                   │ │
│  │ // File: src/Models/Foo.cs                                  │ │
│  │ public class Foo { }                                        │ │
│  │ ```                                                          │ │
│  │                                                              │ │
│  │ Also supports:                                              │ │
│  │   # File: path           (Python, Ruby, etc.)               │ │
│  │   -- File: path          (SQL, Haskell)                     │ │
│  │   /* File: path */       (C-style multiline)                │ │
│  │   <!-- File: path -->    (HTML, XML)                        │ │
│  │                                                              │ │
│  │ Extracted:                                                  │ │
│  │   lang: "csharp"                                            │ │
│  │   path: "src/Models/Foo.cs"                                 │ │
│  │   code: "public class Foo { }"  (comment removed)           │ │
│  └─────────────────────────────────────────────────────────────┘ │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────────┐ │
│  │ No Language Specifier                                       │ │
│  │                                                              │ │
│  │ ```                                                          │ │
│  │ some content here                                           │ │
│  │ ```                                                          │ │
│  │                                                              │ │
│  │ Extracted:                                                  │ │
│  │   lang: null (may be detected from content)                 │ │
│  │   path: null                                                │ │
│  │   code: "some content here"                                 │ │
│  └─────────────────────────────────────────────────────────────┘ │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Service Dependencies

```
┌─────────────────────────────────────────────────────────────────┐
│                    Service Dependencies                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│                 ┌─────────────────────────┐                      │
│                 │ CodeBlockParserService  │                      │
│                 │       (v0.4.1b)         │                      │
│                 └───────────┬─────────────┘                      │
│                             │                                    │
│         ┌───────────────────┼───────────────────┐                │
│         │                   │                   │                │
│         ▼                   ▼                   ▼                │
│  ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐    │
│  │ ILanguage       │ │ IBlock          │ │ IFilePath       │    │
│  │ Detection       │ │ Classification  │ │ Inference       │    │
│  │ Service         │ │ Service         │ │ Service         │    │
│  │ (v0.4.1c)       │ │ (v0.4.1d)       │ │ (v0.4.1e)       │    │
│  └─────────────────┘ └─────────────────┘ └─────────────────┘    │
│         │                   │                   │                │
│         ▼                   ▼                   ▼                │
│  ┌─────────────────────────────────────────────────────────────┐ │
│  │ Responsibilities:                                           │ │
│  │                                                              │ │
│  │ Language Detection:                                         │ │
│  │ - Normalize "cs" → "csharp"                                 │ │
│  │ - Get display name "csharp" → "C#"                          │ │
│  │ - Detect from content if no fence lang                      │ │
│  │                                                              │ │
│  │ Block Classification:                                       │ │
│  │ - Determine if CompleteFile, Snippet, Example, Command      │ │
│  │ - Use surrounding text context                              │ │
│  │                                                              │ │
│  │ File Path Inference:                                        │ │
│  │ - Infer path from attached context                          │ │
│  │ - Match class/function names to files                       │ │
│  │ - Calculate confidence score                                │ │
│  └─────────────────────────────────────────────────────────────┘ │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## Directory Structure

```
src/SeniorIntern.Core/
├── Interfaces/
│   └── ICodeBlockParserService.cs                    (NEW)
└── Events/
    └── CodeBlockEvents.cs                            (NEW)

src/SeniorIntern.Services/
└── CodeBlockParserService.cs                         (NEW)
```

---

## Implementation Details

### Task 1: Create ICodeBlockParserService Interface

**File:** `src/SeniorIntern.Core/Interfaces/ICodeBlockParserService.cs`

```csharp
namespace SeniorIntern.Core.Interfaces;

using SeniorIntern.Core.Models;

/// <summary>
/// Service for parsing code blocks from LLM response content.
/// </summary>
public interface ICodeBlockParserService
{
    /// <summary>
    /// Extract all code blocks from a complete message.
    /// </summary>
    /// <param name="content">The full message content (markdown).</param>
    /// <param name="messageId">ID of the source message.</param>
    /// <returns>List of extracted code blocks.</returns>
    IReadOnlyList<CodeBlock> ParseMessage(string content, Guid messageId);

    /// <summary>
    /// Create a CodeProposal from extracted code blocks with context-aware inference.
    /// </summary>
    /// <param name="content">The full message content.</param>
    /// <param name="messageId">ID of the source message.</param>
    /// <param name="attachedContext">Files attached to the conversation for path inference.</param>
    /// <returns>A proposal containing all code blocks with inferred metadata.</returns>
    CodeProposal CreateProposal(
        string content,
        Guid messageId,
        IReadOnlyList<FileContext>? attachedContext = null);

    /// <summary>
    /// Parse a single code block from raw fence content.
    /// </summary>
    /// <param name="fenceContent">Content including the opening fence (```lang).</param>
    /// <param name="messageId">ID of the source message.</param>
    /// <param name="sequenceNumber">Position in message.</param>
    /// <returns>Parsed code block or null if invalid.</returns>
    CodeBlock? ParseSingleBlock(string fenceContent, Guid messageId, int sequenceNumber);

    /// <summary>
    /// Check if content contains any code blocks.
    /// </summary>
    /// <param name="content">The content to check.</param>
    /// <returns>True if at least one code block is present.</returns>
    bool ContainsCodeBlocks(string content);

    /// <summary>
    /// Get the count of code blocks without fully parsing.
    /// </summary>
    /// <param name="content">The content to check.</param>
    /// <returns>Number of code blocks found.</returns>
    int CountCodeBlocks(string content);
}
```

### Task 2: Create Event Classes

**File:** `src/SeniorIntern.Core/Events/CodeBlockEvents.cs`

```csharp
namespace SeniorIntern.Core.Events;

using SeniorIntern.Core.Models;

/// <summary>
/// Event args for when a code block is extracted.
/// </summary>
public sealed class CodeBlockExtractedEventArgs : EventArgs
{
    /// <summary>
    /// The extracted code block.
    /// </summary>
    public required CodeBlock CodeBlock { get; init; }

    /// <summary>
    /// ID of the message containing this block.
    /// </summary>
    public required Guid MessageId { get; init; }

    /// <summary>
    /// Total number of blocks found in the message.
    /// </summary>
    public required int TotalBlocksInMessage { get; init; }
}

/// <summary>
/// Event args for when a proposal is created.
/// </summary>
public sealed class CodeProposalCreatedEventArgs : EventArgs
{
    /// <summary>
    /// The created proposal.
    /// </summary>
    public required CodeProposal Proposal { get; init; }
}

/// <summary>
/// Event args for parsing errors.
/// </summary>
public sealed class CodeBlockParseErrorEventArgs : EventArgs
{
    /// <summary>
    /// The content that failed to parse.
    /// </summary>
    public required string Content { get; init; }

    /// <summary>
    /// Description of the error.
    /// </summary>
    public required string ErrorMessage { get; init; }

    /// <summary>
    /// Location in the original content where the error occurred.
    /// </summary>
    public required TextRange Location { get; init; }
}
```

### Task 3: Implement CodeBlockParserService

**File:** `src/SeniorIntern.Services/CodeBlockParserService.cs`

```csharp
namespace SeniorIntern.Services;

using System.Text.RegularExpressions;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;

/// <summary>
/// Parses code blocks from markdown-formatted LLM responses.
/// </summary>
public sealed partial class CodeBlockParserService : ICodeBlockParserService
{
    private readonly ILanguageDetectionService _languageService;
    private readonly IBlockClassificationService _classificationService;
    private readonly IFilePathInferenceService _pathInferenceService;
    private readonly ILogger<CodeBlockParserService>? _logger;

    // === Source-Generated Regex Patterns ===
    
    /// <summary>
    /// Matches fenced code blocks: ```lang:path\ncode```
    /// Groups: lang (optional), path (optional), code
    /// </summary>
    [GeneratedRegex(
        @"```(?<lang>[\w\-+#]+)?(?::(?<path>[^\n\r]+))?\r?\n(?<code>[\s\S]*?)```",
        RegexOptions.Compiled | RegexOptions.Multiline)]
    private static partial Regex FencedBlockPattern();

    /// <summary>
    /// Matches file path comments in first lines.
    /// Supports: //, #, --, /* */, <!-- -->
    /// </summary>
    [GeneratedRegex(
        @"^(?://|#|--|/\*|<!--)\s*(?:File|Path|Filename):\s*(?<path>.+?)(?:\s*\*/|-->)?$",
        RegexOptions.Compiled | RegexOptions.IgnoreCase | RegexOptions.Multiline)]
    private static partial Regex FileCommentPattern();

    public CodeBlockParserService(
        ILanguageDetectionService languageService,
        IBlockClassificationService classificationService,
        IFilePathInferenceService pathInferenceService,
        ILogger<CodeBlockParserService>? logger = null)
    {
        _languageService = languageService;
        _classificationService = classificationService;
        _pathInferenceService = pathInferenceService;
        _logger = logger;
    }

    public IReadOnlyList<CodeBlock> ParseMessage(string content, Guid messageId)
    {
        if (string.IsNullOrWhiteSpace(content))
            return Array.Empty<CodeBlock>();

        var blocks = new List<CodeBlock>();
        var matches = FencedBlockPattern().Matches(content);

        _logger?.LogDebug("Found {Count} code block(s) in message {MessageId}",
            matches.Count, messageId);

        for (int i = 0; i < matches.Count; i++)
        {
            var match = matches[i];

            try
            {
                var block = ExtractBlockFromMatch(match, messageId, i, content);
                if (block != null)
                {
                    blocks.Add(block);
                }
            }
            catch (Exception ex)
            {
                _logger?.LogWarning(ex,
                    "Failed to parse code block {Index} in message {MessageId}",
                    i, messageId);
            }
        }

        return blocks;
    }

    public CodeProposal CreateProposal(
        string content,
        Guid messageId,
        IReadOnlyList<FileContext>? attachedContext = null)
    {
        var blocks = ParseMessage(content, messageId);

        // Enhance blocks with inferred metadata
        var enhancedBlocks = blocks.Select(block =>
        {
            // Infer target file path if not explicitly specified
            if (string.IsNullOrEmpty(block.TargetFilePath))
            {
                var inferredPath = _pathInferenceService.InferTargetFilePath(
                    block, attachedContext ?? Array.Empty<FileContext>());

                if (!string.IsNullOrEmpty(inferredPath))
                {
                    return block.With(
                        targetFilePath: inferredPath,
                        confidenceScore: _pathInferenceService.GetConfidenceScore(
                            block, inferredPath));
                }
            }
            return block;
        }).ToList();

        return new CodeProposal
        {
            MessageId = messageId,
            CodeBlocks = enhancedBlocks
        };
    }

    public CodeBlock? ParseSingleBlock(string fenceContent, Guid messageId, int sequenceNumber)
    {
        var match = FencedBlockPattern().Match(fenceContent);
        if (!match.Success)
            return null;

        return ExtractBlockFromMatch(match, messageId, sequenceNumber, fenceContent);
    }

    public bool ContainsCodeBlocks(string content)
    {
        if (string.IsNullOrWhiteSpace(content))
            return false;

        return FencedBlockPattern().IsMatch(content);
    }

    public int CountCodeBlocks(string content)
    {
        if (string.IsNullOrWhiteSpace(content))
            return 0;

        return FencedBlockPattern().Count(content);
    }

    // === Private Helper Methods ===

    private CodeBlock? ExtractBlockFromMatch(
        Match match,
        Guid messageId,
        int sequenceNumber,
        string fullContent)
    {
        var rawCode = match.Groups["code"].Value;
        var langSpec = match.Groups["lang"].Value;
        var pathFromFence = match.Groups["path"].Value?.Trim();

        // Skip empty code blocks
        if (string.IsNullOrWhiteSpace(rawCode))
        {
            _logger?.LogDebug("Skipping empty code block at position {Position}",
                match.Index);
            return null;
        }

        // Extract file path from first-line comment if not in fence
        var pathFromComment = ExtractPathFromComment(rawCode);
        var targetPath = !string.IsNullOrEmpty(pathFromFence)
            ? NormalizePath(pathFromFence)
            : !string.IsNullOrEmpty(pathFromComment)
                ? NormalizePath(pathFromComment)
                : null;

        // Remove the path comment from content if present
        var cleanedCode = pathFromComment != null
            ? RemovePathComment(rawCode)
            : rawCode;

        // Detect/normalize language
        var (language, displayLanguage) = _languageService.DetectLanguage(
            langSpec, cleanedCode, targetPath);

        // Get surrounding text for classification context
        var contextStart = Math.Max(0, match.Index - 300);
        var contextEnd = Math.Min(fullContent.Length, match.Index + match.Length + 100);
        var surroundingText = fullContent[contextStart..contextEnd];

        // Classify block type
        var blockType = _classificationService.ClassifyBlock(
            cleanedCode, language, surroundingText);

        return new CodeBlock
        {
            Content = cleanedCode.Trim(),
            Language = language,
            DisplayLanguage = displayLanguage,
            TargetFilePath = targetPath,
            BlockType = blockType,
            MessageId = messageId,
            SequenceNumber = sequenceNumber,
            SourceRange = new TextRange(match.Index, match.Index + match.Length),
            ConfidenceScore = CalculateConfidence(langSpec, targetPath, blockType)
        };
    }

    private string? ExtractPathFromComment(string code)
    {
        // Check first few lines for file path comment
        var lines = code.Split('\n', 5);
        foreach (var line in lines.Take(3))
        {
            var match = FileCommentPattern().Match(line);
            if (match.Success)
                return match.Groups["path"].Value.Trim();
        }
        return null;
    }

    private string RemovePathComment(string code)
    {
        var lines = code.Split('\n');
        var result = new List<string>();
        bool foundPath = false;

        foreach (var line in lines)
        {
            if (!foundPath && FileCommentPattern().IsMatch(line))
            {
                foundPath = true;
                continue; // Skip the path comment line
            }
            result.Add(line);
        }

        return string.Join('\n', result);
    }

    private static string NormalizePath(string path)
    {
        // Normalize path separators and remove leading/trailing whitespace
        return path.Trim()
            .Replace('\\', '/')
            .TrimStart('/');
    }

    private static float CalculateConfidence(
        string? langSpec,
        string? targetPath,
        CodeBlockType blockType)
    {
        float confidence = 1.0f;

        // Reduce confidence if language wasn't explicitly specified
        if (string.IsNullOrEmpty(langSpec))
            confidence -= 0.1f;

        // Reduce confidence for example blocks
        if (blockType == CodeBlockType.Example)
            confidence -= 0.2f;

        // Reduce confidence if no target path
        if (string.IsNullOrEmpty(targetPath))
            confidence -= 0.3f;

        return Math.Max(0.1f, confidence);
    }
}
```

---

## Regex Pattern Details

### FencedBlockPattern

```
```(?<lang>[\w\-+#]+)?(?::(?<path>[^\n\r]+))?\r?\n(?<code>[\s\S]*?)```
```

| Part | Description |
|------|-------------|
| ` ``` ` | Literal opening fence |
| `(?<lang>[\w\-+#]+)?` | Optional language (named group) |
| `(?::(?<path>[^\n\r]+))?` | Optional :path after language |
| `\r?\n` | Required newline after fence |
| `(?<code>[\s\S]*?)` | Code content (non-greedy) |
| ` ``` ` | Closing fence |

### FileCommentPattern

```
^(?://|#|--|/\*|<!--)\s*(?:File|Path|Filename):\s*(?<path>.+?)(?:\s*\*/|-->)?$
```

| Part | Description |
|------|-------------|
| `^` | Start of line |
| `(?://\|#\|--\|/\*\|<!--)` | Comment start variants |
| `\s*` | Optional whitespace |
| `(?:File\|Path\|Filename):` | Keyword |
| `\s*(?<path>.+?)` | Path (named group) |
| `(?:\s*\*/\|-->)?` | Optional comment close |
| `$` | End of line |

---

## Confidence Score Calculation

| Factor | Impact |
|--------|--------|
| Language explicitly specified | +0.0 (baseline) |
| Language not specified | -0.1 |
| Block type is Example | -0.2 |
| No target path | -0.3 |
| **Minimum** | 0.1 |

**Examples:**
- `csharp:src/Foo.cs` → 1.0
- `csharp` (no path) → 0.7
- ``` (no lang, no path) → 0.6
- Example block, no path → 0.5

---

## Unit Testing Requirements

| Component | Test Count | Focus Areas |
|-----------|------------|-------------|
| ParseMessage (standard fence) | 2 | Extracts content, language |
| ParseMessage (path in fence) | 2 | :path syntax extraction |
| ParseMessage (path in comment) | 3 | All comment styles |
| ParseMessage (multiple blocks) | 2 | Sequence numbers, all extracted |
| ParseMessage (empty blocks) | 1 | Skipped correctly |
| ParseMessage (no newline) | 1 | Edge case handling |
| RemovePathComment | 2 | Removes, preserves rest |
| NormalizePath | 3 | Backslashes, leading slashes, trim |
| CalculateConfidence | 4 | All factor combinations |
| ContainsCodeBlocks | 2 | True/False cases |
| CountCodeBlocks | 2 | Correct counts |
| CreateProposal | 2 | Integrates with inference |
| **Total** | **26** | |

---

## Files Summary

### Files to Create (3)

| File | Lines |
|------|-------|
| `Core/Interfaces/ICodeBlockParserService.cs` | 55 |
| `Core/Events/CodeBlockEvents.cs` | 50 |
| `Services/CodeBlockParserService.cs` | 220 |

### Files to Modify (2)

| File | Changes |
|------|---------|
| `Services/SeniorIntern.Services.csproj` | Ensure regex source generator support |
| `Desktop/Extensions/ServiceCollectionExtensions.cs` | Register parser service |

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | Parser extracts code blocks from standard markdown fences |
| AC-2 | Parser handles ` ```lang:path/to/file ` syntax |
| AC-3 | Parser extracts file paths from first-line comments |
| AC-4 | Parser removes file path comments from extracted content |
| AC-5 | Parser assigns correct sequence numbers to multiple blocks |
| AC-6 | Parser calculates correct source ranges |
| AC-7 | Empty code blocks are skipped |
| AC-8 | Confidence scores calculated correctly |
| AC-9 | CreateProposal integrates with path inference |
| AC-10 | Unit tests pass for all parsing scenarios |

---

## Dependencies

| Dependency | Description |
|------------|-------------|
| v0.4.1a | CodeBlock, CodeProposal, TextRange models |
| v0.4.1c | ILanguageDetectionService |
| v0.4.1d | IBlockClassificationService |
| v0.4.1e | IFilePathInferenceService |
| FileContext | From v0.3.4 for context-aware inference |

---

## Edge Cases

| Scenario | Behavior |
|----------|----------|
| Empty content | Return empty list |
| No code blocks | Return empty list |
| Empty code block (whitespace only) | Skip block |
| Nested fences (```) | Outer fence wins |
| Unclosed fence | Match fails, block not extracted |
| Multiple path comments | First one used |
| Invalid path characters | Path normalized |

---

## Timeline Estimate

| Version | Estimated Effort |
|---------|------------------|
| v0.4.1b | 0.75 day |
