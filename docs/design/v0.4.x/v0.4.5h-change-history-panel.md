# v0.4.5h: Change History Panel - Design Specification

**Status**: _PLANNED_

## Executive Summary

This specification details the **Change History Panel** for The Senior Intern, providing a comprehensive interface for viewing, managing, and reverting recent file changes. The panel displays all changes made through the code generation workflow, allowing users to track modifications, view diffs, undo individual or batch changes, and filter/search through their change history.

### Key Deliverables

| Component | Type | Purpose |
|-----------|------|---------|
| `ChangeHistoryViewModel` | ViewModel | Main panel state and operations |
| `ChangeHistoryItemViewModel` | ViewModel | Individual change item state |
| `ChangeHistoryGroupViewModel` | ViewModel | Grouped changes by file/session |
| `ChangeHistoryPanel` | View | Main panel AXAML view |
| `ChangeHistoryItem` | View | Individual change row component |
| `ChangeHistoryFilter` | Record | Filter/search criteria |
| `ChangeHistoryExporter` | Service | Export history to various formats |
| `IChangeHistoryService` | Interface | Service for history operations |
| `ChangeHistoryService` | Class | History aggregation and queries |

---

## Feature Overview

```
v0.4.5h: Change History Panel
├── Core Models
│   ├── ChangeHistoryFilter (record)
│   │   ├── SearchText (string?)
│   │   ├── FileTypes (ISet<string>?)
│   │   ├── ChangeTypes (ISet<FileChangeType>?)
│   │   ├── DateRange (DateTimeRange?)
│   │   ├── OnlyUndoable (bool)
│   │   ├── OnlyFromSession (Guid?)
│   │   └── SortOrder (ChangeHistorySortOrder)
│   ├── ChangeHistorySortOrder (enum)
│   │   ├── NewestFirst (default)
│   │   ├── OldestFirst
│   │   ├── FileName
│   │   └── ChangeType
│   ├── ChangeHistoryStats (record)
│   │   ├── TotalChanges (int)
│   │   ├── UndoableCount (int)
│   │   ├── FilesAffected (int)
│   │   ├── LinesAdded (int)
│   │   ├── LinesRemoved (int)
│   │   └── TimeSpan (oldest to newest)
│   └── DateTimeRange (record)
│       ├── Start (DateTime?)
│       └── End (DateTime?)
├── Service Layer
│   ├── IChangeHistoryService (interface)
│   │   ├── GetHistoryAsync(filter) → IAsyncEnumerable<FileChangeRecord>
│   │   ├── GetHistoryPagedAsync(filter, page, pageSize)
│   │   ├── GetStatsAsync(filter) → ChangeHistoryStats
│   │   ├── GetGroupedByFileAsync() → IEnumerable<FileChangeGroup>
│   │   ├── GetGroupedBySessionAsync() → IEnumerable<SessionChangeGroup>
│   │   ├── SearchAsync(text) → IEnumerable<FileChangeRecord>
│   │   ├── ExportAsync(format, filter) → Stream
│   │   └── ClearHistoryAsync(olderThan?)
│   └── ChangeHistoryService (implementation)
│       ├── Dependencies
│       │   ├── IUndoManager
│       │   ├── IDiffService
│       │   └── ISettingsService
│       ├── Caching
│       │   ├── In-memory cache of recent records
│       │   └── Cache invalidation on new changes
│       └── Grouping Logic
│           ├── Group by file path
│           ├── Group by session/conversation
│           └── Group by time period
├── ViewModel Layer
│   ├── ChangeHistoryViewModel (main panel)
│   │   ├── Observable Properties
│   │   │   ├── Items (ObservableCollection<ChangeHistoryItemViewModel>)
│   │   │   ├── GroupedItems (ObservableCollection<ChangeHistoryGroupViewModel>)
│   │   │   ├── SelectedItem (ChangeHistoryItemViewModel?)
│   │   │   ├── SelectedItems (ObservableCollection)
│   │   │   ├── Filter (ChangeHistoryFilter)
│   │   │   ├── Stats (ChangeHistoryStats)
│   │   │   ├── IsLoading (bool)
│   │   │   ├── IsGrouped (bool)
│   │   │   ├── GroupBy (HistoryGroupMode)
│   │   │   ├── SearchText (string)
│   │   │   ├── ShowFilters (bool)
│   │   │   └── ErrorMessage (string?)
│   │   ├── Computed Properties
│   │   │   ├── HasChanges (bool)
│   │   │   ├── HasUndoableChanges (bool)
│   │   │   ├── SelectedCount (int)
│   │   │   ├── HasSelection (bool)
│   │   │   ├── CanUndoSelected (bool)
│   │   │   └── DisplayItems → grouped or flat view
│   │   ├── Commands
│   │   │   ├── LoadHistoryCommand
│   │   │   ├── RefreshCommand
│   │   │   ├── UndoSelectedCommand
│   │   │   ├── UndoAllCommand
│   │   │   ├── ClearHistoryCommand
│   │   │   ├── ExportCommand
│   │   │   ├── ToggleGroupingCommand
│   │   │   ├── ToggleFiltersCommand
│   │   │   ├── ApplyFilterCommand
│   │   │   ├── ClearFilterCommand
│   │   │   └── SelectAllCommand
│   │   └── Events
│   │       ├── ShowDiffRequested
│   │       ├── NavigateToFileRequested
│   │       └── HistoryCleared
│   ├── ChangeHistoryItemViewModel (individual change)
│   │   ├── Observable Properties
│   │   │   ├── Record (FileChangeRecord)
│   │   │   ├── CanUndo (bool)
│   │   │   ├── IsUndoing (bool)
│   │   │   ├── WasUndone (bool)
│   │   │   ├── IsSelected (bool)
│   │   │   ├── IsExpanded (bool)
│   │   │   ├── Diff (DiffResult?)
│   │   │   └── IsDiffLoading (bool)
│   │   ├── Computed Properties
│   │   │   ├── FileName (string)
│   │   │   ├── RelativePath (string)
│   │   │   ├── RelativeTime (string)
│   │   │   ├── AbsoluteTime (string)
│   │   │   ├── ChangeTypeLabel (string)
│   │   │   ├── ChangeTypeIcon (string)
│   │   │   ├── ChangeTypeColor (IBrush)
│   │   │   ├── TimeRemaining (string?)
│   │   │   ├── TimeRemainingProgress (double)
│   │   │   ├── IsExpiringSoon (bool)
│   │   │   ├── LineStats (string)
│   │   │   └── FileSizeChange (string)
│   │   ├── Commands
│   │   │   ├── UndoCommand
│   │   │   ├── ViewDiffCommand
│   │   │   ├── OpenFileCommand
│   │   │   ├── CopyPathCommand
│   │   │   └── ToggleExpandCommand
│   │   └── Methods
│   │       ├── LoadDiffAsync()
│   │       ├── MarkAsUndone()
│   │       └── UpdateTimeRemaining()
│   └── ChangeHistoryGroupViewModel (grouped changes)
│       ├── Observable Properties
│       │   ├── GroupKey (string)
│       │   ├── GroupLabel (string)
│       │   ├── Items (ObservableCollection<ChangeHistoryItemViewModel>)
│       │   ├── IsExpanded (bool)
│       │   └── IsAllSelected (bool)
│       ├── Computed Properties
│       │   ├── ItemCount (int)
│       │   ├── UndoableCount (int)
│       │   ├── HasUndoable (bool)
│       │   └── GroupIcon (string)
│       └── Commands
│           ├── ToggleExpandCommand
│           ├── SelectAllCommand
│           └── UndoAllInGroupCommand
├── View Layer
│   ├── ChangeHistoryPanel.axaml
│   │   ├── Header Section
│   │   │   ├── Title + stats summary
│   │   │   ├── Search box
│   │   │   ├── Filter toggle
│   │   │   ├── Group by dropdown
│   │   │   └── Action buttons (Undo All, Clear, Export)
│   │   ├── Filter Panel (collapsible)
│   │   │   ├── Change type checkboxes
│   │   │   ├── Date range picker
│   │   │   ├── File type filter
│   │   │   ├── Only undoable toggle
│   │   │   └── Apply/Clear buttons
│   │   ├── Content Area
│   │   │   ├── Loading state
│   │   │   ├── Empty state
│   │   │   ├── Error state
│   │   │   ├── Flat list view
│   │   │   └── Grouped tree view
│   │   └── Footer Section
│   │       ├── Selection count
│   │       ├── Total stats
│   │       └── Batch action buttons
│   ├── ChangeHistoryItem.axaml
│   │   ├── Selection checkbox
│   │   ├── Change type icon
│   │   ├── File info (name, path)
│   │   ├── Time info (relative + countdown)
│   │   ├── Line stats (+/-)
│   │   ├── Undo button with progress
│   │   ├── Action menu (View Diff, Open, Copy Path)
│   │   └── Expandable diff preview
│   ├── ChangeHistoryGroup.axaml
│   │   ├── Expand/collapse chevron
│   │   ├── Group icon + label
│   │   ├── Item count badge
│   │   ├── Group actions
│   │   └── Nested item list
│   └── ChangeHistoryFilterPanel.axaml
│       ├── Change type filter
│       ├── Date range inputs
│       ├── File extension filter
│       └── Action buttons
├── Export Functionality
│   ├── ChangeHistoryExporter
│   │   ├── ExportToJson()
│   │   ├── ExportToCsv()
│   │   ├── ExportToMarkdown()
│   │   └── ExportToUnifiedDiff()
│   └── Export Formats
│       ├── JSON (structured data)
│       ├── CSV (spreadsheet-friendly)
│       ├── Markdown (documentation)
│       └── Unified Diff (git-compatible)
└── Styling
    ├── history-panel (container)
    ├── history-item (row style)
    ├── history-item:undoable (active state)
    ├── history-item:undone (completed state)
    ├── history-item:expiring-soon (warning state)
    ├── history-group (group header)
    ├── diff-preview (inline diff style)
    ├── time-remaining (countdown style)
    └── stats-badge (statistics display)
```

---

## Architecture

### Component Interaction Diagram

```
┌──────────────────────────────────────────────────────────────────────────┐
│                            MainWindow                                     │
│  ┌────────────────────────────────────────────────────────────────────┐  │
│  │                         Side Panel                                  │  │
│  │  ┌──────────────────────────────────────────────────────────────┐  │  │
│  │  │                    ChangeHistoryPanel                         │  │  │
│  │  │                                                               │  │  │
│  │  │  ┌─────────────────────────────────────────────────────────┐ │  │  │
│  │  │  │  Header: "Recent Changes" | Search | Filters | Actions  │ │  │  │
│  │  │  └─────────────────────────────────────────────────────────┘ │  │  │
│  │  │                                                               │  │  │
│  │  │  ┌─────────────────────────────────────────────────────────┐ │  │  │
│  │  │  │  Filter Panel (when expanded)                           │ │  │  │
│  │  │  │  [x] Created [x] Modified [x] Deleted | Date Range      │ │  │  │
│  │  │  └─────────────────────────────────────────────────────────┘ │  │  │
│  │  │                                                               │  │  │
│  │  │  ┌─────────────────────────────────────────────────────────┐ │  │  │
│  │  │  │  ┌───────────────────────────────────────────────────┐  │ │  │  │
│  │  │  │  │ [+] UserService.cs          2 min ago    [Undo]  │  │ │  │  │
│  │  │  │  │     Modified | +15 -3 | 28:45 remaining          │  │ │  │  │
│  │  │  │  ├───────────────────────────────────────────────────┤  │ │  │  │
│  │  │  │  │ [+] config.json              5 min ago    [Undo]  │  │ │  │  │
│  │  │  │  │     Created | +42 | 25:30 remaining              │  │ │  │  │
│  │  │  │  ├───────────────────────────────────────────────────┤  │ │  │  │
│  │  │  │  │ [ ] helpers.ts               1 hour ago  [Undone] │  │ │  │  │
│  │  │  │  │     Modified | +8 -12 | Expired                  │  │ │  │  │
│  │  │  │  └───────────────────────────────────────────────────┘  │ │  │  │
│  │  │  └─────────────────────────────────────────────────────────┘ │  │  │
│  │  │                                                               │  │  │
│  │  │  ┌─────────────────────────────────────────────────────────┐ │  │  │
│  │  │  │  Footer: 3 changes | 2 undoable | [Undo Selected]      │ │  │  │
│  │  │  └─────────────────────────────────────────────────────────┘ │  │  │
│  │  │                                                               │  │  │
│  │  └──────────────────────────────────────────────────────────────┘  │  │
│  └────────────────────────────────────────────────────────────────────┘  │
└──────────────────────────────────────────────────────────────────────────┘
```

### Data Flow Architecture

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          Data Flow Architecture                              │
└─────────────────────────────────────────────────────────────────────────────┘

                    FileChangeService
                          │
                          │ FileChanged event
                          ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                           IUndoManager                                       │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │                    FileChangeRecord Storage                           │  │
│  │  • In-memory for active session                                       │  │
│  │  • Persisted to disk for history                                      │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
│  Events:                                                                    │
│  ├── ChangeRecorded ─────────────────────────────────────────────────────┐  │
│  ├── ChangeUndone ───────────────────────────────────────────────────────┤  │
│  └── UndoExpired ────────────────────────────────────────────────────────┤  │
└──────────────────────────────────────────────────────────────────────────┼──┘
                                                                           │
                                                                           ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                       IChangeHistoryService                                  │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │                    ChangeHistoryService                               │  │
│  │                                                                       │  │
│  │  Query Methods:                                                       │  │
│  │  ├── GetHistoryAsync(filter) ──► Filtered records                     │  │
│  │  ├── GetStatsAsync(filter) ────► Aggregated statistics                │  │
│  │  ├── GetGroupedByFileAsync() ──► Records grouped by file              │  │
│  │  └── SearchAsync(text) ────────► Text search results                  │  │
│  │                                                                       │  │
│  │  Mutation Methods:                                                    │  │
│  │  ├── ClearHistoryAsync() ──────► Remove old records                   │  │
│  │  └── ExportAsync() ────────────► Generate export file                 │  │
│  │                                                                       │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
└───────────────────────────────────────────────────────────────────────────┼─┘
                                                                            │
                                                                            ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                       ChangeHistoryViewModel                                 │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │                    State Management                                   │  │
│  │                                                                       │  │
│  │  ├── Items: ObservableCollection<ChangeHistoryItemViewModel>          │  │
│  │  ├── GroupedItems: ObservableCollection<ChangeHistoryGroupViewModel>  │  │
│  │  ├── Filter: ChangeHistoryFilter (reactive)                           │  │
│  │  ├── Stats: ChangeHistoryStats (computed)                             │  │
│  │  └── Selection state tracking                                         │  │
│  │                                                                       │  │
│  │  Event Subscriptions:                                                 │  │
│  │  ├── UndoManager.ChangeRecorded → Add new item                        │  │
│  │  ├── UndoManager.ChangeUndone → Update item state                     │  │
│  │  └── UndoManager.TimeRemainingChanged → Update countdown              │  │
│  │                                                                       │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
└───────────────────────────────────────────────────────────────────────────┼─┘
                                                                            │
                                                                            ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                         ChangeHistoryPanel                                   │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │                       AXAML View                                      │  │
│  │                                                                       │  │
│  │  ├── Header with search and controls                                  │  │
│  │  ├── Collapsible filter panel                                         │  │
│  │  ├── Virtualized ListBox for performance                              │  │
│  │  ├── TreeView for grouped display                                     │  │
│  │  └── Footer with stats and batch actions                              │  │
│  │                                                                       │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Undo Countdown Integration

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        Undo Countdown Integration                            │
└─────────────────────────────────────────────────────────────────────────────┘

  UndoManager (1-second timer)
         │
         │ TimeRemainingChanged event (every second)
         ▼
  ┌──────────────────┐
  │ChangeHistory     │
  │ViewModel         │
  └────────┬─────────┘
           │
           │ Updates all ChangeHistoryItemViewModels
           ▼
  ┌──────────────────────────────────────────────────────────────────────────┐
  │                    ChangeHistoryItemViewModel                             │
  │                                                                          │
  │  UpdateTimeRemaining() called every second:                              │
  │                                                                          │
  │  ┌────────────────────────────────────────────────────────────────────┐  │
  │  │  var remaining = Record.ExpiresAt - DateTime.UtcNow;               │  │
  │  │                                                                    │  │
  │  │  if (remaining <= TimeSpan.Zero)                                   │  │
  │  │  {                                                                 │  │
  │  │      CanUndo = false;                                              │  │
  │  │      TimeRemaining = "Expired";                                    │  │
  │  │      TimeRemainingProgress = 0;                                    │  │
  │  │  }                                                                 │  │
  │  │  else                                                              │  │
  │  │  {                                                                 │  │
  │  │      CanUndo = true;                                               │  │
  │  │      TimeRemaining = FormatTimeSpan(remaining);                    │  │
  │  │      TimeRemainingProgress = remaining / TotalWindow;              │  │
  │  │      IsExpiringSoon = remaining < TimeSpan.FromMinutes(1);         │  │
  │  │  }                                                                 │  │
  │  └────────────────────────────────────────────────────────────────────┘  │
  │                                                                          │
  │  Visual Updates:                                                         │
  │  ├── TimeRemaining: "28:45" → "28:44" → ...                              │
  │  ├── Progress bar fills from right to left                               │
  │  ├── Color changes when < 60s (yellow warning)                           │
  │  └── Color changes when < 10s (red urgent)                               │
  │                                                                          │
  └──────────────────────────────────────────────────────────────────────────┘

  Time Display States:

  ┌────────────────┐    ┌────────────────┐    ┌────────────────┐
  │  28:45         │    │  0:45          │    │  Expired       │
  │  ████████████  │    │  █             │    │                │
  │  (green/normal)│    │  (yellow/warn) │    │  (gray/done)   │
  └────────────────┘    └────────────────┘    └────────────────┘
```

---

## Detailed Design

### Core Models

#### ChangeHistoryFilter Record

```csharp
// src/SeniorIntern.Core/Models/ChangeHistoryFilter.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Filter criteria for change history queries.
/// </summary>
public sealed record ChangeHistoryFilter
{
    /// <summary>
    /// Text to search in file names and paths.
    /// </summary>
    public string? SearchText { get; init; }

    /// <summary>
    /// File extensions to include (e.g., ".cs", ".ts").
    /// Null means include all.
    /// </summary>
    public IReadOnlySet<string>? FileExtensions { get; init; }

    /// <summary>
    /// Change types to include.
    /// Null means include all.
    /// </summary>
    public IReadOnlySet<FileChangeType>? ChangeTypes { get; init; }

    /// <summary>
    /// Date range for filtering by timestamp.
    /// </summary>
    public DateTimeRange? DateRange { get; init; }

    /// <summary>
    /// Only include changes that can still be undone.
    /// </summary>
    public bool OnlyUndoable { get; init; }

    /// <summary>
    /// Filter to changes from a specific session/conversation.
    /// </summary>
    public Guid? SessionId { get; init; }

    /// <summary>
    /// Filter to changes from a specific message.
    /// </summary>
    public Guid? MessageId { get; init; }

    /// <summary>
    /// Sort order for results.
    /// </summary>
    public ChangeHistorySortOrder SortOrder { get; init; } = ChangeHistorySortOrder.NewestFirst;

    /// <summary>
    /// Default filter with no restrictions.
    /// </summary>
    public static ChangeHistoryFilter Default => new();

    /// <summary>
    /// Filter for only undoable changes.
    /// </summary>
    public static ChangeHistoryFilter UndoableOnly => new() { OnlyUndoable = true };

    /// <summary>
    /// Filter for changes in the last hour.
    /// </summary>
    public static ChangeHistoryFilter LastHour => new()
    {
        DateRange = new DateTimeRange(DateTime.UtcNow.AddHours(-1), null)
    };

    /// <summary>
    /// Filter for changes today.
    /// </summary>
    public static ChangeHistoryFilter Today => new()
    {
        DateRange = new DateTimeRange(DateTime.UtcNow.Date, null)
    };

    /// <summary>
    /// Checks if a record matches this filter.
    /// </summary>
    public bool Matches(FileChangeRecord record)
    {
        // Search text filter
        if (!string.IsNullOrWhiteSpace(SearchText))
        {
            var searchLower = SearchText.ToLowerInvariant();
            if (!record.FilePath.ToLowerInvariant().Contains(searchLower) &&
                !record.RelativePath.ToLowerInvariant().Contains(searchLower))
            {
                return false;
            }
        }

        // File extension filter
        if (FileExtensions is { Count: > 0 })
        {
            var ext = Path.GetExtension(record.FilePath);
            if (!FileExtensions.Contains(ext))
            {
                return false;
            }
        }

        // Change type filter
        if (ChangeTypes is { Count: > 0 })
        {
            if (!ChangeTypes.Contains(record.ChangeType))
            {
                return false;
            }
        }

        // Date range filter
        if (DateRange is not null)
        {
            if (DateRange.Start.HasValue && record.ChangedAt < DateRange.Start.Value)
            {
                return false;
            }
            if (DateRange.End.HasValue && record.ChangedAt > DateRange.End.Value)
            {
                return false;
            }
        }

        // Session filter
        if (SessionId.HasValue && record.SessionId != SessionId.Value)
        {
            return false;
        }

        // Message filter
        if (MessageId.HasValue && record.MessageId != MessageId.Value)
        {
            return false;
        }

        return true;
    }
}

/// <summary>
/// Date/time range for filtering.
/// </summary>
public sealed record DateTimeRange(DateTime? Start, DateTime? End)
{
    public bool Contains(DateTime value)
    {
        if (Start.HasValue && value < Start.Value) return false;
        if (End.HasValue && value > End.Value) return false;
        return true;
    }

    public static DateTimeRange LastNDays(int days) =>
        new(DateTime.UtcNow.AddDays(-days), null);

    public static DateTimeRange LastNHours(int hours) =>
        new(DateTime.UtcNow.AddHours(-hours), null);
}

/// <summary>
/// Sort order for change history.
/// </summary>
public enum ChangeHistorySortOrder
{
    /// <summary>
    /// Most recent changes first (default).
    /// </summary>
    NewestFirst,

    /// <summary>
    /// Oldest changes first.
    /// </summary>
    OldestFirst,

    /// <summary>
    /// Alphabetically by file name.
    /// </summary>
    FileName,

    /// <summary>
    /// Grouped by change type.
    /// </summary>
    ChangeType,

    /// <summary>
    /// Changes expiring soonest first.
    /// </summary>
    ExpiringSoonest
}
```

#### ChangeHistoryStats Record

```csharp
// src/SeniorIntern.Core/Models/ChangeHistoryStats.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Aggregated statistics for change history.
/// </summary>
public sealed record ChangeHistoryStats
{
    /// <summary>
    /// Total number of changes in the filtered set.
    /// </summary>
    public int TotalChanges { get; init; }

    /// <summary>
    /// Number of changes that can still be undone.
    /// </summary>
    public int UndoableCount { get; init; }

    /// <summary>
    /// Number of changes that were undone.
    /// </summary>
    public int UndoneCount { get; init; }

    /// <summary>
    /// Number of unique files affected.
    /// </summary>
    public int FilesAffected { get; init; }

    /// <summary>
    /// Total lines added across all changes.
    /// </summary>
    public int TotalLinesAdded { get; init; }

    /// <summary>
    /// Total lines removed across all changes.
    /// </summary>
    public int TotalLinesRemoved { get; init; }

    /// <summary>
    /// Net line change (added - removed).
    /// </summary>
    public int NetLineChange => TotalLinesAdded - TotalLinesRemoved;

    /// <summary>
    /// Timestamp of the oldest change.
    /// </summary>
    public DateTime? OldestChange { get; init; }

    /// <summary>
    /// Timestamp of the newest change.
    /// </summary>
    public DateTime? NewestChange { get; init; }

    /// <summary>
    /// Time span covered by the changes.
    /// </summary>
    public TimeSpan? TimeSpan => OldestChange.HasValue && NewestChange.HasValue
        ? NewestChange.Value - OldestChange.Value
        : null;

    /// <summary>
    /// Breakdown by change type.
    /// </summary>
    public IReadOnlyDictionary<FileChangeType, int> ByChangeType { get; init; } =
        new Dictionary<FileChangeType, int>();

    /// <summary>
    /// Breakdown by file extension.
    /// </summary>
    public IReadOnlyDictionary<string, int> ByFileExtension { get; init; } =
        new Dictionary<string, int>();

    /// <summary>
    /// Empty stats instance.
    /// </summary>
    public static ChangeHistoryStats Empty => new();

    /// <summary>
    /// Computes stats from a collection of records.
    /// </summary>
    public static ChangeHistoryStats FromRecords(
        IEnumerable<FileChangeRecord> records,
        Func<FileChangeRecord, bool>? canUndoPredicate = null)
    {
        var list = records.ToList();
        if (list.Count == 0) return Empty;

        var byChangeType = list
            .GroupBy(r => r.ChangeType)
            .ToDictionary(g => g.Key, g => g.Count());

        var byExtension = list
            .GroupBy(r => Path.GetExtension(r.FilePath).ToLowerInvariant())
            .Where(g => !string.IsNullOrEmpty(g.Key))
            .ToDictionary(g => g.Key, g => g.Count());

        var undoableCount = canUndoPredicate is not null
            ? list.Count(canUndoPredicate)
            : 0;

        return new ChangeHistoryStats
        {
            TotalChanges = list.Count,
            UndoableCount = undoableCount,
            UndoneCount = list.Count(r => r.WasUndone),
            FilesAffected = list.Select(r => r.FilePath).Distinct().Count(),
            TotalLinesAdded = list.Sum(r => r.LinesAdded),
            TotalLinesRemoved = list.Sum(r => r.LinesRemoved),
            OldestChange = list.Min(r => r.ChangedAt),
            NewestChange = list.Max(r => r.ChangedAt),
            ByChangeType = byChangeType,
            ByFileExtension = byExtension
        };
    }
}
```

#### HistoryGroupMode Enum

```csharp
// src/SeniorIntern.Core/Models/HistoryGroupMode.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Grouping modes for change history display.
/// </summary>
public enum HistoryGroupMode
{
    /// <summary>
    /// No grouping - flat list.
    /// </summary>
    None,

    /// <summary>
    /// Group by file path.
    /// </summary>
    ByFile,

    /// <summary>
    /// Group by parent directory.
    /// </summary>
    ByDirectory,

    /// <summary>
    /// Group by change type.
    /// </summary>
    ByChangeType,

    /// <summary>
    /// Group by time period (Today, Yesterday, This Week, etc.).
    /// </summary>
    ByTimePeriod,

    /// <summary>
    /// Group by session/conversation.
    /// </summary>
    BySession
}
```

### Service Layer

#### IChangeHistoryService Interface

```csharp
// src/SeniorIntern.Core/Interfaces/IChangeHistoryService.cs
using SeniorIntern.Core.Models;

namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Service for querying and managing change history.
/// </summary>
public interface IChangeHistoryService
{
    /// <summary>
    /// Gets change history matching the filter.
    /// </summary>
    Task<IReadOnlyList<FileChangeRecord>> GetHistoryAsync(
        ChangeHistoryFilter? filter = null,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets a page of change history.
    /// </summary>
    Task<PagedResult<FileChangeRecord>> GetHistoryPagedAsync(
        ChangeHistoryFilter? filter,
        int page,
        int pageSize,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets aggregated statistics for the filtered history.
    /// </summary>
    Task<ChangeHistoryStats> GetStatsAsync(
        ChangeHistoryFilter? filter = null,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets history grouped by file.
    /// </summary>
    Task<IReadOnlyList<ChangeHistoryGroup>> GetGroupedByFileAsync(
        ChangeHistoryFilter? filter = null,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets history grouped by time period.
    /// </summary>
    Task<IReadOnlyList<ChangeHistoryGroup>> GetGroupedByTimePeriodAsync(
        ChangeHistoryFilter? filter = null,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets history grouped by change type.
    /// </summary>
    Task<IReadOnlyList<ChangeHistoryGroup>> GetGroupedByChangeTypeAsync(
        ChangeHistoryFilter? filter = null,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Searches history by text.
    /// </summary>
    Task<IReadOnlyList<FileChangeRecord>> SearchAsync(
        string searchText,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Exports history to a stream in the specified format.
    /// </summary>
    Task<Stream> ExportAsync(
        ChangeHistoryExportFormat format,
        ChangeHistoryFilter? filter = null,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Clears history older than the specified date.
    /// </summary>
    Task<int> ClearHistoryAsync(
        DateTime? olderThan = null,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets the total count of history items.
    /// </summary>
    Task<int> GetCountAsync(
        ChangeHistoryFilter? filter = null,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Raised when new history is recorded.
    /// </summary>
    event EventHandler<FileChangeRecord>? HistoryRecorded;

    /// <summary>
    /// Raised when history is cleared.
    /// </summary>
    event EventHandler<int>? HistoryCleared;
}

/// <summary>
/// Grouped change history records.
/// </summary>
public sealed record ChangeHistoryGroup(
    string Key,
    string Label,
    string? Icon,
    IReadOnlyList<FileChangeRecord> Items);

/// <summary>
/// Paged result wrapper.
/// </summary>
public sealed record PagedResult<T>(
    IReadOnlyList<T> Items,
    int TotalCount,
    int Page,
    int PageSize)
{
    public int TotalPages => (int)Math.Ceiling(TotalCount / (double)PageSize);
    public bool HasNextPage => Page < TotalPages;
    public bool HasPreviousPage => Page > 1;
}

/// <summary>
/// Export format options.
/// </summary>
public enum ChangeHistoryExportFormat
{
    Json,
    Csv,
    Markdown,
    UnifiedDiff
}
```

#### ChangeHistoryService Implementation

```csharp
// src/SeniorIntern.Services/ChangeHistoryService.cs
using System.Text;
using System.Text.Json;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;

namespace SeniorIntern.Services;

/// <summary>
/// Implements change history queries and management.
/// </summary>
public sealed class ChangeHistoryService : IChangeHistoryService
{
    private readonly IUndoManager _undoManager;
    private readonly IDiffService _diffService;
    private readonly ISettingsService _settingsService;

    public event EventHandler<FileChangeRecord>? HistoryRecorded;
    public event EventHandler<int>? HistoryCleared;

    public ChangeHistoryService(
        IUndoManager undoManager,
        IDiffService diffService,
        ISettingsService settingsService)
    {
        _undoManager = undoManager;
        _diffService = diffService;
        _settingsService = settingsService;

        // Forward events from undo manager
        _undoManager.ChangeRecorded += (_, record) =>
            HistoryRecorded?.Invoke(this, record);
    }

    public async Task<IReadOnlyList<FileChangeRecord>> GetHistoryAsync(
        ChangeHistoryFilter? filter = null,
        CancellationToken cancellationToken = default)
    {
        var settings = await _settingsService.GetSettingsAsync();
        var allRecords = await _undoManager.GetRecentChangesAsync(
            settings.MaxChangeHistoryItems);

        var filtered = ApplyFilter(allRecords, filter);
        return ApplySort(filtered, filter?.SortOrder ?? ChangeHistorySortOrder.NewestFirst)
            .ToList();
    }

    public async Task<PagedResult<FileChangeRecord>> GetHistoryPagedAsync(
        ChangeHistoryFilter? filter,
        int page,
        int pageSize,
        CancellationToken cancellationToken = default)
    {
        var allFiltered = await GetHistoryAsync(filter, cancellationToken);
        var totalCount = allFiltered.Count;

        var items = allFiltered
            .Skip((page - 1) * pageSize)
            .Take(pageSize)
            .ToList();

        return new PagedResult<FileChangeRecord>(items, totalCount, page, pageSize);
    }

    public async Task<ChangeHistoryStats> GetStatsAsync(
        ChangeHistoryFilter? filter = null,
        CancellationToken cancellationToken = default)
    {
        var records = await GetHistoryAsync(filter, cancellationToken);
        return ChangeHistoryStats.FromRecords(records, _undoManager.CanUndo);
    }

    public async Task<IReadOnlyList<ChangeHistoryGroup>> GetGroupedByFileAsync(
        ChangeHistoryFilter? filter = null,
        CancellationToken cancellationToken = default)
    {
        var records = await GetHistoryAsync(filter, cancellationToken);

        return records
            .GroupBy(r => r.FilePath)
            .Select(g => new ChangeHistoryGroup(
                Key: g.Key,
                Label: Path.GetFileName(g.Key),
                Icon: GetFileIcon(g.Key),
                Items: g.OrderByDescending(r => r.ChangedAt).ToList()))
            .OrderByDescending(g => g.Items.Max(r => r.ChangedAt))
            .ToList();
    }

    public async Task<IReadOnlyList<ChangeHistoryGroup>> GetGroupedByTimePeriodAsync(
        ChangeHistoryFilter? filter = null,
        CancellationToken cancellationToken = default)
    {
        var records = await GetHistoryAsync(filter, cancellationToken);
        var now = DateTime.UtcNow;
        var today = now.Date;

        var groups = new List<(string Key, string Label, List<FileChangeRecord> Items)>
        {
            ("today", "Today", new List<FileChangeRecord>()),
            ("yesterday", "Yesterday", new List<FileChangeRecord>()),
            ("this_week", "This Week", new List<FileChangeRecord>()),
            ("this_month", "This Month", new List<FileChangeRecord>()),
            ("older", "Older", new List<FileChangeRecord>())
        };

        foreach (var record in records)
        {
            var recordDate = record.ChangedAt.Date;

            if (recordDate == today)
                groups[0].Items.Add(record);
            else if (recordDate == today.AddDays(-1))
                groups[1].Items.Add(record);
            else if (recordDate >= today.AddDays(-(int)today.DayOfWeek))
                groups[2].Items.Add(record);
            else if (recordDate >= today.AddMonths(-1))
                groups[3].Items.Add(record);
            else
                groups[4].Items.Add(record);
        }

        return groups
            .Where(g => g.Items.Count > 0)
            .Select(g => new ChangeHistoryGroup(
                Key: g.Key,
                Label: g.Label,
                Icon: "CalendarIcon",
                Items: g.Items.OrderByDescending(r => r.ChangedAt).ToList()))
            .ToList();
    }

    public async Task<IReadOnlyList<ChangeHistoryGroup>> GetGroupedByChangeTypeAsync(
        ChangeHistoryFilter? filter = null,
        CancellationToken cancellationToken = default)
    {
        var records = await GetHistoryAsync(filter, cancellationToken);

        return records
            .GroupBy(r => r.ChangeType)
            .Select(g => new ChangeHistoryGroup(
                Key: g.Key.ToString(),
                Label: GetChangeTypeLabel(g.Key),
                Icon: GetChangeTypeIcon(g.Key),
                Items: g.OrderByDescending(r => r.ChangedAt).ToList()))
            .OrderBy(g => g.Key)
            .ToList();
    }

    public async Task<IReadOnlyList<FileChangeRecord>> SearchAsync(
        string searchText,
        CancellationToken cancellationToken = default)
    {
        var filter = new ChangeHistoryFilter { SearchText = searchText };
        return await GetHistoryAsync(filter, cancellationToken);
    }

    public async Task<Stream> ExportAsync(
        ChangeHistoryExportFormat format,
        ChangeHistoryFilter? filter = null,
        CancellationToken cancellationToken = default)
    {
        var records = await GetHistoryAsync(filter, cancellationToken);
        var stream = new MemoryStream();

        switch (format)
        {
            case ChangeHistoryExportFormat.Json:
                await ExportToJsonAsync(stream, records);
                break;
            case ChangeHistoryExportFormat.Csv:
                await ExportToCsvAsync(stream, records);
                break;
            case ChangeHistoryExportFormat.Markdown:
                await ExportToMarkdownAsync(stream, records);
                break;
            case ChangeHistoryExportFormat.UnifiedDiff:
                await ExportToUnifiedDiffAsync(stream, records);
                break;
        }

        stream.Position = 0;
        return stream;
    }

    public async Task<int> ClearHistoryAsync(
        DateTime? olderThan = null,
        CancellationToken cancellationToken = default)
    {
        var clearedCount = await _undoManager.ClearHistoryAsync(olderThan);
        HistoryCleared?.Invoke(this, clearedCount);
        return clearedCount;
    }

    public async Task<int> GetCountAsync(
        ChangeHistoryFilter? filter = null,
        CancellationToken cancellationToken = default)
    {
        var records = await GetHistoryAsync(filter, cancellationToken);
        return records.Count;
    }

    // ═══════════════════════════════════════════════════════════════
    // Private Helper Methods
    // ═══════════════════════════════════════════════════════════════

    private static IEnumerable<FileChangeRecord> ApplyFilter(
        IEnumerable<FileChangeRecord> records,
        ChangeHistoryFilter? filter)
    {
        if (filter is null) return records;
        return records.Where(filter.Matches);
    }

    private static IOrderedEnumerable<FileChangeRecord> ApplySort(
        IEnumerable<FileChangeRecord> records,
        ChangeHistorySortOrder sortOrder)
    {
        return sortOrder switch
        {
            ChangeHistorySortOrder.NewestFirst =>
                records.OrderByDescending(r => r.ChangedAt),
            ChangeHistorySortOrder.OldestFirst =>
                records.OrderBy(r => r.ChangedAt),
            ChangeHistorySortOrder.FileName =>
                records.OrderBy(r => Path.GetFileName(r.FilePath)),
            ChangeHistorySortOrder.ChangeType =>
                records.OrderBy(r => r.ChangeType),
            ChangeHistorySortOrder.ExpiringSoonest =>
                records.OrderBy(r => r.ExpiresAt ?? DateTime.MaxValue),
            _ => records.OrderByDescending(r => r.ChangedAt)
        };
    }

    private static string GetFileIcon(string filePath)
    {
        var ext = Path.GetExtension(filePath).ToLowerInvariant();
        return ext switch
        {
            ".cs" => "CSharpIcon",
            ".ts" or ".tsx" => "TypeScriptIcon",
            ".js" or ".jsx" => "JavaScriptIcon",
            ".json" => "JsonIcon",
            ".xml" or ".xaml" or ".axaml" => "XmlIcon",
            ".md" => "MarkdownIcon",
            ".css" or ".scss" or ".sass" => "CssIcon",
            ".html" => "HtmlIcon",
            _ => "FileIcon"
        };
    }

    private static string GetChangeTypeLabel(FileChangeType changeType) =>
        changeType switch
        {
            FileChangeType.Created => "Created",
            FileChangeType.Modified => "Modified",
            FileChangeType.Deleted => "Deleted",
            FileChangeType.Renamed => "Renamed",
            _ => "Changed"
        };

    private static string GetChangeTypeIcon(FileChangeType changeType) =>
        changeType switch
        {
            FileChangeType.Created => "PlusCircleIcon",
            FileChangeType.Modified => "EditIcon",
            FileChangeType.Deleted => "TrashIcon",
            FileChangeType.Renamed => "ArrowRightIcon",
            _ => "FileIcon"
        };

    private async Task ExportToJsonAsync(
        Stream stream,
        IReadOnlyList<FileChangeRecord> records)
    {
        var options = new JsonSerializerOptions
        {
            WriteIndented = true,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        };
        await JsonSerializer.SerializeAsync(stream, records, options);
    }

    private async Task ExportToCsvAsync(
        Stream stream,
        IReadOnlyList<FileChangeRecord> records)
    {
        await using var writer = new StreamWriter(stream, leaveOpen: true);

        // Header
        await writer.WriteLineAsync(
            "Id,FilePath,ChangeType,ChangedAt,LinesAdded,LinesRemoved,WasUndone");

        // Data rows
        foreach (var record in records)
        {
            await writer.WriteLineAsync(
                $"\"{record.Id}\"," +
                $"\"{record.FilePath.Replace("\"", "\"\"")}\"," +
                $"\"{record.ChangeType}\"," +
                $"\"{record.ChangedAt:O}\"," +
                $"{record.LinesAdded}," +
                $"{record.LinesRemoved}," +
                $"{record.WasUndone}");
        }
    }

    private async Task ExportToMarkdownAsync(
        Stream stream,
        IReadOnlyList<FileChangeRecord> records)
    {
        await using var writer = new StreamWriter(stream, leaveOpen: true);

        await writer.WriteLineAsync("# Change History Export");
        await writer.WriteLineAsync();
        await writer.WriteLineAsync($"Exported: {DateTime.Now:F}");
        await writer.WriteLineAsync($"Total Changes: {records.Count}");
        await writer.WriteLineAsync();
        await writer.WriteLineAsync("---");
        await writer.WriteLineAsync();

        foreach (var record in records)
        {
            await writer.WriteLineAsync($"## {Path.GetFileName(record.FilePath)}");
            await writer.WriteLineAsync();
            await writer.WriteLineAsync($"- **Path**: `{record.RelativePath}`");
            await writer.WriteLineAsync($"- **Type**: {record.ChangeType}");
            await writer.WriteLineAsync($"- **Time**: {record.ChangedAt:g}");
            await writer.WriteLineAsync($"- **Lines**: +{record.LinesAdded} -{record.LinesRemoved}");
            if (record.WasUndone)
            {
                await writer.WriteLineAsync("- **Status**: Undone");
            }
            await writer.WriteLineAsync();
        }
    }

    private async Task ExportToUnifiedDiffAsync(
        Stream stream,
        IReadOnlyList<FileChangeRecord> records)
    {
        await using var writer = new StreamWriter(stream, leaveOpen: true);

        foreach (var record in records)
        {
            if (record.OriginalContent is null || record.NewContent is null)
                continue;

            var diff = _diffService.ComputeUnifiedDiff(
                record.OriginalContent,
                record.NewContent,
                record.RelativePath);

            await writer.WriteLineAsync(diff);
            await writer.WriteLineAsync();
        }
    }
}
```

### ViewModel Layer

#### ChangeHistoryViewModel

```csharp
// src/SeniorIntern.Desktop/ViewModels/ChangeHistoryViewModel.cs
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;

namespace SeniorIntern.Desktop.ViewModels;

/// <summary>
/// ViewModel for the Change History Panel.
/// </summary>
public partial class ChangeHistoryViewModel : ViewModelBase, IDisposable
{
    private readonly IChangeHistoryService _historyService;
    private readonly IUndoManager _undoManager;
    private readonly IDiffService _diffService;
    private readonly ISettingsService _settingsService;
    private readonly IDispatcher _dispatcher;

    private CancellationTokenSource? _loadCts;
    private System.Timers.Timer? _updateTimer;

    // ═══════════════════════════════════════════════════════════════
    // Observable Properties
    // ═══════════════════════════════════════════════════════════════

    [ObservableProperty]
    private ObservableCollection<ChangeHistoryItemViewModel> _items = new();

    [ObservableProperty]
    private ObservableCollection<ChangeHistoryGroupViewModel> _groupedItems = new();

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(HasSelection))]
    [NotifyPropertyChangedFor(nameof(CanUndoSelected))]
    private ChangeHistoryItemViewModel? _selectedItem;

    [ObservableProperty]
    private ObservableCollection<ChangeHistoryItemViewModel> _selectedItems = new();

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(HasChanges))]
    [NotifyPropertyChangedFor(nameof(HasUndoableChanges))]
    private ChangeHistoryStats _stats = ChangeHistoryStats.Empty;

    [ObservableProperty]
    private ChangeHistoryFilter _filter = ChangeHistoryFilter.Default;

    [ObservableProperty]
    private bool _isLoading;

    [ObservableProperty]
    private bool _isGrouped;

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(IsGrouped))]
    private HistoryGroupMode _groupBy = HistoryGroupMode.None;

    [ObservableProperty]
    private string _searchText = string.Empty;

    [ObservableProperty]
    private bool _showFilters;

    [ObservableProperty]
    private string? _errorMessage;

    [ObservableProperty]
    private bool _onlyShowUndoable;

    // ═══════════════════════════════════════════════════════════════
    // Computed Properties
    // ═══════════════════════════════════════════════════════════════

    public bool HasChanges => Stats.TotalChanges > 0;
    public bool HasUndoableChanges => Stats.UndoableCount > 0;
    public int SelectedCount => SelectedItems.Count;
    public bool HasSelection => SelectedCount > 0;
    public bool CanUndoSelected => SelectedItems.Any(i => i.CanUndo);

    // ═══════════════════════════════════════════════════════════════
    // Events
    // ═══════════════════════════════════════════════════════════════

    public event EventHandler<FileChangeRecord>? ShowDiffRequested;
    public event EventHandler<string>? NavigateToFileRequested;
    public event EventHandler? HistoryCleared;

    // ═══════════════════════════════════════════════════════════════
    // Constructor
    // ═══════════════════════════════════════════════════════════════

    public ChangeHistoryViewModel(
        IChangeHistoryService historyService,
        IUndoManager undoManager,
        IDiffService diffService,
        ISettingsService settingsService,
        IDispatcher dispatcher)
    {
        _historyService = historyService;
        _undoManager = undoManager;
        _diffService = diffService;
        _settingsService = settingsService;
        _dispatcher = dispatcher;

        // Subscribe to undo manager events
        _undoManager.ChangeRecorded += OnChangeRecorded;
        _undoManager.ChangeUndone += OnChangeUndone;
        _undoManager.TimeRemainingChanged += OnTimeRemainingChanged;

        // Subscribe to history service events
        _historyService.HistoryCleared += OnHistoryCleared;

        // Track selection changes
        SelectedItems.CollectionChanged += OnSelectedItemsChanged;

        // Start update timer for relative times
        StartUpdateTimer();
    }

    // ═══════════════════════════════════════════════════════════════
    // Commands
    // ═══════════════════════════════════════════════════════════════

    [RelayCommand]
    private async Task LoadHistoryAsync()
    {
        _loadCts?.Cancel();
        _loadCts = new CancellationTokenSource();

        IsLoading = true;
        ErrorMessage = null;

        try
        {
            var filter = BuildFilter();
            var records = await _historyService.GetHistoryAsync(filter, _loadCts.Token);
            Stats = await _historyService.GetStatsAsync(filter, _loadCts.Token);

            await _dispatcher.InvokeAsync(() =>
            {
                Items.Clear();
                foreach (var record in records)
                {
                    Items.Add(CreateItemViewModel(record));
                }

                if (GroupBy != HistoryGroupMode.None)
                {
                    RefreshGroupedView();
                }
            });
        }
        catch (OperationCanceledException)
        {
            // Ignored - new load started
        }
        catch (Exception ex)
        {
            ErrorMessage = ex.Message;
        }
        finally
        {
            IsLoading = false;
        }
    }

    [RelayCommand]
    private async Task RefreshAsync()
    {
        await LoadHistoryAsync();
    }

    [RelayCommand(CanExecute = nameof(CanUndoSelected))]
    private async Task UndoSelectedAsync()
    {
        var toUndo = SelectedItems.Where(i => i.CanUndo).ToList();

        foreach (var item in toUndo)
        {
            await item.UndoCommand.ExecuteAsync(null);
        }

        await RefreshStatsAsync();
    }

    [RelayCommand(CanExecute = nameof(HasUndoableChanges))]
    private async Task UndoAllAsync()
    {
        var undoable = Items.Where(i => i.CanUndo).ToList();

        foreach (var item in undoable)
        {
            await item.UndoCommand.ExecuteAsync(null);
        }

        await RefreshStatsAsync();
    }

    [RelayCommand(CanExecute = nameof(HasChanges))]
    private async Task ClearHistoryAsync()
    {
        await _historyService.ClearHistoryAsync();

        Items.Clear();
        GroupedItems.Clear();
        Stats = ChangeHistoryStats.Empty;

        HistoryCleared?.Invoke(this, EventArgs.Empty);
    }

    [RelayCommand]
    private async Task ExportAsync(ChangeHistoryExportFormat format)
    {
        var filter = BuildFilter();
        var stream = await _historyService.ExportAsync(format, filter);

        // TODO: Show save dialog and write to file
        // For now, just create the export data
    }

    [RelayCommand]
    private void ToggleGrouping()
    {
        GroupBy = GroupBy switch
        {
            HistoryGroupMode.None => HistoryGroupMode.ByFile,
            HistoryGroupMode.ByFile => HistoryGroupMode.ByTimePeriod,
            HistoryGroupMode.ByTimePeriod => HistoryGroupMode.ByChangeType,
            HistoryGroupMode.ByChangeType => HistoryGroupMode.None,
            _ => HistoryGroupMode.None
        };

        IsGrouped = GroupBy != HistoryGroupMode.None;
        RefreshGroupedView();
    }

    [RelayCommand]
    private void ToggleFilters()
    {
        ShowFilters = !ShowFilters;
    }

    [RelayCommand]
    private async Task ApplyFilterAsync()
    {
        await LoadHistoryAsync();
    }

    [RelayCommand]
    private async Task ClearFilterAsync()
    {
        SearchText = string.Empty;
        OnlyShowUndoable = false;
        Filter = ChangeHistoryFilter.Default;
        await LoadHistoryAsync();
    }

    [RelayCommand]
    private void SelectAll()
    {
        SelectedItems.Clear();
        foreach (var item in Items)
        {
            item.IsSelected = true;
            SelectedItems.Add(item);
        }
    }

    [RelayCommand]
    private void ClearSelection()
    {
        foreach (var item in Items)
        {
            item.IsSelected = false;
        }
        SelectedItems.Clear();
    }

    // ═══════════════════════════════════════════════════════════════
    // Event Handlers
    // ═══════════════════════════════════════════════════════════════

    private void OnChangeRecorded(object? sender, FileChangeRecord record)
    {
        _dispatcher.InvokeAsync(() =>
        {
            var vm = CreateItemViewModel(record);
            Items.Insert(0, vm);

            // Update stats
            Stats = Stats with
            {
                TotalChanges = Stats.TotalChanges + 1,
                UndoableCount = Stats.UndoableCount + 1
            };

            // Trim to max items
            TrimToMaxItems();

            if (IsGrouped)
            {
                RefreshGroupedView();
            }
        });
    }

    private void OnChangeUndone(object? sender, FileChangeRecord record)
    {
        _dispatcher.InvokeAsync(() =>
        {
            var item = Items.FirstOrDefault(i => i.Record.Id == record.Id);
            item?.MarkAsUndone();

            Stats = Stats with
            {
                UndoableCount = Math.Max(0, Stats.UndoableCount - 1),
                UndoneCount = Stats.UndoneCount + 1
            };
        });
    }

    private void OnTimeRemainingChanged(object? sender, EventArgs e)
    {
        _dispatcher.InvokeAsync(() =>
        {
            foreach (var item in Items)
            {
                item.UpdateTimeRemaining();
            }
        });
    }

    private void OnHistoryCleared(object? sender, int count)
    {
        _dispatcher.InvokeAsync(async () =>
        {
            await LoadHistoryAsync();
        });
    }

    private void OnSelectedItemsChanged(object? sender, NotifyCollectionChangedEventArgs e)
    {
        OnPropertyChanged(nameof(SelectedCount));
        OnPropertyChanged(nameof(HasSelection));
        OnPropertyChanged(nameof(CanUndoSelected));
        UndoSelectedCommand.NotifyCanExecuteChanged();
    }

    // ═══════════════════════════════════════════════════════════════
    // Private Methods
    // ═══════════════════════════════════════════════════════════════

    private ChangeHistoryFilter BuildFilter()
    {
        return Filter with
        {
            SearchText = string.IsNullOrWhiteSpace(SearchText) ? null : SearchText,
            OnlyUndoable = OnlyShowUndoable
        };
    }

    private ChangeHistoryItemViewModel CreateItemViewModel(FileChangeRecord record)
    {
        var vm = new ChangeHistoryItemViewModel(record, _undoManager, _diffService);
        vm.ViewDiffRequested += (_, r) => ShowDiffRequested?.Invoke(this, r);
        vm.NavigateToFileRequested += (_, path) => NavigateToFileRequested?.Invoke(this, path);
        vm.PropertyChanged += (_, e) =>
        {
            if (e.PropertyName == nameof(ChangeHistoryItemViewModel.IsSelected))
            {
                if (vm.IsSelected && !SelectedItems.Contains(vm))
                {
                    SelectedItems.Add(vm);
                }
                else if (!vm.IsSelected && SelectedItems.Contains(vm))
                {
                    SelectedItems.Remove(vm);
                }
            }
        };
        return vm;
    }

    private void RefreshGroupedView()
    {
        GroupedItems.Clear();

        if (GroupBy == HistoryGroupMode.None) return;

        var grouped = GroupBy switch
        {
            HistoryGroupMode.ByFile => GroupByFile(),
            HistoryGroupMode.ByTimePeriod => GroupByTimePeriod(),
            HistoryGroupMode.ByChangeType => GroupByChangeType(),
            HistoryGroupMode.ByDirectory => GroupByDirectory(),
            _ => Enumerable.Empty<ChangeHistoryGroupViewModel>()
        };

        foreach (var group in grouped)
        {
            GroupedItems.Add(group);
        }
    }

    private IEnumerable<ChangeHistoryGroupViewModel> GroupByFile()
    {
        return Items
            .GroupBy(i => i.Record.FilePath)
            .Select(g => new ChangeHistoryGroupViewModel(
                key: g.Key,
                label: Path.GetFileName(g.Key),
                icon: "FileIcon",
                items: new ObservableCollection<ChangeHistoryItemViewModel>(g)))
            .OrderByDescending(g => g.Items.Max(i => i.Record.ChangedAt));
    }

    private IEnumerable<ChangeHistoryGroupViewModel> GroupByTimePeriod()
    {
        var now = DateTime.UtcNow;
        var today = now.Date;

        var groups = new[]
        {
            ("Today", Items.Where(i => i.Record.ChangedAt.Date == today)),
            ("Yesterday", Items.Where(i => i.Record.ChangedAt.Date == today.AddDays(-1))),
            ("This Week", Items.Where(i =>
                i.Record.ChangedAt.Date < today.AddDays(-1) &&
                i.Record.ChangedAt.Date >= today.AddDays(-(int)today.DayOfWeek))),
            ("Older", Items.Where(i =>
                i.Record.ChangedAt.Date < today.AddDays(-(int)today.DayOfWeek)))
        };

        return groups
            .Where(g => g.Item2.Any())
            .Select(g => new ChangeHistoryGroupViewModel(
                key: g.Item1,
                label: g.Item1,
                icon: "CalendarIcon",
                items: new ObservableCollection<ChangeHistoryItemViewModel>(g.Item2)));
    }

    private IEnumerable<ChangeHistoryGroupViewModel> GroupByChangeType()
    {
        return Items
            .GroupBy(i => i.Record.ChangeType)
            .Select(g => new ChangeHistoryGroupViewModel(
                key: g.Key.ToString(),
                label: GetChangeTypeLabel(g.Key),
                icon: GetChangeTypeIcon(g.Key),
                items: new ObservableCollection<ChangeHistoryItemViewModel>(g)));
    }

    private IEnumerable<ChangeHistoryGroupViewModel> GroupByDirectory()
    {
        return Items
            .GroupBy(i => Path.GetDirectoryName(i.Record.RelativePath) ?? "/")
            .Select(g => new ChangeHistoryGroupViewModel(
                key: g.Key,
                label: string.IsNullOrEmpty(g.Key) ? "Root" : g.Key,
                icon: "FolderIcon",
                items: new ObservableCollection<ChangeHistoryItemViewModel>(g)));
    }

    private static string GetChangeTypeLabel(FileChangeType type) => type switch
    {
        FileChangeType.Created => "Created Files",
        FileChangeType.Modified => "Modified Files",
        FileChangeType.Deleted => "Deleted Files",
        FileChangeType.Renamed => "Renamed Files",
        _ => "Other"
    };

    private static string GetChangeTypeIcon(FileChangeType type) => type switch
    {
        FileChangeType.Created => "PlusCircleIcon",
        FileChangeType.Modified => "EditIcon",
        FileChangeType.Deleted => "TrashIcon",
        FileChangeType.Renamed => "ArrowRightIcon",
        _ => "FileIcon"
    };

    private async Task RefreshStatsAsync()
    {
        var filter = BuildFilter();
        Stats = await _historyService.GetStatsAsync(filter);
    }

    private async void TrimToMaxItems()
    {
        var settings = await _settingsService.GetSettingsAsync();
        while (Items.Count > settings.MaxChangeHistoryItems)
        {
            Items.RemoveAt(Items.Count - 1);
        }
    }

    private void StartUpdateTimer()
    {
        _updateTimer = new System.Timers.Timer(60000); // Update every minute
        _updateTimer.Elapsed += (_, _) =>
        {
            _dispatcher.InvokeAsync(() =>
            {
                foreach (var item in Items)
                {
                    item.OnPropertyChanged(nameof(ChangeHistoryItemViewModel.RelativeTime));
                }
            });
        };
        _updateTimer.Start();
    }

    partial void OnGroupByChanged(HistoryGroupMode value)
    {
        IsGrouped = value != HistoryGroupMode.None;
        RefreshGroupedView();
    }

    partial void OnSearchTextChanged(string value)
    {
        // Debounce search
        _loadCts?.Cancel();
        _ = Task.Delay(300).ContinueWith(_ =>
            _dispatcher.InvokeAsync(async () => await LoadHistoryAsync()));
    }

    public void Dispose()
    {
        _loadCts?.Cancel();
        _loadCts?.Dispose();
        _updateTimer?.Stop();
        _updateTimer?.Dispose();

        _undoManager.ChangeRecorded -= OnChangeRecorded;
        _undoManager.ChangeUndone -= OnChangeUndone;
        _undoManager.TimeRemainingChanged -= OnTimeRemainingChanged;
        _historyService.HistoryCleared -= OnHistoryCleared;
    }
}
```

#### ChangeHistoryItemViewModel

```csharp
// src/SeniorIntern.Desktop/ViewModels/ChangeHistoryItemViewModel.cs
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;

namespace SeniorIntern.Desktop.ViewModels;

/// <summary>
/// ViewModel for an individual change history item.
/// </summary>
public partial class ChangeHistoryItemViewModel : ViewModelBase
{
    private readonly IUndoManager _undoManager;
    private readonly IDiffService _diffService;

    // ═══════════════════════════════════════════════════════════════
    // Properties
    // ═══════════════════════════════════════════════════════════════

    public FileChangeRecord Record { get; }

    [ObservableProperty]
    [NotifyCanExecuteChangedFor(nameof(UndoCommand))]
    private bool _canUndo;

    [ObservableProperty]
    private bool _isUndoing;

    [ObservableProperty]
    private bool _wasUndone;

    [ObservableProperty]
    private bool _isSelected;

    [ObservableProperty]
    private bool _isExpanded;

    [ObservableProperty]
    private DiffResult? _diff;

    [ObservableProperty]
    private bool _isDiffLoading;

    [ObservableProperty]
    private string _timeRemaining = string.Empty;

    [ObservableProperty]
    private double _timeRemainingProgress = 1.0;

    [ObservableProperty]
    private bool _isExpiringSoon;

    // ═══════════════════════════════════════════════════════════════
    // Computed Properties
    // ═══════════════════════════════════════════════════════════════

    public string FileName => Path.GetFileName(Record.FilePath);

    public string RelativePath => Record.RelativePath;

    public string RelativeTime => GetRelativeTime(Record.ChangedAt);

    public string AbsoluteTime => Record.ChangedAt.ToLocalTime().ToString("g");

    public string ChangeTypeLabel => Record.ChangeType switch
    {
        FileChangeType.Created => "Created",
        FileChangeType.Modified => "Modified",
        FileChangeType.Deleted => "Deleted",
        FileChangeType.Renamed => "Renamed",
        _ => "Changed"
    };

    public string ChangeTypeIcon => Record.ChangeType switch
    {
        FileChangeType.Created => "PlusCircleIcon",
        FileChangeType.Modified => "EditIcon",
        FileChangeType.Deleted => "TrashIcon",
        FileChangeType.Renamed => "ArrowRightIcon",
        _ => "FileIcon"
    };

    public string ChangeTypeColor => Record.ChangeType switch
    {
        FileChangeType.Created => "SuccessBrush",
        FileChangeType.Modified => "WarningBrush",
        FileChangeType.Deleted => "ErrorBrush",
        FileChangeType.Renamed => "InfoBrush",
        _ => "ForegroundBrush"
    };

    public string LineStats
    {
        get
        {
            var parts = new List<string>();
            if (Record.LinesAdded > 0) parts.Add($"+{Record.LinesAdded}");
            if (Record.LinesRemoved > 0) parts.Add($"-{Record.LinesRemoved}");
            return parts.Count > 0 ? string.Join(" ", parts) : "No changes";
        }
    }

    public string FileExtension => Path.GetExtension(Record.FilePath);

    // ═══════════════════════════════════════════════════════════════
    // Events
    // ═══════════════════════════════════════════════════════════════

    public event EventHandler<FileChangeRecord>? ViewDiffRequested;
    public event EventHandler<string>? NavigateToFileRequested;

    // ═══════════════════════════════════════════════════════════════
    // Constructor
    // ═══════════════════════════════════════════════════════════════

    public ChangeHistoryItemViewModel(
        FileChangeRecord record,
        IUndoManager undoManager,
        IDiffService diffService)
    {
        Record = record;
        _undoManager = undoManager;
        _diffService = diffService;

        CanUndo = _undoManager.CanUndo(record);
        WasUndone = record.WasUndone;
        UpdateTimeRemaining();
    }

    // ═══════════════════════════════════════════════════════════════
    // Commands
    // ═══════════════════════════════════════════════════════════════

    [RelayCommand(CanExecute = nameof(CanUndo))]
    private async Task UndoAsync()
    {
        if (!CanUndo) return;

        IsUndoing = true;

        try
        {
            var result = await _undoManager.UndoAsync(Record);
            if (result.Success)
            {
                MarkAsUndone();
            }
        }
        finally
        {
            IsUndoing = false;
        }
    }

    [RelayCommand]
    private async Task ViewDiffAsync()
    {
        if (Diff is null)
        {
            await LoadDiffAsync();
        }

        ViewDiffRequested?.Invoke(this, Record);
    }

    [RelayCommand]
    private void OpenFile()
    {
        NavigateToFileRequested?.Invoke(this, Record.FilePath);
    }

    [RelayCommand]
    private async Task CopyPathAsync()
    {
        // TODO: Copy to clipboard
        await Task.CompletedTask;
    }

    [RelayCommand]
    private void ToggleExpand()
    {
        IsExpanded = !IsExpanded;

        if (IsExpanded && Diff is null)
        {
            _ = LoadDiffAsync();
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // Public Methods
    // ═══════════════════════════════════════════════════════════════

    public async Task LoadDiffAsync()
    {
        if (Diff is not null || IsDiffLoading) return;
        if (Record.OriginalContent is null || Record.NewContent is null) return;

        IsDiffLoading = true;

        try
        {
            await Task.Run(() =>
            {
                Diff = _diffService.ComputeDiff(
                    Record.OriginalContent,
                    Record.NewContent,
                    Record.FilePath);
            });
        }
        finally
        {
            IsDiffLoading = false;
        }
    }

    public void MarkAsUndone()
    {
        CanUndo = false;
        WasUndone = true;
        TimeRemaining = "Undone";
        TimeRemainingProgress = 0;
        IsExpiringSoon = false;
        UndoCommand.NotifyCanExecuteChanged();
    }

    public void UpdateTimeRemaining()
    {
        if (WasUndone || Record.ExpiresAt is null)
        {
            TimeRemaining = WasUndone ? "Undone" : "Expired";
            TimeRemainingProgress = 0;
            CanUndo = false;
            return;
        }

        var remaining = Record.ExpiresAt.Value - DateTime.UtcNow;

        if (remaining <= TimeSpan.Zero)
        {
            TimeRemaining = "Expired";
            TimeRemainingProgress = 0;
            CanUndo = false;
            IsExpiringSoon = false;
        }
        else
        {
            TimeRemaining = FormatTimeSpan(remaining);
            TimeRemainingProgress = remaining.TotalSeconds / Record.UndoWindow.TotalSeconds;
            CanUndo = _undoManager.CanUndo(Record);
            IsExpiringSoon = remaining < TimeSpan.FromMinutes(1);
        }

        UndoCommand.NotifyCanExecuteChanged();
    }

    // ═══════════════════════════════════════════════════════════════
    // Private Methods
    // ═══════════════════════════════════════════════════════════════

    private static string GetRelativeTime(DateTime timestamp)
    {
        var elapsed = DateTime.UtcNow - timestamp;

        return elapsed.TotalSeconds switch
        {
            < 60 => "Just now",
            < 120 => "1 minute ago",
            < 3600 => $"{(int)elapsed.TotalMinutes} minutes ago",
            < 7200 => "1 hour ago",
            < 86400 => $"{(int)elapsed.TotalHours} hours ago",
            < 172800 => "Yesterday",
            _ => timestamp.ToLocalTime().ToString("d")
        };
    }

    private static string FormatTimeSpan(TimeSpan timeSpan)
    {
        if (timeSpan.TotalHours >= 1)
        {
            return $"{(int)timeSpan.TotalHours}:{timeSpan.Minutes:D2}:{timeSpan.Seconds:D2}";
        }
        return $"{timeSpan.Minutes}:{timeSpan.Seconds:D2}";
    }
}
```

#### ChangeHistoryGroupViewModel

```csharp
// src/SeniorIntern.Desktop/ViewModels/ChangeHistoryGroupViewModel.cs
using System.Collections.ObjectModel;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;

namespace SeniorIntern.Desktop.ViewModels;

/// <summary>
/// ViewModel for a group of change history items.
/// </summary>
public partial class ChangeHistoryGroupViewModel : ViewModelBase
{
    public string Key { get; }
    public string Label { get; }
    public string Icon { get; }

    [ObservableProperty]
    private ObservableCollection<ChangeHistoryItemViewModel> _items;

    [ObservableProperty]
    private bool _isExpanded = true;

    [ObservableProperty]
    private bool _isAllSelected;

    public int ItemCount => Items.Count;
    public int UndoableCount => Items.Count(i => i.CanUndo);
    public bool HasUndoable => UndoableCount > 0;

    public ChangeHistoryGroupViewModel(
        string key,
        string label,
        string icon,
        ObservableCollection<ChangeHistoryItemViewModel> items)
    {
        Key = key;
        Label = label;
        Icon = icon;
        _items = items;

        // Track selection changes
        foreach (var item in items)
        {
            item.PropertyChanged += (_, e) =>
            {
                if (e.PropertyName == nameof(ChangeHistoryItemViewModel.IsSelected))
                {
                    UpdateIsAllSelected();
                }
            };
        }
    }

    [RelayCommand]
    private void ToggleExpand()
    {
        IsExpanded = !IsExpanded;
    }

    [RelayCommand]
    private void SelectAll()
    {
        foreach (var item in Items)
        {
            item.IsSelected = true;
        }
        IsAllSelected = true;
    }

    [RelayCommand]
    private void DeselectAll()
    {
        foreach (var item in Items)
        {
            item.IsSelected = false;
        }
        IsAllSelected = false;
    }

    [RelayCommand(CanExecute = nameof(HasUndoable))]
    private async Task UndoAllInGroupAsync()
    {
        var undoable = Items.Where(i => i.CanUndo).ToList();

        foreach (var item in undoable)
        {
            await item.UndoCommand.ExecuteAsync(null);
        }
    }

    private void UpdateIsAllSelected()
    {
        IsAllSelected = Items.All(i => i.IsSelected);
    }

    partial void OnIsAllSelectedChanged(bool value)
    {
        if (value)
        {
            SelectAllCommand.Execute(null);
        }
        else if (Items.All(i => i.IsSelected))
        {
            DeselectAllCommand.Execute(null);
        }
    }
}
```

### View Layer

#### ChangeHistoryPanel.axaml

```xml
<!-- src/SeniorIntern.Desktop/Views/ChangeHistoryPanel.axaml -->
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:vm="using:SeniorIntern.Desktop.ViewModels"
             xmlns:views="using:SeniorIntern.Desktop.Views"
             xmlns:converters="using:SeniorIntern.Desktop.Converters"
             x:Class="SeniorIntern.Desktop.Views.ChangeHistoryPanel"
             x:DataType="vm:ChangeHistoryViewModel">

    <UserControl.Resources>
        <converters:BoolToOpacityConverter x:Key="BoolToOpacityConverter" />
        <converters:StringToIconConverter x:Key="StringToIconConverter" />
    </UserControl.Resources>

    <UserControl.Styles>
        <Style Selector="ListBoxItem">
            <Setter Property="Padding" Value="0" />
            <Setter Property="Margin" Value="0" />
        </Style>
    </UserControl.Styles>

    <Border Classes="panel-container">
        <Grid RowDefinitions="Auto,Auto,*,Auto">

            <!-- ═══════════════════════════════════════════════════════════════ -->
            <!-- Header Section -->
            <!-- ═══════════════════════════════════════════════════════════════ -->
            <Border Grid.Row="0"
                    Classes="panel-header"
                    Padding="12,8">
                <Grid RowDefinitions="Auto,Auto" ColumnDefinitions="*,Auto">
                    <!-- Title and Stats -->
                    <StackPanel Grid.Row="0" Grid.Column="0">
                        <TextBlock Text="Change History"
                                   FontWeight="SemiBold"
                                   FontSize="14" />
                        <StackPanel Orientation="Horizontal" Spacing="8">
                            <TextBlock FontSize="11"
                                       Foreground="{DynamicResource TextMuted}">
                                <Run Text="{Binding Stats.TotalChanges}" />
                                <Run Text="changes" />
                            </TextBlock>
                            <TextBlock FontSize="11"
                                       Foreground="{DynamicResource SuccessBrush}"
                                       IsVisible="{Binding HasUndoableChanges}">
                                <Run Text="{Binding Stats.UndoableCount}" />
                                <Run Text="undoable" />
                            </TextBlock>
                        </StackPanel>
                    </StackPanel>

                    <!-- Header Actions -->
                    <StackPanel Grid.Row="0" Grid.Column="1"
                                Orientation="Horizontal"
                                Spacing="4">
                        <Button ToolTip.Tip="Refresh"
                                Command="{Binding RefreshCommand}"
                                Classes="icon-button">
                            <PathIcon Data="{StaticResource RefreshIcon}"
                                      Width="14" Height="14" />
                        </Button>
                        <Button ToolTip.Tip="Toggle filters"
                                Command="{Binding ToggleFiltersCommand}"
                                Classes="icon-button"
                                Classes.active="{Binding ShowFilters}">
                            <PathIcon Data="{StaticResource FilterIcon}"
                                      Width="14" Height="14" />
                        </Button>
                        <Button ToolTip.Tip="Group by"
                                Command="{Binding ToggleGroupingCommand}"
                                Classes="icon-button"
                                Classes.active="{Binding IsGrouped}">
                            <PathIcon Data="{StaticResource GroupIcon}"
                                      Width="14" Height="14" />
                        </Button>
                        <Rectangle Width="1" Height="16"
                                   Fill="{DynamicResource DividerBrush}"
                                   Margin="4,0" />
                        <Button ToolTip.Tip="Undo all"
                                Command="{Binding UndoAllCommand}"
                                IsEnabled="{Binding HasUndoableChanges}"
                                Classes="icon-button">
                            <PathIcon Data="{StaticResource UndoAllIcon}"
                                      Width="14" Height="14" />
                        </Button>
                        <Button ToolTip.Tip="Clear history"
                                Command="{Binding ClearHistoryCommand}"
                                IsEnabled="{Binding HasChanges}"
                                Classes="icon-button danger">
                            <PathIcon Data="{StaticResource TrashIcon}"
                                      Width="14" Height="14" />
                        </Button>
                    </StackPanel>

                    <!-- Search Box -->
                    <TextBox Grid.Row="1" Grid.ColumnSpan="2"
                             Text="{Binding SearchText, Mode=TwoWay}"
                             Watermark="Search files..."
                             Classes="search-box"
                             Margin="0,8,0,0">
                        <TextBox.InnerLeftContent>
                            <PathIcon Data="{StaticResource SearchIcon}"
                                      Width="12" Height="12"
                                      Margin="8,0,0,0"
                                      Foreground="{DynamicResource TextMuted}" />
                        </TextBox.InnerLeftContent>
                    </TextBox>
                </Grid>
            </Border>

            <!-- ═══════════════════════════════════════════════════════════════ -->
            <!-- Filter Panel (Collapsible) -->
            <!-- ═══════════════════════════════════════════════════════════════ -->
            <Border Grid.Row="1"
                    IsVisible="{Binding ShowFilters}"
                    Classes="filter-panel"
                    Padding="12,8"
                    Background="{DynamicResource SurfaceBackground}">
                <StackPanel Spacing="8">
                    <!-- Change Type Filter -->
                    <StackPanel>
                        <TextBlock Text="Change Type"
                                   FontSize="11"
                                   FontWeight="SemiBold"
                                   Margin="0,0,0,4" />
                        <WrapPanel>
                            <CheckBox Content="Created" Margin="0,0,8,0" />
                            <CheckBox Content="Modified" Margin="0,0,8,0" />
                            <CheckBox Content="Deleted" />
                        </WrapPanel>
                    </StackPanel>

                    <!-- Undoable Only Toggle -->
                    <CheckBox Content="Only show undoable changes"
                              IsChecked="{Binding OnlyShowUndoable}" />

                    <!-- Filter Actions -->
                    <StackPanel Orientation="Horizontal"
                                Spacing="8"
                                HorizontalAlignment="Right">
                        <Button Content="Clear"
                                Command="{Binding ClearFilterCommand}"
                                Classes="secondary small" />
                        <Button Content="Apply"
                                Command="{Binding ApplyFilterCommand}"
                                Classes="primary small" />
                    </StackPanel>
                </StackPanel>
            </Border>

            <!-- ═══════════════════════════════════════════════════════════════ -->
            <!-- Content Area -->
            <!-- ═══════════════════════════════════════════════════════════════ -->
            <Grid Grid.Row="2">
                <!-- Loading State -->
                <StackPanel IsVisible="{Binding IsLoading}"
                            HorizontalAlignment="Center"
                            VerticalAlignment="Center">
                    <ProgressRing IsActive="True" Width="24" Height="24" />
                    <TextBlock Text="Loading history..."
                               FontSize="12"
                               Margin="0,8,0,0"
                               Foreground="{DynamicResource TextMuted}" />
                </StackPanel>

                <!-- Empty State -->
                <StackPanel IsVisible="{Binding !HasChanges}"
                            HorizontalAlignment="Center"
                            VerticalAlignment="Center"
                            Opacity="0.6">
                    <PathIcon Data="{StaticResource HistoryIcon}"
                              Width="48" Height="48"
                              Foreground="{DynamicResource TextMuted}" />
                    <TextBlock Text="No changes yet"
                               FontSize="14"
                               FontWeight="SemiBold"
                               Margin="0,12,0,4"
                               HorizontalAlignment="Center" />
                    <TextBlock Text="Applied code changes will appear here"
                               FontSize="12"
                               Foreground="{DynamicResource TextMuted}"
                               HorizontalAlignment="Center" />
                </StackPanel>

                <!-- Error State -->
                <Border IsVisible="{Binding ErrorMessage, Converter={x:Static StringConverters.IsNotNullOrEmpty}}"
                        Classes="error-banner"
                        Margin="12">
                    <StackPanel Orientation="Horizontal" Spacing="8">
                        <PathIcon Data="{StaticResource ErrorIcon}"
                                  Width="16" Height="16"
                                  Foreground="{DynamicResource ErrorBrush}" />
                        <TextBlock Text="{Binding ErrorMessage}"
                                   Foreground="{DynamicResource ErrorBrush}" />
                    </StackPanel>
                </Border>

                <!-- Flat List View -->
                <ListBox ItemsSource="{Binding Items}"
                         SelectedItem="{Binding SelectedItem}"
                         SelectionMode="Multiple"
                         IsVisible="{Binding !IsGrouped}"
                         Classes="history-list"
                         ScrollViewer.HorizontalScrollBarVisibility="Disabled">
                    <ListBox.ItemTemplate>
                        <DataTemplate DataType="vm:ChangeHistoryItemViewModel">
                            <views:ChangeHistoryItem />
                        </DataTemplate>
                    </ListBox.ItemTemplate>
                </ListBox>

                <!-- Grouped Tree View -->
                <TreeView ItemsSource="{Binding GroupedItems}"
                          IsVisible="{Binding IsGrouped}"
                          Classes="history-tree">
                    <TreeView.ItemTemplate>
                        <TreeDataTemplate DataType="vm:ChangeHistoryGroupViewModel"
                                          ItemsSource="{Binding Items}">
                            <views:ChangeHistoryGroup />
                        </TreeDataTemplate>
                    </TreeView.ItemTemplate>
                </TreeView>
            </Grid>

            <!-- ═══════════════════════════════════════════════════════════════ -->
            <!-- Footer Section -->
            <!-- ═══════════════════════════════════════════════════════════════ -->
            <Border Grid.Row="3"
                    Classes="panel-footer"
                    Padding="12,8"
                    IsVisible="{Binding HasChanges}">
                <Grid ColumnDefinitions="*,Auto">
                    <!-- Stats Summary -->
                    <StackPanel Orientation="Horizontal" Spacing="12">
                        <TextBlock FontSize="11"
                                   Foreground="{DynamicResource TextMuted}">
                            <Run Text="{Binding Stats.FilesAffected}" />
                            <Run Text="files" />
                        </TextBlock>
                        <TextBlock FontSize="11"
                                   Foreground="{DynamicResource SuccessBrush}">
                            <Run Text="+" />
                            <Run Text="{Binding Stats.TotalLinesAdded}" />
                        </TextBlock>
                        <TextBlock FontSize="11"
                                   Foreground="{DynamicResource ErrorBrush}">
                            <Run Text="-" />
                            <Run Text="{Binding Stats.TotalLinesRemoved}" />
                        </TextBlock>
                    </StackPanel>

                    <!-- Selection Actions -->
                    <StackPanel Grid.Column="1"
                                Orientation="Horizontal"
                                Spacing="8"
                                IsVisible="{Binding HasSelection}">
                        <TextBlock FontSize="11"
                                   VerticalAlignment="Center"
                                   Foreground="{DynamicResource TextMuted}">
                            <Run Text="{Binding SelectedCount}" />
                            <Run Text="selected" />
                        </TextBlock>
                        <Button Content="Undo Selected"
                                Command="{Binding UndoSelectedCommand}"
                                IsEnabled="{Binding CanUndoSelected}"
                                Classes="primary small" />
                    </StackPanel>
                </Grid>
            </Border>
        </Grid>
    </Border>
</UserControl>
```

#### ChangeHistoryItem.axaml

```xml
<!-- src/SeniorIntern.Desktop/Views/ChangeHistoryItem.axaml -->
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:vm="using:SeniorIntern.Desktop.ViewModels"
             xmlns:converters="using:SeniorIntern.Desktop.Converters"
             x:Class="SeniorIntern.Desktop.Views.ChangeHistoryItem"
             x:DataType="vm:ChangeHistoryItemViewModel">

    <UserControl.Styles>
        <Style Selector="Border.history-item">
            <Setter Property="Padding" Value="8" />
            <Setter Property="Margin" Value="4,2" />
            <Setter Property="CornerRadius" Value="4" />
            <Setter Property="Background" Value="Transparent" />
        </Style>
        <Style Selector="Border.history-item:pointerover">
            <Setter Property="Background" Value="{DynamicResource ListItemHoverBackground}" />
        </Style>
        <Style Selector="Border.history-item.undone">
            <Setter Property="Opacity" Value="0.6" />
        </Style>
        <Style Selector="Border.history-item.expiring-soon">
            <Setter Property="Background" Value="{DynamicResource WarningBackgroundSubtle}" />
        </Style>
    </UserControl.Styles>

    <Border Classes="history-item"
            Classes.undone="{Binding WasUndone}"
            Classes.expiring-soon="{Binding IsExpiringSoon}">
        <Grid ColumnDefinitions="Auto,Auto,*,Auto,Auto,Auto" RowDefinitions="Auto,Auto">

            <!-- Selection Checkbox -->
            <CheckBox Grid.RowSpan="2"
                      IsChecked="{Binding IsSelected}"
                      VerticalAlignment="Center"
                      Margin="0,0,8,0" />

            <!-- Change Type Icon -->
            <Border Grid.Column="1" Grid.RowSpan="2"
                    Width="32" Height="32"
                    CornerRadius="4"
                    Background="{DynamicResource SurfaceBackground}"
                    VerticalAlignment="Center"
                    Margin="0,0,8,0">
                <PathIcon Data="{Binding ChangeTypeIcon, Converter={StaticResource StringToIconConverter}}"
                          Width="16" Height="16"
                          Foreground="{Binding ChangeTypeColor, Converter={StaticResource StringToBrushConverter}}" />
            </Border>

            <!-- File Info -->
            <StackPanel Grid.Column="2" Grid.Row="0"
                        VerticalAlignment="Center">
                <TextBlock Text="{Binding FileName}"
                           FontWeight="Medium"
                           TextTrimming="CharacterEllipsis" />
            </StackPanel>

            <StackPanel Grid.Column="2" Grid.Row="1"
                        Orientation="Horizontal"
                        Spacing="8">
                <TextBlock Text="{Binding RelativePath}"
                           FontSize="11"
                           Foreground="{DynamicResource TextMuted}"
                           TextTrimming="CharacterEllipsis"
                           MaxWidth="150" />
                <TextBlock Text="{Binding RelativeTime}"
                           FontSize="11"
                           Foreground="{DynamicResource TextMuted}" />
                <TextBlock Text="{Binding LineStats}"
                           FontSize="11"
                           Foreground="{DynamicResource TextSecondary}" />
            </StackPanel>

            <!-- Time Remaining -->
            <StackPanel Grid.Column="3" Grid.RowSpan="2"
                        VerticalAlignment="Center"
                        Margin="8,0"
                        IsVisible="{Binding CanUndo}">
                <TextBlock Text="{Binding TimeRemaining}"
                           FontSize="11"
                           FontFamily="{StaticResource MonospaceFont}"
                           HorizontalAlignment="Center">
                    <TextBlock.Foreground>
                        <MultiBinding Converter="{StaticResource TimeRemainingToBrushConverter}">
                            <Binding Path="TimeRemainingProgress" />
                            <Binding Path="IsExpiringSoon" />
                        </MultiBinding>
                    </TextBlock.Foreground>
                </TextBlock>
                <ProgressBar Value="{Binding TimeRemainingProgress}"
                             Maximum="1"
                             Height="3"
                             Width="50"
                             Classes="time-remaining-bar" />
            </StackPanel>

            <!-- Undone Badge -->
            <Border Grid.Column="3" Grid.RowSpan="2"
                    IsVisible="{Binding WasUndone}"
                    Classes="badge success"
                    VerticalAlignment="Center"
                    Margin="8,0">
                <TextBlock Text="Undone" FontSize="10" />
            </Border>

            <!-- Undo Button -->
            <Button Grid.Column="4" Grid.RowSpan="2"
                    Content="Undo"
                    Command="{Binding UndoCommand}"
                    IsVisible="{Binding CanUndo}"
                    Classes="secondary small"
                    VerticalAlignment="Center"
                    Margin="4,0">
                <Button.IsEnabled>
                    <MultiBinding Converter="{StaticResource AllTrueConverter}">
                        <Binding Path="CanUndo" />
                        <Binding Path="!IsUndoing" />
                    </MultiBinding>
                </Button.IsEnabled>
            </Button>

            <!-- Actions Menu -->
            <Button Grid.Column="5" Grid.RowSpan="2"
                    VerticalAlignment="Center"
                    Classes="icon-button">
                <PathIcon Data="{StaticResource MoreVerticalIcon}"
                          Width="14" Height="14" />
                <Button.Flyout>
                    <MenuFlyout Placement="BottomEdgeAlignedRight">
                        <MenuItem Header="View Diff"
                                  Command="{Binding ViewDiffCommand}">
                            <MenuItem.Icon>
                                <PathIcon Data="{StaticResource DiffIcon}" Width="14" Height="14" />
                            </MenuItem.Icon>
                        </MenuItem>
                        <MenuItem Header="Open File"
                                  Command="{Binding OpenFileCommand}">
                            <MenuItem.Icon>
                                <PathIcon Data="{StaticResource ExternalLinkIcon}" Width="14" Height="14" />
                            </MenuItem.Icon>
                        </MenuItem>
                        <MenuItem Header="Copy Path"
                                  Command="{Binding CopyPathCommand}">
                            <MenuItem.Icon>
                                <PathIcon Data="{StaticResource CopyIcon}" Width="14" Height="14" />
                            </MenuItem.Icon>
                        </MenuItem>
                    </MenuFlyout>
                </Button.Flyout>
            </Button>
        </Grid>
    </Border>
</UserControl>
```

---

## Unit Tests

### ChangeHistoryFilterTests

```csharp
// tests/SeniorIntern.Core.Tests/Models/ChangeHistoryFilterTests.cs
using SeniorIntern.Core.Models;
using Xunit;

namespace SeniorIntern.Core.Tests.Models;

public class ChangeHistoryFilterTests
{
    [Fact]
    public void Default_MatchesAllRecords()
    {
        // Arrange
        var filter = ChangeHistoryFilter.Default;
        var record = CreateTestRecord();

        // Act & Assert
        Assert.True(filter.Matches(record));
    }

    [Fact]
    public void SearchText_MatchesFileName()
    {
        // Arrange
        var filter = new ChangeHistoryFilter { SearchText = "UserService" };
        var matchingRecord = CreateTestRecord("src/UserService.cs");
        var nonMatchingRecord = CreateTestRecord("src/Config.json");

        // Act & Assert
        Assert.True(filter.Matches(matchingRecord));
        Assert.False(filter.Matches(nonMatchingRecord));
    }

    [Fact]
    public void SearchText_IsCaseInsensitive()
    {
        // Arrange
        var filter = new ChangeHistoryFilter { SearchText = "userservice" };
        var record = CreateTestRecord("src/UserService.cs");

        // Act & Assert
        Assert.True(filter.Matches(record));
    }

    [Fact]
    public void FileExtensions_FiltersCorrectly()
    {
        // Arrange
        var filter = new ChangeHistoryFilter
        {
            FileExtensions = new HashSet<string> { ".cs", ".ts" }
        };
        var csRecord = CreateTestRecord("src/File.cs");
        var tsRecord = CreateTestRecord("src/File.ts");
        var jsonRecord = CreateTestRecord("config.json");

        // Act & Assert
        Assert.True(filter.Matches(csRecord));
        Assert.True(filter.Matches(tsRecord));
        Assert.False(filter.Matches(jsonRecord));
    }

    [Fact]
    public void ChangeTypes_FiltersCorrectly()
    {
        // Arrange
        var filter = new ChangeHistoryFilter
        {
            ChangeTypes = new HashSet<FileChangeType> { FileChangeType.Created }
        };
        var createdRecord = CreateTestRecord(changeType: FileChangeType.Created);
        var modifiedRecord = CreateTestRecord(changeType: FileChangeType.Modified);

        // Act & Assert
        Assert.True(filter.Matches(createdRecord));
        Assert.False(filter.Matches(modifiedRecord));
    }

    [Fact]
    public void DateRange_FiltersCorrectly()
    {
        // Arrange
        var now = DateTime.UtcNow;
        var filter = new ChangeHistoryFilter
        {
            DateRange = new DateTimeRange(now.AddHours(-1), now)
        };
        var recentRecord = CreateTestRecord(changedAt: now.AddMinutes(-30));
        var oldRecord = CreateTestRecord(changedAt: now.AddHours(-2));

        // Act & Assert
        Assert.True(filter.Matches(recentRecord));
        Assert.False(filter.Matches(oldRecord));
    }

    [Fact]
    public void UndoableOnly_PresetFilter()
    {
        // Arrange
        var filter = ChangeHistoryFilter.UndoableOnly;

        // Assert
        Assert.True(filter.OnlyUndoable);
    }

    [Fact]
    public void LastHour_PresetFilter()
    {
        // Arrange
        var filter = ChangeHistoryFilter.LastHour;

        // Assert
        Assert.NotNull(filter.DateRange);
        Assert.NotNull(filter.DateRange.Start);
        Assert.True(filter.DateRange.Start.Value > DateTime.UtcNow.AddHours(-1.1));
    }

    private static FileChangeRecord CreateTestRecord(
        string filePath = "src/Test.cs",
        FileChangeType changeType = FileChangeType.Modified,
        DateTime? changedAt = null)
    {
        return new FileChangeRecord
        {
            Id = Guid.NewGuid(),
            FilePath = filePath,
            RelativePath = filePath,
            ChangeType = changeType,
            ChangedAt = changedAt ?? DateTime.UtcNow
        };
    }
}
```

### ChangeHistoryStatsTests

```csharp
// tests/SeniorIntern.Core.Tests/Models/ChangeHistoryStatsTests.cs
using SeniorIntern.Core.Models;
using Xunit;

namespace SeniorIntern.Core.Tests.Models;

public class ChangeHistoryStatsTests
{
    [Fact]
    public void Empty_ReturnsZeroStats()
    {
        // Arrange
        var stats = ChangeHistoryStats.Empty;

        // Assert
        Assert.Equal(0, stats.TotalChanges);
        Assert.Equal(0, stats.UndoableCount);
        Assert.Equal(0, stats.FilesAffected);
    }

    [Fact]
    public void FromRecords_ComputesTotalChanges()
    {
        // Arrange
        var records = new[]
        {
            CreateRecord("file1.cs"),
            CreateRecord("file2.cs"),
            CreateRecord("file3.cs")
        };

        // Act
        var stats = ChangeHistoryStats.FromRecords(records);

        // Assert
        Assert.Equal(3, stats.TotalChanges);
    }

    [Fact]
    public void FromRecords_ComputesFilesAffected()
    {
        // Arrange
        var records = new[]
        {
            CreateRecord("file1.cs"),
            CreateRecord("file1.cs"), // Same file
            CreateRecord("file2.cs")
        };

        // Act
        var stats = ChangeHistoryStats.FromRecords(records);

        // Assert
        Assert.Equal(2, stats.FilesAffected);
    }

    [Fact]
    public void FromRecords_ComputesLineStats()
    {
        // Arrange
        var records = new[]
        {
            CreateRecord(linesAdded: 10, linesRemoved: 5),
            CreateRecord(linesAdded: 20, linesRemoved: 3)
        };

        // Act
        var stats = ChangeHistoryStats.FromRecords(records);

        // Assert
        Assert.Equal(30, stats.TotalLinesAdded);
        Assert.Equal(8, stats.TotalLinesRemoved);
        Assert.Equal(22, stats.NetLineChange);
    }

    [Fact]
    public void FromRecords_ComputesByChangeType()
    {
        // Arrange
        var records = new[]
        {
            CreateRecord(changeType: FileChangeType.Created),
            CreateRecord(changeType: FileChangeType.Created),
            CreateRecord(changeType: FileChangeType.Modified)
        };

        // Act
        var stats = ChangeHistoryStats.FromRecords(records);

        // Assert
        Assert.Equal(2, stats.ByChangeType[FileChangeType.Created]);
        Assert.Equal(1, stats.ByChangeType[FileChangeType.Modified]);
    }

    [Fact]
    public void FromRecords_ComputesByFileExtension()
    {
        // Arrange
        var records = new[]
        {
            CreateRecord("file1.cs"),
            CreateRecord("file2.cs"),
            CreateRecord("file3.ts")
        };

        // Act
        var stats = ChangeHistoryStats.FromRecords(records);

        // Assert
        Assert.Equal(2, stats.ByFileExtension[".cs"]);
        Assert.Equal(1, stats.ByFileExtension[".ts"]);
    }

    [Fact]
    public void FromRecords_ComputesTimeSpan()
    {
        // Arrange
        var now = DateTime.UtcNow;
        var records = new[]
        {
            CreateRecord(changedAt: now.AddHours(-2)),
            CreateRecord(changedAt: now.AddHours(-1)),
            CreateRecord(changedAt: now)
        };

        // Act
        var stats = ChangeHistoryStats.FromRecords(records);

        // Assert
        Assert.NotNull(stats.TimeSpan);
        Assert.True(stats.TimeSpan.Value.TotalHours >= 1.9);
    }

    private static FileChangeRecord CreateRecord(
        string filePath = "test.cs",
        FileChangeType changeType = FileChangeType.Modified,
        int linesAdded = 0,
        int linesRemoved = 0,
        DateTime? changedAt = null)
    {
        return new FileChangeRecord
        {
            Id = Guid.NewGuid(),
            FilePath = filePath,
            RelativePath = filePath,
            ChangeType = changeType,
            LinesAdded = linesAdded,
            LinesRemoved = linesRemoved,
            ChangedAt = changedAt ?? DateTime.UtcNow
        };
    }
}
```

### ChangeHistoryViewModelTests

```csharp
// tests/SeniorIntern.Desktop.Tests/ViewModels/ChangeHistoryViewModelTests.cs
using Moq;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Desktop.ViewModels;
using Xunit;

namespace SeniorIntern.Desktop.Tests.ViewModels;

public class ChangeHistoryViewModelTests
{
    private readonly Mock<IChangeHistoryService> _historyServiceMock;
    private readonly Mock<IUndoManager> _undoManagerMock;
    private readonly Mock<IDiffService> _diffServiceMock;
    private readonly Mock<ISettingsService> _settingsServiceMock;
    private readonly Mock<IDispatcher> _dispatcherMock;
    private readonly ChangeHistoryViewModel _viewModel;

    public ChangeHistoryViewModelTests()
    {
        _historyServiceMock = new Mock<IChangeHistoryService>();
        _undoManagerMock = new Mock<IUndoManager>();
        _diffServiceMock = new Mock<IDiffService>();
        _settingsServiceMock = new Mock<ISettingsService>();
        _dispatcherMock = new Mock<IDispatcher>();

        _dispatcherMock
            .Setup(d => d.InvokeAsync(It.IsAny<Action>()))
            .Callback<Action>(a => a());

        _viewModel = new ChangeHistoryViewModel(
            _historyServiceMock.Object,
            _undoManagerMock.Object,
            _diffServiceMock.Object,
            _settingsServiceMock.Object,
            _dispatcherMock.Object);
    }

    [Fact]
    public async Task LoadHistoryAsync_PopulatesItems()
    {
        // Arrange
        var records = new List<FileChangeRecord>
        {
            CreateRecord("file1.cs"),
            CreateRecord("file2.cs")
        };

        _historyServiceMock
            .Setup(s => s.GetHistoryAsync(It.IsAny<ChangeHistoryFilter>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(records);

        _historyServiceMock
            .Setup(s => s.GetStatsAsync(It.IsAny<ChangeHistoryFilter>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(ChangeHistoryStats.FromRecords(records));

        // Act
        await _viewModel.LoadHistoryCommand.ExecuteAsync(null);

        // Assert
        Assert.Equal(2, _viewModel.Items.Count);
    }

    [Fact]
    public async Task LoadHistoryAsync_UpdatesStats()
    {
        // Arrange
        var records = new List<FileChangeRecord>
        {
            CreateRecord("file1.cs", linesAdded: 10),
            CreateRecord("file2.cs", linesAdded: 20)
        };

        _historyServiceMock
            .Setup(s => s.GetHistoryAsync(It.IsAny<ChangeHistoryFilter>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(records);

        _historyServiceMock
            .Setup(s => s.GetStatsAsync(It.IsAny<ChangeHistoryFilter>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(ChangeHistoryStats.FromRecords(records));

        // Act
        await _viewModel.LoadHistoryCommand.ExecuteAsync(null);

        // Assert
        Assert.Equal(2, _viewModel.Stats.TotalChanges);
        Assert.Equal(30, _viewModel.Stats.TotalLinesAdded);
    }

    [Fact]
    public void HasChanges_ReflectsStats()
    {
        // Arrange - empty
        Assert.False(_viewModel.HasChanges);

        // Act - simulate stats update
        _viewModel.Stats = new ChangeHistoryStats { TotalChanges = 5 };

        // Assert
        Assert.True(_viewModel.HasChanges);
    }

    [Fact]
    public void ToggleGroupingCommand_CyclesThroughModes()
    {
        // Initial state
        Assert.Equal(HistoryGroupMode.None, _viewModel.GroupBy);
        Assert.False(_viewModel.IsGrouped);

        // First toggle
        _viewModel.ToggleGroupingCommand.Execute(null);
        Assert.Equal(HistoryGroupMode.ByFile, _viewModel.GroupBy);
        Assert.True(_viewModel.IsGrouped);

        // Second toggle
        _viewModel.ToggleGroupingCommand.Execute(null);
        Assert.Equal(HistoryGroupMode.ByTimePeriod, _viewModel.GroupBy);

        // Third toggle
        _viewModel.ToggleGroupingCommand.Execute(null);
        Assert.Equal(HistoryGroupMode.ByChangeType, _viewModel.GroupBy);

        // Fourth toggle - back to none
        _viewModel.ToggleGroupingCommand.Execute(null);
        Assert.Equal(HistoryGroupMode.None, _viewModel.GroupBy);
        Assert.False(_viewModel.IsGrouped);
    }

    [Fact]
    public void ToggleFiltersCommand_TogglesShowFilters()
    {
        // Initial state
        Assert.False(_viewModel.ShowFilters);

        // Toggle on
        _viewModel.ToggleFiltersCommand.Execute(null);
        Assert.True(_viewModel.ShowFilters);

        // Toggle off
        _viewModel.ToggleFiltersCommand.Execute(null);
        Assert.False(_viewModel.ShowFilters);
    }

    [Fact]
    public void SelectAllCommand_SelectsAllItems()
    {
        // Arrange
        _viewModel.Items.Add(CreateItemViewModel("file1.cs"));
        _viewModel.Items.Add(CreateItemViewModel("file2.cs"));

        // Act
        _viewModel.SelectAllCommand.Execute(null);

        // Assert
        Assert.All(_viewModel.Items, item => Assert.True(item.IsSelected));
        Assert.Equal(2, _viewModel.SelectedItems.Count);
    }

    [Fact]
    public void ClearSelectionCommand_DeselectsAllItems()
    {
        // Arrange
        _viewModel.Items.Add(CreateItemViewModel("file1.cs"));
        _viewModel.Items.Add(CreateItemViewModel("file2.cs"));
        _viewModel.SelectAllCommand.Execute(null);

        // Act
        _viewModel.ClearSelectionCommand.Execute(null);

        // Assert
        Assert.All(_viewModel.Items, item => Assert.False(item.IsSelected));
        Assert.Empty(_viewModel.SelectedItems);
    }

    private static FileChangeRecord CreateRecord(
        string filePath = "test.cs",
        int linesAdded = 0,
        int linesRemoved = 0)
    {
        return new FileChangeRecord
        {
            Id = Guid.NewGuid(),
            FilePath = filePath,
            RelativePath = filePath,
            ChangeType = FileChangeType.Modified,
            LinesAdded = linesAdded,
            LinesRemoved = linesRemoved,
            ChangedAt = DateTime.UtcNow
        };
    }

    private ChangeHistoryItemViewModel CreateItemViewModel(string filePath)
    {
        var record = CreateRecord(filePath);
        return new ChangeHistoryItemViewModel(
            record,
            _undoManagerMock.Object,
            _diffServiceMock.Object);
    }
}
```

---

## Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Models/ChangeHistoryFilter.cs` | Filter criteria record |
| `src/SeniorIntern.Core/Models/ChangeHistoryStats.cs` | Aggregated statistics record |
| `src/SeniorIntern.Core/Models/HistoryGroupMode.cs` | Grouping mode enum |
| `src/SeniorIntern.Core/Interfaces/IChangeHistoryService.cs` | Service interface |
| `src/SeniorIntern.Services/ChangeHistoryService.cs` | Service implementation |
| `src/SeniorIntern.Desktop/ViewModels/ChangeHistoryViewModel.cs` | Main panel ViewModel |
| `src/SeniorIntern.Desktop/ViewModels/ChangeHistoryItemViewModel.cs` | Item ViewModel |
| `src/SeniorIntern.Desktop/ViewModels/ChangeHistoryGroupViewModel.cs` | Group ViewModel |
| `src/SeniorIntern.Desktop/Views/ChangeHistoryPanel.axaml` | Main panel view |
| `src/SeniorIntern.Desktop/Views/ChangeHistoryPanel.axaml.cs` | Panel code-behind |
| `src/SeniorIntern.Desktop/Views/ChangeHistoryItem.axaml` | Item view |
| `src/SeniorIntern.Desktop/Views/ChangeHistoryItem.axaml.cs` | Item code-behind |
| `src/SeniorIntern.Desktop/Views/ChangeHistoryGroup.axaml` | Group view |
| `src/SeniorIntern.Desktop/Views/ChangeHistoryGroup.axaml.cs` | Group code-behind |
| `tests/SeniorIntern.Core.Tests/Models/ChangeHistoryFilterTests.cs` | Filter tests |
| `tests/SeniorIntern.Core.Tests/Models/ChangeHistoryStatsTests.cs` | Stats tests |
| `tests/SeniorIntern.Services.Tests/ChangeHistoryServiceTests.cs` | Service tests |
| `tests/SeniorIntern.Desktop.Tests/ViewModels/ChangeHistoryViewModelTests.cs` | ViewModel tests |

## Files to Modify

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/Views/MainWindow.axaml` | Add Change History Panel to side panel |
| `src/SeniorIntern.Desktop/ViewModels/MainWindowViewModel.cs` | Add ChangeHistoryViewModel property |
| `src/SeniorIntern.Desktop/ServiceCollectionExtensions.cs` | Register IChangeHistoryService |
| `src/SeniorIntern.Desktop/App.axaml` | Add history panel styles and icons |

---

## Acceptance Criteria

### Functional Requirements

- [ ] Panel displays all recent file changes from code generation
- [ ] Changes show file name, relative path, type, and timestamp
- [ ] Undoable changes show countdown timer with progress bar
- [ ] Undo button reverts individual changes
- [ ] "Undo All" reverts all undoable changes
- [ ] Search filters changes by file name/path
- [ ] Filter panel filters by change type, date, and undoable status
- [ ] Grouping toggles between flat, by-file, by-time, and by-type views
- [ ] Multi-select allows batch undo operations
- [ ] Export generates JSON, CSV, Markdown, or unified diff
- [ ] Real-time updates when new changes are recorded
- [ ] Countdown timers update every second

### Visual Requirements

- [ ] Change type icons differentiate Created/Modified/Deleted
- [ ] Undone changes appear dimmed
- [ ] Expiring-soon changes (<1 min) show warning state
- [ ] Progress bar visualizes time remaining
- [ ] Empty state shows helpful message
- [ ] Loading state shows spinner
- [ ] Stats summary in header and footer

### Performance Requirements

- [ ] Virtualized list handles 1000+ changes smoothly
- [ ] Debounced search (300ms delay)
- [ ] Efficient grouping without blocking UI
- [ ] Timer updates don't cause excessive re-renders

---

## Design Decisions

### Why a Dedicated History Service?

**Decision**: Create IChangeHistoryService separate from IUndoManager.

**Rationale**:
1. **Single Responsibility**: UndoManager focuses on undo operations; HistoryService focuses on queries
2. **Query Flexibility**: Complex filtering, sorting, and grouping logic isolated
3. **Export Feature**: Export functionality doesn't belong in UndoManager
4. **Caching**: History service can cache aggregated data

### Why Live Countdown Timers?

**Decision**: Update countdown timers every second for undoable changes.

**Rationale**:
1. **Urgency Awareness**: Users see exactly how much time remains
2. **Visual Feedback**: Progress bar provides instant comprehension
3. **Warning States**: Color changes alert users before expiration
4. **Consistency**: Matches modern undo UI patterns (Google Docs, etc.)

### Why Multiple Grouping Modes?

**Decision**: Support flat, by-file, by-time, and by-type grouping.

**Rationale**:
1. **Different Use Cases**: Users scan by file when fixing bugs, by time when reviewing session
2. **Cognitive Load**: Grouping reduces visual overwhelm with many changes
3. **Discovery**: Time-based groups help users find "that thing I did earlier"

---

## Future Considerations

1. **Diff Preview Expansion**: Inline diff preview within each item
2. **Batch Operations**: Select multiple items for batch undo/export
3. **Session Grouping**: Group by conversation/session ID
4. **Conflict Resolution**: UI for handling undo conflicts
5. **Persistence**: Save history across app restarts
6. **Analytics**: Track undo usage patterns
7. **Notifications**: Alert when changes are about to expire
8. **Keyboard Navigation**: Full keyboard support for accessibility

---

## Dependencies

### Internal Dependencies

| Dependency | Version | Purpose |
|------------|---------|---------|
| v0.4.3a (Core Models) | Required | FileChangeRecord, FileChangeType |
| v0.4.3d (Undo System) | Required | IUndoManager, undo operations |
| v0.4.2 (Diff Engine) | Required | IDiffService for diff display |
| v0.4.5a (Settings Models) | Required | MaxChangeHistoryItems setting |

### External Dependencies

| Package | Purpose |
|---------|---------|
| CommunityToolkit.Mvvm | ObservableProperty, RelayCommand |
| Avalonia.Controls | TreeView, ListBox, UI controls |
| System.Text.Json | JSON export |
