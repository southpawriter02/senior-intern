# Design Specification: The Senior Intern v0.4.1f "Streaming Parser"

**Status**: _IMPLEMENTED_

## Executive Summary

This document provides a comprehensive implementation specification for v0.4.1f, which implements an incremental streaming parser for detecting and extracting code blocks during LLM token generation. This enables real-time UI updates showing code blocks as they are being generated, rather than waiting for the complete response.

### v0.4.1f Scope

- Create `IStreamingCodeBlockParser` interface for incremental parsing
- Implement state machine-based parser for token-by-token processing
- Create `PartialCodeBlock` model for in-progress blocks
- Implement streaming events for block start, content, and completion
- Handle edge cases: incomplete fences, nested fences, special characters
- Support `lang:path` fence syntax for explicit file targeting
- Integrate with existing `ILanguageDetectionService` and `IBlockClassificationService`

### Key Deliverables

| Deliverable | Description |
|-------------|-------------|
| IStreamingCodeBlockParser | Interface for incremental code block parsing |
| StreamingCodeBlockParser | State machine implementation for streaming parsing |
| PartialCodeBlock | Model representing an in-progress code block |
| StreamingParserState | Enum for parser state machine states |
| CodeBlockStartedEventArgs | Event data when a code block begins |
| CodeBlockCompletedEventArgs | Event data when a code block finishes |
| CodeBlockContentEventArgs | Event data for incremental content updates |
| TextRange | Model for tracking source positions |

---

## Prerequisites

Before implementing v0.4.1f, ensure:

- v0.4.1a is complete (CodeBlock model)
- v0.4.1c is complete (ILanguageDetectionService)
- v0.4.1d is complete (IBlockClassificationService)
- v0.1.0 is complete (ILlmService with GenerateStreamingAsync)

---

## Feature Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     v0.4.1f Feature Tree                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                        â”‚
â”‚  IStreamingCodeBlockParser                                             â”‚
â”‚  â”œâ”€â”€ State Machine                                                     â”‚
â”‚  â”‚   â”œâ”€â”€ State: Text (outside code blocks)                            â”‚
â”‚  â”‚   â”‚   â””â”€â”€ Watches for "```" fence start sequence                   â”‚
â”‚  â”‚   â”œâ”€â”€ State: FenceOpening (after ``` detected)                     â”‚
â”‚  â”‚   â”‚   â”œâ”€â”€ Accumulates language identifier                          â”‚
â”‚  â”‚   â”‚   â”œâ”€â”€ Parses optional :path suffix                             â”‚
â”‚  â”‚   â”‚   â””â”€â”€ Transitions on newline                                   â”‚
â”‚  â”‚   â”œâ”€â”€ State: CodeContent (inside code block)                       â”‚
â”‚  â”‚   â”‚   â”œâ”€â”€ Accumulates code content                                 â”‚
â”‚  â”‚   â”‚   â”œâ”€â”€ Raises ContentAdded events                               â”‚
â”‚  â”‚   â”‚   â””â”€â”€ Watches for closing "```" fence                          â”‚
â”‚  â”‚   â””â”€â”€ State: FenceClosing (potential end)                          â”‚
â”‚  â”‚       â”œâ”€â”€ Confirms fence end on newline/EOF                        â”‚
â”‚  â”‚       â””â”€â”€ May resume CodeContent if false positive                 â”‚
â”‚  â”‚                                                                     â”‚
â”‚  â”œâ”€â”€ Primary Methods                                                   â”‚
â”‚  â”‚   â”œâ”€â”€ FeedToken(token) â†’ void                                      â”‚
â”‚  â”‚   â”‚   â”œâ”€â”€ Process each character                                   â”‚
â”‚  â”‚   â”‚   â”œâ”€â”€ Update state machine                                     â”‚
â”‚  â”‚   â”‚   â””â”€â”€ Raise events as needed                                   â”‚
â”‚  â”‚   â”‚                                                                 â”‚
â”‚  â”‚   â”œâ”€â”€ GetCompletedBlocks() â†’ IReadOnlyList<CodeBlock>             â”‚
â”‚  â”‚   â”œâ”€â”€ GetCurrentBlock() â†’ PartialCodeBlock?                       â”‚
â”‚  â”‚   â”œâ”€â”€ Complete() â†’ void (finalize any open block)                 â”‚
â”‚  â”‚   â””â”€â”€ Reset(messageId) â†’ void (prepare for new message)           â”‚
â”‚  â”‚                                                                     â”‚
â”‚  â”œâ”€â”€ Events                                                            â”‚
â”‚  â”‚   â”œâ”€â”€ BlockStarted â†’ CodeBlockStartedEventArgs                     â”‚
â”‚  â”‚   â”‚   â””â”€â”€ Fires when opening fence + language parsed               â”‚
â”‚  â”‚   â”œâ”€â”€ ContentAdded â†’ CodeBlockContentEventArgs                     â”‚
â”‚  â”‚   â”‚   â””â”€â”€ Fires for each token/character in code                   â”‚
â”‚  â”‚   â””â”€â”€ BlockCompleted â†’ CodeBlockCompletedEventArgs                 â”‚
â”‚  â”‚       â””â”€â”€ Fires when closing fence detected                        â”‚
â”‚  â”‚                                                                     â”‚
â”‚  â””â”€â”€ Properties                                                        â”‚
â”‚      â”œâ”€â”€ State â†’ StreamingParserState                                 â”‚
â”‚      â”œâ”€â”€ TotalBytesProcessed â†’ int                                    â”‚
â”‚      â””â”€â”€ ActiveBlockCount â†’ int                                       â”‚
â”‚                                                                        â”‚
â”‚  PartialCodeBlock                                                      â”‚
â”‚  â”œâ”€â”€ Id â†’ Guid                                                        â”‚
â”‚  â”œâ”€â”€ MessageId â†’ Guid                                                 â”‚
â”‚  â”œâ”€â”€ SequenceNumber â†’ int                                             â”‚
â”‚  â”œâ”€â”€ Language â†’ string?                                               â”‚
â”‚  â”œâ”€â”€ TargetFilePath â†’ string?                                         â”‚
â”‚  â”œâ”€â”€ Content â†’ StringBuilder                                          â”‚
â”‚  â”œâ”€â”€ StartPosition â†’ int                                              â”‚
â”‚  â”œâ”€â”€ StartedAt â†’ DateTime                                             â”‚
â”‚  â””â”€â”€ ToCodeBlock(endPosition) â†’ CodeBlock                             â”‚
â”‚                                                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Architecture Diagrams

### State Machine Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Streaming Parser State Machine                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                          â”‚
â”‚                            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                   â”‚
â”‚                            â”‚  START  â”‚                                   â”‚
â”‚                            â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                                   â”‚
â”‚                                 â”‚                                        â”‚
â”‚                                 â–¼                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                          TEXT STATE                                â”‚  â”‚
â”‚  â”‚  â€¢ Initial state                                                   â”‚  â”‚
â”‚  â”‚  â€¢ Accumulates non-code text                                       â”‚  â”‚
â”‚  â”‚  â€¢ Watches buffer for "```" sequence                              â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                â”‚                                    â–²                    â”‚
â”‚                â”‚ "```" detected                     â”‚ Block completed    â”‚
â”‚                â–¼                                    â”‚                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                      FENCE_OPENING STATE                           â”‚  â”‚
â”‚  â”‚  â€¢ Triggered when "```" is detected                               â”‚  â”‚
â”‚  â”‚  â€¢ Creates new PartialCodeBlock                                    â”‚  â”‚
â”‚  â”‚  â€¢ Accumulates language identifier (e.g., "csharp")               â”‚  â”‚
â”‚  â”‚  â€¢ Parses optional ":path" suffix                                 â”‚  â”‚
â”‚  â”‚  â€¢ Example: "```csharp:src/Models/User.cs"                        â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                â”‚                                                         â”‚
â”‚                â”‚ '\n' (newline) detected                                â”‚
â”‚                â”‚ â†’ Raises BlockStarted event                            â”‚
â”‚                â–¼                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                      CODE_CONTENT STATE                            â”‚  â”‚
â”‚  â”‚  â€¢ Inside code block                                               â”‚  â”‚
â”‚  â”‚  â€¢ Accumulates code content to PartialCodeBlock.Content           â”‚  â”‚
â”‚  â”‚  â€¢ Raises ContentAdded event for each token                       â”‚  â”‚
â”‚  â”‚  â€¢ Monitors for potential closing fence                           â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                â”‚                                                         â”‚
â”‚                â”‚ "```" detected at start of line                        â”‚
â”‚                â–¼                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                      FENCE_CLOSING STATE                           â”‚  â”‚
â”‚  â”‚  â€¢ Potential end of code block                                     â”‚  â”‚
â”‚  â”‚  â€¢ Confirms on newline or EOF                                      â”‚  â”‚
â”‚  â”‚  â€¢ Converts PartialCodeBlock to CodeBlock                          â”‚  â”‚
â”‚  â”‚  â€¢ Classifies block type                                          â”‚  â”‚
â”‚  â”‚  â€¢ Raises BlockCompleted event                                     â”‚  â”‚
â”‚  â”‚  â€¢ Returns to TEXT state                                           â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Token Processing Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       Token Processing Flow                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                          â”‚
â”‚  LLM Token Stream                                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ "Here's" â†’ "the" â†’ "code" â†’ ":\n" â†’ "```" â†’ "csharp" â†’ "\n" â†’   â”‚    â”‚
â”‚  â”‚ "public" â†’ " class" â†’ " User" â†’ " {" â†’ " }" â†’ "\n" â†’ "```"      â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚       â”‚                                                                  â”‚
â”‚       â–¼                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ FeedToken("Here's")                                              â”‚    â”‚
â”‚  â”‚  â””â”€â”€ State: Text                                                 â”‚    â”‚
â”‚  â”‚      â””â”€â”€ Buffer: "Here's" (no fence detected)                    â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚       â”‚                                                                  â”‚
â”‚       â–¼                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ FeedToken("```")                                                 â”‚    â”‚
â”‚  â”‚  â””â”€â”€ State: Text â†’ FenceOpening                                  â”‚    â”‚
â”‚  â”‚      â””â”€â”€ Create PartialCodeBlock { SequenceNumber: 0 }           â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚       â”‚                                                                  â”‚
â”‚       â–¼                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ FeedToken("csharp")                                              â”‚    â”‚
â”‚  â”‚  â””â”€â”€ State: FenceOpening                                         â”‚    â”‚
â”‚  â”‚      â””â”€â”€ PartialCodeBlock.Language = "csharp"                    â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚       â”‚                                                                  â”‚
â”‚       â–¼                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ FeedToken("\n")                                                  â”‚    â”‚
â”‚  â”‚  â””â”€â”€ State: FenceOpening â†’ CodeContent                           â”‚    â”‚
â”‚  â”‚      â””â”€â”€ ğŸ‰ Raise BlockStarted event                             â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚       â”‚                                                                  â”‚
â”‚       â–¼                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ FeedToken("public class User { }")                               â”‚    â”‚
â”‚  â”‚  â””â”€â”€ State: CodeContent                                          â”‚    â”‚
â”‚  â”‚      â””â”€â”€ PartialCodeBlock.Content += "public class User { }"     â”‚    â”‚
â”‚  â”‚      â””â”€â”€ ğŸ‰ Raise ContentAdded events                            â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚       â”‚                                                                  â”‚
â”‚       â–¼                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ FeedToken("\n```")                                               â”‚    â”‚
â”‚  â”‚  â””â”€â”€ State: CodeContent â†’ FenceClosing â†’ Text                    â”‚    â”‚
â”‚  â”‚      â””â”€â”€ Classify block type                                     â”‚    â”‚
â”‚  â”‚      â””â”€â”€ Create CodeBlock from PartialCodeBlock                  â”‚    â”‚
â”‚  â”‚      â””â”€â”€ ğŸ‰ Raise BlockCompleted event                           â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Integration with LLM Streaming

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Integration with LLM Streaming                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                          â”‚
â”‚  ChatViewModel                                                           â”‚
â”‚       â”‚                                                                  â”‚
â”‚       â”‚ User sends message                                               â”‚
â”‚       â–¼                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ 1. Create streaming parser instance                              â”‚   â”‚
â”‚  â”‚    var parser = _parserFactory.Create();                         â”‚   â”‚
â”‚  â”‚    parser.Reset(messageId);                                      â”‚   â”‚
â”‚  â”‚                                                                   â”‚   â”‚
â”‚  â”‚ 2. Subscribe to parser events                                    â”‚   â”‚
â”‚  â”‚    parser.BlockStarted += OnBlockStarted;                        â”‚   â”‚
â”‚  â”‚    parser.ContentAdded += OnContentAdded;                        â”‚   â”‚
â”‚  â”‚    parser.BlockCompleted += OnBlockCompleted;                    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚       â”‚                                                                  â”‚
â”‚       â–¼                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ 3. Stream tokens from LLM                                        â”‚   â”‚
â”‚  â”‚    await foreach (var token in llmService.GenerateStreamingAsync â”‚   â”‚
â”‚  â”‚                    (conversation, options, ct))                  â”‚   â”‚
â”‚  â”‚    {                                                              â”‚   â”‚
â”‚  â”‚        // Update message content                                  â”‚   â”‚
â”‚  â”‚        messageVm.Content += token;                               â”‚   â”‚
â”‚  â”‚                                                                   â”‚   â”‚
â”‚  â”‚        // Feed to parser                                          â”‚   â”‚
â”‚  â”‚        parser.FeedToken(token);                                  â”‚   â”‚
â”‚  â”‚    }                                                              â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚       â”‚                                                                  â”‚
â”‚       â–¼                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ 4. Finalize parsing                                              â”‚   â”‚
â”‚  â”‚    parser.Complete();                                            â”‚   â”‚
â”‚  â”‚                                                                   â”‚   â”‚
â”‚  â”‚ 5. Get all code blocks                                           â”‚   â”‚
â”‚  â”‚    var blocks = parser.GetCompletedBlocks();                     â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                          â”‚
â”‚  Event Handlers (on UI thread via Dispatcher)                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ OnBlockStarted:                                                  â”‚   â”‚
â”‚  â”‚   â€¢ Create new CodeBlockViewModel with IsStreaming = true        â”‚   â”‚
â”‚  â”‚   â€¢ Add to message's CodeBlocks collection                       â”‚   â”‚
â”‚  â”‚   â€¢ UI shows empty code block with language badge                â”‚   â”‚
â”‚  â”‚                                                                   â”‚   â”‚
â”‚  â”‚ OnContentAdded:                                                  â”‚   â”‚
â”‚  â”‚   â€¢ Append content to CodeBlockViewModel.Content                 â”‚   â”‚
â”‚  â”‚   â€¢ UI updates code preview in real-time                         â”‚   â”‚
â”‚  â”‚                                                                   â”‚   â”‚
â”‚  â”‚ OnBlockCompleted:                                                â”‚   â”‚
â”‚  â”‚   â€¢ Update CodeBlockViewModel with final data                    â”‚   â”‚
â”‚  â”‚   â€¢ Set IsStreaming = false                                      â”‚   â”‚
â”‚  â”‚   â€¢ UI shows Apply/Copy buttons                                  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Fence Syntax Variations

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Supported Fence Syntax Variations                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                          â”‚
â”‚  Basic Syntax                                                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ ```                          â”‚ No language specified             â”‚   â”‚
â”‚  â”‚ code here                    â”‚ BlockType determined by content   â”‚   â”‚
â”‚  â”‚ ```                          â”‚                                    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                          â”‚
â”‚  Language Only                                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ ```csharp                    â”‚ Language: "csharp"                â”‚   â”‚
â”‚  â”‚ public class User { }        â”‚ Path: inferred from content       â”‚   â”‚
â”‚  â”‚ ```                          â”‚                                    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                          â”‚
â”‚  Language + Path (Colon Syntax)                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ ```csharp:src/Models/User.cs â”‚ Language: "csharp"                â”‚   â”‚
â”‚  â”‚ public class User { }        â”‚ Path: "src/Models/User.cs"        â”‚   â”‚
â”‚  â”‚ ```                          â”‚                                    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                          â”‚
â”‚  Path with Spaces (Quoted)                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ ```csharp:"src/My Models/User.cs"                                â”‚   â”‚
â”‚  â”‚ public class User { }        â”‚ Path: "src/My Models/User.cs"     â”‚   â”‚
â”‚  â”‚ ```                          â”‚                                    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                          â”‚
â”‚  Language Aliases                                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ ```cs                        â”‚ Normalized to "csharp"            â”‚   â”‚
â”‚  â”‚ ```c#                        â”‚ Normalized to "csharp"            â”‚   â”‚
â”‚  â”‚ ```ts                        â”‚ Normalized to "typescript"        â”‚   â”‚
â”‚  â”‚ ```js                        â”‚ Normalized to "javascript"        â”‚   â”‚
â”‚  â”‚ ```py                        â”‚ Normalized to "python"            â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                          â”‚
â”‚  Tilde Fences (Alternative)                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ ~~~csharp                    â”‚ Equivalent to backtick fences     â”‚   â”‚
â”‚  â”‚ public class User { }        â”‚ Same parsing rules apply          â”‚   â”‚
â”‚  â”‚ ~~~                          â”‚                                    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                          â”‚
â”‚  Extended Fences (4+ backticks for nesting)                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ ````markdown                 â”‚ Outer fence: 4 backticks          â”‚   â”‚
â”‚  â”‚ Here's an example:           â”‚ Can contain 3-backtick fences     â”‚   â”‚
â”‚  â”‚ ```csharp                    â”‚ Inner fence is content            â”‚   â”‚
â”‚  â”‚ code                         â”‚                                    â”‚   â”‚
â”‚  â”‚ ```                          â”‚                                    â”‚   â”‚
â”‚  â”‚ ````                         â”‚ Close with matching 4 backticks   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Directory Structure

After v0.4.1f implementation:

```
src/SeniorIntern.Core/
â”œâ”€â”€ Interfaces/
â”‚   â””â”€â”€ IStreamingCodeBlockParser.cs                 (NEW)
â”œâ”€â”€ Models/
â”‚   â”œâ”€â”€ PartialCodeBlock.cs                          (NEW)
â”‚   â”œâ”€â”€ TextRange.cs                                 (NEW)
â”‚   â””â”€â”€ StreamingParserState.cs                      (NEW)
â””â”€â”€ Events/
    â””â”€â”€ CodeBlockEvents.cs                           (NEW - streaming events)

src/SeniorIntern.Services/
â”œâ”€â”€ StreamingCodeBlockParser.cs                      (NEW)
â””â”€â”€ Factories/
    â””â”€â”€ StreamingParserFactory.cs                    (NEW)

tests/SeniorIntern.Services.Tests/
â””â”€â”€ StreamingCodeBlockParserTests.cs                 (NEW)
```

---

## Implementation Details

### Task 1: Create TextRange Model

**File:** `src/SeniorIntern.Core/Models/TextRange.cs`

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Represents a range of positions in text content.
/// </summary>
public readonly record struct TextRange
{
    /// <summary>
    /// Start position (inclusive, 0-based character index).
    /// </summary>
    public int Start { get; init; }

    /// <summary>
    /// End position (exclusive, 0-based character index).
    /// </summary>
    public int End { get; init; }

    /// <summary>
    /// Length of the range in characters.
    /// </summary>
    public int Length => End - Start;

    /// <summary>
    /// Whether the range is empty (zero length).
    /// </summary>
    public bool IsEmpty => Length <= 0;

    /// <summary>
    /// Creates a new text range.
    /// </summary>
    public TextRange(int start, int end)
    {
        if (start < 0)
            throw new ArgumentOutOfRangeException(nameof(start), "Start must be non-negative");
        if (end < start)
            throw new ArgumentOutOfRangeException(nameof(end), "End must be >= start");

        Start = start;
        End = end;
    }

    /// <summary>
    /// Creates a range from start position with specified length.
    /// </summary>
    public static TextRange FromLength(int start, int length) =>
        new(start, start + length);

    /// <summary>
    /// Creates an empty range at the specified position.
    /// </summary>
    public static TextRange Empty(int position) =>
        new(position, position);

    /// <summary>
    /// Check if this range contains the specified position.
    /// </summary>
    public bool Contains(int position) =>
        position >= Start && position < End;

    /// <summary>
    /// Check if this range overlaps with another range.
    /// </summary>
    public bool Overlaps(TextRange other) =>
        Start < other.End && End > other.Start;

    /// <summary>
    /// Extract substring from source text using this range.
    /// </summary>
    public string Extract(string source)
    {
        if (string.IsNullOrEmpty(source))
            return string.Empty;
        if (Start >= source.Length)
            return string.Empty;

        var actualEnd = Math.Min(End, source.Length);
        return source[Start..actualEnd];
    }

    public override string ToString() => $"[{Start}..{End}]";
}
```

---

### Task 2: Create StreamingParserState Enum

**File:** `src/SeniorIntern.Core/Models/StreamingParserState.cs`

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Represents the current state of the streaming code block parser.
/// </summary>
public enum StreamingParserState
{
    /// <summary>
    /// Parser is outside any code block, processing regular text.
    /// Watching for fence start sequence (``` or ~~~).
    /// </summary>
    Text,

    /// <summary>
    /// Parser detected fence start, now reading language/path info.
    /// Waiting for newline to complete the opening fence line.
    /// </summary>
    FenceOpening,

    /// <summary>
    /// Parser is inside code block content.
    /// Accumulating code and watching for closing fence.
    /// </summary>
    CodeContent,

    /// <summary>
    /// Parser detected potential closing fence.
    /// Confirming end of block on newline or EOF.
    /// </summary>
    FenceClosing
}

/// <summary>
/// Type of fence delimiter used for code blocks.
/// </summary>
public enum FenceType
{
    /// <summary>
    /// Backtick fence (```).
    /// </summary>
    Backtick,

    /// <summary>
    /// Tilde fence (~~~).
    /// </summary>
    Tilde
}
```

---

### Task 3: Create PartialCodeBlock Model

**File:** `src/SeniorIntern.Core/Models/PartialCodeBlock.cs`

```csharp
namespace SeniorIntern.Core.Models;

using System.Text;

/// <summary>
/// Represents a code block that is currently being parsed during streaming.
/// </summary>
public sealed class PartialCodeBlock
{
    /// <summary>
    /// Unique identifier for this code block.
    /// </summary>
    public Guid Id { get; init; } = Guid.NewGuid();

    /// <summary>
    /// ID of the message containing this code block.
    /// </summary>
    public Guid MessageId { get; init; }

    /// <summary>
    /// Zero-based sequence number within the message.
    /// First code block is 0, second is 1, etc.
    /// </summary>
    public int SequenceNumber { get; init; }

    /// <summary>
    /// Detected or specified programming language.
    /// </summary>
    public string? Language { get; set; }

    /// <summary>
    /// Display name for the language (e.g., "C#" for "csharp").
    /// </summary>
    public string? DisplayLanguage { get; set; }

    /// <summary>
    /// Target file path if specified in fence line.
    /// </summary>
    public string? TargetFilePath { get; set; }

    /// <summary>
    /// Accumulated code content.
    /// </summary>
    public StringBuilder Content { get; } = new();

    /// <summary>
    /// Character position where the code block starts (at the opening fence).
    /// </summary>
    public int StartPosition { get; init; }

    /// <summary>
    /// Timestamp when parsing started for this block.
    /// </summary>
    public DateTime StartedAt { get; init; } = DateTime.UtcNow;

    /// <summary>
    /// Type of fence delimiter (backtick or tilde).
    /// </summary>
    public FenceType FenceType { get; init; } = FenceType.Backtick;

    /// <summary>
    /// Number of fence characters (3 for ```, 4 for ````, etc.).
    /// </summary>
    public int FenceLength { get; init; } = 3;

    /// <summary>
    /// Current line count in the content.
    /// </summary>
    public int LineCount => Content.ToString().Split('\n').Length;

    /// <summary>
    /// Raw fence line content (language + optional path).
    /// </summary>
    public string? FenceLine { get; set; }

    /// <summary>
    /// Convert this partial block to a completed CodeBlock.
    /// </summary>
    /// <param name="endPosition">Character position at end of block.</param>
    /// <returns>Completed CodeBlock model.</returns>
    public CodeBlock ToCodeBlock(int endPosition)
    {
        var content = Content.ToString();

        // Trim trailing newline if present (before closing fence)
        if (content.EndsWith('\n'))
            content = content[..^1];

        return new CodeBlock
        {
            Id = Id,
            MessageId = MessageId,
            SequenceNumber = SequenceNumber,
            Language = Language,
            DisplayLanguage = DisplayLanguage,
            TargetFilePath = TargetFilePath,
            Content = content.Trim(),
            SourceRange = new TextRange(StartPosition, endPosition),
            // BlockType will be set by classifier after conversion
        };
    }

    /// <summary>
    /// Append content to this block.
    /// </summary>
    public void AppendContent(string text)
    {
        Content.Append(text);
    }

    /// <summary>
    /// Append a single character to this block.
    /// </summary>
    public void AppendContent(char ch)
    {
        Content.Append(ch);
    }

    /// <summary>
    /// Remove characters from the end of content.
    /// Used to strip closing fence if detected within content.
    /// </summary>
    public void RemoveFromEnd(int count)
    {
        if (count > 0 && count <= Content.Length)
        {
            Content.Remove(Content.Length - count, count);
        }
    }

    /// <summary>
    /// Check if content ends with the specified string.
    /// </summary>
    public bool ContentEndsWith(string suffix)
    {
        if (string.IsNullOrEmpty(suffix) || Content.Length < suffix.Length)
            return false;

        for (int i = 0; i < suffix.Length; i++)
        {
            if (Content[Content.Length - suffix.Length + i] != suffix[i])
                return false;
        }
        return true;
    }

    public override string ToString() =>
        $"PartialCodeBlock[{SequenceNumber}] Lang={Language} Lines={LineCount} Path={TargetFilePath}";
}
```

---

### Task 4: Create Code Block Events

**File:** `src/SeniorIntern.Core/Events/CodeBlockEvents.cs`

```csharp
namespace SeniorIntern.Core.Events;

using SeniorIntern.Core.Models;

/// <summary>
/// Event args raised when a code block starts during streaming.
/// </summary>
public sealed class CodeBlockStartedEventArgs : EventArgs
{
    /// <summary>
    /// The partial code block that just started.
    /// </summary>
    public required PartialCodeBlock Block { get; init; }

    /// <summary>
    /// ID of the message containing this block.
    /// </summary>
    public required Guid MessageId { get; init; }

    /// <summary>
    /// Sequence number of this block within the message (0-based).
    /// </summary>
    public int SequenceNumber => Block.SequenceNumber;

    /// <summary>
    /// Language detected from fence line (may be null).
    /// </summary>
    public string? Language => Block.Language;

    /// <summary>
    /// Target file path if specified in fence line.
    /// </summary>
    public string? TargetFilePath => Block.TargetFilePath;
}

/// <summary>
/// Event args raised when content is added to a streaming code block.
/// </summary>
public sealed class CodeBlockContentEventArgs : EventArgs
{
    /// <summary>
    /// The content that was just added.
    /// </summary>
    public required string Content { get; init; }

    /// <summary>
    /// The partial code block receiving content.
    /// </summary>
    public required PartialCodeBlock Block { get; init; }

    /// <summary>
    /// Whether this content includes a newline.
    /// </summary>
    public bool ContainsNewline => Content.Contains('\n');

    /// <summary>
    /// Total content accumulated so far.
    /// </summary>
    public string TotalContent => Block.Content.ToString();

    /// <summary>
    /// Current line count in the block.
    /// </summary>
    public int LineCount => Block.LineCount;
}

/// <summary>
/// Event args raised when a code block is completed during streaming.
/// </summary>
public sealed class CodeBlockCompletedEventArgs : EventArgs
{
    /// <summary>
    /// The completed code block.
    /// </summary>
    public required CodeBlock Block { get; init; }

    /// <summary>
    /// ID of the message containing this block.
    /// </summary>
    public required Guid MessageId { get; init; }

    /// <summary>
    /// Time taken to stream this code block.
    /// </summary>
    public TimeSpan Duration { get; init; }

    /// <summary>
    /// Sequence number of this block within the message (0-based).
    /// </summary>
    public int SequenceNumber => Block.SequenceNumber;

    /// <summary>
    /// Number of lines in the completed block.
    /// </summary>
    public int LineCount => Block.LineCount;

    /// <summary>
    /// Whether the block was truncated (incomplete fence at EOF).
    /// </summary>
    public bool WasTruncated { get; init; }
}

/// <summary>
/// Event args raised when a parsing error occurs.
/// </summary>
public sealed class CodeBlockParseErrorEventArgs : EventArgs
{
    /// <summary>
    /// Description of the error.
    /// </summary>
    public required string Error { get; init; }

    /// <summary>
    /// Position in the stream where the error occurred.
    /// </summary>
    public int Position { get; init; }

    /// <summary>
    /// The partial block that was being parsed, if any.
    /// </summary>
    public PartialCodeBlock? Block { get; init; }

    /// <summary>
    /// ID of the message being parsed.
    /// </summary>
    public Guid MessageId { get; init; }
}
```

---

### Task 5: Create IStreamingCodeBlockParser Interface

**File:** `src/SeniorIntern.Core/Interfaces/IStreamingCodeBlockParser.cs`

```csharp
namespace SeniorIntern.Core.Interfaces;

using SeniorIntern.Core.Events;
using SeniorIntern.Core.Models;

/// <summary>
/// Parser that extracts code blocks incrementally during LLM token streaming.
/// </summary>
/// <remarks>
/// <para>
/// The parser operates as a state machine, processing tokens character-by-character
/// and raising events as code blocks are detected, accumulate content, and complete.
/// </para>
/// <para>
/// Typical usage:
/// <code>
/// var parser = parserFactory.Create();
/// parser.Reset(messageId);
/// parser.BlockStarted += OnBlockStarted;
/// parser.ContentAdded += OnContentAdded;
/// parser.BlockCompleted += OnBlockCompleted;
///
/// await foreach (var token in llm.GenerateStreamingAsync(...))
/// {
///     parser.FeedToken(token);
/// }
/// parser.Complete();
///
/// var blocks = parser.GetCompletedBlocks();
/// </code>
/// </para>
/// </remarks>
public interface IStreamingCodeBlockParser : IDisposable
{
    #region State Properties

    /// <summary>
    /// Current state of the parser state machine.
    /// </summary>
    StreamingParserState State { get; }

    /// <summary>
    /// Total number of characters processed.
    /// </summary>
    int TotalCharactersProcessed { get; }

    /// <summary>
    /// Number of code blocks detected so far (completed + current).
    /// </summary>
    int BlockCount { get; }

    /// <summary>
    /// Whether there is currently a block being parsed.
    /// </summary>
    bool IsInsideCodeBlock { get; }

    /// <summary>
    /// ID of the message currently being parsed.
    /// </summary>
    Guid CurrentMessageId { get; }

    #endregion

    #region Core Methods

    /// <summary>
    /// Feed a token from the LLM stream to the parser.
    /// </summary>
    /// <param name="token">The token to process (may be single char or multiple chars).</param>
    void FeedToken(string token);

    /// <summary>
    /// Feed multiple tokens at once.
    /// </summary>
    /// <param name="tokens">Collection of tokens to process.</param>
    void FeedTokens(IEnumerable<string> tokens);

    /// <summary>
    /// Get all completed code blocks extracted so far.
    /// </summary>
    /// <returns>Read-only list of completed code blocks.</returns>
    IReadOnlyList<CodeBlock> GetCompletedBlocks();

    /// <summary>
    /// Get the current partial code block being accumulated.
    /// Returns null if not currently inside a code block.
    /// </summary>
    /// <returns>The partial block or null.</returns>
    PartialCodeBlock? GetCurrentBlock();

    /// <summary>
    /// Get a snapshot of the current block's content.
    /// More efficient than GetCurrentBlock().Content.ToString() for frequent polling.
    /// </summary>
    /// <returns>Current content or empty string if no active block.</returns>
    string GetCurrentBlockContent();

    /// <summary>
    /// Signal that streaming is complete.
    /// Finalizes any open code block (handles missing closing fence).
    /// </summary>
    void Complete();

    /// <summary>
    /// Reset the parser state for a new message.
    /// </summary>
    /// <param name="messageId">ID of the new message.</param>
    void Reset(Guid messageId);

    #endregion

    #region Events

    /// <summary>
    /// Raised when a new code block starts (opening fence detected and parsed).
    /// </summary>
    event EventHandler<CodeBlockStartedEventArgs>? BlockStarted;

    /// <summary>
    /// Raised when content is added to the current code block.
    /// </summary>
    event EventHandler<CodeBlockContentEventArgs>? ContentAdded;

    /// <summary>
    /// Raised when a code block is completed (closing fence detected or EOF).
    /// </summary>
    event EventHandler<CodeBlockCompletedEventArgs>? BlockCompleted;

    /// <summary>
    /// Raised when a parsing error occurs.
    /// </summary>
    event EventHandler<CodeBlockParseErrorEventArgs>? ParseError;

    #endregion
}
```

---

### Task 6: Create StreamingCodeBlockParser Implementation

**File:** `src/SeniorIntern.Services/StreamingCodeBlockParser.cs`

```csharp
namespace SeniorIntern.Services;

using System.Text;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Events;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;

/// <summary>
/// State machine-based parser for extracting code blocks during LLM streaming.
/// </summary>
public sealed class StreamingCodeBlockParser : IStreamingCodeBlockParser
{
    private readonly ILanguageDetectionService _languageService;
    private readonly IBlockClassificationService _classificationService;
    private readonly ILogger<StreamingCodeBlockParser>? _logger;

    // State
    private Guid _messageId;
    private StreamingParserState _state = StreamingParserState.Text;
    private readonly StringBuilder _buffer = new();
    private readonly StringBuilder _fenceLineBuffer = new();
    private int _position;
    private int _blockSequence;

    // Current block being parsed
    private PartialCodeBlock? _currentBlock;
    private DateTime _currentBlockStartTime;

    // Completed blocks
    private readonly List<CodeBlock> _completedBlocks = new();

    // Fence detection
    private FenceType _currentFenceType;
    private int _currentFenceLength;
    private int _pendingFenceChars;
    private char _fenceChar;
    private bool _atLineStart = true;

    // Constants
    private const char BacktickChar = '`';
    private const char TildeChar = '~';
    private const int MinFenceLength = 3;

    public StreamingParserState State => _state;
    public int TotalCharactersProcessed => _position;
    public int BlockCount => _completedBlocks.Count + (_currentBlock != null ? 1 : 0);
    public bool IsInsideCodeBlock => _currentBlock != null;
    public Guid CurrentMessageId => _messageId;

    public event EventHandler<CodeBlockStartedEventArgs>? BlockStarted;
    public event EventHandler<CodeBlockContentEventArgs>? ContentAdded;
    public event EventHandler<CodeBlockCompletedEventArgs>? BlockCompleted;
    public event EventHandler<CodeBlockParseErrorEventArgs>? ParseError;

    public StreamingCodeBlockParser(
        ILanguageDetectionService languageService,
        IBlockClassificationService classificationService,
        ILogger<StreamingCodeBlockParser>? logger = null)
    {
        _languageService = languageService;
        _classificationService = classificationService;
        _logger = logger;
    }

    #region Core Methods

    public void FeedToken(string token)
    {
        if (string.IsNullOrEmpty(token))
            return;

        foreach (var ch in token)
        {
            ProcessCharacter(ch);
            _position++;
            _buffer.Append(ch);
        }
    }

    public void FeedTokens(IEnumerable<string> tokens)
    {
        foreach (var token in tokens)
        {
            FeedToken(token);
        }
    }

    public IReadOnlyList<CodeBlock> GetCompletedBlocks() => _completedBlocks.AsReadOnly();

    public PartialCodeBlock? GetCurrentBlock() => _currentBlock;

    public string GetCurrentBlockContent() => _currentBlock?.Content.ToString() ?? string.Empty;

    public void Complete()
    {
        // If we're inside a code block, finalize it (unclosed fence)
        if (_currentBlock != null && _state == StreamingParserState.CodeContent)
        {
            _logger?.LogWarning(
                "Completing message with unclosed code block. Block {BlockId} at position {Position}",
                _currentBlock.Id, _currentBlock.StartPosition);

            CompleteCurrentBlock(truncated: true);
        }

        // Handle pending fence at EOF
        if (_state == StreamingParserState.FenceClosing && _currentBlock != null)
        {
            CompleteCurrentBlock(truncated: false);
        }

        _state = StreamingParserState.Text;
    }

    public void Reset(Guid messageId)
    {
        _messageId = messageId;
        _state = StreamingParserState.Text;
        _buffer.Clear();
        _fenceLineBuffer.Clear();
        _position = 0;
        _blockSequence = 0;
        _currentBlock = null;
        _completedBlocks.Clear();
        _pendingFenceChars = 0;
        _atLineStart = true;

        _logger?.LogDebug("Parser reset for message {MessageId}", messageId);
    }

    #endregion

    #region State Machine

    private void ProcessCharacter(char ch)
    {
        switch (_state)
        {
            case StreamingParserState.Text:
                ProcessTextState(ch);
                break;

            case StreamingParserState.FenceOpening:
                ProcessFenceOpeningState(ch);
                break;

            case StreamingParserState.CodeContent:
                ProcessCodeContentState(ch);
                break;

            case StreamingParserState.FenceClosing:
                ProcessFenceClosingState(ch);
                break;
        }

        // Track line starts
        _atLineStart = (ch == '\n');
    }

    private void ProcessTextState(char ch)
    {
        // Check for potential fence start
        if (ch == BacktickChar || ch == TildeChar)
        {
            if (_pendingFenceChars == 0)
            {
                _fenceChar = ch;
                _pendingFenceChars = 1;
            }
            else if (ch == _fenceChar)
            {
                _pendingFenceChars++;

                // Check if we have minimum fence length
                if (_pendingFenceChars >= MinFenceLength)
                {
                    // Continue accumulating to handle extended fences (````, etc.)
                }
            }
            else
            {
                // Different fence char, reset
                ResetFenceDetection();
            }
        }
        else if (_pendingFenceChars >= MinFenceLength)
        {
            // We have a complete fence, transition to FenceOpening
            BeginFenceOpening(ch);
        }
        else
        {
            // Not a fence, reset
            ResetFenceDetection();
        }
    }

    private void BeginFenceOpening(char firstChar)
    {
        _currentFenceType = _fenceChar == BacktickChar ? FenceType.Backtick : FenceType.Tilde;
        _currentFenceLength = _pendingFenceChars;

        _currentBlock = new PartialCodeBlock
        {
            MessageId = _messageId,
            SequenceNumber = _blockSequence++,
            StartPosition = _position - _currentFenceLength,
            FenceType = _currentFenceType,
            FenceLength = _currentFenceLength
        };

        _currentBlockStartTime = DateTime.UtcNow;
        _fenceLineBuffer.Clear();
        _state = StreamingParserState.FenceOpening;

        // Process the character that triggered transition
        if (firstChar != '\n')
        {
            _fenceLineBuffer.Append(firstChar);
        }
        else
        {
            // Immediate newline after fence = no language specified
            CompleteFenceOpening();
        }

        _pendingFenceChars = 0;
    }

    private void ProcessFenceOpeningState(char ch)
    {
        if (ch == '\n')
        {
            CompleteFenceOpening();
        }
        else
        {
            _fenceLineBuffer.Append(ch);
        }
    }

    private void CompleteFenceOpening()
    {
        if (_currentBlock == null) return;

        // Parse the fence line for language and optional path
        var fenceLine = _fenceLineBuffer.ToString().Trim();
        _currentBlock.FenceLine = fenceLine;

        ParseFenceLine(fenceLine);

        _state = StreamingParserState.CodeContent;

        _logger?.LogDebug(
            "Code block started: Language={Language}, Path={Path}",
            _currentBlock.Language, _currentBlock.TargetFilePath);

        BlockStarted?.Invoke(this, new CodeBlockStartedEventArgs
        {
            Block = _currentBlock,
            MessageId = _messageId
        });
    }

    private void ParseFenceLine(string fenceLine)
    {
        if (_currentBlock == null || string.IsNullOrEmpty(fenceLine))
            return;

        string? language = null;
        string? path = null;

        // Check for colon separator (lang:path format)
        var colonIndex = fenceLine.IndexOf(':');
        if (colonIndex > 0)
        {
            language = fenceLine[..colonIndex].Trim();
            var pathPart = fenceLine[(colonIndex + 1)..].Trim();

            // Handle quoted paths
            if (pathPart.StartsWith('"') && pathPart.EndsWith('"') && pathPart.Length > 2)
            {
                path = pathPart[1..^1];
            }
            else if (pathPart.StartsWith('\'') && pathPart.EndsWith('\'') && pathPart.Length > 2)
            {
                path = pathPart[1..^1];
            }
            else
            {
                path = pathPart;
            }
        }
        else
        {
            // Just language, no path
            language = fenceLine;
        }

        // Normalize language
        if (!string.IsNullOrEmpty(language))
        {
            var (normalizedLang, displayLang) = _languageService.DetectLanguage(language, "", path);
            _currentBlock.Language = normalizedLang;
            _currentBlock.DisplayLanguage = displayLang;
        }

        _currentBlock.TargetFilePath = path;
    }

    private void ProcessCodeContentState(char ch)
    {
        // Check for potential closing fence
        if (_atLineStart && (ch == BacktickChar || ch == TildeChar) && ch == _fenceChar)
        {
            _pendingFenceChars = 1;
            _state = StreamingParserState.FenceClosing;
            return;
        }

        // Normal code content
        AppendToCurrentBlock(ch);
    }

    private void ProcessFenceClosingState(char ch)
    {
        if (ch == _fenceChar)
        {
            _pendingFenceChars++;
        }
        else if (_pendingFenceChars >= _currentFenceLength)
        {
            // We have a matching closing fence
            if (ch == '\n' || ch == '\r')
            {
                CompleteCurrentBlock(truncated: false);
            }
            else
            {
                // Not a valid closing fence (has trailing chars)
                // Add the fence chars as content and continue
                AppendFenceCharsAsContent();
                _state = StreamingParserState.CodeContent;
                AppendToCurrentBlock(ch);
            }
            _pendingFenceChars = 0;
        }
        else
        {
            // Not enough fence chars, add as content
            AppendFenceCharsAsContent();
            _state = StreamingParserState.CodeContent;
            if (ch != '\n')
            {
                AppendToCurrentBlock(ch);
            }
            _pendingFenceChars = 0;
        }
    }

    private void AppendFenceCharsAsContent()
    {
        for (int i = 0; i < _pendingFenceChars; i++)
        {
            AppendToCurrentBlock(_fenceChar);
        }
    }

    private void AppendToCurrentBlock(char ch)
    {
        if (_currentBlock == null) return;

        _currentBlock.AppendContent(ch);

        ContentAdded?.Invoke(this, new CodeBlockContentEventArgs
        {
            Content = ch.ToString(),
            Block = _currentBlock
        });
    }

    private void AppendToCurrentBlock(string content)
    {
        if (_currentBlock == null) return;

        _currentBlock.AppendContent(content);

        ContentAdded?.Invoke(this, new CodeBlockContentEventArgs
        {
            Content = content,
            Block = _currentBlock
        });
    }

    private void CompleteCurrentBlock(bool truncated)
    {
        if (_currentBlock == null) return;

        var duration = DateTime.UtcNow - _currentBlockStartTime;
        var block = _currentBlock.ToCodeBlock(_position);

        // Classify the block
        var surroundingText = GetSurroundingText(block.SourceRange.Start);
        block = block with
        {
            BlockType = _classificationService.ClassifyBlock(
                block.Content, block.Language, surroundingText)
        };

        _completedBlocks.Add(block);

        _logger?.LogDebug(
            "Code block completed: {BlockId} Type={Type} Lines={Lines} Duration={Duration}ms",
            block.Id, block.BlockType, block.LineCount, duration.TotalMilliseconds);

        BlockCompleted?.Invoke(this, new CodeBlockCompletedEventArgs
        {
            Block = block,
            MessageId = _messageId,
            Duration = duration,
            WasTruncated = truncated
        });

        _currentBlock = null;
        _state = StreamingParserState.Text;
    }

    private void ResetFenceDetection()
    {
        _pendingFenceChars = 0;
    }

    private string GetSurroundingText(int position)
    {
        var bufferStr = _buffer.ToString();
        var contextWindow = 300;
        var start = Math.Max(0, position - contextWindow);
        var end = Math.Min(bufferStr.Length, position + 100);
        return bufferStr[start..end];
    }

    #endregion

    #region IDisposable

    public void Dispose()
    {
        _buffer.Clear();
        _fenceLineBuffer.Clear();
        _completedBlocks.Clear();
        _currentBlock = null;
    }

    #endregion
}
```

---

### Task 7: Create StreamingParserFactory

**File:** `src/SeniorIntern.Services/Factories/StreamingParserFactory.cs`

```csharp
namespace SeniorIntern.Services.Factories;

using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;

/// <summary>
/// Factory for creating streaming parser instances.
/// </summary>
public interface IStreamingParserFactory
{
    /// <summary>
    /// Create a new streaming parser instance.
    /// </summary>
    IStreamingCodeBlockParser Create();

    /// <summary>
    /// Create a new streaming parser initialized for a specific message.
    /// </summary>
    IStreamingCodeBlockParser Create(Guid messageId);
}

/// <summary>
/// Default implementation of the streaming parser factory.
/// </summary>
public sealed class StreamingParserFactory : IStreamingParserFactory
{
    private readonly ILanguageDetectionService _languageService;
    private readonly IBlockClassificationService _classificationService;
    private readonly ILoggerFactory? _loggerFactory;

    public StreamingParserFactory(
        ILanguageDetectionService languageService,
        IBlockClassificationService classificationService,
        ILoggerFactory? loggerFactory = null)
    {
        _languageService = languageService;
        _classificationService = classificationService;
        _loggerFactory = loggerFactory;
    }

    public IStreamingCodeBlockParser Create()
    {
        var logger = _loggerFactory?.CreateLogger<StreamingCodeBlockParser>();
        return new StreamingCodeBlockParser(
            _languageService,
            _classificationService,
            logger);
    }

    public IStreamingCodeBlockParser Create(Guid messageId)
    {
        var parser = Create();
        parser.Reset(messageId);
        return parser;
    }
}
```

---

### Task 8: Register Services in DI

**File to Modify:** `src/SeniorIntern.Desktop/Extensions/ServiceCollectionExtensions.cs`

**Changes Required:**

```csharp
// Add to the ConfigureServices method:

// v0.4.1f: Streaming parser
services.AddTransient<IStreamingCodeBlockParser, StreamingCodeBlockParser>();
services.AddSingleton<IStreamingParserFactory, StreamingParserFactory>();
```

---

## Unit Testing Requirements

### Test File: `tests/SeniorIntern.Services.Tests/StreamingCodeBlockParserTests.cs`

```csharp
namespace SeniorIntern.Services.Tests;

using Moq;
using SeniorIntern.Core.Events;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using Xunit;

public class StreamingCodeBlockParserTests
{
    private readonly Mock<ILanguageDetectionService> _mockLanguageService;
    private readonly Mock<IBlockClassificationService> _mockClassificationService;
    private readonly StreamingCodeBlockParser _parser;

    public StreamingCodeBlockParserTests()
    {
        _mockLanguageService = new Mock<ILanguageDetectionService>();
        _mockClassificationService = new Mock<IBlockClassificationService>();

        SetupDefaultMocks();

        _parser = new StreamingCodeBlockParser(
            _mockLanguageService.Object,
            _mockClassificationService.Object);
    }

    private void SetupDefaultMocks()
    {
        _mockLanguageService
            .Setup(s => s.DetectLanguage(It.IsAny<string>(), It.IsAny<string>(), It.IsAny<string?>()))
            .Returns<string, string, string?>((lang, _, _) => (lang.ToLower(), lang));

        _mockClassificationService
            .Setup(s => s.ClassifyBlock(It.IsAny<string>(), It.IsAny<string?>(), It.IsAny<string>()))
            .Returns(CodeBlockType.CompleteFile);
    }

    #region Basic Detection

    [Fact]
    public void FeedToken_DetectsBlockStart_RaisesBlockStartedEvent()
    {
        _parser.Reset(Guid.NewGuid());

        CodeBlockStartedEventArgs? eventArgs = null;
        _parser.BlockStarted += (s, e) => eventArgs = e;

        _parser.FeedToken("Here's code:\n```csharp\n");

        Assert.NotNull(eventArgs);
        Assert.Equal("csharp", eventArgs.Language);
        Assert.Equal(StreamingParserState.CodeContent, _parser.State);
    }

    [Fact]
    public void FeedToken_DetectsBlockEnd_RaisesBlockCompletedEvent()
    {
        _parser.Reset(Guid.NewGuid());

        CodeBlockCompletedEventArgs? eventArgs = null;
        _parser.BlockCompleted += (s, e) => eventArgs = e;

        _parser.FeedToken("```csharp\npublic class Test { }\n```\n");

        Assert.NotNull(eventArgs);
        Assert.Equal("public class Test { }", eventArgs.Block.Content);
        Assert.False(eventArgs.WasTruncated);
    }

    [Fact]
    public void FeedToken_NoCodeBlock_StateRemainsText()
    {
        _parser.Reset(Guid.NewGuid());

        _parser.FeedToken("Hello, this is just regular text with no code.");

        Assert.Equal(StreamingParserState.Text, _parser.State);
        Assert.Empty(_parser.GetCompletedBlocks());
    }

    #endregion

    #region Content Accumulation

    [Fact]
    public void FeedToken_AccumulatesContent_CharacterByCharacter()
    {
        _parser.Reset(Guid.NewGuid());

        _parser.FeedToken("```csharp\n");

        // Feed character by character
        foreach (var ch in "public class Test { }")
        {
            _parser.FeedToken(ch.ToString());
        }

        var current = _parser.GetCurrentBlock();
        Assert.NotNull(current);
        Assert.Equal("public class Test { }", current.Content.ToString());
    }

    [Fact]
    public void FeedToken_RaisesContentAddedEvents()
    {
        _parser.Reset(Guid.NewGuid());

        var contentEvents = new List<string>();
        _parser.ContentAdded += (s, e) => contentEvents.Add(e.Content);

        _parser.FeedToken("```csharp\n");
        _parser.FeedToken("abc");

        Assert.Equal(3, contentEvents.Count);
        Assert.Equal("a", contentEvents[0]);
        Assert.Equal("b", contentEvents[1]);
        Assert.Equal("c", contentEvents[2]);
    }

    [Fact]
    public void GetCurrentBlockContent_ReturnsAccumulatedContent()
    {
        _parser.Reset(Guid.NewGuid());

        _parser.FeedToken("```csharp\npublic class");

        var content = _parser.GetCurrentBlockContent();
        Assert.Equal("public class", content);
    }

    #endregion

    #region Fence Line Parsing

    [Fact]
    public void FeedToken_ParsesLanguageOnly()
    {
        _parser.Reset(Guid.NewGuid());

        CodeBlockStartedEventArgs? eventArgs = null;
        _parser.BlockStarted += (s, e) => eventArgs = e;

        _parser.FeedToken("```typescript\ncode\n```\n");

        Assert.NotNull(eventArgs);
        Assert.Equal("typescript", eventArgs.Language);
        Assert.Null(eventArgs.TargetFilePath);
    }

    [Fact]
    public void FeedToken_ParsesLanguageAndPath()
    {
        _parser.Reset(Guid.NewGuid());

        CodeBlockStartedEventArgs? eventArgs = null;
        _parser.BlockStarted += (s, e) => eventArgs = e;

        _parser.FeedToken("```csharp:src/Models/User.cs\ncode\n```\n");

        Assert.NotNull(eventArgs);
        Assert.Equal("csharp", eventArgs.Language);
        Assert.Equal("src/Models/User.cs", eventArgs.TargetFilePath);
    }

    [Fact]
    public void FeedToken_ParsesQuotedPath()
    {
        _parser.Reset(Guid.NewGuid());

        CodeBlockStartedEventArgs? eventArgs = null;
        _parser.BlockStarted += (s, e) => eventArgs = e;

        _parser.FeedToken("```csharp:\"src/My Models/User.cs\"\ncode\n```\n");

        Assert.NotNull(eventArgs);
        Assert.Equal("src/My Models/User.cs", eventArgs.TargetFilePath);
    }

    [Fact]
    public void FeedToken_HandlesNoLanguage()
    {
        _parser.Reset(Guid.NewGuid());

        CodeBlockStartedEventArgs? eventArgs = null;
        _parser.BlockStarted += (s, e) => eventArgs = e;

        _parser.FeedToken("```\nsome code\n```\n");

        Assert.NotNull(eventArgs);
        Assert.Null(eventArgs.Language);
    }

    #endregion

    #region Multiple Blocks

    [Fact]
    public void FeedToken_HandlesMultipleBlocks()
    {
        _parser.Reset(Guid.NewGuid());

        _parser.FeedToken("First:\n```js\ncode1\n```\n\nSecond:\n```py\ncode2\n```\n");

        var blocks = _parser.GetCompletedBlocks();

        Assert.Equal(2, blocks.Count);
        Assert.Equal(0, blocks[0].SequenceNumber);
        Assert.Equal(1, blocks[1].SequenceNumber);
        Assert.Equal("code1", blocks[0].Content);
        Assert.Equal("code2", blocks[1].Content);
    }

    [Fact]
    public void FeedToken_SequenceNumbersIncrease()
    {
        _parser.Reset(Guid.NewGuid());

        var sequences = new List<int>();
        _parser.BlockCompleted += (s, e) => sequences.Add(e.SequenceNumber);

        _parser.FeedToken("```a\n1\n```\n```b\n2\n```\n```c\n3\n```\n");

        Assert.Equal(new[] { 0, 1, 2 }, sequences);
    }

    #endregion

    #region Extended Fences

    [Fact]
    public void FeedToken_Handles4BacktickFence()
    {
        _parser.Reset(Guid.NewGuid());

        // 4-backtick fence should work and require 4 backticks to close
        _parser.FeedToken("````csharp\n```not closing```\n````\n");

        var blocks = _parser.GetCompletedBlocks();
        Assert.Single(blocks);
        Assert.Contains("```not closing```", blocks[0].Content);
    }

    [Fact]
    public void FeedToken_HandlesTildeFence()
    {
        _parser.Reset(Guid.NewGuid());

        _parser.FeedToken("~~~python\nprint('hello')\n~~~\n");

        var blocks = _parser.GetCompletedBlocks();
        Assert.Single(blocks);
        Assert.Equal("python", blocks[0].Language);
        Assert.Equal("print('hello')", blocks[0].Content);
    }

    [Fact]
    public void FeedToken_RequiresMatchingFenceType()
    {
        _parser.Reset(Guid.NewGuid());

        // Start with backticks, ~~~ should not close it
        _parser.FeedToken("```csharp\ncode\n~~~\nmore code\n```\n");

        var blocks = _parser.GetCompletedBlocks();
        Assert.Single(blocks);
        Assert.Contains("~~~", blocks[0].Content);
    }

    #endregion

    #region Edge Cases

    [Fact]
    public void FeedToken_IgnoresFenceNotAtLineStart()
    {
        _parser.Reset(Guid.NewGuid());

        _parser.FeedToken("```csharp\nvar x = \"```\";\n```\n");

        var blocks = _parser.GetCompletedBlocks();
        Assert.Single(blocks);
        // The ``` inside string should not close the block
        Assert.Equal("var x = \"```\";", blocks[0].Content);
    }

    [Fact]
    public void Complete_FinalizesUnclosedBlock()
    {
        _parser.Reset(Guid.NewGuid());

        CodeBlockCompletedEventArgs? eventArgs = null;
        _parser.BlockCompleted += (s, e) => eventArgs = e;

        _parser.FeedToken("```csharp\nunclosed code");
        _parser.Complete();

        Assert.NotNull(eventArgs);
        Assert.True(eventArgs.WasTruncated);
        Assert.Equal("unclosed code", eventArgs.Block.Content);
    }

    [Fact]
    public void Reset_ClearsAllState()
    {
        _parser.Reset(Guid.NewGuid());

        _parser.FeedToken("```csharp\nsome code\n```\n");

        var newMessageId = Guid.NewGuid();
        _parser.Reset(newMessageId);

        Assert.Equal(StreamingParserState.Text, _parser.State);
        Assert.Equal(0, _parser.TotalCharactersProcessed);
        Assert.Empty(_parser.GetCompletedBlocks());
        Assert.Null(_parser.GetCurrentBlock());
        Assert.Equal(newMessageId, _parser.CurrentMessageId);
    }

    [Fact]
    public void FeedToken_HandlesEmptyToken()
    {
        _parser.Reset(Guid.NewGuid());

        // Should not throw
        _parser.FeedToken("");
        _parser.FeedToken(null!);

        Assert.Equal(StreamingParserState.Text, _parser.State);
    }

    [Fact]
    public void FeedToken_HandlesBacktickInCode()
    {
        _parser.Reset(Guid.NewGuid());

        _parser.FeedToken("```js\nconst x = `template`;\n```\n");

        var blocks = _parser.GetCompletedBlocks();
        Assert.Single(blocks);
        Assert.Equal("const x = `template`;", blocks[0].Content);
    }

    #endregion

    #region State Properties

    [Fact]
    public void TotalCharactersProcessed_TracksCorrectly()
    {
        _parser.Reset(Guid.NewGuid());

        _parser.FeedToken("Hello");
        Assert.Equal(5, _parser.TotalCharactersProcessed);

        _parser.FeedToken(" World");
        Assert.Equal(11, _parser.TotalCharactersProcessed);
    }

    [Fact]
    public void BlockCount_IncludesCurrentBlock()
    {
        _parser.Reset(Guid.NewGuid());

        Assert.Equal(0, _parser.BlockCount);

        _parser.FeedToken("```js\n");
        Assert.Equal(1, _parser.BlockCount);

        _parser.FeedToken("code\n```\n");
        Assert.Equal(1, _parser.BlockCount);

        _parser.FeedToken("```py\n");
        Assert.Equal(2, _parser.BlockCount);
    }

    [Fact]
    public void IsInsideCodeBlock_ReflectsState()
    {
        _parser.Reset(Guid.NewGuid());

        Assert.False(_parser.IsInsideCodeBlock);

        _parser.FeedToken("```js\n");
        Assert.True(_parser.IsInsideCodeBlock);

        _parser.FeedToken("code\n```\n");
        Assert.False(_parser.IsInsideCodeBlock);
    }

    #endregion

    #region Classification Integration

    [Fact]
    public void BlockCompleted_IncludesClassifiedType()
    {
        _mockClassificationService
            .Setup(s => s.ClassifyBlock(It.IsAny<string>(), "bash", It.IsAny<string>()))
            .Returns(CodeBlockType.Command);

        _parser.Reset(Guid.NewGuid());

        CodeBlockCompletedEventArgs? eventArgs = null;
        _parser.BlockCompleted += (s, e) => eventArgs = e;

        _parser.FeedToken("```bash\nnpm install\n```\n");

        Assert.NotNull(eventArgs);
        Assert.Equal(CodeBlockType.Command, eventArgs.Block.BlockType);
    }

    #endregion

    #region FeedTokens Batch

    [Fact]
    public void FeedTokens_ProcessesMultipleTokens()
    {
        _parser.Reset(Guid.NewGuid());

        var tokens = new[] { "```", "csharp", "\n", "code", "\n```\n" };
        _parser.FeedTokens(tokens);

        var blocks = _parser.GetCompletedBlocks();
        Assert.Single(blocks);
        Assert.Equal("code", blocks[0].Content);
    }

    #endregion

    #region Source Range

    [Fact]
    public void CompletedBlock_HasCorrectSourceRange()
    {
        _parser.Reset(Guid.NewGuid());

        var prefix = "Some text before\n";
        _parser.FeedToken(prefix);
        _parser.FeedToken("```js\ncode\n```\n");

        var blocks = _parser.GetCompletedBlocks();
        Assert.Single(blocks);

        var range = blocks[0].SourceRange;
        Assert.Equal(prefix.Length, range.Start);
        Assert.True(range.End > range.Start);
    }

    #endregion
}
```

---

## Test Count Summary

| Component | Test Count | Focus Areas |
|-----------|------------|-------------|
| Basic Detection | 3 | Block start, end, no block |
| Content Accumulation | 3 | Char-by-char, events, get content |
| Fence Line Parsing | 5 | Language, path, quoted, no language |
| Multiple Blocks | 2 | Sequential blocks, sequence numbers |
| Extended Fences | 3 | 4-backtick, tilde, matching type |
| Edge Cases | 5 | Mid-line fence, unclosed, reset, empty, backtick in code |
| State Properties | 3 | Characters, block count, inside block |
| Classification | 1 | Type from classifier |
| Batch Processing | 1 | FeedTokens |
| Source Range | 1 | Position tracking |
| **Total** | **27** | |

---

## Files Summary

### Files to Create (7)

| File | Purpose | Lines (approx) |
|------|---------|----------------|
| `src/SeniorIntern.Core/Models/TextRange.cs` | Source position range | 80 |
| `src/SeniorIntern.Core/Models/StreamingParserState.cs` | State machine enum | 35 |
| `src/SeniorIntern.Core/Models/PartialCodeBlock.cs` | In-progress block model | 130 |
| `src/SeniorIntern.Core/Events/CodeBlockEvents.cs` | Streaming events | 100 |
| `src/SeniorIntern.Core/Interfaces/IStreamingCodeBlockParser.cs` | Parser interface | 95 |
| `src/SeniorIntern.Services/StreamingCodeBlockParser.cs` | Parser implementation | 380 |
| `src/SeniorIntern.Services/Factories/StreamingParserFactory.cs` | Parser factory | 50 |

### Files to Modify (1)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/Extensions/ServiceCollectionExtensions.cs` | Register parser and factory |

---

## Acceptance Criteria

| ID | Criterion | Verification |
|----|-----------|--------------|
| AC-1 | Parser detects ``` fence start during token streaming | Unit test |
| AC-2 | Parser correctly parses language from fence line | Unit test |
| AC-3 | Parser correctly parses lang:path format | Unit test |
| AC-4 | Parser handles quoted paths with spaces | Unit test |
| AC-5 | Parser accumulates content character-by-character | Unit test |
| AC-6 | Parser detects closing fence and completes block | Unit test |
| AC-7 | BlockStarted event fires when fence opening completes | Unit test |
| AC-8 | ContentAdded event fires for each token in code | Unit test |
| AC-9 | BlockCompleted event fires with classified block | Unit test |
| AC-10 | Multiple code blocks parsed sequentially with correct sequence numbers | Unit test |
| AC-11 | Extended fences (4+ backticks) require matching close | Unit test |
| AC-12 | Tilde fences (~~~) work equivalently to backticks | Unit test |
| AC-13 | Fence characters mid-line don't trigger false positives | Unit test |
| AC-14 | Complete() finalizes unclosed blocks as truncated | Unit test |
| AC-15 | Reset() clears all state for new message | Unit test |
| AC-16 | SourceRange accurately tracks block positions | Unit test |
| AC-17 | Parser integrates with ILanguageDetectionService | Unit test |
| AC-18 | Parser integrates with IBlockClassificationService | Unit test |

---

## Design Decisions

| Decision | Rationale |
|----------|-----------|
| Character-by-character processing | Ensures accurate state transitions regardless of token boundaries |
| State machine architecture | Clean separation of parsing phases, easy to extend |
| Event-driven notifications | Decouples parser from UI, enables flexible subscriptions |
| Support for extended fences | Allows nesting code blocks (markdown in code block) |
| Factory pattern | Enables scoped parser instances per message |
| Separate TextRange model | Reusable for diff highlighting and other features |
| Track line start position | Required for correct fence detection (must be at line start) |
| Trim trailing newline | Consistent content format regardless of fence placement |

---

## Edge Cases and Error Handling

### Edge Case 1: Fence Characters in String Literals

```javascript
// Input stream:
```js
const sql = "SELECT * FROM `users`";
const md = "Use ```code``` for inline";
```

// Expected: Both backticks in strings are preserved as content
// Solution: Only detect closing fence at line start
```

### Edge Case 2: Nested Code Blocks (Markdown in Markdown)

```markdown
// Input stream:
````markdown
Here's how to write code:
```python
print("hello")
```
````

// Expected: Inner ``` is content, outer ```` delimits block
// Solution: Match fence length and type for closing
```

### Edge Case 3: Incomplete Stream (Connection Dropped)

```
// Input stream (truncated):
```python
def foo():
    return 42
// [stream ends without closing fence]

// Expected: Block completed with WasTruncated = true
// Solution: Complete() method finalizes open blocks
```

### Edge Case 4: Empty Code Block

```
// Input stream:
```csharp
```

// Expected: Block with empty content
// Solution: Valid state transition, empty string content
```

### Error Handling

| Scenario | Handling |
|----------|----------|
| Null/empty token | Silently ignored |
| Mismatched fence type | Not recognized as close, content continues |
| Very long content | StringBuilder grows dynamically |
| Invalid language | Passed to LanguageDetectionService, returns null |
| Parse error | ParseError event raised, parsing continues |

---

## Performance Considerations

| Aspect | Approach |
|--------|----------|
| Memory | StringBuilder for content accumulation, reuse where possible |
| Event frequency | ContentAdded per character may be batched in future if needed |
| State transitions | O(1) per character |
| Buffer management | Buffer grows with full message, cleared on Reset |
| Thread safety | Single-threaded by design, parser is not thread-safe |

---

## Integration Points

### Upstream Dependencies

| Component | Dependency |
|-----------|------------|
| v0.4.1a | CodeBlock model |
| v0.4.1c | ILanguageDetectionService |
| v0.4.1d | IBlockClassificationService |
| v0.1.0 | ILlmService.GenerateStreamingAsync |

### Downstream Consumers

| Component | Usage |
|-----------|-------|
| v0.4.1g | ChatViewModel uses parser during streaming |
| v0.4.1g | CodeBlockViewModel created from events |
| v0.4.1h | UI updates in real-time from events |

---

## Dependencies

| Part | Dependency Description |
|------|------------------------|
| v0.4.1a | CodeBlock model for completed blocks |
| v0.4.1c | ILanguageDetectionService for language normalization |
| v0.4.1d | IBlockClassificationService for block type |

---

## Thread Safety Considerations

The streaming parser is designed for **single-threaded use**. The typical usage pattern is:

1. Create parser instance
2. Subscribe to events on UI thread
3. Feed tokens from async stream
4. Events marshal to UI thread via Dispatcher (handled by subscriber)

If multi-threaded access is needed in the future, the parser would need:
- Lock around state mutations
- Thread-safe event invocation
- Concurrent collection for completed blocks

---

## Next Steps

With v0.4.1f complete, the streaming parsing capability is ready. Proceed to:

| Part | Status | Description |
|------|--------|-------------|
| v0.4.1a | Complete | Core models |
| v0.4.1b | Complete | Parser service |
| v0.4.1c | Complete | Language detection |
| v0.4.1d | Complete | Block classification |
| v0.4.1e | Complete | File path inference |
| v0.4.1f | **Complete** | Streaming parser |
| v0.4.1g | Next | ViewModel integration |
| v0.4.1h | Pending | UI rendering |

**Proceed to v0.4.1g: ViewModel Integration**
- Create `CodeBlockViewModel` for UI binding
- Update `ChatMessageViewModel` to use streaming parser
- Wire up event handlers for real-time UI updates
- Implement commands for copy, apply, show diff
