# Design Specification: The Senior Intern v0.4.1 "Code Block Extraction"

**Status**: _IMPLEMENTED_

## Executive Summary

This document provides a comprehensive design specification for v0.4.1, the first sub-version of the Code Generation & Diffing phase. This version focuses on parsing LLM responses to identify code blocks, detecting their programming language, inferring target file paths, and presenting them as actionable proposals in the UI.

### Parent Version Reference
- **Parent**: v0.4.0 "Code Generation & Diffing"
- **Focus**: Parse code blocks from LLM responses, detect language and target file

### Dependencies
- v0.3.4 (Context Attachment) - Required for `FileContext` model used in file path inference

---

## Sub-Part Breakdown

| Sub-Part | Name | Focus |
|----------|------|-------|
| v0.4.1a | Core Models | CodeBlock, CodeProposal, LineRange, and enum definitions |
| v0.4.1b | Parser Service | ICodeBlockParserService interface and implementation |
| v0.4.1c | Language Detection | Language identification and file extension mapping |
| v0.4.1d | Block Classification | Classify blocks as CompleteFile, Snippet, Example, or Command |
| v0.4.1e | File Path Inference | Infer target file paths from context and content analysis |
| v0.4.1f | Streaming Parser | Incremental parsing during LLM token streaming |
| v0.4.1g | ViewModel Integration | ChatMessageViewModel updates and CodeBlockViewModel |
| v0.4.1h | UI Rendering | Code block display with actions in chat messages |

---

## v0.4.1a: Core Models

### Objective
Define the foundational data models for representing code blocks extracted from LLM responses.

### CodeBlock Model

```csharp
// src/SeniorIntern.Core/Models/CodeBlock.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Represents a single code block extracted from an LLM response.
/// </summary>
public sealed class CodeBlock
{
    /// <summary>
    /// Unique identifier for this code block.
    /// </summary>
    public Guid Id { get; init; } = Guid.NewGuid();

    /// <summary>
    /// Raw content of the code block (without markdown fences).
    /// </summary>
    public string Content { get; init; } = string.Empty;

    /// <summary>
    /// Detected or specified programming language identifier.
    /// </summary>
    public string? Language { get; init; }

    /// <summary>
    /// Normalized language name for display (e.g., "C#" instead of "csharp").
    /// </summary>
    public string? DisplayLanguage { get; init; }

    /// <summary>
    /// Inferred or specified target file path (relative to workspace).
    /// </summary>
    public string? TargetFilePath { get; set; }

    /// <summary>
    /// Whether this is a complete file or a partial snippet.
    /// </summary>
    public CodeBlockType BlockType { get; init; } = CodeBlockType.Snippet;

    /// <summary>
    /// Line range in original file this block should replace (for snippets).
    /// </summary>
    public LineRange? ReplacementRange { get; set; }

    /// <summary>
    /// Source message ID that contains this code block.
    /// </summary>
    public Guid MessageId { get; init; }

    /// <summary>
    /// Position in message (0-based index for multiple code blocks).
    /// </summary>
    public int SequenceNumber { get; init; }

    /// <summary>
    /// Start and end character positions in the original message content.
    /// </summary>
    public TextRange SourceRange { get; init; }

    /// <summary>
    /// Confidence level for inferred properties (0.0 to 1.0).
    /// </summary>
    public float ConfidenceScore { get; set; } = 1.0f;

    /// <summary>
    /// Timestamp when this code block was extracted.
    /// </summary>
    public DateTime ExtractedAt { get; init; } = DateTime.UtcNow;

    /// <summary>
    /// Current status of this code block in the apply workflow.
    /// </summary>
    public CodeBlockStatus Status { get; set; } = CodeBlockStatus.Pending;

    /// <summary>
    /// Whether this block can be applied (has target path and is applicable type).
    /// </summary>
    public bool IsApplicable =>
        BlockType is CodeBlockType.CompleteFile or CodeBlockType.Snippet
        && !string.IsNullOrEmpty(TargetFilePath);

    /// <summary>
    /// Line count of the code content.
    /// </summary>
    public int LineCount => Content.Split('\n').Length;
}
```

### Supporting Types

```csharp
// src/SeniorIntern.Core/Models/CodeBlockTypes.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Classification of a code block's purpose.
/// </summary>
public enum CodeBlockType
{
    /// <summary>
    /// A complete file to be created or replaced entirely.
    /// </summary>
    CompleteFile,

    /// <summary>
    /// A partial snippet to be inserted or to replace a section of a file.
    /// </summary>
    Snippet,

    /// <summary>
    /// Example/illustration code (not meant to be applied).
    /// </summary>
    Example,

    /// <summary>
    /// Shell/terminal command (not a code file).
    /// </summary>
    Command,

    /// <summary>
    /// Output/log content (readonly, not applicable).
    /// </summary>
    Output,

    /// <summary>
    /// Configuration or data file (JSON, YAML, XML, etc.).
    /// </summary>
    Config
}

/// <summary>
/// Status of a code block in the apply workflow.
/// </summary>
public enum CodeBlockStatus
{
    /// <summary>
    /// Not yet processed by user.
    /// </summary>
    Pending,

    /// <summary>
    /// Successfully applied to target file.
    /// </summary>
    Applied,

    /// <summary>
    /// User rejected this code block.
    /// </summary>
    Rejected,

    /// <summary>
    /// Skipped (e.g., not applicable or user chose to skip).
    /// </summary>
    Skipped,

    /// <summary>
    /// Conflict detected with current file state.
    /// </summary>
    Conflict,

    /// <summary>
    /// Error occurred during apply.
    /// </summary>
    Error
}

/// <summary>
/// Represents a range of text by character positions.
/// </summary>
public readonly record struct TextRange(int Start, int End)
{
    public int Length => End - Start;
    public bool IsEmpty => Start == End;

    public static TextRange Empty => new(0, 0);
}

/// <summary>
/// Represents a range of lines in a file.
/// </summary>
public readonly record struct LineRange(int StartLine, int EndLine)
{
    /// <summary>
    /// Number of lines in this range (inclusive).
    /// </summary>
    public int LineCount => EndLine - StartLine + 1;

    /// <summary>
    /// Whether this is a valid range (start <= end, both positive).
    /// </summary>
    public bool IsValid => StartLine > 0 && EndLine >= StartLine;

    public static LineRange Empty => new(0, 0);

    /// <summary>
    /// Creates a range for a single line.
    /// </summary>
    public static LineRange SingleLine(int line) => new(line, line);
}
```

### CodeProposal Model

```csharp
// src/SeniorIntern.Core/Models/CodeProposal.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Represents a collection of code blocks from a single LLM response,
/// forming a cohesive proposal for code changes.
/// </summary>
public sealed class CodeProposal
{
    /// <summary>
    /// Unique identifier for this proposal.
    /// </summary>
    public Guid Id { get; init; } = Guid.NewGuid();

    /// <summary>
    /// The message ID that generated this proposal.
    /// </summary>
    public Guid MessageId { get; init; }

    /// <summary>
    /// When this proposal was created.
    /// </summary>
    public DateTime CreatedAt { get; init; } = DateTime.UtcNow;

    /// <summary>
    /// All code blocks in this proposal.
    /// </summary>
    public IReadOnlyList<CodeBlock> CodeBlocks { get; init; } = Array.Empty<CodeBlock>();

    /// <summary>
    /// Code blocks that can be applied (have target paths and are applicable types).
    /// </summary>
    public IEnumerable<CodeBlock> ApplicableBlocks =>
        CodeBlocks.Where(b => b.IsApplicable);

    /// <summary>
    /// Code blocks classified as examples (not meant to be applied).
    /// </summary>
    public IEnumerable<CodeBlock> ExampleBlocks =>
        CodeBlocks.Where(b => b.BlockType == CodeBlockType.Example);

    /// <summary>
    /// Code blocks classified as commands.
    /// </summary>
    public IEnumerable<CodeBlock> CommandBlocks =>
        CodeBlocks.Where(b => b.BlockType == CodeBlockType.Command);

    /// <summary>
    /// Overall status of the proposal.
    /// </summary>
    public ProposalStatus Status { get; set; } = ProposalStatus.Pending;

    /// <summary>
    /// Number of applicable code blocks.
    /// </summary>
    public int ApplicableCount => ApplicableBlocks.Count();

    /// <summary>
    /// Number of blocks that have been applied.
    /// </summary>
    public int AppliedCount => CodeBlocks.Count(b => b.Status == CodeBlockStatus.Applied);

    /// <summary>
    /// Whether all applicable blocks have been processed.
    /// </summary>
    public bool IsFullyProcessed => ApplicableBlocks.All(
        b => b.Status is not CodeBlockStatus.Pending);

    /// <summary>
    /// Unique target files in this proposal.
    /// </summary>
    public IEnumerable<string> TargetFiles =>
        ApplicableBlocks
            .Select(b => b.TargetFilePath!)
            .Distinct();

    /// <summary>
    /// Number of unique files affected.
    /// </summary>
    public int AffectedFileCount => TargetFiles.Count();
}

/// <summary>
/// Overall status of a code proposal.
/// </summary>
public enum ProposalStatus
{
    /// <summary>
    /// No blocks have been processed yet.
    /// </summary>
    Pending,

    /// <summary>
    /// Some blocks have been applied, others pending.
    /// </summary>
    PartiallyApplied,

    /// <summary>
    /// All applicable blocks have been applied.
    /// </summary>
    FullyApplied,

    /// <summary>
    /// User rejected the entire proposal.
    /// </summary>
    Rejected,

    /// <summary>
    /// Proposal has expired (e.g., file changed since proposal).
    /// </summary>
    Expired
}
```

### Files to Create (v0.4.1a)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Models/CodeBlock.cs` | Main code block model |
| `src/SeniorIntern.Core/Models/CodeBlockTypes.cs` | Enums and supporting record structs |
| `src/SeniorIntern.Core/Models/CodeProposal.cs` | Proposal collection model |

### Files to Modify (v0.4.1a)

None - these are new files.

### Testing Strategy (v0.4.1a)

```csharp
// tests/SeniorIntern.Core.Tests/Models/CodeBlockTests.cs
public class CodeBlockTests
{
    [Fact]
    public void IsApplicable_WithTargetPathAndSnippetType_ReturnsTrue()
    {
        var block = new CodeBlock
        {
            Content = "public class Test { }",
            BlockType = CodeBlockType.Snippet,
            TargetFilePath = "src/Test.cs"
        };

        Assert.True(block.IsApplicable);
    }

    [Fact]
    public void IsApplicable_WithExampleType_ReturnsFalse()
    {
        var block = new CodeBlock
        {
            Content = "// example code",
            BlockType = CodeBlockType.Example,
            TargetFilePath = "src/Test.cs"
        };

        Assert.False(block.IsApplicable);
    }

    [Fact]
    public void IsApplicable_WithoutTargetPath_ReturnsFalse()
    {
        var block = new CodeBlock
        {
            Content = "public class Test { }",
            BlockType = CodeBlockType.CompleteFile,
            TargetFilePath = null
        };

        Assert.False(block.IsApplicable);
    }

    [Fact]
    public void LineCount_ReturnsCorrectCount()
    {
        var block = new CodeBlock
        {
            Content = "line1\nline2\nline3"
        };

        Assert.Equal(3, block.LineCount);
    }
}

public class LineRangeTests
{
    [Fact]
    public void LineCount_ReturnsInclusiveCount()
    {
        var range = new LineRange(5, 10);
        Assert.Equal(6, range.LineCount);
    }

    [Fact]
    public void IsValid_WithValidRange_ReturnsTrue()
    {
        var range = new LineRange(1, 5);
        Assert.True(range.IsValid);
    }

    [Fact]
    public void IsValid_WithInvertedRange_ReturnsFalse()
    {
        var range = new LineRange(10, 5);
        Assert.False(range.IsValid);
    }

    [Fact]
    public void SingleLine_CreatesSingleLineRange()
    {
        var range = LineRange.SingleLine(42);
        Assert.Equal(42, range.StartLine);
        Assert.Equal(42, range.EndLine);
        Assert.Equal(1, range.LineCount);
    }
}

public class CodeProposalTests
{
    [Fact]
    public void ApplicableBlocks_FiltersCorrectly()
    {
        var proposal = new CodeProposal
        {
            CodeBlocks = new[]
            {
                new CodeBlock { BlockType = CodeBlockType.Snippet, TargetFilePath = "a.cs" },
                new CodeBlock { BlockType = CodeBlockType.Example, TargetFilePath = "b.cs" },
                new CodeBlock { BlockType = CodeBlockType.Command },
                new CodeBlock { BlockType = CodeBlockType.CompleteFile, TargetFilePath = "c.cs" }
            }
        };

        Assert.Equal(2, proposal.ApplicableCount);
    }

    [Fact]
    public void AffectedFileCount_CountsUniqueFiles()
    {
        var proposal = new CodeProposal
        {
            CodeBlocks = new[]
            {
                new CodeBlock { BlockType = CodeBlockType.Snippet, TargetFilePath = "a.cs" },
                new CodeBlock { BlockType = CodeBlockType.Snippet, TargetFilePath = "a.cs" },
                new CodeBlock { BlockType = CodeBlockType.CompleteFile, TargetFilePath = "b.cs" }
            }
        };

        Assert.Equal(2, proposal.AffectedFileCount);
    }
}
```

### Acceptance Criteria (v0.4.1a)

- [ ] CodeBlock model has all required properties
- [ ] CodeBlockType enum covers all classification scenarios
- [ ] CodeBlockStatus enum covers all workflow states
- [ ] LineRange correctly calculates line counts
- [ ] TextRange correctly calculates character ranges
- [ ] CodeProposal correctly filters applicable blocks
- [ ] All models are immutable where appropriate (using `init`)
- [ ] Unit tests pass for all model behaviors

---

## v0.4.1b: Parser Service

### Objective
Implement the core parsing logic to extract code blocks from markdown-formatted LLM responses.

### ICodeBlockParserService Interface

```csharp
// src/SeniorIntern.Core/Interfaces/ICodeBlockParserService.cs
namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Service for parsing code blocks from LLM response content.
/// </summary>
public interface ICodeBlockParserService
{
    /// <summary>
    /// Extract all code blocks from a complete message.
    /// </summary>
    /// <param name="content">The full message content (markdown).</param>
    /// <param name="messageId">ID of the source message.</param>
    /// <returns>List of extracted code blocks.</returns>
    IReadOnlyList<CodeBlock> ParseMessage(string content, Guid messageId);

    /// <summary>
    /// Create a CodeProposal from extracted code blocks with context-aware inference.
    /// </summary>
    /// <param name="content">The full message content.</param>
    /// <param name="messageId">ID of the source message.</param>
    /// <param name="attachedContext">Files attached to the conversation for path inference.</param>
    /// <returns>A proposal containing all code blocks with inferred metadata.</returns>
    CodeProposal CreateProposal(
        string content,
        Guid messageId,
        IReadOnlyList<FileContext>? attachedContext = null);

    /// <summary>
    /// Parse a single code block from raw fence content.
    /// </summary>
    /// <param name="fenceContent">Content including the opening fence (```lang).</param>
    /// <param name="messageId">ID of the source message.</param>
    /// <param name="sequenceNumber">Position in message.</param>
    /// <returns>Parsed code block or null if invalid.</returns>
    CodeBlock? ParseSingleBlock(string fenceContent, Guid messageId, int sequenceNumber);
}
```

### Parser Events

```csharp
// src/SeniorIntern.Core/Events/CodeBlockEvents.cs
namespace SeniorIntern.Core.Events;

/// <summary>
/// Event args for when a code block is extracted.
/// </summary>
public sealed class CodeBlockExtractedEventArgs : EventArgs
{
    public required CodeBlock CodeBlock { get; init; }
    public required Guid MessageId { get; init; }
    public required int TotalBlocksInMessage { get; init; }
}

/// <summary>
/// Event args for when a proposal is created.
/// </summary>
public sealed class CodeProposalCreatedEventArgs : EventArgs
{
    public required CodeProposal Proposal { get; init; }
}

/// <summary>
/// Event args for parsing errors.
/// </summary>
public sealed class CodeBlockParseErrorEventArgs : EventArgs
{
    public required string Content { get; init; }
    public required string ErrorMessage { get; init; }
    public required TextRange Location { get; init; }
}
```

### CodeBlockParserService Implementation

```csharp
// src/SeniorIntern.Services/CodeBlockParserService.cs
namespace SeniorIntern.Services;

using System.Text.RegularExpressions;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;

/// <summary>
/// Parses code blocks from markdown-formatted LLM responses.
/// </summary>
public sealed partial class CodeBlockParserService : ICodeBlockParserService
{
    private readonly ILanguageDetectionService _languageService;
    private readonly IBlockClassificationService _classificationService;
    private readonly IFilePathInferenceService _pathInferenceService;
    private readonly ILogger<CodeBlockParserService>? _logger;

    // Compiled regex patterns for performance
    [GeneratedRegex(
        @"```(?<lang>[\w\-+#]+)?(?::(?<path>[^\n\r]+))?\r?\n(?<code>[\s\S]*?)```",
        RegexOptions.Compiled | RegexOptions.Multiline)]
    private static partial Regex FencedBlockPattern();

    [GeneratedRegex(
        @"^(?://|#|--|/\*|<!--)\s*(?:File|Path|Filename):\s*(?<path>.+?)(?:\s*\*/|-->)?$",
        RegexOptions.Compiled | RegexOptions.IgnoreCase | RegexOptions.Multiline)]
    private static partial Regex FileCommentPattern();

    public CodeBlockParserService(
        ILanguageDetectionService languageService,
        IBlockClassificationService classificationService,
        IFilePathInferenceService pathInferenceService,
        ILogger<CodeBlockParserService>? logger = null)
    {
        _languageService = languageService;
        _classificationService = classificationService;
        _pathInferenceService = pathInferenceService;
        _logger = logger;
    }

    public IReadOnlyList<CodeBlock> ParseMessage(string content, Guid messageId)
    {
        if (string.IsNullOrWhiteSpace(content))
            return Array.Empty<CodeBlock>();

        var blocks = new List<CodeBlock>();
        var matches = FencedBlockPattern().Matches(content);

        _logger?.LogDebug("Found {Count} code block(s) in message {MessageId}",
            matches.Count, messageId);

        for (int i = 0; i < matches.Count; i++)
        {
            var match = matches[i];

            try
            {
                var block = ExtractBlockFromMatch(match, messageId, i, content);
                if (block != null)
                {
                    blocks.Add(block);
                }
            }
            catch (Exception ex)
            {
                _logger?.LogWarning(ex,
                    "Failed to parse code block {Index} in message {MessageId}",
                    i, messageId);
            }
        }

        return blocks;
    }

    public CodeProposal CreateProposal(
        string content,
        Guid messageId,
        IReadOnlyList<FileContext>? attachedContext = null)
    {
        var blocks = ParseMessage(content, messageId);

        // Enhance blocks with inferred metadata
        var enhancedBlocks = blocks.Select(block =>
        {
            // Infer target file path if not explicitly specified
            if (string.IsNullOrEmpty(block.TargetFilePath))
            {
                var inferredPath = _pathInferenceService.InferTargetFilePath(
                    block, attachedContext ?? Array.Empty<FileContext>());

                if (!string.IsNullOrEmpty(inferredPath))
                {
                    return block with
                    {
                        TargetFilePath = inferredPath,
                        ConfidenceScore = _pathInferenceService.GetConfidenceScore(
                            block, inferredPath)
                    };
                }
            }
            return block;
        }).ToList();

        return new CodeProposal
        {
            MessageId = messageId,
            CodeBlocks = enhancedBlocks
        };
    }

    public CodeBlock? ParseSingleBlock(string fenceContent, Guid messageId, int sequenceNumber)
    {
        var match = FencedBlockPattern().Match(fenceContent);
        if (!match.Success)
            return null;

        return ExtractBlockFromMatch(match, messageId, sequenceNumber, fenceContent);
    }

    private CodeBlock? ExtractBlockFromMatch(
        Match match,
        Guid messageId,
        int sequenceNumber,
        string fullContent)
    {
        var rawCode = match.Groups["code"].Value;
        var langSpec = match.Groups["lang"].Value;
        var pathFromFence = match.Groups["path"].Value?.Trim();

        // Skip empty code blocks
        if (string.IsNullOrWhiteSpace(rawCode))
            return null;

        // Extract file path from first-line comment if not in fence
        var pathFromComment = ExtractPathFromComment(rawCode);
        var targetPath = !string.IsNullOrEmpty(pathFromFence)
            ? NormalizePath(pathFromFence)
            : !string.IsNullOrEmpty(pathFromComment)
                ? NormalizePath(pathFromComment)
                : null;

        // Remove the path comment from content if present
        var cleanedCode = RemovePathComment(rawCode);

        // Detect/normalize language
        var (language, displayLanguage) = _languageService.DetectLanguage(
            langSpec, cleanedCode, targetPath);

        // Get surrounding text for classification context
        var contextStart = Math.Max(0, match.Index - 300);
        var contextEnd = Math.Min(fullContent.Length, match.Index + match.Length + 100);
        var surroundingText = fullContent[contextStart..contextEnd];

        // Classify block type
        var blockType = _classificationService.ClassifyBlock(
            cleanedCode, language, surroundingText);

        return new CodeBlock
        {
            Content = cleanedCode.Trim(),
            Language = language,
            DisplayLanguage = displayLanguage,
            TargetFilePath = targetPath,
            BlockType = blockType,
            MessageId = messageId,
            SequenceNumber = sequenceNumber,
            SourceRange = new TextRange(match.Index, match.Index + match.Length),
            ConfidenceScore = CalculateConfidence(langSpec, targetPath, blockType)
        };
    }

    private string? ExtractPathFromComment(string code)
    {
        // Check first few lines for file path comment
        var lines = code.Split('\n', 5);
        foreach (var line in lines.Take(3))
        {
            var match = FileCommentPattern().Match(line);
            if (match.Success)
                return match.Groups["path"].Value.Trim();
        }
        return null;
    }

    private string RemovePathComment(string code)
    {
        var lines = code.Split('\n');
        var result = new List<string>();
        bool foundPath = false;

        foreach (var line in lines)
        {
            if (!foundPath && FileCommentPattern().IsMatch(line))
            {
                foundPath = true;
                continue; // Skip the path comment line
            }
            result.Add(line);
        }

        return string.Join('\n', result);
    }

    private static string NormalizePath(string path)
    {
        // Normalize path separators and remove leading/trailing whitespace
        return path.Trim()
            .Replace('\\', '/')
            .TrimStart('/');
    }

    private static float CalculateConfidence(
        string? langSpec,
        string? targetPath,
        CodeBlockType blockType)
    {
        float confidence = 1.0f;

        // Reduce confidence if language wasn't explicitly specified
        if (string.IsNullOrEmpty(langSpec))
            confidence -= 0.1f;

        // Reduce confidence for example blocks
        if (blockType == CodeBlockType.Example)
            confidence -= 0.2f;

        // Reduce confidence if no target path
        if (string.IsNullOrEmpty(targetPath))
            confidence -= 0.3f;

        return Math.Max(0.1f, confidence);
    }
}
```

### Files to Create (v0.4.1b)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/ICodeBlockParserService.cs` | Parser interface |
| `src/SeniorIntern.Core/Events/CodeBlockEvents.cs` | Parser events |
| `src/SeniorIntern.Services/CodeBlockParserService.cs` | Main parser implementation |

### Files to Modify (v0.4.1b)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Services/SeniorIntern.Services.csproj` | Ensure regex source generator support |
| `src/SeniorIntern.Desktop/Extensions/ServiceCollectionExtensions.cs` | Register parser service |

### Testing Strategy (v0.4.1b)

```csharp
public class CodeBlockParserServiceTests
{
    [Fact]
    public void ParseMessage_WithStandardFence_ExtractsBlock()
    {
        var content = """
            Here's the code:

            ```csharp
            public class Test { }
            ```
            """;

        var parser = CreateParser();
        var blocks = parser.ParseMessage(content, Guid.NewGuid());

        Assert.Single(blocks);
        Assert.Equal("csharp", blocks[0].Language);
        Assert.Equal("public class Test { }", blocks[0].Content);
    }

    [Fact]
    public void ParseMessage_WithPathInFence_ExtractsPath()
    {
        var content = """
            ```csharp:src/Models/User.cs
            public class User { }
            ```
            """;

        var parser = CreateParser();
        var blocks = parser.ParseMessage(content, Guid.NewGuid());

        Assert.Single(blocks);
        Assert.Equal("src/Models/User.cs", blocks[0].TargetFilePath);
    }

    [Fact]
    public void ParseMessage_WithPathComment_ExtractsPath()
    {
        var content = """
            ```csharp
            // File: src/Models/User.cs
            public class User { }
            ```
            """;

        var parser = CreateParser();
        var blocks = parser.ParseMessage(content, Guid.NewGuid());

        Assert.Single(blocks);
        Assert.Equal("src/Models/User.cs", blocks[0].TargetFilePath);
        Assert.DoesNotContain("// File:", blocks[0].Content);
    }

    [Fact]
    public void ParseMessage_WithMultipleBlocks_ExtractsAll()
    {
        var content = """
            First file:
            ```csharp
            class A { }
            ```

            Second file:
            ```typescript
            class B { }
            ```
            """;

        var parser = CreateParser();
        var blocks = parser.ParseMessage(content, Guid.NewGuid());

        Assert.Equal(2, blocks.Count);
        Assert.Equal(0, blocks[0].SequenceNumber);
        Assert.Equal(1, blocks[1].SequenceNumber);
    }

    [Fact]
    public void ParseMessage_WithEmptyBlock_SkipsIt()
    {
        var content = """
            ```csharp
            ```
            """;

        var parser = CreateParser();
        var blocks = parser.ParseMessage(content, Guid.NewGuid());

        Assert.Empty(blocks);
    }
}
```

### Acceptance Criteria (v0.4.1b)

- [ ] Parser extracts code blocks from standard markdown fences
- [ ] Parser handles `\`\`\`lang:path/to/file` syntax
- [ ] Parser extracts file paths from first-line comments
- [ ] Parser removes file path comments from extracted content
- [ ] Parser assigns correct sequence numbers to multiple blocks
- [ ] Parser calculates correct source ranges
- [ ] Empty code blocks are skipped
- [ ] Unit tests pass for all parsing scenarios

---

## v0.4.1c: Language Detection

### Objective
Implement robust language detection from fence specifiers, file extensions, and content analysis.

### ILanguageDetectionService Interface

```csharp
// src/SeniorIntern.Core/Interfaces/ILanguageDetectionService.cs
namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Service for detecting and normalizing programming language identifiers.
/// </summary>
public interface ILanguageDetectionService
{
    /// <summary>
    /// Detect the programming language of a code block.
    /// </summary>
    /// <param name="fenceLanguage">Language specified in the fence (may be null).</param>
    /// <param name="content">The code content.</param>
    /// <param name="filePath">Optional file path for extension-based detection.</param>
    /// <returns>Tuple of (normalized language ID, display name).</returns>
    (string? Language, string? DisplayLanguage) DetectLanguage(
        string? fenceLanguage,
        string content,
        string? filePath = null);

    /// <summary>
    /// Get the canonical language ID for an alias.
    /// </summary>
    string? NormalizeLanguageId(string languageAlias);

    /// <summary>
    /// Get the display name for a language ID.
    /// </summary>
    string? GetDisplayName(string languageId);

    /// <summary>
    /// Get the primary file extension for a language.
    /// </summary>
    string? GetFileExtension(string languageId);

    /// <summary>
    /// Get the language ID for a file extension.
    /// </summary>
    string? GetLanguageForExtension(string extension);

    /// <summary>
    /// Check if a language is a shell/command language.
    /// </summary>
    bool IsShellLanguage(string? languageId);

    /// <summary>
    /// Check if a language is for configuration files.
    /// </summary>
    bool IsConfigLanguage(string? languageId);
}
```

### LanguageDetectionService Implementation

```csharp
// src/SeniorIntern.Services/LanguageDetectionService.cs
namespace SeniorIntern.Services;

public sealed class LanguageDetectionService : ILanguageDetectionService
{
    // Language definitions with aliases and metadata
    private static readonly Dictionary<string, LanguageInfo> Languages = new(
        StringComparer.OrdinalIgnoreCase)
    {
        // C-family
        ["csharp"] = new("csharp", "C#", ".cs", new[] { "cs", "c#" }),
        ["c"] = new("c", "C", ".c", new[] { "h" }),
        ["cpp"] = new("cpp", "C++", ".cpp", new[] { "c++", "cxx", "cc", "hpp" }),

        // Web
        ["javascript"] = new("javascript", "JavaScript", ".js", new[] { "js", "mjs", "cjs" }),
        ["typescript"] = new("typescript", "TypeScript", ".ts", new[] { "ts" }),
        ["html"] = new("html", "HTML", ".html", new[] { "htm" }),
        ["css"] = new("css", "CSS", ".css", Array.Empty<string>()),
        ["scss"] = new("scss", "SCSS", ".scss", new[] { "sass" }),

        // Scripting
        ["python"] = new("python", "Python", ".py", new[] { "py", "py3" }),
        ["ruby"] = new("ruby", "Ruby", ".rb", new[] { "rb" }),
        ["perl"] = new("perl", "Perl", ".pl", new[] { "pm" }),
        ["php"] = new("php", "PHP", ".php", Array.Empty<string>()),

        // JVM
        ["java"] = new("java", "Java", ".java", Array.Empty<string>()),
        ["kotlin"] = new("kotlin", "Kotlin", ".kt", new[] { "kts" }),
        ["scala"] = new("scala", "Scala", ".scala", Array.Empty<string>()),
        ["groovy"] = new("groovy", "Groovy", ".groovy", Array.Empty<string>()),

        // Systems
        ["rust"] = new("rust", "Rust", ".rs", new[] { "rs" }),
        ["go"] = new("go", "Go", ".go", new[] { "golang" }),
        ["swift"] = new("swift", "Swift", ".swift", Array.Empty<string>()),

        // Shell
        ["bash"] = new("bash", "Bash", ".sh", new[] { "sh", "shell", "zsh" }, isShell: true),
        ["powershell"] = new("powershell", "PowerShell", ".ps1", new[] { "ps", "ps1", "pwsh" }, isShell: true),
        ["cmd"] = new("cmd", "Command Prompt", ".cmd", new[] { "bat", "batch" }, isShell: true),

        // Config/Data
        ["json"] = new("json", "JSON", ".json", Array.Empty<string>(), isConfig: true),
        ["yaml"] = new("yaml", "YAML", ".yaml", new[] { "yml" }, isConfig: true),
        ["xml"] = new("xml", "XML", ".xml", new[] { "xsl", "xslt" }, isConfig: true),
        ["toml"] = new("toml", "TOML", ".toml", Array.Empty<string>(), isConfig: true),
        ["ini"] = new("ini", "INI", ".ini", new[] { "cfg", "conf" }, isConfig: true),

        // Markup
        ["markdown"] = new("markdown", "Markdown", ".md", new[] { "md", "mdx" }),

        // .NET specific
        ["fsharp"] = new("fsharp", "F#", ".fs", new[] { "fs", "f#", "fsx" }),
        ["vb"] = new("vb", "Visual Basic", ".vb", new[] { "vbnet", "visualbasic" }),
        ["razor"] = new("razor", "Razor", ".razor", new[] { "cshtml" }),
        ["axaml"] = new("axaml", "Avalonia XAML", ".axaml", Array.Empty<string>()),
        ["xaml"] = new("xaml", "XAML", ".xaml", Array.Empty<string>()),

        // SQL
        ["sql"] = new("sql", "SQL", ".sql", new[] { "mysql", "postgresql", "sqlite" }),

        // Other
        ["dockerfile"] = new("dockerfile", "Dockerfile", "", new[] { "docker" }),
        ["makefile"] = new("makefile", "Makefile", "", new[] { "make" }),
        ["plaintext"] = new("plaintext", "Plain Text", ".txt", new[] { "text", "txt" }),
    };

    // Extension to language mapping
    private static readonly Dictionary<string, string> ExtensionMap;

    // Alias to canonical ID mapping
    private static readonly Dictionary<string, string> AliasMap;

    static LanguageDetectionService()
    {
        ExtensionMap = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
        AliasMap = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

        foreach (var (id, info) in Languages)
        {
            // Map extension
            if (!string.IsNullOrEmpty(info.Extension))
            {
                ExtensionMap[info.Extension] = id;
            }

            // Map aliases
            foreach (var alias in info.Aliases)
            {
                AliasMap[alias] = id;
            }
            AliasMap[id] = id; // Map ID to itself
        }
    }

    public (string? Language, string? DisplayLanguage) DetectLanguage(
        string? fenceLanguage,
        string content,
        string? filePath = null)
    {
        // Priority 1: Explicit fence language
        if (!string.IsNullOrWhiteSpace(fenceLanguage))
        {
            var normalized = NormalizeLanguageId(fenceLanguage.Trim().ToLowerInvariant());
            if (normalized != null)
            {
                return (normalized, GetDisplayName(normalized));
            }
        }

        // Priority 2: File extension
        if (!string.IsNullOrEmpty(filePath))
        {
            var ext = Path.GetExtension(filePath);
            if (!string.IsNullOrEmpty(ext))
            {
                var langFromExt = GetLanguageForExtension(ext);
                if (langFromExt != null)
                {
                    return (langFromExt, GetDisplayName(langFromExt));
                }
            }
        }

        // Priority 3: Content-based detection (heuristics)
        var detected = DetectFromContent(content);
        if (detected != null)
        {
            return (detected, GetDisplayName(detected));
        }

        return (null, null);
    }

    public string? NormalizeLanguageId(string languageAlias)
    {
        if (string.IsNullOrWhiteSpace(languageAlias))
            return null;

        return AliasMap.TryGetValue(languageAlias, out var id) ? id : null;
    }

    public string? GetDisplayName(string languageId)
    {
        return Languages.TryGetValue(languageId, out var info) ? info.DisplayName : null;
    }

    public string? GetFileExtension(string languageId)
    {
        return Languages.TryGetValue(languageId, out var info) ? info.Extension : null;
    }

    public string? GetLanguageForExtension(string extension)
    {
        var ext = extension.StartsWith('.') ? extension : $".{extension}";
        return ExtensionMap.TryGetValue(ext, out var lang) ? lang : null;
    }

    public bool IsShellLanguage(string? languageId)
    {
        if (string.IsNullOrEmpty(languageId))
            return false;
        return Languages.TryGetValue(languageId, out var info) && info.IsShell;
    }

    public bool IsConfigLanguage(string? languageId)
    {
        if (string.IsNullOrEmpty(languageId))
            return false;
        return Languages.TryGetValue(languageId, out var info) && info.IsConfig;
    }

    private static string? DetectFromContent(string content)
    {
        if (string.IsNullOrWhiteSpace(content))
            return null;

        var trimmed = content.TrimStart();

        // C# indicators
        if (trimmed.Contains("namespace ") && trimmed.Contains("using "))
            return "csharp";
        if (Regex.IsMatch(trimmed, @"^\s*(public|private|internal|protected)\s+(class|interface|record|struct)"))
            return "csharp";

        // TypeScript/JavaScript
        if (trimmed.Contains("import ") && trimmed.Contains("from "))
            return trimmed.Contains(": ") ? "typescript" : "javascript";
        if (trimmed.Contains("export default") || trimmed.Contains("export class"))
            return "javascript";

        // Python
        if (Regex.IsMatch(trimmed, @"^(def |class |import |from .+ import)"))
            return "python";

        // JSON
        if (trimmed.StartsWith('{') && trimmed.TrimEnd().EndsWith('}'))
            return "json";

        // XML/HTML
        if (trimmed.StartsWith("<?xml") || trimmed.StartsWith("<Project"))
            return "xml";
        if (trimmed.StartsWith("<!DOCTYPE html") || trimmed.StartsWith("<html"))
            return "html";

        // Shell commands
        if (trimmed.StartsWith("$ ") || trimmed.StartsWith("# ") && !trimmed.Contains('\n'))
            return "bash";

        return null;
    }

    private sealed record LanguageInfo(
        string Id,
        string DisplayName,
        string Extension,
        string[] Aliases,
        bool IsShell = false,
        bool IsConfig = false);
}
```

### Files to Create (v0.4.1c)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/ILanguageDetectionService.cs` | Language detection interface |
| `src/SeniorIntern.Services/LanguageDetectionService.cs` | Language detection implementation |

### Testing Strategy (v0.4.1c)

```csharp
public class LanguageDetectionServiceTests
{
    private readonly LanguageDetectionService _service = new();

    [Theory]
    [InlineData("csharp", "csharp", "C#")]
    [InlineData("cs", "csharp", "C#")]
    [InlineData("c#", "csharp", "C#")]
    [InlineData("typescript", "typescript", "TypeScript")]
    [InlineData("ts", "typescript", "TypeScript")]
    [InlineData("py", "python", "Python")]
    public void DetectLanguage_FromFence_ReturnsCorrectLanguage(
        string fence, string expectedId, string expectedDisplay)
    {
        var (lang, display) = _service.DetectLanguage(fence, "");

        Assert.Equal(expectedId, lang);
        Assert.Equal(expectedDisplay, display);
    }

    [Theory]
    [InlineData(".cs", "csharp")]
    [InlineData(".ts", "typescript")]
    [InlineData(".py", "python")]
    [InlineData(".axaml", "axaml")]
    public void GetLanguageForExtension_ReturnsCorrectLanguage(string ext, string expected)
    {
        Assert.Equal(expected, _service.GetLanguageForExtension(ext));
    }

    [Theory]
    [InlineData("bash", true)]
    [InlineData("powershell", true)]
    [InlineData("csharp", false)]
    public void IsShellLanguage_ReturnsCorrectValue(string lang, bool expected)
    {
        Assert.Equal(expected, _service.IsShellLanguage(lang));
    }

    [Fact]
    public void DetectLanguage_FromContent_DetectsCSharp()
    {
        var content = """
            using System;
            namespace Test
            {
                public class Foo { }
            }
            """;

        var (lang, _) = _service.DetectLanguage(null, content);
        Assert.Equal("csharp", lang);
    }
}
```

### Acceptance Criteria (v0.4.1c)

- [ ] Language aliases map to canonical IDs
- [ ] File extensions map to languages
- [ ] Content-based detection works for common languages
- [ ] Display names are user-friendly
- [ ] Shell and config languages are correctly identified
- [ ] Unknown languages return null gracefully

---

## v0.4.1d: Block Classification

### Objective
Classify code blocks as CompleteFile, Snippet, Example, Command, Output, or Config based on context and content analysis.

### IBlockClassificationService Interface

```csharp
// src/SeniorIntern.Core/Interfaces/IBlockClassificationService.cs
namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Service for classifying the type/purpose of a code block.
/// </summary>
public interface IBlockClassificationService
{
    /// <summary>
    /// Classify a code block based on its content and surrounding context.
    /// </summary>
    /// <param name="content">The code content.</param>
    /// <param name="language">Detected language (may be null).</param>
    /// <param name="surroundingText">Text before and after the code block.</param>
    /// <returns>The classified block type.</returns>
    CodeBlockType ClassifyBlock(string content, string? language, string surroundingText);

    /// <summary>
    /// Get the confidence score for a classification.
    /// </summary>
    float GetClassificationConfidence(CodeBlock block);
}
```

### BlockClassificationService Implementation

```csharp
// src/SeniorIntern.Services/BlockClassificationService.cs
namespace SeniorIntern.Services;

public sealed class BlockClassificationService : IBlockClassificationService
{
    private readonly ILanguageDetectionService _languageService;

    // Phrases that strongly suggest example/illustration code
    private static readonly string[] ExampleIndicators = new[]
    {
        "for example",
        "e.g.",
        "such as",
        "like this",
        "example:",
        "an example",
        "would look like",
        "something like",
        "here's an example",
        "consider the following",
        "suppose we have",
        "imagine",
        "let's say",
        "hypothetically",
        "for instance"
    };

    // Phrases that strongly suggest actionable/applicable code
    private static readonly string[] ApplyIndicators = new[]
    {
        "update",
        "modify",
        "change",
        "replace",
        "add this",
        "create",
        "here's the",
        "here is the",
        "updated version",
        "fixed version",
        "corrected",
        "the fix",
        "the solution",
        "should be",
        "needs to be",
        "change it to",
        "replace with",
        "use this instead"
    };

    // Phrases suggesting output/logs
    private static readonly string[] OutputIndicators = new[]
    {
        "output:",
        "result:",
        "returns:",
        "produces:",
        "will print",
        "will output",
        "you'll see",
        "the output is",
        "this prints"
    };

    public BlockClassificationService(ILanguageDetectionService languageService)
    {
        _languageService = languageService;
    }

    public CodeBlockType ClassifyBlock(
        string content,
        string? language,
        string surroundingText)
    {
        var lowerContext = surroundingText.ToLowerInvariant();
        var lowerContent = content.ToLowerInvariant();

        // 1. Check for shell/command language
        if (_languageService.IsShellLanguage(language))
        {
            return CodeBlockType.Command;
        }

        // 2. Check for config language
        if (_languageService.IsConfigLanguage(language))
        {
            return CodeBlockType.Config;
        }

        // 3. Check for output indicators
        if (OutputIndicators.Any(ind => lowerContext.Contains(ind)))
        {
            return CodeBlockType.Output;
        }

        // 4. Check for example indicators (strong signal)
        var exampleScore = CalculateIndicatorScore(lowerContext, ExampleIndicators);
        var applyScore = CalculateIndicatorScore(lowerContext, ApplyIndicators);

        if (exampleScore > applyScore && exampleScore > 0)
        {
            return CodeBlockType.Example;
        }

        // 5. Analyze content structure
        if (applyScore > 0 || HasCompleteFileStructure(content, language))
        {
            return CodeBlockType.CompleteFile;
        }

        // 6. Default to Snippet for partial code
        return CodeBlockType.Snippet;
    }

    public float GetClassificationConfidence(CodeBlock block)
    {
        // Higher confidence for explicit classifications
        return block.BlockType switch
        {
            CodeBlockType.Command => 0.95f, // Shell language is explicit
            CodeBlockType.Config => 0.90f,  // Config language is explicit
            CodeBlockType.Output => 0.85f,  // Output indicators are clear
            CodeBlockType.CompleteFile => 0.80f,
            CodeBlockType.Snippet => 0.70f,
            CodeBlockType.Example => 0.75f,
            _ => 0.50f
        };
    }

    private static int CalculateIndicatorScore(string text, string[] indicators)
    {
        return indicators.Count(ind => text.Contains(ind));
    }

    private bool HasCompleteFileStructure(string content, string? language)
    {
        if (string.IsNullOrEmpty(language))
            return false;

        var trimmed = content.Trim();
        var normalized = language.ToLowerInvariant();

        return normalized switch
        {
            "csharp" or "cs" =>
                (trimmed.Contains("namespace ") || trimmed.Contains("using "))
                && (trimmed.Contains("class ") || trimmed.Contains("interface ")
                    || trimmed.Contains("record ") || trimmed.Contains("struct ")),

            "javascript" or "js" or "typescript" or "ts" =>
                trimmed.Contains("import ") || trimmed.Contains("export ")
                || trimmed.Contains("module.exports"),

            "python" or "py" =>
                (trimmed.Contains("def ") || trimmed.Contains("class "))
                && (trimmed.Contains("import ") || trimmed.StartsWith("#!")),

            "java" =>
                trimmed.Contains("public class ") || trimmed.Contains("package "),

            "go" =>
                trimmed.Contains("package ") && trimmed.Contains("func "),

            "rust" =>
                (trimmed.Contains("fn ") || trimmed.Contains("struct "))
                && (trimmed.Contains("use ") || trimmed.Contains("mod ")),

            "xml" =>
                trimmed.StartsWith("<?xml") || trimmed.StartsWith("<Project")
                || trimmed.StartsWith("<configuration"),

            "json" =>
                trimmed.StartsWith('{') && trimmed.EndsWith('}'),

            "yaml" or "yml" =>
                trimmed.Contains(": ") && !trimmed.StartsWith('-'),

            _ => false
        };
    }
}
```

### Files to Create (v0.4.1d)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/IBlockClassificationService.cs` | Classification interface |
| `src/SeniorIntern.Services/BlockClassificationService.cs` | Classification implementation |

### Testing Strategy (v0.4.1d)

```csharp
public class BlockClassificationServiceTests
{
    [Fact]
    public void ClassifyBlock_ShellLanguage_ReturnsCommand()
    {
        var service = CreateService();
        var result = service.ClassifyBlock("npm install", "bash", "Run this command:");

        Assert.Equal(CodeBlockType.Command, result);
    }

    [Fact]
    public void ClassifyBlock_WithExampleContext_ReturnsExample()
    {
        var service = CreateService();
        var result = service.ClassifyBlock(
            "public class Foo { }",
            "csharp",
            "For example, you could do something like this:");

        Assert.Equal(CodeBlockType.Example, result);
    }

    [Fact]
    public void ClassifyBlock_WithApplyContext_ReturnsCompleteFile()
    {
        var service = CreateService();
        var content = """
            using System;
            namespace Test
            {
                public class User { }
            }
            """;
        var result = service.ClassifyBlock(
            content,
            "csharp",
            "Here's the updated version of the file:");

        Assert.Equal(CodeBlockType.CompleteFile, result);
    }

    [Fact]
    public void ClassifyBlock_WithOutputContext_ReturnsOutput()
    {
        var service = CreateService();
        var result = service.ClassifyBlock(
            "Hello, World!",
            "plaintext",
            "The output is:");

        Assert.Equal(CodeBlockType.Output, result);
    }
}
```

### Acceptance Criteria (v0.4.1d)

- [ ] Shell languages classified as Command
- [ ] Config languages classified as Config
- [ ] Example context phrases trigger Example classification
- [ ] Apply context phrases trigger CompleteFile/Snippet
- [ ] Complete file structures detected by language
- [ ] Classification confidence scores are reasonable

---

## v0.4.1e: File Path Inference

### Objective
Infer target file paths for code blocks based on attached context, content analysis, and conversation history.

### IFilePathInferenceService Interface

```csharp
// src/SeniorIntern.Core/Interfaces/IFilePathInferenceService.cs
namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Service for inferring target file paths for code blocks.
/// </summary>
public interface IFilePathInferenceService
{
    /// <summary>
    /// Attempt to infer the target file path for a code block.
    /// </summary>
    /// <param name="block">The code block to analyze.</param>
    /// <param name="attachedContext">Files attached to the conversation.</param>
    /// <returns>Inferred file path (relative to workspace) or null.</returns>
    string? InferTargetFilePath(CodeBlock block, IReadOnlyList<FileContext> attachedContext);

    /// <summary>
    /// Get confidence score for an inferred path.
    /// </summary>
    float GetConfidenceScore(CodeBlock block, string inferredPath);

    /// <summary>
    /// Extract potential file name from code content.
    /// </summary>
    string? InferFileNameFromContent(string content, string? language);

    /// <summary>
    /// Get the appropriate file extension for a language.
    /// </summary>
    string? GetExtensionForLanguage(string? language);
}
```

### FilePathInferenceService Implementation

```csharp
// src/SeniorIntern.Services/FilePathInferenceService.cs
namespace SeniorIntern.Services;

using System.Text.RegularExpressions;

public sealed partial class FilePathInferenceService : IFilePathInferenceService
{
    private readonly ILanguageDetectionService _languageService;

    public FilePathInferenceService(ILanguageDetectionService languageService)
    {
        _languageService = languageService;
    }

    public string? InferTargetFilePath(
        CodeBlock block,
        IReadOnlyList<FileContext> attachedContext)
    {
        // 1. Block already has explicit path
        if (!string.IsNullOrEmpty(block.TargetFilePath))
            return block.TargetFilePath;

        // 2. Single attached context - assume it's the target
        if (attachedContext.Count == 1)
            return attachedContext[0].FilePath;

        // 3. Match by language
        if (block.Language != null && attachedContext.Count > 0)
        {
            var matchingFile = FindByLanguage(block.Language, attachedContext);
            if (matchingFile != null)
                return matchingFile;
        }

        // 4. Match by inferred type name
        var inferredName = InferFileNameFromContent(block.Content, block.Language);
        if (!string.IsNullOrEmpty(inferredName) && attachedContext.Count > 0)
        {
            var matchingFile = FindByTypeName(inferredName, attachedContext);
            if (matchingFile != null)
                return matchingFile;
        }

        // 5. Build a suggested path from inferred name
        if (!string.IsNullOrEmpty(inferredName))
        {
            var ext = GetExtensionForLanguage(block.Language);
            if (!string.IsNullOrEmpty(ext))
            {
                return $"{inferredName}{ext}";
            }
        }

        return null;
    }

    public float GetConfidenceScore(CodeBlock block, string inferredPath)
    {
        // Explicit path in fence = highest confidence
        if (!string.IsNullOrEmpty(block.TargetFilePath)
            && block.TargetFilePath == inferredPath)
            return 1.0f;

        // Inferred from single context = high confidence
        // Inferred from language match = medium confidence
        // Inferred from content = lower confidence

        return 0.7f; // Default for inferred paths
    }

    public string? InferFileNameFromContent(string content, string? language)
    {
        if (string.IsNullOrEmpty(language))
            return null;

        var patterns = GetTypeNamePatterns(language);

        foreach (var pattern in patterns)
        {
            var match = Regex.Match(content, pattern);
            if (match.Success && match.Groups.Count > 1)
            {
                return match.Groups[1].Value;
            }
        }

        return null;
    }

    public string? GetExtensionForLanguage(string? language)
    {
        return _languageService.GetFileExtension(language ?? "");
    }

    private static string? FindByLanguage(
        string language,
        IReadOnlyList<FileContext> contexts)
    {
        // Find first file with matching language
        foreach (var ctx in contexts)
        {
            if (ctx.Language?.Equals(language, StringComparison.OrdinalIgnoreCase) == true)
            {
                return ctx.FilePath;
            }

            // Also check by extension
            var ext = Path.GetExtension(ctx.FilePath);
            if (MatchesLanguageExtension(language, ext))
            {
                return ctx.FilePath;
            }
        }
        return null;
    }

    private static string? FindByTypeName(
        string typeName,
        IReadOnlyList<FileContext> contexts)
    {
        foreach (var ctx in contexts)
        {
            var fileName = Path.GetFileNameWithoutExtension(ctx.FilePath);
            if (fileName.Equals(typeName, StringComparison.OrdinalIgnoreCase))
            {
                return ctx.FilePath;
            }
            if (fileName.Contains(typeName, StringComparison.OrdinalIgnoreCase))
            {
                return ctx.FilePath;
            }
        }
        return null;
    }

    private static bool MatchesLanguageExtension(string language, string extension)
    {
        var lang = language.ToLowerInvariant();
        var ext = extension.ToLowerInvariant();

        return (lang, ext) switch
        {
            ("csharp" or "cs", ".cs") => true,
            ("typescript" or "ts", ".ts" or ".tsx") => true,
            ("javascript" or "js", ".js" or ".jsx" or ".mjs") => true,
            ("python" or "py", ".py") => true,
            ("java", ".java") => true,
            ("go" or "golang", ".go") => true,
            ("rust" or "rs", ".rs") => true,
            _ => false
        };
    }

    private static string[] GetTypeNamePatterns(string language)
    {
        return language.ToLowerInvariant() switch
        {
            "csharp" or "cs" => new[]
            {
                @"(?:public|internal|private)?\s*(?:sealed|abstract|static|partial)?\s*(?:class|record|struct)\s+(\w+)",
                @"(?:public|internal)?\s*interface\s+(I\w+)",
                @"(?:public|internal)?\s*enum\s+(\w+)"
            },

            "typescript" or "ts" or "javascript" or "js" => new[]
            {
                @"(?:export\s+)?(?:default\s+)?class\s+(\w+)",
                @"(?:export\s+)?interface\s+(\w+)",
                @"(?:export\s+)?(?:async\s+)?function\s+(\w+)",
                @"(?:export\s+)?const\s+(\w+)\s*="
            },

            "python" or "py" => new[]
            {
                @"class\s+(\w+)\s*[:\(]",
                @"def\s+(\w+)\s*\("
            },

            "java" => new[]
            {
                @"(?:public|private|protected)?\s*(?:final|abstract)?\s*class\s+(\w+)",
                @"(?:public)?\s*interface\s+(\w+)",
                @"(?:public)?\s*enum\s+(\w+)"
            },

            "go" or "golang" => new[]
            {
                @"type\s+(\w+)\s+struct",
                @"type\s+(\w+)\s+interface",
                @"func\s+(\w+)\s*\("
            },

            "rust" or "rs" => new[]
            {
                @"(?:pub\s+)?struct\s+(\w+)",
                @"(?:pub\s+)?enum\s+(\w+)",
                @"(?:pub\s+)?trait\s+(\w+)",
                @"(?:pub\s+)?fn\s+(\w+)"
            },

            _ => Array.Empty<string>()
        };
    }
}
```

### Files to Create (v0.4.1e)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/IFilePathInferenceService.cs` | Inference interface |
| `src/SeniorIntern.Services/FilePathInferenceService.cs` | Inference implementation |

### Testing Strategy (v0.4.1e)

```csharp
public class FilePathInferenceServiceTests
{
    [Fact]
    public void InferTargetFilePath_WithSingleContext_ReturnsContextPath()
    {
        var service = CreateService();
        var block = new CodeBlock { Content = "class Foo { }", Language = "csharp" };
        var context = new[] { new FileContext { FilePath = "src/Bar.cs" } };

        var result = service.InferTargetFilePath(block, context);

        Assert.Equal("src/Bar.cs", result);
    }

    [Fact]
    public void InferTargetFilePath_MatchesByLanguage()
    {
        var service = CreateService();
        var block = new CodeBlock { Content = "class Foo { }", Language = "csharp" };
        var context = new[]
        {
            new FileContext { FilePath = "app.ts", Language = "typescript" },
            new FileContext { FilePath = "src/Model.cs", Language = "csharp" }
        };

        var result = service.InferTargetFilePath(block, context);

        Assert.Equal("src/Model.cs", result);
    }

    [Fact]
    public void InferFileNameFromContent_ExtractsCSharpClassName()
    {
        var service = CreateService();
        var content = "public class UserService { }";

        var result = service.InferFileNameFromContent(content, "csharp");

        Assert.Equal("UserService", result);
    }

    [Fact]
    public void InferFileNameFromContent_ExtractsTypeScriptInterface()
    {
        var service = CreateService();
        var content = "export interface IUserRepository { }";

        var result = service.InferFileNameFromContent(content, "typescript");

        Assert.Equal("IUserRepository", result);
    }
}
```

### Acceptance Criteria (v0.4.1e)

- [ ] Single attached context becomes target path
- [ ] Language matching finds correct file
- [ ] Type name extraction works for C#, TS, Python, Java, Go, Rust
- [ ] Confidence scores reflect inference quality
- [ ] File extensions correctly mapped from languages

---

## v0.4.1f: Streaming Parser

### Objective
Implement incremental parsing that can detect and extract code blocks during LLM token streaming, enabling early UI updates.

### IStreamingCodeBlockParser Interface

```csharp
// src/SeniorIntern.Core/Interfaces/IStreamingCodeBlockParser.cs
namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Parser that can extract code blocks incrementally during streaming.
/// </summary>
public interface IStreamingCodeBlockParser : IDisposable
{
    /// <summary>
    /// Current parsing state.
    /// </summary>
    StreamingParserState State { get; }

    /// <summary>
    /// Feed a token to the parser.
    /// </summary>
    void FeedToken(string token);

    /// <summary>
    /// Get any complete code blocks extracted so far.
    /// </summary>
    IReadOnlyList<CodeBlock> GetCompletedBlocks();

    /// <summary>
    /// Get the currently accumulating block (if inside a fence).
    /// </summary>
    PartialCodeBlock? GetCurrentBlock();

    /// <summary>
    /// Signal that streaming is complete.
    /// </summary>
    void Complete();

    /// <summary>
    /// Reset the parser state.
    /// </summary>
    void Reset(Guid messageId);

    /// <summary>
    /// Event raised when a new code block starts.
    /// </summary>
    event EventHandler<CodeBlockStartedEventArgs>? BlockStarted;

    /// <summary>
    /// Event raised when a code block is completed.
    /// </summary>
    event EventHandler<CodeBlockCompletedEventArgs>? BlockCompleted;

    /// <summary>
    /// Event raised when content is added to current block.
    /// </summary>
    event EventHandler<CodeBlockContentEventArgs>? ContentAdded;
}

public enum StreamingParserState
{
    /// <summary>
    /// Outside of any code block.
    /// </summary>
    Text,

    /// <summary>
    /// Just saw opening fence, may have language.
    /// </summary>
    FenceOpening,

    /// <summary>
    /// Inside code block content.
    /// </summary>
    CodeContent,

    /// <summary>
    /// Possibly at closing fence.
    /// </summary>
    FenceClosing
}

/// <summary>
/// Represents a partially parsed code block during streaming.
/// </summary>
public sealed class PartialCodeBlock
{
    public Guid Id { get; init; } = Guid.NewGuid();
    public Guid MessageId { get; init; }
    public int SequenceNumber { get; init; }
    public string? Language { get; set; }
    public string? TargetFilePath { get; set; }
    public StringBuilder Content { get; } = new();
    public int StartPosition { get; init; }
    public DateTime StartedAt { get; init; } = DateTime.UtcNow;

    public CodeBlock ToCodeBlock(int endPosition) => new()
    {
        Id = Id,
        MessageId = MessageId,
        SequenceNumber = SequenceNumber,
        Language = Language,
        TargetFilePath = TargetFilePath,
        Content = Content.ToString().Trim(),
        SourceRange = new TextRange(StartPosition, endPosition)
    };
}
```

### StreamingCodeBlockParser Implementation

```csharp
// src/SeniorIntern.Services/StreamingCodeBlockParser.cs
namespace SeniorIntern.Services;

public sealed class StreamingCodeBlockParser : IStreamingCodeBlockParser
{
    private readonly ILanguageDetectionService _languageService;
    private readonly IBlockClassificationService _classificationService;

    private Guid _messageId;
    private StringBuilder _buffer = new();
    private int _position;
    private int _blockSequence;
    private PartialCodeBlock? _currentBlock;
    private readonly List<CodeBlock> _completedBlocks = new();

    private const string FenceStart = "```";
    private const string FenceEnd = "```";

    public StreamingParserState State { get; private set; } = StreamingParserState.Text;

    public event EventHandler<CodeBlockStartedEventArgs>? BlockStarted;
    public event EventHandler<CodeBlockCompletedEventArgs>? BlockCompleted;
    public event EventHandler<CodeBlockContentEventArgs>? ContentAdded;

    public StreamingCodeBlockParser(
        ILanguageDetectionService languageService,
        IBlockClassificationService classificationService)
    {
        _languageService = languageService;
        _classificationService = classificationService;
    }

    public void FeedToken(string token)
    {
        foreach (var ch in token)
        {
            _buffer.Append(ch);
            _position++;
            ProcessCharacter(ch);
        }
    }

    private void ProcessCharacter(char ch)
    {
        switch (State)
        {
            case StreamingParserState.Text:
                CheckForFenceStart();
                break;

            case StreamingParserState.FenceOpening:
                if (ch == '\n')
                {
                    // End of opening fence line
                    CompleteFenceOpening();
                }
                break;

            case StreamingParserState.CodeContent:
                if (CheckForFenceEnd())
                {
                    CompleteCodeBlock();
                }
                else
                {
                    _currentBlock?.Content.Append(ch);
                    RaiseContentAdded(ch);
                }
                break;
        }
    }

    private void CheckForFenceStart()
    {
        var bufferStr = _buffer.ToString();
        var lastIndex = bufferStr.LastIndexOf(FenceStart, StringComparison.Ordinal);

        if (lastIndex >= 0 && lastIndex == bufferStr.Length - FenceStart.Length)
        {
            // We just completed a fence start
            State = StreamingParserState.FenceOpening;
            _currentBlock = new PartialCodeBlock
            {
                MessageId = _messageId,
                SequenceNumber = _blockSequence++,
                StartPosition = _position - FenceStart.Length
            };
        }
    }

    private void CompleteFenceOpening()
    {
        if (_currentBlock == null) return;

        // Parse the fence line for language and path
        var fenceLine = ExtractFenceLine();
        ParseFenceLine(fenceLine);

        State = StreamingParserState.CodeContent;
        BlockStarted?.Invoke(this, new CodeBlockStartedEventArgs
        {
            Block = _currentBlock,
            MessageId = _messageId
        });
    }

    private string ExtractFenceLine()
    {
        var bufferStr = _buffer.ToString();
        var fenceStart = bufferStr.LastIndexOf(FenceStart, StringComparison.Ordinal);
        if (fenceStart < 0) return string.Empty;

        var afterFence = bufferStr[(fenceStart + FenceStart.Length)..];
        var newlineIndex = afterFence.IndexOf('\n');
        return newlineIndex >= 0 ? afterFence[..newlineIndex] : afterFence;
    }

    private void ParseFenceLine(string fenceLine)
    {
        if (_currentBlock == null || string.IsNullOrEmpty(fenceLine))
            return;

        // Format: lang:path or just lang
        var colonIndex = fenceLine.IndexOf(':');
        if (colonIndex > 0)
        {
            var lang = fenceLine[..colonIndex].Trim();
            var path = fenceLine[(colonIndex + 1)..].Trim();

            var (normalizedLang, _) = _languageService.DetectLanguage(lang, "", path);
            _currentBlock.Language = normalizedLang;
            _currentBlock.TargetFilePath = path;
        }
        else
        {
            var (normalizedLang, _) = _languageService.DetectLanguage(fenceLine.Trim(), "", null);
            _currentBlock.Language = normalizedLang;
        }
    }

    private bool CheckForFenceEnd()
    {
        if (_currentBlock == null) return false;

        var content = _currentBlock.Content.ToString();
        if (content.EndsWith(FenceEnd))
        {
            // Remove the fence from content
            _currentBlock.Content.Remove(
                _currentBlock.Content.Length - FenceEnd.Length,
                FenceEnd.Length);
            return true;
        }
        return false;
    }

    private void CompleteCodeBlock()
    {
        if (_currentBlock == null) return;

        var block = _currentBlock.ToCodeBlock(_position);

        // Classify the block
        var surroundingText = GetSurroundingText(block.SourceRange.Start);
        block = block with
        {
            BlockType = _classificationService.ClassifyBlock(
                block.Content, block.Language, surroundingText)
        };

        _completedBlocks.Add(block);

        BlockCompleted?.Invoke(this, new CodeBlockCompletedEventArgs
        {
            Block = block,
            MessageId = _messageId
        });

        _currentBlock = null;
        State = StreamingParserState.Text;
    }

    private string GetSurroundingText(int position)
    {
        var bufferStr = _buffer.ToString();
        var start = Math.Max(0, position - 300);
        var length = Math.Min(400, bufferStr.Length - start);
        return bufferStr.Substring(start, length);
    }

    private void RaiseContentAdded(char ch)
    {
        ContentAdded?.Invoke(this, new CodeBlockContentEventArgs
        {
            Content = ch.ToString(),
            Block = _currentBlock!
        });
    }

    public IReadOnlyList<CodeBlock> GetCompletedBlocks() => _completedBlocks.AsReadOnly();

    public PartialCodeBlock? GetCurrentBlock() => _currentBlock;

    public void Complete()
    {
        // If we're still in a code block, complete it
        if (_currentBlock != null && State == StreamingParserState.CodeContent)
        {
            CompleteCodeBlock();
        }
    }

    public void Reset(Guid messageId)
    {
        _messageId = messageId;
        _buffer.Clear();
        _position = 0;
        _blockSequence = 0;
        _currentBlock = null;
        _completedBlocks.Clear();
        State = StreamingParserState.Text;
    }

    public void Dispose()
    {
        _buffer.Clear();
        _completedBlocks.Clear();
    }
}
```

### Streaming Events

```csharp
// Add to CodeBlockEvents.cs

public sealed class CodeBlockStartedEventArgs : EventArgs
{
    public required PartialCodeBlock Block { get; init; }
    public required Guid MessageId { get; init; }
}

public sealed class CodeBlockCompletedEventArgs : EventArgs
{
    public required CodeBlock Block { get; init; }
    public required Guid MessageId { get; init; }
}

public sealed class CodeBlockContentEventArgs : EventArgs
{
    public required string Content { get; init; }
    public required PartialCodeBlock Block { get; init; }
}
```

### Files to Create (v0.4.1f)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/IStreamingCodeBlockParser.cs` | Streaming parser interface |
| `src/SeniorIntern.Services/StreamingCodeBlockParser.cs` | Streaming parser implementation |

### Files to Modify (v0.4.1f)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Core/Events/CodeBlockEvents.cs` | Add streaming events |

### Testing Strategy (v0.4.1f)

```csharp
public class StreamingCodeBlockParserTests
{
    [Fact]
    public void FeedToken_DetectsBlockStart()
    {
        var parser = CreateParser();
        parser.Reset(Guid.NewGuid());

        bool started = false;
        parser.BlockStarted += (s, e) => started = true;

        parser.FeedToken("Here's code:\n```csharp\n");

        Assert.True(started);
        Assert.Equal(StreamingParserState.CodeContent, parser.State);
    }

    [Fact]
    public void FeedToken_AccumulatesContent()
    {
        var parser = CreateParser();
        parser.Reset(Guid.NewGuid());

        parser.FeedToken("```csharp\n");
        parser.FeedToken("public ");
        parser.FeedToken("class ");
        parser.FeedToken("Test { }");

        var current = parser.GetCurrentBlock();
        Assert.Equal("public class Test { }", current?.Content.ToString());
    }

    [Fact]
    public void FeedToken_CompletesBlock()
    {
        var parser = CreateParser();
        parser.Reset(Guid.NewGuid());

        CodeBlock? completed = null;
        parser.BlockCompleted += (s, e) => completed = e.Block;

        parser.FeedToken("```csharp\npublic class Test { }\n```");

        Assert.NotNull(completed);
        Assert.Equal("public class Test { }", completed.Content);
    }

    [Fact]
    public void FeedToken_ParsesLanguageAndPath()
    {
        var parser = CreateParser();
        parser.Reset(Guid.NewGuid());

        parser.FeedToken("```csharp:src/Test.cs\ncode\n```");

        var blocks = parser.GetCompletedBlocks();
        Assert.Single(blocks);
        Assert.Equal("csharp", blocks[0].Language);
        Assert.Equal("src/Test.cs", blocks[0].TargetFilePath);
    }
}
```

### Acceptance Criteria (v0.4.1f)

- [ ] Parser detects fence start during streaming
- [ ] Parser accumulates content correctly
- [ ] Parser detects fence end and completes block
- [ ] Events fire at appropriate times
- [ ] Language and path parsed from fence line
- [ ] Multiple blocks handled correctly
- [ ] Reset clears state properly

---

## v0.4.1g: ViewModel Integration

### Objective
Integrate code block parsing into ChatMessageViewModel and create CodeBlockViewModel for UI binding.

### CodeBlockViewModel

```csharp
// src/SeniorIntern.Desktop/ViewModels/CodeBlockViewModel.cs
namespace SeniorIntern.Desktop.ViewModels;

public partial class CodeBlockViewModel : ViewModelBase
{
    [ObservableProperty]
    private Guid _id;

    [ObservableProperty]
    private string _content = string.Empty;

    [ObservableProperty]
    private string? _language;

    [ObservableProperty]
    private string? _displayLanguage;

    [ObservableProperty]
    private string? _targetFilePath;

    [ObservableProperty]
    private CodeBlockType _blockType;

    [ObservableProperty]
    private CodeBlockStatus _status = CodeBlockStatus.Pending;

    [ObservableProperty]
    private float _confidenceScore = 1.0f;

    [ObservableProperty]
    private bool _isStreaming;

    [ObservableProperty]
    private int _lineCount;

    // Computed properties
    public bool IsApplicable =>
        BlockType is CodeBlockType.CompleteFile or CodeBlockType.Snippet
        && !string.IsNullOrEmpty(TargetFilePath);

    public bool IsExample => BlockType == CodeBlockType.Example;
    public bool IsCommand => BlockType == CodeBlockType.Command;
    public bool IsOutput => BlockType == CodeBlockType.Output;

    public bool ShowApplyButton => IsApplicable && Status == CodeBlockStatus.Pending;
    public bool ShowStatusBadge => Status != CodeBlockStatus.Pending;

    public string? FileName => !string.IsNullOrEmpty(TargetFilePath)
        ? Path.GetFileName(TargetFilePath)
        : null;

    public string StatusText => Status switch
    {
        CodeBlockStatus.Applied => "Applied",
        CodeBlockStatus.Rejected => "Rejected",
        CodeBlockStatus.Skipped => "Skipped",
        CodeBlockStatus.Conflict => "Conflict",
        CodeBlockStatus.Error => "Error",
        _ => ""
    };

    public CodeBlockViewModel() { }

    public CodeBlockViewModel(CodeBlock block)
    {
        Id = block.Id;
        Content = block.Content;
        Language = block.Language;
        DisplayLanguage = block.DisplayLanguage;
        TargetFilePath = block.TargetFilePath;
        BlockType = block.BlockType;
        Status = block.Status;
        ConfidenceScore = block.ConfidenceScore;
        LineCount = block.LineCount;
    }

    public CodeBlock ToModel() => new()
    {
        Id = Id,
        Content = Content,
        Language = Language,
        DisplayLanguage = DisplayLanguage,
        TargetFilePath = TargetFilePath,
        BlockType = BlockType,
        Status = Status,
        ConfidenceScore = ConfidenceScore
    };

    // Commands
    [RelayCommand]
    private void CopyToClipboard()
    {
        // Will be handled by parent view
    }

    [RelayCommand]
    private void ShowDiff()
    {
        // Will be handled by parent view
    }

    [RelayCommand]
    private void ApplyChanges()
    {
        // Will be handled by parent view
    }

    // Streaming support
    public void AppendContent(string token)
    {
        Content += token;
        LineCount = Content.Split('\n').Length;
    }

    public void CompleteStreaming()
    {
        IsStreaming = false;
    }
}
```

### Updated ChatMessageViewModel

```csharp
// Updates to src/SeniorIntern.Desktop/ViewModels/ChatMessageViewModel.cs
namespace SeniorIntern.Desktop.ViewModels;

public partial class ChatMessageViewModel : ViewModelBase
{
    // ... existing properties ...

    [ObservableProperty]
    private ObservableCollection<CodeBlockViewModel> _codeBlocks = new();

    [ObservableProperty]
    private bool _hasCodeBlocks;

    [ObservableProperty]
    private bool _hasApplicableCode;

    [ObservableProperty]
    private int _applicableBlockCount;

    [ObservableProperty]
    private int _totalBlockCount;

    // Computed
    public bool ShowCodeActions => HasApplicableCode && Role == MessageRole.Assistant;

    /// <summary>
    /// Parse code blocks from the message content.
    /// </summary>
    public void ParseCodeBlocks(ICodeBlockParserService parser, IReadOnlyList<FileContext>? context = null)
    {
        if (Role != MessageRole.Assistant || string.IsNullOrEmpty(Content))
            return;

        var proposal = parser.CreateProposal(Content, Id, context);

        CodeBlocks.Clear();
        foreach (var block in proposal.CodeBlocks)
        {
            CodeBlocks.Add(new CodeBlockViewModel(block));
        }

        UpdateCodeBlockStats();
    }

    /// <summary>
    /// Add a code block from streaming.
    /// </summary>
    public void AddCodeBlock(CodeBlock block)
    {
        CodeBlocks.Add(new CodeBlockViewModel(block) { IsStreaming = true });
        UpdateCodeBlockStats();
    }

    /// <summary>
    /// Get the currently streaming code block.
    /// </summary>
    public CodeBlockViewModel? GetStreamingBlock()
    {
        return CodeBlocks.FirstOrDefault(b => b.IsStreaming);
    }

    /// <summary>
    /// Complete streaming for the current block.
    /// </summary>
    public void CompleteCurrentBlock(CodeBlock finalBlock)
    {
        var streaming = GetStreamingBlock();
        if (streaming != null)
        {
            streaming.Content = finalBlock.Content;
            streaming.BlockType = finalBlock.BlockType;
            streaming.CompleteStreaming();
            UpdateCodeBlockStats();
        }
    }

    private void UpdateCodeBlockStats()
    {
        TotalBlockCount = CodeBlocks.Count;
        ApplicableBlockCount = CodeBlocks.Count(b => b.IsApplicable);
        HasCodeBlocks = TotalBlockCount > 0;
        HasApplicableCode = ApplicableBlockCount > 0;
    }

    // Commands for code blocks
    [RelayCommand]
    private async Task CopyCodeAsync(CodeBlockViewModel block)
    {
        var clipboard = TopLevel.GetTopLevel(null)?.Clipboard;
        if (clipboard != null)
        {
            await clipboard.SetTextAsync(block.Content);
        }
    }

    [RelayCommand]
    private void ShowDiff(CodeBlockViewModel block)
    {
        // Raise event or use messenger to show diff view
        // WeakReferenceMessenger.Default.Send(new ShowDiffMessage(block));
    }
}
```

### CodeProposalViewModel

```csharp
// src/SeniorIntern.Desktop/ViewModels/CodeProposalViewModel.cs
namespace SeniorIntern.Desktop.ViewModels;

/// <summary>
/// ViewModel for a complete code proposal containing multiple blocks.
/// </summary>
public partial class CodeProposalViewModel : ViewModelBase
{
    [ObservableProperty]
    private Guid _id;

    [ObservableProperty]
    private Guid _messageId;

    [ObservableProperty]
    private ObservableCollection<CodeBlockViewModel> _codeBlocks = new();

    [ObservableProperty]
    private ProposalStatus _status = ProposalStatus.Pending;

    public int ApplicableCount => CodeBlocks.Count(b => b.IsApplicable);
    public int AppliedCount => CodeBlocks.Count(b => b.Status == CodeBlockStatus.Applied);
    public int TotalCount => CodeBlocks.Count;

    public bool HasApplicableBlocks => ApplicableCount > 0;
    public bool IsFullyApplied => ApplicableCount > 0 && ApplicableCount == AppliedCount;
    public bool IsPartiallyApplied => AppliedCount > 0 && AppliedCount < ApplicableCount;

    public IEnumerable<string> AffectedFiles =>
        CodeBlocks
            .Where(b => !string.IsNullOrEmpty(b.TargetFilePath))
            .Select(b => b.TargetFilePath!)
            .Distinct();

    public CodeProposalViewModel() { }

    public CodeProposalViewModel(CodeProposal proposal)
    {
        Id = proposal.Id;
        MessageId = proposal.MessageId;
        Status = proposal.Status;

        foreach (var block in proposal.CodeBlocks)
        {
            CodeBlocks.Add(new CodeBlockViewModel(block));
        }
    }

    [RelayCommand]
    private void ApplyAll()
    {
        // Apply all applicable blocks
    }

    [RelayCommand]
    private void RejectAll()
    {
        Status = ProposalStatus.Rejected;
        foreach (var block in CodeBlocks.Where(b => b.IsApplicable))
        {
            block.Status = CodeBlockStatus.Rejected;
        }
    }
}
```

### Files to Create (v0.4.1g)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/ViewModels/CodeBlockViewModel.cs` | Code block ViewModel |
| `src/SeniorIntern.Desktop/ViewModels/CodeProposalViewModel.cs` | Proposal ViewModel |

### Files to Modify (v0.4.1g)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/ViewModels/ChatMessageViewModel.cs` | Add code block support |
| `src/SeniorIntern.Desktop/ViewModels/ChatViewModel.cs` | Wire up parsing |

### Acceptance Criteria (v0.4.1g)

- [ ] CodeBlockViewModel correctly binds all properties
- [ ] ChatMessageViewModel parses blocks on content change
- [ ] Streaming blocks update in real-time
- [ ] Block status changes propagate to UI
- [ ] Copy command works
- [ ] Statistics update correctly

---

## v0.4.1h: UI Rendering

### Objective
Create the visual representation of code blocks within chat messages, including syntax highlighting preview, action buttons, and status indicators.

### Code Block Styles

```xml
<!-- Add to src/SeniorIntern.Desktop/Themes/Dark.axaml -->

<!-- Code Block Container -->
<Style Selector="Border.code-block">
    <Setter Property="Background" Value="{DynamicResource CodeBlockBackground}" />
    <Setter Property="BorderBrush" Value="{DynamicResource CodeBlockBorder}" />
    <Setter Property="BorderThickness" Value="1" />
    <Setter Property="CornerRadius" Value="6" />
    <Setter Property="Margin" Value="0,8" />
</Style>

<Style Selector="Border.code-block.applicable">
    <Setter Property="BorderBrush" Value="{DynamicResource AccentBrush}" />
    <Setter Property="BorderThickness" Value="1,1,1,3" />
</Style>

<Style Selector="Border.code-block.example">
    <Setter Property="Opacity" Value="0.8" />
</Style>

<Style Selector="Border.code-block.command">
    <Setter Property="Background" Value="{DynamicResource CommandBlockBackground}" />
</Style>

<!-- Code Block Header -->
<Style Selector="Border.code-block-header">
    <Setter Property="Background" Value="{DynamicResource CodeBlockHeaderBackground}" />
    <Setter Property="Padding" Value="8,4" />
    <Setter Property="CornerRadius" Value="6,6,0,0" />
</Style>

<!-- Language Badge -->
<Style Selector="Border.language-badge">
    <Setter Property="Background" Value="{DynamicResource LanguageBadgeBackground}" />
    <Setter Property="CornerRadius" Value="3" />
    <Setter Property="Padding" Value="6,2" />
</Style>

<Style Selector="Border.language-badge TextBlock">
    <Setter Property="FontSize" Value="11" />
    <Setter Property="FontWeight" Value="SemiBold" />
    <Setter Property="Foreground" Value="{DynamicResource LanguageBadgeForeground}" />
</Style>

<!-- File Path -->
<Style Selector="TextBlock.file-path">
    <Setter Property="FontFamily" Value="Cascadia Code, Consolas, monospace" />
    <Setter Property="FontSize" Value="12" />
    <Setter Property="Foreground" Value="{DynamicResource TextMuted}" />
    <Setter Property="TextTrimming" Value="CharacterEllipsis" />
</Style>

<!-- Code Content -->
<Style Selector="Border.code-content">
    <Setter Property="Padding" Value="12,8" />
</Style>

<Style Selector="SelectableTextBlock.code-text">
    <Setter Property="FontFamily" Value="Cascadia Code, Consolas, monospace" />
    <Setter Property="FontSize" Value="13" />
    <Setter Property="Foreground" Value="{DynamicResource CodeForeground}" />
    <Setter Property="TextWrapping" Value="NoWrap" />
</Style>

<!-- Apply Button -->
<Style Selector="Button.apply-button">
    <Setter Property="Background" Value="{DynamicResource AccentBrush}" />
    <Setter Property="Foreground" Value="White" />
    <Setter Property="Padding" Value="8,4" />
    <Setter Property="CornerRadius" Value="4" />
    <Setter Property="FontSize" Value="12" />
</Style>

<Style Selector="Button.apply-button:pointerover">
    <Setter Property="Background" Value="{DynamicResource AccentBrushHover}" />
</Style>

<!-- Status Badge -->
<Style Selector="Border.status-badge">
    <Setter Property="CornerRadius" Value="3" />
    <Setter Property="Padding" Value="6,2" />
</Style>

<Style Selector="Border.status-badge.applied">
    <Setter Property="Background" Value="{DynamicResource SuccessBackground}" />
</Style>

<Style Selector="Border.status-badge.rejected">
    <Setter Property="Background" Value="{DynamicResource ErrorBackground}" />
</Style>

<Style Selector="Border.status-badge.conflict">
    <Setter Property="Background" Value="{DynamicResource WarningBackground}" />
</Style>

<!-- Color Resources -->
<Color x:Key="CodeBlockBackgroundColor">#1E1E1E</Color>
<Color x:Key="CodeBlockBorderColor">#3E3E3E</Color>
<Color x:Key="CodeBlockHeaderBackgroundColor">#252526</Color>
<Color x:Key="CommandBlockBackgroundColor">#1A1A2E</Color>
<Color x:Key="LanguageBadgeBackgroundColor">#0E639C</Color>
<Color x:Key="CodeForegroundColor">#D4D4D4</Color>

<SolidColorBrush x:Key="CodeBlockBackground" Color="{StaticResource CodeBlockBackgroundColor}" />
<SolidColorBrush x:Key="CodeBlockBorder" Color="{StaticResource CodeBlockBorderColor}" />
<SolidColorBrush x:Key="CodeBlockHeaderBackground" Color="{StaticResource CodeBlockHeaderBackgroundColor}" />
<SolidColorBrush x:Key="CommandBlockBackground" Color="{StaticResource CommandBlockBackgroundColor}" />
<SolidColorBrush x:Key="LanguageBadgeBackground" Color="{StaticResource LanguageBadgeBackgroundColor}" />
<SolidColorBrush x:Key="LanguageBadgeForeground" Color="White" />
<SolidColorBrush x:Key="CodeForeground" Color="{StaticResource CodeForegroundColor}" />
```

### CodeBlockControl

```xml
<!-- src/SeniorIntern.Desktop/Controls/CodeBlockControl.axaml -->
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:vm="using:SeniorIntern.Desktop.ViewModels"
             x:Class="SeniorIntern.Desktop.Controls.CodeBlockControl"
             x:DataType="vm:CodeBlockViewModel">

    <Border Classes="code-block"
            Classes.applicable="{Binding IsApplicable}"
            Classes.example="{Binding IsExample}"
            Classes.command="{Binding IsCommand}">

        <Grid RowDefinitions="Auto, *, Auto">
            <!-- Header -->
            <Border Grid.Row="0" Classes="code-block-header">
                <Grid ColumnDefinitions="Auto, Auto, *, Auto, Auto, Auto">
                    <!-- Language Badge -->
                    <Border Classes="language-badge"
                            IsVisible="{Binding DisplayLanguage, Converter={x:Static StringConverters.IsNotNullOrEmpty}}">
                        <TextBlock Text="{Binding DisplayLanguage}" />
                    </Border>

                    <!-- Block Type Indicator -->
                    <TextBlock Grid.Column="1"
                               Text="{Binding BlockType}"
                               Margin="8,0,0,0"
                               FontSize="10"
                               Foreground="{DynamicResource TextMuted}"
                               IsVisible="{Binding IsExample}" />

                    <!-- File Path -->
                    <TextBlock Grid.Column="2"
                               Text="{Binding TargetFilePath}"
                               Classes="file-path"
                               Margin="8,0"
                               VerticalAlignment="Center"
                               IsVisible="{Binding TargetFilePath, Converter={x:Static StringConverters.IsNotNullOrEmpty}}" />

                    <!-- Line Count -->
                    <TextBlock Grid.Column="3"
                               Text="{Binding LineCount, StringFormat='{}{0} lines'}"
                               FontSize="11"
                               Foreground="{DynamicResource TextMuted}"
                               VerticalAlignment="Center"
                               Margin="8,0" />

                    <!-- Copy Button -->
                    <Button Grid.Column="4"
                            Classes="icon-button"
                            Command="{Binding CopyToClipboardCommand}"
                            ToolTip.Tip="Copy code (Ctrl+C)">
                        <PathIcon Data="{StaticResource CopyIcon}" Width="14" Height="14" />
                    </Button>

                    <!-- Apply Button -->
                    <Button Grid.Column="5"
                            Classes="apply-button"
                            Command="{Binding ShowDiffCommand}"
                            IsVisible="{Binding ShowApplyButton}"
                            ToolTip.Tip="Review and apply changes"
                            Margin="4,0,0,0">
                        <StackPanel Orientation="Horizontal" Spacing="4">
                            <PathIcon Data="{StaticResource DiffIcon}" Width="12" Height="12" />
                            <TextBlock Text="Apply" />
                        </StackPanel>
                    </Button>
                </Grid>
            </Border>

            <!-- Code Content -->
            <Border Grid.Row="1" Classes="code-content">
                <ScrollViewer HorizontalScrollBarVisibility="Auto"
                              VerticalScrollBarVisibility="Auto"
                              MaxHeight="400">
                    <SelectableTextBlock Text="{Binding Content}"
                                         Classes="code-text" />
                </ScrollViewer>
            </Border>

            <!-- Status Footer -->
            <Border Grid.Row="2"
                    Padding="8,4"
                    IsVisible="{Binding ShowStatusBadge}">
                <StackPanel Orientation="Horizontal" Spacing="8">
                    <Border Classes="status-badge"
                            Classes.applied="{Binding Status, Converter={StaticResource EnumEqualsConverter}, ConverterParameter=Applied}"
                            Classes.rejected="{Binding Status, Converter={StaticResource EnumEqualsConverter}, ConverterParameter=Rejected}"
                            Classes.conflict="{Binding Status, Converter={StaticResource EnumEqualsConverter}, ConverterParameter=Conflict}">
                        <TextBlock Text="{Binding StatusText}"
                                   FontSize="11"
                                   FontWeight="SemiBold" />
                    </Border>
                </StackPanel>
            </Border>

            <!-- Streaming Indicator -->
            <Border Grid.Row="2"
                    Padding="8,4"
                    IsVisible="{Binding IsStreaming}">
                <StackPanel Orientation="Horizontal" Spacing="8">
                    <ProgressBar IsIndeterminate="True"
                                 Width="60"
                                 Height="3" />
                    <TextBlock Text="Receiving..."
                               FontSize="11"
                               Foreground="{DynamicResource TextMuted}" />
                </StackPanel>
            </Border>
        </Grid>
    </Border>
</UserControl>
```

### CodeBlockControl Code-Behind

```csharp
// src/SeniorIntern.Desktop/Controls/CodeBlockControl.axaml.cs
namespace SeniorIntern.Desktop.Controls;

public partial class CodeBlockControl : UserControl
{
    public CodeBlockControl()
    {
        InitializeComponent();
    }
}
```

### Update ChatMessageControl

```xml
<!-- Add to ChatMessageControl.axaml after the markdown content -->

<!-- Code Blocks Section -->
<ItemsControl ItemsSource="{Binding CodeBlocks}"
              IsVisible="{Binding HasCodeBlocks}"
              Margin="0,8,0,0">
    <ItemsControl.ItemTemplate>
        <DataTemplate DataType="{x:Type vm:CodeBlockViewModel}">
            <controls:CodeBlockControl />
        </DataTemplate>
    </ItemsControl.ItemTemplate>
</ItemsControl>

<!-- Code Block Summary (when multiple applicable) -->
<Border Classes="code-summary"
        IsVisible="{Binding HasApplicableCode}"
        Margin="0,8,0,0"
        Padding="12,8"
        Background="{DynamicResource SurfaceBackground}"
        CornerRadius="4">
    <Grid ColumnDefinitions="*, Auto">
        <StackPanel Orientation="Horizontal" Spacing="8">
            <PathIcon Data="{StaticResource CodeIcon}" Width="16" Height="16" />
            <TextBlock>
                <TextBlock.Text>
                    <MultiBinding StringFormat="{}{0} code block(s), {1} applicable">
                        <Binding Path="TotalBlockCount" />
                        <Binding Path="ApplicableBlockCount" />
                    </MultiBinding>
                </TextBlock.Text>
            </TextBlock>
        </StackPanel>

        <Button Grid.Column="1"
                Content="Apply All"
                Classes="secondary"
                IsVisible="{Binding ApplicableBlockCount, Converter={StaticResource GreaterThanOneConverter}}"
                Command="{Binding ApplyAllBlocksCommand}" />
    </Grid>
</Border>
```

### Converters

```csharp
// src/SeniorIntern.Desktop/Converters/CodeBlockConverters.cs
namespace SeniorIntern.Desktop.Converters;

public class IsApplicableBlockConverter : IValueConverter
{
    public object Convert(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        if (value is CodeBlockType blockType)
        {
            return blockType is CodeBlockType.CompleteFile or CodeBlockType.Snippet;
        }
        return false;
    }

    public object ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        throw new NotSupportedException();
    }
}

public class EnumEqualsConverter : IValueConverter
{
    public object Convert(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        if (value == null || parameter == null)
            return false;

        var paramString = parameter.ToString();
        var valueString = value.ToString();

        return string.Equals(paramString, valueString, StringComparison.OrdinalIgnoreCase);
    }

    public object ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        throw new NotSupportedException();
    }
}

public class GreaterThanOneConverter : IValueConverter
{
    public object Convert(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        if (value is int intValue)
            return intValue > 1;
        return false;
    }

    public object ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        throw new NotSupportedException();
    }
}
```

### Icon Resources

```xml
<!-- Add to App.axaml Resources -->
<StreamGeometry x:Key="CopyIcon">M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z</StreamGeometry>
<StreamGeometry x:Key="DiffIcon">M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zM4 12c0-4.42 3.58-8 8-8 1.85 0 3.55.63 4.9 1.69L5.69 16.9C4.63 15.55 4 13.85 4 12zm8 8c-1.85 0-3.55-.63-4.9-1.69L18.31 7.1C19.37 8.45 20 10.15 20 12c0 4.42-3.58 8-8 8z</StreamGeometry>
<StreamGeometry x:Key="CodeIcon">M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z</StreamGeometry>
```

### Files to Create (v0.4.1h)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/Controls/CodeBlockControl.axaml` | Code block UI control |
| `src/SeniorIntern.Desktop/Controls/CodeBlockControl.axaml.cs` | Code-behind |
| `src/SeniorIntern.Desktop/Converters/CodeBlockConverters.cs` | UI converters |

### Files to Modify (v0.4.1h)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/Themes/Dark.axaml` | Add code block styles and colors |
| `src/SeniorIntern.Desktop/Views/ChatMessageControl.axaml` | Add code block rendering |
| `src/SeniorIntern.Desktop/App.axaml` | Add icon resources |

### Testing Strategy (v0.4.1h)

- Visual verification of code block rendering
- Verify language badges display correctly
- Verify file paths truncate properly
- Verify Apply button shows only for applicable blocks
- Verify status badges change color correctly
- Verify streaming indicator animates
- Verify copy button copies to clipboard
- Test responsive layout at different widths

### Acceptance Criteria (v0.4.1h)

- [ ] Code blocks render with proper styling
- [ ] Language badges show correct display names
- [ ] File paths display and truncate correctly
- [ ] Apply button only visible for applicable blocks
- [ ] Status badges reflect current status with colors
- [ ] Streaming indicator shows during streaming
- [ ] Copy button works
- [ ] Code text is selectable
- [ ] Horizontal scroll for long lines
- [ ] Maximum height with vertical scroll

---

## Architecture Summary

### Component Diagram

```

                        ChatViewModel                             
         
   Message Stream  > StreamingCodeBlockParser            
        - FeedToken()                      
                           - BlockStarted event               
                           - BlockCompleted event             
                            
                                                                
                                        v                        
     
                ChatMessageViewModel                           
        
     ObservableCollection<CodeBlockViewModel>               
       - CodeBlockViewModel 1                               
       - CodeBlockViewModel 2                               
       - ...                                                
        
     



                     Services Layer                               

     
   CodeBlockParser       LanguageDetectionService            
   Service              - DetectLanguage()                 
    - ParseMessage()      - NormalizeLanguageId()            
    - CreateProposal()    - GetDisplayName()                 
     
                                                                 
           v                                                      
     
   BlockClassification   FilePathInferenceService            
   Service                - InferTargetFilePath()            
    - ClassifyBlock()     - InferFileNameFromContent()       
     

```

### Data Flow

```
1. LLM Response Stream
        
        v
2. StreamingCodeBlockParser.FeedToken()
        
        > BlockStarted event (partial block)
        
        > ContentAdded events (streaming content)
        
        > BlockCompleted event (final block)
                    
                    v
3. CodeBlockParserService.CreateProposal()
        
        > LanguageDetectionService.DetectLanguage()
        
        > BlockClassificationService.ClassifyBlock()
        
        > FilePathInferenceService.InferTargetFilePath()
                    
                    v
4. ChatMessageViewModel.CodeBlocks updated
        
        v
5. CodeBlockControl UI renders
```

---

## Files Summary

### Files to Create (Total: 14)

| File | Sub-Part |
|------|----------|
| `src/SeniorIntern.Core/Models/CodeBlock.cs` | v0.4.1a |
| `src/SeniorIntern.Core/Models/CodeBlockTypes.cs` | v0.4.1a |
| `src/SeniorIntern.Core/Models/CodeProposal.cs` | v0.4.1a |
| `src/SeniorIntern.Core/Interfaces/ICodeBlockParserService.cs` | v0.4.1b |
| `src/SeniorIntern.Core/Events/CodeBlockEvents.cs` | v0.4.1b |
| `src/SeniorIntern.Services/CodeBlockParserService.cs` | v0.4.1b |
| `src/SeniorIntern.Core/Interfaces/ILanguageDetectionService.cs` | v0.4.1c |
| `src/SeniorIntern.Services/LanguageDetectionService.cs` | v0.4.1c |
| `src/SeniorIntern.Core/Interfaces/IBlockClassificationService.cs` | v0.4.1d |
| `src/SeniorIntern.Services/BlockClassificationService.cs` | v0.4.1d |
| `src/SeniorIntern.Core/Interfaces/IFilePathInferenceService.cs` | v0.4.1e |
| `src/SeniorIntern.Services/FilePathInferenceService.cs` | v0.4.1e |
| `src/SeniorIntern.Core/Interfaces/IStreamingCodeBlockParser.cs` | v0.4.1f |
| `src/SeniorIntern.Services/StreamingCodeBlockParser.cs` | v0.4.1f |
| `src/SeniorIntern.Desktop/ViewModels/CodeBlockViewModel.cs` | v0.4.1g |
| `src/SeniorIntern.Desktop/ViewModels/CodeProposalViewModel.cs` | v0.4.1g |
| `src/SeniorIntern.Desktop/Controls/CodeBlockControl.axaml` | v0.4.1h |
| `src/SeniorIntern.Desktop/Controls/CodeBlockControl.axaml.cs` | v0.4.1h |
| `src/SeniorIntern.Desktop/Converters/CodeBlockConverters.cs` | v0.4.1h |

### Files to Modify (Total: 7)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Services/SeniorIntern.Services.csproj` | Enable regex source generators |
| `src/SeniorIntern.Desktop/Extensions/ServiceCollectionExtensions.cs` | Register all new services |
| `src/SeniorIntern.Desktop/ViewModels/ChatMessageViewModel.cs` | Add code block support |
| `src/SeniorIntern.Desktop/ViewModels/ChatViewModel.cs` | Wire up parsing during streaming |
| `src/SeniorIntern.Desktop/Themes/Dark.axaml` | Add code block styles |
| `src/SeniorIntern.Desktop/Views/ChatMessageControl.axaml` | Add code block rendering |
| `src/SeniorIntern.Desktop/App.axaml` | Add icon resources and converters |

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Regex parsing edge cases | Medium | Medium | Comprehensive test suite with edge cases |
| Language detection false positives | Low | Low | Confidence scoring, fallback to null |
| Streaming parser state corruption | Medium | High | Thorough state machine testing, reset capability |
| Performance with many code blocks | Low | Medium | Virtualization if needed, lazy parsing |
| UI thread blocking during parsing | Low | Medium | Parse on background thread, marshal to UI |

---

## Acceptance Criteria (Complete v0.4.1)

- [ ] Code blocks extracted from standard markdown fences
- [ ] Code blocks extracted from `\`\`\`lang:path` syntax
- [ ] File paths extracted from first-line comments
- [ ] Language detection works for 20+ languages
- [ ] Block classification accurate for examples vs applicable code
- [ ] File path inference works with attached context
- [ ] Streaming parsing detects blocks during generation
- [ ] ViewModels correctly bind to UI
- [ ] Code blocks render with proper styling
- [ ] Copy button copies code to clipboard
- [ ] Apply button visible only for applicable blocks
- [ ] Status badges reflect current state
- [ ] All unit tests pass
- [ ] Integration with ChatViewModel complete

---

## References

- [v0.4.0 Code Generation & Diffing](v0.4.0-code-generation-diffing.md) - Parent specification
- [v0.3.4 Context Attachment](v0.3.4-context-attachment.md) - FileContext model
- [CommonMark Specification](https://spec.commonmark.org/) - Markdown parsing reference
- [TextMate Language Grammars](https://macromates.com/manual/en/language_grammars) - Language identification
