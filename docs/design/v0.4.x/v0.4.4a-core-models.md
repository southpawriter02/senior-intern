# v0.4.4a: Core Models - Design Specification

**Status**: _IMPLEMENTED_

## Executive Summary

This specification details the **Core Models** for The Senior Intern's Multi-File Creation system, defining the data structures that represent file tree proposals, file operations, batch apply results, validation outcomes, and progress tracking. These models form the foundation for the entire v0.4.4 sub-system, establishing contracts used by the parser, proposal service, ViewModels, and UI components.

### Key Deliverables

| Component | Type | Purpose |
|-----------|------|---------|
| `FileTreeProposal` | Class | Represents a proposal to create multiple files |
| `FileTreeProposalStatus` | Enum | Status of the overall proposal |
| `FileOperation` | Class | Single file operation within a proposal |
| `FileOperationType` | Enum | Type of file operation (Create, Modify, etc.) |
| `FileOperationStatus` | Enum | Status of an individual operation |
| `BatchApplyResult` | Class | Result of applying a batch of operations |
| `BatchApplyProgress` | Class | Progress information during batch apply |
| `BatchApplyPhase` | Enum | Phase of batch apply operation |
| `ProposalValidationResult` | Class | Result of validating a proposal |
| `ValidationIssue` | Class | Individual validation issue |
| `ValidationIssueType` | Enum | Type of validation issue |
| `ValidationSeverity` | Enum | Severity of validation issue |

---

## Feature Overview

```
v0.4.4a: Core Models
├── Proposal Models
│   ├── FileTreeProposal
│   │   ├── Id (Guid, unique identifier)
│   │   ├── MessageId (source message reference)
│   │   ├── CreatedAt (timestamp)
│   │   ├── RootPath (common directory root)
│   │   ├── Operations (IReadOnlyList<FileOperation>)
│   │   ├── Description (LLM-extracted summary)
│   │   ├── RawTreeText (ASCII tree if detected)
│   │   ├── Status (FileTreeProposalStatus)
│   │   ├── Computed Properties
│   │   │   ├── FileCount, ModifyCount
│   │   │   ├── Directories, DirectoryCount
│   │   │   ├── SelectedOperations, SelectedCount
│   │   │   ├── HasSelectedOperations
│   │   │   └── TotalSizeBytes
│   │   └── Query Methods
│   │       ├── ContainsPath(string)
│   │       └── GetOperation(string)
│   └── FileTreeProposalStatus (6 values)
│       ├── Pending, PartiallyApplied, FullyApplied
│       └── Rejected, Cancelled, Invalid
├── Operation Models
│   ├── FileOperation
│   │   ├── Id (Guid, unique identifier)
│   │   ├── Path (relative file path)
│   │   ├── Type (FileOperationType)
│   │   ├── Content (file contents)
│   │   ├── CodeBlockId (source block reference)
│   │   ├── Language, DisplayLanguage
│   │   ├── IsSelected (for batch selection)
│   │   ├── Status (FileOperationStatus)
│   │   ├── ErrorMessage (if failed)
│   │   ├── NewPath (for rename/move)
│   │   ├── Order (dependency sequence)
│   │   ├── Computed Properties
│   │   │   ├── FileName, Directory, Extension
│   │   │   ├── ContentSizeBytes, LineCount
│   │   │   └── CanApply
│   │   └── Factory Methods
│   │       └── FromCodeBlock(CodeBlock, int)
│   ├── FileOperationType (7 values)
│   │   ├── Create, Modify, Delete
│   │   ├── Rename, Move, CreateDirectory
│   │   └── Unknown
│   └── FileOperationStatus (6 values)
│       ├── Pending, Applied, Skipped
│       └── Failed, Conflict, InProgress
├── Result Models
│   ├── BatchApplyResult
│   │   ├── AllSucceeded (bool)
│   │   ├── SuccessCount, FailedCount, SkippedCount
│   │   ├── TotalCount (computed)
│   │   ├── Results (IReadOnlyList<ApplyResult>)
│   │   ├── FailedResults, SucceededResults (filtered)
│   │   ├── StartedAt, CompletedAt, Duration
│   │   ├── BackupPaths (for undo)
│   │   ├── CanUndoAll (bool)
│   │   └── Factory Methods
│   │       └── Success(results, startedAt)
│   ├── BatchApplyProgress
│   │   ├── TotalOperations, CompletedOperations
│   │   ├── CurrentFile (path being processed)
│   │   ├── CurrentOperation (FileOperationType)
│   │   ├── ProgressPercent (computed 0-100)
│   │   ├── EstimatedRemaining (TimeSpan?)
│   │   ├── Phase (BatchApplyPhase)
│   │   └── CanCancel (bool)
│   └── BatchApplyPhase (7 values)
│       ├── Validating, CreatingBackups
│       ├── CreatingDirectories, WritingFiles
│       ├── Finalizing, Completed
│       └── RollingBack
└── Validation Models
    ├── ProposalValidationResult
    │   ├── IsValid (bool)
    │   ├── Issues (IReadOnlyList<ValidationIssue>)
    │   ├── Errors, Warnings (filtered)
    │   ├── HasErrors, HasWarnings (bool)
    │   └── Factory Methods
    │       ├── Valid()
    │       └── Invalid(params ValidationIssue[])
    ├── ValidationIssue
    │   ├── OperationId (affected operation)
    │   ├── Path (affected file)
    │   ├── Type (ValidationIssueType)
    │   ├── Severity (ValidationSeverity)
    │   ├── Message (human-readable)
    │   └── SuggestedFix (optional)
    ├── ValidationIssueType (11 values)
    │   ├── FileExists, DirectoryExists
    │   ├── InvalidPath, PermissionDenied
    │   ├── ParentNotExists, PathTooLong
    │   ├── InvalidCharacters, CircularDependency
    │   ├── DuplicatePath, EmptyContent
    │   └── OutsideWorkspace
    └── ValidationSeverity (3 values)
        └── Info, Warning, Error
```

---

## Architecture Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              Model Layer                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │                        FileTreeProposal                                │  │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐   │  │
│  │  │     Id      │  │  MessageId  │  │  CreatedAt  │  │  RootPath   │   │  │
│  │  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘   │  │
│  │  ┌─────────────────────────────────────────────────────────────────┐  │  │
│  │  │                    Operations: List<FileOperation>               │  │  │
│  │  └─────────────────────────────────────────────────────────────────┘  │  │
│  │  ┌─────────────┐  ┌─────────────┐  ┌────────────────────────────────┐ │  │
│  │  │ Description │  │ RawTreeText │  │ Status: FileTreeProposalStatus │ │  │
│  │  └─────────────┘  └─────────────┘  └────────────────────────────────┘ │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                    │                                         │
│                                    ▼                                         │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │                          FileOperation                                 │  │
│  │  ┌──────┐  ┌──────┐  ┌──────────────────────┐  ┌─────────────────┐    │  │
│  │  │  Id  │  │ Path │  │ Type: FileOpType     │  │ Content: string │    │  │
│  │  └──────┘  └──────┘  └──────────────────────┘  └─────────────────┘    │  │
│  │  ┌───────────┐  ┌──────────┐  ┌──────────┐  ┌──────────────────────┐  │  │
│  │  │CodeBlockId│  │ Language │  │IsSelected│  │Status: FileOpStatus │  │  │
│  │  └───────────┘  └──────────┘  └──────────┘  └──────────────────────┘  │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
├─────────────────────────────────────────────────────────────────────────────┤
│                              Result Models                                   │
│  ┌─────────────────────────────┐  ┌─────────────────────────────────────┐   │
│  │      BatchApplyResult       │  │        BatchApplyProgress           │   │
│  │  ┌───────────────────────┐  │  │  ┌────────────────────────────────┐ │   │
│  │  │ AllSucceeded: bool    │  │  │  │ TotalOperations: int           │ │   │
│  │  │ SuccessCount: int     │  │  │  │ CompletedOperations: int       │ │   │
│  │  │ FailedCount: int      │  │  │  │ CurrentFile: string            │ │   │
│  │  │ Results: ApplyResult[]│  │  │  │ Phase: BatchApplyPhase         │ │   │
│  │  │ BackupPaths: string[] │  │  │  │ ProgressPercent: double        │ │   │
│  │  │ Duration: TimeSpan    │  │  │  │ CanCancel: bool                │ │   │
│  │  └───────────────────────┘  │  │  └────────────────────────────────┘ │   │
│  └─────────────────────────────┘  └─────────────────────────────────────┘   │
│                                                                             │
├─────────────────────────────────────────────────────────────────────────────┤
│                            Validation Models                                 │
│  ┌─────────────────────────────┐  ┌─────────────────────────────────────┐   │
│  │  ProposalValidationResult   │  │         ValidationIssue             │   │
│  │  ┌───────────────────────┐  │  │  ┌────────────────────────────────┐ │   │
│  │  │ IsValid: bool         │  │  │  │ OperationId: Guid?             │ │   │
│  │  │ Issues: List<Issue>   │  │  │  │ Path: string                   │ │   │
│  │  │ Errors (filtered)     │  │  │  │ Type: ValidationIssueType      │ │   │
│  │  │ Warnings (filtered)   │  │  │  │ Severity: ValidationSeverity   │ │   │
│  │  └───────────────────────┘  │  │  │ Message: string                │ │   │
│  └─────────────────────────────┘  │  │ SuggestedFix: string?          │ │   │
│                                   │  └────────────────────────────────┘ │   │
│                                   └─────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Relationship Diagram

```
                                 ┌─────────────────┐
                                 │   ChatMessage   │
                                 │  (from v0.3.x)  │
                                 └────────┬────────┘
                                          │ MessageId
                                          ▼
┌──────────────────────────────────────────────────────────────────────────────┐
│                              FileTreeProposal                                 │
│                                                                              │
│  Id ─────────────────────────────────────────────────────────────────────┐   │
│  MessageId ←───────────────────────────────────────────────────────────┐ │   │
│  Status: FileTreeProposalStatus                                        │ │   │
│                                                                        │ │   │
│  Operations: IReadOnlyList<FileOperation> ─────────────────────────┐   │ │   │
│                                                                    │   │ │   │
└────────────────────────────────────────────────────────────────────┼───┼─┼───┘
                                                                     │   │ │
     ┌───────────────────────────────────────────────────────────────┘   │ │
     │                                                                   │ │
     ▼                                                                   │ │
┌────────────────────────────────────────────┐                           │ │
│              FileOperation                  │                           │ │
│                                            │                           │ │
│  Id ──────────────────────────────────────────────────────────────┐    │ │
│  Path: string                              │                      │    │ │
│  Type: FileOperationType                   │                      │    │ │
│  Content: string?                          │                      │    │ │
│  CodeBlockId ──────────────────────────────┼───┐                  │    │ │
│  IsSelected: bool                          │   │                  │    │ │
│  Status: FileOperationStatus               │   │                  │    │ │
│  Order: int                                │   │                  │    │ │
└────────────────────────────────────────────┘   │                  │    │ │
                                                 │                  │    │ │
                                                 ▼                  │    │ │
                                         ┌─────────────┐            │    │ │
                                         │  CodeBlock  │            │    │ │
                                         │ (from 0.4.1)│            │    │ │
                                         └─────────────┘            │    │ │
                                                                    │    │ │
┌──────────────────────────────────────────────────────────────┐    │    │ │
│                    ProposalValidationResult                   │    │    │ │
│                                                              │    │    │ │
│  IsValid: bool                                               │    │    │ │
│  Issues: IReadOnlyList<ValidationIssue> ──────────────────┐  │    │    │ │
│                                                           │  │    │    │ │
└───────────────────────────────────────────────────────────┼──┘    │    │ │
                                                            │       │    │ │
     ┌──────────────────────────────────────────────────────┘       │    │ │
     │                                                              │    │ │
     ▼                                                              │    │ │
┌────────────────────────────────────────────┐                      │    │ │
│              ValidationIssue                │                      │    │ │
│                                            │                      │    │ │
│  OperationId: Guid? ───────────────────────┼──────────────────────┘    │ │
│  Path: string                              │                           │ │
│  Type: ValidationIssueType                 │                           │ │
│  Severity: ValidationSeverity              │                           │ │
│  Message: string                           │                           │ │
└────────────────────────────────────────────┘                           │ │
                                                                         │ │
┌──────────────────────────────────────────────────────────────────┐     │ │
│                       BatchApplyResult                            │     │ │
│                                                                  │     │ │
│  AllSucceeded: bool                                              │     │ │
│  Results: IReadOnlyList<ApplyResult> ────────────────────────────┼─────┘ │
│  BackupPaths: IReadOnlyList<string>                              │       │
│                                                                  │       │
└──────────────────────────────────────────────────────────────────┘       │
                          │                                                │
                          ▼                                                │
                  ┌─────────────┐                                          │
                  │ ApplyResult │                                          │
                  │(from v0.4.3)│ ─────────────────────────────────────────┘
                  └─────────────┘
```

---

## Detailed Design

### 1. FileTreeProposal Model

The `FileTreeProposal` is the root model representing a complete multi-file creation proposal extracted from an LLM response.

```csharp
// src/SeniorIntern.Core/Models/FileTreeProposal.cs
namespace SeniorIntern.Core.Models;

using System.Text;

/// <summary>
/// Represents a proposal to create multiple files and directories.
/// This is the root model for multi-file creation proposals extracted
/// from LLM responses containing multiple code blocks with file paths.
/// </summary>
public sealed class FileTreeProposal
{
    #region Identity Properties

    /// <summary>
    /// Unique identifier for this proposal.
    /// </summary>
    public Guid Id { get; init; } = Guid.NewGuid();

    /// <summary>
    /// ID of the ChatMessage that generated this proposal.
    /// Used to link back to the source message for context.
    /// </summary>
    public Guid MessageId { get; init; }

    /// <summary>
    /// When this proposal was created (UTC).
    /// </summary>
    public DateTime CreatedAt { get; init; } = DateTime.UtcNow;

    #endregion

    #region Structure Properties

    /// <summary>
    /// Root directory for the proposal (relative to workspace).
    /// Computed as the common path prefix of all operations.
    /// May be empty if files span multiple root directories.
    /// </summary>
    /// <example>
    /// For operations: ["src/Models/User.cs", "src/Services/UserService.cs"]
    /// RootPath would be: "src"
    /// </example>
    public string RootPath { get; init; } = string.Empty;

    /// <summary>
    /// All proposed file operations in dependency order.
    /// Order is determined by the Order property of each FileOperation.
    /// </summary>
    public IReadOnlyList<FileOperation> Operations { get; init; } = Array.Empty<FileOperation>();

    /// <summary>
    /// Summary description extracted from the LLM response.
    /// Typically the text immediately preceding the file tree or code blocks.
    /// </summary>
    /// <example>
    /// "Here's a complete user authentication module with the following structure:"
    /// </example>
    public string? Description { get; set; }

    /// <summary>
    /// The raw file tree text if detected (e.g., ASCII tree representation).
    /// Preserved for display purposes and potential re-parsing.
    /// </summary>
    /// <example>
    /// src/
    /// ├── Models/
    /// │   └── User.cs
    /// └── Services/
    ///     └── UserService.cs
    /// </example>
    public string? RawTreeText { get; init; }

    #endregion

    #region Status Properties

    /// <summary>
    /// Status of the overall proposal.
    /// Tracks whether operations have been applied, rejected, etc.
    /// </summary>
    public FileTreeProposalStatus Status { get; set; } = FileTreeProposalStatus.Pending;

    #endregion

    #region Computed Properties - Counts

    /// <summary>
    /// Total files to create (operations with Type == Create).
    /// </summary>
    public int FileCount => Operations.Count(o => o.Type == FileOperationType.Create);

    /// <summary>
    /// Total files to modify (operations with Type == Modify).
    /// </summary>
    public int ModifyCount => Operations.Count(o => o.Type == FileOperationType.Modify);

    /// <summary>
    /// Total files to delete (operations with Type == Delete).
    /// </summary>
    public int DeleteCount => Operations.Count(o => o.Type == FileOperationType.Delete);

    /// <summary>
    /// Total rename operations.
    /// </summary>
    public int RenameCount => Operations.Count(o => o.Type == FileOperationType.Rename);

    /// <summary>
    /// Unique directories that will be created.
    /// Extracted from Create operation paths.
    /// </summary>
    public IEnumerable<string> Directories => Operations
        .Where(o => o.Type == FileOperationType.Create)
        .Select(o => Path.GetDirectoryName(o.Path))
        .Where(d => !string.IsNullOrEmpty(d))
        .Distinct()!;

    /// <summary>
    /// Total unique directories to create.
    /// </summary>
    public int DirectoryCount => Directories.Count();

    #endregion

    #region Computed Properties - Selection

    /// <summary>
    /// Operations currently selected for apply.
    /// Users can toggle selection in the UI.
    /// </summary>
    public IEnumerable<FileOperation> SelectedOperations =>
        Operations.Where(o => o.IsSelected);

    /// <summary>
    /// Count of selected operations.
    /// </summary>
    public int SelectedCount => SelectedOperations.Count();

    /// <summary>
    /// Whether any operations are selected for apply.
    /// </summary>
    public bool HasSelectedOperations => SelectedCount > 0;

    /// <summary>
    /// Whether all operations are selected.
    /// </summary>
    public bool AllSelected => SelectedCount == Operations.Count;

    #endregion

    #region Computed Properties - Size

    /// <summary>
    /// Total estimated size of all files to create (in bytes).
    /// Calculated as UTF-8 byte count of all operation content.
    /// </summary>
    public long TotalSizeBytes => Operations
        .Where(o => o.Content != null)
        .Sum(o => Encoding.UTF8.GetByteCount(o.Content!));

    /// <summary>
    /// Human-readable total size (e.g., "12.5 KB").
    /// </summary>
    public string TotalSizeFormatted => FormatBytes(TotalSizeBytes);

    /// <summary>
    /// Total line count across all operations.
    /// </summary>
    public int TotalLineCount => Operations
        .Where(o => o.Content != null)
        .Sum(o => o.LineCount);

    #endregion

    #region Query Methods

    /// <summary>
    /// Check if a specific path is included in this proposal.
    /// </summary>
    /// <param name="path">The path to check (case-insensitive).</param>
    /// <returns>True if an operation exists for this path.</returns>
    public bool ContainsPath(string path) =>
        Operations.Any(o => o.Path.Equals(path, StringComparison.OrdinalIgnoreCase));

    /// <summary>
    /// Get operation by path.
    /// </summary>
    /// <param name="path">The path to find (case-insensitive).</param>
    /// <returns>The operation, or null if not found.</returns>
    public FileOperation? GetOperation(string path) =>
        Operations.FirstOrDefault(o => o.Path.Equals(path, StringComparison.OrdinalIgnoreCase));

    /// <summary>
    /// Get operation by ID.
    /// </summary>
    /// <param name="id">The operation ID.</param>
    /// <returns>The operation, or null if not found.</returns>
    public FileOperation? GetOperationById(Guid id) =>
        Operations.FirstOrDefault(o => o.Id == id);

    /// <summary>
    /// Get all operations for a specific directory.
    /// </summary>
    /// <param name="directory">The directory path.</param>
    /// <returns>Operations within that directory.</returns>
    public IEnumerable<FileOperation> GetOperationsInDirectory(string directory) =>
        Operations.Where(o =>
            o.Directory?.Equals(directory, StringComparison.OrdinalIgnoreCase) == true);

    /// <summary>
    /// Get operations by type.
    /// </summary>
    /// <param name="type">The operation type to filter by.</param>
    /// <returns>Operations of the specified type.</returns>
    public IEnumerable<FileOperation> GetOperationsByType(FileOperationType type) =>
        Operations.Where(o => o.Type == type);

    /// <summary>
    /// Get operations that have not been applied yet.
    /// </summary>
    public IEnumerable<FileOperation> PendingOperations =>
        Operations.Where(o => o.Status == FileOperationStatus.Pending);

    /// <summary>
    /// Get operations that have been applied.
    /// </summary>
    public IEnumerable<FileOperation> AppliedOperations =>
        Operations.Where(o => o.Status == FileOperationStatus.Applied);

    /// <summary>
    /// Get operations that failed.
    /// </summary>
    public IEnumerable<FileOperation> FailedOperations =>
        Operations.Where(o => o.Status == FileOperationStatus.Failed);

    #endregion

    #region Selection Methods

    /// <summary>
    /// Select all operations.
    /// </summary>
    public void SelectAll()
    {
        foreach (var op in Operations)
        {
            op.IsSelected = true;
        }
    }

    /// <summary>
    /// Deselect all operations.
    /// </summary>
    public void DeselectAll()
    {
        foreach (var op in Operations)
        {
            op.IsSelected = false;
        }
    }

    /// <summary>
    /// Toggle selection for a specific operation.
    /// </summary>
    /// <param name="operationId">The operation ID to toggle.</param>
    public void ToggleSelection(Guid operationId)
    {
        var op = GetOperationById(operationId);
        if (op != null)
        {
            op.IsSelected = !op.IsSelected;
        }
    }

    /// <summary>
    /// Select operations by type.
    /// </summary>
    /// <param name="type">The operation type to select.</param>
    public void SelectByType(FileOperationType type)
    {
        foreach (var op in Operations.Where(o => o.Type == type))
        {
            op.IsSelected = true;
        }
    }

    #endregion

    #region Helper Methods

    /// <summary>
    /// Format bytes as human-readable string.
    /// </summary>
    private static string FormatBytes(long bytes)
    {
        string[] sizes = { "B", "KB", "MB", "GB" };
        int order = 0;
        double size = bytes;

        while (size >= 1024 && order < sizes.Length - 1)
        {
            order++;
            size /= 1024;
        }

        return $"{size:0.##} {sizes[order]}";
    }

    #endregion
}

/// <summary>
/// Status of a file tree proposal lifecycle.
/// </summary>
public enum FileTreeProposalStatus
{
    /// <summary>
    /// No operations have been applied yet.
    /// Initial state after proposal detection.
    /// </summary>
    Pending,

    /// <summary>
    /// Some operations have been applied.
    /// User may have selected a subset of operations.
    /// </summary>
    PartiallyApplied,

    /// <summary>
    /// All selected operations have been applied successfully.
    /// Terminal success state.
    /// </summary>
    FullyApplied,

    /// <summary>
    /// User explicitly rejected the proposal.
    /// Terminal failure state.
    /// </summary>
    Rejected,

    /// <summary>
    /// Apply was cancelled mid-operation.
    /// May have partial changes applied.
    /// </summary>
    Cancelled,

    /// <summary>
    /// Proposal validation failed.
    /// Contains invalid paths, conflicts, or other issues.
    /// </summary>
    Invalid
}
```

### 2. FileOperation Model

The `FileOperation` represents a single file operation within a proposal.

```csharp
// src/SeniorIntern.Core/Models/FileOperation.cs
namespace SeniorIntern.Core.Models;

using System.Text;

/// <summary>
/// Represents a single file operation within a multi-file proposal.
/// Each operation corresponds to one code block or detected file action.
/// </summary>
public sealed class FileOperation
{
    #region Identity Properties

    /// <summary>
    /// Unique identifier for this operation.
    /// </summary>
    public Guid Id { get; init; } = Guid.NewGuid();

    /// <summary>
    /// Relative path within the workspace.
    /// Always uses forward slashes for consistency.
    /// </summary>
    /// <example>"src/Models/User.cs"</example>
    public string Path { get; init; } = string.Empty;

    /// <summary>
    /// Type of file operation to perform.
    /// </summary>
    public FileOperationType Type { get; init; }

    #endregion

    #region Content Properties

    /// <summary>
    /// Content for create/modify operations.
    /// Null for delete/rename operations.
    /// </summary>
    public string? Content { get; init; }

    /// <summary>
    /// ID of the source CodeBlock (if applicable).
    /// Links back to v0.4.1 code extraction.
    /// </summary>
    public Guid? CodeBlockId { get; init; }

    /// <summary>
    /// Detected programming language identifier.
    /// </summary>
    /// <example>"csharp", "typescript", "python"</example>
    public string? Language { get; init; }

    /// <summary>
    /// Display-friendly language name for UI.
    /// </summary>
    /// <example>"C#", "TypeScript", "Python"</example>
    public string? DisplayLanguage { get; init; }

    #endregion

    #region State Properties

    /// <summary>
    /// Whether this operation is selected for batch apply.
    /// Default true - user can deselect individual operations.
    /// </summary>
    public bool IsSelected { get; set; } = true;

    /// <summary>
    /// Status of this individual operation.
    /// </summary>
    public FileOperationStatus Status { get; set; } = FileOperationStatus.Pending;

    /// <summary>
    /// Error message if operation failed.
    /// </summary>
    public string? ErrorMessage { get; set; }

    #endregion

    #region Rename/Move Properties

    /// <summary>
    /// New path for rename/move operations.
    /// Only used when Type is Rename or Move.
    /// </summary>
    public string? NewPath { get; init; }

    #endregion

    #region Ordering Properties

    /// <summary>
    /// Sequence order for dependency handling.
    /// Lower numbers are processed first.
    /// </summary>
    /// <remarks>
    /// Used to ensure directories are created before files,
    /// and dependencies are resolved in correct order.
    /// </remarks>
    public int Order { get; init; }

    #endregion

    #region Computed Properties - Path Components

    /// <summary>
    /// File name without directory path.
    /// </summary>
    /// <example>"User.cs" from "src/Models/User.cs"</example>
    public string FileName => System.IO.Path.GetFileName(Path);

    /// <summary>
    /// Directory containing this file.
    /// </summary>
    /// <example>"src/Models" from "src/Models/User.cs"</example>
    public string? Directory => System.IO.Path.GetDirectoryName(Path)?.Replace('\\', '/');

    /// <summary>
    /// File extension including dot.
    /// </summary>
    /// <example>".cs" from "src/Models/User.cs"</example>
    public string Extension => System.IO.Path.GetExtension(Path);

    /// <summary>
    /// File name without extension.
    /// </summary>
    /// <example>"User" from "src/Models/User.cs"</example>
    public string FileNameWithoutExtension => System.IO.Path.GetFileNameWithoutExtension(Path);

    /// <summary>
    /// Depth of the path (number of directory levels).
    /// </summary>
    /// <example>2 for "src/Models/User.cs"</example>
    public int PathDepth => Path.Count(c => c == '/');

    #endregion

    #region Computed Properties - Content Analysis

    /// <summary>
    /// Content size in bytes (UTF-8 encoded).
    /// </summary>
    public long ContentSizeBytes => Content != null
        ? Encoding.UTF8.GetByteCount(Content)
        : 0;

    /// <summary>
    /// Human-readable content size.
    /// </summary>
    public string ContentSizeFormatted => FormatBytes(ContentSizeBytes);

    /// <summary>
    /// Line count of content.
    /// </summary>
    public int LineCount => Content?.Split('\n').Length ?? 0;

    /// <summary>
    /// Whether the content is empty or whitespace only.
    /// </summary>
    public bool IsContentEmpty => string.IsNullOrWhiteSpace(Content);

    #endregion

    #region Computed Properties - State

    /// <summary>
    /// Whether this operation can be applied.
    /// Must be pending and have a known operation type.
    /// </summary>
    public bool CanApply =>
        Status == FileOperationStatus.Pending &&
        Type != FileOperationType.Unknown;

    /// <summary>
    /// Whether this operation has been completed (success or failure).
    /// </summary>
    public bool IsCompleted =>
        Status is FileOperationStatus.Applied
        or FileOperationStatus.Failed
        or FileOperationStatus.Skipped;

    /// <summary>
    /// Whether this operation is currently being processed.
    /// </summary>
    public bool IsInProgress => Status == FileOperationStatus.InProgress;

    /// <summary>
    /// Whether this operation has a conflict.
    /// </summary>
    public bool HasConflict => Status == FileOperationStatus.Conflict;

    #endregion

    #region Icon/Display Properties

    /// <summary>
    /// Material icon name for the operation type.
    /// Used in UI for visual indication.
    /// </summary>
    public string OperationIcon => Type switch
    {
        FileOperationType.Create => "add_circle",
        FileOperationType.Modify => "edit",
        FileOperationType.Delete => "delete",
        FileOperationType.Rename => "drive_file_rename_outline",
        FileOperationType.Move => "drive_file_move",
        FileOperationType.CreateDirectory => "create_new_folder",
        _ => "help_outline"
    };

    /// <summary>
    /// Operation type display text.
    /// </summary>
    public string OperationDisplayText => Type switch
    {
        FileOperationType.Create => "Create",
        FileOperationType.Modify => "Modify",
        FileOperationType.Delete => "Delete",
        FileOperationType.Rename => "Rename",
        FileOperationType.Move => "Move",
        FileOperationType.CreateDirectory => "Create Directory",
        _ => "Unknown"
    };

    /// <summary>
    /// Status display text.
    /// </summary>
    public string StatusDisplayText => Status switch
    {
        FileOperationStatus.Pending => "Pending",
        FileOperationStatus.Applied => "Applied",
        FileOperationStatus.Skipped => "Skipped",
        FileOperationStatus.Failed => "Failed",
        FileOperationStatus.Conflict => "Conflict",
        FileOperationStatus.InProgress => "In Progress",
        _ => "Unknown"
    };

    #endregion

    #region Factory Methods

    /// <summary>
    /// Create a FileOperation from a CodeBlock.
    /// </summary>
    /// <param name="block">The source code block.</param>
    /// <param name="order">The sequence order.</param>
    /// <returns>A new FileOperation.</returns>
    public static FileOperation FromCodeBlock(CodeBlock block, int order = 0) => new()
    {
        Path = NormalizePath(block.TargetFilePath ?? string.Empty),
        Type = FileOperationType.Create,
        Content = block.Content,
        CodeBlockId = block.Id,
        Language = block.Language,
        DisplayLanguage = block.DisplayLanguage,
        Order = order
    };

    /// <summary>
    /// Create a directory creation operation.
    /// </summary>
    /// <param name="path">The directory path.</param>
    /// <param name="order">The sequence order.</param>
    /// <returns>A new FileOperation for directory creation.</returns>
    public static FileOperation CreateDirectory(string path, int order = 0) => new()
    {
        Path = NormalizePath(path),
        Type = FileOperationType.CreateDirectory,
        Order = order
    };

    /// <summary>
    /// Create a file deletion operation.
    /// </summary>
    /// <param name="path">The file path to delete.</param>
    /// <param name="order">The sequence order.</param>
    /// <returns>A new FileOperation for deletion.</returns>
    public static FileOperation Delete(string path, int order = 0) => new()
    {
        Path = NormalizePath(path),
        Type = FileOperationType.Delete,
        Order = order
    };

    /// <summary>
    /// Create a file rename operation.
    /// </summary>
    /// <param name="oldPath">The current file path.</param>
    /// <param name="newPath">The new file path.</param>
    /// <param name="order">The sequence order.</param>
    /// <returns>A new FileOperation for renaming.</returns>
    public static FileOperation Rename(string oldPath, string newPath, int order = 0) => new()
    {
        Path = NormalizePath(oldPath),
        NewPath = NormalizePath(newPath),
        Type = FileOperationType.Rename,
        Order = order
    };

    #endregion

    #region Helper Methods

    /// <summary>
    /// Normalize a path to use forward slashes.
    /// </summary>
    private static string NormalizePath(string path) =>
        path.Replace('\\', '/').TrimStart('/');

    /// <summary>
    /// Format bytes as human-readable string.
    /// </summary>
    private static string FormatBytes(long bytes)
    {
        string[] sizes = { "B", "KB", "MB", "GB" };
        int order = 0;
        double size = bytes;

        while (size >= 1024 && order < sizes.Length - 1)
        {
            order++;
            size /= 1024;
        }

        return $"{size:0.##} {sizes[order]}";
    }

    #endregion
}

/// <summary>
/// Type of file operation.
/// </summary>
public enum FileOperationType
{
    /// <summary>
    /// Create a new file.
    /// File must not exist (or will be overwritten with confirmation).
    /// </summary>
    Create,

    /// <summary>
    /// Modify an existing file.
    /// File must exist.
    /// </summary>
    Modify,

    /// <summary>
    /// Delete a file.
    /// File must exist.
    /// </summary>
    Delete,

    /// <summary>
    /// Rename a file (within same directory).
    /// Source must exist, target must not exist.
    /// </summary>
    Rename,

    /// <summary>
    /// Move a file to a new location.
    /// Source must exist, target directory must exist.
    /// </summary>
    Move,

    /// <summary>
    /// Create a directory.
    /// Parent directories will be created as needed.
    /// </summary>
    CreateDirectory,

    /// <summary>
    /// Unknown or unsupported operation type.
    /// Cannot be applied.
    /// </summary>
    Unknown
}

/// <summary>
/// Status of a file operation.
/// </summary>
public enum FileOperationStatus
{
    /// <summary>
    /// Not yet applied.
    /// Initial state, eligible for apply.
    /// </summary>
    Pending,

    /// <summary>
    /// Successfully applied.
    /// Terminal success state.
    /// </summary>
    Applied,

    /// <summary>
    /// Skipped by user choice.
    /// User deselected this operation.
    /// </summary>
    Skipped,

    /// <summary>
    /// Failed to apply.
    /// Check ErrorMessage for details.
    /// </summary>
    Failed,

    /// <summary>
    /// Conflict detected (file exists with different content).
    /// Requires user resolution.
    /// </summary>
    Conflict,

    /// <summary>
    /// Currently being applied.
    /// Transient state during batch apply.
    /// </summary>
    InProgress
}
```

### 3. BatchApplyResult Model

The `BatchApplyResult` tracks the outcome of applying multiple operations.

```csharp
// src/SeniorIntern.Core/Models/BatchApplyResult.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Result of applying a batch of file operations.
/// Aggregates individual ApplyResult instances with summary statistics.
/// </summary>
public sealed class BatchApplyResult
{
    #region Summary Properties

    /// <summary>
    /// Whether all selected operations succeeded.
    /// </summary>
    public bool AllSucceeded { get; init; }

    /// <summary>
    /// Number of successful operations.
    /// </summary>
    public int SuccessCount { get; init; }

    /// <summary>
    /// Number of failed operations.
    /// </summary>
    public int FailedCount { get; init; }

    /// <summary>
    /// Number of skipped operations.
    /// </summary>
    public int SkippedCount { get; init; }

    /// <summary>
    /// Total operations attempted (success + failed + skipped).
    /// </summary>
    public int TotalCount => SuccessCount + FailedCount + SkippedCount;

    /// <summary>
    /// Success rate as percentage (0-100).
    /// </summary>
    public double SuccessRate => TotalCount > 0
        ? (double)SuccessCount / TotalCount * 100
        : 0;

    #endregion

    #region Individual Results

    /// <summary>
    /// Individual results for each operation.
    /// Ordered by operation sequence.
    /// </summary>
    public IReadOnlyList<ApplyResult> Results { get; init; } = Array.Empty<ApplyResult>();

    /// <summary>
    /// Operations that failed.
    /// </summary>
    public IEnumerable<ApplyResult> FailedResults =>
        Results.Where(r => !r.Success);

    /// <summary>
    /// Operations that succeeded.
    /// </summary>
    public IEnumerable<ApplyResult> SucceededResults =>
        Results.Where(r => r.Success);

    /// <summary>
    /// Get result for a specific path.
    /// </summary>
    /// <param name="path">The file path.</param>
    /// <returns>The result, or null if not found.</returns>
    public ApplyResult? GetResultForPath(string path) =>
        Results.FirstOrDefault(r =>
            r.FilePath.Equals(path, StringComparison.OrdinalIgnoreCase));

    #endregion

    #region Timing Properties

    /// <summary>
    /// When the batch apply started.
    /// </summary>
    public DateTime StartedAt { get; init; }

    /// <summary>
    /// When the batch apply completed.
    /// </summary>
    public DateTime CompletedAt { get; init; }

    /// <summary>
    /// Duration of the batch apply.
    /// </summary>
    public TimeSpan Duration => CompletedAt - StartedAt;

    /// <summary>
    /// Average time per operation.
    /// </summary>
    public TimeSpan AverageOperationTime => TotalCount > 0
        ? TimeSpan.FromTicks(Duration.Ticks / TotalCount)
        : TimeSpan.Zero;

    #endregion

    #region Undo Support

    /// <summary>
    /// Paths of all backup files created.
    /// Used for undo operations.
    /// </summary>
    public IReadOnlyList<string> BackupPaths { get; init; } = Array.Empty<string>();

    /// <summary>
    /// Whether undo is available for all successful changes.
    /// </summary>
    public bool CanUndoAll => Results.All(r => !r.Success || r.CanUndo);

    /// <summary>
    /// Number of operations that can be undone.
    /// </summary>
    public int UndoableCount => Results.Count(r => r.CanUndo);

    #endregion

    #region State Properties

    /// <summary>
    /// Whether the batch was cancelled mid-operation.
    /// </summary>
    public bool WasCancelled { get; init; }

    /// <summary>
    /// Whether a rollback was performed after failure.
    /// </summary>
    public bool WasRolledBack { get; init; }

    /// <summary>
    /// Error message if the batch failed overall.
    /// </summary>
    public string? BatchErrorMessage { get; init; }

    #endregion

    #region Factory Methods

    /// <summary>
    /// Create a successful batch result.
    /// </summary>
    /// <param name="results">Individual operation results.</param>
    /// <param name="startedAt">When the batch started.</param>
    /// <returns>A successful BatchApplyResult.</returns>
    public static BatchApplyResult Success(
        IReadOnlyList<ApplyResult> results,
        DateTime startedAt) => new()
    {
        AllSucceeded = true,
        SuccessCount = results.Count,
        FailedCount = 0,
        SkippedCount = 0,
        Results = results,
        StartedAt = startedAt,
        CompletedAt = DateTime.UtcNow,
        BackupPaths = results
            .Where(r => r.BackupPath != null)
            .Select(r => r.BackupPath!)
            .ToList()
    };

    /// <summary>
    /// Create a partial success result.
    /// </summary>
    /// <param name="results">All operation results.</param>
    /// <param name="startedAt">When the batch started.</param>
    /// <returns>A partial success BatchApplyResult.</returns>
    public static BatchApplyResult PartialSuccess(
        IReadOnlyList<ApplyResult> results,
        DateTime startedAt)
    {
        var succeeded = results.Where(r => r.Success).ToList();
        var failed = results.Where(r => !r.Success).ToList();

        return new()
        {
            AllSucceeded = false,
            SuccessCount = succeeded.Count,
            FailedCount = failed.Count,
            SkippedCount = 0,
            Results = results,
            StartedAt = startedAt,
            CompletedAt = DateTime.UtcNow,
            BackupPaths = succeeded
                .Where(r => r.BackupPath != null)
                .Select(r => r.BackupPath!)
                .ToList()
        };
    }

    /// <summary>
    /// Create a cancelled result.
    /// </summary>
    /// <param name="completedResults">Results completed before cancellation.</param>
    /// <param name="startedAt">When the batch started.</param>
    /// <returns>A cancelled BatchApplyResult.</returns>
    public static BatchApplyResult Cancelled(
        IReadOnlyList<ApplyResult> completedResults,
        DateTime startedAt) => new()
    {
        AllSucceeded = false,
        SuccessCount = completedResults.Count(r => r.Success),
        FailedCount = completedResults.Count(r => !r.Success),
        SkippedCount = 0,
        Results = completedResults,
        StartedAt = startedAt,
        CompletedAt = DateTime.UtcNow,
        WasCancelled = true,
        BackupPaths = completedResults
            .Where(r => r.Success && r.BackupPath != null)
            .Select(r => r.BackupPath!)
            .ToList()
    };

    /// <summary>
    /// Create a rolled back result.
    /// </summary>
    /// <param name="errorMessage">The error that triggered rollback.</param>
    /// <param name="startedAt">When the batch started.</param>
    /// <returns>A rolled back BatchApplyResult.</returns>
    public static BatchApplyResult RolledBack(
        string errorMessage,
        DateTime startedAt) => new()
    {
        AllSucceeded = false,
        SuccessCount = 0,
        FailedCount = 0,
        SkippedCount = 0,
        Results = Array.Empty<ApplyResult>(),
        StartedAt = startedAt,
        CompletedAt = DateTime.UtcNow,
        WasRolledBack = true,
        BatchErrorMessage = errorMessage
    };

    #endregion
}

/// <summary>
/// Progress information during batch apply.
/// Reported through IProgress&lt;BatchApplyProgress&gt;.
/// </summary>
public sealed class BatchApplyProgress
{
    #region Count Properties

    /// <summary>
    /// Total number of operations to process.
    /// </summary>
    public int TotalOperations { get; init; }

    /// <summary>
    /// Number of completed operations.
    /// </summary>
    public int CompletedOperations { get; init; }

    /// <summary>
    /// Number of failed operations so far.
    /// </summary>
    public int FailedOperations { get; init; }

    /// <summary>
    /// Operations remaining to process.
    /// </summary>
    public int RemainingOperations => TotalOperations - CompletedOperations;

    #endregion

    #region Current Operation Properties

    /// <summary>
    /// Current file being processed.
    /// </summary>
    public string CurrentFile { get; init; } = string.Empty;

    /// <summary>
    /// Current operation type.
    /// </summary>
    public FileOperationType CurrentOperation { get; init; }

    /// <summary>
    /// Current operation ID.
    /// </summary>
    public Guid? CurrentOperationId { get; init; }

    #endregion

    #region Progress Properties

    /// <summary>
    /// Progress percentage (0-100).
    /// </summary>
    public double ProgressPercent => TotalOperations > 0
        ? (double)CompletedOperations / TotalOperations * 100
        : 0;

    /// <summary>
    /// Estimated time remaining based on average operation time.
    /// Null if not enough data to estimate.
    /// </summary>
    public TimeSpan? EstimatedRemaining { get; init; }

    /// <summary>
    /// Time elapsed since batch started.
    /// </summary>
    public TimeSpan Elapsed { get; init; }

    #endregion

    #region Phase Properties

    /// <summary>
    /// Current phase of the batch apply.
    /// </summary>
    public BatchApplyPhase Phase { get; init; }

    /// <summary>
    /// Human-readable phase description.
    /// </summary>
    public string PhaseDescription => Phase switch
    {
        BatchApplyPhase.Validating => "Validating operations...",
        BatchApplyPhase.CreatingBackups => "Creating backups...",
        BatchApplyPhase.CreatingDirectories => "Creating directories...",
        BatchApplyPhase.WritingFiles => $"Writing files ({CompletedOperations}/{TotalOperations})...",
        BatchApplyPhase.Finalizing => "Finalizing...",
        BatchApplyPhase.Completed => "Completed",
        BatchApplyPhase.RollingBack => "Rolling back changes...",
        _ => "Processing..."
    };

    #endregion

    #region Control Properties

    /// <summary>
    /// Whether the operation can be cancelled at this point.
    /// </summary>
    public bool CanCancel { get; init; } = true;

    /// <summary>
    /// Whether cancellation has been requested.
    /// </summary>
    public bool CancellationRequested { get; init; }

    #endregion

    #region Status Message

    /// <summary>
    /// Detailed status message for display.
    /// </summary>
    public string StatusMessage { get; init; } = string.Empty;

    #endregion
}

/// <summary>
/// Phase of batch apply operation.
/// </summary>
public enum BatchApplyPhase
{
    /// <summary>
    /// Validating operations before apply.
    /// Checking paths, permissions, conflicts.
    /// </summary>
    Validating,

    /// <summary>
    /// Creating backup copies of existing files.
    /// Only for files that will be modified.
    /// </summary>
    CreatingBackups,

    /// <summary>
    /// Creating required directories.
    /// Parent directories for new files.
    /// </summary>
    CreatingDirectories,

    /// <summary>
    /// Writing file contents.
    /// Main phase of the operation.
    /// </summary>
    WritingFiles,

    /// <summary>
    /// Finalizing the operation.
    /// Cleanup, notifications.
    /// </summary>
    Finalizing,

    /// <summary>
    /// Operation completed successfully.
    /// Terminal success state.
    /// </summary>
    Completed,

    /// <summary>
    /// Rolling back due to error.
    /// Restoring from backups.
    /// </summary>
    RollingBack
}
```

### 4. ProposalValidation Models

The validation models capture issues found during proposal validation.

```csharp
// src/SeniorIntern.Core/Models/ProposalValidation.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Result of validating a file tree proposal.
/// Contains all validation issues found during analysis.
/// </summary>
public sealed class ProposalValidationResult
{
    #region Core Properties

    /// <summary>
    /// Whether the proposal is valid and can be applied.
    /// True only if there are no Error-level issues.
    /// </summary>
    public bool IsValid { get; init; }

    /// <summary>
    /// All validation issues found.
    /// Ordered by severity (errors first), then by path.
    /// </summary>
    public IReadOnlyList<ValidationIssue> Issues { get; init; } = Array.Empty<ValidationIssue>();

    #endregion

    #region Filtered Views

    /// <summary>
    /// Issues that are errors (blocking apply).
    /// </summary>
    public IEnumerable<ValidationIssue> Errors =>
        Issues.Where(i => i.Severity == ValidationSeverity.Error);

    /// <summary>
    /// Issues that are warnings (can proceed with caution).
    /// </summary>
    public IEnumerable<ValidationIssue> Warnings =>
        Issues.Where(i => i.Severity == ValidationSeverity.Warning);

    /// <summary>
    /// Issues that are informational.
    /// </summary>
    public IEnumerable<ValidationIssue> InfoMessages =>
        Issues.Where(i => i.Severity == ValidationSeverity.Info);

    #endregion

    #region Summary Properties

    /// <summary>
    /// Whether there are any errors.
    /// </summary>
    public bool HasErrors => Errors.Any();

    /// <summary>
    /// Whether there are any warnings.
    /// </summary>
    public bool HasWarnings => Warnings.Any();

    /// <summary>
    /// Total number of errors.
    /// </summary>
    public int ErrorCount => Errors.Count();

    /// <summary>
    /// Total number of warnings.
    /// </summary>
    public int WarningCount => Warnings.Count();

    /// <summary>
    /// Total number of issues.
    /// </summary>
    public int TotalIssueCount => Issues.Count;

    /// <summary>
    /// Summary message describing the validation result.
    /// </summary>
    public string SummaryMessage
    {
        get
        {
            if (IsValid && !HasWarnings)
                return "Proposal is valid and ready to apply.";

            if (IsValid && HasWarnings)
                return $"Proposal is valid with {WarningCount} warning(s).";

            return $"Proposal has {ErrorCount} error(s) that must be resolved.";
        }
    }

    #endregion

    #region Query Methods

    /// <summary>
    /// Get all issues for a specific path.
    /// </summary>
    /// <param name="path">The file path.</param>
    /// <returns>Issues affecting that path.</returns>
    public IEnumerable<ValidationIssue> GetIssuesForPath(string path) =>
        Issues.Where(i => i.Path.Equals(path, StringComparison.OrdinalIgnoreCase));

    /// <summary>
    /// Get all issues for a specific operation.
    /// </summary>
    /// <param name="operationId">The operation ID.</param>
    /// <returns>Issues for that operation.</returns>
    public IEnumerable<ValidationIssue> GetIssuesForOperation(Guid operationId) =>
        Issues.Where(i => i.OperationId == operationId);

    /// <summary>
    /// Get issues of a specific type.
    /// </summary>
    /// <param name="type">The issue type.</param>
    /// <returns>Issues of that type.</returns>
    public IEnumerable<ValidationIssue> GetIssuesByType(ValidationIssueType type) =>
        Issues.Where(i => i.Type == type);

    /// <summary>
    /// Check if a specific path has errors.
    /// </summary>
    /// <param name="path">The file path.</param>
    /// <returns>True if there are errors for this path.</returns>
    public bool PathHasErrors(string path) =>
        GetIssuesForPath(path).Any(i => i.Severity == ValidationSeverity.Error);

    #endregion

    #region Factory Methods

    /// <summary>
    /// Create a valid result with no issues.
    /// </summary>
    public static ProposalValidationResult Valid() => new()
    {
        IsValid = true
    };

    /// <summary>
    /// Create a valid result with warnings.
    /// </summary>
    /// <param name="warnings">The warning issues.</param>
    public static ProposalValidationResult ValidWithWarnings(
        params ValidationIssue[] warnings) => new()
    {
        IsValid = true,
        Issues = warnings
    };

    /// <summary>
    /// Create an invalid result with issues.
    /// </summary>
    /// <param name="issues">The validation issues.</param>
    public static ProposalValidationResult Invalid(
        params ValidationIssue[] issues) => new()
    {
        IsValid = false,
        Issues = issues.OrderBy(i => i.Severity)
                       .ThenBy(i => i.Path)
                       .ToArray()
    };

    /// <summary>
    /// Create an invalid result with multiple issue lists.
    /// </summary>
    /// <param name="issues">The validation issues.</param>
    public static ProposalValidationResult Invalid(
        IEnumerable<ValidationIssue> issues) => new()
    {
        IsValid = !issues.Any(i => i.Severity == ValidationSeverity.Error),
        Issues = issues.OrderBy(i => i.Severity)
                       .ThenBy(i => i.Path)
                       .ToArray()
    };

    #endregion
}

/// <summary>
/// A validation issue with a file operation.
/// </summary>
public sealed class ValidationIssue
{
    #region Identity Properties

    /// <summary>
    /// ID of the affected operation (if applicable).
    /// </summary>
    public Guid? OperationId { get; init; }

    /// <summary>
    /// Path of the affected file.
    /// </summary>
    public string Path { get; init; } = string.Empty;

    #endregion

    #region Classification Properties

    /// <summary>
    /// Type of validation issue.
    /// </summary>
    public ValidationIssueType Type { get; init; }

    /// <summary>
    /// Severity of the issue.
    /// </summary>
    public ValidationSeverity Severity { get; init; }

    #endregion

    #region Message Properties

    /// <summary>
    /// Human-readable error message.
    /// </summary>
    public string Message { get; init; } = string.Empty;

    /// <summary>
    /// Suggested fix for the issue (if applicable).
    /// </summary>
    public string? SuggestedFix { get; init; }

    /// <summary>
    /// Additional context or details.
    /// </summary>
    public string? Details { get; init; }

    #endregion

    #region Display Properties

    /// <summary>
    /// Icon for the severity level.
    /// </summary>
    public string SeverityIcon => Severity switch
    {
        ValidationSeverity.Error => "error",
        ValidationSeverity.Warning => "warning",
        ValidationSeverity.Info => "info",
        _ => "help_outline"
    };

    /// <summary>
    /// Display name for the issue type.
    /// </summary>
    public string TypeDisplayName => Type switch
    {
        ValidationIssueType.FileExists => "File Exists",
        ValidationIssueType.DirectoryExists => "Directory Exists",
        ValidationIssueType.InvalidPath => "Invalid Path",
        ValidationIssueType.PermissionDenied => "Permission Denied",
        ValidationIssueType.ParentNotExists => "Parent Directory Missing",
        ValidationIssueType.PathTooLong => "Path Too Long",
        ValidationIssueType.InvalidCharacters => "Invalid Characters",
        ValidationIssueType.CircularDependency => "Circular Dependency",
        ValidationIssueType.DuplicatePath => "Duplicate Path",
        ValidationIssueType.EmptyContent => "Empty Content",
        ValidationIssueType.OutsideWorkspace => "Outside Workspace",
        _ => "Unknown Issue"
    };

    #endregion

    #region Factory Methods

    /// <summary>
    /// Create a file exists error.
    /// </summary>
    public static ValidationIssue FileExists(string path, Guid? operationId = null) => new()
    {
        OperationId = operationId,
        Path = path,
        Type = ValidationIssueType.FileExists,
        Severity = ValidationSeverity.Warning,
        Message = $"File already exists: {path}",
        SuggestedFix = "The file will be overwritten if you proceed."
    };

    /// <summary>
    /// Create an invalid path error.
    /// </summary>
    public static ValidationIssue InvalidPath(
        string path,
        string reason,
        Guid? operationId = null) => new()
    {
        OperationId = operationId,
        Path = path,
        Type = ValidationIssueType.InvalidPath,
        Severity = ValidationSeverity.Error,
        Message = $"Invalid file path: {reason}",
        SuggestedFix = "Correct the file path and try again."
    };

    /// <summary>
    /// Create a permission denied error.
    /// </summary>
    public static ValidationIssue PermissionDenied(
        string path,
        Guid? operationId = null) => new()
    {
        OperationId = operationId,
        Path = path,
        Type = ValidationIssueType.PermissionDenied,
        Severity = ValidationSeverity.Error,
        Message = $"Permission denied: Cannot write to {path}",
        SuggestedFix = "Check file permissions or choose a different location."
    };

    /// <summary>
    /// Create a path too long error.
    /// </summary>
    public static ValidationIssue PathTooLong(
        string path,
        int maxLength,
        Guid? operationId = null) => new()
    {
        OperationId = operationId,
        Path = path,
        Type = ValidationIssueType.PathTooLong,
        Severity = ValidationSeverity.Error,
        Message = $"Path exceeds maximum length of {maxLength} characters",
        SuggestedFix = "Use a shorter file path."
    };

    /// <summary>
    /// Create a duplicate path error.
    /// </summary>
    public static ValidationIssue DuplicatePath(
        string path,
        Guid? operationId = null) => new()
    {
        OperationId = operationId,
        Path = path,
        Type = ValidationIssueType.DuplicatePath,
        Severity = ValidationSeverity.Error,
        Message = $"Duplicate path in proposal: {path}",
        SuggestedFix = "Remove duplicate operations for this path."
    };

    /// <summary>
    /// Create an outside workspace error.
    /// </summary>
    public static ValidationIssue OutsideWorkspace(
        string path,
        Guid? operationId = null) => new()
    {
        OperationId = operationId,
        Path = path,
        Type = ValidationIssueType.OutsideWorkspace,
        Severity = ValidationSeverity.Error,
        Message = $"Path is outside the workspace: {path}",
        SuggestedFix = "Files can only be created within the current workspace."
    };

    /// <summary>
    /// Create an empty content warning.
    /// </summary>
    public static ValidationIssue EmptyContent(
        string path,
        Guid? operationId = null) => new()
    {
        OperationId = operationId,
        Path = path,
        Type = ValidationIssueType.EmptyContent,
        Severity = ValidationSeverity.Warning,
        Message = $"File has empty content: {path}",
        SuggestedFix = "An empty file will be created."
    };

    /// <summary>
    /// Create a parent not exists info.
    /// </summary>
    public static ValidationIssue ParentNotExists(
        string path,
        string parentPath,
        Guid? operationId = null) => new()
    {
        OperationId = operationId,
        Path = path,
        Type = ValidationIssueType.ParentNotExists,
        Severity = ValidationSeverity.Info,
        Message = $"Parent directory will be created: {parentPath}",
        Details = "The directory will be created automatically."
    };

    #endregion
}

/// <summary>
/// Type of validation issue.
/// </summary>
public enum ValidationIssueType
{
    /// <summary>
    /// File already exists at the target path.
    /// </summary>
    FileExists,

    /// <summary>
    /// Directory already exists at the target path.
    /// </summary>
    DirectoryExists,

    /// <summary>
    /// File path is invalid (bad format).
    /// </summary>
    InvalidPath,

    /// <summary>
    /// Permission denied to write to location.
    /// </summary>
    PermissionDenied,

    /// <summary>
    /// Parent directory doesn't exist (will be created).
    /// </summary>
    ParentNotExists,

    /// <summary>
    /// File path exceeds maximum length.
    /// </summary>
    PathTooLong,

    /// <summary>
    /// Path contains invalid characters.
    /// </summary>
    InvalidCharacters,

    /// <summary>
    /// Circular dependency detected between operations.
    /// </summary>
    CircularDependency,

    /// <summary>
    /// Duplicate path in proposal (multiple operations for same file).
    /// </summary>
    DuplicatePath,

    /// <summary>
    /// File content is empty.
    /// </summary>
    EmptyContent,

    /// <summary>
    /// Target path is outside the workspace boundary.
    /// </summary>
    OutsideWorkspace
}

/// <summary>
/// Severity of a validation issue.
/// </summary>
public enum ValidationSeverity
{
    /// <summary>
    /// Informational message.
    /// Does not block apply.
    /// </summary>
    Info,

    /// <summary>
    /// Warning - can proceed with caution.
    /// User should be informed but apply is allowed.
    /// </summary>
    Warning,

    /// <summary>
    /// Error - cannot proceed.
    /// Must be resolved before apply.
    /// </summary>
    Error
}
```

---

## Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Models/FileTreeProposal.cs` | Main proposal model with operations collection |
| `src/SeniorIntern.Core/Models/FileOperation.cs` | Individual file operation model |
| `src/SeniorIntern.Core/Models/BatchApplyResult.cs` | Batch apply result and progress models |
| `src/SeniorIntern.Core/Models/ProposalValidation.cs` | Validation result and issue models |

---

## Files to Modify

| File | Modification |
|------|--------------|
| `src/SeniorIntern.Core/Models/CodeBlock.cs` | Ensure `Id` property exists for linking |

---

## Dependencies

| Dependency | Purpose |
|------------|---------|
| `System.Text` | UTF-8 encoding for size calculations |
| `System.IO` | Path manipulation utilities |
| `SeniorIntern.Core.Models.CodeBlock` | From v0.4.1 for linking code blocks |
| `SeniorIntern.Core.Models.ApplyResult` | From v0.4.3 for individual results |

---

## Testing Strategy

### Unit Tests

```csharp
// tests/SeniorIntern.Core.Tests/Models/FileTreeProposalTests.cs
namespace SeniorIntern.Core.Tests.Models;

public class FileTreeProposalTests
{
    #region FileCount Tests

    [Fact]
    public void FileCount_WithMultipleCreateOperations_ReturnsCorrectCount()
    {
        // Arrange
        var proposal = new FileTreeProposal
        {
            Operations = new[]
            {
                new FileOperation { Type = FileOperationType.Create },
                new FileOperation { Type = FileOperationType.Create },
                new FileOperation { Type = FileOperationType.Modify }
            }
        };

        // Act & Assert
        Assert.Equal(2, proposal.FileCount);
    }

    [Fact]
    public void FileCount_WithNoCreateOperations_ReturnsZero()
    {
        // Arrange
        var proposal = new FileTreeProposal
        {
            Operations = new[]
            {
                new FileOperation { Type = FileOperationType.Modify },
                new FileOperation { Type = FileOperationType.Delete }
            }
        };

        // Act & Assert
        Assert.Equal(0, proposal.FileCount);
    }

    #endregion

    #region Directories Tests

    [Fact]
    public void Directories_ReturnsUniqueDirectories()
    {
        // Arrange
        var proposal = new FileTreeProposal
        {
            Operations = new[]
            {
                new FileOperation
                {
                    Type = FileOperationType.Create,
                    Path = "src/Models/User.cs"
                },
                new FileOperation
                {
                    Type = FileOperationType.Create,
                    Path = "src/Models/Product.cs"
                },
                new FileOperation
                {
                    Type = FileOperationType.Create,
                    Path = "src/Services/UserService.cs"
                }
            }
        };

        // Act
        var dirs = proposal.Directories.ToList();

        // Assert
        Assert.Equal(2, dirs.Count);
        Assert.Contains("src/Models", dirs);
        Assert.Contains("src/Services", dirs);
    }

    [Fact]
    public void DirectoryCount_MatchesUniqueDirectories()
    {
        // Arrange
        var proposal = new FileTreeProposal
        {
            Operations = new[]
            {
                new FileOperation
                {
                    Type = FileOperationType.Create,
                    Path = "a/b/c.cs"
                },
                new FileOperation
                {
                    Type = FileOperationType.Create,
                    Path = "a/b/d.cs"
                },
                new FileOperation
                {
                    Type = FileOperationType.Create,
                    Path = "x/y/z.cs"
                }
            }
        };

        // Act & Assert
        Assert.Equal(2, proposal.DirectoryCount);
    }

    #endregion

    #region Selection Tests

    [Fact]
    public void SelectedOperations_FiltersCorrectly()
    {
        // Arrange
        var proposal = new FileTreeProposal
        {
            Operations = new[]
            {
                new FileOperation { IsSelected = true },
                new FileOperation { IsSelected = false },
                new FileOperation { IsSelected = true }
            }
        };

        // Act & Assert
        Assert.Equal(2, proposal.SelectedCount);
        Assert.True(proposal.HasSelectedOperations);
        Assert.False(proposal.AllSelected);
    }

    [Fact]
    public void SelectAll_SelectsAllOperations()
    {
        // Arrange
        var operations = new[]
        {
            new FileOperation { IsSelected = false },
            new FileOperation { IsSelected = true },
            new FileOperation { IsSelected = false }
        };
        var proposal = new FileTreeProposal { Operations = operations };

        // Act
        proposal.SelectAll();

        // Assert
        Assert.True(proposal.AllSelected);
        Assert.Equal(3, proposal.SelectedCount);
    }

    [Fact]
    public void DeselectAll_DeselectsAllOperations()
    {
        // Arrange
        var operations = new[]
        {
            new FileOperation { IsSelected = true },
            new FileOperation { IsSelected = true }
        };
        var proposal = new FileTreeProposal { Operations = operations };

        // Act
        proposal.DeselectAll();

        // Assert
        Assert.Equal(0, proposal.SelectedCount);
        Assert.False(proposal.HasSelectedOperations);
    }

    #endregion

    #region Query Method Tests

    [Fact]
    public void ContainsPath_ReturnsTrueForExistingPath()
    {
        // Arrange
        var proposal = new FileTreeProposal
        {
            Operations = new[]
            {
                new FileOperation { Path = "src/file.cs" }
            }
        };

        // Act & Assert
        Assert.True(proposal.ContainsPath("src/file.cs"));
        Assert.True(proposal.ContainsPath("SRC/FILE.CS")); // Case insensitive
        Assert.False(proposal.ContainsPath("other/file.cs"));
    }

    [Fact]
    public void GetOperation_ReturnsOperationForPath()
    {
        // Arrange
        var expectedId = Guid.NewGuid();
        var proposal = new FileTreeProposal
        {
            Operations = new[]
            {
                new FileOperation { Id = expectedId, Path = "src/file.cs" }
            }
        };

        // Act
        var op = proposal.GetOperation("src/file.cs");

        // Assert
        Assert.NotNull(op);
        Assert.Equal(expectedId, op.Id);
    }

    [Fact]
    public void GetOperationsInDirectory_ReturnsMatchingOperations()
    {
        // Arrange
        var proposal = new FileTreeProposal
        {
            Operations = new[]
            {
                new FileOperation
                {
                    Type = FileOperationType.Create,
                    Path = "src/Models/User.cs"
                },
                new FileOperation
                {
                    Type = FileOperationType.Create,
                    Path = "src/Models/Product.cs"
                },
                new FileOperation
                {
                    Type = FileOperationType.Create,
                    Path = "src/Services/UserService.cs"
                }
            }
        };

        // Act
        var modelOps = proposal.GetOperationsInDirectory("src/Models").ToList();

        // Assert
        Assert.Equal(2, modelOps.Count);
    }

    #endregion

    #region Size Calculation Tests

    [Fact]
    public void TotalSizeBytes_CalculatesCorrectly()
    {
        // Arrange
        var proposal = new FileTreeProposal
        {
            Operations = new[]
            {
                new FileOperation { Content = "Hello" },      // 5 bytes
                new FileOperation { Content = "World!" },     // 6 bytes
                new FileOperation { Content = null }          // 0 bytes
            }
        };

        // Act & Assert
        Assert.Equal(11, proposal.TotalSizeBytes);
    }

    [Fact]
    public void TotalLineCount_CalculatesCorrectly()
    {
        // Arrange
        var proposal = new FileTreeProposal
        {
            Operations = new[]
            {
                new FileOperation { Content = "line1\nline2\nline3" },  // 3 lines
                new FileOperation { Content = "single" },               // 1 line
                new FileOperation { Content = null }                    // 0 lines
            }
        };

        // Act & Assert
        Assert.Equal(4, proposal.TotalLineCount);
    }

    #endregion
}

// tests/SeniorIntern.Core.Tests/Models/FileOperationTests.cs
namespace SeniorIntern.Core.Tests.Models;

public class FileOperationTests
{
    #region Path Component Tests

    [Theory]
    [InlineData("src/Models/User.cs", "User.cs")]
    [InlineData("file.txt", "file.txt")]
    [InlineData("a/b/c/deep.js", "deep.js")]
    public void FileName_ExtractsCorrectly(string path, string expectedFileName)
    {
        // Arrange
        var op = new FileOperation { Path = path };

        // Act & Assert
        Assert.Equal(expectedFileName, op.FileName);
    }

    [Theory]
    [InlineData("src/Models/User.cs", "src/Models")]
    [InlineData("file.txt", null)]
    [InlineData("a/b/c/deep.js", "a/b/c")]
    public void Directory_ExtractsCorrectly(string path, string? expectedDir)
    {
        // Arrange
        var op = new FileOperation { Path = path };

        // Act
        var dir = op.Directory;

        // Assert
        // Normalize backslashes for cross-platform
        Assert.Equal(expectedDir, dir?.Replace('\\', '/'));
    }

    [Theory]
    [InlineData("file.cs", ".cs")]
    [InlineData("file.test.js", ".js")]
    [InlineData("noextension", "")]
    public void Extension_ExtractsCorrectly(string path, string expectedExt)
    {
        // Arrange
        var op = new FileOperation { Path = path };

        // Act & Assert
        Assert.Equal(expectedExt, op.Extension);
    }

    [Theory]
    [InlineData("src/file.cs", 1)]
    [InlineData("a/b/c/file.cs", 3)]
    [InlineData("file.cs", 0)]
    public void PathDepth_CalculatesCorrectly(string path, int expectedDepth)
    {
        // Arrange
        var op = new FileOperation { Path = path };

        // Act & Assert
        Assert.Equal(expectedDepth, op.PathDepth);
    }

    #endregion

    #region Content Analysis Tests

    [Fact]
    public void ContentSizeBytes_CalculatesUtf8Size()
    {
        // Arrange - includes multi-byte characters
        var op = new FileOperation { Content = "Hello 世界" }; // 5 + 1 + 6 = 12 bytes

        // Act & Assert
        Assert.Equal(12, op.ContentSizeBytes);
    }

    [Fact]
    public void LineCount_CountsNewlines()
    {
        // Arrange
        var op = new FileOperation { Content = "line1\nline2\nline3" };

        // Act & Assert
        Assert.Equal(3, op.LineCount);
    }

    [Fact]
    public void IsContentEmpty_DetectsEmptyContent()
    {
        // Arrange & Act & Assert
        Assert.True(new FileOperation { Content = null }.IsContentEmpty);
        Assert.True(new FileOperation { Content = "" }.IsContentEmpty);
        Assert.True(new FileOperation { Content = "   " }.IsContentEmpty);
        Assert.False(new FileOperation { Content = "content" }.IsContentEmpty);
    }

    #endregion

    #region State Tests

    [Theory]
    [InlineData(FileOperationStatus.Pending, FileOperationType.Create, true)]
    [InlineData(FileOperationStatus.Applied, FileOperationType.Create, false)]
    [InlineData(FileOperationStatus.Pending, FileOperationType.Unknown, false)]
    [InlineData(FileOperationStatus.Failed, FileOperationType.Modify, false)]
    public void CanApply_DependsOnStatusAndType(
        FileOperationStatus status,
        FileOperationType type,
        bool expected)
    {
        // Arrange
        var op = new FileOperation { Status = status, Type = type };

        // Act & Assert
        Assert.Equal(expected, op.CanApply);
    }

    [Fact]
    public void IsCompleted_TrueForTerminalStates()
    {
        // Arrange & Act & Assert
        Assert.True(new FileOperation
            { Status = FileOperationStatus.Applied }.IsCompleted);
        Assert.True(new FileOperation
            { Status = FileOperationStatus.Failed }.IsCompleted);
        Assert.True(new FileOperation
            { Status = FileOperationStatus.Skipped }.IsCompleted);
        Assert.False(new FileOperation
            { Status = FileOperationStatus.Pending }.IsCompleted);
        Assert.False(new FileOperation
            { Status = FileOperationStatus.InProgress }.IsCompleted);
    }

    #endregion

    #region Factory Method Tests

    [Fact]
    public void FromCodeBlock_CreatesCorrectOperation()
    {
        // Arrange
        var blockId = Guid.NewGuid();
        var block = new CodeBlock
        {
            Id = blockId,
            TargetFilePath = "src/Test.cs",
            Content = "public class Test { }",
            Language = "csharp",
            DisplayLanguage = "C#"
        };

        // Act
        var op = FileOperation.FromCodeBlock(block, order: 5);

        // Assert
        Assert.Equal("src/Test.cs", op.Path);
        Assert.Equal(FileOperationType.Create, op.Type);
        Assert.Equal("public class Test { }", op.Content);
        Assert.Equal(blockId, op.CodeBlockId);
        Assert.Equal("csharp", op.Language);
        Assert.Equal("C#", op.DisplayLanguage);
        Assert.Equal(5, op.Order);
    }

    [Fact]
    public void CreateDirectory_CreatesDirectoryOperation()
    {
        // Arrange & Act
        var op = FileOperation.CreateDirectory("src/Models", order: 0);

        // Assert
        Assert.Equal("src/Models", op.Path);
        Assert.Equal(FileOperationType.CreateDirectory, op.Type);
        Assert.Null(op.Content);
    }

    [Fact]
    public void Rename_CreatesRenameOperation()
    {
        // Arrange & Act
        var op = FileOperation.Rename("old.cs", "new.cs", order: 1);

        // Assert
        Assert.Equal("old.cs", op.Path);
        Assert.Equal("new.cs", op.NewPath);
        Assert.Equal(FileOperationType.Rename, op.Type);
    }

    #endregion

    #region Display Property Tests

    [Theory]
    [InlineData(FileOperationType.Create, "add_circle")]
    [InlineData(FileOperationType.Modify, "edit")]
    [InlineData(FileOperationType.Delete, "delete")]
    [InlineData(FileOperationType.CreateDirectory, "create_new_folder")]
    public void OperationIcon_ReturnsCorrectIcon(
        FileOperationType type,
        string expectedIcon)
    {
        // Arrange
        var op = new FileOperation { Type = type };

        // Act & Assert
        Assert.Equal(expectedIcon, op.OperationIcon);
    }

    #endregion
}

// tests/SeniorIntern.Core.Tests/Models/BatchApplyResultTests.cs
namespace SeniorIntern.Core.Tests.Models;

public class BatchApplyResultTests
{
    [Fact]
    public void Success_CreatesSuccessfulResult()
    {
        // Arrange
        var startedAt = DateTime.UtcNow.AddSeconds(-5);
        var results = new[]
        {
            ApplyResult.Succeeded("path1.cs", "backup1"),
            ApplyResult.Succeeded("path2.cs", "backup2")
        };

        // Act
        var batch = BatchApplyResult.Success(results, startedAt);

        // Assert
        Assert.True(batch.AllSucceeded);
        Assert.Equal(2, batch.SuccessCount);
        Assert.Equal(0, batch.FailedCount);
        Assert.Equal(2, batch.TotalCount);
        Assert.Equal(100, batch.SuccessRate);
        Assert.Equal(2, batch.BackupPaths.Count);
    }

    [Fact]
    public void PartialSuccess_TracksFailures()
    {
        // Arrange
        var startedAt = DateTime.UtcNow.AddSeconds(-3);
        var results = new[]
        {
            ApplyResult.Succeeded("path1.cs", "backup1"),
            ApplyResult.Failed("path2.cs", "Error message")
        };

        // Act
        var batch = BatchApplyResult.PartialSuccess(results, startedAt);

        // Assert
        Assert.False(batch.AllSucceeded);
        Assert.Equal(1, batch.SuccessCount);
        Assert.Equal(1, batch.FailedCount);
        Assert.Single(batch.FailedResults);
        Assert.Single(batch.SucceededResults);
    }

    [Fact]
    public void Cancelled_SetsWasCancelledFlag()
    {
        // Arrange
        var startedAt = DateTime.UtcNow;
        var completed = Array.Empty<ApplyResult>();

        // Act
        var batch = BatchApplyResult.Cancelled(completed, startedAt);

        // Assert
        Assert.True(batch.WasCancelled);
        Assert.False(batch.AllSucceeded);
    }

    [Fact]
    public void Duration_CalculatesTimeSpan()
    {
        // Arrange
        var startedAt = new DateTime(2024, 1, 1, 12, 0, 0, DateTimeKind.Utc);
        var completedAt = new DateTime(2024, 1, 1, 12, 0, 10, DateTimeKind.Utc);

        var batch = new BatchApplyResult
        {
            StartedAt = startedAt,
            CompletedAt = completedAt
        };

        // Act & Assert
        Assert.Equal(TimeSpan.FromSeconds(10), batch.Duration);
    }
}

// tests/SeniorIntern.Core.Tests/Models/ProposalValidationTests.cs
namespace SeniorIntern.Core.Tests.Models;

public class ProposalValidationTests
{
    [Fact]
    public void Valid_CreatesValidResult()
    {
        // Arrange & Act
        var result = ProposalValidationResult.Valid();

        // Assert
        Assert.True(result.IsValid);
        Assert.Empty(result.Issues);
        Assert.False(result.HasErrors);
        Assert.False(result.HasWarnings);
    }

    [Fact]
    public void Invalid_CreatesInvalidResult()
    {
        // Arrange
        var error = ValidationIssue.InvalidPath("bad/path", "Contains invalid chars");

        // Act
        var result = ProposalValidationResult.Invalid(error);

        // Assert
        Assert.False(result.IsValid);
        Assert.Single(result.Issues);
        Assert.True(result.HasErrors);
    }

    [Fact]
    public void Errors_FiltersCorrectly()
    {
        // Arrange
        var issues = new[]
        {
            new ValidationIssue { Severity = ValidationSeverity.Error },
            new ValidationIssue { Severity = ValidationSeverity.Warning },
            new ValidationIssue { Severity = ValidationSeverity.Error }
        };
        var result = new ProposalValidationResult { Issues = issues };

        // Act & Assert
        Assert.Equal(2, result.ErrorCount);
        Assert.Equal(1, result.WarningCount);
    }

    [Fact]
    public void GetIssuesForPath_ReturnsMatchingIssues()
    {
        // Arrange
        var issues = new[]
        {
            new ValidationIssue { Path = "file1.cs", Type = ValidationIssueType.FileExists },
            new ValidationIssue { Path = "file1.cs", Type = ValidationIssueType.EmptyContent },
            new ValidationIssue { Path = "file2.cs", Type = ValidationIssueType.InvalidPath }
        };
        var result = new ProposalValidationResult { Issues = issues };

        // Act
        var file1Issues = result.GetIssuesForPath("file1.cs").ToList();

        // Assert
        Assert.Equal(2, file1Issues.Count);
    }

    [Fact]
    public void ValidationIssue_FactoryMethods_CreateCorrectIssues()
    {
        // Arrange & Act
        var fileExists = ValidationIssue.FileExists("test.cs");
        var invalidPath = ValidationIssue.InvalidPath("bad", "reason");
        var permDenied = ValidationIssue.PermissionDenied("protected.cs");

        // Assert
        Assert.Equal(ValidationIssueType.FileExists, fileExists.Type);
        Assert.Equal(ValidationSeverity.Warning, fileExists.Severity);

        Assert.Equal(ValidationIssueType.InvalidPath, invalidPath.Type);
        Assert.Equal(ValidationSeverity.Error, invalidPath.Severity);

        Assert.Equal(ValidationIssueType.PermissionDenied, permDenied.Type);
        Assert.Equal(ValidationSeverity.Error, permDenied.Severity);
    }
}

// tests/SeniorIntern.Core.Tests/Models/BatchApplyProgressTests.cs
namespace SeniorIntern.Core.Tests.Models;

public class BatchApplyProgressTests
{
    [Theory]
    [InlineData(10, 0, 0)]
    [InlineData(10, 5, 50)]
    [InlineData(10, 10, 100)]
    [InlineData(0, 0, 0)]
    public void ProgressPercent_CalculatesCorrectly(
        int total,
        int completed,
        double expectedPercent)
    {
        // Arrange
        var progress = new BatchApplyProgress
        {
            TotalOperations = total,
            CompletedOperations = completed
        };

        // Act & Assert
        Assert.Equal(expectedPercent, progress.ProgressPercent);
    }

    [Fact]
    public void RemainingOperations_CalculatesCorrectly()
    {
        // Arrange
        var progress = new BatchApplyProgress
        {
            TotalOperations = 10,
            CompletedOperations = 3
        };

        // Act & Assert
        Assert.Equal(7, progress.RemainingOperations);
    }

    [Theory]
    [InlineData(BatchApplyPhase.Validating, "Validating operations...")]
    [InlineData(BatchApplyPhase.WritingFiles, "Writing files (5/10)...")]
    [InlineData(BatchApplyPhase.Completed, "Completed")]
    public void PhaseDescription_ReturnsCorrectText(
        BatchApplyPhase phase,
        string expectedContains)
    {
        // Arrange
        var progress = new BatchApplyProgress
        {
            Phase = phase,
            CompletedOperations = 5,
            TotalOperations = 10
        };

        // Act
        var description = progress.PhaseDescription;

        // Assert
        Assert.Contains(expectedContains.Split(' ')[0], description);
    }
}
```

---

## Acceptance Criteria

- [ ] `FileTreeProposal` tracks all operations with unique IDs
- [ ] `FileTreeProposal` correctly computes file/directory counts
- [ ] `FileTreeProposal` tracks selection state for batch operations
- [ ] `FileTreeProposal` provides query methods for path/operation lookup
- [ ] `FileOperation` supports all operation types (Create, Modify, Delete, Rename, Move)
- [ ] `FileOperation` extracts path components correctly (FileName, Directory, Extension)
- [ ] `FileOperation` calculates content metrics (size, line count)
- [ ] `FileOperation.FromCodeBlock` factory method creates operations from code blocks
- [ ] `BatchApplyResult` aggregates individual results with success/failure counts
- [ ] `BatchApplyResult` tracks timing (start, completion, duration)
- [ ] `BatchApplyResult` supports undo tracking via backup paths
- [ ] `BatchApplyProgress` calculates progress percentage correctly
- [ ] `BatchApplyProgress` provides human-readable phase descriptions
- [ ] `ProposalValidationResult` separates errors from warnings
- [ ] `ProposalValidationResult` factory methods create valid/invalid results
- [ ] `ValidationIssue` factory methods create common issue types
- [ ] All models are immutable where appropriate (init-only properties)
- [ ] All enums have XML documentation for each value
- [ ] Unit tests achieve >90% code coverage

---

## Design Decisions

| Decision | Rationale | Alternatives Considered |
|----------|-----------|------------------------|
| Mutable `IsSelected` on FileOperation | Selection is a UI concern that changes frequently; immutable would require recreating operations | Separate selection tracking in ViewModel |
| Mutable `Status` on FileOperation | Status changes during batch apply; avoids recreating models | Immutable with new instances for each state change |
| Computed properties for counts | Avoids stale data; always accurate from source | Cached counts with invalidation logic |
| Factory methods on result types | Enforces valid construction patterns | Constructors with validation |
| Separate validation issue types | Fine-grained categorization for UI display and handling | Single generic "ValidationError" type |
| Path normalization to forward slashes | Cross-platform consistency | Platform-specific paths |
| UTF-8 byte counting for size | Accurate disk size representation | Character count (misleading for multi-byte) |
| Guid IDs for all entities | Enables linking between models across layers | Integer IDs, string IDs |

---

## Accessibility Considerations

- All display text properties return screen-reader-friendly descriptions
- Icon names follow standard icon library naming for assistive technology
- Severity levels map to ARIA alert roles (error → alert, warning → status)
- Status messages are complete sentences suitable for announcement

---

## Performance Considerations

| Concern | Mitigation |
|---------|------------|
| LINQ queries on Operations | Operations list is typically small (<100); no caching needed |
| Repeated directory enumeration | Directories property uses LINQ; call sparingly or cache result |
| UTF-8 byte counting | Only calculated on demand via computed property |
| Large content strings | Content is reference type; no copying on model access |

---

## Future Enhancements

1. **Dependency Graph**: Add explicit dependency tracking between operations
2. **Conflict Resolution Options**: Add user preferences for handling existing files
3. **Template Support**: Allow operations to reference template content
4. **Rollback Groups**: Group operations for atomic rollback
5. **Progress Estimation**: Machine learning for operation time estimation
6. **Compression**: Support for compressed content in large proposals

---

## Related Specifications

| Specification | Relationship |
|---------------|--------------|
| v0.4.1 (Code Block Extraction) | Provides `CodeBlock` model for `FromCodeBlock` factory |
| v0.4.3a (Apply Core Models) | Provides `ApplyResult` used in `BatchApplyResult` |
| v0.4.4b (File Tree Parser) | Consumer of these models |
| v0.4.4c (Proposal Service) | Consumer of these models |
| v0.4.4d (Tree ViewModels) | Wraps these models for UI binding |
