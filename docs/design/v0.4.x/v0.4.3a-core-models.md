# v0.4.3a: Core Models - Design Specification

**Status**: _IMPLEMENTED_

## Executive Summary

This specification details the **Core Models** for The Senior Intern's Apply Changes Workflow, defining the data structures that represent apply operations, results, change tracking, and events. These models form the foundation for the entire v0.4.3 sub-system, establishing contracts used by the file change service, backup system, undo mechanism, and UI components.

### Key Deliverables

| Component | Type | Purpose |
|-----------|------|---------|
| `ApplyOptions` | Record | Configuration for apply operations |
| `ApplyResult` | Class | Result of an apply operation |
| `ApplyResultType` | Enum | Categorization of apply outcomes |
| `FileChangeRecord` | Class | Undo tracking and change history |
| `FileChangeType` | Enum | Type of file modification |
| `ApplyPreview` | Class | Preview of apply operation effects |
| `ConflictCheckResult` | Class | Result of conflict detection |
| `ApplyEvents` | Events | Event args for apply-related events |

---

## Feature Overview

```
v0.4.3a: Core Models
├── Configuration Models
│   └── ApplyOptions
│       ├── CreateBackup (default: true)
│       ├── AllowConflictOverwrite (default: false)
│       ├── RefreshEditorAfterApply (default: true)
│       ├── UndoWindow (default: 30 minutes)
│       ├── ShowConfirmationDialog (default: true)
│       ├── ValidateEncoding (default: true)
│       ├── PreserveLineEndings (default: true)
│       ├── CreateParentDirectories (default: true)
│       └── Static Presets (Default, Silent)
├── Result Models
│   ├── ApplyResult
│   │   ├── Success/Failure state
│   │   ├── File paths (absolute, relative)
│   │   ├── Backup path
│   │   ├── ResultType enumeration
│   │   ├── Error information
│   │   ├── Applied diff reference
│   │   ├── Timestamps
│   │   └── Factory methods (Succeeded, Failed)
│   ├── ApplyResultType (11 values)
│   │   ├── Success states: Success, Created, Modified
│   │   └── Failure states: Conflict, FileNotFound, PermissionDenied, etc.
│   ├── ApplyPreview
│   │   ├── Diff preview
│   │   ├── Potential conflicts
│   │   ├── File existence
│   │   └── Permission status
│   └── ConflictCheckResult
│       ├── HasConflict flag
│       ├── Expected vs actual hash
│       ├── File modification times
│       └── Conflict description
├── Change Tracking Models
│   ├── FileChangeRecord
│   │   ├── Unique ID
│   │   ├── File paths
│   │   ├── Backup path
│   │   ├── Timestamps
│   │   ├── Change type
│   │   ├── Code block reference
│   │   ├── Content hashes
│   │   └── Undo time calculations
│   └── FileChangeType (4 values)
│       └── Created, Modified, Deleted, Renamed
└── Event Models
    ├── FileChangedEventArgs
    ├── FileChangeFailedEventArgs
    ├── FileChangeUndoneEventArgs
    └── FileConflictDetectedEventArgs
```

---

## Architecture Diagrams

### Model Relationships

```
┌─────────────────────────────────────────────────────────────────────┐
│                         Apply Workflow Models                        │
└─────────────────────────────────────────────────────────────────────┘

                              INPUT
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│                          ApplyOptions                                │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │  Configuration for apply behavior                            │    │
│  │  • Backup, Undo, Dialog, Encoding, Line Endings settings    │    │
│  └─────────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────────┘
                                │
                         Apply Operation
                                │
                    ┌───────────┴───────────┐
                    │                       │
                    ▼                       ▼
┌───────────────────────────┐    ┌───────────────────────────┐
│      ApplyPreview         │    │    ConflictCheckResult    │
│  ┌─────────────────────┐  │    │  ┌─────────────────────┐  │
│  │ Pre-apply preview   │  │    │  │ Conflict detection  │  │
│  │ • DiffResult        │  │    │  │ • HasConflict       │  │
│  │ • TargetExists      │  │    │  │ • ExpectedHash      │  │
│  │ • HasConflict       │  │    │  │ • ActualHash        │  │
│  │ • CanWrite          │  │    │  │ • Description       │  │
│  └─────────────────────┘  │    │  └─────────────────────┘  │
└───────────────────────────┘    └───────────────────────────┘
                    │                       │
                    └───────────┬───────────┘
                                │
                           File Write
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│                          ApplyResult                                 │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │  Result of apply operation                                   │    │
│  │  • Success, FilePath, BackupPath, ResultType, Error         │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                              │                                       │
│              ┌───────────────┴───────────────┐                      │
│              ▼                               ▼                      │
│  ┌─────────────────────┐         ┌─────────────────────┐           │
│  │  ApplyResultType    │         │  FileChangeRecord   │           │
│  │  (enum)             │         │  (undo tracking)    │           │
│  │  • Success          │         │  • Id               │           │
│  │  • Created          │         │  • FilePath         │           │
│  │  • Modified         │         │  • BackupPath       │           │
│  │  • Conflict         │         │  • ChangedAt        │           │
│  │  • Error states...  │         │  • ChangeType       │           │
│  └─────────────────────┘         │  • ContentHashes    │           │
│                                  └─────────────────────┘           │
└─────────────────────────────────────────────────────────────────────┘
                                │
                           Events
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│                          Apply Events                                │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐     │
│  │FileChangedEvent │  │FileChangeFailed │  │FileChangeUndone │     │
│  │Args             │  │EventArgs        │  │EventArgs        │     │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘     │
│  ┌─────────────────┐                                                │
│  │FileConflict     │                                                │
│  │DetectedEventArgs│                                                │
│  └─────────────────┘                                                │
└─────────────────────────────────────────────────────────────────────┘
```

### State Transitions

```
┌─────────────────────────────────────────────────────────────────────┐
│                    ApplyResultType State Machine                     │
└─────────────────────────────────────────────────────────────────────┘

                    ┌───────────────────┐
                    │    Start Apply    │
                    └─────────┬─────────┘
                              │
              ┌───────────────┼───────────────┐
              │               │               │
              ▼               ▼               ▼
       ┌──────────┐    ┌──────────┐    ┌──────────┐
       │Validation│    │  Check   │    │  Check   │
       │  Failed  │    │  Target  │    │ Conflict │
       └────┬─────┘    └────┬─────┘    └────┬─────┘
            │               │               │
            ▼               ▼               ▼
    ┌───────────────┐ ┌───────────┐  ┌───────────┐
    │Validation     │ │FileNot    │  │ Conflict  │
    │Failed         │ │Found      │  │ Detected  │
    └───────────────┘ └───────────┘  └─────┬─────┘
                                           │
                           ┌───────────────┴───────────────┐
                           │ AllowConflictOverwrite?       │
                           └───────────────┬───────────────┘
                                    No     │     Yes
                           ┌───────────────┴───────────────┐
                           ▼                               ▼
                    ┌──────────┐                    ┌──────────┐
                    │ Conflict │                    │ Continue │
                    │ (abort)  │                    │  Apply   │
                    └──────────┘                    └────┬─────┘
                                                        │
                              ┌──────────────────────────┘
                              │
              ┌───────────────┼───────────────┐
              │               │               │
              ▼               ▼               ▼
       ┌──────────┐    ┌──────────┐    ┌──────────┐
       │Permission│    │   File   │    │   Disk   │
       │  Check   │    │   Lock   │    │   Space  │
       └────┬─────┘    └────┬─────┘    └────┬─────┘
            │               │               │
     ┌──────┴──────┐ ┌──────┴──────┐ ┌──────┴──────┐
     │Permission   │ │FileLocked   │ │DiskFull     │
     │Denied       │ │             │ │             │
     └─────────────┘ └─────────────┘ └─────────────┘
            │
            │ (all checks pass)
            ▼
    ┌───────────────────────────────────────┐
    │            Write File                  │
    └───────────────────┬───────────────────┘
                        │
        ┌───────────────┼───────────────┐
        │               │               │
        ▼               ▼               ▼
  ┌──────────┐   ┌──────────┐    ┌──────────┐
  │ Created  │   │ Modified │    │  Error   │
  │ (new)    │   │ (exists) │    │(generic) │
  └──────────┘   └──────────┘    └──────────┘
        │               │
        └───────┬───────┘
                ▼
         ┌──────────┐
         │ Success  │
         └──────────┘
```

### Undo Time Window

```
┌─────────────────────────────────────────────────────────────────────┐
│                    Undo Window Timeline                              │
└─────────────────────────────────────────────────────────────────────┘

Change Applied                                    Undo Expires
     │                                                 │
     ▼                                                 ▼
     ├─────────────────────────────────────────────────┤
     │◄────────────── UndoWindow (30 min) ────────────►│
     │                                                 │
     │  ┌──────────────────────────────────────────┐  │
     │  │         CanUndo = true                   │  │
     │  │         GetUndoTimeRemaining() > 0       │  │
     │  │         IsUndoExpired() = false          │  │
     │  └──────────────────────────────────────────┘  │
     │                                                 │
     └─────────────────────────────────────────────────┘
                                                       │
                                                       ▼
                                        ┌──────────────────────────┐
                                        │  CanUndo = false         │
                                        │  GetUndoTimeRemaining()=0│
                                        │  IsUndoExpired() = true  │
                                        │  Backup cleaned up       │
                                        └──────────────────────────┘
```

---

## Detailed Design

### ApplyOptions Record

```csharp
// src/SeniorIntern.Core/Models/ApplyOptions.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Configuration options for applying code changes to files.
/// Immutable record with sensible defaults.
/// </summary>
public sealed record ApplyOptions
{
    #region Backup Options

    /// <summary>
    /// Whether to create a backup before modifying the file.
    /// Enables undo functionality when true.
    /// </summary>
    public bool CreateBackup { get; init; } = true;

    /// <summary>
    /// Directory for storing backup files.
    /// If null, uses the default backup directory.
    /// </summary>
    public string? BackupDirectory { get; init; }

    #endregion

    #region Conflict Options

    /// <summary>
    /// Whether to allow overwriting when a conflict is detected.
    /// A conflict occurs when the file has been modified since the diff was computed.
    /// </summary>
    public bool AllowConflictOverwrite { get; init; } = false;

    /// <summary>
    /// Whether to check for conflicts before applying.
    /// Disabling this skips the hash verification step.
    /// </summary>
    public bool CheckForConflicts { get; init; } = true;

    #endregion

    #region Editor Integration Options

    /// <summary>
    /// Whether to refresh/reload the editor after applying changes.
    /// </summary>
    public bool RefreshEditorAfterApply { get; init; } = true;

    /// <summary>
    /// Whether to scroll to the first change after applying.
    /// </summary>
    public bool ScrollToFirstChange { get; init; } = true;

    #endregion

    #region Undo Options

    /// <summary>
    /// Time window during which undo is available.
    /// After this period, backups are eligible for cleanup.
    /// </summary>
    public TimeSpan UndoWindow { get; init; } = TimeSpan.FromMinutes(30);

    /// <summary>
    /// Maximum number of undo records to keep per file.
    /// Older records are pruned when this limit is exceeded.
    /// </summary>
    public int MaxUndoRecordsPerFile { get; init; } = 10;

    #endregion

    #region Dialog Options

    /// <summary>
    /// Whether to show a confirmation dialog before applying.
    /// </summary>
    public bool ShowConfirmationDialog { get; init; } = true;

    /// <summary>
    /// Whether to show a toast notification after successful apply.
    /// </summary>
    public bool ShowSuccessToast { get; init; } = true;

    /// <summary>
    /// Duration to show the success toast (with undo button).
    /// </summary>
    public TimeSpan ToastDuration { get; init; } = TimeSpan.FromSeconds(10);

    #endregion

    #region File Handling Options

    /// <summary>
    /// Validate that the file encoding can be detected and preserved.
    /// </summary>
    public bool ValidateEncoding { get; init; } = true;

    /// <summary>
    /// Preserve the original file's line ending style (CRLF, LF, CR).
    /// </summary>
    public bool PreserveLineEndings { get; init; } = true;

    /// <summary>
    /// Create parent directories if they don't exist (for new files).
    /// </summary>
    public bool CreateParentDirectories { get; init; } = true;

    /// <summary>
    /// Whether to preserve the original file's attributes (readonly, hidden, etc.).
    /// </summary>
    public bool PreserveFileAttributes { get; init; } = true;

    /// <summary>
    /// Whether to update the file's modification timestamp.
    /// If false, preserves the original timestamp.
    /// </summary>
    public bool UpdateTimestamp { get; init; } = true;

    #endregion

    #region Validation Options

    /// <summary>
    /// Maximum file size (in bytes) that can be modified.
    /// Prevents accidental modification of large binary files.
    /// </summary>
    public long MaxFileSizeBytes { get; init; } = 10 * 1024 * 1024; // 10 MB

    /// <summary>
    /// Whether to validate that the file appears to be a text file.
    /// </summary>
    public bool ValidateTextFile { get; init; } = true;

    /// <summary>
    /// File extensions to treat as binary (skip text validation).
    /// </summary>
    public IReadOnlySet<string> BinaryExtensions { get; init; } = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
    {
        ".exe", ".dll", ".so", ".dylib",
        ".png", ".jpg", ".jpeg", ".gif", ".bmp", ".ico",
        ".zip", ".tar", ".gz", ".7z", ".rar",
        ".pdf", ".doc", ".docx", ".xls", ".xlsx",
        ".sqlite", ".db"
    };

    #endregion

    #region Static Presets

    /// <summary>
    /// Default options with all safety features enabled.
    /// </summary>
    public static ApplyOptions Default => new();

    /// <summary>
    /// Options for silent apply (no dialogs, no backup).
    /// Use with caution - no undo capability.
    /// </summary>
    public static ApplyOptions Silent => new()
    {
        CreateBackup = false,
        ShowConfirmationDialog = false,
        ShowSuccessToast = false,
        CheckForConflicts = false
    };

    /// <summary>
    /// Options optimized for batch operations.
    /// Creates backups but skips dialogs for efficiency.
    /// </summary>
    public static ApplyOptions Batch => new()
    {
        CreateBackup = true,
        ShowConfirmationDialog = false,
        ShowSuccessToast = false,
        RefreshEditorAfterApply = false
    };

    /// <summary>
    /// Options with extended undo window (1 hour).
    /// </summary>
    public static ApplyOptions ExtendedUndo => new()
    {
        UndoWindow = TimeSpan.FromHours(1),
        MaxUndoRecordsPerFile = 20
    };

    #endregion

    #region Builder Methods

    /// <summary>
    /// Creates options with backup disabled.
    /// </summary>
    public ApplyOptions WithoutBackup() => this with { CreateBackup = false };

    /// <summary>
    /// Creates options with a custom undo window.
    /// </summary>
    public ApplyOptions WithUndoWindow(TimeSpan window) => this with { UndoWindow = window };

    /// <summary>
    /// Creates options that allow conflict overwrite.
    /// </summary>
    public ApplyOptions WithConflictOverwrite() => this with { AllowConflictOverwrite = true };

    /// <summary>
    /// Creates options with dialogs disabled.
    /// </summary>
    public ApplyOptions WithoutDialogs() => this with
    {
        ShowConfirmationDialog = false,
        ShowSuccessToast = false
    };

    #endregion
}
```

### ApplyResult Class

```csharp
// src/SeniorIntern.Core/Models/ApplyResult.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Result of applying a code change to a file.
/// Provides comprehensive information about the operation outcome.
/// </summary>
public sealed class ApplyResult
{
    #region Core Properties

    /// <summary>
    /// Whether the apply operation succeeded.
    /// </summary>
    public bool Success { get; init; }

    /// <summary>
    /// Type of result (success category or failure reason).
    /// </summary>
    public ApplyResultType ResultType { get; init; }

    /// <summary>
    /// Error message (populated when Success is false).
    /// </summary>
    public string? ErrorMessage { get; init; }

    /// <summary>
    /// Exception that caused the failure (if any).
    /// </summary>
    public Exception? Exception { get; init; }

    #endregion

    #region File Information

    /// <summary>
    /// Full absolute path to the affected file.
    /// </summary>
    public string FilePath { get; init; } = string.Empty;

    /// <summary>
    /// Relative path within the workspace.
    /// </summary>
    public string RelativePath { get; init; } = string.Empty;

    /// <summary>
    /// Path to the backup file (if created).
    /// </summary>
    public string? BackupPath { get; init; }

    /// <summary>
    /// File size after apply (in bytes).
    /// </summary>
    public long? FileSizeBytes { get; init; }

    /// <summary>
    /// Detected file encoding.
    /// </summary>
    public string? Encoding { get; init; }

    /// <summary>
    /// Detected line ending style.
    /// </summary>
    public LineEndingStyle? LineEndings { get; init; }

    #endregion

    #region Change Information

    /// <summary>
    /// The diff that was applied.
    /// </summary>
    public DiffResult? AppliedDiff { get; init; }

    /// <summary>
    /// When the change was applied.
    /// </summary>
    public DateTime AppliedAt { get; init; } = DateTime.UtcNow;

    /// <summary>
    /// ID of the code block that was applied.
    /// </summary>
    public Guid? CodeBlockId { get; init; }

    /// <summary>
    /// ID of the message containing the code block.
    /// </summary>
    public Guid? MessageId { get; init; }

    /// <summary>
    /// Number of lines added.
    /// </summary>
    public int LinesAdded { get; init; }

    /// <summary>
    /// Number of lines removed.
    /// </summary>
    public int LinesRemoved { get; init; }

    /// <summary>
    /// Number of lines modified.
    /// </summary>
    public int LinesModified { get; init; }

    #endregion

    #region Undo Information

    /// <summary>
    /// Whether undo is available for this change.
    /// </summary>
    public bool CanUndo { get; init; }

    /// <summary>
    /// ID of the change record (for undo operations).
    /// </summary>
    public Guid? ChangeRecordId { get; init; }

    /// <summary>
    /// When the undo capability expires.
    /// </summary>
    public DateTime? UndoExpiresAt { get; init; }

    #endregion

    #region Conflict Information

    /// <summary>
    /// Whether a conflict was detected and overwritten.
    /// </summary>
    public bool ConflictOverwritten { get; init; }

    /// <summary>
    /// Hash of the expected content (before apply).
    /// </summary>
    public string? ExpectedContentHash { get; init; }

    /// <summary>
    /// Hash of the actual content found.
    /// </summary>
    public string? ActualContentHash { get; init; }

    #endregion

    #region Factory Methods

    /// <summary>
    /// Creates a successful result for a modified file.
    /// </summary>
    public static ApplyResult Modified(
        string filePath,
        string relativePath,
        DiffResult? diff = null,
        string? backupPath = null,
        Guid? codeBlockId = null) => new()
    {
        Success = true,
        FilePath = filePath,
        RelativePath = relativePath,
        ResultType = ApplyResultType.Modified,
        AppliedDiff = diff,
        BackupPath = backupPath,
        CodeBlockId = codeBlockId,
        CanUndo = !string.IsNullOrEmpty(backupPath),
        LinesAdded = diff?.Stats?.LinesAdded ?? 0,
        LinesRemoved = diff?.Stats?.LinesRemoved ?? 0,
        LinesModified = diff?.Stats?.LinesModified ?? 0
    };

    /// <summary>
    /// Creates a successful result for a newly created file.
    /// </summary>
    public static ApplyResult Created(
        string filePath,
        string relativePath,
        string? backupPath = null,
        Guid? codeBlockId = null,
        int linesAdded = 0) => new()
    {
        Success = true,
        FilePath = filePath,
        RelativePath = relativePath,
        ResultType = ApplyResultType.Created,
        BackupPath = backupPath,
        CodeBlockId = codeBlockId,
        CanUndo = true, // Can always undo creates by deleting
        LinesAdded = linesAdded
    };

    /// <summary>
    /// Creates a successful result (generic).
    /// </summary>
    public static ApplyResult Succeeded(
        string filePath,
        string relativePath,
        ApplyResultType type,
        DiffResult? diff = null,
        string? backupPath = null) => new()
    {
        Success = true,
        FilePath = filePath,
        RelativePath = relativePath,
        ResultType = type,
        AppliedDiff = diff,
        BackupPath = backupPath,
        CanUndo = !string.IsNullOrEmpty(backupPath)
    };

    /// <summary>
    /// Creates a failed result.
    /// </summary>
    public static ApplyResult Failed(
        string filePath,
        ApplyResultType type,
        string errorMessage,
        Exception? exception = null) => new()
    {
        Success = false,
        FilePath = filePath,
        ResultType = type,
        ErrorMessage = errorMessage,
        Exception = exception,
        CanUndo = false
    };

    /// <summary>
    /// Creates a conflict result.
    /// </summary>
    public static ApplyResult Conflict(
        string filePath,
        string relativePath,
        string expectedHash,
        string actualHash,
        string description) => new()
    {
        Success = false,
        FilePath = filePath,
        RelativePath = relativePath,
        ResultType = ApplyResultType.Conflict,
        ErrorMessage = description,
        ExpectedContentHash = expectedHash,
        ActualContentHash = actualHash,
        CanUndo = false
    };

    /// <summary>
    /// Creates a cancelled result.
    /// </summary>
    public static ApplyResult Cancelled(string filePath) => new()
    {
        Success = false,
        FilePath = filePath,
        ResultType = ApplyResultType.Cancelled,
        ErrorMessage = "Operation was cancelled by the user.",
        CanUndo = false
    };

    #endregion

    #region Helper Methods

    /// <summary>
    /// Gets a human-readable summary of the result.
    /// </summary>
    public string GetSummary()
    {
        if (Success)
        {
            var changes = new List<string>();
            if (LinesAdded > 0) changes.Add($"+{LinesAdded}");
            if (LinesRemoved > 0) changes.Add($"-{LinesRemoved}");
            if (LinesModified > 0) changes.Add($"~{LinesModified}");

            var changeSummary = changes.Count > 0
                ? $" ({string.Join(", ", changes)})"
                : string.Empty;

            return ResultType switch
            {
                ApplyResultType.Created => $"Created {RelativePath}{changeSummary}",
                ApplyResultType.Modified => $"Modified {RelativePath}{changeSummary}",
                _ => $"Applied changes to {RelativePath}{changeSummary}"
            };
        }

        return $"Failed to apply changes to {RelativePath}: {ErrorMessage}";
    }

    /// <summary>
    /// Gets the file name from the file path.
    /// </summary>
    public string FileName => Path.GetFileName(FilePath);

    /// <summary>
    /// Gets whether this result represents a new file creation.
    /// </summary>
    public bool IsNewFile => ResultType == ApplyResultType.Created;

    /// <summary>
    /// Gets whether this result represents a failure that can be retried.
    /// </summary>
    public bool IsRetryable => ResultType is
        ApplyResultType.FileLocked or
        ApplyResultType.Conflict or
        ApplyResultType.PermissionDenied;

    #endregion
}

/// <summary>
/// Type of apply result indicating success category or failure reason.
/// </summary>
public enum ApplyResultType
{
    /// <summary>
    /// Successfully applied changes (generic success).
    /// </summary>
    Success = 0,

    /// <summary>
    /// Successfully created a new file.
    /// </summary>
    Created = 1,

    /// <summary>
    /// Successfully modified an existing file.
    /// </summary>
    Modified = 2,

    /// <summary>
    /// Conflict detected - file was modified since the diff was computed.
    /// </summary>
    Conflict = 10,

    /// <summary>
    /// Target file was not found.
    /// </summary>
    FileNotFound = 11,

    /// <summary>
    /// Permission denied to write file.
    /// </summary>
    PermissionDenied = 12,

    /// <summary>
    /// Validation failed (e.g., invalid path, binary file).
    /// </summary>
    ValidationFailed = 13,

    /// <summary>
    /// Operation was cancelled by user.
    /// </summary>
    Cancelled = 14,

    /// <summary>
    /// File is locked by another process.
    /// </summary>
    FileLocked = 15,

    /// <summary>
    /// Disk is full or quota exceeded.
    /// </summary>
    DiskFull = 16,

    /// <summary>
    /// Path is outside the allowed workspace.
    /// </summary>
    PathOutsideWorkspace = 17,

    /// <summary>
    /// Unknown error occurred.
    /// </summary>
    Error = 99
}

/// <summary>
/// Line ending styles for file handling.
/// </summary>
public enum LineEndingStyle
{
    /// <summary>
    /// Unix-style line endings (LF).
    /// </summary>
    LF,

    /// <summary>
    /// Windows-style line endings (CRLF).
    /// </summary>
    CRLF,

    /// <summary>
    /// Old Mac-style line endings (CR).
    /// </summary>
    CR,

    /// <summary>
    /// Mixed line endings detected.
    /// </summary>
    Mixed,

    /// <summary>
    /// Unknown or no line endings (single-line file).
    /// </summary>
    Unknown
}
```

### FileChangeRecord Class

```csharp
// src/SeniorIntern.Core/Models/FileChangeRecord.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Record of a file change for undo tracking and history.
/// </summary>
public sealed class FileChangeRecord
{
    #region Identity

    /// <summary>
    /// Unique identifier for this change.
    /// </summary>
    public Guid Id { get; init; } = Guid.NewGuid();

    #endregion

    #region File Information

    /// <summary>
    /// Full absolute path to the changed file.
    /// </summary>
    public string FilePath { get; init; } = string.Empty;

    /// <summary>
    /// Relative path within the workspace.
    /// </summary>
    public string RelativePath { get; init; } = string.Empty;

    /// <summary>
    /// Path to the backup file (for undo).
    /// Required for Modified/Deleted changes, null for Created.
    /// </summary>
    public string? BackupPath { get; init; }

    /// <summary>
    /// Path to the new file (for rename tracking).
    /// </summary>
    public string? NewFilePath { get; init; }

    #endregion

    #region Timestamps

    /// <summary>
    /// When the change was made.
    /// </summary>
    public DateTime ChangedAt { get; init; } = DateTime.UtcNow;

    /// <summary>
    /// Original file modification time before the change.
    /// </summary>
    public DateTime? OriginalModifiedAt { get; init; }

    #endregion

    #region Change Information

    /// <summary>
    /// Type of change that was made.
    /// </summary>
    public FileChangeType ChangeType { get; init; }

    /// <summary>
    /// ID of the code block that generated this change.
    /// </summary>
    public Guid? CodeBlockId { get; init; }

    /// <summary>
    /// ID of the message containing the code block.
    /// </summary>
    public Guid? MessageId { get; init; }

    /// <summary>
    /// ID of the conversation containing the message.
    /// </summary>
    public Guid? ConversationId { get; init; }

    /// <summary>
    /// Human-readable description of the change.
    /// </summary>
    public string? Description { get; init; }

    #endregion

    #region Content Hashes

    /// <summary>
    /// SHA-256 hash of the original content (before change).
    /// Used for verification during undo.
    /// </summary>
    public string? OriginalContentHash { get; init; }

    /// <summary>
    /// SHA-256 hash of the new content (after change).
    /// Used for conflict detection.
    /// </summary>
    public string? NewContentHash { get; init; }

    /// <summary>
    /// Original file size in bytes.
    /// </summary>
    public long? OriginalSizeBytes { get; init; }

    /// <summary>
    /// New file size in bytes.
    /// </summary>
    public long? NewSizeBytes { get; init; }

    #endregion

    #region Undo State

    /// <summary>
    /// Whether undo has been performed for this change.
    /// </summary>
    public bool IsUndone { get; set; }

    /// <summary>
    /// When the undo was performed.
    /// </summary>
    public DateTime? UndoneAt { get; set; }

    #endregion

    #region Statistics

    /// <summary>
    /// Number of lines added in this change.
    /// </summary>
    public int LinesAdded { get; init; }

    /// <summary>
    /// Number of lines removed in this change.
    /// </summary>
    public int LinesRemoved { get; init; }

    /// <summary>
    /// Number of lines modified in this change.
    /// </summary>
    public int LinesModified { get; init; }

    #endregion

    #region Undo Time Calculations

    /// <summary>
    /// Calculates the time remaining for undo based on the configured window.
    /// </summary>
    /// <param name="undoWindow">The configured undo time window.</param>
    /// <returns>Time remaining, or TimeSpan.Zero if expired.</returns>
    public TimeSpan GetUndoTimeRemaining(TimeSpan undoWindow)
    {
        if (IsUndone)
        {
            return TimeSpan.Zero;
        }

        var elapsed = DateTime.UtcNow - ChangedAt;
        var remaining = undoWindow - elapsed;
        return remaining > TimeSpan.Zero ? remaining : TimeSpan.Zero;
    }

    /// <summary>
    /// Checks if the undo window has expired.
    /// </summary>
    /// <param name="undoWindow">The configured undo time window.</param>
    /// <returns>True if undo is no longer available.</returns>
    public bool IsUndoExpired(TimeSpan undoWindow)
    {
        return IsUndone || DateTime.UtcNow - ChangedAt > undoWindow;
    }

    /// <summary>
    /// Gets whether undo is currently available.
    /// </summary>
    /// <param name="undoWindow">The configured undo time window.</param>
    /// <returns>True if undo can be performed.</returns>
    public bool CanUndo(TimeSpan undoWindow)
    {
        if (IsUndone)
        {
            return false;
        }

        if (string.IsNullOrEmpty(BackupPath) && ChangeType != FileChangeType.Created)
        {
            return false;
        }

        return !IsUndoExpired(undoWindow);
    }

    /// <summary>
    /// Gets the percentage of undo time remaining (0-100).
    /// </summary>
    /// <param name="undoWindow">The configured undo time window.</param>
    /// <returns>Percentage of time remaining.</returns>
    public double GetUndoTimeRemainingPercent(TimeSpan undoWindow)
    {
        if (undoWindow <= TimeSpan.Zero)
        {
            return 0;
        }

        var remaining = GetUndoTimeRemaining(undoWindow);
        return (remaining.TotalMilliseconds / undoWindow.TotalMilliseconds) * 100;
    }

    #endregion

    #region Helper Methods

    /// <summary>
    /// Gets a human-readable summary of the change.
    /// </summary>
    public string GetSummary()
    {
        var action = ChangeType switch
        {
            FileChangeType.Created => "Created",
            FileChangeType.Modified => "Modified",
            FileChangeType.Deleted => "Deleted",
            FileChangeType.Renamed => "Renamed",
            _ => "Changed"
        };

        return $"{action} {RelativePath}";
    }

    /// <summary>
    /// Gets the file name from the file path.
    /// </summary>
    public string FileName => Path.GetFileName(FilePath);

    /// <summary>
    /// Gets a formatted time since the change.
    /// </summary>
    public string GetTimeSinceChange()
    {
        var elapsed = DateTime.UtcNow - ChangedAt;

        if (elapsed.TotalSeconds < 60)
            return "just now";
        if (elapsed.TotalMinutes < 60)
            return $"{(int)elapsed.TotalMinutes}m ago";
        if (elapsed.TotalHours < 24)
            return $"{(int)elapsed.TotalHours}h ago";
        return $"{(int)elapsed.TotalDays}d ago";
    }

    #endregion
}

/// <summary>
/// Type of file change for categorization.
/// </summary>
public enum FileChangeType
{
    /// <summary>
    /// A new file was created.
    /// </summary>
    Created = 0,

    /// <summary>
    /// An existing file was modified.
    /// </summary>
    Modified = 1,

    /// <summary>
    /// A file was deleted.
    /// </summary>
    Deleted = 2,

    /// <summary>
    /// A file was renamed or moved.
    /// </summary>
    Renamed = 3
}
```

### ApplyPreview Class

```csharp
// src/SeniorIntern.Core/Models/ApplyPreview.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Preview of what will happen when applying a code change.
/// Used to display information in confirmation dialogs.
/// </summary>
public sealed class ApplyPreview
{
    #region Target Information

    /// <summary>
    /// Full path to the target file.
    /// </summary>
    public string FilePath { get; init; } = string.Empty;

    /// <summary>
    /// Relative path within the workspace.
    /// </summary>
    public string RelativePath { get; init; } = string.Empty;

    /// <summary>
    /// Whether the target file currently exists.
    /// </summary>
    public bool TargetExists { get; init; }

    /// <summary>
    /// Whether parent directories need to be created.
    /// </summary>
    public bool RequiresDirectoryCreation { get; init; }

    #endregion

    #region Diff Information

    /// <summary>
    /// The computed diff showing the changes.
    /// </summary>
    public DiffResult? Diff { get; init; }

    /// <summary>
    /// Number of lines that will be added.
    /// </summary>
    public int LinesAdded { get; init; }

    /// <summary>
    /// Number of lines that will be removed.
    /// </summary>
    public int LinesRemoved { get; init; }

    /// <summary>
    /// Number of lines that will be modified.
    /// </summary>
    public int LinesModified { get; init; }

    /// <summary>
    /// Number of hunks (change blocks) in the diff.
    /// </summary>
    public int HunkCount { get; init; }

    #endregion

    #region Conflict Information

    /// <summary>
    /// Whether a conflict was detected.
    /// </summary>
    public bool HasConflict { get; init; }

    /// <summary>
    /// Description of the conflict (if any).
    /// </summary>
    public string? ConflictDescription { get; init; }

    /// <summary>
    /// When the file was last modified (for conflict context).
    /// </summary>
    public DateTime? FileLastModified { get; init; }

    #endregion

    #region Permission Information

    /// <summary>
    /// Whether the file can be written.
    /// </summary>
    public bool CanWrite { get; init; }

    /// <summary>
    /// Whether the file is locked by another process.
    /// </summary>
    public bool IsLocked { get; init; }

    /// <summary>
    /// Whether the file is marked as read-only.
    /// </summary>
    public bool IsReadOnly { get; init; }

    /// <summary>
    /// Reason why write is not possible (if applicable).
    /// </summary>
    public string? WriteBlockedReason { get; init; }

    #endregion

    #region Size Information

    /// <summary>
    /// Current file size in bytes (if exists).
    /// </summary>
    public long? CurrentSizeBytes { get; init; }

    /// <summary>
    /// Estimated file size after apply.
    /// </summary>
    public long? EstimatedNewSizeBytes { get; init; }

    /// <summary>
    /// Change in file size.
    /// </summary>
    public long SizeChangeBytes => (EstimatedNewSizeBytes ?? 0) - (CurrentSizeBytes ?? 0);

    #endregion

    #region Encoding Information

    /// <summary>
    /// Detected file encoding.
    /// </summary>
    public string? DetectedEncoding { get; init; }

    /// <summary>
    /// Detected line ending style.
    /// </summary>
    public LineEndingStyle? DetectedLineEndings { get; init; }

    #endregion

    #region Warnings

    /// <summary>
    /// List of warnings about the apply operation.
    /// </summary>
    public IReadOnlyList<ApplyWarning> Warnings { get; init; } = Array.Empty<ApplyWarning>();

    /// <summary>
    /// Whether there are any warnings.
    /// </summary>
    public bool HasWarnings => Warnings.Count > 0;

    #endregion

    #region Computed Properties

    /// <summary>
    /// Gets the operation type description.
    /// </summary>
    public string OperationType => TargetExists ? "Modify" : "Create";

    /// <summary>
    /// Gets whether apply can proceed.
    /// </summary>
    public bool CanApply => CanWrite && !IsLocked && (!HasConflict || Warnings.All(w => w.Severity != WarningSeverity.Error));

    /// <summary>
    /// Gets a summary of the changes.
    /// </summary>
    public string GetChangesSummary()
    {
        var parts = new List<string>();
        if (LinesAdded > 0) parts.Add($"+{LinesAdded}");
        if (LinesRemoved > 0) parts.Add($"-{LinesRemoved}");
        if (LinesModified > 0) parts.Add($"~{LinesModified}");

        return parts.Count > 0 ? string.Join(" ", parts) : "No changes";
    }

    #endregion

    #region Factory Methods

    /// <summary>
    /// Creates a preview for a new file.
    /// </summary>
    public static ApplyPreview ForNewFile(
        string filePath,
        string relativePath,
        int linesAdded,
        bool requiresDirectoryCreation = false) => new()
    {
        FilePath = filePath,
        RelativePath = relativePath,
        TargetExists = false,
        RequiresDirectoryCreation = requiresDirectoryCreation,
        LinesAdded = linesAdded,
        CanWrite = true
    };

    /// <summary>
    /// Creates a preview for an existing file modification.
    /// </summary>
    public static ApplyPreview ForModification(
        string filePath,
        string relativePath,
        DiffResult diff,
        bool hasConflict = false,
        string? conflictDescription = null) => new()
    {
        FilePath = filePath,
        RelativePath = relativePath,
        TargetExists = true,
        Diff = diff,
        LinesAdded = diff.Stats?.LinesAdded ?? 0,
        LinesRemoved = diff.Stats?.LinesRemoved ?? 0,
        LinesModified = diff.Stats?.LinesModified ?? 0,
        HunkCount = diff.Hunks?.Count ?? 0,
        HasConflict = hasConflict,
        ConflictDescription = conflictDescription,
        CanWrite = true
    };

    #endregion
}

/// <summary>
/// Warning about an apply operation.
/// </summary>
public sealed record ApplyWarning
{
    /// <summary>
    /// Warning message.
    /// </summary>
    public required string Message { get; init; }

    /// <summary>
    /// Severity of the warning.
    /// </summary>
    public WarningSeverity Severity { get; init; } = WarningSeverity.Warning;

    /// <summary>
    /// Warning code for programmatic handling.
    /// </summary>
    public string? Code { get; init; }
}

/// <summary>
/// Severity levels for apply warnings.
/// </summary>
public enum WarningSeverity
{
    /// <summary>
    /// Informational warning, apply can proceed.
    /// </summary>
    Info,

    /// <summary>
    /// Standard warning, user should review.
    /// </summary>
    Warning,

    /// <summary>
    /// Error-level warning, apply should not proceed.
    /// </summary>
    Error
}
```

### ConflictCheckResult Class

```csharp
// src/SeniorIntern.Core/Models/ConflictCheckResult.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Result of checking for conflicts before applying changes.
/// </summary>
public sealed class ConflictCheckResult
{
    #region Conflict Status

    /// <summary>
    /// Whether a conflict was detected.
    /// </summary>
    public bool HasConflict { get; init; }

    /// <summary>
    /// Type of conflict detected.
    /// </summary>
    public ConflictType ConflictType { get; init; }

    /// <summary>
    /// Human-readable description of the conflict.
    /// </summary>
    public string? Description { get; init; }

    #endregion

    #region Hash Information

    /// <summary>
    /// Expected hash of the file content (from when diff was computed).
    /// </summary>
    public string? ExpectedHash { get; init; }

    /// <summary>
    /// Actual hash of the current file content.
    /// </summary>
    public string? ActualHash { get; init; }

    #endregion

    #region File Information

    /// <summary>
    /// Path to the file being checked.
    /// </summary>
    public string FilePath { get; init; } = string.Empty;

    /// <summary>
    /// Whether the file currently exists.
    /// </summary>
    public bool FileExists { get; init; }

    /// <summary>
    /// When the file was last modified.
    /// </summary>
    public DateTime? LastModified { get; init; }

    /// <summary>
    /// Expected modification time (from when diff was computed).
    /// </summary>
    public DateTime? ExpectedModified { get; init; }

    /// <summary>
    /// Current file size in bytes.
    /// </summary>
    public long? CurrentSizeBytes { get; init; }

    #endregion

    #region Resolution Options

    /// <summary>
    /// Available resolution options for this conflict.
    /// </summary>
    public IReadOnlyList<ConflictResolution> AvailableResolutions { get; init; } = Array.Empty<ConflictResolution>();

    /// <summary>
    /// Recommended resolution (if any).
    /// </summary>
    public ConflictResolution? RecommendedResolution { get; init; }

    #endregion

    #region Factory Methods

    /// <summary>
    /// Creates a result indicating no conflict.
    /// </summary>
    public static ConflictCheckResult NoConflict(string filePath) => new()
    {
        FilePath = filePath,
        HasConflict = false,
        ConflictType = ConflictType.None,
        FileExists = true
    };

    /// <summary>
    /// Creates a result for a content modification conflict.
    /// </summary>
    public static ConflictCheckResult ContentModified(
        string filePath,
        string expectedHash,
        string actualHash,
        DateTime lastModified) => new()
    {
        FilePath = filePath,
        HasConflict = true,
        ConflictType = ConflictType.ContentModified,
        Description = "The file has been modified since the changes were generated.",
        ExpectedHash = expectedHash,
        ActualHash = actualHash,
        LastModified = lastModified,
        FileExists = true,
        AvailableResolutions = new[]
        {
            ConflictResolution.OverwriteWithProposed,
            ConflictResolution.KeepExisting,
            ConflictResolution.OpenMergeTool,
            ConflictResolution.Cancel
        },
        RecommendedResolution = ConflictResolution.OpenMergeTool
    };

    /// <summary>
    /// Creates a result for a deleted file conflict.
    /// </summary>
    public static ConflictCheckResult FileDeleted(string filePath) => new()
    {
        FilePath = filePath,
        HasConflict = true,
        ConflictType = ConflictType.FileDeleted,
        Description = "The file has been deleted since the changes were generated.",
        FileExists = false,
        AvailableResolutions = new[]
        {
            ConflictResolution.CreateNew,
            ConflictResolution.Cancel
        },
        RecommendedResolution = ConflictResolution.CreateNew
    };

    /// <summary>
    /// Creates a result for a newly created file conflict.
    /// </summary>
    public static ConflictCheckResult FileCreatedExternally(
        string filePath,
        DateTime lastModified) => new()
    {
        FilePath = filePath,
        HasConflict = true,
        ConflictType = ConflictType.FileCreatedExternally,
        Description = "A file was created at this path since the changes were generated.",
        LastModified = lastModified,
        FileExists = true,
        AvailableResolutions = new[]
        {
            ConflictResolution.OverwriteWithProposed,
            ConflictResolution.KeepExisting,
            ConflictResolution.CreateWithDifferentName,
            ConflictResolution.Cancel
        },
        RecommendedResolution = ConflictResolution.KeepExisting
    };

    #endregion

    #region Helper Methods

    /// <summary>
    /// Gets whether overwrite is recommended.
    /// </summary>
    public bool IsOverwriteRecommended =>
        RecommendedResolution == ConflictResolution.OverwriteWithProposed;

    /// <summary>
    /// Gets whether the conflict can be auto-resolved.
    /// </summary>
    public bool CanAutoResolve =>
        !HasConflict || RecommendedResolution == ConflictResolution.OverwriteWithProposed;

    #endregion
}

/// <summary>
/// Type of conflict detected.
/// </summary>
public enum ConflictType
{
    /// <summary>
    /// No conflict detected.
    /// </summary>
    None = 0,

    /// <summary>
    /// File content was modified since diff was computed.
    /// </summary>
    ContentModified = 1,

    /// <summary>
    /// File was deleted since diff was computed.
    /// </summary>
    FileDeleted = 2,

    /// <summary>
    /// File was created externally (for new file proposals).
    /// </summary>
    FileCreatedExternally = 3,

    /// <summary>
    /// File was renamed or moved.
    /// </summary>
    FileRenamed = 4,

    /// <summary>
    /// File permissions changed.
    /// </summary>
    PermissionsChanged = 5
}

/// <summary>
/// Available resolutions for a conflict.
/// </summary>
public enum ConflictResolution
{
    /// <summary>
    /// Overwrite the existing file with the proposed changes.
    /// </summary>
    OverwriteWithProposed,

    /// <summary>
    /// Keep the existing file content, discard proposed changes.
    /// </summary>
    KeepExisting,

    /// <summary>
    /// Open a merge tool to manually resolve.
    /// </summary>
    OpenMergeTool,

    /// <summary>
    /// Create a new file with a different name.
    /// </summary>
    CreateWithDifferentName,

    /// <summary>
    /// Create the file (for deleted file conflicts).
    /// </summary>
    CreateNew,

    /// <summary>
    /// Cancel the apply operation.
    /// </summary>
    Cancel
}
```

### Apply Events

```csharp
// src/SeniorIntern.Core/Events/ApplyEvents.cs
namespace SeniorIntern.Core.Events;

using SeniorIntern.Core.Models;

/// <summary>
/// Event args for successful file changes.
/// </summary>
public sealed class FileChangedEventArgs : EventArgs
{
    /// <summary>
    /// Full path to the changed file.
    /// </summary>
    public required string FilePath { get; init; }

    /// <summary>
    /// Relative path within the workspace.
    /// </summary>
    public required string RelativePath { get; init; }

    /// <summary>
    /// Type of change that was made.
    /// </summary>
    public required FileChangeType ChangeType { get; init; }

    /// <summary>
    /// ID of the code block that was applied.
    /// </summary>
    public Guid? CodeBlockId { get; init; }

    /// <summary>
    /// ID of the message containing the code block.
    /// </summary>
    public Guid? MessageId { get; init; }

    /// <summary>
    /// ID of the change record for undo.
    /// </summary>
    public Guid? ChangeRecordId { get; init; }

    /// <summary>
    /// When the change occurred.
    /// </summary>
    public DateTime Timestamp { get; init; } = DateTime.UtcNow;

    /// <summary>
    /// Whether undo is available.
    /// </summary>
    public bool CanUndo { get; init; }

    /// <summary>
    /// Number of lines added.
    /// </summary>
    public int LinesAdded { get; init; }

    /// <summary>
    /// Number of lines removed.
    /// </summary>
    public int LinesRemoved { get; init; }
}

/// <summary>
/// Event args for failed file changes.
/// </summary>
public sealed class FileChangeFailedEventArgs : EventArgs
{
    /// <summary>
    /// Full path to the file that failed.
    /// </summary>
    public required string FilePath { get; init; }

    /// <summary>
    /// Error message describing the failure.
    /// </summary>
    public required string ErrorMessage { get; init; }

    /// <summary>
    /// Type of failure.
    /// </summary>
    public required ApplyResultType FailureType { get; init; }

    /// <summary>
    /// Exception that caused the failure (if any).
    /// </summary>
    public Exception? Exception { get; init; }

    /// <summary>
    /// ID of the code block that failed to apply.
    /// </summary>
    public Guid? CodeBlockId { get; init; }

    /// <summary>
    /// When the failure occurred.
    /// </summary>
    public DateTime Timestamp { get; init; } = DateTime.UtcNow;

    /// <summary>
    /// Whether the operation can be retried.
    /// </summary>
    public bool IsRetryable { get; init; }
}

/// <summary>
/// Event args for undo operations.
/// </summary>
public sealed class FileChangeUndoneEventArgs : EventArgs
{
    /// <summary>
    /// Full path to the restored file.
    /// </summary>
    public required string FilePath { get; init; }

    /// <summary>
    /// The original change that was undone.
    /// </summary>
    public required FileChangeRecord OriginalChange { get; init; }

    /// <summary>
    /// When the undo occurred.
    /// </summary>
    public DateTime Timestamp { get; init; } = DateTime.UtcNow;

    /// <summary>
    /// Whether the file was fully restored from backup.
    /// </summary>
    public bool FullyRestored { get; init; }
}

/// <summary>
/// Event args for conflict detection.
/// </summary>
public sealed class FileConflictDetectedEventArgs : EventArgs
{
    /// <summary>
    /// Full path to the conflicted file.
    /// </summary>
    public required string FilePath { get; init; }

    /// <summary>
    /// Type of conflict detected.
    /// </summary>
    public required ConflictType ConflictType { get; init; }

    /// <summary>
    /// Expected content hash.
    /// </summary>
    public required string ExpectedHash { get; init; }

    /// <summary>
    /// Actual content hash found.
    /// </summary>
    public required string ActualHash { get; init; }

    /// <summary>
    /// When the file was last modified.
    /// </summary>
    public required DateTime LastModified { get; init; }

    /// <summary>
    /// Description of the conflict.
    /// </summary>
    public string? Description { get; init; }
}

/// <summary>
/// Event args for backup creation.
/// </summary>
public sealed class BackupCreatedEventArgs : EventArgs
{
    /// <summary>
    /// Path to the original file.
    /// </summary>
    public required string OriginalPath { get; init; }

    /// <summary>
    /// Path to the backup file.
    /// </summary>
    public required string BackupPath { get; init; }

    /// <summary>
    /// Size of the backup in bytes.
    /// </summary>
    public long SizeBytes { get; init; }

    /// <summary>
    /// When the backup was created.
    /// </summary>
    public DateTime Timestamp { get; init; } = DateTime.UtcNow;
}

/// <summary>
/// Event args for backup cleanup.
/// </summary>
public sealed class BackupCleanedUpEventArgs : EventArgs
{
    /// <summary>
    /// Number of backup files cleaned up.
    /// </summary>
    public int FilesRemoved { get; init; }

    /// <summary>
    /// Total bytes freed.
    /// </summary>
    public long BytesFreed { get; init; }

    /// <summary>
    /// When the cleanup occurred.
    /// </summary>
    public DateTime Timestamp { get; init; } = DateTime.UtcNow;
}
```

---

## Data Binding Specifications

### ApplyOptions Property Table

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `CreateBackup` | `bool` | `true` | Enable backup/undo |
| `BackupDirectory` | `string?` | `null` | Custom backup location |
| `AllowConflictOverwrite` | `bool` | `false` | Force overwrite on conflict |
| `CheckForConflicts` | `bool` | `true` | Enable conflict detection |
| `RefreshEditorAfterApply` | `bool` | `true` | Reload editor |
| `ScrollToFirstChange` | `bool` | `true` | Scroll after apply |
| `UndoWindow` | `TimeSpan` | `30 min` | Undo availability period |
| `MaxUndoRecordsPerFile` | `int` | `10` | History limit |
| `ShowConfirmationDialog` | `bool` | `true` | Show confirm dialog |
| `ShowSuccessToast` | `bool` | `true` | Show success notification |
| `ToastDuration` | `TimeSpan` | `10 sec` | Toast display time |
| `ValidateEncoding` | `bool` | `true` | Check file encoding |
| `PreserveLineEndings` | `bool` | `true` | Keep original line endings |
| `CreateParentDirectories` | `bool` | `true` | Create missing dirs |
| `PreserveFileAttributes` | `bool` | `true` | Keep file attributes |
| `MaxFileSizeBytes` | `long` | `10 MB` | Size limit |

### ApplyResultType Values

| Value | Code | Category | Retryable | Description |
|-------|------|----------|-----------|-------------|
| `Success` | 0 | Success | N/A | Generic success |
| `Created` | 1 | Success | N/A | New file created |
| `Modified` | 2 | Success | N/A | File modified |
| `Conflict` | 10 | Failure | Yes | Content conflict |
| `FileNotFound` | 11 | Failure | No | Target missing |
| `PermissionDenied` | 12 | Failure | Yes | Access denied |
| `ValidationFailed` | 13 | Failure | No | Invalid input |
| `Cancelled` | 14 | Failure | N/A | User cancelled |
| `FileLocked` | 15 | Failure | Yes | Process lock |
| `DiskFull` | 16 | Failure | Yes | No space |
| `PathOutsideWorkspace` | 17 | Failure | No | Security |
| `Error` | 99 | Failure | No | Unknown |

---

## Files to Create

| File | Purpose | Lines (approx) |
|------|---------|----------------|
| `src/SeniorIntern.Core/Models/ApplyOptions.cs` | Apply configuration options | 200 |
| `src/SeniorIntern.Core/Models/ApplyResult.cs` | Apply operation result | 280 |
| `src/SeniorIntern.Core/Models/FileChangeRecord.cs` | Change tracking record | 200 |
| `src/SeniorIntern.Core/Models/ApplyPreview.cs` | Apply preview information | 180 |
| `src/SeniorIntern.Core/Models/ConflictCheckResult.cs` | Conflict detection result | 170 |
| `src/SeniorIntern.Core/Events/ApplyEvents.cs` | Apply-related events | 180 |

## Directories to Create

| Directory | Purpose |
|-----------|---------|
| `src/SeniorIntern.Core/Events/` | Event argument classes |

---

## Testing Strategy

### Unit Tests

```csharp
// tests/SeniorIntern.Core.Tests/Models/ApplyOptionsTests.cs
namespace SeniorIntern.Core.Tests.Models;

using SeniorIntern.Core.Models;
using Xunit;

public class ApplyOptionsTests
{
    [Fact]
    public void Default_HasExpectedValues()
    {
        var options = ApplyOptions.Default;

        Assert.True(options.CreateBackup);
        Assert.False(options.AllowConflictOverwrite);
        Assert.True(options.ShowConfirmationDialog);
        Assert.Equal(TimeSpan.FromMinutes(30), options.UndoWindow);
    }

    [Fact]
    public void Silent_DisablesDialogsAndBackup()
    {
        var options = ApplyOptions.Silent;

        Assert.False(options.CreateBackup);
        Assert.False(options.ShowConfirmationDialog);
        Assert.False(options.ShowSuccessToast);
    }

    [Fact]
    public void Batch_EnablesBackupButDisablesDialogs()
    {
        var options = ApplyOptions.Batch;

        Assert.True(options.CreateBackup);
        Assert.False(options.ShowConfirmationDialog);
        Assert.False(options.RefreshEditorAfterApply);
    }

    [Fact]
    public void WithUndoWindow_CreatesNewRecordWithUpdatedValue()
    {
        var options = ApplyOptions.Default.WithUndoWindow(TimeSpan.FromHours(2));

        Assert.Equal(TimeSpan.FromHours(2), options.UndoWindow);
        Assert.True(options.CreateBackup); // Other values preserved
    }

    [Fact]
    public void WithoutDialogs_DisablesAllDialogs()
    {
        var options = ApplyOptions.Default.WithoutDialogs();

        Assert.False(options.ShowConfirmationDialog);
        Assert.False(options.ShowSuccessToast);
    }

    [Fact]
    public void BinaryExtensions_ContainsExpectedExtensions()
    {
        var options = ApplyOptions.Default;

        Assert.Contains(".exe", options.BinaryExtensions);
        Assert.Contains(".png", options.BinaryExtensions);
        Assert.Contains(".zip", options.BinaryExtensions);
    }

    [Fact]
    public void BinaryExtensions_IsCaseInsensitive()
    {
        var options = ApplyOptions.Default;

        Assert.Contains(".EXE", options.BinaryExtensions);
        Assert.Contains(".PNG", options.BinaryExtensions);
    }
}
```

```csharp
// tests/SeniorIntern.Core.Tests/Models/ApplyResultTests.cs
namespace SeniorIntern.Core.Tests.Models;

using SeniorIntern.Core.Models;
using Xunit;

public class ApplyResultTests
{
    [Fact]
    public void Succeeded_SetsCorrectProperties()
    {
        var result = ApplyResult.Succeeded(
            "/path/to/file.cs",
            "src/file.cs",
            ApplyResultType.Modified,
            backupPath: "/backup/file.cs");

        Assert.True(result.Success);
        Assert.Equal(ApplyResultType.Modified, result.ResultType);
        Assert.Equal("/path/to/file.cs", result.FilePath);
        Assert.Equal("src/file.cs", result.RelativePath);
        Assert.Equal("/backup/file.cs", result.BackupPath);
        Assert.True(result.CanUndo);
    }

    [Fact]
    public void Failed_SetsCorrectProperties()
    {
        var result = ApplyResult.Failed(
            "/path/to/file.cs",
            ApplyResultType.PermissionDenied,
            "Access denied");

        Assert.False(result.Success);
        Assert.Equal(ApplyResultType.PermissionDenied, result.ResultType);
        Assert.Equal("Access denied", result.ErrorMessage);
        Assert.False(result.CanUndo);
    }

    [Fact]
    public void Created_SetsCanUndoTrue()
    {
        var result = ApplyResult.Created(
            "/path/to/file.cs",
            "src/file.cs");

        Assert.True(result.Success);
        Assert.True(result.CanUndo);
        Assert.True(result.IsNewFile);
    }

    [Fact]
    public void Conflict_IncludesHashInformation()
    {
        var result = ApplyResult.Conflict(
            "/path/to/file.cs",
            "src/file.cs",
            "hash1",
            "hash2",
            "File was modified");

        Assert.False(result.Success);
        Assert.Equal(ApplyResultType.Conflict, result.ResultType);
        Assert.Equal("hash1", result.ExpectedContentHash);
        Assert.Equal("hash2", result.ActualContentHash);
    }

    [Fact]
    public void GetSummary_FormatsSuccessCorrectly()
    {
        var result = ApplyResult.Modified(
            "/path/to/file.cs",
            "src/file.cs") with
        {
            LinesAdded = 10,
            LinesRemoved = 5
        };

        var summary = result.GetSummary();

        Assert.Contains("Modified", summary);
        Assert.Contains("+10", summary);
        Assert.Contains("-5", summary);
    }

    [Fact]
    public void IsRetryable_TrueForFileLocked()
    {
        var result = ApplyResult.Failed(
            "/path/to/file.cs",
            ApplyResultType.FileLocked,
            "File is locked");

        Assert.True(result.IsRetryable);
    }

    [Fact]
    public void IsRetryable_FalseForValidationFailed()
    {
        var result = ApplyResult.Failed(
            "/path/to/file.cs",
            ApplyResultType.ValidationFailed,
            "Invalid path");

        Assert.False(result.IsRetryable);
    }
}
```

```csharp
// tests/SeniorIntern.Core.Tests/Models/FileChangeRecordTests.cs
namespace SeniorIntern.Core.Tests.Models;

using SeniorIntern.Core.Models;
using Xunit;

public class FileChangeRecordTests
{
    [Fact]
    public void GetUndoTimeRemaining_CalculatesCorrectly()
    {
        var record = new FileChangeRecord
        {
            ChangedAt = DateTime.UtcNow.AddMinutes(-10)
        };
        var undoWindow = TimeSpan.FromMinutes(30);

        var remaining = record.GetUndoTimeRemaining(undoWindow);

        Assert.True(remaining.TotalMinutes >= 19 && remaining.TotalMinutes <= 20);
    }

    [Fact]
    public void GetUndoTimeRemaining_ReturnsZero_WhenExpired()
    {
        var record = new FileChangeRecord
        {
            ChangedAt = DateTime.UtcNow.AddMinutes(-35)
        };
        var undoWindow = TimeSpan.FromMinutes(30);

        var remaining = record.GetUndoTimeRemaining(undoWindow);

        Assert.Equal(TimeSpan.Zero, remaining);
    }

    [Fact]
    public void IsUndoExpired_ReturnsFalse_WithinWindow()
    {
        var record = new FileChangeRecord
        {
            ChangedAt = DateTime.UtcNow.AddMinutes(-10)
        };

        Assert.False(record.IsUndoExpired(TimeSpan.FromMinutes(30)));
    }

    [Fact]
    public void IsUndoExpired_ReturnsTrue_AfterWindow()
    {
        var record = new FileChangeRecord
        {
            ChangedAt = DateTime.UtcNow.AddMinutes(-35)
        };

        Assert.True(record.IsUndoExpired(TimeSpan.FromMinutes(30)));
    }

    [Fact]
    public void CanUndo_ReturnsFalse_WhenAlreadyUndone()
    {
        var record = new FileChangeRecord
        {
            ChangedAt = DateTime.UtcNow.AddMinutes(-5),
            BackupPath = "/backup/file.cs",
            IsUndone = true
        };

        Assert.False(record.CanUndo(TimeSpan.FromMinutes(30)));
    }

    [Fact]
    public void CanUndo_ReturnsFalse_WhenNoBackup_AndNotCreated()
    {
        var record = new FileChangeRecord
        {
            ChangedAt = DateTime.UtcNow.AddMinutes(-5),
            ChangeType = FileChangeType.Modified,
            BackupPath = null
        };

        Assert.False(record.CanUndo(TimeSpan.FromMinutes(30)));
    }

    [Fact]
    public void CanUndo_ReturnsTrue_ForCreated_WithoutBackup()
    {
        var record = new FileChangeRecord
        {
            ChangedAt = DateTime.UtcNow.AddMinutes(-5),
            ChangeType = FileChangeType.Created,
            BackupPath = null
        };

        Assert.True(record.CanUndo(TimeSpan.FromMinutes(30)));
    }

    [Fact]
    public void GetUndoTimeRemainingPercent_CalculatesCorrectly()
    {
        var record = new FileChangeRecord
        {
            ChangedAt = DateTime.UtcNow.AddMinutes(-15)
        };

        var percent = record.GetUndoTimeRemainingPercent(TimeSpan.FromMinutes(30));

        Assert.True(percent >= 45 && percent <= 55); // ~50%
    }

    [Fact]
    public void GetSummary_FormatsCorrectly()
    {
        var record = new FileChangeRecord
        {
            RelativePath = "src/file.cs",
            ChangeType = FileChangeType.Modified
        };

        Assert.Equal("Modified src/file.cs", record.GetSummary());
    }

    [Fact]
    public void Id_IsUniqueForEachInstance()
    {
        var record1 = new FileChangeRecord();
        var record2 = new FileChangeRecord();

        Assert.NotEqual(record1.Id, record2.Id);
    }
}
```

```csharp
// tests/SeniorIntern.Core.Tests/Models/ConflictCheckResultTests.cs
namespace SeniorIntern.Core.Tests.Models;

using SeniorIntern.Core.Models;
using Xunit;

public class ConflictCheckResultTests
{
    [Fact]
    public void NoConflict_HasCorrectProperties()
    {
        var result = ConflictCheckResult.NoConflict("/path/to/file.cs");

        Assert.False(result.HasConflict);
        Assert.Equal(ConflictType.None, result.ConflictType);
        Assert.True(result.CanAutoResolve);
    }

    [Fact]
    public void ContentModified_IncludesResolutionOptions()
    {
        var result = ConflictCheckResult.ContentModified(
            "/path/to/file.cs",
            "hash1",
            "hash2",
            DateTime.UtcNow);

        Assert.True(result.HasConflict);
        Assert.Equal(ConflictType.ContentModified, result.ConflictType);
        Assert.Contains(ConflictResolution.OverwriteWithProposed, result.AvailableResolutions);
        Assert.Contains(ConflictResolution.OpenMergeTool, result.AvailableResolutions);
    }

    [Fact]
    public void FileDeleted_RecommendsCreateNew()
    {
        var result = ConflictCheckResult.FileDeleted("/path/to/file.cs");

        Assert.True(result.HasConflict);
        Assert.Equal(ConflictType.FileDeleted, result.ConflictType);
        Assert.Equal(ConflictResolution.CreateNew, result.RecommendedResolution);
    }

    [Fact]
    public void FileCreatedExternally_RecommendsKeepExisting()
    {
        var result = ConflictCheckResult.FileCreatedExternally(
            "/path/to/file.cs",
            DateTime.UtcNow);

        Assert.True(result.HasConflict);
        Assert.Equal(ConflictResolution.KeepExisting, result.RecommendedResolution);
    }
}
```

---

## Acceptance Criteria

- [ ] `ApplyOptions` has all necessary configuration properties with sensible defaults
- [ ] `ApplyOptions` provides static presets (Default, Silent, Batch, ExtendedUndo)
- [ ] `ApplyOptions` provides builder methods for common customizations
- [ ] `ApplyResult` correctly represents success and failure states
- [ ] `ApplyResult` factory methods simplify result creation
- [ ] `ApplyResult.GetSummary()` provides human-readable descriptions
- [ ] `ApplyResultType` covers all possible outcomes
- [ ] `FileChangeRecord` tracks all change metadata for undo
- [ ] `FileChangeRecord.GetUndoTimeRemaining()` calculates accurately
- [ ] `FileChangeRecord.IsUndoExpired()` works correctly at boundaries
- [ ] `FileChangeRecord.CanUndo()` considers all relevant factors
- [ ] `ApplyPreview` provides complete preview information
- [ ] `ConflictCheckResult` identifies conflict types correctly
- [ ] `ConflictCheckResult` provides appropriate resolution options
- [ ] All event args contain complete information for subscribers
- [ ] All models are immutable or clearly document mutability
- [ ] XML documentation is complete for all public members
- [ ] Unit tests achieve >90% code coverage

---

## Design Decisions

### 1. Record vs Class for ApplyOptions

**Decision:** Use `sealed record` for `ApplyOptions`.

**Rationale:**
- Immutable by default (init-only properties)
- Built-in value equality
- `with` expression support for creating variations
- Clear intent that options shouldn't change after creation

### 2. Factory Methods in Result Classes

**Decision:** Provide static factory methods (`Succeeded`, `Failed`, `Created`, etc.) instead of relying solely on constructors.

**Rationale:**
- More readable code at call sites
- Encapsulates setting related properties together
- Prevents invalid state combinations
- Self-documenting intent

### 3. TimeSpan for Undo Window

**Decision:** Use `TimeSpan` for undo window configuration rather than integer minutes.

**Rationale:**
- Type-safe representation of duration
- Prevents unit confusion (seconds vs minutes)
- Allows fine-grained control (seconds, hours, etc.)
- Standard .NET pattern for durations

### 4. Separate ConflictCheckResult

**Decision:** Create a dedicated `ConflictCheckResult` class rather than embedding conflict info in `ApplyResult`.

**Rationale:**
- Conflict checking is a distinct operation from apply
- Can be performed independently (preview mode)
- Cleaner separation of concerns
- Resolution options are conflict-specific

### 5. Hash-Based Conflict Detection

**Decision:** Use content hash comparison for conflict detection rather than timestamp comparison.

**Rationale:**
- More reliable than timestamps (which can be preserved/manipulated)
- Detects actual content changes, not just file touches
- Works consistently across platforms
- SHA-256 provides strong collision resistance

### 6. Events Namespace

**Decision:** Create a dedicated `Events` namespace for event argument classes.

**Rationale:**
- Clear organization of event-related types
- Follows .NET convention for event args
- Separates concerns from models
- Makes event discovery easier

---

## Dependencies

### From Previous v0.4.x Sub-parts

| Sub-part | Dependency |
|----------|------------|
| v0.4.1a | `CodeBlock` model (for CodeBlockId references) |
| v0.4.2a | `DiffResult`, `DiffStats` models |

### External Dependencies

| Package | Purpose |
|---------|---------|
| None | Pure .NET models |

---

## Future Considerations

| Item | Target Version | Rationale |
|------|----------------|-----------|
| JSON serialization attributes | v0.4.3d | For persisting change history |
| Binary diff support | v0.5.0+ | Non-text file changes |
| Remote file support | v0.6.0+ | SSH/SFTP file changes |
| Change grouping | v0.5.0+ | Undo multiple related changes |
