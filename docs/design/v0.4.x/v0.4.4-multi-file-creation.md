# Design Specification: AIntern v0.4.4 "Multi-File Creation"

**Status**: _IMPLEMENTED_

## Executive Summary

This document provides a comprehensive design specification for v0.4.4, which enables the LLM to propose creating multiple files at once, including folder structures, with batch preview and creation capabilities. This is essential for project scaffolding scenarios where the assistant suggests entire module structures.

### Parent Version Reference
- **Parent**: v0.4.0 "Code Generation & Diffing"
- **Focus**: Propose folder structures, batch file creation, project scaffolding

### Dependencies
- v0.4.1 (Code Block Extraction) - Required for CodeBlock parsing
- v0.4.2 (Diff Engine) - Required for multi-file diff preview
- v0.4.3 (Apply Changes Workflow) - Required for batch file writing

---

## Sub-Part Breakdown

| Sub-Part | Name | Focus |
|----------|------|-------|
| v0.4.4a | Core Models | FileTreeProposal, FileOperation, and related types |
| v0.4.4b | File Tree Parser | Parse LLM responses for multi-file proposals |
| v0.4.4c | Proposal Service | IFileTreeProposalService validation and apply |
| v0.4.4d | Tree ViewModels | FileTreeProposalViewModel, FileTreeItemViewModel |
| v0.4.4e | Proposal Panel | FileTreeProposalPanel with tree visualization |
| v0.4.4f | Batch Preview | BatchPreviewDialog with tabbed diffs |
| v0.4.4g | Progress Overlay | ApplyProgressOverlay with live updates |
| v0.4.4h | Chat Integration | Integrate proposals into ChatMessageControl |

---

## v0.4.4a: Core Models

### Objective
Define the data models for representing multi-file proposals with folder structures.

### FileTreeProposal Model

```csharp
// src/SeniorIntern.Core/Models/FileTreeProposal.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Represents a proposal to create multiple files and directories.
/// </summary>
public sealed class FileTreeProposal
{
    /// <summary>
    /// Unique identifier for this proposal.
    /// </summary>
    public Guid Id { get; init; } = Guid.NewGuid();

    /// <summary>
    /// ID of the message that generated this proposal.
    /// </summary>
    public Guid MessageId { get; init; }

    /// <summary>
    /// When this proposal was created.
    /// </summary>
    public DateTime CreatedAt { get; init; } = DateTime.UtcNow;

    /// <summary>
    /// Root directory for the proposal (relative to workspace).
    /// </summary>
    public string RootPath { get; init; } = string.Empty;

    /// <summary>
    /// All proposed file operations.
    /// </summary>
    public IReadOnlyList<FileOperation> Operations { get; init; } = Array.Empty<FileOperation>();

    /// <summary>
    /// Summary description extracted from LLM response.
    /// </summary>
    public string? Description { get; set; }

    /// <summary>
    /// The raw file tree text if detected (e.g., ASCII tree representation).
    /// </summary>
    public string? RawTreeText { get; init; }

    /// <summary>
    /// Status of the overall proposal.
    /// </summary>
    public FileTreeProposalStatus Status { get; set; } = FileTreeProposalStatus.Pending;

    /// <summary>
    /// Total files to create.
    /// </summary>
    public int FileCount => Operations.Count(o => o.Type == FileOperationType.Create);

    /// <summary>
    /// Total files to modify.
    /// </summary>
    public int ModifyCount => Operations.Count(o => o.Type == FileOperationType.Modify);

    /// <summary>
    /// Unique directories that will be created.
    /// </summary>
    public IEnumerable<string> Directories => Operations
        .Where(o => o.Type == FileOperationType.Create)
        .Select(o => Path.GetDirectoryName(o.Path))
        .Where(d => !string.IsNullOrEmpty(d))
        .Distinct()!;

    /// <summary>
    /// Total directories to create.
    /// </summary>
    public int DirectoryCount => Directories.Count();

    /// <summary>
    /// Operations selected for apply.
    /// </summary>
    public IEnumerable<FileOperation> SelectedOperations =>
        Operations.Where(o => o.IsSelected);

    /// <summary>
    /// Count of selected operations.
    /// </summary>
    public int SelectedCount => SelectedOperations.Count();

    /// <summary>
    /// Whether any operations are selected.
    /// </summary>
    public bool HasSelectedOperations => SelectedCount > 0;

    /// <summary>
    /// Total estimated size of all files to create.
    /// </summary>
    public long TotalSizeBytes => Operations
        .Where(o => o.Content != null)
        .Sum(o => Encoding.UTF8.GetByteCount(o.Content!));

    /// <summary>
    /// Check if a specific path is included in this proposal.
    /// </summary>
    public bool ContainsPath(string path) =>
        Operations.Any(o => o.Path.Equals(path, StringComparison.OrdinalIgnoreCase));

    /// <summary>
    /// Get operation by path.
    /// </summary>
    public FileOperation? GetOperation(string path) =>
        Operations.FirstOrDefault(o => o.Path.Equals(path, StringComparison.OrdinalIgnoreCase));
}

/// <summary>
/// Status of a file tree proposal.
/// </summary>
public enum FileTreeProposalStatus
{
    /// <summary>
    /// No operations have been applied yet.
    /// </summary>
    Pending,

    /// <summary>
    /// Some operations have been applied.
    /// </summary>
    PartiallyApplied,

    /// <summary>
    /// All selected operations have been applied.
    /// </summary>
    FullyApplied,

    /// <summary>
    /// User rejected the proposal.
    /// </summary>
    Rejected,

    /// <summary>
    /// Apply was cancelled mid-operation.
    /// </summary>
    Cancelled,

    /// <summary>
    /// Proposal validation failed.
    /// </summary>
    Invalid
}
```

### FileOperation Model

```csharp
// src/SeniorIntern.Core/Models/FileOperation.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Represents a single file operation within a proposal.
/// </summary>
public sealed class FileOperation
{
    /// <summary>
    /// Unique identifier for this operation.
    /// </summary>
    public Guid Id { get; init; } = Guid.NewGuid();

    /// <summary>
    /// Relative path within the workspace.
    /// </summary>
    public string Path { get; init; } = string.Empty;

    /// <summary>
    /// Type of file operation.
    /// </summary>
    public FileOperationType Type { get; init; }

    /// <summary>
    /// Content for create/modify operations.
    /// </summary>
    public string? Content { get; init; }

    /// <summary>
    /// ID of the source code block (if applicable).
    /// </summary>
    public Guid? CodeBlockId { get; init; }

    /// <summary>
    /// Detected programming language.
    /// </summary>
    public string? Language { get; init; }

    /// <summary>
    /// Display-friendly language name.
    /// </summary>
    public string? DisplayLanguage { get; init; }

    /// <summary>
    /// Whether this operation is selected for batch apply.
    /// </summary>
    public bool IsSelected { get; set; } = true;

    /// <summary>
    /// Status of this individual operation.
    /// </summary>
    public FileOperationStatus Status { get; set; } = FileOperationStatus.Pending;

    /// <summary>
    /// Error message if failed.
    /// </summary>
    public string? ErrorMessage { get; set; }

    /// <summary>
    /// New path for rename/move operations.
    /// </summary>
    public string? NewPath { get; init; }

    /// <summary>
    /// Sequence order for dependencies.
    /// </summary>
    public int Order { get; init; }

    /// <summary>
    /// File name without directory.
    /// </summary>
    public string FileName => System.IO.Path.GetFileName(Path);

    /// <summary>
    /// Directory containing this file.
    /// </summary>
    public string? Directory => System.IO.Path.GetDirectoryName(Path);

    /// <summary>
    /// File extension including dot.
    /// </summary>
    public string Extension => System.IO.Path.GetExtension(Path);

    /// <summary>
    /// Content size in bytes.
    /// </summary>
    public long ContentSizeBytes => Content != null
        ? Encoding.UTF8.GetByteCount(Content)
        : 0;

    /// <summary>
    /// Line count of content.
    /// </summary>
    public int LineCount => Content?.Split('\n').Length ?? 0;

    /// <summary>
    /// Whether this operation can be applied.
    /// </summary>
    public bool CanApply =>
        Status == FileOperationStatus.Pending &&
        Type != FileOperationType.Unknown;

    /// <summary>
    /// Create from a CodeBlock.
    /// </summary>
    public static FileOperation FromCodeBlock(CodeBlock block, int order = 0) => new()
    {
        Path = block.TargetFilePath ?? string.Empty,
        Type = FileOperationType.Create,
        Content = block.Content,
        CodeBlockId = block.Id,
        Language = block.Language,
        DisplayLanguage = block.DisplayLanguage,
        Order = order
    };
}

/// <summary>
/// Type of file operation.
/// </summary>
public enum FileOperationType
{
    /// <summary>
    /// Create a new file.
    /// </summary>
    Create,

    /// <summary>
    /// Modify an existing file.
    /// </summary>
    Modify,

    /// <summary>
    /// Delete a file.
    /// </summary>
    Delete,

    /// <summary>
    /// Rename a file.
    /// </summary>
    Rename,

    /// <summary>
    /// Move a file to a new location.
    /// </summary>
    Move,

    /// <summary>
    /// Create a directory.
    /// </summary>
    CreateDirectory,

    /// <summary>
    /// Unknown operation type.
    /// </summary>
    Unknown
}

/// <summary>
/// Status of a file operation.
/// </summary>
public enum FileOperationStatus
{
    /// <summary>
    /// Not yet applied.
    /// </summary>
    Pending,

    /// <summary>
    /// Successfully applied.
    /// </summary>
    Applied,

    /// <summary>
    /// Skipped by user choice.
    /// </summary>
    Skipped,

    /// <summary>
    /// Failed to apply.
    /// </summary>
    Failed,

    /// <summary>
    /// Conflict detected (file exists).
    /// </summary>
    Conflict,

    /// <summary>
    /// Currently being applied.
    /// </summary>
    InProgress
}
```

### Batch Apply Result Models

```csharp
// src/SeniorIntern.Core/Models/BatchApplyResult.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Result of applying a batch of file operations.
/// </summary>
public sealed class BatchApplyResult
{
    /// <summary>
    /// Whether all operations succeeded.
    /// </summary>
    public bool AllSucceeded { get; init; }

    /// <summary>
    /// Number of successful operations.
    /// </summary>
    public int SuccessCount { get; init; }

    /// <summary>
    /// Number of failed operations.
    /// </summary>
    public int FailedCount { get; init; }

    /// <summary>
    /// Number of skipped operations.
    /// </summary>
    public int SkippedCount { get; init; }

    /// <summary>
    /// Total operations attempted.
    /// </summary>
    public int TotalCount => SuccessCount + FailedCount + SkippedCount;

    /// <summary>
    /// Individual results for each operation.
    /// </summary>
    public IReadOnlyList<ApplyResult> Results { get; init; } = Array.Empty<ApplyResult>();

    /// <summary>
    /// Operations that failed.
    /// </summary>
    public IEnumerable<ApplyResult> FailedResults =>
        Results.Where(r => !r.Success);

    /// <summary>
    /// Operations that succeeded.
    /// </summary>
    public IEnumerable<ApplyResult> SucceededResults =>
        Results.Where(r => r.Success);

    /// <summary>
    /// When the batch apply started.
    /// </summary>
    public DateTime StartedAt { get; init; }

    /// <summary>
    /// When the batch apply completed.
    /// </summary>
    public DateTime CompletedAt { get; init; }

    /// <summary>
    /// Duration of the batch apply.
    /// </summary>
    public TimeSpan Duration => CompletedAt - StartedAt;

    /// <summary>
    /// Paths of all backup files created.
    /// </summary>
    public IReadOnlyList<string> BackupPaths { get; init; } = Array.Empty<string>();

    /// <summary>
    /// Whether undo is available for all changes.
    /// </summary>
    public bool CanUndoAll => Results.All(r => r.CanUndo);

    /// <summary>
    /// Create a successful result.
    /// </summary>
    public static BatchApplyResult Success(
        IReadOnlyList<ApplyResult> results,
        DateTime startedAt) => new()
    {
        AllSucceeded = true,
        SuccessCount = results.Count,
        FailedCount = 0,
        SkippedCount = 0,
        Results = results,
        StartedAt = startedAt,
        CompletedAt = DateTime.UtcNow,
        BackupPaths = results
            .Where(r => r.BackupPath != null)
            .Select(r => r.BackupPath!)
            .ToList()
    };
}

/// <summary>
/// Progress information during batch apply.
/// </summary>
public sealed class BatchApplyProgress
{
    /// <summary>
    /// Total number of operations.
    /// </summary>
    public int TotalOperations { get; init; }

    /// <summary>
    /// Number of completed operations.
    /// </summary>
    public int CompletedOperations { get; init; }

    /// <summary>
    /// Current file being processed.
    /// </summary>
    public string CurrentFile { get; init; } = string.Empty;

    /// <summary>
    /// Current operation type.
    /// </summary>
    public FileOperationType CurrentOperation { get; init; }

    /// <summary>
    /// Progress percentage (0-100).
    /// </summary>
    public double ProgressPercent => TotalOperations > 0
        ? (double)CompletedOperations / TotalOperations * 100
        : 0;

    /// <summary>
    /// Estimated time remaining.
    /// </summary>
    public TimeSpan? EstimatedRemaining { get; init; }

    /// <summary>
    /// Phase of the batch apply.
    /// </summary>
    public BatchApplyPhase Phase { get; init; }

    /// <summary>
    /// Whether the operation can be cancelled.
    /// </summary>
    public bool CanCancel { get; init; } = true;
}

/// <summary>
/// Phase of batch apply operation.
/// </summary>
public enum BatchApplyPhase
{
    /// <summary>
    /// Validating operations.
    /// </summary>
    Validating,

    /// <summary>
    /// Creating backups.
    /// </summary>
    CreatingBackups,

    /// <summary>
    /// Creating directories.
    /// </summary>
    CreatingDirectories,

    /// <summary>
    /// Writing files.
    /// </summary>
    WritingFiles,

    /// <summary>
    /// Finalizing.
    /// </summary>
    Finalizing,

    /// <summary>
    /// Completed.
    /// </summary>
    Completed,

    /// <summary>
    /// Rolling back due to error.
    /// </summary>
    RollingBack
}
```

### Validation Models

```csharp
// src/SeniorIntern.Core/Models/ProposalValidation.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Result of validating a file tree proposal.
/// </summary>
public sealed class ProposalValidationResult
{
    /// <summary>
    /// Whether the proposal is valid and can be applied.
    /// </summary>
    public bool IsValid { get; init; }

    /// <summary>
    /// Validation issues found.
    /// </summary>
    public IReadOnlyList<ValidationIssue> Issues { get; init; } = Array.Empty<ValidationIssue>();

    /// <summary>
    /// Issues that are errors (blocking).
    /// </summary>
    public IEnumerable<ValidationIssue> Errors =>
        Issues.Where(i => i.Severity == ValidationSeverity.Error);

    /// <summary>
    /// Issues that are warnings (non-blocking).
    /// </summary>
    public IEnumerable<ValidationIssue> Warnings =>
        Issues.Where(i => i.Severity == ValidationSeverity.Warning);

    /// <summary>
    /// Whether there are any errors.
    /// </summary>
    public bool HasErrors => Errors.Any();

    /// <summary>
    /// Whether there are any warnings.
    /// </summary>
    public bool HasWarnings => Warnings.Any();

    /// <summary>
    /// Create a valid result.
    /// </summary>
    public static ProposalValidationResult Valid() => new() { IsValid = true };

    /// <summary>
    /// Create an invalid result with issues.
    /// </summary>
    public static ProposalValidationResult Invalid(params ValidationIssue[] issues) => new()
    {
        IsValid = false,
        Issues = issues
    };
}

/// <summary>
/// A validation issue with a file operation.
/// </summary>
public sealed class ValidationIssue
{
    /// <summary>
    /// ID of the affected operation.
    /// </summary>
    public Guid? OperationId { get; init; }

    /// <summary>
    /// Path of the affected file.
    /// </summary>
    public string Path { get; init; } = string.Empty;

    /// <summary>
    /// Type of issue.
    /// </summary>
    public ValidationIssueType Type { get; init; }

    /// <summary>
    /// Severity of the issue.
    /// </summary>
    public ValidationSeverity Severity { get; init; }

    /// <summary>
    /// Human-readable message.
    /// </summary>
    public string Message { get; init; } = string.Empty;

    /// <summary>
    /// Suggested fix for the issue.
    /// </summary>
    public string? SuggestedFix { get; init; }
}

/// <summary>
/// Type of validation issue.
/// </summary>
public enum ValidationIssueType
{
    /// <summary>
    /// File already exists.
    /// </summary>
    FileExists,

    /// <summary>
    /// Directory already exists.
    /// </summary>
    DirectoryExists,

    /// <summary>
    /// Invalid file path.
    /// </summary>
    InvalidPath,

    /// <summary>
    /// Permission denied.
    /// </summary>
    PermissionDenied,

    /// <summary>
    /// Parent directory doesn't exist.
    /// </summary>
    ParentNotExists,

    /// <summary>
    /// File path too long.
    /// </summary>
    PathTooLong,

    /// <summary>
    /// Invalid characters in path.
    /// </summary>
    InvalidCharacters,

    /// <summary>
    /// Circular dependency detected.
    /// </summary>
    CircularDependency,

    /// <summary>
    /// Duplicate path in proposal.
    /// </summary>
    DuplicatePath,

    /// <summary>
    /// Content is empty.
    /// </summary>
    EmptyContent,

    /// <summary>
    /// File is outside workspace.
    /// </summary>
    OutsideWorkspace
}

/// <summary>
/// Severity of a validation issue.
/// </summary>
public enum ValidationSeverity
{
    /// <summary>
    /// Informational message.
    /// </summary>
    Info,

    /// <summary>
    /// Warning - can proceed with caution.
    /// </summary>
    Warning,

    /// <summary>
    /// Error - cannot proceed.
    /// </summary>
    Error
}
```

### Files to Create (v0.4.4a)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Models/FileTreeProposal.cs` | Main proposal model |
| `src/SeniorIntern.Core/Models/FileOperation.cs` | File operation model |
| `src/SeniorIntern.Core/Models/BatchApplyResult.cs` | Batch result and progress |
| `src/SeniorIntern.Core/Models/ProposalValidation.cs` | Validation result models |

### Testing Strategy (v0.4.4a)

```csharp
public class FileTreeProposalTests
{
    [Fact]
    public void FileCount_ReturnsCorrectCount()
    {
        var proposal = new FileTreeProposal
        {
            Operations = new[]
            {
                new FileOperation { Type = FileOperationType.Create },
                new FileOperation { Type = FileOperationType.Create },
                new FileOperation { Type = FileOperationType.Modify }
            }
        };

        Assert.Equal(2, proposal.FileCount);
    }

    [Fact]
    public void Directories_ReturnsUniqueDirectories()
    {
        var proposal = new FileTreeProposal
        {
            Operations = new[]
            {
                new FileOperation { Type = FileOperationType.Create, Path = "src/Models/User.cs" },
                new FileOperation { Type = FileOperationType.Create, Path = "src/Models/Product.cs" },
                new FileOperation { Type = FileOperationType.Create, Path = "src/Services/UserService.cs" }
            }
        };

        var dirs = proposal.Directories.ToList();
        Assert.Equal(2, dirs.Count);
        Assert.Contains("src/Models", dirs);
        Assert.Contains("src/Services", dirs);
    }

    [Fact]
    public void SelectedOperations_FiltersCorrectly()
    {
        var proposal = new FileTreeProposal
        {
            Operations = new[]
            {
                new FileOperation { IsSelected = true },
                new FileOperation { IsSelected = false },
                new FileOperation { IsSelected = true }
            }
        };

        Assert.Equal(2, proposal.SelectedCount);
    }
}
```

### Acceptance Criteria (v0.4.4a)

- [ ] FileTreeProposal tracks all operations
- [ ] FileOperation supports all operation types
- [ ] Directory counting is correct
- [ ] Selection state tracked properly
- [ ] Validation models capture all issue types
- [ ] BatchApplyResult tracks success/failure

---

## v0.4.4b: File Tree Parser

### Objective
Parse LLM responses to detect multi-file proposals from code blocks and ASCII tree structures.

### IFileTreeParser Interface

```csharp
// src/SeniorIntern.Core/Interfaces/IFileTreeParser.cs
namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Parser for detecting multi-file proposals from LLM responses.
/// </summary>
public interface IFileTreeParser
{
    /// <summary>
    /// Parse a message to detect multi-file proposals.
    /// </summary>
    FileTreeProposal? ParseProposal(
        string content,
        Guid messageId,
        IReadOnlyList<CodeBlock> codeBlocks);

    /// <summary>
    /// Detect if content contains a file tree structure.
    /// </summary>
    bool ContainsFileTree(string content);

    /// <summary>
    /// Parse an ASCII file tree into paths.
    /// </summary>
    IReadOnlyList<string> ParseAsciiTree(string treeContent);

    /// <summary>
    /// Extract description from surrounding text.
    /// </summary>
    string? ExtractDescription(string content);
}
```

### FileTreeParser Implementation

```csharp
// src/SeniorIntern.Services/FileTreeParser.cs
namespace SeniorIntern.Services;

using System.Text.RegularExpressions;

/// <summary>
/// Parses LLM responses to detect multi-file proposals.
/// </summary>
public sealed partial class FileTreeParser : IFileTreeParser
{
    private readonly ILanguageDetectionService _languageService;
    private readonly ILogger<FileTreeParser>? _logger;

    // Pattern for ASCII tree structures
    [GeneratedRegex(
        @"```(?:text|tree|plaintext)?\s*\n((?:[\s│├└──]+[\w\.\-/]+/?(?:\s*#[^\n]*)?\n?)+)```",
        RegexOptions.Compiled | RegexOptions.Multiline)]
    private static partial Regex TreeBlockPattern();

    // Pattern for tree lines
    [GeneratedRegex(
        @"^[\s│]*[├└]──\s*(.+?)(?:\s*#.*)?$",
        RegexOptions.Compiled | RegexOptions.Multiline)]
    private static partial Regex TreeLinePattern();

    // Pattern for simple directory listing
    [GeneratedRegex(
        @"^(\s*)([a-zA-Z_][\w\-\.]*(?:/[\w\-\.]+)*/?)$",
        RegexOptions.Compiled | RegexOptions.Multiline)]
    private static partial Regex SimpleListingPattern();

    // Phrases indicating a file structure follows
    private static readonly string[] StructureIndicators = new[]
    {
        "project structure",
        "file structure",
        "folder structure",
        "directory structure",
        "here's the structure",
        "create these files",
        "create the following",
        "files to create"
    };

    public FileTreeParser(
        ILanguageDetectionService languageService,
        ILogger<FileTreeParser>? logger = null)
    {
        _languageService = languageService;
        _logger = logger;
    }

    public FileTreeProposal? ParseProposal(
        string content,
        Guid messageId,
        IReadOnlyList<CodeBlock> codeBlocks)
    {
        // Need at least 2 code blocks with paths to consider multi-file
        var blocksWithPaths = codeBlocks
            .Where(b => !string.IsNullOrEmpty(b.TargetFilePath))
            .ToList();

        if (blocksWithPaths.Count < 2)
        {
            return null;
        }

        // Check for explicit file tree
        var treePaths = new List<string>();
        string? rawTreeText = null;

        if (ContainsFileTree(content))
        {
            var treeMatch = TreeBlockPattern().Match(content);
            if (treeMatch.Success)
            {
                rawTreeText = treeMatch.Groups[1].Value;
                treePaths = ParseAsciiTree(rawTreeText).ToList();
            }
        }

        // Build operations from code blocks
        var operations = new List<FileOperation>();
        int order = 0;

        foreach (var block in blocksWithPaths)
        {
            if (block.BlockType is not (CodeBlockType.CompleteFile or CodeBlockType.Snippet))
                continue;

            operations.Add(FileOperation.FromCodeBlock(block, order++));
        }

        if (operations.Count < 2)
        {
            return null;
        }

        // Find common root path
        var rootPath = FindCommonRoot(operations.Select(o => o.Path));

        // Extract description
        var description = ExtractDescription(content);

        _logger?.LogDebug(
            "Detected multi-file proposal with {Count} files in {Root}",
            operations.Count, rootPath);

        return new FileTreeProposal
        {
            MessageId = messageId,
            RootPath = rootPath,
            Operations = operations,
            Description = description,
            RawTreeText = rawTreeText
        };
    }

    public bool ContainsFileTree(string content)
    {
        var lowerContent = content.ToLowerInvariant();

        // Check for structure indicators
        if (!StructureIndicators.Any(ind => lowerContent.Contains(ind)))
            return false;

        // Check for tree block
        return TreeBlockPattern().IsMatch(content);
    }

    public IReadOnlyList<string> ParseAsciiTree(string treeContent)
    {
        var paths = new List<string>();
        var lines = treeContent.Split('\n', StringSplitOptions.RemoveEmptyEntries);
        var pathStack = new Stack<(int Depth, string Name)>();

        foreach (var line in lines)
        {
            var match = TreeLinePattern().Match(line);
            if (!match.Success)
            {
                // Try simple listing format
                match = SimpleListingPattern().Match(line);
            }

            if (!match.Success)
                continue;

            var name = match.Groups[1].Value.Trim();
            var depth = CalculateDepth(line);

            // Pop items from stack until we're at the right level
            while (pathStack.Count > 0 && pathStack.Peek().Depth >= depth)
            {
                pathStack.Pop();
            }

            pathStack.Push((depth, name));

            // Build full path
            var pathParts = pathStack.Reverse().Select(p => p.Name).ToList();
            var fullPath = string.Join("/", pathParts);

            // Only add files (not directories ending in /)
            if (!name.EndsWith('/'))
            {
                paths.Add(fullPath);
            }
        }

        return paths;
    }

    public string? ExtractDescription(string content)
    {
        var lines = content.Split('\n');

        // Look for description near structure indicators
        foreach (var indicator in StructureIndicators)
        {
            var index = content.ToLowerInvariant().IndexOf(indicator);
            if (index < 0) continue;

            // Get surrounding context
            var lineStart = content.LastIndexOf('\n', Math.Max(0, index - 1)) + 1;
            var lineEnd = content.IndexOf('\n', index);
            if (lineEnd < 0) lineEnd = content.Length;

            var line = content[lineStart..lineEnd].Trim();

            // Remove markdown formatting
            line = Regex.Replace(line, @"^#+\s*", "");
            line = Regex.Replace(line, @"[*_`]", "");

            if (line.Length > 10 && line.Length < 200)
            {
                return line;
            }
        }

        // Default description
        return null;
    }

    private static int CalculateDepth(string line)
    {
        int depth = 0;
        foreach (var c in line)
        {
            if (c == ' ') depth++;
            else if (c == '\t') depth += 4;
            else if (c == '│') depth += 4;
            else if (c == '├' || c == '└') break;
            else break;
        }
        return depth / 4;
    }

    private static string FindCommonRoot(IEnumerable<string> paths)
    {
        var pathList = paths.ToList();
        if (pathList.Count == 0) return string.Empty;
        if (pathList.Count == 1) return Path.GetDirectoryName(pathList[0]) ?? string.Empty;

        var segments = pathList
            .Select(p => p.Split('/'))
            .ToList();

        var minLength = segments.Min(s => s.Length);
        var commonParts = new List<string>();

        for (int i = 0; i < minLength - 1; i++)
        {
            var part = segments[0][i];
            if (segments.All(s => s[i] == part))
            {
                commonParts.Add(part);
            }
            else
            {
                break;
            }
        }

        return string.Join("/", commonParts);
    }
}
```

### Files to Create (v0.4.4b)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/IFileTreeParser.cs` | Parser interface |
| `src/SeniorIntern.Services/FileTreeParser.cs` | Parser implementation |

### Testing Strategy (v0.4.4b)

```csharp
public class FileTreeParserTests
{
    [Fact]
    public void ParseAsciiTree_StandardTree_ReturnsCorrectPaths()
    {
        var parser = CreateParser();
        var tree = """
            src/
            ├── Models/
            │   ├── User.cs
            │   └── Product.cs
            ├── Services/
            │   └── UserService.cs
            └── Program.cs
            """;

        var paths = parser.ParseAsciiTree(tree);

        Assert.Equal(4, paths.Count);
        Assert.Contains("src/Models/User.cs", paths);
        Assert.Contains("src/Models/Product.cs", paths);
        Assert.Contains("src/Services/UserService.cs", paths);
        Assert.Contains("src/Program.cs", paths);
    }

    [Fact]
    public void ContainsFileTree_WithStructureIndicator_ReturnsTrue()
    {
        var parser = CreateParser();
        var content = """
            Here's the project structure:

            ```
            src/
            └── App.cs
            ```
            """;

        Assert.True(parser.ContainsFileTree(content));
    }

    [Fact]
    public void ParseProposal_MultipleCodeBlocks_CreatesProposal()
    {
        var parser = CreateParser();
        var codeBlocks = new[]
        {
            new CodeBlock { TargetFilePath = "src/A.cs", Content = "class A {}", BlockType = CodeBlockType.CompleteFile },
            new CodeBlock { TargetFilePath = "src/B.cs", Content = "class B {}", BlockType = CodeBlockType.CompleteFile }
        };

        var proposal = parser.ParseProposal("content", Guid.NewGuid(), codeBlocks);

        Assert.NotNull(proposal);
        Assert.Equal(2, proposal.FileCount);
    }
}
```

### Acceptance Criteria (v0.4.4b)

- [ ] ASCII tree structures parsed correctly
- [ ] Standard tree characters (├└│──) handled
- [ ] Depth calculated correctly for nesting
- [ ] Common root path found
- [ ] Description extracted from context
- [ ] Single file proposals rejected
- [ ] Directories (ending in /) excluded from files

---

## v0.4.4c: Proposal Service

### Objective
Implement the service for validating and applying multi-file proposals.

### IFileTreeProposalService Interface

```csharp
// src/SeniorIntern.Core/Interfaces/IFileTreeProposalService.cs
namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Service for handling multi-file proposals.
/// </summary>
public interface IFileTreeProposalService
{
    /// <summary>
    /// Validate a proposal against the current workspace state.
    /// </summary>
    Task<ProposalValidationResult> ValidateProposalAsync(
        FileTreeProposal proposal,
        string workspacePath,
        CancellationToken ct = default);

    /// <summary>
    /// Apply selected operations from a proposal.
    /// </summary>
    Task<BatchApplyResult> ApplyProposalAsync(
        FileTreeProposal proposal,
        string workspacePath,
        ApplyOptions? options = null,
        IProgress<BatchApplyProgress>? progress = null,
        CancellationToken ct = default);

    /// <summary>
    /// Preview what changes will be made.
    /// </summary>
    Task<IReadOnlyList<DiffResult>> PreviewProposalAsync(
        FileTreeProposal proposal,
        string workspacePath,
        CancellationToken ct = default);

    /// <summary>
    /// Undo all changes from a batch apply.
    /// </summary>
    Task<bool> UndoBatchApplyAsync(
        BatchApplyResult result,
        CancellationToken ct = default);

    /// <summary>
    /// Check which files in a proposal already exist.
    /// </summary>
    Task<IReadOnlyDictionary<string, bool>> CheckExistingFilesAsync(
        FileTreeProposal proposal,
        string workspacePath,
        CancellationToken ct = default);

    /// <summary>
    /// Event raised when batch apply progress updates.
    /// </summary>
    event EventHandler<BatchApplyProgress>? ProgressChanged;
}
```

### FileTreeProposalService Implementation

```csharp
// src/SeniorIntern.Services/FileTreeProposalService.cs
namespace SeniorIntern.Services;

public sealed class FileTreeProposalService : IFileTreeProposalService
{
    private readonly IFileSystemService _fileSystem;
    private readonly IFileChangeService _changeService;
    private readonly IDiffService _diffService;
    private readonly IBackupService _backupService;
    private readonly ILogger<FileTreeProposalService>? _logger;

    public event EventHandler<BatchApplyProgress>? ProgressChanged;

    public FileTreeProposalService(
        IFileSystemService fileSystem,
        IFileChangeService changeService,
        IDiffService diffService,
        IBackupService backupService,
        ILogger<FileTreeProposalService>? logger = null)
    {
        _fileSystem = fileSystem;
        _changeService = changeService;
        _diffService = diffService;
        _backupService = backupService;
        _logger = logger;
    }

    public async Task<ProposalValidationResult> ValidateProposalAsync(
        FileTreeProposal proposal,
        string workspacePath,
        CancellationToken ct = default)
    {
        var issues = new List<ValidationIssue>();

        // Check for duplicate paths
        var duplicates = proposal.Operations
            .GroupBy(o => o.Path.ToLowerInvariant())
            .Where(g => g.Count() > 1)
            .Select(g => g.Key);

        foreach (var dup in duplicates)
        {
            issues.Add(new ValidationIssue
            {
                Path = dup,
                Type = ValidationIssueType.DuplicatePath,
                Severity = ValidationSeverity.Error,
                Message = $"Duplicate path: {dup}"
            });
        }

        // Validate each operation
        foreach (var op in proposal.Operations)
        {
            var opIssues = await ValidateOperationAsync(op, workspacePath, ct);
            issues.AddRange(opIssues);
        }

        return new ProposalValidationResult
        {
            IsValid = !issues.Any(i => i.Severity == ValidationSeverity.Error),
            Issues = issues
        };
    }

    private async Task<IEnumerable<ValidationIssue>> ValidateOperationAsync(
        FileOperation op,
        string workspacePath,
        CancellationToken ct)
    {
        var issues = new List<ValidationIssue>();
        var fullPath = Path.Combine(workspacePath, op.Path);

        // Check path validity
        if (!IsValidPath(op.Path))
        {
            issues.Add(new ValidationIssue
            {
                OperationId = op.Id,
                Path = op.Path,
                Type = ValidationIssueType.InvalidPath,
                Severity = ValidationSeverity.Error,
                Message = "Invalid file path"
            });
            return issues;
        }

        // Check if path is within workspace
        if (!IsWithinWorkspace(fullPath, workspacePath))
        {
            issues.Add(new ValidationIssue
            {
                OperationId = op.Id,
                Path = op.Path,
                Type = ValidationIssueType.OutsideWorkspace,
                Severity = ValidationSeverity.Error,
                Message = "Path is outside the workspace"
            });
            return issues;
        }

        // Check path length
        if (fullPath.Length > 260)
        {
            issues.Add(new ValidationIssue
            {
                OperationId = op.Id,
                Path = op.Path,
                Type = ValidationIssueType.PathTooLong,
                Severity = ValidationSeverity.Error,
                Message = "Path exceeds maximum length"
            });
        }

        // Check if file exists for create operations
        if (op.Type == FileOperationType.Create)
        {
            if (await _fileSystem.FileExistsAsync(fullPath, ct))
            {
                issues.Add(new ValidationIssue
                {
                    OperationId = op.Id,
                    Path = op.Path,
                    Type = ValidationIssueType.FileExists,
                    Severity = ValidationSeverity.Warning,
                    Message = "File already exists and will be overwritten",
                    SuggestedFix = "Deselect to skip or proceed to overwrite"
                });
            }
        }

        // Check for empty content
        if (op.Type is FileOperationType.Create or FileOperationType.Modify)
        {
            if (string.IsNullOrWhiteSpace(op.Content))
            {
                issues.Add(new ValidationIssue
                {
                    OperationId = op.Id,
                    Path = op.Path,
                    Type = ValidationIssueType.EmptyContent,
                    Severity = ValidationSeverity.Warning,
                    Message = "File content is empty"
                });
            }
        }

        return issues;
    }

    public async Task<BatchApplyResult> ApplyProposalAsync(
        FileTreeProposal proposal,
        string workspacePath,
        ApplyOptions? options = null,
        IProgress<BatchApplyProgress>? progress = null,
        CancellationToken ct = default)
    {
        options ??= ApplyOptions.Default;
        var startedAt = DateTime.UtcNow;
        var results = new List<ApplyResult>();
        var backupPaths = new List<string>();

        var selectedOps = proposal.SelectedOperations.ToList();
        int totalOps = selectedOps.Count;
        int completedOps = 0;

        try
        {
            // Phase 1: Validation
            ReportProgress(progress, new BatchApplyProgress
            {
                TotalOperations = totalOps,
                CompletedOperations = 0,
                Phase = BatchApplyPhase.Validating,
                CurrentFile = "Validating proposal..."
            });

            var validation = await ValidateProposalAsync(proposal, workspacePath, ct);
            if (!validation.IsValid)
            {
                _logger?.LogWarning("Proposal validation failed with {Count} errors",
                    validation.Errors.Count());

                // Mark operations with errors
                foreach (var error in validation.Errors)
                {
                    var op = selectedOps.FirstOrDefault(o => o.Id == error.OperationId);
                    if (op != null)
                    {
                        op.Status = FileOperationStatus.Failed;
                        op.ErrorMessage = error.Message;
                    }
                }
            }

            // Phase 2: Create directories
            ReportProgress(progress, new BatchApplyProgress
            {
                TotalOperations = totalOps,
                CompletedOperations = 0,
                Phase = BatchApplyPhase.CreatingDirectories,
                CurrentFile = "Creating directories..."
            });

            var directories = selectedOps
                .Where(o => o.Type == FileOperationType.Create)
                .Select(o => Path.GetDirectoryName(Path.Combine(workspacePath, o.Path)))
                .Where(d => !string.IsNullOrEmpty(d))
                .Distinct()
                .OrderBy(d => d!.Length);

            foreach (var dir in directories)
            {
                if (!Directory.Exists(dir))
                {
                    Directory.CreateDirectory(dir!);
                    _logger?.LogDebug("Created directory: {Dir}", dir);
                }
            }

            // Phase 3: Create backups
            if (options.CreateBackup)
            {
                ReportProgress(progress, new BatchApplyProgress
                {
                    TotalOperations = totalOps,
                    CompletedOperations = 0,
                    Phase = BatchApplyPhase.CreatingBackups,
                    CurrentFile = "Creating backups..."
                });

                foreach (var op in selectedOps.Where(o => o.Type == FileOperationType.Modify))
                {
                    var fullPath = Path.Combine(workspacePath, op.Path);
                    if (await _fileSystem.FileExistsAsync(fullPath, ct))
                    {
                        var backupPath = await _backupService.CreateBackupAsync(fullPath, ct);
                        backupPaths.Add(backupPath);
                    }
                }
            }

            // Phase 4: Apply operations
            foreach (var op in selectedOps.OrderBy(o => o.Order))
            {
                ct.ThrowIfCancellationRequested();

                ReportProgress(progress, new BatchApplyProgress
                {
                    TotalOperations = totalOps,
                    CompletedOperations = completedOps,
                    Phase = BatchApplyPhase.WritingFiles,
                    CurrentFile = op.Path,
                    CurrentOperation = op.Type
                });

                op.Status = FileOperationStatus.InProgress;

                try
                {
                    var result = await ApplyOperationAsync(op, workspacePath, options, ct);
                    results.Add(result);

                    op.Status = result.Success
                        ? FileOperationStatus.Applied
                        : FileOperationStatus.Failed;
                    op.ErrorMessage = result.ErrorMessage;
                }
                catch (Exception ex)
                {
                    op.Status = FileOperationStatus.Failed;
                    op.ErrorMessage = ex.Message;
                    results.Add(ApplyResult.Failed(
                        Path.Combine(workspacePath, op.Path),
                        ApplyResultType.Error,
                        ex.Message));
                }

                completedOps++;
            }

            // Phase 5: Finalize
            ReportProgress(progress, new BatchApplyProgress
            {
                TotalOperations = totalOps,
                CompletedOperations = totalOps,
                Phase = BatchApplyPhase.Completed,
                CurrentFile = "Complete"
            });

            // Update proposal status
            var successCount = results.Count(r => r.Success);
            proposal.Status = successCount == selectedOps.Count
                ? FileTreeProposalStatus.FullyApplied
                : successCount > 0
                    ? FileTreeProposalStatus.PartiallyApplied
                    : FileTreeProposalStatus.Pending;

            return new BatchApplyResult
            {
                AllSucceeded = successCount == selectedOps.Count,
                SuccessCount = successCount,
                FailedCount = results.Count(r => !r.Success),
                SkippedCount = selectedOps.Count(o => o.Status == FileOperationStatus.Skipped),
                Results = results,
                StartedAt = startedAt,
                CompletedAt = DateTime.UtcNow,
                BackupPaths = backupPaths
            };
        }
        catch (OperationCanceledException)
        {
            proposal.Status = FileTreeProposalStatus.Cancelled;

            // Rollback completed operations
            ReportProgress(progress, new BatchApplyProgress
            {
                TotalOperations = totalOps,
                CompletedOperations = completedOps,
                Phase = BatchApplyPhase.RollingBack,
                CurrentFile = "Rolling back..."
            });

            // TODO: Implement rollback

            throw;
        }
    }

    private async Task<ApplyResult> ApplyOperationAsync(
        FileOperation op,
        string workspacePath,
        ApplyOptions options,
        CancellationToken ct)
    {
        var fullPath = Path.Combine(workspacePath, op.Path);

        return op.Type switch
        {
            FileOperationType.Create or FileOperationType.Modify =>
                await WriteFileAsync(op, fullPath, options, ct),

            FileOperationType.Delete =>
                await DeleteFileAsync(fullPath, ct),

            FileOperationType.Rename when op.NewPath != null =>
                await RenameFileAsync(fullPath, Path.Combine(workspacePath, op.NewPath), ct),

            _ => ApplyResult.Failed(fullPath, ApplyResultType.ValidationFailed,
                $"Unsupported operation type: {op.Type}")
        };
    }

    private async Task<ApplyResult> WriteFileAsync(
        FileOperation op,
        string fullPath,
        ApplyOptions options,
        CancellationToken ct)
    {
        var fileExists = await _fileSystem.FileExistsAsync(fullPath, ct);

        await _fileSystem.WriteFileAsync(fullPath, op.Content ?? string.Empty, ct);

        return ApplyResult.Succeeded(
            fullPath,
            op.Path,
            fileExists ? ApplyResultType.Modified : ApplyResultType.Created);
    }

    private async Task<ApplyResult> DeleteFileAsync(string fullPath, CancellationToken ct)
    {
        if (await _fileSystem.FileExistsAsync(fullPath, ct))
        {
            await Task.Run(() => File.Delete(fullPath), ct);
            return ApplyResult.Succeeded(fullPath, fullPath, ApplyResultType.Success);
        }

        return ApplyResult.Failed(fullPath, ApplyResultType.FileNotFound, "File not found");
    }

    private async Task<ApplyResult> RenameFileAsync(
        string oldPath,
        string newPath,
        CancellationToken ct)
    {
        if (!await _fileSystem.FileExistsAsync(oldPath, ct))
        {
            return ApplyResult.Failed(oldPath, ApplyResultType.FileNotFound, "File not found");
        }

        await Task.Run(() => File.Move(oldPath, newPath), ct);
        return ApplyResult.Succeeded(newPath, newPath, ApplyResultType.Success);
    }

    public async Task<IReadOnlyList<DiffResult>> PreviewProposalAsync(
        FileTreeProposal proposal,
        string workspacePath,
        CancellationToken ct = default)
    {
        var diffs = new List<DiffResult>();

        foreach (var op in proposal.SelectedOperations)
        {
            if (op.Type is not (FileOperationType.Create or FileOperationType.Modify))
                continue;

            if (op.CodeBlockId.HasValue)
            {
                var block = new CodeBlock
                {
                    Id = op.CodeBlockId.Value,
                    Content = op.Content ?? string.Empty,
                    TargetFilePath = op.Path,
                    Language = op.Language,
                    BlockType = CodeBlockType.CompleteFile
                };

                var diff = await _diffService.ComputeDiffForBlockAsync(block, workspacePath, ct);
                diffs.Add(diff);
            }
            else
            {
                var fullPath = Path.Combine(workspacePath, op.Path);
                var exists = await _fileSystem.FileExistsAsync(fullPath, ct);

                if (exists)
                {
                    var original = await _fileSystem.ReadFileAsync(fullPath, ct);
                    diffs.Add(_diffService.ComputeDiff(original, op.Content ?? "", op.Path));
                }
                else
                {
                    diffs.Add(_diffService.ComputeNewFileDiff(op.Content ?? "", op.Path));
                }
            }
        }

        return diffs;
    }

    public async Task<bool> UndoBatchApplyAsync(
        BatchApplyResult result,
        CancellationToken ct = default)
    {
        if (!result.CanUndoAll)
            return false;

        var allSuccess = true;

        // Undo in reverse order
        foreach (var applyResult in result.Results.Reverse())
        {
            if (applyResult.CanUndo)
            {
                var success = await _changeService.UndoLastChangeAsync(
                    applyResult.FilePath, ct);
                if (!success)
                    allSuccess = false;
            }
        }

        return allSuccess;
    }

    public async Task<IReadOnlyDictionary<string, bool>> CheckExistingFilesAsync(
        FileTreeProposal proposal,
        string workspacePath,
        CancellationToken ct = default)
    {
        var results = new Dictionary<string, bool>();

        foreach (var op in proposal.Operations)
        {
            var fullPath = Path.Combine(workspacePath, op.Path);
            results[op.Path] = await _fileSystem.FileExistsAsync(fullPath, ct);
        }

        return results;
    }

    private void ReportProgress(IProgress<BatchApplyProgress>? progress, BatchApplyProgress value)
    {
        progress?.Report(value);
        ProgressChanged?.Invoke(this, value);
    }

    private static bool IsValidPath(string path)
    {
        if (string.IsNullOrWhiteSpace(path))
            return false;

        var invalidChars = Path.GetInvalidPathChars();
        return !path.Any(c => invalidChars.Contains(c));
    }

    private static bool IsWithinWorkspace(string fullPath, string workspacePath)
    {
        var normalizedFull = Path.GetFullPath(fullPath);
        var normalizedWorkspace = Path.GetFullPath(workspacePath);
        return normalizedFull.StartsWith(normalizedWorkspace, StringComparison.OrdinalIgnoreCase);
    }
}
```

### Files to Create (v0.4.4c)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/IFileTreeProposalService.cs` | Service interface |
| `src/SeniorIntern.Services/FileTreeProposalService.cs` | Service implementation |

### Testing Strategy (v0.4.4c)

```csharp
public class FileTreeProposalServiceTests
{
    [Fact]
    public async Task ValidateProposalAsync_ValidProposal_ReturnsValid()
    {
        var service = CreateService();
        var proposal = CreateValidProposal();

        var result = await service.ValidateProposalAsync(proposal, _workspacePath);

        Assert.True(result.IsValid);
    }

    [Fact]
    public async Task ValidateProposalAsync_DuplicatePaths_ReturnsError()
    {
        var service = CreateService();
        var proposal = new FileTreeProposal
        {
            Operations = new[]
            {
                new FileOperation { Path = "src/File.cs" },
                new FileOperation { Path = "src/File.cs" }
            }
        };

        var result = await service.ValidateProposalAsync(proposal, _workspacePath);

        Assert.False(result.IsValid);
        Assert.Contains(result.Issues, i => i.Type == ValidationIssueType.DuplicatePath);
    }

    [Fact]
    public async Task ApplyProposalAsync_CreatesAllFiles()
    {
        var service = CreateService();
        var proposal = CreateValidProposal();

        var result = await service.ApplyProposalAsync(proposal, _workspacePath);

        Assert.True(result.AllSucceeded);
        Assert.Equal(proposal.FileCount, result.SuccessCount);
    }

    [Fact]
    public async Task ApplyProposalAsync_ReportsProgress()
    {
        var service = CreateService();
        var proposal = CreateValidProposal();
        var progressReports = new List<BatchApplyProgress>();

        await service.ApplyProposalAsync(
            proposal,
            _workspacePath,
            progress: new Progress<BatchApplyProgress>(p => progressReports.Add(p)));

        Assert.NotEmpty(progressReports);
        Assert.Contains(progressReports, p => p.Phase == BatchApplyPhase.Completed);
    }
}
```

### Acceptance Criteria (v0.4.4c)

- [ ] Validation detects duplicate paths
- [ ] Validation detects invalid paths
- [ ] Validation warns about existing files
- [ ] Directories created before files
- [ ] Backups created when configured
- [ ] Progress reported during apply
- [ ] Cancellation supported
- [ ] Rollback on failure
- [ ] Undo batch available

---

## v0.4.4d: Tree ViewModels

### Objective
Create ViewModels for displaying the file tree and managing selection state.

### FileTreeProposalViewModel

```csharp
// src/SeniorIntern.Desktop/ViewModels/FileTreeProposalViewModel.cs
namespace SeniorIntern.Desktop.ViewModels;

public partial class FileTreeProposalViewModel : ViewModelBase
{
    private readonly IFileTreeProposalService _proposalService;
    private readonly IDiffService _diffService;
    private readonly string _workspacePath;

    [ObservableProperty]
    private FileTreeProposal _proposal;

    [ObservableProperty]
    private ObservableCollection<FileTreeItemViewModel> _treeItems = new();

    [ObservableProperty]
    private FileTreeItemViewModel? _selectedItem;

    [ObservableProperty]
    private string? _description;

    [ObservableProperty]
    private int _fileCount;

    [ObservableProperty]
    private int _directoryCount;

    [ObservableProperty]
    private int _selectedCount;

    [ObservableProperty]
    private bool _hasSelectedFiles;

    [ObservableProperty]
    private bool _createBackups = true;

    [ObservableProperty]
    private bool _isApplying;

    [ObservableProperty]
    private double _applyProgress;

    [ObservableProperty]
    private string _currentFile = string.Empty;

    [ObservableProperty]
    private ProposalValidationResult? _validationResult;

    [ObservableProperty]
    private bool _hasWarnings;

    [ObservableProperty]
    private bool _hasErrors;

    public FileTreeProposalViewModel(
        FileTreeProposal proposal,
        IFileTreeProposalService proposalService,
        IDiffService diffService,
        string workspacePath)
    {
        _proposal = proposal;
        _proposalService = proposalService;
        _diffService = diffService;
        _workspacePath = workspacePath;

        Description = proposal.Description;
        FileCount = proposal.FileCount;
        DirectoryCount = proposal.DirectoryCount;

        BuildTree();
        UpdateSelectedCount();

        _ = ValidateAsync();
    }

    private void BuildTree()
    {
        TreeItems.Clear();

        // Group operations by directory
        var grouped = Proposal.Operations
            .GroupBy(o => Path.GetDirectoryName(o.Path) ?? "")
            .OrderBy(g => g.Key);

        var rootItems = new Dictionary<string, FileTreeItemViewModel>();

        foreach (var group in grouped)
        {
            var pathParts = group.Key.Split('/', '\\')
                .Where(p => !string.IsNullOrEmpty(p))
                .ToList();

            FileTreeItemViewModel? parent = null;

            // Create directory nodes
            for (int i = 0; i < pathParts.Count; i++)
            {
                var partPath = string.Join("/", pathParts.Take(i + 1));

                if (!rootItems.TryGetValue(partPath, out var dirItem))
                {
                    dirItem = new FileTreeItemViewModel
                    {
                        Name = pathParts[i],
                        Path = partPath,
                        IsDirectory = true,
                        IsExpanded = true
                    };

                    rootItems[partPath] = dirItem;

                    if (parent == null)
                    {
                        TreeItems.Add(dirItem);
                    }
                    else
                    {
                        parent.Children.Add(dirItem);
                    }
                }

                parent = dirItem;
            }

            // Add file nodes
            foreach (var op in group.OrderBy(o => o.FileName))
            {
                var fileItem = new FileTreeItemViewModel
                {
                    Name = op.FileName,
                    Path = op.Path,
                    IsDirectory = false,
                    Operation = op,
                    Language = op.DisplayLanguage,
                    IsSelected = op.IsSelected
                };

                fileItem.PropertyChanged += OnFileItemPropertyChanged;

                if (parent != null)
                {
                    parent.Children.Add(fileItem);
                }
                else
                {
                    TreeItems.Add(fileItem);
                }
            }
        }
    }

    private void OnFileItemPropertyChanged(object? sender, PropertyChangedEventArgs e)
    {
        if (e.PropertyName == nameof(FileTreeItemViewModel.IsSelected))
        {
            var item = (FileTreeItemViewModel)sender!;
            if (item.Operation != null)
            {
                item.Operation.IsSelected = item.IsSelected;
            }
            UpdateSelectedCount();
        }
    }

    private void UpdateSelectedCount()
    {
        SelectedCount = Proposal.SelectedCount;
        HasSelectedFiles = SelectedCount > 0;
    }

    private async Task ValidateAsync()
    {
        ValidationResult = await _proposalService.ValidateProposalAsync(
            Proposal, _workspacePath);

        HasWarnings = ValidationResult.HasWarnings;
        HasErrors = ValidationResult.HasErrors;

        // Update tree items with validation status
        foreach (var issue in ValidationResult.Issues)
        {
            var item = FindItemByPath(issue.Path);
            if (item != null)
            {
                item.ValidationIssue = issue;
            }
        }
    }

    private FileTreeItemViewModel? FindItemByPath(string path)
    {
        return FindItemRecursive(TreeItems, path);
    }

    private FileTreeItemViewModel? FindItemRecursive(
        IEnumerable<FileTreeItemViewModel> items,
        string path)
    {
        foreach (var item in items)
        {
            if (item.Path.Equals(path, StringComparison.OrdinalIgnoreCase))
                return item;

            var found = FindItemRecursive(item.Children, path);
            if (found != null)
                return found;
        }
        return null;
    }

    [RelayCommand]
    private void SelectAll()
    {
        SetAllSelected(true);
    }

    [RelayCommand]
    private void DeselectAll()
    {
        SetAllSelected(false);
    }

    private void SetAllSelected(bool selected)
    {
        foreach (var item in GetAllFileItems())
        {
            item.IsSelected = selected;
        }
    }

    private IEnumerable<FileTreeItemViewModel> GetAllFileItems()
    {
        return GetAllItemsRecursive(TreeItems).Where(i => !i.IsDirectory);
    }

    private IEnumerable<FileTreeItemViewModel> GetAllItemsRecursive(
        IEnumerable<FileTreeItemViewModel> items)
    {
        foreach (var item in items)
        {
            yield return item;
            foreach (var child in GetAllItemsRecursive(item.Children))
            {
                yield return child;
            }
        }
    }

    [RelayCommand]
    private async Task PreviewAsync()
    {
        var diffs = await _proposalService.PreviewProposalAsync(Proposal, _workspacePath);
        // Show BatchPreviewDialog
        PreviewRequested?.Invoke(this, diffs);
    }

    [RelayCommand]
    private async Task ApplyAsync()
    {
        if (!HasSelectedFiles || IsApplying)
            return;

        try
        {
            IsApplying = true;

            var options = new ApplyOptions { CreateBackup = CreateBackups };
            var progress = new Progress<BatchApplyProgress>(OnProgressUpdate);

            var result = await _proposalService.ApplyProposalAsync(
                Proposal, _workspacePath, options, progress);

            ApplyCompleted?.Invoke(this, result);
        }
        finally
        {
            IsApplying = false;
        }
    }

    private void OnProgressUpdate(BatchApplyProgress progress)
    {
        ApplyProgress = progress.ProgressPercent;
        CurrentFile = progress.CurrentFile;
    }

    public event EventHandler<IReadOnlyList<DiffResult>>? PreviewRequested;
    public event EventHandler<BatchApplyResult>? ApplyCompleted;
}
```

### FileTreeItemViewModel

```csharp
// src/SeniorIntern.Desktop/ViewModels/FileTreeItemViewModel.cs
namespace SeniorIntern.Desktop.ViewModels;

public partial class FileTreeItemViewModel : ViewModelBase
{
    [ObservableProperty]
    private string _name = string.Empty;

    [ObservableProperty]
    private string _path = string.Empty;

    [ObservableProperty]
    private bool _isDirectory;

    [ObservableProperty]
    private bool _isExpanded = true;

    [ObservableProperty]
    private bool _isSelected = true;

    [ObservableProperty]
    private FileOperation? _operation;

    [ObservableProperty]
    private string? _language;

    [ObservableProperty]
    private bool _fileExists;

    [ObservableProperty]
    private ValidationIssue? _validationIssue;

    [ObservableProperty]
    private ObservableCollection<FileTreeItemViewModel> _children = new();

    public bool IsFile => !IsDirectory;

    public bool HasChildren => Children.Count > 0;

    public bool HasWarning => ValidationIssue?.Severity == ValidationSeverity.Warning;

    public bool HasError => ValidationIssue?.Severity == ValidationSeverity.Error;

    public string Icon => IsDirectory
        ? (IsExpanded ? "FolderOpenIcon" : "FolderIcon")
        : GetFileIcon();

    public string StatusText => Operation?.Status switch
    {
        FileOperationStatus.Applied => "Applied",
        FileOperationStatus.Failed => "Failed",
        FileOperationStatus.Skipped => "Skipped",
        FileOperationStatus.InProgress => "Applying...",
        _ => FileExists ? "Exists" : ""
    };

    private string GetFileIcon()
    {
        return Path.GetExtension(_path).ToLowerInvariant() switch
        {
            ".cs" => "CSharpIcon",
            ".ts" or ".tsx" => "TypeScriptIcon",
            ".js" or ".jsx" => "JavaScriptIcon",
            ".py" => "PythonIcon",
            ".json" => "JsonIcon",
            ".xml" or ".axaml" or ".xaml" => "XmlIcon",
            ".md" => "MarkdownIcon",
            ".html" => "HtmlIcon",
            ".css" or ".scss" => "CssIcon",
            _ => "FileIcon"
        };
    }

    partial void OnIsExpandedChanged(bool value)
    {
        OnPropertyChanged(nameof(Icon));
    }
}
```

### Files to Create (v0.4.4d)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/ViewModels/FileTreeProposalViewModel.cs` | Main proposal VM |
| `src/SeniorIntern.Desktop/ViewModels/FileTreeItemViewModel.cs` | Tree item VM |

### Acceptance Criteria (v0.4.4d)

- [ ] Tree structure built correctly from operations
- [ ] Selection state syncs with operations
- [ ] Directory nodes group files properly
- [ ] Validation issues displayed on items
- [ ] Select/Deselect All works
- [ ] Progress updates during apply

---

## v0.4.4e: Proposal Panel

### Objective
Create the UI panel for displaying multi-file proposals with tree visualization.

### FileTreeProposalPanel.axaml

```xml
<!-- src/SeniorIntern.Desktop/Controls/FileTreeProposalPanel.axaml -->
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:vm="using:SeniorIntern.Desktop.ViewModels"
             xmlns:controls="using:SeniorIntern.Desktop.Controls"
             x:Class="SeniorIntern.Desktop.Controls.FileTreeProposalPanel"
             x:DataType="vm:FileTreeProposalViewModel">

    <Border Classes="proposal-panel"
            Background="{DynamicResource SurfaceBackground}"
            BorderBrush="{DynamicResource AccentBrush}"
            BorderThickness="1,1,1,3"
            CornerRadius="6"
            Margin="0,8"
            Padding="16">

        <Grid RowDefinitions="Auto, Auto, *, Auto, Auto">
            <!-- Header -->
            <Grid ColumnDefinitions="Auto, *, Auto">
                <PathIcon Data="{StaticResource FolderPlusIcon}"
                          Width="24" Height="24"
                          Foreground="{DynamicResource AccentBrush}" />

                <StackPanel Grid.Column="1" Margin="12,0,0,0">
                    <TextBlock Text="Multi-File Proposal"
                               FontWeight="SemiBold"
                               FontSize="16" />
                    <TextBlock Text="{Binding Description}"
                               Foreground="{DynamicResource TextMuted}"
                               TextWrapping="Wrap"
                               IsVisible="{Binding Description, Converter={x:Static StringConverters.IsNotNullOrEmpty}}" />
                </StackPanel>

                <StackPanel Grid.Column="2"
                            Orientation="Horizontal"
                            Spacing="12">
                    <StackPanel Orientation="Horizontal" Spacing="4">
                        <PathIcon Data="{StaticResource FileIcon}"
                                  Width="14" Height="14"
                                  Foreground="{DynamicResource TextMuted}" />
                        <TextBlock Text="{Binding FileCount, StringFormat='{}{0} files'}" />
                    </StackPanel>
                    <StackPanel Orientation="Horizontal" Spacing="4">
                        <PathIcon Data="{StaticResource FolderIcon}"
                                  Width="14" Height="14"
                                  Foreground="{DynamicResource TextMuted}" />
                        <TextBlock Text="{Binding DirectoryCount, StringFormat='{}{0} folders'}" />
                    </StackPanel>
                </StackPanel>
            </Grid>

            <!-- Validation Messages -->
            <Border Grid.Row="1"
                    IsVisible="{Binding HasErrors}"
                    Background="{DynamicResource ErrorBackgroundBrush}"
                    CornerRadius="4"
                    Padding="12,8"
                    Margin="0,12,0,0">
                <StackPanel Orientation="Horizontal" Spacing="8">
                    <PathIcon Data="{StaticResource ErrorIcon}"
                              Width="16" Height="16"
                              Foreground="{DynamicResource ErrorForeground}" />
                    <TextBlock Text="Some files have validation errors"
                               Foreground="{DynamicResource ErrorForeground}" />
                </StackPanel>
            </Border>

            <!-- Selection Controls -->
            <StackPanel Grid.Row="1"
                        Orientation="Horizontal"
                        Spacing="8"
                        Margin="0,12,0,0"
                        IsVisible="{Binding !HasErrors}">
                <Button Content="Select All"
                        Command="{Binding SelectAllCommand}"
                        Classes="secondary"
                        Padding="8,4" />
                <Button Content="Deselect All"
                        Command="{Binding DeselectAllCommand}"
                        Classes="secondary"
                        Padding="8,4" />
                <TextBlock VerticalAlignment="Center"
                           Margin="8,0,0,0">
                    <TextBlock.Text>
                        <MultiBinding StringFormat="{}{0} of {1} selected">
                            <Binding Path="SelectedCount" />
                            <Binding Path="FileCount" />
                        </MultiBinding>
                    </TextBlock.Text>
                </TextBlock>
            </StackPanel>

            <!-- File Tree -->
            <TreeView Grid.Row="2"
                      ItemsSource="{Binding TreeItems}"
                      SelectedItem="{Binding SelectedItem}"
                      Margin="0,12"
                      MaxHeight="300">
                <TreeView.ItemTemplate>
                    <TreeDataTemplate ItemsSource="{Binding Children}">
                        <Grid ColumnDefinitions="Auto, Auto, *, Auto, Auto">
                            <!-- Checkbox (files only) -->
                            <CheckBox IsChecked="{Binding IsSelected}"
                                      IsVisible="{Binding IsFile}"
                                      Margin="0,0,4,0" />

                            <!-- Icon -->
                            <PathIcon Grid.Column="1"
                                      Data="{Binding Icon, Converter={StaticResource IconNameConverter}}"
                                      Width="16" Height="16"
                                      Margin="0,0,8,0" />

                            <!-- Name -->
                            <TextBlock Grid.Column="2"
                                       Text="{Binding Name}"
                                       VerticalAlignment="Center" />

                            <!-- Language Badge -->
                            <Border Grid.Column="3"
                                    Classes="language-badge"
                                    IsVisible="{Binding Language, Converter={x:Static StringConverters.IsNotNullOrEmpty}}"
                                    Margin="8,0,0,0">
                                <TextBlock Text="{Binding Language}" FontSize="10" />
                            </Border>

                            <!-- Status/Warning -->
                            <StackPanel Grid.Column="4"
                                        Orientation="Horizontal"
                                        Spacing="4"
                                        Margin="8,0,0,0">
                                <!-- Exists Badge -->
                                <Border Classes="exists-badge"
                                        IsVisible="{Binding FileExists}"
                                        Padding="4,2"
                                        CornerRadius="3">
                                    <TextBlock Text="exists"
                                               FontSize="10"
                                               Foreground="{DynamicResource WarningForeground}" />
                                </Border>

                                <!-- Warning Icon -->
                                <PathIcon Data="{StaticResource WarningIcon}"
                                          Width="14" Height="14"
                                          Foreground="{DynamicResource WarningForeground}"
                                          IsVisible="{Binding HasWarning}"
                                          ToolTip.Tip="{Binding ValidationIssue.Message}" />

                                <!-- Error Icon -->
                                <PathIcon Data="{StaticResource ErrorIcon}"
                                          Width="14" Height="14"
                                          Foreground="{DynamicResource ErrorForeground}"
                                          IsVisible="{Binding HasError}"
                                          ToolTip.Tip="{Binding ValidationIssue.Message}" />
                            </StackPanel>
                        </Grid>
                    </TreeDataTemplate>
                </TreeView.ItemTemplate>
            </TreeView>

            <!-- Options -->
            <StackPanel Grid.Row="3"
                        Orientation="Horizontal"
                        Spacing="16"
                        Margin="0,0,0,12">
                <CheckBox Content="Create backup for existing files"
                          IsChecked="{Binding CreateBackups}" />
            </StackPanel>

            <!-- Actions -->
            <Grid Grid.Row="4" ColumnDefinitions="*, Auto">
                <!-- Progress (when applying) -->
                <StackPanel IsVisible="{Binding IsApplying}" Spacing="8">
                    <ProgressBar Value="{Binding ApplyProgress}"
                                 Minimum="0" Maximum="100" />
                    <TextBlock Text="{Binding CurrentFile}"
                               FontSize="12"
                               Foreground="{DynamicResource TextMuted}"
                               TextTrimming="CharacterEllipsis" />
                </StackPanel>

                <!-- Buttons -->
                <StackPanel Grid.Column="1"
                            Orientation="Horizontal"
                            Spacing="8">
                    <Button Content="Preview"
                            Command="{Binding PreviewCommand}"
                            IsEnabled="{Binding !IsApplying}" />
                    <Button Classes="accent"
                            Command="{Binding ApplyCommand}"
                            IsEnabled="{Binding HasSelectedFiles}">
                        <StackPanel Orientation="Horizontal" Spacing="8">
                            <ProgressBar IsVisible="{Binding IsApplying}"
                                         IsIndeterminate="True"
                                         Width="16" Height="16" />
                            <TextBlock Text="{Binding IsApplying,
                                Converter={StaticResource BoolToStringConverter},
                                ConverterParameter='Creating...|Create Files'}" />
                        </StackPanel>
                    </Button>
                </StackPanel>
            </Grid>
        </Grid>
    </Border>
</UserControl>
```

### Files to Create (v0.4.4e)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/Controls/FileTreeProposalPanel.axaml` | Proposal panel UI |
| `src/SeniorIntern.Desktop/Controls/FileTreeProposalPanel.axaml.cs` | Panel code-behind |

### Acceptance Criteria (v0.4.4e)

- [ ] Tree displays directory structure
- [ ] Checkboxes control file selection
- [ ] Expand/collapse works for directories
- [ ] Language badges show on files
- [ ] Exists badges show for existing files
- [ ] Warning/error icons show on issues
- [ ] Progress bar during apply

---

## v0.4.4f: Batch Preview

### Objective
Create a dialog for previewing all file changes in a batch proposal.

### BatchPreviewDialogViewModel

```csharp
// src/SeniorIntern.Desktop/ViewModels/BatchPreviewDialogViewModel.cs
namespace SeniorIntern.Desktop.ViewModels;

public partial class BatchPreviewDialogViewModel : ViewModelBase
{
    private readonly Window _dialog;

    [ObservableProperty]
    private ObservableCollection<DiffPreviewViewModel> _diffPreviews = new();

    [ObservableProperty]
    private DiffPreviewViewModel? _selectedPreview;

    [ObservableProperty]
    private int _selectedIndex;

    [ObservableProperty]
    private bool _isApplying;

    [ObservableProperty]
    private double _progress;

    public int TotalFiles => DiffPreviews.Count;
    public int NewFiles => DiffPreviews.Count(d => d.IsNewFile);
    public int ModifiedFiles => DiffPreviews.Count(d => !d.IsNewFile);

    public BatchPreviewDialogViewModel(
        IReadOnlyList<DiffResult> diffs,
        Window dialog)
    {
        _dialog = dialog;

        foreach (var diff in diffs)
        {
            DiffPreviews.Add(new DiffPreviewViewModel(diff));
        }

        if (DiffPreviews.Count > 0)
        {
            SelectedPreview = DiffPreviews[0];
        }
    }

    [RelayCommand]
    private void NextFile()
    {
        if (SelectedIndex < DiffPreviews.Count - 1)
        {
            SelectedIndex++;
            SelectedPreview = DiffPreviews[SelectedIndex];
        }
    }

    [RelayCommand]
    private void PreviousFile()
    {
        if (SelectedIndex > 0)
        {
            SelectedIndex--;
            SelectedPreview = DiffPreviews[SelectedIndex];
        }
    }

    [RelayCommand]
    private void ApplyAll()
    {
        _dialog.Close(true);
    }

    [RelayCommand]
    private void Cancel()
    {
        _dialog.Close(false);
    }
}

public partial class DiffPreviewViewModel : ViewModelBase
{
    private readonly DiffResult _diff;

    [ObservableProperty]
    private DiffViewerViewModel _diffViewModel;

    public string FileName => Path.GetFileName(_diff.OriginalFilePath);
    public string FilePath => _diff.OriginalFilePath;
    public bool IsNewFile => _diff.IsNewFile;
    public int AddedLines => _diff.Stats.AddedLines;
    public int RemovedLines => _diff.Stats.RemovedLines;

    public DiffPreviewViewModel(DiffResult diff)
    {
        _diff = diff;
        // DiffViewModel would be initialized with proper services
    }
}
```

### BatchPreviewDialog.axaml

```xml
<!-- src/SeniorIntern.Desktop/Views/BatchPreviewDialog.axaml -->
<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:vm="using:SeniorIntern.Desktop.ViewModels"
        xmlns:views="using:SeniorIntern.Desktop.Views"
        x:Class="SeniorIntern.Desktop.Views.BatchPreviewDialog"
        x:DataType="vm:BatchPreviewDialogViewModel"
        Title="Preview All Changes"
        Width="1000" Height="700"
        MinWidth="800" MinHeight="500"
        WindowStartupLocation="CenterOwner">

    <Grid RowDefinitions="Auto, *, Auto">
        <!-- Header with file tabs -->
        <Border Grid.Row="0"
                Background="{DynamicResource SurfaceBackground}"
                BorderBrush="{DynamicResource BorderBrush}"
                BorderThickness="0,0,0,1"
                Padding="8">
            <Grid RowDefinitions="Auto, Auto">
                <!-- Stats -->
                <StackPanel Orientation="Horizontal" Spacing="16" Margin="8,0,0,8">
                    <TextBlock>
                        <TextBlock.Text>
                            <MultiBinding StringFormat="{}{0} files to create">
                                <Binding Path="TotalFiles" />
                            </MultiBinding>
                        </TextBlock.Text>
                    </TextBlock>
                    <StackPanel Orientation="Horizontal" Spacing="4">
                        <TextBlock Text="{Binding NewFiles, StringFormat='{}{0} new'}"
                                   Foreground="{DynamicResource DiffAddedForeground}" />
                        <TextBlock Text="•" Foreground="{DynamicResource TextMuted}" />
                        <TextBlock Text="{Binding ModifiedFiles, StringFormat='{}{0} modified'}"
                                   Foreground="{DynamicResource DiffModifiedForeground}" />
                    </StackPanel>
                </StackPanel>

                <!-- File Tabs -->
                <ScrollViewer Grid.Row="1"
                              HorizontalScrollBarVisibility="Auto"
                              VerticalScrollBarVisibility="Disabled">
                    <ItemsControl ItemsSource="{Binding DiffPreviews}">
                        <ItemsControl.ItemsPanel>
                            <ItemsPanelTemplate>
                                <StackPanel Orientation="Horizontal" Spacing="4" />
                            </ItemsPanelTemplate>
                        </ItemsControl.ItemsPanel>
                        <ItemsControl.ItemTemplate>
                            <DataTemplate DataType="{x:Type vm:DiffPreviewViewModel}">
                                <Button Classes="file-tab"
                                        Classes.selected="{Binding $parent[ItemsControl].DataContext.SelectedPreview,
                                            Converter={StaticResource ReferenceEqualsConverter},
                                            ConverterParameter={Binding}}"
                                        Command="{Binding $parent[ItemsControl].DataContext.SelectPreviewCommand}"
                                        CommandParameter="{Binding}">
                                    <StackPanel Orientation="Horizontal" Spacing="6">
                                        <TextBlock Text="{Binding FileName}" />
                                        <Border Classes="new-badge"
                                                IsVisible="{Binding IsNewFile}"
                                                Padding="4,1"
                                                CornerRadius="3">
                                            <TextBlock Text="NEW" FontSize="9" />
                                        </Border>
                                        <StackPanel Orientation="Horizontal"
                                                    Spacing="4"
                                                    IsVisible="{Binding !IsNewFile}">
                                            <TextBlock Text="{Binding AddedLines, StringFormat='+{0}'}"
                                                       Foreground="{DynamicResource DiffAddedForeground}"
                                                       FontSize="11" />
                                            <TextBlock Text="{Binding RemovedLines, StringFormat='-{0}'}"
                                                       Foreground="{DynamicResource DiffRemovedForeground}"
                                                       FontSize="11" />
                                        </StackPanel>
                                    </StackPanel>
                                </Button>
                            </DataTemplate>
                        </ItemsControl.ItemTemplate>
                    </ItemsControl>
                </ScrollViewer>
            </Grid>
        </Border>

        <!-- Diff Content -->
        <views:DiffViewerPanel Grid.Row="1"
                               DataContext="{Binding SelectedPreview.DiffViewModel}" />

        <!-- Footer -->
        <Border Grid.Row="2"
                Background="{DynamicResource SurfaceBackground}"
                BorderBrush="{DynamicResource BorderBrush}"
                BorderThickness="0,1,0,0"
                Padding="16,12">
            <Grid ColumnDefinitions="Auto, *, Auto">
                <!-- Navigation -->
                <StackPanel Orientation="Horizontal" Spacing="8">
                    <Button Content="← Previous"
                            Command="{Binding PreviousFileCommand}"
                            Classes="secondary" />
                    <Button Content="Next →"
                            Command="{Binding NextFileCommand}"
                            Classes="secondary" />
                    <TextBlock VerticalAlignment="Center" Margin="8,0,0,0">
                        <TextBlock.Text>
                            <MultiBinding StringFormat="File {0} of {1}">
                                <Binding Path="SelectedIndex"
                                         Converter="{StaticResource IncrementConverter}" />
                                <Binding Path="TotalFiles" />
                            </MultiBinding>
                        </TextBlock.Text>
                    </TextBlock>
                </StackPanel>

                <!-- Actions -->
                <StackPanel Grid.Column="2"
                            Orientation="Horizontal"
                            Spacing="8">
                    <Button Content="Cancel"
                            Command="{Binding CancelCommand}" />
                    <Button Content="Create All Files"
                            Command="{Binding ApplyAllCommand}"
                            Classes="accent" />
                </StackPanel>
            </Grid>
        </Border>
    </Grid>
</Window>
```

### Files to Create (v0.4.4f)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/ViewModels/BatchPreviewDialogViewModel.cs` | Dialog ViewModel |
| `src/SeniorIntern.Desktop/Views/BatchPreviewDialog.axaml` | Dialog UI |
| `src/SeniorIntern.Desktop/Views/BatchPreviewDialog.axaml.cs` | Dialog code-behind |

### Acceptance Criteria (v0.4.4f)

- [ ] All diffs shown in tabs
- [ ] Navigation between files works
- [ ] Stats show new vs modified
- [ ] Cancel returns false
- [ ] Apply All returns true

---

## v0.4.4g: Progress Overlay

### Objective
Create a progress overlay that shows during batch apply operations.

### ApplyProgressOverlay.axaml

```xml
<!-- src/SeniorIntern.Desktop/Controls/ApplyProgressOverlay.axaml -->
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:vm="using:SeniorIntern.Desktop.ViewModels"
             x:Class="SeniorIntern.Desktop.Controls.ApplyProgressOverlay"
             x:DataType="vm:ApplyProgressViewModel"
             IsVisible="{Binding IsVisible}">

    <Border Background="#CC000000">
        <Border Background="{DynamicResource SurfaceBackground}"
                CornerRadius="8"
                Padding="32"
                HorizontalAlignment="Center"
                VerticalAlignment="Center"
                MinWidth="400"
                BoxShadow="0 8 32 0 #80000000">
            <Grid RowDefinitions="Auto, Auto, Auto, Auto, Auto">
                <!-- Phase Icon -->
                <PathIcon Grid.Row="0"
                          Data="{Binding PhaseIcon}"
                          Width="48" Height="48"
                          Foreground="{DynamicResource AccentBrush}"
                          HorizontalAlignment="Center"
                          Margin="0,0,0,16" />

                <!-- Phase Title -->
                <TextBlock Grid.Row="1"
                           Text="{Binding PhaseTitle}"
                           FontSize="18"
                           FontWeight="SemiBold"
                           HorizontalAlignment="Center"
                           Margin="0,0,0,8" />

                <!-- Current File -->
                <TextBlock Grid.Row="2"
                           Text="{Binding CurrentFile}"
                           Foreground="{DynamicResource TextMuted}"
                           HorizontalAlignment="Center"
                           TextTrimming="CharacterEllipsis"
                           MaxWidth="350"
                           Margin="0,0,0,16" />

                <!-- Progress Bar -->
                <Grid Grid.Row="3" ColumnDefinitions="*, Auto" Margin="0,0,0,8">
                    <ProgressBar Value="{Binding ProgressPercent}"
                                 Minimum="0" Maximum="100"
                                 Height="8" />
                    <TextBlock Grid.Column="1"
                               Text="{Binding ProgressPercent, StringFormat='{}{0:F0}%'}"
                               Margin="12,0,0,0"
                               FontWeight="SemiBold" />
                </Grid>

                <!-- File Count -->
                <TextBlock Grid.Row="4"
                           HorizontalAlignment="Center"
                           Foreground="{DynamicResource TextMuted}">
                    <TextBlock.Text>
                        <MultiBinding StringFormat="{}{0} of {1} files">
                            <Binding Path="CompletedCount" />
                            <Binding Path="TotalCount" />
                        </MultiBinding>
                    </TextBlock.Text>
                </TextBlock>

                <!-- Cancel Button -->
                <Button Grid.Row="4"
                        Content="Cancel"
                        Command="{Binding CancelCommand}"
                        IsVisible="{Binding CanCancel}"
                        HorizontalAlignment="Right"
                        Classes="secondary" />
            </Grid>
        </Border>
    </Border>
</UserControl>
```

### ApplyProgressViewModel

```csharp
// src/SeniorIntern.Desktop/ViewModels/ApplyProgressViewModel.cs
namespace SeniorIntern.Desktop.ViewModels;

public partial class ApplyProgressViewModel : ViewModelBase
{
    private CancellationTokenSource? _cts;

    [ObservableProperty]
    private bool _isVisible;

    [ObservableProperty]
    private BatchApplyPhase _phase;

    [ObservableProperty]
    private string _currentFile = string.Empty;

    [ObservableProperty]
    private double _progressPercent;

    [ObservableProperty]
    private int _completedCount;

    [ObservableProperty]
    private int _totalCount;

    [ObservableProperty]
    private bool _canCancel = true;

    public string PhaseTitle => Phase switch
    {
        BatchApplyPhase.Validating => "Validating...",
        BatchApplyPhase.CreatingBackups => "Creating Backups...",
        BatchApplyPhase.CreatingDirectories => "Creating Directories...",
        BatchApplyPhase.WritingFiles => "Writing Files...",
        BatchApplyPhase.Finalizing => "Finalizing...",
        BatchApplyPhase.RollingBack => "Rolling Back...",
        BatchApplyPhase.Completed => "Complete!",
        _ => "Processing..."
    };

    public string PhaseIcon => Phase switch
    {
        BatchApplyPhase.Validating => "ChecklistIcon",
        BatchApplyPhase.CreatingBackups => "BackupIcon",
        BatchApplyPhase.CreatingDirectories => "FolderPlusIcon",
        BatchApplyPhase.WritingFiles => "FileEditIcon",
        BatchApplyPhase.Finalizing => "CheckCircleIcon",
        BatchApplyPhase.RollingBack => "UndoIcon",
        _ => "ProcessingIcon"
    };

    public void Start(CancellationTokenSource cts)
    {
        _cts = cts;
        IsVisible = true;
        Phase = BatchApplyPhase.Validating;
    }

    public void Update(BatchApplyProgress progress)
    {
        Phase = progress.Phase;
        CurrentFile = progress.CurrentFile;
        ProgressPercent = progress.ProgressPercent;
        CompletedCount = progress.CompletedOperations;
        TotalCount = progress.TotalOperations;
        CanCancel = progress.CanCancel;
    }

    public void Complete()
    {
        Phase = BatchApplyPhase.Completed;
        ProgressPercent = 100;

        // Auto-hide after delay
        Task.Delay(1500).ContinueWith(_ =>
        {
            Dispatcher.UIThread.Post(() => IsVisible = false);
        });
    }

    [RelayCommand]
    private void Cancel()
    {
        _cts?.Cancel();
        CanCancel = false;
        Phase = BatchApplyPhase.RollingBack;
    }
}
```

### Files to Create (v0.4.4g)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/Controls/ApplyProgressOverlay.axaml` | Progress overlay UI |
| `src/SeniorIntern.Desktop/Controls/ApplyProgressOverlay.axaml.cs` | Overlay code-behind |
| `src/SeniorIntern.Desktop/ViewModels/ApplyProgressViewModel.cs` | Progress ViewModel |

### Acceptance Criteria (v0.4.4g)

- [ ] Shows during batch apply
- [ ] Phase title updates correctly
- [ ] Progress bar animates
- [ ] File count updates
- [ ] Cancel button works
- [ ] Auto-hides on completion

---

## v0.4.4h: Chat Integration

### Objective
Integrate multi-file proposals into the chat message display.

### Update ChatMessageViewModel

```csharp
// Add to ChatMessageViewModel.cs

[ObservableProperty]
private FileTreeProposal? _fileTreeProposal;

[ObservableProperty]
private bool _hasFileTreeProposal;

public void ParseFileTreeProposal(IFileTreeParser parser)
{
    if (Role != MessageRole.Assistant || CodeBlocks.Count < 2)
        return;

    var codeBlocks = CodeBlocks.Select(vm => vm.ToModel()).ToList();
    FileTreeProposal = parser.ParseProposal(Content, Id, codeBlocks);
    HasFileTreeProposal = FileTreeProposal != null;
}
```

### Update ChatMessageControl.axaml

```xml
<!-- Add after code blocks section in ChatMessageControl.axaml -->

<!-- Multi-File Proposal Panel -->
<controls:FileTreeProposalPanel
    IsVisible="{Binding HasFileTreeProposal}"
    DataContext="{Binding FileTreeProposalViewModel}"
    Margin="0,12,0,0" />
```

### Files to Modify (v0.4.4h)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/ViewModels/ChatMessageViewModel.cs` | Add proposal parsing |
| `src/SeniorIntern.Desktop/Views/ChatMessageControl.axaml` | Add proposal panel |
| `src/SeniorIntern.Desktop/ViewModels/ChatViewModel.cs` | Wire up parsing |
| `src/SeniorIntern.Desktop/Extensions/ServiceCollectionExtensions.cs` | Register new services |

### Acceptance Criteria (v0.4.4h)

- [ ] Multi-file proposals detected automatically
- [ ] Proposal panel shown in chat message
- [ ] Single file proposals don't show panel
- [ ] Panel interacts correctly with chat

---

## Architecture Summary

### Component Diagram

```
┌─────────────────────────────────────────────────────────────────┐
│                   ChatMessageControl                             │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │ FileTreeProposalPanel                                      │ │
│  │  ┌──────────────────────────────────────────────────────┐ │ │
│  │  │ TreeView with FileTreeItemViewModels                 │ │ │
│  │  │  📁 src/                                              │ │ │
│  │  │    ☑ 📄 Models/User.cs           [C#]                │ │ │
│  │  │    ☑ 📄 Models/Product.cs        [C#]                │ │ │
│  │  │    ☑ 📄 Services/UserService.cs  [C#] [exists]       │ │ │
│  │  └──────────────────────────────────────────────────────┘ │ │
│  │  [Select All] [Deselect All]  3 of 3 selected            │ │
│  │  ☑ Create backups                                        │ │
│  │  [Preview] [Create Files]                                 │ │
│  └────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                   BatchPreviewDialog                             │
│  ┌───────┬────────────┬──────────────────────────────────────┐ │
│  │User.cs│ Product.cs │ UserService.cs [exists] +5 -3        │ │
│  └───────┴────────────┴──────────────────────────────────────┘ │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │              DiffViewerPanel (side-by-side)                │ │
│  └────────────────────────────────────────────────────────────┘ │
│  [← Previous] [Next →] File 2 of 3     [Cancel] [Create All]   │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                  ApplyProgressOverlay                            │
│              ┌─────────────────────────────┐                    │
│              │      📁 Writing Files...    │                    │
│              │   src/Models/Product.cs     │                    │
│              │   ████████████░░░░░  67%    │                    │
│              │      2 of 3 files           │                    │
│              │              [Cancel]       │                    │
│              └─────────────────────────────┘                    │
└─────────────────────────────────────────────────────────────────┘
```

### Data Flow

```
1. LLM Response with Multiple Code Blocks
              │
              ▼
2. CodeBlockParserService extracts blocks
              │
              ▼
3. FileTreeParser.ParseProposal()
              │
              ├──► Detects ASCII tree if present
              │
              ├──► Groups blocks by target paths
              │
              └──► Creates FileTreeProposal
                        │
                        ▼
4. FileTreeProposalViewModel builds tree
              │
              ├──► Validates against workspace
              │
              └──► Checks existing files
                        │
                        ▼
5. User interacts with FileTreeProposalPanel
              │
              ├──► Select/deselect files
              │
              ├──► Preview ──► BatchPreviewDialog
              │
              └──► Create Files
                        │
                        ▼
6. FileTreeProposalService.ApplyProposalAsync()
              │
              ├──► Validation
              │
              ├──► Create directories
              │
              ├──► Create backups
              │
              └──► Write files with progress
                        │
                        ▼
7. BatchApplyResult returned
              │
              └──► Update UI, show undo toast
```

---

## Files Summary

### Files to Create (Total: 16)

| File | Sub-Part |
|------|----------|
| `src/SeniorIntern.Core/Models/FileTreeProposal.cs` | v0.4.4a |
| `src/SeniorIntern.Core/Models/FileOperation.cs` | v0.4.4a |
| `src/SeniorIntern.Core/Models/BatchApplyResult.cs` | v0.4.4a |
| `src/SeniorIntern.Core/Models/ProposalValidation.cs` | v0.4.4a |
| `src/SeniorIntern.Core/Interfaces/IFileTreeParser.cs` | v0.4.4b |
| `src/SeniorIntern.Services/FileTreeParser.cs` | v0.4.4b |
| `src/SeniorIntern.Core/Interfaces/IFileTreeProposalService.cs` | v0.4.4c |
| `src/SeniorIntern.Services/FileTreeProposalService.cs` | v0.4.4c |
| `src/SeniorIntern.Desktop/ViewModels/FileTreeProposalViewModel.cs` | v0.4.4d |
| `src/SeniorIntern.Desktop/ViewModels/FileTreeItemViewModel.cs` | v0.4.4d |
| `src/SeniorIntern.Desktop/Controls/FileTreeProposalPanel.axaml` | v0.4.4e |
| `src/SeniorIntern.Desktop/Controls/FileTreeProposalPanel.axaml.cs` | v0.4.4e |
| `src/SeniorIntern.Desktop/ViewModels/BatchPreviewDialogViewModel.cs` | v0.4.4f |
| `src/SeniorIntern.Desktop/Views/BatchPreviewDialog.axaml` | v0.4.4f |
| `src/SeniorIntern.Desktop/Views/BatchPreviewDialog.axaml.cs` | v0.4.4f |
| `src/SeniorIntern.Desktop/Controls/ApplyProgressOverlay.axaml` | v0.4.4g |
| `src/SeniorIntern.Desktop/Controls/ApplyProgressOverlay.axaml.cs` | v0.4.4g |
| `src/SeniorIntern.Desktop/ViewModels/ApplyProgressViewModel.cs` | v0.4.4g |

### Files to Modify (Total: 5)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/ViewModels/ChatMessageViewModel.cs` | Add FileTreeProposal |
| `src/SeniorIntern.Desktop/Views/ChatMessageControl.axaml` | Add proposal panel |
| `src/SeniorIntern.Desktop/ViewModels/ChatViewModel.cs` | Wire up proposal parsing |
| `src/SeniorIntern.Desktop/Extensions/ServiceCollectionExtensions.cs` | Register services |
| `src/SeniorIntern.Desktop/App.axaml` | Add new icons |

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| ASCII tree parsing edge cases | Medium | Low | Comprehensive regex testing |
| Large proposal performance | Low | Medium | Virtualize tree view |
| Partial failure during batch | Medium | High | Transaction-like rollback |
| Directory creation race conditions | Low | Medium | Sequential directory creation |
| Path normalization issues (Win/Mac/Linux) | Medium | Medium | Use Path.Combine everywhere |

---

## References

- [v0.4.0 Code Generation & Diffing](v0.4.0-code-generation-diffing.md) - Parent specification
- [v0.4.1 Code Block Extraction](v0.4.1-code-block-extraction.md) - CodeBlock model
- [v0.4.2 Diff Engine](v0.4.2-diff-engine.md) - DiffResult and preview
- [v0.4.3 Apply Changes Workflow](v0.4.3-apply-changes-workflow.md) - File writing infrastructure
