# Design Specification: The Senior Intern v0.4.0 "Code Generation & Diffing"

## Executive Summary

This document provides a comprehensive design specification for v0.4.0, which transforms The Senior Intern from a passive coding assistant into an active code generation tool. This phase introduces the ability for the LLM to propose code changes with side-by-side diff visualization, apply changes to files with user approval, and create multiple new files from structured proposals.

### v0.4.0 Scope (from ROADMAP.md)
- **"Apply Changes" button**: The Intern suggests code, and the UI shows a **Side-by-Side Diff** before overwriting the user's file
- **File Creation**: The Intern can propose a folder structure and create multiple files at once using `System.IO`

---

## Sub-Version Breakdown

| Version | Name | Focus |
|---------|------|-------|
| v0.4.1 | Code Block Extraction | Parse code blocks from LLM responses, detect language and target file |
| v0.4.2 | Diff Engine | Compute and visualize side-by-side diffs, inline highlighting |
| v0.4.3 | Apply Changes Workflow | User approval flow, file writing, undo capability |
| v0.4.4 | Multi-File Creation | Propose folder structures, batch file creation, project scaffolding |
| v0.4.5 | Polish & Integration | Conflict detection, partial apply, streaming diff preview |

---

## v0.4.1: Code Block Extraction

### Objective
Parse LLM responses to identify code blocks, detect their programming language, infer target file paths, and present them as actionable proposals.

### Code Block Detection

#### Markdown Code Block Patterns

```
Standard:
```language
code here
```

With filename:
```language:path/to/file.ext
code here
```

Alternate (triple backticks with path comment):
```language
// File: path/to/file.ext
code here
```
```

#### CodeBlock Model

```csharp
namespace SeniorIntern.Core.Models;

public sealed class CodeBlock
{
    public Guid Id { get; init; } = Guid.NewGuid();

    /// <summary>
    /// Raw content of the code block (without markdown fences)
    /// </summary>
    public string Content { get; init; } = string.Empty;

    /// <summary>
    /// Detected or specified programming language
    /// </summary>
    public string? Language { get; init; }

    /// <summary>
    /// Inferred or specified target file path (relative to workspace)
    /// </summary>
    public string? TargetFilePath { get; set; }

    /// <summary>
    /// Whether this is a complete file or a partial snippet
    /// </summary>
    public CodeBlockType BlockType { get; init; } = CodeBlockType.Snippet;

    /// <summary>
    /// Line range in original file this block should replace (for snippets)
    /// </summary>
    public LineRange? ReplacementRange { get; set; }

    /// <summary>
    /// Source message ID
    /// </summary>
    public Guid MessageId { get; init; }

    /// <summary>
    /// Position in message (for multiple code blocks)
    /// </summary>
    public int SequenceNumber { get; init; }

    /// <summary>
    /// Start and end character positions in the original message
    /// </summary>
    public (int Start, int End) SourceRange { get; init; }

    /// <summary>
    /// Confidence level for inferred properties
    /// </summary>
    public float ConfidenceScore { get; set; } = 1.0f;
}

public enum CodeBlockType
{
    /// <summary>
    /// A complete file to be created or replaced
    /// </summary>
    CompleteFile,

    /// <summary>
    /// A partial snippet to be inserted or to replace a section
    /// </summary>
    Snippet,

    /// <summary>
    /// Example/illustration code (not meant to be applied)
    /// </summary>
    Example,

    /// <summary>
    /// Shell command (not a code file)
    /// </summary>
    Command
}

public record LineRange(int StartLine, int EndLine)
{
    public int LineCount => EndLine - StartLine + 1;
}
```

### Code Block Parser Service

#### ICodeBlockParserService Interface

```csharp
namespace SeniorIntern.Core.Interfaces;

public interface ICodeBlockParserService
{
    /// <summary>
    /// Extract all code blocks from a message
    /// </summary>
    IReadOnlyList<CodeBlock> ParseMessage(string content, Guid messageId);

    /// <summary>
    /// Extract code blocks incrementally during streaming
    /// </summary>
    IAsyncEnumerable<CodeBlock> ParseStreamingAsync(
        IAsyncEnumerable<string> tokenStream,
        Guid messageId,
        CancellationToken ct = default);

    /// <summary>
    /// Attempt to infer the target file path for a code block
    /// </summary>
    string? InferTargetFilePath(CodeBlock block, IReadOnlyList<FileContext> attachedContext);

    /// <summary>
    /// Detect if a code block is meant to be applied vs just an example
    /// </summary>
    CodeBlockType ClassifyBlockType(CodeBlock block, string surroundingText);
}
```

#### CodeBlockParserService Implementation

```csharp
namespace SeniorIntern.Services;

public sealed class CodeBlockParserService : ICodeBlockParserService
{
    // Regex patterns for code block detection
    private static readonly Regex FencedBlockPattern = new(
        @"```(?<lang>\w+)?(?::(?<path>[^\n]+))?\n(?<code>[\s\S]*?)```",
        RegexOptions.Compiled | RegexOptions.Multiline);

    private static readonly Regex FileCommentPattern = new(
        @"^(?://|#|--|/\*)\s*(?:File|Path|Filename):\s*(?<path>.+?)(?:\s*\*/)?$",
        RegexOptions.Compiled | RegexOptions.IgnoreCase | RegexOptions.Multiline);

    // Keywords that suggest example code vs. actual proposals
    private static readonly string[] ExampleIndicators =
    {
        "for example", "e.g.", "such as", "like this", "example:",
        "would look like", "something like", "here's an example"
    };

    private static readonly string[] ApplyIndicators =
    {
        "update", "modify", "change", "replace", "add", "create",
        "here's the", "updated version", "fixed version", "corrected"
    };

    public IReadOnlyList<CodeBlock> ParseMessage(string content, Guid messageId)
    {
        var blocks = new List<CodeBlock>();
        var matches = FencedBlockPattern.Matches(content);

        for (int i = 0; i < matches.Count; i++)
        {
            var match = matches[i];
            var code = match.Groups["code"].Value;
            var lang = match.Groups["lang"].Value;
            var pathFromFence = match.Groups["path"].Value;

            // Check for file path in first line comment
            var pathFromComment = ExtractPathFromComment(code);
            var targetPath = !string.IsNullOrEmpty(pathFromFence)
                ? pathFromFence
                : pathFromComment;

            // Get surrounding text for classification
            var contextStart = Math.Max(0, match.Index - 200);
            var surroundingText = content.Substring(contextStart,
                Math.Min(200 + match.Length, content.Length - contextStart));

            var block = new CodeBlock
            {
                Content = code.Trim(),
                Language = !string.IsNullOrEmpty(lang) ? lang : null,
                TargetFilePath = targetPath,
                MessageId = messageId,
                SequenceNumber = i,
                SourceRange = (match.Index, match.Index + match.Length)
            };

            block = block with { BlockType = ClassifyBlockType(block, surroundingText) };
            blocks.Add(block);
        }

        return blocks;
    }

    public CodeBlockType ClassifyBlockType(CodeBlock block, string surroundingText)
    {
        var lowerText = surroundingText.ToLowerInvariant();

        // Check for shell commands
        if (IsShellCommand(block))
            return CodeBlockType.Command;

        // Check for example indicators
        if (ExampleIndicators.Any(ind => lowerText.Contains(ind)))
            return CodeBlockType.Example;

        // Check for apply indicators
        if (ApplyIndicators.Any(ind => lowerText.Contains(ind)))
        {
            return HasCompleteFileStructure(block.Content, block.Language)
                ? CodeBlockType.CompleteFile
                : CodeBlockType.Snippet;
        }

        // Default based on content analysis
        return HasCompleteFileStructure(block.Content, block.Language)
            ? CodeBlockType.CompleteFile
            : CodeBlockType.Snippet;
    }

    private bool IsShellCommand(CodeBlock block)
    {
        var lang = block.Language?.ToLowerInvariant();
        return lang is "bash" or "sh" or "shell" or "cmd" or "powershell" or "ps1"
            || (lang == null && block.Content.Split('\n').Length <= 3
                && (block.Content.StartsWith("$") || block.Content.StartsWith(">")));
    }

    private bool HasCompleteFileStructure(string content, string? language)
    {
        return language?.ToLowerInvariant() switch
        {
            "csharp" or "cs" => content.Contains("namespace ") || content.Contains("class ")
                                || content.Contains("using "),
            "javascript" or "js" or "typescript" or "ts" =>
                content.Contains("import ") || content.Contains("export ")
                || content.Contains("module.exports"),
            "python" or "py" => content.Contains("def ") || content.Contains("class ")
                                || content.Contains("import "),
            "xml" => content.TrimStart().StartsWith("<?xml") || content.TrimStart().StartsWith("<Project"),
            "json" => content.TrimStart().StartsWith("{") && content.TrimEnd().EndsWith("}"),
            _ => false
        };
    }

    private string? ExtractPathFromComment(string code)
    {
        var match = FileCommentPattern.Match(code);
        return match.Success ? match.Groups["path"].Value.Trim() : null;
    }

    public string? InferTargetFilePath(CodeBlock block, IReadOnlyList<FileContext> attachedContext)
    {
        // 1. Already has explicit path
        if (!string.IsNullOrEmpty(block.TargetFilePath))
            return block.TargetFilePath;

        // 2. Single attached context - assume it's the target
        if (attachedContext.Count == 1)
            return attachedContext[0].FilePath;

        // 3. Try to match language to attached files
        if (block.Language != null && attachedContext.Count > 0)
        {
            var matchingFile = attachedContext.FirstOrDefault(
                ctx => ctx.Language?.Equals(block.Language, StringComparison.OrdinalIgnoreCase) == true);
            if (matchingFile != null)
                return matchingFile.FilePath;
        }

        // 4. Look for class/namespace/module names that match files
        var inferredName = InferFileNameFromContent(block.Content, block.Language);
        if (inferredName != null && attachedContext.Count > 0)
        {
            var matchingFile = attachedContext.FirstOrDefault(
                ctx => ctx.FileName.Contains(inferredName, StringComparison.OrdinalIgnoreCase));
            if (matchingFile != null)
                return matchingFile.FilePath;
        }

        return null;
    }

    private string? InferFileNameFromContent(string content, string? language)
    {
        // Extract class/type name from content
        var patterns = language?.ToLowerInvariant() switch
        {
            "csharp" or "cs" => new[]
            {
                @"(?:public|internal|private)?\s*(?:sealed|abstract|static)?\s*class\s+(\w+)",
                @"(?:public|internal)?\s*interface\s+(\w+)",
                @"(?:public|internal)?\s*record\s+(\w+)"
            },
            "typescript" or "ts" or "javascript" or "js" => new[]
            {
                @"(?:export\s+)?class\s+(\w+)",
                @"(?:export\s+)?interface\s+(\w+)",
                @"(?:export\s+)?function\s+(\w+)"
            },
            "python" or "py" => new[]
            {
                @"class\s+(\w+)",
                @"def\s+(\w+)"
            },
            _ => Array.Empty<string>()
        };

        foreach (var pattern in patterns)
        {
            var match = Regex.Match(content, pattern);
            if (match.Success)
                return match.Groups[1].Value;
        }

        return null;
    }
}
```

### Code Proposal Model

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Represents a proposed set of code changes from an LLM response
/// </summary>
public sealed class CodeProposal
{
    public Guid Id { get; init; } = Guid.NewGuid();
    public Guid MessageId { get; init; }
    public DateTime CreatedAt { get; init; } = DateTime.UtcNow;

    /// <summary>
    /// All code blocks in this proposal
    /// </summary>
    public IReadOnlyList<CodeBlock> CodeBlocks { get; init; } = Array.Empty<CodeBlock>();

    /// <summary>
    /// Code blocks that can be applied (have target paths)
    /// </summary>
    public IEnumerable<CodeBlock> ApplicableBlocks =>
        CodeBlocks.Where(b => b.BlockType is CodeBlockType.CompleteFile or CodeBlockType.Snippet
                              && !string.IsNullOrEmpty(b.TargetFilePath));

    /// <summary>
    /// Status of each code block
    /// </summary>
    public Dictionary<Guid, ProposalBlockStatus> BlockStatuses { get; } = new();

    /// <summary>
    /// Overall status of the proposal
    /// </summary>
    public ProposalStatus Status { get; set; } = ProposalStatus.Pending;
}

public enum ProposalStatus
{
    Pending,
    PartiallyApplied,
    FullyApplied,
    Rejected,
    Expired
}

public enum ProposalBlockStatus
{
    Pending,
    Applied,
    Rejected,
    Skipped,
    Conflict
}
```

### Updated ChatMessageViewModel

```csharp
public partial class ChatMessageViewModel : ViewModelBase
{
    // ... existing properties ...

    [ObservableProperty]
    private CodeProposal? _codeProposal;

    [ObservableProperty]
    private bool _hasApplicableCode;

    [ObservableProperty]
    private int _applicableBlockCount;

    // Computed
    public bool ShowCodeActions => HasApplicableCode && Role == MessageRole.Assistant;
}
```

### Code Block UI Rendering

```xml
<!-- Within ChatMessageControl.axaml -->
<ItemsControl ItemsSource="{Binding CodeProposal.CodeBlocks}"
              IsVisible="{Binding HasApplicableCode}">
    <ItemsControl.ItemTemplate>
        <DataTemplate DataType="{x:Type models:CodeBlock}">
            <Border Classes="code-block"
                    Classes.applicable="{Binding BlockType,
                        Converter={StaticResource IsApplicableBlockConverter}}">
                <Grid RowDefinitions="Auto, *, Auto">
                    <!-- Header -->
                    <Border Grid.Row="0" Classes="code-block-header">
                        <Grid ColumnDefinitions="Auto, *, Auto, Auto">
                            <TextBlock Text="{Binding Language}"
                                       Classes="language-badge" />
                            <TextBlock Grid.Column="1"
                                       Text="{Binding TargetFilePath}"
                                       Classes="file-path"
                                       IsVisible="{Binding TargetFilePath,
                                           Converter={x:Static StringConverters.IsNotNullOrEmpty}}" />
                            <Button Grid.Column="2"
                                    Classes="icon-button"
                                    Command="{Binding $parent[UserControl].DataContext.CopyCodeCommand}"
                                    CommandParameter="{Binding}"
                                    ToolTip.Tip="Copy code">
                                <PathIcon Data="{StaticResource CopyIcon}" />
                            </Button>
                            <Button Grid.Column="3"
                                    Classes="apply-button"
                                    Command="{Binding $parent[UserControl].DataContext.ShowDiffCommand}"
                                    CommandParameter="{Binding}"
                                    IsVisible="{Binding TargetFilePath,
                                        Converter={x:Static StringConverters.IsNotNullOrEmpty}}"
                                    ToolTip.Tip="Review and apply changes">
                                <StackPanel Orientation="Horizontal" Spacing="4">
                                    <PathIcon Data="{StaticResource DiffIcon}" />
                                    <TextBlock Text="Apply" />
                                </StackPanel>
                            </Button>
                        </Grid>
                    </Border>

                    <!-- Code Content -->
                    <Border Grid.Row="1" Classes="code-content">
                        <SelectableTextBlock Text="{Binding Content}"
                                             FontFamily="Cascadia Code, Consolas, monospace"
                                             FontSize="13" />
                    </Border>

                    <!-- Status Footer (when applied/rejected) -->
                    <Border Grid.Row="2" Classes="code-block-footer"
                            IsVisible="{Binding Status,
                                Converter={StaticResource IsNotPendingConverter}}">
                        <TextBlock Text="{Binding Status}" Classes="status-label" />
                    </Border>
                </Grid>
            </Border>
        </DataTemplate>
    </ItemsControl.ItemTemplate>
</ItemsControl>
```

### Files to Create (v0.4.1)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Models/CodeBlock.cs` | Code block model |
| `src/SeniorIntern.Core/Models/CodeProposal.cs` | Proposal model |
| `src/SeniorIntern.Core/Interfaces/ICodeBlockParserService.cs` | Parser interface |
| `src/SeniorIntern.Services/CodeBlockParserService.cs` | Parser implementation |
| `src/SeniorIntern.Desktop/Converters/IsApplicableBlockConverter.cs` | UI converter |

### Files to Modify (v0.4.1)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/ViewModels/ChatMessageViewModel.cs` | Add CodeProposal property |
| `src/SeniorIntern.Desktop/ViewModels/ChatViewModel.cs` | Parse code blocks from responses |
| `src/SeniorIntern.Desktop/Views/ChatMessageControl.axaml` | Add code block rendering |
| `src/SeniorIntern.Desktop/Themes/Dark.axaml` | Add code block styles |

### Testing Strategy (v0.4.1)
- Test code block extraction from various markdown formats
- Test language detection accuracy
- Test file path inference with attached context
- Test block type classification
- Test streaming code block parsing

---

## v0.4.2: Diff Engine

### Objective
Implement a diff computation engine and side-by-side diff visualization UI that shows exactly what changes will be made before applying code changes.

### Diff Engine Architecture

#### DiffResult Model

```csharp
namespace SeniorIntern.Core.Models;

public sealed class DiffResult
{
    public string OriginalFilePath { get; init; } = string.Empty;
    public string OriginalContent { get; init; } = string.Empty;
    public string ProposedContent { get; init; } = string.Empty;

    /// <summary>
    /// Individual diff hunks
    /// </summary>
    public IReadOnlyList<DiffHunk> Hunks { get; init; } = Array.Empty<DiffHunk>();

    /// <summary>
    /// Summary statistics
    /// </summary>
    public DiffStats Stats { get; init; } = new();

    /// <summary>
    /// Whether this is a new file creation
    /// </summary>
    public bool IsNewFile { get; init; }

    /// <summary>
    /// Whether this is a file deletion
    /// </summary>
    public bool IsDeleteFile { get; init; }
}

public sealed class DiffHunk
{
    public int OriginalStartLine { get; init; }
    public int OriginalLineCount { get; init; }
    public int ProposedStartLine { get; init; }
    public int ProposedLineCount { get; init; }

    /// <summary>
    /// Lines in this hunk with change type
    /// </summary>
    public IReadOnlyList<DiffLine> Lines { get; init; } = Array.Empty<DiffLine>();
}

public sealed class DiffLine
{
    public int? OriginalLineNumber { get; init; }
    public int? ProposedLineNumber { get; init; }
    public string Content { get; init; } = string.Empty;
    public DiffLineType Type { get; init; }

    /// <summary>
    /// Inline character-level changes (for modified lines)
    /// </summary>
    public IReadOnlyList<InlineChange>? InlineChanges { get; init; }
}

public enum DiffLineType
{
    Unchanged,
    Added,
    Removed,
    Modified
}

public sealed class InlineChange
{
    public int StartColumn { get; init; }
    public int Length { get; init; }
    public InlineChangeType Type { get; init; }
}

public enum InlineChangeType
{
    Added,
    Removed
}

public record DiffStats(
    int TotalLines = 0,
    int AddedLines = 0,
    int RemovedLines = 0,
    int ModifiedLines = 0,
    int UnchangedLines = 0
)
{
    public int NetChange => AddedLines - RemovedLines;
}
```

### IDiffService Interface

```csharp
namespace SeniorIntern.Core.Interfaces;

public interface IDiffService
{
    /// <summary>
    /// Compute diff between original file content and proposed changes
    /// </summary>
    DiffResult ComputeDiff(string originalContent, string proposedContent);

    /// <summary>
    /// Compute diff for a file that will be created (no original)
    /// </summary>
    DiffResult ComputeNewFileDiff(string proposedContent);

    /// <summary>
    /// Compute diff for a specific code block against the target file
    /// </summary>
    Task<DiffResult> ComputeDiffForBlockAsync(
        CodeBlock block,
        string workspacePath,
        CancellationToken ct = default);

    /// <summary>
    /// Apply a diff to produce the final content
    /// </summary>
    string ApplyDiff(string originalContent, DiffResult diff);

    /// <summary>
    /// Merge multiple code blocks targeting the same file
    /// </summary>
    DiffResult MergeBlockDiffs(IReadOnlyList<DiffResult> diffs);
}
```

### DiffService Implementation

```csharp
namespace SeniorIntern.Services;

using DiffPlex;
using DiffPlex.DiffBuilder;
using DiffPlex.DiffBuilder.Model;

public sealed class DiffService : IDiffService
{
    private readonly IFileSystemService _fileSystemService;
    private readonly InlineDiffBuilder _diffBuilder;

    public DiffService(IFileSystemService fileSystemService)
    {
        _fileSystemService = fileSystemService;
        _diffBuilder = new InlineDiffBuilder(new Differ());
    }

    public DiffResult ComputeDiff(string originalContent, string proposedContent)
    {
        var diff = _diffBuilder.BuildDiffModel(originalContent, proposedContent);

        var hunks = new List<DiffHunk>();
        var currentHunk = new List<DiffLine>();
        int origLine = 1, propLine = 1;
        int hunkOrigStart = 0, hunkPropStart = 0;
        bool inHunk = false;
        int contextLines = 3; // Lines of context around changes

        var lines = diff.Lines;
        for (int i = 0; i < lines.Count; i++)
        {
            var line = lines[i];
            var diffLine = ConvertToDiffLine(line, ref origLine, ref propLine);

            if (diffLine.Type != DiffLineType.Unchanged)
            {
                if (!inHunk)
                {
                    // Start new hunk with context
                    inHunk = true;
                    hunkOrigStart = Math.Max(1, origLine - contextLines);
                    hunkPropStart = Math.Max(1, propLine - contextLines);

                    // Add leading context
                    for (int j = Math.Max(0, i - contextLines); j < i; j++)
                    {
                        var contextLine = lines[j];
                        currentHunk.Add(ConvertToDiffLine(contextLine, ref origLine, ref propLine, true));
                    }
                }
                currentHunk.Add(diffLine);
            }
            else if (inHunk)
            {
                currentHunk.Add(diffLine);

                // Check if we should end the hunk
                int unchangedCount = 0;
                for (int j = currentHunk.Count - 1; j >= 0 && currentHunk[j].Type == DiffLineType.Unchanged; j--)
                    unchangedCount++;

                if (unchangedCount >= contextLines * 2)
                {
                    // End hunk, trim trailing context
                    while (currentHunk.Count > 0 &&
                           currentHunk[^1].Type == DiffLineType.Unchanged &&
                           currentHunk.Count(l => l.Type == DiffLineType.Unchanged) > contextLines)
                    {
                        currentHunk.RemoveAt(currentHunk.Count - 1);
                    }

                    hunks.Add(CreateHunk(hunkOrigStart, hunkPropStart, currentHunk));
                    currentHunk = new List<DiffLine>();
                    inHunk = false;
                }
            }
        }

        // Close any remaining hunk
        if (currentHunk.Count > 0)
        {
            hunks.Add(CreateHunk(hunkOrigStart, hunkPropStart, currentHunk));
        }

        var stats = ComputeStats(hunks);

        return new DiffResult
        {
            OriginalContent = originalContent,
            ProposedContent = proposedContent,
            Hunks = hunks,
            Stats = stats,
            IsNewFile = string.IsNullOrEmpty(originalContent)
        };
    }

    public DiffResult ComputeNewFileDiff(string proposedContent)
    {
        var lines = proposedContent.Split('\n');
        var diffLines = lines.Select((line, i) => new DiffLine
        {
            ProposedLineNumber = i + 1,
            Content = line,
            Type = DiffLineType.Added
        }).ToList();

        return new DiffResult
        {
            OriginalContent = string.Empty,
            ProposedContent = proposedContent,
            Hunks = new[]
            {
                new DiffHunk
                {
                    OriginalStartLine = 0,
                    OriginalLineCount = 0,
                    ProposedStartLine = 1,
                    ProposedLineCount = lines.Length,
                    Lines = diffLines
                }
            },
            Stats = new DiffStats(
                TotalLines: lines.Length,
                AddedLines: lines.Length
            ),
            IsNewFile = true
        };
    }

    public async Task<DiffResult> ComputeDiffForBlockAsync(
        CodeBlock block,
        string workspacePath,
        CancellationToken ct = default)
    {
        if (string.IsNullOrEmpty(block.TargetFilePath))
            throw new ArgumentException("Code block must have a target file path");

        var fullPath = Path.Combine(workspacePath, block.TargetFilePath);

        if (!await _fileSystemService.FileExistsAsync(fullPath))
        {
            // New file
            return ComputeNewFileDiff(block.Content);
        }

        var originalContent = await _fileSystemService.ReadFileAsync(fullPath, ct);

        if (block.BlockType == CodeBlockType.CompleteFile)
        {
            return ComputeDiff(originalContent, block.Content);
        }
        else if (block.ReplacementRange != null)
        {
            // Snippet with specific replacement range
            var proposedContent = ReplaceLines(
                originalContent,
                block.ReplacementRange.StartLine,
                block.ReplacementRange.EndLine,
                block.Content);
            return ComputeDiff(originalContent, proposedContent);
        }
        else
        {
            // Snippet without range - use fuzzy matching
            var proposedContent = await SmartMergeSnippetAsync(
                originalContent, block.Content, block.Language);
            return ComputeDiff(originalContent, proposedContent);
        }
    }

    private async Task<string> SmartMergeSnippetAsync(
        string original, string snippet, string? language)
    {
        // TODO: Implement intelligent snippet merging
        // For now, fall back to replacing the entire file
        // Future: Use semantic analysis or LLM-assisted merging
        return snippet;
    }

    private string ReplaceLines(string content, int startLine, int endLine, string replacement)
    {
        var lines = content.Split('\n').ToList();
        var replacementLines = replacement.Split('\n');

        // Remove old lines
        lines.RemoveRange(startLine - 1, endLine - startLine + 1);

        // Insert new lines
        lines.InsertRange(startLine - 1, replacementLines);

        return string.Join('\n', lines);
    }

    private DiffStats ComputeStats(IReadOnlyList<DiffHunk> hunks)
    {
        int added = 0, removed = 0, modified = 0, unchanged = 0;

        foreach (var hunk in hunks)
        {
            foreach (var line in hunk.Lines)
            {
                switch (line.Type)
                {
                    case DiffLineType.Added: added++; break;
                    case DiffLineType.Removed: removed++; break;
                    case DiffLineType.Modified: modified++; break;
                    case DiffLineType.Unchanged: unchanged++; break;
                }
            }
        }

        return new DiffStats(added + removed + modified + unchanged, added, removed, modified, unchanged);
    }
}
```

### New NuGet Package

| Package | Version | Purpose |
|---------|---------|---------|
| DiffPlex | 1.7.2 | Diff computation library |

### Side-by-Side Diff View

#### DiffViewerViewModel

```csharp
namespace SeniorIntern.Desktop.ViewModels;

public partial class DiffViewerViewModel : ViewModelBase
{
    [ObservableProperty]
    private DiffResult? _diffResult;

    [ObservableProperty]
    private CodeBlock? _codeBlock;

    [ObservableProperty]
    private string _originalFilePath = string.Empty;

    [ObservableProperty]
    private string _fileName = string.Empty;

    [ObservableProperty]
    private string? _language;

    [ObservableProperty]
    private bool _isNewFile;

    [ObservableProperty]
    private bool _showInlineChanges = true;

    [ObservableProperty]
    private bool _wordWrap = false;

    [ObservableProperty]
    private int _scrollPosition;

    // Synchronized scrolling between panels
    [ObservableProperty]
    private bool _synchronizedScroll = true;

    // Stats display
    public string StatsDisplay => DiffResult != null
        ? $"+{DiffResult.Stats.AddedLines} -{DiffResult.Stats.RemovedLines}"
        : string.Empty;

    // Commands
    [RelayCommand]
    private async Task ApplyChangesAsync();

    [RelayCommand]
    private void Reject();

    [RelayCommand]
    private void CopyProposed();

    [RelayCommand]
    private void OpenInEditor();

    [RelayCommand]
    private void ToggleInlineChanges();

    [RelayCommand]
    private void ToggleWordWrap();

    [RelayCommand]
    private void NextHunk();

    [RelayCommand]
    private void PreviousHunk();
}
```

### Diff Viewer UI (DiffViewerPanel.axaml)

```xml
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:vm="using:SeniorIntern.Desktop.ViewModels"
             x:Class="SeniorIntern.Desktop.Views.DiffViewerPanel"
             x:DataType="vm:DiffViewerViewModel">

    <Grid RowDefinitions="Auto, *, Auto">
        <!-- Header -->
        <Border Grid.Row="0" Classes="diff-header" Padding="12,8">
            <Grid ColumnDefinitions="Auto, *, Auto">
                <!-- File info -->
                <StackPanel Orientation="Horizontal" Spacing="8">
                    <PathIcon Data="{StaticResource FileIcon}" Width="16" Height="16" />
                    <TextBlock Text="{Binding FileName}" FontWeight="SemiBold" />
                    <Border Classes="language-badge" IsVisible="{Binding Language, Converter={x:Static StringConverters.IsNotNullOrEmpty}}">
                        <TextBlock Text="{Binding Language}" FontSize="11" />
                    </Border>
                    <Border Classes="new-file-badge" IsVisible="{Binding IsNewFile}">
                        <TextBlock Text="NEW" FontSize="11" />
                    </Border>
                </StackPanel>

                <!-- Stats -->
                <StackPanel Grid.Column="1" Orientation="Horizontal"
                            HorizontalAlignment="Center" Spacing="12">
                    <TextBlock Text="{Binding DiffResult.Stats.AddedLines, StringFormat='+{0}'}"
                               Foreground="{DynamicResource DiffAddedForeground}" />
                    <TextBlock Text="{Binding DiffResult.Stats.RemovedLines, StringFormat='-{0}'}"
                               Foreground="{DynamicResource DiffRemovedForeground}" />
                </StackPanel>

                <!-- Toolbar -->
                <StackPanel Grid.Column="2" Orientation="Horizontal" Spacing="4">
                    <Button Classes="icon-button" Command="{Binding PreviousHunkCommand}"
                            ToolTip.Tip="Previous change (↑)">
                        <PathIcon Data="{StaticResource ChevronUpIcon}" />
                    </Button>
                    <Button Classes="icon-button" Command="{Binding NextHunkCommand}"
                            ToolTip.Tip="Next change (↓)">
                        <PathIcon Data="{StaticResource ChevronDownIcon}" />
                    </Button>
                    <Separator />
                    <ToggleButton Classes="icon-button" IsChecked="{Binding ShowInlineChanges}"
                                  ToolTip.Tip="Show inline changes">
                        <PathIcon Data="{StaticResource InlineChangesIcon}" />
                    </ToggleButton>
                    <ToggleButton Classes="icon-button" IsChecked="{Binding WordWrap}"
                                  ToolTip.Tip="Word wrap">
                        <PathIcon Data="{StaticResource WordWrapIcon}" />
                    </ToggleButton>
                    <ToggleButton Classes="icon-button" IsChecked="{Binding SynchronizedScroll}"
                                  ToolTip.Tip="Synchronized scrolling">
                        <PathIcon Data="{StaticResource SyncScrollIcon}" />
                    </ToggleButton>
                </StackPanel>
            </Grid>
        </Border>

        <!-- Side-by-Side Diff View -->
        <Grid Grid.Row="1" ColumnDefinitions="*, 2, *">
            <!-- Original (Left) -->
            <Border Classes="diff-panel original">
                <Grid RowDefinitions="Auto, *">
                    <Border Classes="panel-header">
                        <TextBlock Text="Original" FontWeight="SemiBold" />
                    </Border>
                    <ScrollViewer Grid.Row="1"
                                  x:Name="OriginalScroll"
                                  VerticalScrollBarVisibility="Auto"
                                  HorizontalScrollBarVisibility="Auto">
                        <ItemsControl ItemsSource="{Binding DiffResult.Hunks}">
                            <ItemsControl.ItemTemplate>
                                <DataTemplate>
                                    <local:DiffHunkView Side="Original" />
                                </DataTemplate>
                            </ItemsControl.ItemTemplate>
                        </ItemsControl>
                    </ScrollViewer>
                </Grid>
            </Border>

            <!-- Splitter -->
            <GridSplitter Grid.Column="1" Width="2"
                          Background="{DynamicResource BorderBrush}" />

            <!-- Proposed (Right) -->
            <Border Grid.Column="2" Classes="diff-panel proposed">
                <Grid RowDefinitions="Auto, *">
                    <Border Classes="panel-header">
                        <TextBlock Text="Proposed" FontWeight="SemiBold" />
                    </Border>
                    <ScrollViewer Grid.Row="1"
                                  x:Name="ProposedScroll"
                                  VerticalScrollBarVisibility="Auto"
                                  HorizontalScrollBarVisibility="Auto">
                        <ItemsControl ItemsSource="{Binding DiffResult.Hunks}">
                            <ItemsControl.ItemTemplate>
                                <DataTemplate>
                                    <local:DiffHunkView Side="Proposed" />
                                </DataTemplate>
                            </ItemsControl.ItemTemplate>
                        </ItemsControl>
                    </ScrollViewer>
                </Grid>
            </Border>
        </Grid>

        <!-- Footer Actions -->
        <Border Grid.Row="2" Classes="diff-footer" Padding="12,8">
            <Grid ColumnDefinitions="Auto, *, Auto">
                <Button Content="Open in Editor"
                        Command="{Binding OpenInEditorCommand}"
                        Classes="secondary" />

                <StackPanel Grid.Column="2" Orientation="Horizontal" Spacing="8">
                    <Button Content="Reject"
                            Command="{Binding RejectCommand}"
                            Classes="secondary" />
                    <Button Content="Apply Changes"
                            Command="{Binding ApplyChangesCommand}"
                            Classes="primary accent" />
                </StackPanel>
            </Grid>
        </Border>
    </Grid>
</UserControl>
```

### Diff Line Rendering (DiffLineControl.axaml)

```xml
<UserControl xmlns="https://github.com/avaloniaui"
             x:Class="SeniorIntern.Desktop.Controls.DiffLineControl">

    <Grid ColumnDefinitions="50, *" Classes="diff-line"
          Classes.added="{Binding Type, Converter={StaticResource DiffTypeConverter}, ConverterParameter=Added}"
          Classes.removed="{Binding Type, Converter={StaticResource DiffTypeConverter}, ConverterParameter=Removed}"
          Classes.modified="{Binding Type, Converter={StaticResource DiffTypeConverter}, ConverterParameter=Modified}">

        <!-- Line Number -->
        <Border Classes="line-number">
            <TextBlock Text="{Binding LineNumber}"
                       HorizontalAlignment="Right"
                       Foreground="{DynamicResource TextMuted}"
                       FontFamily="Cascadia Code, Consolas, monospace"
                       FontSize="12" />
        </Border>

        <!-- Content -->
        <Border Grid.Column="1" Classes="line-content" Padding="8,2">
            <!-- With inline changes -->
            <ItemsControl ItemsSource="{Binding Segments}"
                          IsVisible="{Binding HasInlineChanges}">
                <ItemsControl.ItemsPanel>
                    <ItemsPanelTemplate>
                        <WrapPanel />
                    </ItemsPanelTemplate>
                </ItemsControl.ItemsPanel>
                <ItemsControl.ItemTemplate>
                    <DataTemplate>
                        <TextBlock Text="{Binding Text}"
                                   FontFamily="Cascadia Code, Consolas, monospace"
                                   FontSize="13"
                                   Classes.inline-added="{Binding IsAdded}"
                                   Classes.inline-removed="{Binding IsRemoved}" />
                    </DataTemplate>
                </ItemsControl.ItemTemplate>
            </ItemsControl>

            <!-- Without inline changes -->
            <TextBlock Text="{Binding Content}"
                       IsVisible="{Binding !HasInlineChanges}"
                       FontFamily="Cascadia Code, Consolas, monospace"
                       FontSize="13" />
        </Border>
    </Grid>
</UserControl>
```

### Diff Theme Colors (Dark.axaml additions)

```xml
<!-- Diff Colors -->
<Color x:Key="DiffAddedBackground">#1E3A21</Color>
<Color x:Key="DiffAddedForeground">#4ADE80</Color>
<Color x:Key="DiffAddedInlineBackground">#2D5A31</Color>

<Color x:Key="DiffRemovedBackground">#3A1E1E</Color>
<Color x:Key="DiffRemovedForeground">#F87171</Color>
<Color x:Key="DiffRemovedInlineBackground">#5A2D2D</Color>

<Color x:Key="DiffModifiedBackground">#3A3A1E</Color>
<Color x:Key="DiffModifiedForeground">#FBBF24</Color>

<Color x:Key="DiffGutterBackground">#1A1A1A</Color>
<Color x:Key="DiffHunkSeparator">#333333</Color>

<SolidColorBrush x:Key="DiffAddedBackgroundBrush" Color="{StaticResource DiffAddedBackground}" />
<SolidColorBrush x:Key="DiffRemovedBackgroundBrush" Color="{StaticResource DiffRemovedBackground}" />
<!-- ... etc -->
```

### Files to Create (v0.4.2)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Models/DiffResult.cs` | Diff result models |
| `src/SeniorIntern.Core/Interfaces/IDiffService.cs` | Diff service interface |
| `src/SeniorIntern.Services/DiffService.cs` | Diff computation |
| `src/SeniorIntern.Desktop/ViewModels/DiffViewerViewModel.cs` | Diff viewer VM |
| `src/SeniorIntern.Desktop/Views/DiffViewerPanel.axaml` | Main diff view |
| `src/SeniorIntern.Desktop/Views/DiffViewerPanel.axaml.cs` | Code-behind |
| `src/SeniorIntern.Desktop/Controls/DiffLineControl.axaml` | Line renderer |
| `src/SeniorIntern.Desktop/Controls/DiffHunkView.axaml` | Hunk renderer |
| `src/SeniorIntern.Desktop/Converters/DiffTypeConverter.cs` | Type converter |

### Files to Modify (v0.4.2)

| File | Changes |
|------|---------|
| `Directory.Packages.props` | Add DiffPlex package |
| `src/SeniorIntern.Desktop/Themes/Dark.axaml` | Add diff colors |
| `src/SeniorIntern.Desktop/Views/MainWindow.axaml` | Add diff panel placement |

### Testing Strategy (v0.4.2)
- Test diff computation accuracy
- Test side-by-side alignment
- Test inline change highlighting
- Test synchronized scrolling
- Test hunk navigation
- Test word wrap behavior

---

## v0.4.3: Apply Changes Workflow

### Objective
Implement the complete workflow for applying proposed code changes to files, including confirmation dialogs, file backup, undo capability, and conflict detection.

### Apply Changes Flow

```
1. User clicks "Apply" on a code block or proposal
2. System computes diff against current file state
3. Conflict check: Has file changed since proposal was made?
   - If yes: Show conflict warning, offer refresh or force apply
4. Show DiffViewerPanel with side-by-side view
5. User reviews changes
6. User clicks "Apply Changes" to confirm
7. System creates backup of original file
8. System writes new content to file
9. System updates proposal status
10. Editor refreshes if file is open
11. Undo is available for configured time window
```

### IFileChangeService Interface

```csharp
namespace SeniorIntern.Core.Interfaces;

public interface IFileChangeService
{
    /// <summary>
    /// Apply a code block to its target file
    /// </summary>
    Task<ApplyResult> ApplyCodeBlockAsync(
        CodeBlock block,
        string workspacePath,
        ApplyOptions? options = null,
        CancellationToken ct = default);

    /// <summary>
    /// Apply multiple code blocks (potentially to same file)
    /// </summary>
    Task<IReadOnlyList<ApplyResult>> ApplyCodeBlocksAsync(
        IEnumerable<CodeBlock> blocks,
        string workspacePath,
        ApplyOptions? options = null,
        CancellationToken ct = default);

    /// <summary>
    /// Undo the last applied change
    /// </summary>
    Task<bool> UndoLastChangeAsync(string filePath);

    /// <summary>
    /// Check if undo is available for a file
    /// </summary>
    bool CanUndo(string filePath);

    /// <summary>
    /// Get change history for a file
    /// </summary>
    IReadOnlyList<FileChangeRecord> GetChangeHistory(string filePath, int maxRecords = 10);

    /// <summary>
    /// Clear backup files older than specified age
    /// </summary>
    Task CleanupBackupsAsync(TimeSpan maxAge);

    /// <summary>
    /// Events
    /// </summary>
    event EventHandler<FileChangedEventArgs>? FileChanged;
    event EventHandler<FileChangeFailedEventArgs>? ChangeFailed;
}

public record ApplyOptions(
    bool CreateBackup = true,
    bool AllowConflictOverwrite = false,
    bool RefreshEditorAfterApply = true,
    TimeSpan? UndoWindow = null // Default: 30 minutes
);

public sealed class ApplyResult
{
    public bool Success { get; init; }
    public string FilePath { get; init; } = string.Empty;
    public string? BackupPath { get; init; }
    public ApplyResultType ResultType { get; init; }
    public string? ErrorMessage { get; init; }
    public DiffResult? AppliedDiff { get; init; }
    public DateTime AppliedAt { get; init; }
}

public enum ApplyResultType
{
    Success,
    Created,
    Modified,
    Conflict,
    FileNotFound,
    PermissionDenied,
    ValidationFailed,
    Cancelled
}

public sealed class FileChangeRecord
{
    public Guid Id { get; init; }
    public string FilePath { get; init; } = string.Empty;
    public string BackupPath { get; init; } = string.Empty;
    public DateTime ChangedAt { get; init; }
    public ChangeType Type { get; init; }
    public Guid? CodeBlockId { get; init; }
    public bool CanUndo { get; init; }
}

public enum ChangeType
{
    Created,
    Modified,
    Deleted
}
```

### FileChangeService Implementation

```csharp
namespace SeniorIntern.Services;

public sealed class FileChangeService : IFileChangeService
{
    private readonly IFileSystemService _fileSystem;
    private readonly IDiffService _diffService;
    private readonly ISettingsService _settings;
    private readonly ConcurrentDictionary<string, Stack<FileChangeRecord>> _changeHistory = new();
    private readonly TimeSpan _defaultUndoWindow = TimeSpan.FromMinutes(30);

    public async Task<ApplyResult> ApplyCodeBlockAsync(
        CodeBlock block,
        string workspacePath,
        ApplyOptions? options = null,
        CancellationToken ct = default)
    {
        options ??= new ApplyOptions();

        if (string.IsNullOrEmpty(block.TargetFilePath))
            return new ApplyResult
            {
                Success = false,
                ResultType = ApplyResultType.ValidationFailed,
                ErrorMessage = "Code block does not have a target file path"
            };

        var fullPath = Path.Combine(workspacePath, block.TargetFilePath);
        var fileExists = await _fileSystem.FileExistsAsync(fullPath);

        try
        {
            // Create backup if file exists
            string? backupPath = null;
            if (fileExists && options.CreateBackup)
            {
                backupPath = await CreateBackupAsync(fullPath, ct);
            }

            // Compute and apply diff
            var diff = await _diffService.ComputeDiffForBlockAsync(block, workspacePath, ct);

            // Check for conflicts (file modified since block was generated)
            if (fileExists && !options.AllowConflictOverwrite)
            {
                var currentContent = await _fileSystem.ReadFileAsync(fullPath, ct);
                if (currentContent != diff.OriginalContent)
                {
                    return new ApplyResult
                    {
                        Success = false,
                        FilePath = fullPath,
                        ResultType = ApplyResultType.Conflict,
                        ErrorMessage = "File has been modified since the proposal was generated"
                    };
                }
            }

            // Ensure directory exists for new files
            var directory = Path.GetDirectoryName(fullPath);
            if (!string.IsNullOrEmpty(directory) && !Directory.Exists(directory))
            {
                Directory.CreateDirectory(directory);
            }

            // Write the new content
            await _fileSystem.WriteFileAsync(fullPath, diff.ProposedContent, ct);

            // Record change for undo
            var record = new FileChangeRecord
            {
                Id = Guid.NewGuid(),
                FilePath = fullPath,
                BackupPath = backupPath ?? string.Empty,
                ChangedAt = DateTime.UtcNow,
                Type = fileExists ? ChangeType.Modified : ChangeType.Created,
                CodeBlockId = block.Id,
                CanUndo = !string.IsNullOrEmpty(backupPath)
            };

            RecordChange(fullPath, record);

            FileChanged?.Invoke(this, new FileChangedEventArgs
            {
                FilePath = fullPath,
                ChangeType = record.Type,
                CodeBlockId = block.Id
            });

            return new ApplyResult
            {
                Success = true,
                FilePath = fullPath,
                BackupPath = backupPath,
                ResultType = fileExists ? ApplyResultType.Modified : ApplyResultType.Created,
                AppliedDiff = diff,
                AppliedAt = DateTime.UtcNow
            };
        }
        catch (UnauthorizedAccessException ex)
        {
            return new ApplyResult
            {
                Success = false,
                FilePath = fullPath,
                ResultType = ApplyResultType.PermissionDenied,
                ErrorMessage = ex.Message
            };
        }
        catch (Exception ex)
        {
            ChangeFailed?.Invoke(this, new FileChangeFailedEventArgs
            {
                FilePath = fullPath,
                Error = ex.Message
            });

            return new ApplyResult
            {
                Success = false,
                FilePath = fullPath,
                ResultType = ApplyResultType.ValidationFailed,
                ErrorMessage = ex.Message
            };
        }
    }

    public async Task<bool> UndoLastChangeAsync(string filePath)
    {
        if (!_changeHistory.TryGetValue(filePath, out var history) || history.Count == 0)
            return false;

        var lastChange = history.Peek();

        if (!lastChange.CanUndo)
            return false;

        // Check if within undo window
        if (DateTime.UtcNow - lastChange.ChangedAt > _defaultUndoWindow)
            return false;

        try
        {
            if (lastChange.Type == ChangeType.Created)
            {
                // Delete the created file
                if (File.Exists(filePath))
                    File.Delete(filePath);
            }
            else
            {
                // Restore from backup
                if (File.Exists(lastChange.BackupPath))
                {
                    File.Copy(lastChange.BackupPath, filePath, overwrite: true);
                }
                else
                {
                    return false;
                }
            }

            history.Pop();
            return true;
        }
        catch
        {
            return false;
        }
    }

    private async Task<string> CreateBackupAsync(string filePath, CancellationToken ct)
    {
        var backupDir = GetBackupDirectory();
        Directory.CreateDirectory(backupDir);

        var fileName = Path.GetFileName(filePath);
        var timestamp = DateTime.UtcNow.ToString("yyyyMMdd_HHmmss");
        var backupName = $"{Path.GetFileNameWithoutExtension(fileName)}_{timestamp}{Path.GetExtension(fileName)}";
        var backupPath = Path.Combine(backupDir, backupName);

        await Task.Run(() => File.Copy(filePath, backupPath), ct);

        return backupPath;
    }

    private string GetBackupDirectory()
    {
        var appData = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
        return Path.Combine(appData, "SeniorIntern", "backups");
    }

    private void RecordChange(string filePath, FileChangeRecord record)
    {
        var history = _changeHistory.GetOrAdd(filePath, _ => new Stack<FileChangeRecord>());
        history.Push(record);

        // Limit history size
        while (history.Count > 50)
        {
            var old = history.ToArray().Reverse().First();
            // Clean up old backup file
            if (File.Exists(old.BackupPath))
            {
                try { File.Delete(old.BackupPath); } catch { }
            }
        }
    }

    public event EventHandler<FileChangedEventArgs>? FileChanged;
    public event EventHandler<FileChangeFailedEventArgs>? ChangeFailed;
}
```

### Confirmation Dialog

```xml
<!-- ApplyChangesDialog.axaml -->
<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        x:Class="SeniorIntern.Desktop.Views.ApplyChangesDialog"
        Title="Apply Changes"
        Width="600" Height="400"
        WindowStartupLocation="CenterOwner">

    <Grid RowDefinitions="*, Auto">
        <!-- Diff Preview -->
        <local:DiffViewerPanel DataContext="{Binding DiffViewModel}" />

        <!-- Actions -->
        <Border Grid.Row="1" Padding="16" Background="{DynamicResource SurfaceBackground}">
            <Grid ColumnDefinitions="Auto, *, Auto">
                <!-- Options -->
                <StackPanel Orientation="Horizontal" Spacing="16">
                    <CheckBox Content="Create backup" IsChecked="{Binding CreateBackup}" />
                </StackPanel>

                <!-- Buttons -->
                <StackPanel Grid.Column="2" Orientation="Horizontal" Spacing="8">
                    <Button Content="Cancel" Command="{Binding CancelCommand}" />
                    <Button Content="Apply Changes"
                            Command="{Binding ApplyCommand}"
                            Classes="accent" />
                </StackPanel>
            </Grid>
        </Border>
    </Grid>
</Window>
```

### Conflict Resolution UI

```xml
<!-- ConflictWarningDialog.axaml -->
<Window Title="File Conflict Detected" Width="500">
    <StackPanel Padding="24" Spacing="16">
        <PathIcon Data="{StaticResource WarningIcon}"
                  Width="48" Height="48"
                  Foreground="{DynamicResource WarningForeground}" />

        <TextBlock Text="The file has been modified since this change was proposed."
                   TextWrapping="Wrap" TextAlignment="Center" />

        <TextBlock Text="{Binding FilePath}"
                   FontFamily="Consolas"
                   TextAlignment="Center"
                   Foreground="{DynamicResource TextMuted}" />

        <StackPanel Orientation="Horizontal" HorizontalAlignment="Center" Spacing="8">
            <Button Content="Refresh Diff" Command="{Binding RefreshCommand}"
                    ToolTip.Tip="Recompute diff against current file content" />
            <Button Content="Force Apply" Command="{Binding ForceApplyCommand}"
                    ToolTip.Tip="Overwrite with proposed changes (may lose recent edits)" />
            <Button Content="Cancel" Command="{Binding CancelCommand}" />
        </StackPanel>
    </StackPanel>
</Window>
```

### Undo Toast Notification

```csharp
public partial class MainWindowViewModel
{
    [ObservableProperty]
    private bool _showUndoToast;

    [ObservableProperty]
    private string _undoToastMessage = string.Empty;

    [ObservableProperty]
    private string? _undoFilePath;

    [RelayCommand]
    private async Task UndoLastChangeAsync()
    {
        if (_undoFilePath != null)
        {
            var success = await _fileChangeService.UndoLastChangeAsync(_undoFilePath);
            if (success)
            {
                ShowUndoToast = false;
                // Refresh editor if file is open
            }
        }
    }

    public void ShowUndoOption(string filePath, string fileName)
    {
        UndoFilePath = filePath;
        UndoToastMessage = $"Applied changes to {fileName}";
        ShowUndoToast = true;

        // Auto-hide after 10 seconds
        Task.Delay(10000).ContinueWith(_ =>
        {
            if (UndoFilePath == filePath)
                ShowUndoToast = false;
        }, TaskScheduler.FromCurrentSynchronizationContext());
    }
}
```

### Undo Toast UI

```xml
<!-- In MainWindow.axaml -->
<Border Classes="undo-toast"
        IsVisible="{Binding ShowUndoToast}"
        HorizontalAlignment="Center"
        VerticalAlignment="Bottom"
        Margin="0,0,0,20">
    <Grid ColumnDefinitions="*, Auto, Auto">
        <TextBlock Text="{Binding UndoToastMessage}"
                   VerticalAlignment="Center" />
        <Button Grid.Column="1" Content="Undo"
                Command="{Binding UndoLastChangeCommand}"
                Classes="link-button"
                Margin="16,0" />
        <Button Grid.Column="2" Classes="icon-button"
                Command="{Binding DismissUndoToastCommand}">
            <PathIcon Data="{StaticResource CloseIcon}" Width="12" Height="12" />
        </Button>
    </Grid>
</Border>
```

### Files to Create (v0.4.3)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/IFileChangeService.cs` | Change service interface |
| `src/SeniorIntern.Services/FileChangeService.cs` | Change service implementation |
| `src/SeniorIntern.Desktop/Views/ApplyChangesDialog.axaml` | Apply confirmation dialog |
| `src/SeniorIntern.Desktop/Views/ConflictWarningDialog.axaml` | Conflict warning |
| `src/SeniorIntern.Desktop/ViewModels/ApplyChangesDialogViewModel.cs` | Dialog ViewModel |
| `src/SeniorIntern.Desktop/ViewModels/ConflictWarningViewModel.cs` | Conflict VM |

### Files to Modify (v0.4.3)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/ViewModels/MainWindowViewModel.cs` | Add undo toast |
| `src/SeniorIntern.Desktop/Views/MainWindow.axaml` | Add undo toast UI |
| `src/SeniorIntern.Desktop/ViewModels/ChatMessageViewModel.cs` | Wire up apply actions |
| `src/SeniorIntern.Desktop/ViewModels/EditorPanelViewModel.cs` | Refresh on file change |

### Testing Strategy (v0.4.3)
- Test apply workflow end-to-end
- Test backup creation and restoration
- Test undo within and outside window
- Test conflict detection
- Test permission error handling
- Test concurrent apply operations

---

## v0.4.4: Multi-File Creation

### Objective
Enable the LLM to propose creating multiple files at once, including folder structures, with batch preview and creation capabilities for project scaffolding scenarios.

### Multi-File Proposal Detection

#### File Tree Proposal Pattern

```
The LLM might propose structure like:

Here's the project structure:

```
src/
├── Models/
│   ├── User.cs
│   └── Product.cs
├── Services/
│   ├── IUserService.cs
│   └── UserService.cs
└── Program.cs
```

With the following file contents:

```csharp:src/Models/User.cs
public class User { ... }
```

```csharp:src/Models/Product.cs
public class Product { ... }
```
... etc
```

### FileTreeProposal Model

```csharp
namespace SeniorIntern.Core.Models;

public sealed class FileTreeProposal
{
    public Guid Id { get; init; } = Guid.NewGuid();
    public Guid MessageId { get; init; }
    public DateTime CreatedAt { get; init; } = DateTime.UtcNow;

    /// <summary>
    /// Root directory for the proposal (relative to workspace)
    /// </summary>
    public string RootPath { get; init; } = string.Empty;

    /// <summary>
    /// All proposed file operations
    /// </summary>
    public IReadOnlyList<FileOperation> Operations { get; init; } = Array.Empty<FileOperation>();

    /// <summary>
    /// Summary description of the proposal
    /// </summary>
    public string? Description { get; set; }

    /// <summary>
    /// Total files to create
    /// </summary>
    public int FileCount => Operations.Count(o => o.Type == FileOperationType.Create);

    /// <summary>
    /// Total directories to create
    /// </summary>
    public int DirectoryCount => Operations
        .Where(o => o.Type == FileOperationType.Create)
        .Select(o => Path.GetDirectoryName(o.Path))
        .Where(d => !string.IsNullOrEmpty(d))
        .Distinct()
        .Count();

    /// <summary>
    /// Status of the proposal
    /// </summary>
    public FileTreeProposalStatus Status { get; set; } = FileTreeProposalStatus.Pending;
}

public sealed class FileOperation
{
    public Guid Id { get; init; } = Guid.NewGuid();

    /// <summary>
    /// Relative path within workspace
    /// </summary>
    public string Path { get; init; } = string.Empty;

    /// <summary>
    /// Type of operation
    /// </summary>
    public FileOperationType Type { get; init; }

    /// <summary>
    /// Content for create/modify operations
    /// </summary>
    public string? Content { get; init; }

    /// <summary>
    /// Source code block if applicable
    /// </summary>
    public Guid? CodeBlockId { get; init; }

    /// <summary>
    /// Detected language
    /// </summary>
    public string? Language { get; init; }

    /// <summary>
    /// Whether this operation is selected for batch apply
    /// </summary>
    public bool IsSelected { get; set; } = true;

    /// <summary>
    /// Status of this individual operation
    /// </summary>
    public FileOperationStatus Status { get; set; } = FileOperationStatus.Pending;

    /// <summary>
    /// Error message if failed
    /// </summary>
    public string? ErrorMessage { get; set; }
}

public enum FileOperationType
{
    Create,
    Modify,
    Delete,
    Rename,
    Move
}

public enum FileOperationStatus
{
    Pending,
    Applied,
    Skipped,
    Failed,
    Conflict
}

public enum FileTreeProposalStatus
{
    Pending,
    PartiallyApplied,
    FullyApplied,
    Rejected,
    Cancelled
}
```

### IFileTreeProposalService Interface

```csharp
namespace SeniorIntern.Core.Interfaces;

public interface IFileTreeProposalService
{
    /// <summary>
    /// Parse a message to detect multi-file proposals
    /// </summary>
    FileTreeProposal? ParseProposal(string content, Guid messageId, IReadOnlyList<CodeBlock> codeBlocks);

    /// <summary>
    /// Validate a proposal against the current workspace state
    /// </summary>
    Task<ProposalValidationResult> ValidateProposalAsync(
        FileTreeProposal proposal,
        string workspacePath,
        CancellationToken ct = default);

    /// <summary>
    /// Apply selected operations from a proposal
    /// </summary>
    Task<BatchApplyResult> ApplyProposalAsync(
        FileTreeProposal proposal,
        string workspacePath,
        ApplyOptions? options = null,
        IProgress<BatchApplyProgress>? progress = null,
        CancellationToken ct = default);

    /// <summary>
    /// Preview what changes will be made
    /// </summary>
    Task<IReadOnlyList<DiffResult>> PreviewProposalAsync(
        FileTreeProposal proposal,
        string workspacePath,
        CancellationToken ct = default);
}

public sealed class ProposalValidationResult
{
    public bool IsValid { get; init; }
    public IReadOnlyList<ValidationIssue> Issues { get; init; } = Array.Empty<ValidationIssue>();
}

public sealed class ValidationIssue
{
    public string Path { get; init; } = string.Empty;
    public ValidationIssueType Type { get; init; }
    public string Message { get; init; } = string.Empty;
}

public enum ValidationIssueType
{
    FileExists,
    DirectoryExists,
    InvalidPath,
    PermissionDenied,
    ParentNotExists
}

public sealed class BatchApplyResult
{
    public bool AllSucceeded { get; init; }
    public int SuccessCount { get; init; }
    public int FailedCount { get; init; }
    public int SkippedCount { get; init; }
    public IReadOnlyList<ApplyResult> Results { get; init; } = Array.Empty<ApplyResult>();
}

public sealed class BatchApplyProgress
{
    public int TotalOperations { get; init; }
    public int CompletedOperations { get; init; }
    public string CurrentFile { get; init; } = string.Empty;
    public double ProgressPercent => TotalOperations > 0
        ? (double)CompletedOperations / TotalOperations * 100
        : 0;
}
```

### Multi-File Proposal UI

#### FileTreeProposalPanel.axaml

```xml
<UserControl xmlns="https://github.com/avaloniaui"
             x:Class="SeniorIntern.Desktop.Views.FileTreeProposalPanel"
             x:DataType="vm:FileTreeProposalViewModel">

    <Border Classes="proposal-panel" Padding="16">
        <Grid RowDefinitions="Auto, Auto, *, Auto">
            <!-- Header -->
            <Grid ColumnDefinitions="Auto, *, Auto">
                <PathIcon Data="{StaticResource FolderPlusIcon}"
                          Width="24" Height="24"
                          Foreground="{DynamicResource AccentBrush}" />
                <StackPanel Grid.Column="1" Margin="12,0">
                    <TextBlock Text="File Creation Proposal" FontWeight="SemiBold" FontSize="16" />
                    <TextBlock Text="{Binding Description}"
                               Foreground="{DynamicResource TextMuted}"
                               TextWrapping="Wrap" />
                </StackPanel>
                <StackPanel Grid.Column="2" Orientation="Horizontal" Spacing="8">
                    <TextBlock Text="{Binding FileCount, StringFormat='{}{0} files'}" />
                    <TextBlock Text="{Binding DirectoryCount, StringFormat='{}{0} folders'}" />
                </StackPanel>
            </Grid>

            <!-- Selection Controls -->
            <StackPanel Grid.Row="1" Orientation="Horizontal" Spacing="8" Margin="0,12">
                <Button Content="Select All" Command="{Binding SelectAllCommand}" Classes="secondary" />
                <Button Content="Deselect All" Command="{Binding DeselectAllCommand}" Classes="secondary" />
                <TextBlock Text="{Binding SelectedCount, StringFormat='{}{0} selected'}"
                           VerticalAlignment="Center" Margin="8,0" />
            </StackPanel>

            <!-- File Tree -->
            <TreeView Grid.Row="2" ItemsSource="{Binding TreeItems}" Margin="0,8">
                <TreeView.ItemTemplate>
                    <TreeDataTemplate ItemsSource="{Binding Children}">
                        <Grid ColumnDefinitions="Auto, Auto, *, Auto">
                            <CheckBox IsChecked="{Binding IsSelected}"
                                      IsVisible="{Binding IsFile}" />
                            <PathIcon Grid.Column="1"
                                      Data="{Binding Icon}"
                                      Width="16" Height="16" Margin="4,0" />
                            <TextBlock Grid.Column="2" Text="{Binding Name}" />
                            <StackPanel Grid.Column="3" Orientation="Horizontal" Spacing="4"
                                        IsVisible="{Binding IsFile}">
                                <Border Classes="language-badge"
                                        IsVisible="{Binding Language, Converter={x:Static StringConverters.IsNotNullOrEmpty}}">
                                    <TextBlock Text="{Binding Language}" FontSize="10" />
                                </Border>
                                <Border Classes="status-badge"
                                        Classes.exists="{Binding FileExists}">
                                    <TextBlock Text="exists" FontSize="10"
                                               IsVisible="{Binding FileExists}" />
                                </Border>
                            </StackPanel>
                        </Grid>
                    </TreeDataTemplate>
                </TreeView.ItemTemplate>
            </TreeView>

            <!-- Actions -->
            <Border Grid.Row="3" Padding="0,12,0,0"
                    BorderThickness="0,1,0,0"
                    BorderBrush="{DynamicResource BorderBrush}">
                <Grid ColumnDefinitions="Auto, *, Auto">
                    <StackPanel Orientation="Horizontal" Spacing="8">
                        <CheckBox Content="Create backup for existing files"
                                  IsChecked="{Binding CreateBackups}" />
                    </StackPanel>

                    <StackPanel Grid.Column="2" Orientation="Horizontal" Spacing="8">
                        <Button Content="Preview" Command="{Binding PreviewCommand}" />
                        <Button Content="Create Files"
                                Command="{Binding ApplyCommand}"
                                Classes="accent"
                                IsEnabled="{Binding HasSelectedFiles}" />
                    </StackPanel>
                </Grid>
            </Border>
        </Grid>
    </Border>
</UserControl>
```

### Batch Preview Dialog

```xml
<!-- BatchPreviewDialog.axaml -->
<Window Title="Preview Changes" Width="900" Height="700">
    <Grid RowDefinitions="Auto, *, Auto">
        <!-- File Tabs -->
        <TabControl Grid.Row="0"
                    ItemsSource="{Binding DiffPreviews}"
                    SelectedItem="{Binding SelectedPreview}">
            <TabControl.ItemTemplate>
                <DataTemplate>
                    <StackPanel Orientation="Horizontal" Spacing="4">
                        <TextBlock Text="{Binding FileName}" />
                        <Border Classes.new="{Binding IsNewFile}">
                            <TextBlock Text="NEW" FontSize="10" IsVisible="{Binding IsNewFile}" />
                        </Border>
                    </StackPanel>
                </DataTemplate>
            </TabControl.ItemTemplate>
        </TabControl>

        <!-- Diff View -->
        <local:DiffViewerPanel Grid.Row="1"
                               DataContext="{Binding SelectedPreview.DiffViewModel}" />

        <!-- Progress & Actions -->
        <Border Grid.Row="2" Padding="16">
            <Grid ColumnDefinitions="*, Auto">
                <ProgressBar Value="{Binding Progress}"
                             IsVisible="{Binding IsApplying}" />
                <StackPanel Grid.Column="1" Orientation="Horizontal" Spacing="8">
                    <Button Content="Cancel" Command="{Binding CancelCommand}" />
                    <Button Content="Apply All Selected"
                            Command="{Binding ApplyAllCommand}"
                            Classes="accent"
                            IsEnabled="{Binding !IsApplying}" />
                </StackPanel>
            </Grid>
        </Border>
    </Grid>
</Window>
```

### Apply Progress UI

```xml
<!-- ApplyProgressOverlay.axaml -->
<Border Classes="progress-overlay" IsVisible="{Binding IsApplying}">
    <StackPanel HorizontalAlignment="Center" VerticalAlignment="Center" Spacing="16">
        <ProgressBar Value="{Binding ApplyProgress.ProgressPercent}"
                     Width="300" />
        <TextBlock Text="{Binding ApplyProgress.CurrentFile}"
                   HorizontalAlignment="Center" />
        <TextBlock Text="{Binding ApplyProgress.CompletedOperations, StringFormat='{}{0} / {1} files'}"
                   HorizontalAlignment="Center"
                   Foreground="{DynamicResource TextMuted}" />
    </StackPanel>
</Border>
```

### Files to Create (v0.4.4)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Models/FileTreeProposal.cs` | Multi-file proposal model |
| `src/SeniorIntern.Core/Models/FileOperation.cs` | File operation model |
| `src/SeniorIntern.Core/Interfaces/IFileTreeProposalService.cs` | Service interface |
| `src/SeniorIntern.Services/FileTreeProposalService.cs` | Service implementation |
| `src/SeniorIntern.Desktop/ViewModels/FileTreeProposalViewModel.cs` | Proposal ViewModel |
| `src/SeniorIntern.Desktop/ViewModels/FileTreeItemViewModel.cs` | Tree item ViewModel |
| `src/SeniorIntern.Desktop/Views/FileTreeProposalPanel.axaml` | Proposal UI |
| `src/SeniorIntern.Desktop/Views/BatchPreviewDialog.axaml` | Batch preview dialog |
| `src/SeniorIntern.Desktop/Views/ApplyProgressOverlay.axaml` | Progress overlay |

### Files to Modify (v0.4.4)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/ViewModels/ChatMessageViewModel.cs` | Add FileTreeProposal |
| `src/SeniorIntern.Desktop/Views/ChatMessageControl.axaml` | Add proposal rendering |
| `src/SeniorIntern.Services/CodeBlockParserService.cs` | Detect multi-file patterns |

### Testing Strategy (v0.4.4)
- Test multi-file proposal detection
- Test tree structure parsing
- Test batch file creation
- Test partial selection and apply
- Test progress reporting
- Test rollback on partial failure

---

## v0.4.5: Polish & Integration

### Objective
Final integration of all code generation features, streaming diff preview, partial apply for snippets, keyboard shortcuts, and comprehensive testing.

### Streaming Diff Preview

Show diff computation progress during LLM streaming:

```csharp
public partial class ChatMessageViewModel
{
    [ObservableProperty]
    private bool _isComputingDiff;

    [ObservableProperty]
    private DiffResult? _streamingDiffPreview;

    // Called during streaming when a code block is detected
    public async Task OnCodeBlockDetectedAsync(CodeBlock block)
    {
        if (string.IsNullOrEmpty(block.TargetFilePath))
            return;

        IsComputingDiff = true;
        try
        {
            // Compute diff in background
            var diff = await _diffService.ComputeDiffForBlockAsync(
                block, _workspaceService.CurrentWorkspace!.RootPath);

            StreamingDiffPreview = diff;
            HasApplicableCode = true;
        }
        finally
        {
            IsComputingDiff = false;
        }
    }
}
```

### Partial Snippet Apply

For snippets that should replace specific lines:

```csharp
public sealed class SnippetApplyOptions
{
    /// <summary>
    /// Where to insert the snippet
    /// </summary>
    public SnippetInsertMode InsertMode { get; set; } = SnippetInsertMode.Replace;

    /// <summary>
    /// Target line for insert operations
    /// </summary>
    public int? TargetLine { get; set; }

    /// <summary>
    /// Lines to replace (for Replace mode)
    /// </summary>
    public LineRange? ReplaceRange { get; set; }
}

public enum SnippetInsertMode
{
    Replace,        // Replace specific lines
    InsertBefore,   // Insert before target line
    InsertAfter,    // Insert after target line
    Append,         // Append to end of file
    Prepend         // Add to beginning of file
}
```

### Partial Apply UI

```xml
<!-- SnippetApplyOptionsPopup.axaml -->
<Popup PlacementMode="Bottom" StaysOpen="False">
    <Border Classes="popup-content" Padding="12">
        <StackPanel Spacing="12">
            <TextBlock Text="Apply snippet to:" FontWeight="SemiBold" />

            <RadioButton Content="Replace lines"
                         IsChecked="{Binding InsertMode,
                             Converter={StaticResource EnumConverter},
                             ConverterParameter=Replace}" />

            <Grid ColumnDefinitions="Auto, 60, Auto, 60" Margin="20,0,0,0"
                  IsEnabled="{Binding IsReplaceMode}">
                <TextBlock Text="From:" VerticalAlignment="Center" />
                <NumericUpDown Grid.Column="1" Value="{Binding StartLine}" Minimum="1" />
                <TextBlock Grid.Column="2" Text="To:" VerticalAlignment="Center" Margin="8,0" />
                <NumericUpDown Grid.Column="3" Value="{Binding EndLine}" Minimum="1" />
            </Grid>

            <RadioButton Content="Insert after line"
                         IsChecked="{Binding InsertMode,
                             Converter={StaticResource EnumConverter},
                             ConverterParameter=InsertAfter}" />

            <NumericUpDown Value="{Binding TargetLine}" Minimum="1" Margin="20,0,0,0"
                           IsEnabled="{Binding IsInsertMode}" />

            <RadioButton Content="Append to end of file"
                         IsChecked="{Binding InsertMode,
                             Converter={StaticResource EnumConverter},
                             ConverterParameter=Append}" />

            <Separator />

            <Button Content="Preview" Command="{Binding PreviewCommand}" />
        </StackPanel>
    </Border>
</Popup>
```

### Keyboard Shortcuts

| Shortcut | Action | Context |
|----------|--------|---------|
| Ctrl+Shift+A | Apply all pending changes | Chat view |
| Ctrl+Shift+D | Show diff for selected block | Code block selected |
| Ctrl+Shift+U | Undo last file change | Global |
| Enter | Apply changes | Diff viewer focused |
| Escape | Reject/close diff viewer | Diff viewer focused |
| ↑/↓ | Navigate between hunks | Diff viewer focused |
| Ctrl+C | Copy proposed code | Code block focused |

### Quick Actions Menu

```xml
<!-- Inline quick actions for code blocks -->
<StackPanel Orientation="Horizontal" Classes="code-quick-actions">
    <Button ToolTip.Tip="Apply (Ctrl+Enter)" Command="{Binding ApplyCommand}">
        <PathIcon Data="{StaticResource CheckIcon}" />
    </Button>
    <Button ToolTip.Tip="Copy" Command="{Binding CopyCommand}">
        <PathIcon Data="{StaticResource CopyIcon}" />
    </Button>
    <Button ToolTip.Tip="Show diff" Command="{Binding ShowDiffCommand}">
        <PathIcon Data="{StaticResource DiffIcon}" />
    </Button>
    <Button ToolTip.Tip="Open in editor" Command="{Binding OpenInEditorCommand}">
        <PathIcon Data="{StaticResource ExternalLinkIcon}" />
    </Button>
    <Button ToolTip.Tip="More options" Command="{Binding ShowOptionsCommand}">
        <PathIcon Data="{StaticResource MoreIcon}" />
    </Button>
</StackPanel>
```

### Settings Updates

```csharp
public sealed class AppSettings
{
    // ... existing properties ...

    // Code Generation settings (v0.4.0)
    public bool AutoDetectCodeBlocks { get; set; } = true;
    public bool ShowDiffPreviewDuringStreaming { get; set; } = true;
    public bool CreateBackupBeforeApply { get; set; } = true;
    public int UndoWindowMinutes { get; set; } = 30;
    public int MaxBackupAgeDays { get; set; } = 7;
    public bool AutoRefreshEditorAfterApply { get; set; } = true;
    public DiffViewMode DefaultDiffViewMode { get; set; } = DiffViewMode.SideBySide;
}

public enum DiffViewMode
{
    SideBySide,
    Inline,
    Unified
}
```

### Status Bar Integration

```
┌─────────────────────────────────────────────────────────────────┐
│ Model: llama.gguf │ [📝 3 pending changes] │ ✓ Saved │ T:0.7    │
└─────────────────────────────────────────────────────────────────┘
```

Clicking "3 pending changes" opens a summary panel.

### Change History Panel

```xml
<!-- ChangeHistoryPanel.axaml -->
<Border Classes="history-panel">
    <Grid RowDefinitions="Auto, *">
        <TextBlock Text="Recent Changes" FontWeight="SemiBold" Padding="12" />

        <ListBox Grid.Row="1" ItemsSource="{Binding RecentChanges}">
            <ListBox.ItemTemplate>
                <DataTemplate>
                    <Grid ColumnDefinitions="Auto, *, Auto, Auto">
                        <PathIcon Data="{Binding TypeIcon}" Width="14" Height="14" />
                        <StackPanel Grid.Column="1" Margin="8,0">
                            <TextBlock Text="{Binding FileName}" />
                            <TextBlock Text="{Binding RelativeTime}"
                                       FontSize="11" Foreground="{DynamicResource TextMuted}" />
                        </StackPanel>
                        <Button Grid.Column="2" Content="Undo"
                                Command="{Binding UndoCommand}"
                                IsEnabled="{Binding CanUndo}"
                                Classes="secondary" />
                        <Button Grid.Column="3" Content="View Diff"
                                Command="{Binding ViewDiffCommand}" />
                    </Grid>
                </DataTemplate>
            </ListBox.ItemTemplate>
        </ListBox>
    </Grid>
</Border>
```

### Files to Create (v0.4.5)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/Views/SnippetApplyOptionsPopup.axaml` | Snippet options |
| `src/SeniorIntern.Desktop/Views/ChangeHistoryPanel.axaml` | Change history UI |
| `src/SeniorIntern.Desktop/ViewModels/ChangeHistoryViewModel.cs` | History ViewModel |
| `src/SeniorIntern.Desktop/ViewModels/SnippetApplyOptionsViewModel.cs` | Options ViewModel |

### Files to Modify (v0.4.5)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Core/Models/AppSettings.cs` | Add code gen settings |
| `src/SeniorIntern.Desktop/Views/MainWindow.axaml` | Add keyboard shortcuts, status bar |
| `src/SeniorIntern.Desktop/Views/ChatMessageControl.axaml` | Add quick actions |
| `src/SeniorIntern.Desktop/ViewModels/MainWindowViewModel.cs` | Wire up shortcuts |

### Testing Strategy (v0.4.5)
- End-to-end tests for complete workflow
- Keyboard shortcut coverage tests
- Streaming diff preview tests
- Partial snippet apply tests
- History panel functionality tests
- Settings persistence tests

---

## Architecture Summary

### Project Structure After v0.4.0

```
SeniorIntern/
├── src/
│   ├── SeniorIntern.Core/
│   │   ├── Models/
│   │   │   ├── CodeBlock.cs                     [NEW]
│   │   │   ├── CodeProposal.cs                  [NEW]
│   │   │   ├── DiffResult.cs                    [NEW]
│   │   │   ├── FileTreeProposal.cs              [NEW]
│   │   │   ├── FileOperation.cs                 [NEW]
│   │   │   └── AppSettings.cs (updated)
│   │   └── Interfaces/
│   │       ├── ICodeBlockParserService.cs       [NEW]
│   │       ├── IDiffService.cs                  [NEW]
│   │       ├── IFileChangeService.cs            [NEW]
│   │       └── IFileTreeProposalService.cs      [NEW]
│   │
│   ├── SeniorIntern.Services/
│   │   ├── CodeBlockParserService.cs            [NEW]
│   │   ├── DiffService.cs                       [NEW]
│   │   ├── FileChangeService.cs                 [NEW]
│   │   └── FileTreeProposalService.cs           [NEW]
│   │
│   └── SeniorIntern.Desktop/
│       ├── ViewModels/
│       │   ├── DiffViewerViewModel.cs           [NEW]
│       │   ├── ApplyChangesDialogViewModel.cs   [NEW]
│       │   ├── ConflictWarningViewModel.cs      [NEW]
│       │   ├── FileTreeProposalViewModel.cs     [NEW]
│       │   ├── FileTreeItemViewModel.cs         [NEW]
│       │   ├── ChangeHistoryViewModel.cs        [NEW]
│       │   ├── SnippetApplyOptionsViewModel.cs  [NEW]
│       │   └── ChatMessageViewModel.cs (updated)
│       ├── Views/
│       │   ├── DiffViewerPanel.axaml            [NEW]
│       │   ├── ApplyChangesDialog.axaml         [NEW]
│       │   ├── ConflictWarningDialog.axaml      [NEW]
│       │   ├── BatchPreviewDialog.axaml         [NEW]
│       │   ├── FileTreeProposalPanel.axaml      [NEW]
│       │   ├── ApplyProgressOverlay.axaml       [NEW]
│       │   ├── SnippetApplyOptionsPopup.axaml   [NEW]
│       │   ├── ChangeHistoryPanel.axaml         [NEW]
│       │   └── ChatMessageControl.axaml (updated)
│       ├── Controls/
│       │   ├── DiffLineControl.axaml            [NEW]
│       │   └── DiffHunkView.axaml               [NEW]
│       └── Converters/
│           ├── IsApplicableBlockConverter.cs    [NEW]
│           └── DiffTypeConverter.cs             [NEW]
```

### New NuGet Packages (v0.4.0)

| Package | Version | Project | Purpose |
|---------|---------|---------|---------|
| DiffPlex | 1.7.2 | Services | Diff computation |

### Dependency Flow

```
SeniorIntern.Core (no dependencies)
       ↑
SeniorIntern.Data (→ Core, EF Core)
       ↑
SeniorIntern.Services (→ Core, Data, LLamaSharp, DiffPlex)
       ↑
SeniorIntern.Desktop (→ Core, Services, Avalonia, AvaloniaEdit)
```

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Code block parsing false positives | Medium | Low | Confidence scoring, manual toggle |
| Diff computation performance | Low | Medium | Async computation, caching |
| File corruption during apply | Low | High | Backup before write, atomic operations |
| Conflict resolution complexity | Medium | Medium | Clear UI, refresh option |
| Multi-file partial failures | Medium | Medium | Transaction-like rollback |
| Snippet merge accuracy | High | Medium | Fuzzy matching, manual range selection |

---

## Acceptance Criteria

### v0.4.1
- [ ] Code blocks extracted from markdown responses
- [ ] Language detection accurate for common languages
- [ ] File path inference from context works
- [ ] Block type classification (example vs applicable) correct
- [ ] Streaming parsing works during generation

### v0.4.2
- [ ] Diff computation produces correct results
- [ ] Side-by-side view aligned properly
- [ ] Inline changes highlighted
- [ ] Synchronized scrolling works
- [ ] Hunk navigation functions

### v0.4.3
- [ ] Apply workflow creates/modifies files correctly
- [ ] Backup files created before modification
- [ ] Undo restores previous state
- [ ] Conflict detection prevents data loss
- [ ] Editor refreshes after apply

### v0.4.4
- [ ] Multi-file proposals detected
- [ ] Tree view displays structure correctly
- [ ] Batch apply creates all files
- [ ] Partial selection works
- [ ] Progress reporting accurate

### v0.4.5
- [ ] All keyboard shortcuts function
- [ ] Streaming diff preview works
- [ ] Partial snippet apply available
- [ ] Change history tracks operations
- [ ] Settings persist correctly

---

## References

- [DiffPlex Library](https://github.com/mmanela/diffplex)
- [Side-by-Side Diff Visualization Patterns](https://github.blog/2018-05-01-side-by-side-diffs/)
- [Monaco Editor Diff Implementation](https://microsoft.github.io/monaco-editor/)
- [VS Code SCM/Git Diff View](https://code.visualstudio.com/docs/sourcecontrol/overview)
- [Unified Diff Format](https://en.wikipedia.org/wiki/Diff#Unified_format)
