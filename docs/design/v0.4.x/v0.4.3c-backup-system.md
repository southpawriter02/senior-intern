# v0.4.3c: Backup System - Design Specification

**Status**: _IMPLEMENTED_

## Executive Summary

This specification details the **Backup System** for The Senior Intern's Apply Changes Workflow. The `BackupService` provides reliable file backup capabilities that enable the undo functionality in the apply workflow. It manages backup creation, restoration, storage, metadata tracking, and automatic cleanup of old backups. The system uses a hash-based naming scheme to correlate backups with their original files and stores metadata alongside each backup for traceability.

### Key Deliverables

| Component | Type | Purpose |
|-----------|------|---------|
| `IBackupService` | Interface | Contract for backup operations |
| `BackupService` | Class | Main implementation with full functionality |
| `BackupInfo` | Class | Information about a backup file |
| `BackupMetadata` | Class | Serialized metadata stored with backups |
| `BackupOptions` | Record | Configuration for backup behavior |
| `BackupStorageInfo` | Class | Storage statistics and health information |
| Cleanup System | Methods | Automatic and manual cleanup of old backups |
| Integrity Verification | Methods | Verify backup file integrity |

---

## Feature Overview

```
v0.4.3c: Backup System
├── Service Interface (IBackupService)
│   ├── Backup Operations
│   │   ├── CreateBackupAsync
│   │   ├── CreateBackupWithHashAsync
│   │   └── CreateIncrementalBackupAsync
│   ├── Restore Operations
│   │   ├── RestoreBackupAsync
│   │   └── RestoreLatestBackupAsync
│   ├── Delete Operations
│   │   ├── DeleteBackupAsync
│   │   └── DeleteAllBackupsForFileAsync
│   ├── Query Operations
│   │   ├── GetBackupsForFile
│   │   ├── GetAllBackups
│   │   ├── GetBackupInfo
│   │   └── BackupExistsAsync
│   ├── Cleanup Operations
│   │   ├── CleanupOldBackupsAsync
│   │   ├── CleanupByStorageLimitAsync
│   │   └── CleanupOrphanedBackupsAsync
│   ├── Storage Operations
│   │   ├── GetTotalBackupSize
│   │   ├── GetStorageInfo
│   │   └── BackupDirectory (property)
│   └── Integrity Operations
│       ├── VerifyBackupIntegrityAsync
│       └── VerifyAllBackupsAsync
├── Models
│   ├── BackupInfo
│   │   ├── BackupPath
│   │   ├── OriginalPath
│   │   ├── CreatedAt
│   │   ├── SizeBytes
│   │   ├── ContentHash
│   │   └── IsVerified
│   ├── BackupMetadata (internal)
│   │   ├── OriginalPath
│   │   ├── CreatedAt
│   │   ├── OriginalSize
│   │   ├── ContentHash
│   │   ├── WorkspacePath
│   │   └── Version
│   ├── BackupOptions
│   │   ├── MaxBackupsPerFile
│   │   ├── MaxTotalStorageBytes
│   │   ├── MaxBackupAge
│   │   ├── ComputeContentHash
│   │   └── CompressBackups
│   └── BackupStorageInfo
│       ├── TotalSizeBytes
│       ├── BackupCount
│       ├── OldestBackup
│       ├── NewestBackup
│       └── HealthStatus
├── Naming Convention
│   ├── Format: {filename}_{timestamp}_{pathHash}{ext}.backup
│   ├── Timestamp: yyyyMMdd_HHmmss_fff
│   ├── PathHash: First 8 chars of MD5(lowercase path)
│   └── Metadata: {backupName}.meta
└── Storage Location
    ├── Default: %LocalAppData%/SeniorIntern/backups
    ├── Custom: Configurable via constructor
    └── Per-workspace: Optional subdirectories
```

---

## Architecture Diagrams

### Backup Creation Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           Backup Creation Flow                               │
└─────────────────────────────────────────────────────────────────────────────┘

                         ┌──────────────────┐
                         │  Original File   │
                         │  (source path)   │
                         └────────┬─────────┘
                                  │
                                  ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                            BackupService                                     │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │                      CreateBackupAsync                                 │  │
│  │                                                                        │  │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐   │  │
│  │  │   Verify    │─▶│  Generate   │─▶│    Copy     │─▶│   Write     │   │  │
│  │  │ File Exists │  │ Backup Name │  │    File     │  │  Metadata   │   │  │
│  │  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘   │  │
│  │        │                │                │                │           │  │
│  │        │                │                │                │           │  │
│  │        ▼                ▼                ▼                ▼           │  │
│  │  FileNotFound    Path Hash +       source.txt →     JSON metadata     │  │
│  │  Exception       Timestamp         backup file      + content hash    │  │
│  │                                                                        │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────┘
                                  │
                    ┌─────────────┴─────────────┐
                    ▼                           ▼
         ┌──────────────────┐        ┌──────────────────┐
         │   Backup File    │        │  Metadata File   │
         │  Example.cs_     │        │  Example.cs_     │
         │  20240115_       │        │  20240115_       │
         │  143052_A1B2C3D4 │        │  143052_A1B2C3D4 │
         │  .cs.backup      │        │  .cs.backup.meta │
         └──────────────────┘        └──────────────────┘
```

### Backup Naming Convention

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         Backup Naming Convention                             │
└─────────────────────────────────────────────────────────────────────────────┘

Original File: /workspace/src/Services/UserService.cs

                    ┌─────────────────────────────────────────────────────┐
                    │              Backup Filename Components              │
                    └─────────────────────────────────────────────────────┘

┌───────────────┐  ┌──────────────────────┐  ┌──────────┐  ┌────┐  ┌───────┐
│  UserService  │  │  20240115_143052_789 │  │ A1B2C3D4 │  │ .cs│  │.backup│
│   (base name) │  │     (UTC timestamp)  │  │(path hash)│  │(ext)│  │(suffix)│
└───────┬───────┘  └──────────┬───────────┘  └────┬─────┘  └──┬─┘  └───┬───┘
        │                     │                   │           │        │
        │                     │                   │           │        │
        └─────────────────────┴───────────────────┴───────────┴────────┘
                                        │
                                        ▼
          UserService_20240115_143052_789_A1B2C3D4.cs.backup

                    ┌─────────────────────────────────────────────────────┐
                    │                  Path Hash Computation               │
                    └─────────────────────────────────────────────────────┘

    /workspace/src/Services/UserService.cs
                    │
                    ▼
    (lowercase) /workspace/src/services/userservice.cs
                    │
                    ▼
    MD5: "a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6"
                    │
                    ▼
    First 8 chars: "A1B2C3D4"

    Purpose: Group backups by original file path regardless of filename changes
```

### Storage Structure

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           Backup Storage Structure                           │
└─────────────────────────────────────────────────────────────────────────────┘

%LocalAppData%/SeniorIntern/
└── backups/
    ├── UserService_20240115_143052_789_A1B2C3D4.cs.backup
    ├── UserService_20240115_143052_789_A1B2C3D4.cs.backup.meta
    ├── UserService_20240115_150000_123_A1B2C3D4.cs.backup
    ├── UserService_20240115_150000_123_A1B2C3D4.cs.backup.meta
    ├── Program_20240115_120000_000_B5C6D7E8.cs.backup
    ├── Program_20240115_120000_000_B5C6D7E8.cs.backup.meta
    └── .backup-index.json (optional index for faster queries)

                    ┌─────────────────────────────────────────────────────┐
                    │              Metadata File Contents                  │
                    └─────────────────────────────────────────────────────┘

{
    "version": 1,
    "originalPath": "/workspace/src/Services/UserService.cs",
    "workspacePath": "/workspace",
    "createdAt": "2024-01-15T14:30:52.789Z",
    "originalSize": 4096,
    "contentHash": "sha256:abc123...",
    "originalLastModified": "2024-01-15T14:25:00.000Z"
}
```

### Cleanup Strategy

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                            Cleanup Strategy                                  │
└─────────────────────────────────────────────────────────────────────────────┘

                         Cleanup Triggers
                               │
          ┌────────────────────┼────────────────────┐
          │                    │                    │
          ▼                    ▼                    ▼
   ┌─────────────┐      ┌─────────────┐      ┌─────────────┐
   │  Age-Based  │      │ Size-Based  │      │  Count-Based │
   │  Cleanup    │      │  Cleanup    │      │   Cleanup    │
   └──────┬──────┘      └──────┬──────┘      └──────┬──────┘
          │                    │                    │
          ▼                    ▼                    ▼
   Delete backups       Delete oldest        Delete oldest
   older than           until under          backups per file
   maxAge               maxStorage           beyond maxCount
   (default: 7 days)    (default: 500MB)     (default: 10)

                         ┌─────────────┐
                         │   Orphan    │
                         │  Detection  │
                         └──────┬──────┘
                                │
                                ▼
                         Delete backups
                         where metadata
                         is missing or
                         corrupted
```

---

## Detailed Design

### IBackupService Interface

```csharp
// src/SeniorIntern.Core/Interfaces/IBackupService.cs
namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Service for managing file backups to support undo operations.
/// </summary>
/// <remarks>
/// The backup service provides:
/// <list type="bullet">
///   <item>Automatic backup creation before file modifications</item>
///   <item>Metadata tracking for each backup (original path, hash, timestamps)</item>
///   <item>Multiple backups per file with configurable limits</item>
///   <item>Cleanup of old backups by age, size, or count</item>
///   <item>Integrity verification of backup files</item>
/// </list>
/// </remarks>
public interface IBackupService
{
    #region Properties

    /// <summary>
    /// Gets the directory where backups are stored.
    /// </summary>
    string BackupDirectory { get; }

    #endregion

    #region Backup Operations

    /// <summary>
    /// Create a backup of a file.
    /// </summary>
    /// <param name="filePath">The absolute path to the file to backup.</param>
    /// <param name="ct">Cancellation token for the operation.</param>
    /// <returns>The path to the created backup file.</returns>
    /// <exception cref="FileNotFoundException">If the source file does not exist.</exception>
    /// <exception cref="IOException">If the backup cannot be created.</exception>
    Task<string> CreateBackupAsync(string filePath, CancellationToken ct = default);

    /// <summary>
    /// Create a backup with a pre-computed content hash.
    /// </summary>
    /// <param name="filePath">The absolute path to the file to backup.</param>
    /// <param name="contentHash">Pre-computed hash of the file content.</param>
    /// <param name="ct">Cancellation token for the operation.</param>
    /// <returns>The path to the created backup file.</returns>
    /// <remarks>
    /// Use this overload when you've already computed the hash (e.g., for conflict detection)
    /// to avoid redundant hash computation.
    /// </remarks>
    Task<string> CreateBackupWithHashAsync(
        string filePath,
        string contentHash,
        CancellationToken ct = default);

    /// <summary>
    /// Create an incremental backup only if content has changed.
    /// </summary>
    /// <param name="filePath">The absolute path to the file to backup.</param>
    /// <param name="ct">Cancellation token for the operation.</param>
    /// <returns>
    /// The path to the backup file (existing or new), or null if file hasn't changed.
    /// </returns>
    /// <remarks>
    /// Compares the current file hash with the most recent backup's hash.
    /// If identical, returns the existing backup path without creating a new one.
    /// </remarks>
    Task<string?> CreateIncrementalBackupAsync(string filePath, CancellationToken ct = default);

    #endregion

    #region Restore Operations

    /// <summary>
    /// Restore a file from a specific backup.
    /// </summary>
    /// <param name="backupPath">The path to the backup file.</param>
    /// <param name="targetPath">The path where the file should be restored.</param>
    /// <param name="ct">Cancellation token for the operation.</param>
    /// <returns>True if restoration succeeded, false otherwise.</returns>
    Task<bool> RestoreBackupAsync(
        string backupPath,
        string targetPath,
        CancellationToken ct = default);

    /// <summary>
    /// Restore a file from its most recent backup.
    /// </summary>
    /// <param name="originalPath">The original file path.</param>
    /// <param name="ct">Cancellation token for the operation.</param>
    /// <returns>True if restoration succeeded, false if no backup exists.</returns>
    Task<bool> RestoreLatestBackupAsync(string originalPath, CancellationToken ct = default);

    #endregion

    #region Delete Operations

    /// <summary>
    /// Delete a specific backup file and its metadata.
    /// </summary>
    /// <param name="backupPath">The path to the backup file to delete.</param>
    /// <param name="ct">Cancellation token for the operation.</param>
    /// <returns>True if deletion succeeded, false otherwise.</returns>
    Task<bool> DeleteBackupAsync(string backupPath, CancellationToken ct = default);

    /// <summary>
    /// Delete all backups for a specific file.
    /// </summary>
    /// <param name="originalPath">The original file path.</param>
    /// <param name="ct">Cancellation token for the operation.</param>
    /// <returns>Number of backups deleted.</returns>
    Task<int> DeleteAllBackupsForFileAsync(string originalPath, CancellationToken ct = default);

    #endregion

    #region Query Operations

    /// <summary>
    /// Get all backups for a specific file.
    /// </summary>
    /// <param name="originalPath">The original file path.</param>
    /// <returns>List of backup information, ordered by creation time (newest first).</returns>
    IReadOnlyList<BackupInfo> GetBackupsForFile(string originalPath);

    /// <summary>
    /// Get all backups in the backup directory.
    /// </summary>
    /// <returns>List of all backup information.</returns>
    IReadOnlyList<BackupInfo> GetAllBackups();

    /// <summary>
    /// Get information about a specific backup.
    /// </summary>
    /// <param name="backupPath">The path to the backup file.</param>
    /// <returns>Backup information, or null if backup doesn't exist.</returns>
    BackupInfo? GetBackupInfo(string backupPath);

    /// <summary>
    /// Check if a backup exists for a file.
    /// </summary>
    /// <param name="originalPath">The original file path.</param>
    /// <param name="ct">Cancellation token for the operation.</param>
    /// <returns>True if at least one backup exists.</returns>
    Task<bool> BackupExistsAsync(string originalPath, CancellationToken ct = default);

    #endregion

    #region Cleanup Operations

    /// <summary>
    /// Clean up backups older than the specified age.
    /// </summary>
    /// <param name="maxAge">Maximum age of backups to keep.</param>
    /// <param name="ct">Cancellation token for the operation.</param>
    /// <returns>Number of backups deleted.</returns>
    Task<int> CleanupOldBackupsAsync(TimeSpan maxAge, CancellationToken ct = default);

    /// <summary>
    /// Clean up backups to stay under storage limit.
    /// </summary>
    /// <param name="maxStorageBytes">Maximum total storage to use for backups.</param>
    /// <param name="ct">Cancellation token for the operation.</param>
    /// <returns>Number of backups deleted.</returns>
    /// <remarks>
    /// Deletes oldest backups first until total storage is under the limit.
    /// </remarks>
    Task<int> CleanupByStorageLimitAsync(long maxStorageBytes, CancellationToken ct = default);

    /// <summary>
    /// Clean up orphaned backups (missing or corrupted metadata).
    /// </summary>
    /// <param name="ct">Cancellation token for the operation.</param>
    /// <returns>Number of orphaned backups deleted.</returns>
    Task<int> CleanupOrphanedBackupsAsync(CancellationToken ct = default);

    /// <summary>
    /// Clean up excess backups per file beyond the limit.
    /// </summary>
    /// <param name="maxBackupsPerFile">Maximum backups to keep per original file.</param>
    /// <param name="ct">Cancellation token for the operation.</param>
    /// <returns>Number of backups deleted.</returns>
    Task<int> CleanupExcessBackupsAsync(int maxBackupsPerFile, CancellationToken ct = default);

    #endregion

    #region Storage Operations

    /// <summary>
    /// Get total size of all backup files.
    /// </summary>
    /// <returns>Total size in bytes.</returns>
    long GetTotalBackupSize();

    /// <summary>
    /// Get storage information and health status.
    /// </summary>
    /// <returns>Storage statistics and health information.</returns>
    BackupStorageInfo GetStorageInfo();

    #endregion

    #region Integrity Operations

    /// <summary>
    /// Verify integrity of a specific backup.
    /// </summary>
    /// <param name="backupPath">The path to the backup file.</param>
    /// <param name="ct">Cancellation token for the operation.</param>
    /// <returns>True if backup is valid, false if corrupted.</returns>
    Task<bool> VerifyBackupIntegrityAsync(string backupPath, CancellationToken ct = default);

    /// <summary>
    /// Verify integrity of all backups.
    /// </summary>
    /// <param name="ct">Cancellation token for the operation.</param>
    /// <returns>List of corrupted backup paths.</returns>
    Task<IReadOnlyList<string>> VerifyAllBackupsAsync(CancellationToken ct = default);

    #endregion
}
```

### BackupInfo Model

```csharp
// src/SeniorIntern.Core/Models/BackupInfo.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Information about a backup file.
/// </summary>
public sealed class BackupInfo
{
    /// <summary>
    /// Full path to the backup file.
    /// </summary>
    public string BackupPath { get; init; } = string.Empty;

    /// <summary>
    /// Original file path that was backed up.
    /// </summary>
    public string OriginalPath { get; init; } = string.Empty;

    /// <summary>
    /// Relative path within the workspace (if available).
    /// </summary>
    public string? RelativePath { get; init; }

    /// <summary>
    /// When the backup was created (UTC).
    /// </summary>
    public DateTime CreatedAt { get; init; }

    /// <summary>
    /// Size of the backup file in bytes.
    /// </summary>
    public long SizeBytes { get; init; }

    /// <summary>
    /// SHA-256 hash of the file content (if computed).
    /// </summary>
    public string? ContentHash { get; init; }

    /// <summary>
    /// Whether the backup has been verified for integrity.
    /// </summary>
    public bool IsVerified { get; init; }

    /// <summary>
    /// The workspace path at the time of backup (if available).
    /// </summary>
    public string? WorkspacePath { get; init; }

    /// <summary>
    /// Original file's last modified time (if available).
    /// </summary>
    public DateTime? OriginalLastModified { get; init; }

    /// <summary>
    /// Gets the age of this backup.
    /// </summary>
    public TimeSpan Age => DateTime.UtcNow - CreatedAt;

    /// <summary>
    /// Gets the filename portion of the backup path.
    /// </summary>
    public string BackupFileName => Path.GetFileName(BackupPath);

    /// <summary>
    /// Gets the filename portion of the original path.
    /// </summary>
    public string OriginalFileName => Path.GetFileName(OriginalPath);
}
```

### BackupOptions Model

```csharp
// src/SeniorIntern.Core/Models/BackupOptions.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Configuration options for the backup service.
/// </summary>
public sealed record BackupOptions
{
    /// <summary>
    /// Maximum number of backups to keep per original file.
    /// </summary>
    /// <remarks>
    /// When exceeded, oldest backups are deleted.
    /// Default: 10 backups per file.
    /// </remarks>
    public int MaxBackupsPerFile { get; init; } = 10;

    /// <summary>
    /// Maximum total storage for all backups in bytes.
    /// </summary>
    /// <remarks>
    /// When exceeded, oldest backups are deleted.
    /// Default: 500 MB.
    /// </remarks>
    public long MaxTotalStorageBytes { get; init; } = 500 * 1024 * 1024; // 500 MB

    /// <summary>
    /// Maximum age of backups to keep.
    /// </summary>
    /// <remarks>
    /// Backups older than this are eligible for cleanup.
    /// Default: 7 days.
    /// </remarks>
    public TimeSpan MaxBackupAge { get; init; } = TimeSpan.FromDays(7);

    /// <summary>
    /// Whether to compute content hash for each backup.
    /// </summary>
    /// <remarks>
    /// Enables incremental backups and integrity verification.
    /// Default: true.
    /// </remarks>
    public bool ComputeContentHash { get; init; } = true;

    /// <summary>
    /// Whether to compress backup files.
    /// </summary>
    /// <remarks>
    /// Not implemented in v0.4.3c, reserved for future use.
    /// Default: false.
    /// </remarks>
    public bool CompressBackups { get; init; } = false;

    /// <summary>
    /// Whether to run automatic cleanup after creating backups.
    /// </summary>
    /// <remarks>
    /// If true, cleanup is triggered after each backup creation.
    /// Default: false (manual cleanup preferred).
    /// </remarks>
    public bool AutoCleanup { get; init; } = false;

    /// <summary>
    /// Interval for automatic cleanup timer.
    /// </summary>
    /// <remarks>
    /// Only used when AutoCleanup is true.
    /// Default: 1 hour.
    /// </remarks>
    public TimeSpan AutoCleanupInterval { get; init; } = TimeSpan.FromHours(1);

    /// <summary>
    /// Whether to verify backups after creation.
    /// </summary>
    /// <remarks>
    /// Reads back the backup to verify it matches the source.
    /// Default: false (for performance).
    /// </remarks>
    public bool VerifyAfterCreate { get; init; } = false;

    /// <summary>
    /// Custom backup directory path.
    /// </summary>
    /// <remarks>
    /// If null, uses default location: %LocalAppData%/SeniorIntern/backups
    /// </remarks>
    public string? CustomBackupDirectory { get; init; }

    /// <summary>
    /// Default backup options.
    /// </summary>
    public static BackupOptions Default { get; } = new();

    /// <summary>
    /// Minimal options for testing (small limits).
    /// </summary>
    public static BackupOptions Minimal { get; } = new()
    {
        MaxBackupsPerFile = 3,
        MaxTotalStorageBytes = 10 * 1024 * 1024, // 10 MB
        MaxBackupAge = TimeSpan.FromHours(1),
        ComputeContentHash = true
    };

    /// <summary>
    /// Extended options for long-term backup retention.
    /// </summary>
    public static BackupOptions Extended { get; } = new()
    {
        MaxBackupsPerFile = 50,
        MaxTotalStorageBytes = 2L * 1024 * 1024 * 1024, // 2 GB
        MaxBackupAge = TimeSpan.FromDays(30),
        ComputeContentHash = true
    };
}
```

### BackupStorageInfo Model

```csharp
// src/SeniorIntern.Core/Models/BackupStorageInfo.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Storage statistics and health information for backups.
/// </summary>
public sealed class BackupStorageInfo
{
    /// <summary>
    /// Total size of all backup files in bytes.
    /// </summary>
    public long TotalSizeBytes { get; init; }

    /// <summary>
    /// Total number of backup files.
    /// </summary>
    public int BackupCount { get; init; }

    /// <summary>
    /// Number of unique original files with backups.
    /// </summary>
    public int UniqueFilesCount { get; init; }

    /// <summary>
    /// Timestamp of the oldest backup.
    /// </summary>
    public DateTime? OldestBackup { get; init; }

    /// <summary>
    /// Timestamp of the newest backup.
    /// </summary>
    public DateTime? NewestBackup { get; init; }

    /// <summary>
    /// Number of backups with corrupted or missing metadata.
    /// </summary>
    public int OrphanedCount { get; init; }

    /// <summary>
    /// Number of backups that failed integrity verification.
    /// </summary>
    public int CorruptedCount { get; init; }

    /// <summary>
    /// Overall health status of the backup system.
    /// </summary>
    public BackupHealthStatus HealthStatus { get; init; }

    /// <summary>
    /// Path to the backup directory.
    /// </summary>
    public string BackupDirectory { get; init; } = string.Empty;

    /// <summary>
    /// Available disk space in the backup directory.
    /// </summary>
    public long AvailableDiskSpaceBytes { get; init; }

    /// <summary>
    /// Formatted total size (e.g., "125.5 MB").
    /// </summary>
    public string FormattedTotalSize => FormatBytes(TotalSizeBytes);

    /// <summary>
    /// Formatted available space (e.g., "50.2 GB").
    /// </summary>
    public string FormattedAvailableSpace => FormatBytes(AvailableDiskSpaceBytes);

    private static string FormatBytes(long bytes)
    {
        string[] sizes = { "B", "KB", "MB", "GB", "TB" };
        int order = 0;
        double size = bytes;
        while (size >= 1024 && order < sizes.Length - 1)
        {
            order++;
            size /= 1024;
        }
        return $"{size:0.##} {sizes[order]}";
    }
}

/// <summary>
/// Health status of the backup system.
/// </summary>
public enum BackupHealthStatus
{
    /// <summary>
    /// All backups are healthy.
    /// </summary>
    Healthy,

    /// <summary>
    /// Some backups have issues but system is functional.
    /// </summary>
    Warning,

    /// <summary>
    /// Critical issues detected (e.g., disk full, many corrupted backups).
    /// </summary>
    Critical,

    /// <summary>
    /// Backup system is unavailable.
    /// </summary>
    Unavailable
}
```

### BackupService Implementation

```csharp
// src/SeniorIntern.Services/BackupService.cs
using System.Collections.Concurrent;
using System.Security.Cryptography;
using System.Text;
using System.Text.Json;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;

namespace SeniorIntern.Services;

/// <summary>
/// Service for managing file backups to support undo operations.
/// </summary>
public sealed class BackupService : IBackupService, IDisposable
{
    private readonly ILogger<BackupService>? _logger;
    private readonly BackupOptions _options;
    private readonly string _backupDirectory;
    private readonly Timer? _cleanupTimer;
    private readonly object _cleanupLock = new();

    // Constants for file naming
    private const string BackupExtension = ".backup";
    private const string MetadataExtension = ".meta";
    private const int MetadataVersion = 1;

    // Cache for path hashes to avoid recomputation
    private readonly ConcurrentDictionary<string, string> _pathHashCache = new();

    /// <inheritdoc />
    public string BackupDirectory => _backupDirectory;

    /// <summary>
    /// Initializes a new instance of the BackupService.
    /// </summary>
    /// <param name="logger">Optional logger for diagnostics.</param>
    /// <param name="options">Backup configuration options.</param>
    public BackupService(
        ILogger<BackupService>? logger = null,
        BackupOptions? options = null)
    {
        _logger = logger;
        _options = options ?? BackupOptions.Default;
        _backupDirectory = _options.CustomBackupDirectory ?? GetDefaultBackupDirectory();

        // Ensure backup directory exists
        Directory.CreateDirectory(_backupDirectory);
        _logger?.LogDebug("Backup directory: {BackupDirectory}", _backupDirectory);

        // Set up automatic cleanup if configured
        if (_options.AutoCleanup)
        {
            _cleanupTimer = new Timer(
                OnCleanupTimer,
                null,
                _options.AutoCleanupInterval,
                _options.AutoCleanupInterval);
        }
    }

    #region Backup Operations

    /// <inheritdoc />
    public async Task<string> CreateBackupAsync(string filePath, CancellationToken ct = default)
    {
        if (string.IsNullOrEmpty(filePath))
            throw new ArgumentException("File path cannot be empty", nameof(filePath));

        if (!File.Exists(filePath))
            throw new FileNotFoundException("File to backup not found", filePath);

        // Compute content hash if configured
        string? contentHash = null;
        if (_options.ComputeContentHash)
        {
            var content = await File.ReadAllBytesAsync(filePath, ct);
            contentHash = ComputeContentHash(content);
        }

        return await CreateBackupInternalAsync(filePath, contentHash, ct);
    }

    /// <inheritdoc />
    public async Task<string> CreateBackupWithHashAsync(
        string filePath,
        string contentHash,
        CancellationToken ct = default)
    {
        if (string.IsNullOrEmpty(filePath))
            throw new ArgumentException("File path cannot be empty", nameof(filePath));

        if (!File.Exists(filePath))
            throw new FileNotFoundException("File to backup not found", filePath);

        return await CreateBackupInternalAsync(filePath, contentHash, ct);
    }

    /// <inheritdoc />
    public async Task<string?> CreateIncrementalBackupAsync(
        string filePath,
        CancellationToken ct = default)
    {
        if (string.IsNullOrEmpty(filePath))
            throw new ArgumentException("File path cannot be empty", nameof(filePath));

        if (!File.Exists(filePath))
            throw new FileNotFoundException("File to backup not found", filePath);

        // Compute current content hash
        var content = await File.ReadAllBytesAsync(filePath, ct);
        var currentHash = ComputeContentHash(content);

        // Check if latest backup has same hash
        var existingBackups = GetBackupsForFile(filePath);
        if (existingBackups.Count > 0)
        {
            var latestBackup = existingBackups[0]; // Already sorted newest first
            if (latestBackup.ContentHash == currentHash)
            {
                _logger?.LogDebug(
                    "Skipping backup for {FilePath} - content unchanged",
                    filePath);
                return latestBackup.BackupPath;
            }
        }

        // Content changed, create new backup
        return await CreateBackupInternalAsync(filePath, currentHash, ct);
    }

    private async Task<string> CreateBackupInternalAsync(
        string filePath,
        string? contentHash,
        CancellationToken ct)
    {
        var fileName = Path.GetFileName(filePath);
        var fileExt = Path.GetExtension(filePath);
        var baseName = Path.GetFileNameWithoutExtension(filePath);
        var timestamp = DateTime.UtcNow.ToString("yyyyMMdd_HHmmss_fff");
        var pathHash = GetPathHash(filePath);

        // Build backup filename: {basename}_{timestamp}_{pathhash}{ext}.backup
        var backupName = $"{baseName}_{timestamp}_{pathHash}{fileExt}{BackupExtension}";
        var backupPath = Path.Combine(_backupDirectory, backupName);

        try
        {
            // Copy the file
            await Task.Run(() => File.Copy(filePath, backupPath, overwrite: true), ct);

            // Get file info for metadata
            var sourceInfo = new FileInfo(filePath);

            // Create and save metadata
            var metadata = new BackupMetadata
            {
                Version = MetadataVersion,
                OriginalPath = filePath,
                CreatedAt = DateTime.UtcNow,
                OriginalSize = sourceInfo.Length,
                ContentHash = contentHash,
                OriginalLastModified = sourceInfo.LastWriteTimeUtc
            };

            var metaPath = backupPath + MetadataExtension;
            var metaJson = JsonSerializer.Serialize(metadata, new JsonSerializerOptions
            {
                WriteIndented = true
            });
            await File.WriteAllTextAsync(metaPath, metaJson, ct);

            _logger?.LogDebug(
                "Created backup: {BackupPath} for {OriginalPath}",
                backupPath, filePath);

            // Verify if configured
            if (_options.VerifyAfterCreate)
            {
                var isValid = await VerifyBackupIntegrityAsync(backupPath, ct);
                if (!isValid)
                {
                    _logger?.LogWarning(
                        "Backup verification failed for {BackupPath}",
                        backupPath);
                }
            }

            // Trigger auto-cleanup if configured
            if (_options.AutoCleanup)
            {
                _ = Task.Run(() => RunCleanupAsync(ct), ct);
            }

            return backupPath;
        }
        catch (Exception ex)
        {
            _logger?.LogError(ex, "Failed to create backup for {FilePath}", filePath);

            // Clean up partial backup
            try
            {
                if (File.Exists(backupPath))
                    File.Delete(backupPath);
                var metaPath = backupPath + MetadataExtension;
                if (File.Exists(metaPath))
                    File.Delete(metaPath);
            }
            catch { /* Ignore cleanup errors */ }

            throw;
        }
    }

    #endregion

    #region Restore Operations

    /// <inheritdoc />
    public async Task<bool> RestoreBackupAsync(
        string backupPath,
        string targetPath,
        CancellationToken ct = default)
    {
        if (string.IsNullOrEmpty(backupPath))
        {
            _logger?.LogWarning("Restore failed: backup path is empty");
            return false;
        }

        if (!File.Exists(backupPath))
        {
            _logger?.LogWarning("Backup file not found: {BackupPath}", backupPath);
            return false;
        }

        try
        {
            // Ensure target directory exists
            var targetDir = Path.GetDirectoryName(targetPath);
            if (!string.IsNullOrEmpty(targetDir) && !Directory.Exists(targetDir))
            {
                Directory.CreateDirectory(targetDir);
            }

            // Copy backup to target
            await Task.Run(() => File.Copy(backupPath, targetPath, overwrite: true), ct);

            _logger?.LogInformation(
                "Restored backup {BackupPath} to {TargetPath}",
                backupPath, targetPath);

            return true;
        }
        catch (Exception ex)
        {
            _logger?.LogError(
                ex,
                "Failed to restore backup {BackupPath} to {TargetPath}",
                backupPath, targetPath);
            return false;
        }
    }

    /// <inheritdoc />
    public async Task<bool> RestoreLatestBackupAsync(
        string originalPath,
        CancellationToken ct = default)
    {
        var backups = GetBackupsForFile(originalPath);
        if (backups.Count == 0)
        {
            _logger?.LogWarning("No backups found for {OriginalPath}", originalPath);
            return false;
        }

        var latestBackup = backups[0]; // Already sorted newest first
        return await RestoreBackupAsync(latestBackup.BackupPath, originalPath, ct);
    }

    #endregion

    #region Delete Operations

    /// <inheritdoc />
    public async Task<bool> DeleteBackupAsync(string backupPath, CancellationToken ct = default)
    {
        if (string.IsNullOrEmpty(backupPath))
            return false;

        try
        {
            await Task.Run(() =>
            {
                // Delete backup file
                if (File.Exists(backupPath))
                    File.Delete(backupPath);

                // Delete metadata file
                var metaPath = backupPath + MetadataExtension;
                if (File.Exists(metaPath))
                    File.Delete(metaPath);
            }, ct);

            _logger?.LogDebug("Deleted backup: {BackupPath}", backupPath);
            return true;
        }
        catch (Exception ex)
        {
            _logger?.LogWarning(ex, "Failed to delete backup: {BackupPath}", backupPath);
            return false;
        }
    }

    /// <inheritdoc />
    public async Task<int> DeleteAllBackupsForFileAsync(
        string originalPath,
        CancellationToken ct = default)
    {
        var backups = GetBackupsForFile(originalPath);
        var deleted = 0;

        foreach (var backup in backups)
        {
            ct.ThrowIfCancellationRequested();
            if (await DeleteBackupAsync(backup.BackupPath, ct))
                deleted++;
        }

        _logger?.LogInformation(
            "Deleted {Count} backup(s) for {OriginalPath}",
            deleted, originalPath);

        return deleted;
    }

    #endregion

    #region Query Operations

    /// <inheritdoc />
    public IReadOnlyList<BackupInfo> GetBackupsForFile(string originalPath)
    {
        if (string.IsNullOrEmpty(originalPath))
            return Array.Empty<BackupInfo>();

        var pathHash = GetPathHash(originalPath);
        var backups = new List<BackupInfo>();

        try
        {
            // Find all backups matching the path hash
            var pattern = $"*_{pathHash}*{BackupExtension}";
            foreach (var file in Directory.EnumerateFiles(_backupDirectory, pattern))
            {
                var info = LoadBackupInfo(file);
                if (info != null)
                {
                    backups.Add(info);
                }
            }
        }
        catch (Exception ex)
        {
            _logger?.LogWarning(ex, "Error enumerating backups for {OriginalPath}", originalPath);
        }

        // Sort by creation time, newest first
        return backups.OrderByDescending(b => b.CreatedAt).ToList();
    }

    /// <inheritdoc />
    public IReadOnlyList<BackupInfo> GetAllBackups()
    {
        var backups = new List<BackupInfo>();

        try
        {
            foreach (var file in Directory.EnumerateFiles(_backupDirectory, $"*{BackupExtension}"))
            {
                // Skip metadata files
                if (file.EndsWith(MetadataExtension))
                    continue;

                var info = LoadBackupInfo(file);
                if (info != null)
                {
                    backups.Add(info);
                }
            }
        }
        catch (Exception ex)
        {
            _logger?.LogWarning(ex, "Error enumerating all backups");
        }

        return backups.OrderByDescending(b => b.CreatedAt).ToList();
    }

    /// <inheritdoc />
    public BackupInfo? GetBackupInfo(string backupPath)
    {
        if (string.IsNullOrEmpty(backupPath) || !File.Exists(backupPath))
            return null;

        return LoadBackupInfo(backupPath);
    }

    /// <inheritdoc />
    public Task<bool> BackupExistsAsync(string originalPath, CancellationToken ct = default)
    {
        var backups = GetBackupsForFile(originalPath);
        return Task.FromResult(backups.Count > 0);
    }

    private BackupInfo? LoadBackupInfo(string backupPath)
    {
        try
        {
            var fileInfo = new FileInfo(backupPath);
            var metaPath = backupPath + MetadataExtension;
            BackupMetadata? metadata = null;

            // Try to load metadata
            if (File.Exists(metaPath))
            {
                try
                {
                    var json = File.ReadAllText(metaPath);
                    metadata = JsonSerializer.Deserialize<BackupMetadata>(json);
                }
                catch (Exception ex)
                {
                    _logger?.LogDebug(ex, "Failed to parse metadata for {BackupPath}", backupPath);
                }
            }

            return new BackupInfo
            {
                BackupPath = backupPath,
                OriginalPath = metadata?.OriginalPath ?? ExtractOriginalPathFromName(backupPath),
                CreatedAt = metadata?.CreatedAt ?? fileInfo.CreationTimeUtc,
                SizeBytes = fileInfo.Length,
                ContentHash = metadata?.ContentHash,
                IsVerified = false,
                WorkspacePath = metadata?.WorkspacePath,
                OriginalLastModified = metadata?.OriginalLastModified
            };
        }
        catch (Exception ex)
        {
            _logger?.LogWarning(ex, "Failed to load backup info for {BackupPath}", backupPath);
            return null;
        }
    }

    private static string ExtractOriginalPathFromName(string backupPath)
    {
        // Fallback: extract filename from backup name
        // Format: {basename}_{timestamp}_{hash}{ext}.backup
        var fileName = Path.GetFileName(backupPath);
        var parts = fileName.Split('_');
        if (parts.Length >= 1)
        {
            return parts[0]; // Just the base name
        }
        return fileName;
    }

    #endregion

    #region Cleanup Operations

    /// <inheritdoc />
    public async Task<int> CleanupOldBackupsAsync(TimeSpan maxAge, CancellationToken ct = default)
    {
        var cutoff = DateTime.UtcNow - maxAge;
        var deleted = 0;

        await Task.Run(() =>
        {
            lock (_cleanupLock)
            {
                foreach (var file in Directory.EnumerateFiles(_backupDirectory, $"*{BackupExtension}"))
                {
                    if (file.EndsWith(MetadataExtension))
                        continue;

                    ct.ThrowIfCancellationRequested();

                    var fileInfo = new FileInfo(file);
                    if (fileInfo.CreationTimeUtc < cutoff)
                    {
                        try
                        {
                            File.Delete(file);
                            var metaPath = file + MetadataExtension;
                            if (File.Exists(metaPath))
                                File.Delete(metaPath);
                            deleted++;
                        }
                        catch (Exception ex)
                        {
                            _logger?.LogDebug(ex, "Failed to delete old backup: {File}", file);
                        }
                    }
                }
            }
        }, ct);

        _logger?.LogInformation("Cleaned up {Count} old backup(s)", deleted);
        return deleted;
    }

    /// <inheritdoc />
    public async Task<int> CleanupByStorageLimitAsync(
        long maxStorageBytes,
        CancellationToken ct = default)
    {
        var allBackups = GetAllBackups();
        var totalSize = allBackups.Sum(b => b.SizeBytes);
        var deleted = 0;

        if (totalSize <= maxStorageBytes)
            return 0;

        // Sort by age (oldest first) for deletion
        var sortedByAge = allBackups.OrderBy(b => b.CreatedAt).ToList();

        foreach (var backup in sortedByAge)
        {
            ct.ThrowIfCancellationRequested();

            if (totalSize <= maxStorageBytes)
                break;

            if (await DeleteBackupAsync(backup.BackupPath, ct))
            {
                totalSize -= backup.SizeBytes;
                deleted++;
            }
        }

        _logger?.LogInformation(
            "Cleaned up {Count} backup(s) to meet storage limit of {Limit}",
            deleted, FormatBytes(maxStorageBytes));

        return deleted;
    }

    /// <inheritdoc />
    public async Task<int> CleanupOrphanedBackupsAsync(CancellationToken ct = default)
    {
        var deleted = 0;

        await Task.Run(() =>
        {
            lock (_cleanupLock)
            {
                foreach (var file in Directory.EnumerateFiles(_backupDirectory, $"*{BackupExtension}"))
                {
                    if (file.EndsWith(MetadataExtension))
                        continue;

                    ct.ThrowIfCancellationRequested();

                    var metaPath = file + MetadataExtension;
                    var isOrphaned = false;

                    if (!File.Exists(metaPath))
                    {
                        isOrphaned = true;
                    }
                    else
                    {
                        // Try to parse metadata
                        try
                        {
                            var json = File.ReadAllText(metaPath);
                            var metadata = JsonSerializer.Deserialize<BackupMetadata>(json);
                            if (metadata == null || string.IsNullOrEmpty(metadata.OriginalPath))
                            {
                                isOrphaned = true;
                            }
                        }
                        catch
                        {
                            isOrphaned = true;
                        }
                    }

                    if (isOrphaned)
                    {
                        try
                        {
                            File.Delete(file);
                            if (File.Exists(metaPath))
                                File.Delete(metaPath);
                            deleted++;
                            _logger?.LogDebug("Deleted orphaned backup: {File}", file);
                        }
                        catch (Exception ex)
                        {
                            _logger?.LogDebug(ex, "Failed to delete orphaned backup: {File}", file);
                        }
                    }
                }
            }
        }, ct);

        _logger?.LogInformation("Cleaned up {Count} orphaned backup(s)", deleted);
        return deleted;
    }

    /// <inheritdoc />
    public async Task<int> CleanupExcessBackupsAsync(
        int maxBackupsPerFile,
        CancellationToken ct = default)
    {
        var allBackups = GetAllBackups();
        var deleted = 0;

        // Group by original path
        var grouped = allBackups
            .GroupBy(b => b.OriginalPath.ToLowerInvariant())
            .ToList();

        foreach (var group in grouped)
        {
            ct.ThrowIfCancellationRequested();

            var backupsForFile = group.OrderByDescending(b => b.CreatedAt).ToList();
            if (backupsForFile.Count <= maxBackupsPerFile)
                continue;

            // Delete oldest backups beyond limit
            var toDelete = backupsForFile.Skip(maxBackupsPerFile);
            foreach (var backup in toDelete)
            {
                if (await DeleteBackupAsync(backup.BackupPath, ct))
                    deleted++;
            }
        }

        _logger?.LogInformation(
            "Cleaned up {Count} excess backup(s) (limit: {Limit} per file)",
            deleted, maxBackupsPerFile);

        return deleted;
    }

    private async Task RunCleanupAsync(CancellationToken ct = default)
    {
        try
        {
            await CleanupOldBackupsAsync(_options.MaxBackupAge, ct);
            await CleanupByStorageLimitAsync(_options.MaxTotalStorageBytes, ct);
            await CleanupExcessBackupsAsync(_options.MaxBackupsPerFile, ct);
        }
        catch (Exception ex)
        {
            _logger?.LogWarning(ex, "Error during backup cleanup");
        }
    }

    private void OnCleanupTimer(object? state)
    {
        _ = RunCleanupAsync();
    }

    #endregion

    #region Storage Operations

    /// <inheritdoc />
    public long GetTotalBackupSize()
    {
        try
        {
            return Directory.EnumerateFiles(_backupDirectory, $"*{BackupExtension}")
                .Where(f => !f.EndsWith(MetadataExtension))
                .Sum(f => new FileInfo(f).Length);
        }
        catch (Exception ex)
        {
            _logger?.LogWarning(ex, "Error calculating total backup size");
            return 0;
        }
    }

    /// <inheritdoc />
    public BackupStorageInfo GetStorageInfo()
    {
        var allBackups = GetAllBackups();
        var orphanedCount = 0;

        // Count orphaned backups
        foreach (var file in Directory.EnumerateFiles(_backupDirectory, $"*{BackupExtension}"))
        {
            if (file.EndsWith(MetadataExtension))
                continue;

            var metaPath = file + MetadataExtension;
            if (!File.Exists(metaPath))
                orphanedCount++;
        }

        // Get disk space info
        long availableSpace = 0;
        try
        {
            var driveInfo = new DriveInfo(Path.GetPathRoot(_backupDirectory) ?? "C:");
            availableSpace = driveInfo.AvailableFreeSpace;
        }
        catch { /* Ignore */ }

        // Determine health status
        var totalSize = allBackups.Sum(b => b.SizeBytes);
        var healthStatus = BackupHealthStatus.Healthy;

        if (availableSpace > 0 && availableSpace < 100 * 1024 * 1024) // < 100 MB free
            healthStatus = BackupHealthStatus.Critical;
        else if (orphanedCount > allBackups.Count * 0.1) // > 10% orphaned
            healthStatus = BackupHealthStatus.Warning;
        else if (totalSize > _options.MaxTotalStorageBytes * 0.9) // > 90% of limit
            healthStatus = BackupHealthStatus.Warning;

        return new BackupStorageInfo
        {
            TotalSizeBytes = totalSize,
            BackupCount = allBackups.Count,
            UniqueFilesCount = allBackups.Select(b => b.OriginalPath.ToLowerInvariant()).Distinct().Count(),
            OldestBackup = allBackups.Count > 0 ? allBackups.Min(b => b.CreatedAt) : null,
            NewestBackup = allBackups.Count > 0 ? allBackups.Max(b => b.CreatedAt) : null,
            OrphanedCount = orphanedCount,
            CorruptedCount = 0, // Would require integrity check
            HealthStatus = healthStatus,
            BackupDirectory = _backupDirectory,
            AvailableDiskSpaceBytes = availableSpace
        };
    }

    #endregion

    #region Integrity Operations

    /// <inheritdoc />
    public async Task<bool> VerifyBackupIntegrityAsync(
        string backupPath,
        CancellationToken ct = default)
    {
        if (!File.Exists(backupPath))
            return false;

        var metaPath = backupPath + MetadataExtension;
        if (!File.Exists(metaPath))
        {
            _logger?.LogDebug("No metadata for backup: {BackupPath}", backupPath);
            return false; // Can't verify without metadata
        }

        try
        {
            // Load metadata
            var json = await File.ReadAllTextAsync(metaPath, ct);
            var metadata = JsonSerializer.Deserialize<BackupMetadata>(json);

            if (metadata?.ContentHash == null)
            {
                _logger?.LogDebug("No content hash in metadata: {BackupPath}", backupPath);
                return true; // Can't verify hash, assume OK
            }

            // Compute current hash of backup file
            var content = await File.ReadAllBytesAsync(backupPath, ct);
            var currentHash = ComputeContentHash(content);

            var isValid = currentHash == metadata.ContentHash;
            if (!isValid)
            {
                _logger?.LogWarning(
                    "Backup integrity check failed: {BackupPath} (expected: {Expected}, actual: {Actual})",
                    backupPath, metadata.ContentHash, currentHash);
            }

            return isValid;
        }
        catch (Exception ex)
        {
            _logger?.LogError(ex, "Error verifying backup integrity: {BackupPath}", backupPath);
            return false;
        }
    }

    /// <inheritdoc />
    public async Task<IReadOnlyList<string>> VerifyAllBackupsAsync(CancellationToken ct = default)
    {
        var corrupted = new List<string>();
        var allBackups = GetAllBackups();

        foreach (var backup in allBackups)
        {
            ct.ThrowIfCancellationRequested();

            if (!await VerifyBackupIntegrityAsync(backup.BackupPath, ct))
            {
                corrupted.Add(backup.BackupPath);
            }
        }

        _logger?.LogInformation(
            "Verified {Total} backups, {Corrupted} corrupted",
            allBackups.Count, corrupted.Count);

        return corrupted;
    }

    #endregion

    #region Helper Methods

    /// <summary>
    /// Gets the default backup directory path.
    /// </summary>
    private static string GetDefaultBackupDirectory()
    {
        var appData = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
        return Path.Combine(appData, "SeniorIntern", "backups");
    }

    /// <summary>
    /// Computes path hash for file grouping.
    /// </summary>
    private string GetPathHash(string path)
    {
        return _pathHashCache.GetOrAdd(path.ToLowerInvariant(), p =>
        {
            using var md5 = MD5.Create();
            var bytes = Encoding.UTF8.GetBytes(p);
            var hash = md5.ComputeHash(bytes);
            return Convert.ToHexString(hash)[..8];
        });
    }

    /// <summary>
    /// Computes SHA-256 hash of content.
    /// </summary>
    private static string ComputeContentHash(byte[] content)
    {
        using var sha256 = SHA256.Create();
        var hash = sha256.ComputeHash(content);
        return "sha256:" + Convert.ToHexString(hash).ToLowerInvariant();
    }

    /// <summary>
    /// Formats bytes as human-readable string.
    /// </summary>
    private static string FormatBytes(long bytes)
    {
        string[] sizes = { "B", "KB", "MB", "GB", "TB" };
        int order = 0;
        double size = bytes;
        while (size >= 1024 && order < sizes.Length - 1)
        {
            order++;
            size /= 1024;
        }
        return $"{size:0.##} {sizes[order]}";
    }

    /// <inheritdoc />
    public void Dispose()
    {
        _cleanupTimer?.Dispose();
    }

    #endregion

    #region Internal Classes

    /// <summary>
    /// Metadata stored alongside each backup file.
    /// </summary>
    private sealed class BackupMetadata
    {
        public int Version { get; set; } = MetadataVersion;
        public string OriginalPath { get; set; } = string.Empty;
        public string? WorkspacePath { get; set; }
        public DateTime CreatedAt { get; set; }
        public long OriginalSize { get; set; }
        public string? ContentHash { get; set; }
        public DateTime? OriginalLastModified { get; set; }
    }

    #endregion
}
```

### Dependency Injection Registration

```csharp
// src/SeniorIntern.Desktop/Extensions/ServiceCollectionExtensions.cs
using Microsoft.Extensions.DependencyInjection;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Services;

namespace SeniorIntern.Desktop.Extensions;

public static partial class ServiceCollectionExtensions
{
    /// <summary>
    /// Registers backup services with default options.
    /// </summary>
    public static IServiceCollection AddBackupServices(this IServiceCollection services)
    {
        return AddBackupServices(services, BackupOptions.Default);
    }

    /// <summary>
    /// Registers backup services with custom options.
    /// </summary>
    public static IServiceCollection AddBackupServices(
        this IServiceCollection services,
        BackupOptions options)
    {
        services.AddSingleton(options);
        services.AddSingleton<IBackupService, BackupService>();

        return services;
    }
}
```

---

## Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/IBackupService.cs` | Backup service interface |
| `src/SeniorIntern.Core/Models/BackupInfo.cs` | Backup information model |
| `src/SeniorIntern.Core/Models/BackupOptions.cs` | Configuration options |
| `src/SeniorIntern.Core/Models/BackupStorageInfo.cs` | Storage statistics model |
| `src/SeniorIntern.Services/BackupService.cs` | Backup service implementation |

## Files to Modify

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/Extensions/ServiceCollectionExtensions.cs` | Register backup services |

---

## Testing Strategy

### Unit Tests

```csharp
// tests/SeniorIntern.Services.Tests/BackupServiceTests.cs
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Services;
using Xunit;

namespace SeniorIntern.Services.Tests;

public class BackupServiceTests : IDisposable
{
    private readonly string _testDirectory;
    private readonly string _backupDirectory;
    private readonly BackupService _service;

    public BackupServiceTests()
    {
        _testDirectory = Path.Combine(Path.GetTempPath(), $"BackupTest_{Guid.NewGuid()}");
        _backupDirectory = Path.Combine(_testDirectory, "backups");
        Directory.CreateDirectory(_testDirectory);

        var options = new BackupOptions
        {
            CustomBackupDirectory = _backupDirectory,
            MaxBackupsPerFile = 5,
            MaxBackupAge = TimeSpan.FromHours(1),
            ComputeContentHash = true
        };

        _service = new BackupService(options: options);
    }

    public void Dispose()
    {
        _service.Dispose();
        if (Directory.Exists(_testDirectory))
        {
            Directory.Delete(_testDirectory, recursive: true);
        }
    }

    #region CreateBackupAsync Tests

    [Fact]
    public async Task CreateBackupAsync_ValidFile_CreatesBackup()
    {
        // Arrange
        var sourcePath = CreateTestFile("source.cs", "public class Test {}");

        // Act
        var backupPath = await _service.CreateBackupAsync(sourcePath);

        // Assert
        Assert.True(File.Exists(backupPath));
        Assert.Equal("public class Test {}", await File.ReadAllTextAsync(backupPath));
    }

    [Fact]
    public async Task CreateBackupAsync_ValidFile_CreatesMetadata()
    {
        // Arrange
        var sourcePath = CreateTestFile("source.cs", "content");

        // Act
        var backupPath = await _service.CreateBackupAsync(sourcePath);

        // Assert
        var metaPath = backupPath + ".meta";
        Assert.True(File.Exists(metaPath));

        var metaJson = await File.ReadAllTextAsync(metaPath);
        Assert.Contains(sourcePath, metaJson);
    }

    [Fact]
    public async Task CreateBackupAsync_FileNotFound_ThrowsException()
    {
        // Arrange
        var nonExistentPath = Path.Combine(_testDirectory, "nonexistent.cs");

        // Act & Assert
        await Assert.ThrowsAsync<FileNotFoundException>(
            () => _service.CreateBackupAsync(nonExistentPath));
    }

    [Fact]
    public async Task CreateBackupAsync_EmptyPath_ThrowsArgumentException()
    {
        // Act & Assert
        await Assert.ThrowsAsync<ArgumentException>(
            () => _service.CreateBackupAsync(string.Empty));
    }

    [Fact]
    public async Task CreateBackupAsync_MultipleBackups_CreatesUniqueNames()
    {
        // Arrange
        var sourcePath = CreateTestFile("source.cs", "content");

        // Act
        var backup1 = await _service.CreateBackupAsync(sourcePath);
        await Task.Delay(10); // Ensure different timestamp
        var backup2 = await _service.CreateBackupAsync(sourcePath);

        // Assert
        Assert.NotEqual(backup1, backup2);
        Assert.True(File.Exists(backup1));
        Assert.True(File.Exists(backup2));
    }

    #endregion

    #region CreateIncrementalBackupAsync Tests

    [Fact]
    public async Task CreateIncrementalBackupAsync_NewFile_CreatesBackup()
    {
        // Arrange
        var sourcePath = CreateTestFile("source.cs", "content");

        // Act
        var backupPath = await _service.CreateIncrementalBackupAsync(sourcePath);

        // Assert
        Assert.NotNull(backupPath);
        Assert.True(File.Exists(backupPath));
    }

    [Fact]
    public async Task CreateIncrementalBackupAsync_UnchangedContent_ReturnsExistingBackup()
    {
        // Arrange
        var sourcePath = CreateTestFile("source.cs", "content");
        var firstBackup = await _service.CreateBackupAsync(sourcePath);

        // Act
        var secondBackup = await _service.CreateIncrementalBackupAsync(sourcePath);

        // Assert
        Assert.Equal(firstBackup, secondBackup);
    }

    [Fact]
    public async Task CreateIncrementalBackupAsync_ChangedContent_CreatesNewBackup()
    {
        // Arrange
        var sourcePath = CreateTestFile("source.cs", "original content");
        var firstBackup = await _service.CreateBackupAsync(sourcePath);

        // Modify the file
        await File.WriteAllTextAsync(sourcePath, "modified content");

        // Act
        var secondBackup = await _service.CreateIncrementalBackupAsync(sourcePath);

        // Assert
        Assert.NotEqual(firstBackup, secondBackup);
        Assert.Equal("modified content", await File.ReadAllTextAsync(secondBackup!));
    }

    #endregion

    #region RestoreBackupAsync Tests

    [Fact]
    public async Task RestoreBackupAsync_ValidBackup_RestoresFile()
    {
        // Arrange
        var sourcePath = CreateTestFile("source.cs", "original");
        var backupPath = await _service.CreateBackupAsync(sourcePath);
        await File.WriteAllTextAsync(sourcePath, "modified"); // Modify original

        // Act
        var result = await _service.RestoreBackupAsync(backupPath, sourcePath);

        // Assert
        Assert.True(result);
        Assert.Equal("original", await File.ReadAllTextAsync(sourcePath));
    }

    [Fact]
    public async Task RestoreBackupAsync_NonExistentBackup_ReturnsFalse()
    {
        // Arrange
        var targetPath = Path.Combine(_testDirectory, "target.cs");

        // Act
        var result = await _service.RestoreBackupAsync("/nonexistent/backup.backup", targetPath);

        // Assert
        Assert.False(result);
    }

    [Fact]
    public async Task RestoreLatestBackupAsync_MultipleBackups_RestoresNewest()
    {
        // Arrange
        var sourcePath = CreateTestFile("source.cs", "version1");
        await _service.CreateBackupAsync(sourcePath);

        await File.WriteAllTextAsync(sourcePath, "version2");
        await Task.Delay(10);
        await _service.CreateBackupAsync(sourcePath);

        await File.WriteAllTextAsync(sourcePath, "current");

        // Act
        var result = await _service.RestoreLatestBackupAsync(sourcePath);

        // Assert
        Assert.True(result);
        Assert.Equal("version2", await File.ReadAllTextAsync(sourcePath));
    }

    #endregion

    #region DeleteBackupAsync Tests

    [Fact]
    public async Task DeleteBackupAsync_ExistingBackup_DeletesBothFiles()
    {
        // Arrange
        var sourcePath = CreateTestFile("source.cs", "content");
        var backupPath = await _service.CreateBackupAsync(sourcePath);
        var metaPath = backupPath + ".meta";

        // Act
        var result = await _service.DeleteBackupAsync(backupPath);

        // Assert
        Assert.True(result);
        Assert.False(File.Exists(backupPath));
        Assert.False(File.Exists(metaPath));
    }

    [Fact]
    public async Task DeleteAllBackupsForFileAsync_MultipleBackups_DeletesAll()
    {
        // Arrange
        var sourcePath = CreateTestFile("source.cs", "content");
        await _service.CreateBackupAsync(sourcePath);
        await Task.Delay(10);
        await _service.CreateBackupAsync(sourcePath);
        await Task.Delay(10);
        await _service.CreateBackupAsync(sourcePath);

        // Act
        var deleted = await _service.DeleteAllBackupsForFileAsync(sourcePath);

        // Assert
        Assert.Equal(3, deleted);
        Assert.Empty(_service.GetBackupsForFile(sourcePath));
    }

    #endregion

    #region GetBackupsForFile Tests

    [Fact]
    public async Task GetBackupsForFile_MultipleBackups_ReturnsInOrder()
    {
        // Arrange
        var sourcePath = CreateTestFile("source.cs", "content");
        await _service.CreateBackupAsync(sourcePath);
        await Task.Delay(10);
        await _service.CreateBackupAsync(sourcePath);
        await Task.Delay(10);
        var latestBackup = await _service.CreateBackupAsync(sourcePath);

        // Act
        var backups = _service.GetBackupsForFile(sourcePath);

        // Assert
        Assert.Equal(3, backups.Count);
        Assert.Equal(latestBackup, backups[0].BackupPath); // Newest first
    }

    [Fact]
    public void GetBackupsForFile_NoBackups_ReturnsEmpty()
    {
        // Act
        var backups = _service.GetBackupsForFile("/nonexistent/file.cs");

        // Assert
        Assert.Empty(backups);
    }

    #endregion

    #region Cleanup Tests

    [Fact]
    public async Task CleanupOldBackupsAsync_OldBackups_DeletesThem()
    {
        // Arrange
        var sourcePath = CreateTestFile("source.cs", "content");
        var backupPath = await _service.CreateBackupAsync(sourcePath);

        // Manually set creation time to past
        File.SetCreationTimeUtc(backupPath, DateTime.UtcNow.AddDays(-10));

        // Act
        var deleted = await _service.CleanupOldBackupsAsync(TimeSpan.FromDays(7));

        // Assert
        Assert.Equal(1, deleted);
        Assert.False(File.Exists(backupPath));
    }

    [Fact]
    public async Task CleanupExcessBackupsAsync_TooManyBackups_DeletesOldest()
    {
        // Arrange
        var sourcePath = CreateTestFile("source.cs", "content");
        for (int i = 0; i < 10; i++)
        {
            await _service.CreateBackupAsync(sourcePath);
            await Task.Delay(10);
        }

        // Act
        var deleted = await _service.CleanupExcessBackupsAsync(maxBackupsPerFile: 3);

        // Assert
        Assert.Equal(7, deleted);
        Assert.Equal(3, _service.GetBackupsForFile(sourcePath).Count);
    }

    [Fact]
    public async Task CleanupByStorageLimitAsync_OverLimit_DeletesUntilUnder()
    {
        // Arrange
        var sourcePath = CreateTestFile("source.cs", new string('x', 1000));
        for (int i = 0; i < 10; i++)
        {
            await _service.CreateBackupAsync(sourcePath);
            await Task.Delay(10);
        }

        // Act - Set limit to roughly fit 5 backups
        var deleted = await _service.CleanupByStorageLimitAsync(5 * 1100);

        // Assert
        Assert.True(deleted > 0);
        Assert.True(_service.GetTotalBackupSize() <= 5 * 1100);
    }

    #endregion

    #region Integrity Tests

    [Fact]
    public async Task VerifyBackupIntegrityAsync_ValidBackup_ReturnsTrue()
    {
        // Arrange
        var sourcePath = CreateTestFile("source.cs", "content");
        var backupPath = await _service.CreateBackupAsync(sourcePath);

        // Act
        var isValid = await _service.VerifyBackupIntegrityAsync(backupPath);

        // Assert
        Assert.True(isValid);
    }

    [Fact]
    public async Task VerifyBackupIntegrityAsync_CorruptedBackup_ReturnsFalse()
    {
        // Arrange
        var sourcePath = CreateTestFile("source.cs", "original content");
        var backupPath = await _service.CreateBackupAsync(sourcePath);

        // Corrupt the backup
        await File.WriteAllTextAsync(backupPath, "corrupted content");

        // Act
        var isValid = await _service.VerifyBackupIntegrityAsync(backupPath);

        // Assert
        Assert.False(isValid);
    }

    #endregion

    #region Storage Info Tests

    [Fact]
    public async Task GetStorageInfo_WithBackups_ReturnsCorrectInfo()
    {
        // Arrange
        var sourcePath = CreateTestFile("source.cs", "content");
        await _service.CreateBackupAsync(sourcePath);
        await Task.Delay(10);
        await _service.CreateBackupAsync(sourcePath);

        // Act
        var info = _service.GetStorageInfo();

        // Assert
        Assert.Equal(2, info.BackupCount);
        Assert.Equal(1, info.UniqueFilesCount);
        Assert.True(info.TotalSizeBytes > 0);
        Assert.NotNull(info.OldestBackup);
        Assert.NotNull(info.NewestBackup);
    }

    [Fact]
    public void GetStorageInfo_EmptyBackupDir_ReturnsZeros()
    {
        // Act
        var info = _service.GetStorageInfo();

        // Assert
        Assert.Equal(0, info.BackupCount);
        Assert.Equal(0, info.TotalSizeBytes);
        Assert.Null(info.OldestBackup);
    }

    #endregion

    #region Helper Methods

    private string CreateTestFile(string name, string content)
    {
        var path = Path.Combine(_testDirectory, name);
        var dir = Path.GetDirectoryName(path);
        if (!string.IsNullOrEmpty(dir) && !Directory.Exists(dir))
            Directory.CreateDirectory(dir);
        File.WriteAllText(path, content);
        return path;
    }

    #endregion
}
```

### Integration Tests

```csharp
// tests/SeniorIntern.Services.Tests/BackupServiceIntegrationTests.cs
namespace SeniorIntern.Services.Tests;

public class BackupServiceIntegrationTests : IDisposable
{
    private readonly string _testDirectory;
    private readonly BackupService _service;

    public BackupServiceIntegrationTests()
    {
        _testDirectory = Path.Combine(Path.GetTempPath(), $"BackupIntegration_{Guid.NewGuid()}");
        Directory.CreateDirectory(_testDirectory);

        _service = new BackupService(options: new BackupOptions
        {
            CustomBackupDirectory = Path.Combine(_testDirectory, "backups")
        });
    }

    public void Dispose()
    {
        _service.Dispose();
        if (Directory.Exists(_testDirectory))
            Directory.Delete(_testDirectory, recursive: true);
    }

    [Fact]
    public async Task FullWorkflow_BackupModifyRestore()
    {
        // 1. Create original file
        var filePath = Path.Combine(_testDirectory, "test.cs");
        await File.WriteAllTextAsync(filePath, "original content");

        // 2. Create backup
        var backupPath = await _service.CreateBackupAsync(filePath);
        Assert.True(File.Exists(backupPath));

        // 3. Modify file
        await File.WriteAllTextAsync(filePath, "modified content");
        Assert.Equal("modified content", await File.ReadAllTextAsync(filePath));

        // 4. Restore from backup
        var restored = await _service.RestoreBackupAsync(backupPath, filePath);
        Assert.True(restored);
        Assert.Equal("original content", await File.ReadAllTextAsync(filePath));
    }

    [Fact]
    public async Task MultiFileWorkflow_IndependentBackups()
    {
        // Create multiple files
        var file1 = Path.Combine(_testDirectory, "file1.cs");
        var file2 = Path.Combine(_testDirectory, "file2.cs");
        await File.WriteAllTextAsync(file1, "content1");
        await File.WriteAllTextAsync(file2, "content2");

        // Backup both
        var backup1 = await _service.CreateBackupAsync(file1);
        var backup2 = await _service.CreateBackupAsync(file2);

        // Verify independent
        var backupsFor1 = _service.GetBackupsForFile(file1);
        var backupsFor2 = _service.GetBackupsForFile(file2);

        Assert.Single(backupsFor1);
        Assert.Single(backupsFor2);
        Assert.NotEqual(backupsFor1[0].BackupPath, backupsFor2[0].BackupPath);
    }
}
```

---

## Acceptance Criteria

### Functional Requirements

- [ ] `CreateBackupAsync` creates backup file with content
- [ ] `CreateBackupAsync` creates metadata file alongside backup
- [ ] `CreateBackupAsync` uses unique naming with timestamp and hash
- [ ] `CreateBackupWithHashAsync` accepts pre-computed hash
- [ ] `CreateIncrementalBackupAsync` skips backup if content unchanged
- [ ] `CreateIncrementalBackupAsync` creates backup if content changed
- [ ] `RestoreBackupAsync` restores file from backup
- [ ] `RestoreBackupAsync` creates parent directories if needed
- [ ] `RestoreLatestBackupAsync` restores most recent backup
- [ ] `DeleteBackupAsync` deletes both backup and metadata
- [ ] `DeleteAllBackupsForFileAsync` deletes all backups for a file
- [ ] `GetBackupsForFile` returns backups sorted newest first
- [ ] `GetAllBackups` returns all backup files
- [ ] `BackupExistsAsync` correctly detects backup presence

### Cleanup Requirements

- [ ] `CleanupOldBackupsAsync` deletes backups older than maxAge
- [ ] `CleanupByStorageLimitAsync` deletes oldest until under limit
- [ ] `CleanupExcessBackupsAsync` keeps only maxBackupsPerFile
- [ ] `CleanupOrphanedBackupsAsync` deletes backups with missing metadata
- [ ] Auto-cleanup runs on configured interval when enabled

### Storage Requirements

- [ ] `GetTotalBackupSize` returns accurate total
- [ ] `GetStorageInfo` returns complete statistics
- [ ] `GetStorageInfo` reports correct health status
- [ ] Backup directory created automatically if missing

### Integrity Requirements

- [ ] Content hash computed and stored in metadata
- [ ] `VerifyBackupIntegrityAsync` detects corruption
- [ ] `VerifyAllBackupsAsync` checks all backups
- [ ] Corrupted backups correctly identified

### Performance Requirements

- [ ] Path hash computation cached
- [ ] Large files backed up efficiently (streaming)
- [ ] Cleanup operations don't block main operations

---

## Design Decisions

### Decision 1: Path Hash for File Grouping

**Choice**: MD5 hash of lowercase path, first 8 characters

**Rationale**:
- Groups all backups for same file regardless of filename changes
- 8 characters (32 bits) provides sufficient uniqueness
- MD5 is fast and doesn't need cryptographic security here
- Case-insensitive for cross-platform compatibility

**Alternatives Considered**:
- Full path in filename: Too long, filesystem limits
- Incremental IDs: Requires persistent state
- Random UUID: No grouping capability

### Decision 2: Separate Metadata Files

**Choice**: JSON metadata in `.meta` file alongside backup

**Rationale**:
- Preserves original file exactly (byte-for-byte)
- Easy to inspect metadata manually
- Can be extended without breaking backups
- Orphan detection via missing metadata

**Alternatives Considered**:
- Embedded in backup file: Complicates restore
- Single index file: Single point of failure
- Database: Overkill for simple metadata

### Decision 3: SHA-256 for Content Hash

**Choice**: SHA-256 with "sha256:" prefix

**Rationale**:
- Cryptographically secure for integrity verification
- Industry standard, widely supported
- Prefix allows future algorithm changes
- Collision-resistant for deduplication

**Alternatives Considered**:
- MD5: Not secure enough for integrity
- CRC32: Too collision-prone
- xxHash: Less standard, not cryptographic

### Decision 4: Timestamp Format

**Choice**: `yyyyMMdd_HHmmss_fff` (UTC)

**Rationale**:
- Sorts correctly as string
- Milliseconds prevent collisions in rapid succession
- Human-readable in file listing
- UTC avoids timezone issues

**Alternatives Considered**:
- Unix timestamp: Less readable
- Ticks: Too long
- Local time: Timezone issues

### Decision 5: Default Storage Location

**Choice**: `%LocalAppData%/SeniorIntern/backups`

**Rationale**:
- Standard location for application data
- Per-user isolation
- Excluded from typical roaming
- Easy to find and clean up

**Alternatives Considered**:
- Temp directory: May be cleaned unexpectedly
- Project directory: Pollutes workspace
- Home directory: Too visible to users

### Decision 6: Auto-Cleanup Strategy

**Choice**: Optional, disabled by default, timer-based when enabled

**Rationale**:
- User control over when cleanup happens
- Background timer doesn't block operations
- Manual cleanup preferred for predictability
- Configurable interval

**Alternatives Considered**:
- Always auto-cleanup: May delete needed backups
- Cleanup on every create: Performance impact
- Startup cleanup only: May grow unbounded

---

## Dependencies

### Required Services

| Service | Interface | Purpose |
|---------|-----------|---------|
| Logger | `ILogger<BackupService>` | Diagnostic logging (optional) |

### NuGet Packages

| Package | Version | Purpose |
|---------|---------|---------|
| `Microsoft.Extensions.Logging.Abstractions` | 8.0+ | ILogger interface |
| `System.Text.Json` | 8.0+ | Metadata serialization |

---

## Future Considerations

1. **Compression**: GZIP or LZ4 compression for storage efficiency
2. **Encryption**: Encrypt backup files for security
3. **Remote storage**: Backup to cloud storage (Azure Blob, S3)
4. **Deduplication**: Content-addressed storage for identical content
5. **Differential backups**: Store only changes between versions
6. **Workspace-specific backups**: Organize by workspace subdirectories
7. **Backup scheduling**: Time-based backup creation (not just on-demand)
8. **Restore preview**: Show diff before restoring
