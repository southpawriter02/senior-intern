# Design Specification: The Senior Intern v0.4.2a "Diff Models"

**Status**: _IMPLEMENTED_

## Executive Summary

This document provides a comprehensive implementation specification for v0.4.2a, which defines the foundational data models for representing computed diffs between original file content and LLM-proposed changes. These models form the core data structures used throughout the diff visualization and application workflow.

### v0.4.2a Scope

- Create `DiffResult` model as the top-level container for diff computation results
- Create `DiffHunk` model for contiguous groups of changes
- Create `DiffLine` model for individual line-level differences
- Create `InlineChange` model for character-level changes within lines
- Create `DiffStats` record for summary statistics
- Define supporting enums: `DiffLineType`, `DiffSide`, `InlineChangeType`
- Implement computed properties and helper methods

### Key Deliverables

| Deliverable | Description |
|-------------|-------------|
| DiffResult | Top-level model containing complete diff computation output |
| DiffHunk | Grouped changes with hunk header and context |
| DiffLine | Single line with change type and optional inline changes |
| InlineChange | Character-level change span for modified lines |
| DiffStats | Summary statistics (added, removed, modified, unchanged) |
| DiffLineType | Enum for line change classification |
| DiffSide | Enum for side-by-side positioning |
| InlineChangeType | Enum for character-level change types |

---

## Prerequisites

Before implementing v0.4.2a, ensure:

- v0.4.1 (Code Block Extraction) is complete - provides CodeBlock model referenced by SourceBlockId
- .NET 8 with C# 12 features (primary constructors, records, init-only properties)

---

## Feature Overview

```
┌───────────────────────────────────────────────────────────────────────┐
│                     v0.4.2a Feature Tree                               │
├───────────────────────────────────────────────────────────────────────┤
│                                                                        │
│  DiffResult                                                            │
│  ├── Identity                                                          │
│  │   ├── Id (Guid) → unique identifier                                │
│  │   └── SourceBlockId (Guid?) → link to originating CodeBlock        │
│  │                                                                     │
│  ├── Content                                                           │
│  │   ├── OriginalFilePath → path to the file being modified           │
│  │   ├── OriginalContent → full text before changes                   │
│  │   └── ProposedContent → full text after changes                    │
│  │                                                                     │
│  ├── Change Data                                                       │
│  │   ├── Hunks (IReadOnlyList<DiffHunk>) → grouped changes            │
│  │   └── Stats (DiffStats) → summary statistics                       │
│  │                                                                     │
│  ├── Metadata                                                          │
│  │   ├── IsNewFile → original didn't exist                            │
│  │   ├── IsDeleteFile → proposed is empty/deletion                    │
│  │   ├── IsBinaryFile → cannot diff binary content                    │
│  │   └── ComputedAt (DateTime) → when diff was calculated             │
│  │                                                                     │
│  └── Computed Properties                                               │
│      ├── HasChanges → any actual differences exist                    │
│      └── HunkCount → total number of hunks                            │
│                                                                        │
│  DiffHunk                                                              │
│  ├── Identity                                                          │
│  │   ├── Id (Guid) → unique identifier                                │
│  │   └── Index (int) → position within parent DiffResult              │
│  │                                                                     │
│  ├── Line Ranges                                                       │
│  │   ├── OriginalStartLine → 1-based start in original                │
│  │   ├── OriginalLineCount → lines from original                      │
│  │   ├── ProposedStartLine → 1-based start in proposed                │
│  │   └── ProposedLineCount → lines from proposed                      │
│  │                                                                     │
│  ├── Content                                                           │
│  │   ├── Lines (IReadOnlyList<DiffLine>) → all lines in hunk          │
│  │   └── ContextHeader (string?) → function/class context             │
│  │                                                                     │
│  └── Computed Properties                                               │
│      ├── Header → "@@ -start,count +start,count @@"                   │
│      ├── AddedLines → filtered additions                              │
│      ├── RemovedLines → filtered removals                             │
│      ├── IsInsertOnly → only additions + context                      │
│      └── IsDeleteOnly → only removals + context                       │
│                                                                        │
│  DiffLine                                                              │
│  ├── Line Numbers                                                      │
│  │   ├── OriginalLineNumber (int?) → null if added                    │
│  │   └── ProposedLineNumber (int?) → null if removed                  │
│  │                                                                     │
│  ├── Content                                                           │
│  │   ├── Content (string) → actual line text                          │
│  │   └── InlineChanges (IReadOnlyList<InlineChange>?) → char diffs    │
│  │                                                                     │
│  ├── Classification                                                    │
│  │   ├── Type (DiffLineType) → Unchanged/Added/Removed/Modified       │
│  │   └── PairedLine (DiffLine?) → matching line for modifications     │
│  │                                                                     │
│  └── Computed Properties                                               │
│      ├── Prefix → '+', '-', '~', or ' '                               │
│      ├── HasInlineChanges → character-level diffs present             │
│      └── GetLineNumber(side) → line number for specified side         │
│                                                                        │
│  InlineChange                                                          │
│  ├── Position                                                          │
│  │   ├── StartColumn (int) → 0-based start position                   │
│  │   └── Length (int) → span length                                   │
│  │                                                                     │
│  ├── Content                                                           │
│  │   ├── Text (string) → changed text segment                         │
│  │   └── Type (InlineChangeType) → Added/Removed/Unchanged            │
│  │                                                                     │
│  └── Computed Properties                                               │
│      └── EndColumn → StartColumn + Length                             │
│                                                                        │
│  DiffStats                                                             │
│  ├── Line Counts                                                       │
│  │   ├── TotalLines → total lines in diff                             │
│  │   ├── AddedLines → count of additions                              │
│  │   ├── RemovedLines → count of deletions                            │
│  │   ├── ModifiedLines → count of modifications                       │
│  │   └── UnchangedLines → count of context lines                      │
│  │                                                                     │
│  └── Computed Properties                                               │
│      ├── NetChange → AddedLines - RemovedLines                        │
│      ├── ChangePercentage → (changed / total) * 100                   │
│      ├── Summary → "+X -Y ~Z" format                                  │
│      └── Empty → static empty instance                                │
│                                                                        │
│  Enumerations                                                          │
│  ├── DiffLineType: Unchanged, Added, Removed, Modified                │
│  ├── DiffSide: Original, Proposed                                     │
│  └── InlineChangeType: Added, Removed, Unchanged                      │
│                                                                        │
└───────────────────────────────────────────────────────────────────────┘
```

---

## Architecture Diagrams

### Model Relationship Diagram

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         DiffResult (Root)                                │
│  Id: Guid                                                               │
│  OriginalFilePath: string                                               │
│  OriginalContent: string                                                │
│  ProposedContent: string                                                │
│  SourceBlockId: Guid? ─────────────────────────────► CodeBlock (v0.4.1) │
│  ComputedAt: DateTime                                                   │
│  IsNewFile, IsDeleteFile, IsBinaryFile: bool                            │
├─────────────────────────────────────────────────────────────────────────┤
│  ┌─────────────────┐         ┌─────────────────────────────────────┐   │
│  │ Stats: DiffStats │         │ Hunks: IReadOnlyList<DiffHunk>      │   │
│  │ (1:1 composition)│         │ (1:N aggregation)                   │   │
│  └─────────────────┘         └─────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────┘
                                            │
                                            │ contains 0..N
                                            ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                              DiffHunk                                    │
│  Id: Guid                                                               │
│  Index: int                                                             │
│  OriginalStartLine, OriginalLineCount: int                              │
│  ProposedStartLine, ProposedLineCount: int                              │
│  ContextHeader: string?                                                 │
├─────────────────────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │ Lines: IReadOnlyList<DiffLine>                                   │   │
│  │ (1:N aggregation)                                                │   │
│  └─────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────┘
                                            │
                                            │ contains 1..N
                                            ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                              DiffLine                                    │
│  OriginalLineNumber: int?                                               │
│  ProposedLineNumber: int?                                               │
│  Content: string                                                        │
│  Type: DiffLineType                                                     │
│  PairedLine: DiffLine? ─────────────────────────────► DiffLine (self)  │
├─────────────────────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │ InlineChanges: IReadOnlyList<InlineChange>?                      │   │
│  │ (1:N optional aggregation, only for Modified lines)              │   │
│  └─────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────┘
                                            │
                                            │ contains 0..N (optional)
                                            ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                            InlineChange                                  │
│  StartColumn: int                                                       │
│  Length: int                                                            │
│  Text: string                                                           │
│  Type: InlineChangeType                                                 │
└─────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────┐
│                        DiffStats (Value Object)                          │
│  TotalLines: int                                                        │
│  AddedLines: int                                                        │
│  RemovedLines: int                                                      │
│  ModifiedLines: int                                                     │
│  UnchangedLines: int                                                    │
└─────────────────────────────────────────────────────────────────────────┘
```

### Diff Computation Flow (Context for Models)

```
┌────────────────────┐     ┌────────────────────┐
│  Original Content  │     │  Proposed Content  │
│  (from file)       │     │  (from CodeBlock)  │
└─────────┬──────────┘     └─────────┬──────────┘
          │                          │
          └──────────┬───────────────┘
                     │
                     ▼
          ┌──────────────────┐
          │   IDiffService   │  (v0.4.2b)
          │  ComputeDiff()   │
          └────────┬─────────┘
                   │
                   ▼
          ┌──────────────────────────────────────────────────────┐
          │                    DiffResult                         │
          │  ┌────────────────────────────────────────────────┐  │
          │  │ Hunks[]                                         │  │
          │  │  ┌──────────────────────────────────────────┐  │  │
          │  │  │ DiffHunk[0]                               │  │  │
          │  │  │  @@ -10,5 +10,7 @@                        │  │  │
          │  │  │  Lines[]                                  │  │  │
          │  │  │   [ ] Line 10: context                    │  │  │
          │  │  │   [-] Line 11: removed                    │  │  │
          │  │  │   [+] Line 11: added (new)                │  │  │
          │  │  │   [+] Line 12: added (new)                │  │  │
          │  │  │   [~] Line 13: modified (inline changes)  │  │  │
          │  │  │   [ ] Line 14: context                    │  │  │
          │  │  └──────────────────────────────────────────┘  │  │
          │  │  ┌──────────────────────────────────────────┐  │  │
          │  │  │ DiffHunk[1]                               │  │  │
          │  │  │  @@ -25,3 +27,4 @@                        │  │  │
          │  │  │  ...                                      │  │  │
          │  │  └──────────────────────────────────────────┘  │  │
          │  └────────────────────────────────────────────────┘  │
          │  ┌────────────────────────────────────────────────┐  │
          │  │ Stats: +5 -2 ~1                                │  │
          │  └────────────────────────────────────────────────┘  │
          └──────────────────────────────────────────────────────┘
```

### Side-by-Side Line Alignment (Conceptual)

```
Original Side                           Proposed Side
─────────────────────────────────────  ─────────────────────────────────────
Line#  Gutter  Content                  Line#  Gutter  Content
─────────────────────────────────────  ─────────────────────────────────────
  10   [ ]     public void Foo()          10   [ ]     public void Foo()
  11   [-]     // old comment             --   ---     (empty - line removed)
  --   ---     (empty - line added)       11   [+]     // new comment
  --   ---     (empty - line added)       12   [+]     // extra line
  12   [~]     var x = OLD;               13   [~]     var x = NEW;
       │                                        │
       └──────── Paired for inline diff ────────┘
       InlineChanges: "OLD" → "NEW"
  13   [ ]     return x;                  14   [ ]     return x;
```

---

## Implementation Details

### 1. DiffResult Model

The top-level container for a complete diff computation:

```csharp
// src/SeniorIntern.Core/Models/DiffResult.cs

namespace SeniorIntern.Core.Models;

/// <summary>
/// Represents the complete result of a diff computation between two texts.
/// This is the root model returned by IDiffService.ComputeDiff().
/// </summary>
public sealed class DiffResult
{
    /// <summary>
    /// Unique identifier for this diff result.
    /// Used for caching and tracking diffs across UI interactions.
    /// </summary>
    public Guid Id { get; init; } = Guid.NewGuid();

    /// <summary>
    /// Path to the original file being modified.
    /// Empty string for in-memory comparisons or new file creation.
    /// </summary>
    /// <example>"src/Services/MyService.cs"</example>
    public string OriginalFilePath { get; init; } = string.Empty;

    /// <summary>
    /// The original content before changes.
    /// Empty string if IsNewFile is true.
    /// </summary>
    public string OriginalContent { get; init; } = string.Empty;

    /// <summary>
    /// The proposed content after changes.
    /// Empty string if IsDeleteFile is true.
    /// </summary>
    public string ProposedContent { get; init; } = string.Empty;

    /// <summary>
    /// Individual diff hunks (contiguous groups of changes).
    /// Each hunk contains context lines plus the actual changes.
    /// </summary>
    public IReadOnlyList<DiffHunk> Hunks { get; init; } = [];

    /// <summary>
    /// Summary statistics for the diff.
    /// </summary>
    public DiffStats Stats { get; init; } = DiffStats.Empty;

    /// <summary>
    /// Whether this represents a new file creation (original didn't exist).
    /// When true, OriginalContent is empty.
    /// </summary>
    public bool IsNewFile { get; init; }

    /// <summary>
    /// Whether this represents a file deletion (proposed is empty).
    /// When true, ProposedContent is empty.
    /// </summary>
    public bool IsDeleteFile { get; init; }

    /// <summary>
    /// Whether this represents a binary file that cannot be diffed.
    /// When true, Hunks will be empty.
    /// </summary>
    public bool IsBinaryFile { get; init; }

    /// <summary>
    /// The code block that generated this diff (if applicable).
    /// Links back to the v0.4.1 CodeBlock model.
    /// </summary>
    public Guid? SourceBlockId { get; init; }

    /// <summary>
    /// When this diff was computed.
    /// Useful for cache invalidation and debugging.
    /// </summary>
    public DateTime ComputedAt { get; init; } = DateTime.UtcNow;

    // ═══════════════════════════════════════════════════════════════
    // Computed Properties
    // ═══════════════════════════════════════════════════════════════

    /// <summary>
    /// Whether there are any actual changes between original and proposed.
    /// Returns false if the files are identical or if this is a binary file.
    /// </summary>
    public bool HasChanges => Hunks.Count > 0 &&
        (Stats.AddedLines > 0 || Stats.RemovedLines > 0 || Stats.ModifiedLines > 0);

    /// <summary>
    /// Total number of hunks in this diff.
    /// </summary>
    public int HunkCount => Hunks.Count;

    /// <summary>
    /// Whether the diff can be applied (not binary, has changes or is new/delete).
    /// </summary>
    public bool IsApplicable => !IsBinaryFile && (HasChanges || IsNewFile || IsDeleteFile);

    /// <summary>
    /// File name extracted from OriginalFilePath.
    /// </summary>
    public string FileName => string.IsNullOrEmpty(OriginalFilePath)
        ? "(untitled)"
        : Path.GetFileName(OriginalFilePath);

    /// <summary>
    /// Creates an empty diff result for identical content.
    /// </summary>
    public static DiffResult NoChanges(string filePath, string content) => new()
    {
        OriginalFilePath = filePath,
        OriginalContent = content,
        ProposedContent = content,
        Hunks = [],
        Stats = DiffStats.Empty
    };

    /// <summary>
    /// Creates a diff result for a new file.
    /// </summary>
    public static DiffResult NewFile(string filePath, string content, IReadOnlyList<DiffHunk> hunks, DiffStats stats) => new()
    {
        OriginalFilePath = filePath,
        OriginalContent = string.Empty,
        ProposedContent = content,
        Hunks = hunks,
        Stats = stats,
        IsNewFile = true
    };

    /// <summary>
    /// Creates a diff result for file deletion.
    /// </summary>
    public static DiffResult DeleteFile(string filePath, string originalContent, IReadOnlyList<DiffHunk> hunks, DiffStats stats) => new()
    {
        OriginalFilePath = filePath,
        OriginalContent = originalContent,
        ProposedContent = string.Empty,
        Hunks = hunks,
        Stats = stats,
        IsDeleteFile = true
    };

    /// <summary>
    /// Creates a diff result for binary files.
    /// </summary>
    public static DiffResult BinaryFile(string filePath) => new()
    {
        OriginalFilePath = filePath,
        IsBinaryFile = true,
        Hunks = [],
        Stats = DiffStats.Empty
    };
}
```

### 2. DiffHunk Model

Represents a contiguous group of changes:

```csharp
// src/SeniorIntern.Core/Models/DiffHunk.cs

namespace SeniorIntern.Core.Models;

/// <summary>
/// Represents a contiguous group of changes in a diff.
/// A hunk contains context lines (unchanged) surrounding the actual changes,
/// similar to the hunks in a unified diff format.
/// </summary>
/// <remarks>
/// Hunk header format follows Git/unified diff convention:
/// @@ -originalStart,originalCount +proposedStart,proposedCount @@ [context]
/// </remarks>
public sealed class DiffHunk
{
    /// <summary>
    /// Unique identifier for this hunk.
    /// Used for navigation and per-hunk apply/reject actions.
    /// </summary>
    public Guid Id { get; init; } = Guid.NewGuid();

    /// <summary>
    /// Starting line number in the original content (1-based).
    /// </summary>
    public int OriginalStartLine { get; init; }

    /// <summary>
    /// Number of lines from the original content in this hunk.
    /// Includes context lines and removed lines.
    /// </summary>
    public int OriginalLineCount { get; init; }

    /// <summary>
    /// Starting line number in the proposed content (1-based).
    /// </summary>
    public int ProposedStartLine { get; init; }

    /// <summary>
    /// Number of lines from the proposed content in this hunk.
    /// Includes context lines and added lines.
    /// </summary>
    public int ProposedLineCount { get; init; }

    /// <summary>
    /// All lines in this hunk with their change types.
    /// Includes context lines (Unchanged), additions (Added),
    /// removals (Removed), and modifications (Modified).
    /// </summary>
    public IReadOnlyList<DiffLine> Lines { get; init; } = [];

    /// <summary>
    /// Optional header/context for this hunk.
    /// Typically contains the function or class name where changes occur.
    /// </summary>
    /// <example>"public void ProcessData()"</example>
    public string? ContextHeader { get; init; }

    /// <summary>
    /// Index of this hunk in the parent DiffResult (0-based).
    /// Useful for navigation: "Hunk 2 of 5".
    /// </summary>
    public int Index { get; init; }

    // ═══════════════════════════════════════════════════════════════
    // Computed Properties
    // ═══════════════════════════════════════════════════════════════

    /// <summary>
    /// Standard hunk header in unified diff format.
    /// </summary>
    /// <example>"@@ -10,5 +10,7 @@"</example>
    public string Header =>
        $"@@ -{OriginalStartLine},{OriginalLineCount} +{ProposedStartLine},{ProposedLineCount} @@";

    /// <summary>
    /// Full header including context if available.
    /// </summary>
    /// <example>"@@ -10,5 +10,7 @@ public void ProcessData()"</example>
    public string FullHeader => ContextHeader is not null
        ? $"{Header} {ContextHeader}"
        : Header;

    /// <summary>
    /// Lines that were added in this hunk.
    /// </summary>
    public IEnumerable<DiffLine> AddedLines =>
        Lines.Where(l => l.Type == DiffLineType.Added);

    /// <summary>
    /// Lines that were removed in this hunk.
    /// </summary>
    public IEnumerable<DiffLine> RemovedLines =>
        Lines.Where(l => l.Type == DiffLineType.Removed);

    /// <summary>
    /// Lines that were modified in this hunk.
    /// </summary>
    public IEnumerable<DiffLine> ModifiedLines =>
        Lines.Where(l => l.Type == DiffLineType.Modified);

    /// <summary>
    /// Context (unchanged) lines in this hunk.
    /// </summary>
    public IEnumerable<DiffLine> UnchangedLines =>
        Lines.Where(l => l.Type == DiffLineType.Unchanged);

    /// <summary>
    /// Whether this hunk contains only additions (no removals).
    /// </summary>
    public bool IsInsertOnly => Lines.All(l =>
        l.Type is DiffLineType.Added or DiffLineType.Unchanged);

    /// <summary>
    /// Whether this hunk contains only deletions (no additions).
    /// </summary>
    public bool IsDeleteOnly => Lines.All(l =>
        l.Type is DiffLineType.Removed or DiffLineType.Unchanged);

    /// <summary>
    /// Whether this hunk contains modifications (paired removed/added lines).
    /// </summary>
    public bool HasModifications => Lines.Any(l => l.Type == DiffLineType.Modified);

    /// <summary>
    /// Count of added lines in this hunk.
    /// </summary>
    public int AddedCount => Lines.Count(l => l.Type == DiffLineType.Added);

    /// <summary>
    /// Count of removed lines in this hunk.
    /// </summary>
    public int RemovedCount => Lines.Count(l => l.Type == DiffLineType.Removed);

    /// <summary>
    /// Count of modified lines in this hunk.
    /// </summary>
    public int ModifiedCount => Lines.Count(l => l.Type == DiffLineType.Modified);
}
```

### 3. DiffLine Model and Enums

Individual line with change classification:

```csharp
// src/SeniorIntern.Core/Models/DiffLine.cs

namespace SeniorIntern.Core.Models;

/// <summary>
/// Represents a single line in a diff with its change type and optional inline changes.
/// </summary>
public sealed class DiffLine
{
    /// <summary>
    /// Line number in the original content (1-based).
    /// Null if this line was added (doesn't exist in original).
    /// </summary>
    public int? OriginalLineNumber { get; init; }

    /// <summary>
    /// Line number in the proposed content (1-based).
    /// Null if this line was removed (doesn't exist in proposed).
    /// </summary>
    public int? ProposedLineNumber { get; init; }

    /// <summary>
    /// The text content of this line (without line ending).
    /// </summary>
    public string Content { get; init; } = string.Empty;

    /// <summary>
    /// The type of change for this line.
    /// </summary>
    public DiffLineType Type { get; init; }

    /// <summary>
    /// Inline character-level changes within this line.
    /// Only populated for Modified lines to show exactly what changed.
    /// </summary>
    public IReadOnlyList<InlineChange>? InlineChanges { get; init; }

    /// <summary>
    /// The paired line for modified lines.
    /// For a removed line that was modified, this points to the corresponding added line.
    /// For an added line that was modified, this points to the corresponding removed line.
    /// </summary>
    public DiffLine? PairedLine { get; set; }

    // ═══════════════════════════════════════════════════════════════
    // Computed Properties
    // ═══════════════════════════════════════════════════════════════

    /// <summary>
    /// Whether this line has inline character-level changes.
    /// </summary>
    public bool HasInlineChanges => InlineChanges is { Count: > 0 };

    /// <summary>
    /// Display prefix character for unified diff format.
    /// </summary>
    public char Prefix => Type switch
    {
        DiffLineType.Added => '+',
        DiffLineType.Removed => '-',
        DiffLineType.Modified => '~',
        DiffLineType.Unchanged => ' ',
        _ => ' '
    };

    /// <summary>
    /// Whether this line exists on the original (left) side.
    /// </summary>
    public bool ExistsOnOriginalSide => Type is not DiffLineType.Added;

    /// <summary>
    /// Whether this line exists on the proposed (right) side.
    /// </summary>
    public bool ExistsOnProposedSide => Type is not DiffLineType.Removed;

    /// <summary>
    /// Gets the appropriate line number based on the diff side.
    /// </summary>
    /// <param name="side">Which side of the diff to get the line number for.</param>
    /// <returns>The line number, or null if the line doesn't exist on that side.</returns>
    public int? GetLineNumber(DiffSide side) => side switch
    {
        DiffSide.Original => OriginalLineNumber,
        DiffSide.Proposed => ProposedLineNumber,
        _ => null
    };

    /// <summary>
    /// Creates an unchanged context line.
    /// </summary>
    public static DiffLine Unchanged(int originalLine, int proposedLine, string content) => new()
    {
        OriginalLineNumber = originalLine,
        ProposedLineNumber = proposedLine,
        Content = content,
        Type = DiffLineType.Unchanged
    };

    /// <summary>
    /// Creates an added line (only exists in proposed).
    /// </summary>
    public static DiffLine Added(int proposedLine, string content) => new()
    {
        OriginalLineNumber = null,
        ProposedLineNumber = proposedLine,
        Content = content,
        Type = DiffLineType.Added
    };

    /// <summary>
    /// Creates a removed line (only exists in original).
    /// </summary>
    public static DiffLine Removed(int originalLine, string content) => new()
    {
        OriginalLineNumber = originalLine,
        ProposedLineNumber = null,
        Content = content,
        Type = DiffLineType.Removed
    };

    /// <summary>
    /// Creates a modified line with inline changes.
    /// </summary>
    public static DiffLine Modified(
        int? originalLine,
        int? proposedLine,
        string content,
        IReadOnlyList<InlineChange>? inlineChanges = null) => new()
    {
        OriginalLineNumber = originalLine,
        ProposedLineNumber = proposedLine,
        Content = content,
        Type = DiffLineType.Modified,
        InlineChanges = inlineChanges
    };
}

/// <summary>
/// Type of change for a diff line.
/// </summary>
public enum DiffLineType
{
    /// <summary>
    /// Line is unchanged between original and proposed.
    /// Serves as context around changes.
    /// </summary>
    Unchanged = 0,

    /// <summary>
    /// Line was added in proposed content.
    /// Does not exist in original.
    /// </summary>
    Added = 1,

    /// <summary>
    /// Line was removed from original content.
    /// Does not exist in proposed.
    /// </summary>
    Removed = 2,

    /// <summary>
    /// Line was modified (exists in both but content differs).
    /// Has a PairedLine and may have InlineChanges.
    /// </summary>
    Modified = 3
}

/// <summary>
/// Which side of a side-by-side diff view.
/// </summary>
public enum DiffSide
{
    /// <summary>
    /// The original (left) side showing content before changes.
    /// </summary>
    Original = 0,

    /// <summary>
    /// The proposed (right) side showing content after changes.
    /// </summary>
    Proposed = 1
}
```

### 4. InlineChange Model

Character-level changes within a line:

```csharp
// src/SeniorIntern.Core/Models/InlineChange.cs

namespace SeniorIntern.Core.Models;

/// <summary>
/// Represents a character-level change within a modified line.
/// Used to highlight exactly which characters changed when a line was modified.
/// </summary>
/// <remarks>
/// InlineChanges are computed by performing a word-level or character-level
/// diff between the original and proposed versions of a modified line.
/// </remarks>
/// <example>
/// Original: "var count = 10;"
/// Proposed: "var count = 20;"
///
/// InlineChanges on original line:
///   - Removed: StartColumn=12, Length=2, Text="10"
///
/// InlineChanges on proposed line:
///   - Added: StartColumn=12, Length=2, Text="20"
/// </example>
public sealed class InlineChange
{
    /// <summary>
    /// Starting column position (0-based index into the line content).
    /// </summary>
    public int StartColumn { get; init; }

    /// <summary>
    /// Length of the changed text segment in characters.
    /// </summary>
    public int Length { get; init; }

    /// <summary>
    /// The changed text content.
    /// </summary>
    public string Text { get; init; } = string.Empty;

    /// <summary>
    /// Type of inline change (Added, Removed, or Unchanged).
    /// </summary>
    public InlineChangeType Type { get; init; }

    // ═══════════════════════════════════════════════════════════════
    // Computed Properties
    // ═══════════════════════════════════════════════════════════════

    /// <summary>
    /// End column position (exclusive, 0-based).
    /// </summary>
    public int EndColumn => StartColumn + Length;

    /// <summary>
    /// Whether this represents an actual change (not unchanged context).
    /// </summary>
    public bool IsChange => Type != InlineChangeType.Unchanged;

    /// <summary>
    /// Creates an added inline change.
    /// </summary>
    public static InlineChange Added(int startColumn, string text) => new()
    {
        StartColumn = startColumn,
        Length = text.Length,
        Text = text,
        Type = InlineChangeType.Added
    };

    /// <summary>
    /// Creates a removed inline change.
    /// </summary>
    public static InlineChange Removed(int startColumn, string text) => new()
    {
        StartColumn = startColumn,
        Length = text.Length,
        Text = text,
        Type = InlineChangeType.Removed
    };

    /// <summary>
    /// Creates an unchanged inline segment (context).
    /// </summary>
    public static InlineChange Unchanged(int startColumn, string text) => new()
    {
        StartColumn = startColumn,
        Length = text.Length,
        Text = text,
        Type = InlineChangeType.Unchanged
    };
}

/// <summary>
/// Type of character-level change within a line.
/// </summary>
public enum InlineChangeType
{
    /// <summary>
    /// Text segment is unchanged (context between changes).
    /// </summary>
    Unchanged = 0,

    /// <summary>
    /// Text segment was added.
    /// </summary>
    Added = 1,

    /// <summary>
    /// Text segment was removed.
    /// </summary>
    Removed = 2
}
```

### 5. DiffStats Record

Summary statistics for the diff:

```csharp
// src/SeniorIntern.Core/Models/DiffStats.cs

namespace SeniorIntern.Core.Models;

/// <summary>
/// Summary statistics for a diff computation.
/// Implemented as a record for value equality and immutability.
/// </summary>
public sealed record DiffStats
{
    /// <summary>
    /// Total number of lines involved in the diff.
    /// Sum of all line types.
    /// </summary>
    public int TotalLines { get; init; }

    /// <summary>
    /// Number of lines added (exist only in proposed).
    /// </summary>
    public int AddedLines { get; init; }

    /// <summary>
    /// Number of lines removed (exist only in original).
    /// </summary>
    public int RemovedLines { get; init; }

    /// <summary>
    /// Number of lines modified (exist in both but content differs).
    /// </summary>
    public int ModifiedLines { get; init; }

    /// <summary>
    /// Number of unchanged context lines.
    /// </summary>
    public int UnchangedLines { get; init; }

    // ═══════════════════════════════════════════════════════════════
    // Computed Properties
    // ═══════════════════════════════════════════════════════════════

    /// <summary>
    /// Net line change (additions minus removals).
    /// Positive means file grew, negative means file shrank.
    /// </summary>
    public int NetChange => AddedLines - RemovedLines;

    /// <summary>
    /// Percentage of lines that were changed.
    /// </summary>
    public double ChangePercentage => TotalLines > 0
        ? (double)(AddedLines + RemovedLines + ModifiedLines) / TotalLines * 100
        : 0;

    /// <summary>
    /// Total number of changed lines (added + removed + modified).
    /// </summary>
    public int ChangedLines => AddedLines + RemovedLines + ModifiedLines;

    /// <summary>
    /// Human-readable summary in compact format.
    /// </summary>
    /// <example>"+5 -2" or "+5 -2 ~1"</example>
    public string Summary
    {
        get
        {
            var parts = new List<string>(3);
            if (AddedLines > 0 || RemovedLines == 0 && ModifiedLines == 0)
                parts.Add($"+{AddedLines}");
            if (RemovedLines > 0 || AddedLines == 0 && ModifiedLines == 0)
                parts.Add($"-{RemovedLines}");
            if (ModifiedLines > 0)
                parts.Add($"~{ModifiedLines}");
            return string.Join(" ", parts);
        }
    }

    /// <summary>
    /// Verbose summary with labels.
    /// </summary>
    /// <example>"5 additions, 2 deletions, 1 modification"</example>
    public string VerboseSummary
    {
        get
        {
            var parts = new List<string>(3);
            if (AddedLines > 0)
                parts.Add($"{AddedLines} addition{(AddedLines != 1 ? "s" : "")}");
            if (RemovedLines > 0)
                parts.Add($"{RemovedLines} deletion{(RemovedLines != 1 ? "s" : "")}");
            if (ModifiedLines > 0)
                parts.Add($"{ModifiedLines} modification{(ModifiedLines != 1 ? "s" : "")}");
            return parts.Count > 0 ? string.Join(", ", parts) : "No changes";
        }
    }

    /// <summary>
    /// Whether there are any changes.
    /// </summary>
    public bool HasChanges => AddedLines > 0 || RemovedLines > 0 || ModifiedLines > 0;

    /// <summary>
    /// Empty stats instance for no changes.
    /// </summary>
    public static DiffStats Empty => new();

    /// <summary>
    /// Creates stats from line counts.
    /// </summary>
    public static DiffStats FromCounts(int added, int removed, int modified, int unchanged) => new()
    {
        AddedLines = added,
        RemovedLines = removed,
        ModifiedLines = modified,
        UnchangedLines = unchanged,
        TotalLines = added + removed + modified + unchanged
    };
}
```

---

## Files Summary

### Files to Create

| File | Purpose | Lines (Est.) |
|------|---------|--------------|
| `src/SeniorIntern.Core/Models/DiffResult.cs` | Top-level diff result model | ~120 |
| `src/SeniorIntern.Core/Models/DiffHunk.cs` | Hunk grouping model | ~100 |
| `src/SeniorIntern.Core/Models/DiffLine.cs` | Line diff model with DiffLineType, DiffSide enums | ~130 |
| `src/SeniorIntern.Core/Models/InlineChange.cs` | Character-level change with InlineChangeType enum | ~80 |
| `src/SeniorIntern.Core/Models/DiffStats.cs` | Statistics record | ~90 |

### Files to Modify

None - v0.4.2a is purely additive, creating new model files.

---

## Testing Strategy

### Unit Tests

```csharp
// tests/SeniorIntern.Core.Tests/Models/DiffResultTests.cs

namespace SeniorIntern.Core.Tests.Models;

public class DiffResultTests
{
    [Fact]
    public void HasChanges_WithAddedLines_ReturnsTrue()
    {
        var result = new DiffResult
        {
            Stats = DiffStats.FromCounts(added: 5, removed: 0, modified: 0, unchanged: 10),
            Hunks = [new DiffHunk()]
        };

        Assert.True(result.HasChanges);
    }

    [Fact]
    public void HasChanges_WithRemovedLines_ReturnsTrue()
    {
        var result = new DiffResult
        {
            Stats = DiffStats.FromCounts(added: 0, removed: 3, modified: 0, unchanged: 10),
            Hunks = [new DiffHunk()]
        };

        Assert.True(result.HasChanges);
    }

    [Fact]
    public void HasChanges_WithModifiedLines_ReturnsTrue()
    {
        var result = new DiffResult
        {
            Stats = DiffStats.FromCounts(added: 0, removed: 0, modified: 2, unchanged: 10),
            Hunks = [new DiffHunk()]
        };

        Assert.True(result.HasChanges);
    }

    [Fact]
    public void HasChanges_WithNoChanges_ReturnsFalse()
    {
        var result = new DiffResult
        {
            Stats = DiffStats.Empty,
            Hunks = []
        };

        Assert.False(result.HasChanges);
    }

    [Fact]
    public void HasChanges_WithEmptyHunks_ReturnsFalse()
    {
        var result = new DiffResult
        {
            Stats = DiffStats.FromCounts(added: 5, removed: 0, modified: 0, unchanged: 0),
            Hunks = [] // No hunks even though stats say there are adds
        };

        Assert.False(result.HasChanges);
    }

    [Fact]
    public void IsApplicable_BinaryFile_ReturnsFalse()
    {
        var result = DiffResult.BinaryFile("image.png");

        Assert.False(result.IsApplicable);
    }

    [Fact]
    public void IsApplicable_NewFile_ReturnsTrue()
    {
        var result = DiffResult.NewFile(
            "src/NewFile.cs",
            "public class NewFile { }",
            [new DiffHunk()],
            DiffStats.FromCounts(added: 1, removed: 0, modified: 0, unchanged: 0));

        Assert.True(result.IsApplicable);
    }

    [Fact]
    public void FileName_WithPath_ReturnsFileName()
    {
        var result = new DiffResult { OriginalFilePath = "src/Services/MyService.cs" };

        Assert.Equal("MyService.cs", result.FileName);
    }

    [Fact]
    public void FileName_WithEmptyPath_ReturnsUntitled()
    {
        var result = new DiffResult { OriginalFilePath = "" };

        Assert.Equal("(untitled)", result.FileName);
    }

    [Fact]
    public void NoChanges_CreatesIdenticalResult()
    {
        var content = "line1\nline2";
        var result = DiffResult.NoChanges("file.txt", content);

        Assert.Equal(content, result.OriginalContent);
        Assert.Equal(content, result.ProposedContent);
        Assert.Empty(result.Hunks);
        Assert.False(result.HasChanges);
    }
}
```

```csharp
// tests/SeniorIntern.Core.Tests/Models/DiffHunkTests.cs

namespace SeniorIntern.Core.Tests.Models;

public class DiffHunkTests
{
    [Fact]
    public void Header_FormatsCorrectly()
    {
        var hunk = new DiffHunk
        {
            OriginalStartLine = 10,
            OriginalLineCount = 5,
            ProposedStartLine = 10,
            ProposedLineCount = 7
        };

        Assert.Equal("@@ -10,5 +10,7 @@", hunk.Header);
    }

    [Fact]
    public void Header_SingleLine_FormatsCorrectly()
    {
        var hunk = new DiffHunk
        {
            OriginalStartLine = 1,
            OriginalLineCount = 1,
            ProposedStartLine = 1,
            ProposedLineCount = 1
        };

        Assert.Equal("@@ -1,1 +1,1 @@", hunk.Header);
    }

    [Fact]
    public void FullHeader_WithContext_IncludesContext()
    {
        var hunk = new DiffHunk
        {
            OriginalStartLine = 10,
            OriginalLineCount = 5,
            ProposedStartLine = 10,
            ProposedLineCount = 7,
            ContextHeader = "public void ProcessData()"
        };

        Assert.Equal("@@ -10,5 +10,7 @@ public void ProcessData()", hunk.FullHeader);
    }

    [Fact]
    public void FullHeader_WithoutContext_ReturnsHeaderOnly()
    {
        var hunk = new DiffHunk
        {
            OriginalStartLine = 10,
            OriginalLineCount = 5,
            ProposedStartLine = 10,
            ProposedLineCount = 7,
            ContextHeader = null
        };

        Assert.Equal("@@ -10,5 +10,7 @@", hunk.FullHeader);
    }

    [Fact]
    public void AddedLines_FiltersCorrectly()
    {
        var hunk = new DiffHunk
        {
            Lines =
            [
                DiffLine.Unchanged(1, 1, "context"),
                DiffLine.Added(2, "new line 1"),
                DiffLine.Added(3, "new line 2"),
                DiffLine.Removed(2, "old line"),
                DiffLine.Unchanged(3, 4, "more context")
            ]
        };

        var added = hunk.AddedLines.ToList();
        Assert.Equal(2, added.Count);
        Assert.All(added, l => Assert.Equal(DiffLineType.Added, l.Type));
    }

    [Fact]
    public void IsInsertOnly_WithOnlyAdditions_ReturnsTrue()
    {
        var hunk = new DiffHunk
        {
            Lines =
            [
                DiffLine.Unchanged(1, 1, "context"),
                DiffLine.Added(2, "new line"),
                DiffLine.Unchanged(2, 3, "more context")
            ]
        };

        Assert.True(hunk.IsInsertOnly);
    }

    [Fact]
    public void IsInsertOnly_WithRemovals_ReturnsFalse()
    {
        var hunk = new DiffHunk
        {
            Lines =
            [
                DiffLine.Unchanged(1, 1, "context"),
                DiffLine.Removed(2, "old line"),
                DiffLine.Unchanged(3, 2, "more context")
            ]
        };

        Assert.False(hunk.IsInsertOnly);
    }

    [Fact]
    public void IsDeleteOnly_WithOnlyRemovals_ReturnsTrue()
    {
        var hunk = new DiffHunk
        {
            Lines =
            [
                DiffLine.Unchanged(1, 1, "context"),
                DiffLine.Removed(2, "deleted line"),
                DiffLine.Unchanged(3, 2, "more context")
            ]
        };

        Assert.True(hunk.IsDeleteOnly);
    }
}
```

```csharp
// tests/SeniorIntern.Core.Tests/Models/DiffLineTests.cs

namespace SeniorIntern.Core.Tests.Models;

public class DiffLineTests
{
    [Theory]
    [InlineData(DiffLineType.Added, '+')]
    [InlineData(DiffLineType.Removed, '-')]
    [InlineData(DiffLineType.Modified, '~')]
    [InlineData(DiffLineType.Unchanged, ' ')]
    public void Prefix_ReturnsCorrectSymbol(DiffLineType type, char expected)
    {
        var line = new DiffLine { Type = type };
        Assert.Equal(expected, line.Prefix);
    }

    [Fact]
    public void GetLineNumber_Original_ReturnsOriginalLineNumber()
    {
        var line = new DiffLine
        {
            OriginalLineNumber = 42,
            ProposedLineNumber = 45
        };

        Assert.Equal(42, line.GetLineNumber(DiffSide.Original));
    }

    [Fact]
    public void GetLineNumber_Proposed_ReturnsProposedLineNumber()
    {
        var line = new DiffLine
        {
            OriginalLineNumber = 42,
            ProposedLineNumber = 45
        };

        Assert.Equal(45, line.GetLineNumber(DiffSide.Proposed));
    }

    [Fact]
    public void GetLineNumber_AddedLine_Original_ReturnsNull()
    {
        var line = DiffLine.Added(10, "new content");

        Assert.Null(line.GetLineNumber(DiffSide.Original));
        Assert.Equal(10, line.GetLineNumber(DiffSide.Proposed));
    }

    [Fact]
    public void GetLineNumber_RemovedLine_Proposed_ReturnsNull()
    {
        var line = DiffLine.Removed(10, "old content");

        Assert.Equal(10, line.GetLineNumber(DiffSide.Original));
        Assert.Null(line.GetLineNumber(DiffSide.Proposed));
    }

    [Fact]
    public void HasInlineChanges_WithChanges_ReturnsTrue()
    {
        var line = new DiffLine
        {
            InlineChanges = [InlineChange.Added(0, "new")]
        };

        Assert.True(line.HasInlineChanges);
    }

    [Fact]
    public void HasInlineChanges_WithEmptyList_ReturnsFalse()
    {
        var line = new DiffLine
        {
            InlineChanges = []
        };

        Assert.False(line.HasInlineChanges);
    }

    [Fact]
    public void HasInlineChanges_WithNull_ReturnsFalse()
    {
        var line = new DiffLine
        {
            InlineChanges = null
        };

        Assert.False(line.HasInlineChanges);
    }

    [Fact]
    public void ExistsOnOriginalSide_AddedLine_ReturnsFalse()
    {
        var line = DiffLine.Added(1, "content");
        Assert.False(line.ExistsOnOriginalSide);
    }

    [Fact]
    public void ExistsOnProposedSide_RemovedLine_ReturnsFalse()
    {
        var line = DiffLine.Removed(1, "content");
        Assert.False(line.ExistsOnProposedSide);
    }

    [Fact]
    public void StaticFactories_CreateCorrectTypes()
    {
        var unchanged = DiffLine.Unchanged(1, 1, "ctx");
        var added = DiffLine.Added(2, "new");
        var removed = DiffLine.Removed(3, "old");
        var modified = DiffLine.Modified(4, 5, "mod", []);

        Assert.Equal(DiffLineType.Unchanged, unchanged.Type);
        Assert.Equal(DiffLineType.Added, added.Type);
        Assert.Equal(DiffLineType.Removed, removed.Type);
        Assert.Equal(DiffLineType.Modified, modified.Type);
    }
}
```

```csharp
// tests/SeniorIntern.Core.Tests/Models/InlineChangeTests.cs

namespace SeniorIntern.Core.Tests.Models;

public class InlineChangeTests
{
    [Fact]
    public void EndColumn_CalculatesCorrectly()
    {
        var change = new InlineChange
        {
            StartColumn = 10,
            Length = 5,
            Text = "hello"
        };

        Assert.Equal(15, change.EndColumn);
    }

    [Fact]
    public void IsChange_Added_ReturnsTrue()
    {
        var change = InlineChange.Added(0, "new");
        Assert.True(change.IsChange);
    }

    [Fact]
    public void IsChange_Removed_ReturnsTrue()
    {
        var change = InlineChange.Removed(0, "old");
        Assert.True(change.IsChange);
    }

    [Fact]
    public void IsChange_Unchanged_ReturnsFalse()
    {
        var change = InlineChange.Unchanged(0, "same");
        Assert.False(change.IsChange);
    }

    [Fact]
    public void StaticFactories_SetLengthFromText()
    {
        var added = InlineChange.Added(5, "hello");
        var removed = InlineChange.Removed(10, "world");
        var unchanged = InlineChange.Unchanged(0, "test");

        Assert.Equal(5, added.Length);
        Assert.Equal(5, removed.Length);
        Assert.Equal(4, unchanged.Length);
    }

    [Fact]
    public void StaticFactories_SetCorrectTypes()
    {
        var added = InlineChange.Added(0, "x");
        var removed = InlineChange.Removed(0, "y");
        var unchanged = InlineChange.Unchanged(0, "z");

        Assert.Equal(InlineChangeType.Added, added.Type);
        Assert.Equal(InlineChangeType.Removed, removed.Type);
        Assert.Equal(InlineChangeType.Unchanged, unchanged.Type);
    }
}
```

```csharp
// tests/SeniorIntern.Core.Tests/Models/DiffStatsTests.cs

namespace SeniorIntern.Core.Tests.Models;

public class DiffStatsTests
{
    [Fact]
    public void NetChange_CalculatesCorrectly()
    {
        var stats = new DiffStats { AddedLines = 10, RemovedLines = 3 };
        Assert.Equal(7, stats.NetChange);
    }

    [Fact]
    public void NetChange_Negative_WhenMoreRemoved()
    {
        var stats = new DiffStats { AddedLines = 2, RemovedLines = 8 };
        Assert.Equal(-6, stats.NetChange);
    }

    [Fact]
    public void ChangePercentage_CalculatesCorrectly()
    {
        var stats = DiffStats.FromCounts(added: 2, removed: 2, modified: 1, unchanged: 5);
        // 5 changed out of 10 total = 50%
        Assert.Equal(50.0, stats.ChangePercentage, precision: 1);
    }

    [Fact]
    public void ChangePercentage_ZeroTotal_ReturnsZero()
    {
        var stats = DiffStats.Empty;
        Assert.Equal(0.0, stats.ChangePercentage);
    }

    [Fact]
    public void Summary_AdditionsOnly()
    {
        var stats = new DiffStats { AddedLines = 5 };
        Assert.Equal("+5", stats.Summary);
    }

    [Fact]
    public void Summary_RemovalsOnly()
    {
        var stats = new DiffStats { RemovedLines = 3 };
        Assert.Equal("-3", stats.Summary);
    }

    [Fact]
    public void Summary_Mixed()
    {
        var stats = new DiffStats { AddedLines = 5, RemovedLines = 2 };
        Assert.Equal("+5 -2", stats.Summary);
    }

    [Fact]
    public void Summary_WithModifications()
    {
        var stats = new DiffStats { AddedLines = 5, RemovedLines = 2, ModifiedLines = 1 };
        Assert.Equal("+5 -2 ~1", stats.Summary);
    }

    [Fact]
    public void Summary_NoChanges()
    {
        var stats = DiffStats.Empty;
        Assert.Equal("+0", stats.Summary);
    }

    [Fact]
    public void VerboseSummary_Singular()
    {
        var stats = new DiffStats { AddedLines = 1, RemovedLines = 1, ModifiedLines = 1 };
        Assert.Equal("1 addition, 1 deletion, 1 modification", stats.VerboseSummary);
    }

    [Fact]
    public void VerboseSummary_Plural()
    {
        var stats = new DiffStats { AddedLines = 5, RemovedLines = 2 };
        Assert.Equal("5 additions, 2 deletions", stats.VerboseSummary);
    }

    [Fact]
    public void VerboseSummary_NoChanges()
    {
        var stats = DiffStats.Empty;
        Assert.Equal("No changes", stats.VerboseSummary);
    }

    [Fact]
    public void HasChanges_WithChanges_ReturnsTrue()
    {
        var stats = new DiffStats { AddedLines = 1 };
        Assert.True(stats.HasChanges);
    }

    [Fact]
    public void HasChanges_Empty_ReturnsFalse()
    {
        Assert.False(DiffStats.Empty.HasChanges);
    }

    [Fact]
    public void FromCounts_CalculatesTotalLines()
    {
        var stats = DiffStats.FromCounts(added: 5, removed: 3, modified: 2, unchanged: 10);
        Assert.Equal(20, stats.TotalLines);
    }

    [Fact]
    public void Empty_IsDefault()
    {
        var empty = DiffStats.Empty;
        Assert.Equal(0, empty.TotalLines);
        Assert.Equal(0, empty.AddedLines);
        Assert.Equal(0, empty.RemovedLines);
        Assert.Equal(0, empty.ModifiedLines);
        Assert.Equal(0, empty.UnchangedLines);
    }

    [Fact]
    public void RecordEquality_Works()
    {
        var stats1 = DiffStats.FromCounts(1, 2, 3, 4);
        var stats2 = DiffStats.FromCounts(1, 2, 3, 4);
        var stats3 = DiffStats.FromCounts(1, 2, 3, 5);

        Assert.Equal(stats1, stats2);
        Assert.NotEqual(stats1, stats3);
    }
}
```

### Test Summary

| Test Class | Test Count |
|------------|------------|
| DiffResultTests | 10 |
| DiffHunkTests | 9 |
| DiffLineTests | 13 |
| InlineChangeTests | 6 |
| DiffStatsTests | 16 |
| **Total** | **54** |

---

## Acceptance Criteria

### Must Have

- [ ] DiffResult contains all required properties (Id, paths, content, hunks, stats)
- [ ] DiffResult.HasChanges correctly identifies when actual changes exist
- [ ] DiffResult.IsApplicable returns false for binary files
- [ ] DiffResult static factories (NoChanges, NewFile, DeleteFile, BinaryFile) work correctly
- [ ] DiffHunk generates correct header format (@@ -start,count +start,count @@)
- [ ] DiffHunk.FullHeader includes context when available
- [ ] DiffHunk filtered properties (AddedLines, RemovedLines, etc.) work correctly
- [ ] DiffHunk.IsInsertOnly and IsDeleteOnly detect pure operations
- [ ] DiffLine supports both original and proposed line numbers
- [ ] DiffLine.Prefix returns correct symbol for each type
- [ ] DiffLine.GetLineNumber returns correct value for each side
- [ ] DiffLine static factories create correctly typed instances
- [ ] InlineChange tracks character-level positions correctly
- [ ] InlineChange.EndColumn calculates correctly
- [ ] DiffStats calculates NetChange correctly
- [ ] DiffStats.ChangePercentage handles edge cases (zero total)
- [ ] DiffStats.Summary and VerboseSummary format correctly
- [ ] DiffStats record equality works for caching/comparison
- [ ] All models are immutable (init-only properties)
- [ ] All enums have XML documentation

### Should Have

- [ ] DiffResult includes SourceBlockId for traceability to CodeBlock
- [ ] DiffHunk includes Index for navigation context
- [ ] DiffLine.PairedLine supports modification tracking
- [ ] DiffStats.ChangedLines computed property for convenience

### Could Have

- [ ] Additional DiffResult metadata (e.g., encoding, line endings)
- [ ] DiffHunk grouping hints (e.g., "this is a function change")

---

## Integration Points

### Upstream (Consumes)

| Component | Usage |
|-----------|-------|
| CodeBlock (v0.4.1a) | SourceBlockId links DiffResult to originating code block |

### Downstream (Consumed By)

| Component | Usage |
|-----------|-------|
| IDiffService (v0.4.2b) | Returns DiffResult from ComputeDiff() |
| DiffViewerViewModel (v0.4.2d) | Binds to DiffResult for UI display |
| DiffLineControl (v0.4.2f) | Renders DiffLine with InlineChanges |

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Model changes break downstream | Medium | High | Freeze interface early, add tests |
| Line number off-by-one errors | Medium | Medium | Clearly document 1-based indexing |
| InlineChange position miscalculation | Medium | Low | Comprehensive test coverage |
| DiffStats percentage rounding issues | Low | Low | Use consistent precision in display |
| Memory pressure with large diffs | Low | Medium | Consider lazy loading of hunks |

---

## Future Enhancements

The following are explicitly out of scope for v0.4.2a but documented for future consideration:

1. **Binary diff support** (v0.5.x) - Hex diff for binary files
2. **Encoding detection** (v0.5.x) - Track and preserve file encoding
3. **Line ending handling** (v0.5.x) - Normalize/preserve CRLF vs LF
4. **Semantic diff hints** (v0.5.x) - "Renamed method" vs "Changed method body"
5. **Diff compression** (v0.5.x) - Efficient serialization for large diffs

---

## References

- [v0.4.2-diff-engine.md](v0.4.2-diff-engine.md) - Parent specification
- [v0.4.1a models](v0.4.1-code-block-extraction.md) - CodeBlock model (SourceBlockId reference)
- [Unified diff format](https://www.gnu.org/software/diffutils/manual/html_node/Detailed-Unified.html) - Hunk header format reference
- [DiffPlex](https://github.com/mmanela/diffplex) - Diff computation library (used in v0.4.2b)

---

**Proceed to v0.4.2b: Diff Service**
- Create IDiffService interface
- Implement DiffPlex-based diff computation
- Handle new file, deleted file, and binary file cases
- Generate hunks with configurable context lines
