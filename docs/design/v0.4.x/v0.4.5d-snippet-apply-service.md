# v0.4.5d: Snippet Apply Service - Design Specification

**Status**: _PLANNED_

## Executive Summary

This specification details the **Snippet Apply Service** for The Senior Intern, providing the core service layer for applying code snippets to specific file locations. This service coordinates between the diff engine, backup service, and settings service to safely apply code changes with indentation preservation, preview generation, and automatic location detection.

### Key Deliverables

| Component | Type | Purpose |
|-----------|------|---------|
| `ISnippetApplyService` | Interface | Contract for snippet application operations |
| `SnippetApplyService` | Class | Main implementation coordinating all snippet operations |
| `SnippetApplyResult` | Record | Result of applying a snippet including success/failure status |
| `SnippetApplyPreview` | Record | Preview of changes before applying a snippet |
| `SnippetLocationSuggestion` | Record | AI-suggested location for inserting a snippet |
| `SnippetApplyException` | Class | Specialized exception for apply failures |

---

## Feature Overview

```
v0.4.5d: Snippet Apply Service
├── Service Interface
│   └── ISnippetApplyService
│       ├── ApplySnippetAsync
│       │   ├── Validates options
│       │   ├── Creates backup (if enabled)
│       │   ├── Applies snippet content
│       │   └── Returns SnippetApplyResult
│       ├── PreviewSnippetAsync
│       │   ├── Generates preview without writing
│       │   ├── Computes diff
│       │   └── Returns SnippetApplyPreview
│       ├── DetectIndentationAsync
│       │   ├── Analyzes file content
│       │   ├── Detects tabs vs spaces
│       │   └── Returns IndentationStyle
│       ├── SuggestLocationAsync
│       │   ├── Analyzes snippet content
│       │   ├── Matches patterns in file
│       │   └── Returns SnippetLocationSuggestion
│       └── ValidateOptionsAsync
│           ├── Checks option validity
│           ├── Validates line ranges
│           └── Returns validation result
├── Service Implementation
│   └── SnippetApplyService
│       ├── Dependencies
│       │   ├── IDiffService
│       │   ├── IBackupService
│       │   └── ISettingsService
│       ├── Core Operations
│       │   ├── ApplyOperation (private)
│       │   │   ├── ReplaceFile handling
│       │   │   ├── Replace line range
│       │   │   ├── InsertBefore/InsertAfter
│       │   │   ├── Append/Prepend
│       │   │   └── Returns (lines, affected range)
│       │   ├── AdjustIndentation (private)
│       │   │   ├── Find minimum indent in snippet
│       │   │   ├── Apply target indentation
│       │   │   └── Preserve relative indentation
│       │   ├── GetLineIndentation (private)
│       │   └── FindMethodEnd (private)
│       └── Pattern Detection
│           ├── Method signature matching
│           ├── Class declaration matching
│           └── Brace counting for scope detection
├── Result Models
│   ├── SnippetApplyResult (record)
│   │   ├── IsSuccess (bool)
│   │   ├── FilePath (string)
│   │   ├── Options (SnippetApplyOptions)
│   │   ├── BackupPath (string?)
│   │   ├── LinesModified (int)
│   │   ├── LinesAdded (int)
│   │   ├── LinesRemoved (int)
│   │   ├── Diff (DiffResult?)
│   │   ├── ErrorMessage (string?)
│   │   ├── AppliedAt (DateTime)
│   │   └── Factory Methods
│   │       ├── Succeeded(...)
│   │       └── Failed(filePath, message)
│   ├── SnippetApplyPreview (record)
│   │   ├── ResultContent (string)
│   │   ├── Diff (DiffResult)
│   │   ├── AffectedRange (LineRange)
│   │   ├── LinesAdded (int)
│   │   ├── LinesRemoved (int)
│   │   ├── Warnings (IReadOnlyList<string>)
│   │   └── IsValid (computed)
│   └── SnippetLocationSuggestion (record)
│       ├── SuggestedMode (SnippetInsertMode)
│       ├── SuggestedLine (int?)
│       ├── SuggestedRange (LineRange?)
│       ├── Confidence (double, 0.0-1.0)
│       ├── Reason (string)
│       ├── MatchedContext (string?)
│       └── ToApplyOptions() method
└── Exception Handling
    └── SnippetApplyException
        ├── FilePath (string)
        ├── Operation (SnippetApplyOperation enum)
        ├── InnerDetails (string?)
        └── Operations
            ├── Validation
            ├── Backup
            ├── Apply
            ├── IndentationDetection
            └── LocationSuggestion
```

---

## Architecture

### Service Integration Diagram

```
┌──────────────────────────────────────────────────────────────────┐
│                      Chat ViewModel                              │
│  (requests snippet apply, shows preview, handles user actions)   │
└───────────────────────────────┬──────────────────────────────────┘
                                │
                                ▼
┌──────────────────────────────────────────────────────────────────┐
│                    ISnippetApplyService                          │
│  ┌────────────────────────────────────────────────────────────┐  │
│  │                  SnippetApplyService                       │  │
│  │                                                            │  │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐ │  │
│  │  │ ApplySnippet │  │PreviewSnippet│  │SuggestLocation   │ │  │
│  │  │    Async     │  │    Async     │  │    Async         │ │  │
│  │  └──────┬───────┘  └──────┬───────┘  └────────┬─────────┘ │  │
│  │         │                 │                    │           │  │
│  │         ▼                 ▼                    ▼           │  │
│  │  ┌─────────────────────────────────────────────────────┐  │  │
│  │  │              ApplyOperation (private)                │  │  │
│  │  │  Handles all SnippetInsertMode cases                │  │  │
│  │  └─────────────────────────────────────────────────────┘  │  │
│  │         │                 │                    │           │  │
│  │         ▼                 ▼                    ▼           │  │
│  │  ┌─────────────┐  ┌─────────────┐      ┌─────────────┐    │  │
│  │  │AdjustIndent │  │GetLineIndent│      │FindMethodEnd│    │  │
│  │  └─────────────┘  └─────────────┘      └─────────────┘    │  │
│  └────────────────────────────────────────────────────────────┘  │
└───────────────────────────────┬──────────────────────────────────┘
                                │
                ┌───────────────┼───────────────┐
                │               │               │
                ▼               ▼               ▼
       ┌────────────┐  ┌────────────┐  ┌────────────────┐
       │IDiffService│  │IBackupSvc  │  │ISettingsService│
       │            │  │            │  │                │
       │ComputeDiff │  │CreateBackup│  │GetSettings     │
       └────────────┘  └────────────┘  └────────────────┘
```

### Apply Operation Flow

```
┌─────────────────────────────────────────────────────────────────────┐
│                     ApplySnippetAsync Flow                          │
└─────────────────────────────────────────────────────────────────────┘

  Input: filePath, snippetContent, options
         │
         ▼
  ┌──────────────────┐     ┌────────────────────────────────────────┐
  │ Validate Options │────▶│ Return SnippetApplyResult.Failed if    │
  │                  │ NO  │ options.IsValid == false               │
  └────────┬─────────┘     └────────────────────────────────────────┘
           │ YES
           ▼
  ┌──────────────────┐
  │ PreviewSnippet   │◄─── Generates result without writing
  │     Async        │
  └────────┬─────────┘
           │
           ▼
  ┌──────────────────┐     ┌────────────────────────────────────────┐
  │ Check Settings   │────▶│ CreateBackupBeforeApply?               │
  │ CreateBackup?    │     │   YES → CreateBackupAsync              │
  └────────┬─────────┘     │   NO  → Continue                       │
           │               └────────────────────────────────────────┘
           ▼
  ┌──────────────────┐
  │ Write Result     │◄─── File.WriteAllTextAsync(preview.ResultContent)
  │ To File          │
  └────────┬─────────┘
           │
           ▼
  ┌──────────────────┐
  │ Return Success   │◄─── SnippetApplyResult.Succeeded with metrics
  │ Result           │
  └──────────────────┘

  Exception at any step:
         │
         ▼
  ┌──────────────────┐
  │ Return Failed    │◄─── SnippetApplyResult.Failed(filePath, ex.Message)
  │ Result           │
  └──────────────────┘
```

### Preview Generation Flow

```
┌─────────────────────────────────────────────────────────────────────┐
│                    PreviewSnippetAsync Flow                         │
└─────────────────────────────────────────────────────────────────────┘

  Input: filePath, snippetContent, options
         │
         ▼
  ┌──────────────────┐
  │ Read Original    │◄─── File.Exists ? ReadAllText : Empty
  │ Content          │
  └────────┬─────────┘
           │
           ▼
  ┌──────────────────┐
  │ Split Into Lines │◄─── originalContent.Split('\n')
  │                  │     snippetContent.Split('\n')
  └────────┬─────────┘
           │
           ▼
  ┌──────────────────┐     ┌────────────────────────────────────────┐
  │ Preserve Indent? │────▶│ options.PreserveIndentation &&         │
  │                  │ YES │ options.TargetLine.HasValue            │
  └────────┬─────────┘     │   → AdjustIndentation()                │
           │               └────────────────────────────────────────┘
           ▼
  ┌──────────────────┐
  │ ApplyOperation   │◄─── Based on options.InsertMode
  │                  │     Returns (resultLines, affectedRange)
  └────────┬─────────┘
           │
           ▼
  ┌──────────────────┐     ┌────────────────────────────────────────┐
  │ Add Blank Lines? │────▶│ AddBlankLineBefore → Insert at start   │
  │                  │     │ AddBlankLineAfter  → Insert at end     │
  └────────┬─────────┘     └────────────────────────────────────────┘
           │
           ▼
  ┌──────────────────┐
  │ Compute Diff     │◄─── _diffService.ComputeDiff(original, result)
  │                  │
  └────────┬─────────┘
           │
           ▼
  ┌──────────────────┐
  │ Generate Warnings│◄─── e.g., "Replace range extends beyond EOF"
  │                  │
  └────────┬─────────┘
           │
           ▼
  ┌──────────────────┐
  │ Return Preview   │◄─── SnippetApplyPreview with all computed data
  │                  │
  └──────────────────┘
```

---

## Detailed Design

### 1. ISnippetApplyService Interface

```csharp
// src/SeniorIntern.Core/Interfaces/ISnippetApplyService.cs
namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Service interface for applying code snippets to specific file locations.
/// Provides preview generation, indentation detection, and smart location suggestions.
/// </summary>
public interface ISnippetApplyService
{
    /// <summary>
    /// Applies a code snippet to a file using the specified options.
    /// Creates a backup if enabled in settings before making changes.
    /// </summary>
    /// <param name="filePath">Target file path (may not exist for new files)</param>
    /// <param name="snippetContent">The code snippet content to apply</param>
    /// <param name="options">Options controlling how the snippet is applied</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>Result indicating success/failure with metrics</returns>
    Task<SnippetApplyResult> ApplySnippetAsync(
        string filePath,
        string snippetContent,
        SnippetApplyOptions options,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Generates a preview of applying a snippet without writing to disk.
    /// Useful for showing diffs to the user before confirming changes.
    /// </summary>
    /// <param name="filePath">Target file path</param>
    /// <param name="snippetContent">The code snippet content to apply</param>
    /// <param name="options">Options controlling how the snippet is applied</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>Preview containing the result content, diff, and metrics</returns>
    Task<SnippetApplyPreview> PreviewSnippetAsync(
        string filePath,
        string snippetContent,
        SnippetApplyOptions options,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Detects the indentation style used in a file.
    /// Analyzes leading whitespace patterns to determine tabs vs spaces.
    /// </summary>
    /// <param name="filePath">File to analyze</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>Detected indentation style with confidence score</returns>
    Task<IndentationStyle> DetectIndentationAsync(
        string filePath,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Suggests an optimal location for inserting a code snippet.
    /// Uses pattern matching to find appropriate insertion points.
    /// </summary>
    /// <param name="filePath">Target file to analyze</param>
    /// <param name="snippetContent">Snippet to find a location for</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>Suggestion with confidence score, or null if no suggestion</returns>
    Task<SnippetLocationSuggestion?> SuggestLocationAsync(
        string filePath,
        string snippetContent,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Validates apply options against a specific file context.
    /// Checks that line ranges are valid, anchors can be found, etc.
    /// </summary>
    /// <param name="filePath">Target file path</param>
    /// <param name="options">Options to validate</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>Validation result with any issues found</returns>
    Task<SnippetOptionsValidationResult> ValidateOptionsAsync(
        string filePath,
        SnippetApplyOptions options,
        CancellationToken cancellationToken = default);
}
```

### 2. SnippetApplyService Implementation

```csharp
// src/SeniorIntern.Services/SnippetApplyService.cs
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using System.Text;
using System.Text.RegularExpressions;

namespace SeniorIntern.Services;

/// <summary>
/// Service for applying code snippets to specific file locations.
/// Coordinates with diff, backup, and settings services for safe operations.
/// </summary>
public sealed class SnippetApplyService : ISnippetApplyService
{
    private readonly IDiffService _diffService;
    private readonly IBackupService _backupService;
    private readonly ISettingsService _settingsService;
    private readonly ILogger<SnippetApplyService>? _logger;

    // Regex patterns for code structure detection
    private static readonly Regex MethodPattern = new(
        @"^\s*(public|private|protected|internal|static|async|override|virtual|sealed|abstract)*\s*[\w<>\[\],\s]+\s+\w+\s*\(",
        RegexOptions.Compiled);

    private static readonly Regex ClassPattern = new(
        @"^\s*(public|private|protected|internal|static|sealed|abstract|partial)*\s*(class|interface|struct|record|enum)\s+\w+",
        RegexOptions.Compiled);

    private static readonly Regex PropertyPattern = new(
        @"^\s*(public|private|protected|internal|static|virtual|override|abstract)*\s*[\w<>\[\],\?\s]+\s+\w+\s*\{",
        RegexOptions.Compiled);

    public SnippetApplyService(
        IDiffService diffService,
        IBackupService backupService,
        ISettingsService settingsService,
        ILogger<SnippetApplyService>? logger = null)
    {
        _diffService = diffService ?? throw new ArgumentNullException(nameof(diffService));
        _backupService = backupService ?? throw new ArgumentNullException(nameof(backupService));
        _settingsService = settingsService ?? throw new ArgumentNullException(nameof(settingsService));
        _logger = logger;
    }

    public async Task<SnippetApplyResult> ApplySnippetAsync(
        string filePath,
        string snippetContent,
        SnippetApplyOptions options,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(filePath);
        ArgumentNullException.ThrowIfNull(snippetContent);
        ArgumentNullException.ThrowIfNull(options);

        if (!options.IsValid)
        {
            _logger?.LogWarning("Invalid snippet apply options for {FilePath}", filePath);
            return SnippetApplyResult.Failed(filePath, "Invalid snippet apply options");
        }

        try
        {
            // Validate options against actual file
            var validation = await ValidateOptionsAsync(filePath, options, cancellationToken);
            if (!validation.IsValid)
            {
                var errors = string.Join("; ", validation.Issues.Select(i => i.Message));
                return SnippetApplyResult.Failed(filePath, $"Validation failed: {errors}");
            }

            // Generate preview to compute result
            var preview = await PreviewSnippetAsync(filePath, snippetContent, options, cancellationToken);

            // Create backup if enabled
            var settings = await _settingsService.GetSettingsAsync(cancellationToken);
            string? backupPath = null;

            if (settings.CreateBackupBeforeApply && File.Exists(filePath))
            {
                try
                {
                    backupPath = await _backupService.CreateBackupAsync(filePath, cancellationToken);
                    _logger?.LogDebug("Created backup at {BackupPath}", backupPath);
                }
                catch (Exception ex)
                {
                    _logger?.LogWarning(ex, "Failed to create backup for {FilePath}", filePath);
                    if (settings.RequireBackupSuccess)
                    {
                        throw new SnippetApplyException(
                            filePath,
                            SnippetApplyOperation.Backup,
                            "Failed to create required backup",
                            ex);
                    }
                }
            }

            // Ensure directory exists for new files
            var directory = Path.GetDirectoryName(filePath);
            if (!string.IsNullOrEmpty(directory) && !Directory.Exists(directory))
            {
                Directory.CreateDirectory(directory);
                _logger?.LogDebug("Created directory {Directory}", directory);
            }

            // Write the result
            await File.WriteAllTextAsync(filePath, preview.ResultContent, cancellationToken);
            _logger?.LogInformation(
                "Applied snippet to {FilePath}: {LinesAdded} added, {LinesRemoved} removed",
                filePath, preview.LinesAdded, preview.LinesRemoved);

            return SnippetApplyResult.Succeeded(
                filePath,
                options,
                backupPath,
                linesModified: preview.AffectedRange.LineCount,
                linesAdded: preview.LinesAdded,
                linesRemoved: preview.LinesRemoved,
                diff: preview.Diff);
        }
        catch (SnippetApplyException)
        {
            throw;
        }
        catch (OperationCanceledException)
        {
            throw;
        }
        catch (Exception ex)
        {
            _logger?.LogError(ex, "Failed to apply snippet to {FilePath}", filePath);
            return SnippetApplyResult.Failed(filePath, ex.Message);
        }
    }

    public async Task<SnippetApplyPreview> PreviewSnippetAsync(
        string filePath,
        string snippetContent,
        SnippetApplyOptions options,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(filePath);
        ArgumentNullException.ThrowIfNull(snippetContent);
        ArgumentNullException.ThrowIfNull(options);

        var originalContent = File.Exists(filePath)
            ? await File.ReadAllTextAsync(filePath, cancellationToken)
            : string.Empty;

        var originalLines = SplitLines(originalContent);
        var snippetLines = SplitLines(snippetContent);

        // Normalize line endings if requested
        if (options.NormalizeLineEndings)
        {
            snippetLines = NormalizeLineEndings(snippetLines);
        }

        // Trim trailing whitespace if requested
        if (options.TrimTrailingWhitespace)
        {
            snippetLines = TrimTrailingWhitespace(snippetLines);
        }

        // Resolve anchor to concrete line numbers if specified
        var resolvedOptions = options;
        if (options.Anchor is not null)
        {
            var context = new SnippetContext(filePath, originalContent);
            var anchorMatch = options.Anchor.FindInContent(context);

            if (anchorMatch is null || !anchorMatch.IsMatch)
            {
                return new SnippetApplyPreview
                {
                    ResultContent = originalContent,
                    Diff = DiffResult.Empty(filePath),
                    AffectedRange = LineRange.Empty,
                    LinesAdded = 0,
                    LinesRemoved = 0,
                    Warnings = new[] { $"Anchor not found: {options.Anchor.Pattern}" }
                };
            }

            resolvedOptions = options.WithResolvedAnchor(anchorMatch);
        }

        // Adjust indentation if needed
        if (resolvedOptions.PreserveIndentation && resolvedOptions.TargetLine.HasValue)
        {
            var targetIndent = GetLineIndentation(originalLines, resolvedOptions.TargetLine.Value);
            snippetLines = AdjustIndentation(snippetLines, targetIndent, resolvedOptions.IndentationOverride);
        }

        // Apply the insert/replace operation
        var (resultLines, affectedRange) = ApplyOperation(originalLines, snippetLines, resolvedOptions);

        // Add blank lines if requested
        if (resolvedOptions.AddBlankLineBefore && affectedRange.StartLine > 1)
        {
            var insertIndex = affectedRange.StartLine - 1;
            if (insertIndex >= 0 && insertIndex < resultLines.Count)
            {
                // Only add if previous line is not already blank
                if (insertIndex > 0 && !string.IsNullOrWhiteSpace(resultLines[insertIndex - 1]))
                {
                    resultLines.Insert(insertIndex, string.Empty);
                    affectedRange = new LineRange(affectedRange.StartLine + 1, affectedRange.EndLine + 1);
                }
            }
        }

        if (resolvedOptions.AddBlankLineAfter && affectedRange.EndLine <= resultLines.Count)
        {
            var insertIndex = affectedRange.EndLine;
            if (insertIndex < resultLines.Count)
            {
                // Only add if next line is not already blank
                if (!string.IsNullOrWhiteSpace(resultLines[insertIndex]))
                {
                    resultLines.Insert(insertIndex, string.Empty);
                }
            }
        }

        var resultContent = JoinLines(resultLines);

        // Compute diff
        var diff = _diffService.ComputeDiff(originalContent, resultContent, filePath);

        // Calculate line changes
        var linesAdded = snippetLines.Count;
        var linesRemoved = resolvedOptions.InsertMode switch
        {
            SnippetInsertMode.Replace => resolvedOptions.ReplaceRange?.LineCount ?? 0,
            SnippetInsertMode.ReplaceFile => originalLines.Count,
            _ => 0
        };

        // Collect warnings
        var warnings = new List<string>();
        if (resolvedOptions.ReplaceRange.HasValue &&
            resolvedOptions.ReplaceRange.Value.EndLine > originalLines.Count)
        {
            warnings.Add(
                $"Replace range extends beyond end of file (file has {originalLines.Count} lines)");
        }

        if (snippetLines.Count == 0)
        {
            warnings.Add("Snippet content is empty");
        }

        return new SnippetApplyPreview
        {
            ResultContent = resultContent,
            Diff = diff,
            AffectedRange = affectedRange,
            LinesAdded = linesAdded,
            LinesRemoved = linesRemoved,
            Warnings = warnings
        };
    }

    public async Task<IndentationStyle> DetectIndentationAsync(
        string filePath,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(filePath);

        if (!File.Exists(filePath))
        {
            _logger?.LogDebug("File does not exist, returning default indentation: {FilePath}", filePath);
            return IndentationStyle.Default;
        }

        var content = await File.ReadAllTextAsync(filePath, cancellationToken);
        return DetectIndentationFromContent(content);
    }

    public async Task<SnippetLocationSuggestion?> SuggestLocationAsync(
        string filePath,
        string snippetContent,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(filePath);
        ArgumentNullException.ThrowIfNull(snippetContent);

        // New file - suggest creating it
        if (!File.Exists(filePath))
        {
            return new SnippetLocationSuggestion
            {
                SuggestedMode = SnippetInsertMode.ReplaceFile,
                Confidence = 1.0,
                Reason = "File does not exist - will create new file"
            };
        }

        var fileContent = await File.ReadAllTextAsync(filePath, cancellationToken);
        var fileLines = SplitLines(fileContent);
        var snippetLines = SplitLines(snippetContent);

        var firstMeaningfulLine = snippetLines.FirstOrDefault(l => !string.IsNullOrWhiteSpace(l));
        if (firstMeaningfulLine is null)
        {
            return null;
        }

        // Try to detect what kind of code the snippet contains
        var suggestion = TryMatchMethod(fileLines, firstMeaningfulLine)
                      ?? TryMatchClass(fileLines, firstMeaningfulLine)
                      ?? TryMatchProperty(fileLines, firstMeaningfulLine)
                      ?? SuggestDefaultLocation(fileLines);

        return suggestion;
    }

    public async Task<SnippetOptionsValidationResult> ValidateOptionsAsync(
        string filePath,
        SnippetApplyOptions options,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(filePath);
        ArgumentNullException.ThrowIfNull(options);

        var issues = new List<SnippetOptionsValidationIssue>();

        // Basic options validation
        if (!options.IsValid)
        {
            issues.Add(new SnippetOptionsValidationIssue(
                SnippetOptionsValidationSeverity.Error,
                "Options are not valid - check InsertMode and required properties"));
        }

        // File-specific validation
        if (!File.Exists(filePath))
        {
            // For non-existent files, only ReplaceFile and Append modes make sense
            if (options.InsertMode != SnippetInsertMode.ReplaceFile &&
                options.InsertMode != SnippetInsertMode.Append)
            {
                issues.Add(new SnippetOptionsValidationIssue(
                    SnippetOptionsValidationSeverity.Warning,
                    $"File does not exist. InsertMode '{options.InsertMode}' will be treated as ReplaceFile."));
            }
        }
        else
        {
            var content = await File.ReadAllTextAsync(filePath, cancellationToken);
            var lineCount = SplitLines(content).Count;

            // Validate line numbers
            if (options.TargetLine.HasValue)
            {
                if (options.TargetLine.Value < 1)
                {
                    issues.Add(new SnippetOptionsValidationIssue(
                        SnippetOptionsValidationSeverity.Error,
                        "Target line must be >= 1"));
                }
                else if (options.TargetLine.Value > lineCount + 1)
                {
                    issues.Add(new SnippetOptionsValidationIssue(
                        SnippetOptionsValidationSeverity.Warning,
                        $"Target line {options.TargetLine.Value} exceeds file length ({lineCount} lines)"));
                }
            }

            // Validate replace range
            if (options.ReplaceRange.HasValue)
            {
                var range = options.ReplaceRange.Value;
                if (!range.IsValid)
                {
                    issues.Add(new SnippetOptionsValidationIssue(
                        SnippetOptionsValidationSeverity.Error,
                        "Replace range is invalid"));
                }
                else if (range.StartLine > lineCount)
                {
                    issues.Add(new SnippetOptionsValidationIssue(
                        SnippetOptionsValidationSeverity.Error,
                        $"Replace range start ({range.StartLine}) exceeds file length ({lineCount} lines)"));
                }
                else if (range.EndLine > lineCount)
                {
                    issues.Add(new SnippetOptionsValidationIssue(
                        SnippetOptionsValidationSeverity.Warning,
                        $"Replace range end ({range.EndLine}) exceeds file length ({lineCount} lines) - will be clamped"));
                }
            }

            // Validate anchor if present
            if (options.Anchor is not null)
            {
                var context = new SnippetContext(filePath, content);
                var match = options.Anchor.FindInContent(context);

                if (match is null || !match.IsMatch)
                {
                    issues.Add(new SnippetOptionsValidationIssue(
                        SnippetOptionsValidationSeverity.Error,
                        $"Anchor pattern not found: {options.Anchor.Pattern}"));
                }
            }
        }

        return new SnippetOptionsValidationResult(issues);
    }

    #region Private Helper Methods

    private static List<string> SplitLines(string content)
    {
        if (string.IsNullOrEmpty(content))
            return new List<string>();

        // Normalize to \n first, then split
        return content.Replace("\r\n", "\n").Replace("\r", "\n").Split('\n').ToList();
    }

    private static string JoinLines(List<string> lines)
    {
        return string.Join('\n', lines);
    }

    private static List<string> NormalizeLineEndings(List<string> lines)
    {
        // Lines are already split by \n, so just ensure no \r remains
        return lines.Select(l => l.TrimEnd('\r')).ToList();
    }

    private static List<string> TrimTrailingWhitespace(List<string> lines)
    {
        return lines.Select(l => l.TrimEnd()).ToList();
    }

    private static string GetLineIndentation(List<string> lines, int lineNumber)
    {
        if (lineNumber <= 0 || lineNumber > lines.Count)
            return string.Empty;

        var line = lines[lineNumber - 1];
        var indent = new string(line.TakeWhile(char.IsWhiteSpace).ToArray());
        return indent;
    }

    private static List<string> AdjustIndentation(
        List<string> lines,
        string targetIndent,
        string? indentOverride)
    {
        if (lines.Count == 0)
            return lines;

        // Find minimum indentation in snippet (baseline)
        var minIndent = lines
            .Where(l => !string.IsNullOrWhiteSpace(l))
            .Select(l => new string(l.TakeWhile(char.IsWhiteSpace).ToArray()))
            .OrderBy(i => i.Length)
            .FirstOrDefault() ?? string.Empty;

        var effectiveIndent = indentOverride ?? targetIndent;

        return lines.Select(line =>
        {
            if (string.IsNullOrWhiteSpace(line))
                return line;

            if (line.StartsWith(minIndent))
            {
                // Replace base indent with target, preserving additional indent
                return effectiveIndent + line[minIndent.Length..];
            }

            // Line has less indent than min - just prepend target
            return effectiveIndent + line;
        }).ToList();
    }

    private static (List<string> ResultLines, LineRange AffectedRange) ApplyOperation(
        List<string> originalLines,
        List<string> snippetLines,
        SnippetApplyOptions options)
    {
        var result = new List<string>(originalLines);
        LineRange affectedRange;

        switch (options.InsertMode)
        {
            case SnippetInsertMode.ReplaceFile:
                result = new List<string>(snippetLines);
                affectedRange = snippetLines.Count > 0
                    ? new LineRange(1, snippetLines.Count)
                    : LineRange.Empty;
                break;

            case SnippetInsertMode.Replace:
                var range = options.ReplaceRange!.Value;
                var startIdx = Math.Max(0, range.StartLine - 1);
                var endIdx = Math.Min(result.Count, range.EndLine);
                var removeCount = Math.Max(0, endIdx - startIdx);

                if (removeCount > 0)
                {
                    result.RemoveRange(startIdx, removeCount);
                }
                result.InsertRange(startIdx, snippetLines);

                affectedRange = snippetLines.Count > 0
                    ? new LineRange(range.StartLine, range.StartLine + snippetLines.Count - 1)
                    : LineRange.Empty;
                break;

            case SnippetInsertMode.InsertBefore:
                var beforeIdx = Math.Max(0, options.TargetLine!.Value - 1);
                result.InsertRange(beforeIdx, snippetLines);
                affectedRange = snippetLines.Count > 0
                    ? new LineRange(options.TargetLine.Value, options.TargetLine.Value + snippetLines.Count - 1)
                    : LineRange.Empty;
                break;

            case SnippetInsertMode.InsertAfter:
                var afterIdx = Math.Min(result.Count, options.TargetLine!.Value);
                result.InsertRange(afterIdx, snippetLines);
                affectedRange = snippetLines.Count > 0
                    ? new LineRange(options.TargetLine.Value + 1, options.TargetLine.Value + snippetLines.Count)
                    : LineRange.Empty;
                break;

            case SnippetInsertMode.Append:
                var appendStart = result.Count + 1;
                result.AddRange(snippetLines);
                affectedRange = snippetLines.Count > 0
                    ? new LineRange(appendStart, appendStart + snippetLines.Count - 1)
                    : LineRange.Empty;
                break;

            case SnippetInsertMode.Prepend:
                result.InsertRange(0, snippetLines);
                affectedRange = snippetLines.Count > 0
                    ? new LineRange(1, snippetLines.Count)
                    : LineRange.Empty;
                break;

            default:
                throw new ArgumentException($"Unknown insert mode: {options.InsertMode}");
        }

        return (result, affectedRange);
    }

    private IndentationStyle DetectIndentationFromContent(string content)
    {
        var lines = SplitLines(content);

        int tabCount = 0;
        int spaceCount = 0;
        var spaceIndents = new Dictionary<int, int>();

        foreach (var line in lines)
        {
            if (string.IsNullOrWhiteSpace(line))
                continue;

            var leadingWhitespace = line.TakeWhile(char.IsWhiteSpace).ToArray();
            if (leadingWhitespace.Length == 0)
                continue;

            if (leadingWhitespace[0] == '\t')
            {
                tabCount++;
            }
            else if (leadingWhitespace[0] == ' ')
            {
                spaceCount++;
                var spaceLen = leadingWhitespace.TakeWhile(c => c == ' ').Count();
                if (!spaceIndents.TryGetValue(spaceLen, out var existing))
                {
                    spaceIndents[spaceLen] = 0;
                }
                spaceIndents[spaceLen]++;
            }
        }

        var total = tabCount + spaceCount;
        if (total == 0)
        {
            return IndentationStyle.Default;
        }

        if (tabCount > spaceCount)
        {
            return new IndentationStyle
            {
                UseTabs = true,
                Confidence = tabCount / (double)total
            };
        }

        // Detect spaces per indent using GCD
        var spacesPerIndent = 4;
        if (spaceIndents.Count > 0)
        {
            var indentLevels = spaceIndents.Keys.Where(k => k > 0).ToList();
            if (indentLevels.Count > 0)
            {
                spacesPerIndent = indentLevels.Aggregate(GCD);
                if (spacesPerIndent <= 0 || spacesPerIndent > 8)
                {
                    spacesPerIndent = 4;
                }
            }
        }

        return new IndentationStyle
        {
            UseTabs = false,
            SpacesPerIndent = spacesPerIndent,
            Confidence = spaceCount / (double)(total + 1)
        };
    }

    private SnippetLocationSuggestion? TryMatchMethod(List<string> fileLines, string snippetFirstLine)
    {
        if (!MethodPattern.IsMatch(snippetFirstLine))
            return null;

        // Look for similar method in the file to replace
        for (int i = 0; i < fileLines.Count; i++)
        {
            if (MethodPattern.IsMatch(fileLines[i]))
            {
                // Extract method name from both
                var snippetMethodName = ExtractMethodName(snippetFirstLine);
                var fileMethodName = ExtractMethodName(fileLines[i]);

                if (snippetMethodName is not null &&
                    snippetMethodName.Equals(fileMethodName, StringComparison.Ordinal))
                {
                    // Found matching method - suggest replacing it
                    var methodEnd = FindMethodEnd(fileLines, i);
                    return new SnippetLocationSuggestion
                    {
                        SuggestedMode = SnippetInsertMode.Replace,
                        SuggestedRange = new LineRange(i + 1, methodEnd + 1),
                        Confidence = 0.85,
                        Reason = $"Found existing method '{fileMethodName}' to replace",
                        MatchedContext = fileLines[i].Trim()
                    };
                }
            }
        }

        // No matching method - suggest inserting before closing brace
        var lastBraceIndex = FindLastClosingBrace(fileLines);
        if (lastBraceIndex > 0)
        {
            return new SnippetLocationSuggestion
            {
                SuggestedMode = SnippetInsertMode.InsertBefore,
                SuggestedLine = lastBraceIndex + 1,
                Confidence = 0.5,
                Reason = "Insert new method before closing brace"
            };
        }

        return null;
    }

    private SnippetLocationSuggestion? TryMatchClass(List<string> fileLines, string snippetFirstLine)
    {
        if (!ClassPattern.IsMatch(snippetFirstLine))
            return null;

        // For classes, typically append at end of file
        return new SnippetLocationSuggestion
        {
            SuggestedMode = SnippetInsertMode.Append,
            Confidence = 0.6,
            Reason = "New class/interface - append to end of file"
        };
    }

    private SnippetLocationSuggestion? TryMatchProperty(List<string> fileLines, string snippetFirstLine)
    {
        if (!PropertyPattern.IsMatch(snippetFirstLine))
            return null;

        // Look for properties section in the file
        for (int i = 0; i < fileLines.Count; i++)
        {
            if (PropertyPattern.IsMatch(fileLines[i]))
            {
                // Found a property - suggest inserting after the last property
                var lastPropertyLine = i;
                for (int j = i + 1; j < fileLines.Count; j++)
                {
                    if (PropertyPattern.IsMatch(fileLines[j]))
                    {
                        lastPropertyLine = j;
                    }
                    else if (MethodPattern.IsMatch(fileLines[j]))
                    {
                        break; // Stop at methods
                    }
                }

                // Find end of last property (closing brace)
                var propertyEnd = FindPropertyEnd(fileLines, lastPropertyLine);

                return new SnippetLocationSuggestion
                {
                    SuggestedMode = SnippetInsertMode.InsertAfter,
                    SuggestedLine = propertyEnd + 1,
                    Confidence = 0.65,
                    Reason = "Insert after existing properties"
                };
            }
        }

        return null;
    }

    private static SnippetLocationSuggestion SuggestDefaultLocation(List<string> fileLines)
    {
        return new SnippetLocationSuggestion
        {
            SuggestedMode = SnippetInsertMode.Append,
            Confidence = 0.3,
            Reason = "No specific location detected - appending to end"
        };
    }

    private static string? ExtractMethodName(string line)
    {
        // Simple extraction - find word before opening paren
        var parenIndex = line.IndexOf('(');
        if (parenIndex <= 0)
            return null;

        var beforeParen = line[..parenIndex].TrimEnd();
        var lastSpace = beforeParen.LastIndexOf(' ');
        if (lastSpace < 0)
            return beforeParen;

        return beforeParen[(lastSpace + 1)..];
    }

    private static int FindMethodEnd(List<string> lines, int startLine)
    {
        int braceCount = 0;
        bool foundOpenBrace = false;

        for (int i = startLine; i < lines.Count; i++)
        {
            foreach (var c in lines[i])
            {
                if (c == '{')
                {
                    braceCount++;
                    foundOpenBrace = true;
                }
                else if (c == '}')
                {
                    braceCount--;
                    if (foundOpenBrace && braceCount == 0)
                        return i;
                }
            }
        }

        return lines.Count - 1;
    }

    private static int FindPropertyEnd(List<string> lines, int startLine)
    {
        // Properties can be auto-properties (single line) or have getters/setters
        int braceCount = 0;
        bool foundOpenBrace = false;

        for (int i = startLine; i < lines.Count; i++)
        {
            foreach (var c in lines[i])
            {
                if (c == '{')
                {
                    braceCount++;
                    foundOpenBrace = true;
                }
                else if (c == '}')
                {
                    braceCount--;
                    if (foundOpenBrace && braceCount == 0)
                        return i;
                }
            }
        }

        return startLine;
    }

    private static int FindLastClosingBrace(List<string> lines)
    {
        for (int i = lines.Count - 1; i >= 0; i--)
        {
            if (lines[i].Trim() == "}")
                return i;
        }
        return -1;
    }

    private static int GCD(int a, int b)
    {
        while (b != 0)
        {
            var temp = b;
            b = a % b;
            a = temp;
        }
        return Math.Abs(a);
    }

    #endregion
}
```

### 3. SnippetApplyResult Model

```csharp
// src/SeniorIntern.Core/Models/SnippetApplyResult.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Result of applying a code snippet to a file.
/// Includes success/failure status, metrics, and optional backup information.
/// </summary>
public sealed record SnippetApplyResult
{
    /// <summary>
    /// Indicates whether the snippet was successfully applied.
    /// </summary>
    public required bool IsSuccess { get; init; }

    /// <summary>
    /// The file path that was modified (or would have been modified on failure).
    /// </summary>
    public required string FilePath { get; init; }

    /// <summary>
    /// The options that were used to apply the snippet.
    /// Null on validation failures before apply.
    /// </summary>
    public SnippetApplyOptions? Options { get; init; }

    /// <summary>
    /// Path to the backup file created before applying changes.
    /// Null if backup was disabled or file didn't exist.
    /// </summary>
    public string? BackupPath { get; init; }

    /// <summary>
    /// Number of lines in the affected range.
    /// </summary>
    public int LinesModified { get; init; }

    /// <summary>
    /// Number of new lines added to the file.
    /// </summary>
    public int LinesAdded { get; init; }

    /// <summary>
    /// Number of lines removed from the file.
    /// </summary>
    public int LinesRemoved { get; init; }

    /// <summary>
    /// The computed diff between original and result.
    /// Null on failure.
    /// </summary>
    public DiffResult? Diff { get; init; }

    /// <summary>
    /// Error message if the apply operation failed.
    /// Null on success.
    /// </summary>
    public string? ErrorMessage { get; init; }

    /// <summary>
    /// Timestamp when the snippet was applied.
    /// </summary>
    public DateTime AppliedAt { get; init; } = DateTime.UtcNow;

    /// <summary>
    /// Net change in file line count (added - removed).
    /// </summary>
    public int NetLineChange => LinesAdded - LinesRemoved;

    /// <summary>
    /// Indicates whether a backup was created.
    /// </summary>
    public bool HasBackup => !string.IsNullOrEmpty(BackupPath);

    /// <summary>
    /// Creates a successful apply result.
    /// </summary>
    public static SnippetApplyResult Succeeded(
        string filePath,
        SnippetApplyOptions options,
        string? backupPath,
        int linesModified,
        int linesAdded,
        int linesRemoved,
        DiffResult? diff = null)
    {
        return new SnippetApplyResult
        {
            IsSuccess = true,
            FilePath = filePath,
            Options = options,
            BackupPath = backupPath,
            LinesModified = linesModified,
            LinesAdded = linesAdded,
            LinesRemoved = linesRemoved,
            Diff = diff,
            AppliedAt = DateTime.UtcNow
        };
    }

    /// <summary>
    /// Creates a failed apply result.
    /// </summary>
    public static SnippetApplyResult Failed(string filePath, string errorMessage)
    {
        return new SnippetApplyResult
        {
            IsSuccess = false,
            FilePath = filePath,
            ErrorMessage = errorMessage,
            AppliedAt = DateTime.UtcNow
        };
    }
}
```

### 4. SnippetApplyPreview Model

```csharp
// src/SeniorIntern.Core/Models/SnippetApplyPreview.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Preview of applying a snippet without actually modifying the file.
/// Contains the result content, diff, and any warnings.
/// </summary>
public sealed record SnippetApplyPreview
{
    /// <summary>
    /// The content that would result from applying the snippet.
    /// </summary>
    public required string ResultContent { get; init; }

    /// <summary>
    /// The diff between original and result content.
    /// </summary>
    public required DiffResult Diff { get; init; }

    /// <summary>
    /// The range of lines affected by the snippet application.
    /// </summary>
    public required LineRange AffectedRange { get; init; }

    /// <summary>
    /// Number of lines added by the snippet.
    /// </summary>
    public required int LinesAdded { get; init; }

    /// <summary>
    /// Number of lines removed by the snippet.
    /// </summary>
    public required int LinesRemoved { get; init; }

    /// <summary>
    /// Warnings generated during preview (e.g., range extends beyond EOF).
    /// </summary>
    public IReadOnlyList<string> Warnings { get; init; } = Array.Empty<string>();

    /// <summary>
    /// Indicates whether the preview is valid (no critical issues).
    /// </summary>
    public bool IsValid => !Warnings.Any(w => w.Contains("error", StringComparison.OrdinalIgnoreCase));

    /// <summary>
    /// Net change in line count.
    /// </summary>
    public int NetLineChange => LinesAdded - LinesRemoved;

    /// <summary>
    /// Indicates whether there are any warnings.
    /// </summary>
    public bool HasWarnings => Warnings.Count > 0;

    /// <summary>
    /// Indicates whether there are any changes.
    /// </summary>
    public bool HasChanges => Diff.HasChanges;

    /// <summary>
    /// Total number of lines in the result content.
    /// </summary>
    public int ResultLineCount =>
        string.IsNullOrEmpty(ResultContent) ? 0 : ResultContent.Split('\n').Length;
}
```

### 5. SnippetLocationSuggestion Model

```csharp
// src/SeniorIntern.Core/Models/SnippetLocationSuggestion.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Suggestion for where to insert a code snippet in a file.
/// Generated by analyzing the snippet and file content.
/// </summary>
public sealed record SnippetLocationSuggestion
{
    /// <summary>
    /// The suggested insert mode based on analysis.
    /// </summary>
    public required SnippetInsertMode SuggestedMode { get; init; }

    /// <summary>
    /// The suggested target line for InsertBefore/InsertAfter modes.
    /// </summary>
    public int? SuggestedLine { get; init; }

    /// <summary>
    /// The suggested range for Replace mode.
    /// </summary>
    public LineRange? SuggestedRange { get; init; }

    /// <summary>
    /// Confidence score for this suggestion (0.0 to 1.0).
    /// Higher values indicate more certainty.
    /// </summary>
    public required double Confidence { get; init; }

    /// <summary>
    /// Human-readable explanation for the suggestion.
    /// </summary>
    public required string Reason { get; init; }

    /// <summary>
    /// The matched context in the file that influenced this suggestion.
    /// For example, the method signature that matched.
    /// </summary>
    public string? MatchedContext { get; init; }

    /// <summary>
    /// Indicates whether this is a high-confidence suggestion (>= 0.7).
    /// </summary>
    public bool IsHighConfidence => Confidence >= 0.7;

    /// <summary>
    /// Indicates whether this is a low-confidence suggestion (< 0.4).
    /// </summary>
    public bool IsLowConfidence => Confidence < 0.4;

    /// <summary>
    /// Converts this suggestion to SnippetApplyOptions.
    /// </summary>
    /// <param name="preserveIndentation">Whether to preserve indentation</param>
    /// <returns>Apply options configured according to this suggestion</returns>
    public SnippetApplyOptions ToApplyOptions(bool preserveIndentation = true)
    {
        return SuggestedMode switch
        {
            SnippetInsertMode.Replace when SuggestedRange.HasValue =>
                SnippetApplyOptions.ReplaceLines(
                    SuggestedRange.Value.StartLine,
                    SuggestedRange.Value.EndLine) with
                {
                    PreserveIndentation = preserveIndentation
                },

            SnippetInsertMode.InsertBefore when SuggestedLine.HasValue =>
                SnippetApplyOptions.InsertBeforeLine(SuggestedLine.Value) with
                {
                    PreserveIndentation = preserveIndentation
                },

            SnippetInsertMode.InsertAfter when SuggestedLine.HasValue =>
                SnippetApplyOptions.InsertAfterLine(SuggestedLine.Value) with
                {
                    PreserveIndentation = preserveIndentation
                },

            SnippetInsertMode.Append =>
                SnippetApplyOptions.AppendToFile with
                {
                    PreserveIndentation = preserveIndentation
                },

            SnippetInsertMode.Prepend =>
                SnippetApplyOptions.PrependToFile with
                {
                    PreserveIndentation = preserveIndentation
                },

            SnippetInsertMode.ReplaceFile =>
                SnippetApplyOptions.FullReplace,

            _ => SnippetApplyOptions.AppendToFile
        };
    }
}
```

### 6. Validation Models

```csharp
// src/SeniorIntern.Core/Models/SnippetOptionsValidation.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Result of validating snippet apply options against a file.
/// </summary>
public sealed record SnippetOptionsValidationResult
{
    private readonly IReadOnlyList<SnippetOptionsValidationIssue> _issues;

    public SnippetOptionsValidationResult(IEnumerable<SnippetOptionsValidationIssue> issues)
    {
        _issues = issues.ToList();
    }

    /// <summary>
    /// All validation issues found.
    /// </summary>
    public IReadOnlyList<SnippetOptionsValidationIssue> Issues => _issues;

    /// <summary>
    /// Indicates whether the options are valid (no errors).
    /// </summary>
    public bool IsValid => !_issues.Any(i => i.Severity == SnippetOptionsValidationSeverity.Error);

    /// <summary>
    /// Indicates whether there are any warnings.
    /// </summary>
    public bool HasWarnings => _issues.Any(i => i.Severity == SnippetOptionsValidationSeverity.Warning);

    /// <summary>
    /// Gets all error issues.
    /// </summary>
    public IEnumerable<SnippetOptionsValidationIssue> Errors =>
        _issues.Where(i => i.Severity == SnippetOptionsValidationSeverity.Error);

    /// <summary>
    /// Gets all warning issues.
    /// </summary>
    public IEnumerable<SnippetOptionsValidationIssue> Warnings =>
        _issues.Where(i => i.Severity == SnippetOptionsValidationSeverity.Warning);

    /// <summary>
    /// Creates a valid result with no issues.
    /// </summary>
    public static SnippetOptionsValidationResult Valid =>
        new(Array.Empty<SnippetOptionsValidationIssue>());
}

/// <summary>
/// A single validation issue.
/// </summary>
public sealed record SnippetOptionsValidationIssue(
    SnippetOptionsValidationSeverity Severity,
    string Message);

/// <summary>
/// Severity level for validation issues.
/// </summary>
public enum SnippetOptionsValidationSeverity
{
    /// <summary>
    /// Informational message, does not affect validity.
    /// </summary>
    Info,

    /// <summary>
    /// Warning - operation can proceed but may have unexpected results.
    /// </summary>
    Warning,

    /// <summary>
    /// Error - operation cannot proceed.
    /// </summary>
    Error
}
```

### 7. SnippetApplyException

```csharp
// src/SeniorIntern.Core/Exceptions/SnippetApplyException.cs
namespace SeniorIntern.Core.Exceptions;

/// <summary>
/// Exception thrown when a snippet apply operation fails.
/// </summary>
public class SnippetApplyException : Exception
{
    /// <summary>
    /// The file path that was being modified.
    /// </summary>
    public string FilePath { get; }

    /// <summary>
    /// The operation that failed.
    /// </summary>
    public SnippetApplyOperation Operation { get; }

    /// <summary>
    /// Additional details about the failure.
    /// </summary>
    public string? InnerDetails { get; }

    public SnippetApplyException(
        string filePath,
        SnippetApplyOperation operation,
        string message,
        Exception? innerException = null)
        : base(message, innerException)
    {
        FilePath = filePath;
        Operation = operation;
    }

    public SnippetApplyException(
        string filePath,
        SnippetApplyOperation operation,
        string message,
        string innerDetails,
        Exception? innerException = null)
        : base(message, innerException)
    {
        FilePath = filePath;
        Operation = operation;
        InnerDetails = innerDetails;
    }
}

/// <summary>
/// The operation that caused a SnippetApplyException.
/// </summary>
public enum SnippetApplyOperation
{
    /// <summary>
    /// Options validation failed.
    /// </summary>
    Validation,

    /// <summary>
    /// Backup creation failed.
    /// </summary>
    Backup,

    /// <summary>
    /// Reading the original file failed.
    /// </summary>
    ReadFile,

    /// <summary>
    /// Writing the result failed.
    /// </summary>
    WriteFile,

    /// <summary>
    /// Indentation detection failed.
    /// </summary>
    IndentationDetection,

    /// <summary>
    /// Location suggestion failed.
    /// </summary>
    LocationSuggestion,

    /// <summary>
    /// Anchor resolution failed.
    /// </summary>
    AnchorResolution,

    /// <summary>
    /// Diff computation failed.
    /// </summary>
    DiffComputation
}
```

### 8. Service Registration

```csharp
// src/SeniorIntern.Services/ServiceCollectionExtensions.cs (additions)
using Microsoft.Extensions.DependencyInjection;
using SeniorIntern.Core.Interfaces;

namespace SeniorIntern.Services;

public static partial class ServiceCollectionExtensions
{
    /// <summary>
    /// Registers the snippet apply service and its dependencies.
    /// </summary>
    public static IServiceCollection AddSnippetApplyService(this IServiceCollection services)
    {
        // Register the service as a singleton for consistent state
        services.AddSingleton<ISnippetApplyService, SnippetApplyService>();

        return services;
    }
}
```

---

## Unit Tests

### SnippetApplyService Tests

```csharp
// tests/SeniorIntern.Services.Tests/SnippetApplyServiceTests.cs
using Moq;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using Xunit;

namespace SeniorIntern.Services.Tests;

public class SnippetApplyServiceTests : IDisposable
{
    private readonly Mock<IDiffService> _mockDiffService;
    private readonly Mock<IBackupService> _mockBackupService;
    private readonly Mock<ISettingsService> _mockSettingsService;
    private readonly SnippetApplyService _service;
    private readonly string _testDirectory;

    public SnippetApplyServiceTests()
    {
        _mockDiffService = new Mock<IDiffService>();
        _mockBackupService = new Mock<IBackupService>();
        _mockSettingsService = new Mock<ISettingsService>();

        _mockDiffService
            .Setup(x => x.ComputeDiff(It.IsAny<string>(), It.IsAny<string>(), It.IsAny<string>()))
            .Returns((string orig, string result, string path) =>
                new DiffResult { FilePath = path, HasChanges = orig != result });

        _mockSettingsService
            .Setup(x => x.GetSettingsAsync(It.IsAny<CancellationToken>()))
            .ReturnsAsync(new AppSettings { CreateBackupBeforeApply = false });

        _service = new SnippetApplyService(
            _mockDiffService.Object,
            _mockBackupService.Object,
            _mockSettingsService.Object);

        _testDirectory = Path.Combine(Path.GetTempPath(), $"SnippetApplyTests_{Guid.NewGuid():N}");
        Directory.CreateDirectory(_testDirectory);
    }

    public void Dispose()
    {
        if (Directory.Exists(_testDirectory))
        {
            Directory.Delete(_testDirectory, recursive: true);
        }
    }

    #region ApplySnippetAsync Tests

    [Fact]
    public async Task ApplySnippetAsync_ReplaceFile_CreatesNewFile()
    {
        // Arrange
        var filePath = Path.Combine(_testDirectory, "new_file.cs");
        var snippet = "public class Test { }";
        var options = SnippetApplyOptions.FullReplace;

        // Act
        var result = await _service.ApplySnippetAsync(filePath, snippet, options);

        // Assert
        Assert.True(result.IsSuccess);
        Assert.True(File.Exists(filePath));
        Assert.Equal(snippet, File.ReadAllText(filePath));
    }

    [Fact]
    public async Task ApplySnippetAsync_ReplaceLines_ModifiesCorrectRange()
    {
        // Arrange
        var filePath = Path.Combine(_testDirectory, "existing.cs");
        var original = "line1\nline2\nline3\nline4\nline5";
        File.WriteAllText(filePath, original);

        var snippet = "replaced2\nreplaced3";
        var options = SnippetApplyOptions.ReplaceLines(2, 3);

        // Act
        var result = await _service.ApplySnippetAsync(filePath, snippet, options);

        // Assert
        Assert.True(result.IsSuccess);
        var content = File.ReadAllText(filePath);
        Assert.Equal("line1\nreplaced2\nreplaced3\nline4\nline5", content);
        Assert.Equal(2, result.LinesAdded);
        Assert.Equal(2, result.LinesRemoved);
    }

    [Fact]
    public async Task ApplySnippetAsync_InsertAfter_AddsLinesCorrectly()
    {
        // Arrange
        var filePath = Path.Combine(_testDirectory, "insert_after.cs");
        var original = "line1\nline2\nline3";
        File.WriteAllText(filePath, original);

        var snippet = "inserted";
        var options = SnippetApplyOptions.InsertAfterLine(2);

        // Act
        var result = await _service.ApplySnippetAsync(filePath, snippet, options);

        // Assert
        Assert.True(result.IsSuccess);
        var content = File.ReadAllText(filePath);
        Assert.Equal("line1\nline2\ninserted\nline3", content);
        Assert.Equal(1, result.LinesAdded);
        Assert.Equal(0, result.LinesRemoved);
    }

    [Fact]
    public async Task ApplySnippetAsync_InsertBefore_AddsLinesCorrectly()
    {
        // Arrange
        var filePath = Path.Combine(_testDirectory, "insert_before.cs");
        var original = "line1\nline2\nline3";
        File.WriteAllText(filePath, original);

        var snippet = "inserted";
        var options = SnippetApplyOptions.InsertBeforeLine(2);

        // Act
        var result = await _service.ApplySnippetAsync(filePath, snippet, options);

        // Assert
        Assert.True(result.IsSuccess);
        var content = File.ReadAllText(filePath);
        Assert.Equal("line1\ninserted\nline2\nline3", content);
    }

    [Fact]
    public async Task ApplySnippetAsync_Append_AddsToEnd()
    {
        // Arrange
        var filePath = Path.Combine(_testDirectory, "append.cs");
        var original = "line1\nline2";
        File.WriteAllText(filePath, original);

        var snippet = "appended";
        var options = SnippetApplyOptions.AppendToFile;

        // Act
        var result = await _service.ApplySnippetAsync(filePath, snippet, options);

        // Assert
        Assert.True(result.IsSuccess);
        var content = File.ReadAllText(filePath);
        Assert.Equal("line1\nline2\nappended", content);
    }

    [Fact]
    public async Task ApplySnippetAsync_Prepend_AddsToBeginning()
    {
        // Arrange
        var filePath = Path.Combine(_testDirectory, "prepend.cs");
        var original = "line1\nline2";
        File.WriteAllText(filePath, original);

        var snippet = "prepended";
        var options = SnippetApplyOptions.PrependToFile;

        // Act
        var result = await _service.ApplySnippetAsync(filePath, snippet, options);

        // Assert
        Assert.True(result.IsSuccess);
        var content = File.ReadAllText(filePath);
        Assert.Equal("prepended\nline1\nline2", content);
    }

    [Fact]
    public async Task ApplySnippetAsync_InvalidOptions_ReturnsFailed()
    {
        // Arrange
        var filePath = Path.Combine(_testDirectory, "invalid.cs");
        var options = new SnippetApplyOptions
        {
            InsertMode = SnippetInsertMode.Replace,
            ReplaceRange = null // Invalid - Replace needs ReplaceRange
        };

        // Act
        var result = await _service.ApplySnippetAsync(filePath, "content", options);

        // Assert
        Assert.False(result.IsSuccess);
        Assert.Contains("Invalid", result.ErrorMessage);
    }

    [Fact]
    public async Task ApplySnippetAsync_WithBackup_CreatesBackup()
    {
        // Arrange
        var filePath = Path.Combine(_testDirectory, "with_backup.cs");
        var original = "original content";
        File.WriteAllText(filePath, original);

        _mockSettingsService
            .Setup(x => x.GetSettingsAsync(It.IsAny<CancellationToken>()))
            .ReturnsAsync(new AppSettings { CreateBackupBeforeApply = true });

        _mockBackupService
            .Setup(x => x.CreateBackupAsync(filePath, It.IsAny<CancellationToken>()))
            .ReturnsAsync(filePath + ".bak");

        var options = SnippetApplyOptions.FullReplace;

        // Act
        var result = await _service.ApplySnippetAsync(filePath, "new content", options);

        // Assert
        Assert.True(result.IsSuccess);
        Assert.Equal(filePath + ".bak", result.BackupPath);
        _mockBackupService.Verify(
            x => x.CreateBackupAsync(filePath, It.IsAny<CancellationToken>()),
            Times.Once);
    }

    #endregion

    #region PreviewSnippetAsync Tests

    [Fact]
    public async Task PreviewSnippetAsync_ReturnsPreviewWithoutModifyingFile()
    {
        // Arrange
        var filePath = Path.Combine(_testDirectory, "preview_test.cs");
        var original = "original";
        File.WriteAllText(filePath, original);

        var snippet = "new content";
        var options = SnippetApplyOptions.FullReplace;

        // Act
        var preview = await _service.PreviewSnippetAsync(filePath, snippet, options);

        // Assert
        Assert.Equal(snippet, preview.ResultContent);
        Assert.True(preview.HasChanges);
        Assert.Equal(original, File.ReadAllText(filePath)); // File unchanged
    }

    [Fact]
    public async Task PreviewSnippetAsync_ReportsCorrectLineChanges()
    {
        // Arrange
        var filePath = Path.Combine(_testDirectory, "line_changes.cs");
        var original = "line1\nline2\nline3";
        File.WriteAllText(filePath, original);

        var snippet = "new1\nnew2\nnew3\nnew4";
        var options = SnippetApplyOptions.ReplaceLines(1, 2);

        // Act
        var preview = await _service.PreviewSnippetAsync(filePath, snippet, options);

        // Assert
        Assert.Equal(4, preview.LinesAdded);
        Assert.Equal(2, preview.LinesRemoved);
        Assert.Equal(2, preview.NetLineChange);
    }

    [Fact]
    public async Task PreviewSnippetAsync_GeneratesWarningForRangeBeyondEOF()
    {
        // Arrange
        var filePath = Path.Combine(_testDirectory, "beyond_eof.cs");
        var original = "line1\nline2";
        File.WriteAllText(filePath, original);

        var options = SnippetApplyOptions.ReplaceLines(1, 10); // File only has 2 lines

        // Act
        var preview = await _service.PreviewSnippetAsync(filePath, "replacement", options);

        // Assert
        Assert.True(preview.HasWarnings);
        Assert.Contains(preview.Warnings, w => w.Contains("extends beyond"));
    }

    [Fact]
    public async Task PreviewSnippetAsync_PreservesIndentation()
    {
        // Arrange
        var filePath = Path.Combine(_testDirectory, "indent_test.cs");
        var original = "class Test\n{\n    void Method()\n    {\n    }\n}";
        File.WriteAllText(filePath, original);

        var snippet = "// Comment\nint x = 1;";
        var options = SnippetApplyOptions.InsertAfterLine(3) with
        {
            PreserveIndentation = true
        };

        // Act
        var preview = await _service.PreviewSnippetAsync(filePath, snippet, options);

        // Assert
        var lines = preview.ResultContent.Split('\n');
        // The inserted lines should have 4-space indent (same as line 3)
        Assert.StartsWith("    ", lines[3]); // First inserted line
        Assert.StartsWith("    ", lines[4]); // Second inserted line
    }

    #endregion

    #region DetectIndentationAsync Tests

    [Fact]
    public async Task DetectIndentationAsync_DetectsSpaces()
    {
        // Arrange
        var filePath = Path.Combine(_testDirectory, "spaces.cs");
        var content = "class Test\n{\n    void Method()\n    {\n        int x;\n    }\n}";
        File.WriteAllText(filePath, content);

        // Act
        var style = await _service.DetectIndentationAsync(filePath);

        // Assert
        Assert.False(style.UseTabs);
        Assert.Equal(4, style.SpacesPerIndent);
        Assert.True(style.Confidence > 0.5);
    }

    [Fact]
    public async Task DetectIndentationAsync_DetectsTabs()
    {
        // Arrange
        var filePath = Path.Combine(_testDirectory, "tabs.cs");
        var content = "class Test\n{\n\tvoid Method()\n\t{\n\t\tint x;\n\t}\n}";
        File.WriteAllText(filePath, content);

        // Act
        var style = await _service.DetectIndentationAsync(filePath);

        // Assert
        Assert.True(style.UseTabs);
        Assert.True(style.Confidence > 0.5);
    }

    [Fact]
    public async Task DetectIndentationAsync_ReturnsDefaultForNonexistentFile()
    {
        // Arrange
        var filePath = Path.Combine(_testDirectory, "nonexistent.cs");

        // Act
        var style = await _service.DetectIndentationAsync(filePath);

        // Assert
        Assert.Equal(IndentationStyle.Default, style);
    }

    [Fact]
    public async Task DetectIndentationAsync_DetectsTwoSpaces()
    {
        // Arrange
        var filePath = Path.Combine(_testDirectory, "two_spaces.js");
        var content = "function test() {\n  if (true) {\n    console.log('hi');\n  }\n}";
        File.WriteAllText(filePath, content);

        // Act
        var style = await _service.DetectIndentationAsync(filePath);

        // Assert
        Assert.False(style.UseTabs);
        Assert.Equal(2, style.SpacesPerIndent);
    }

    #endregion

    #region SuggestLocationAsync Tests

    [Fact]
    public async Task SuggestLocationAsync_NewFile_SuggestsReplaceFile()
    {
        // Arrange
        var filePath = Path.Combine(_testDirectory, "new_suggestion.cs");
        var snippet = "public class Test { }";

        // Act
        var suggestion = await _service.SuggestLocationAsync(filePath, snippet);

        // Assert
        Assert.NotNull(suggestion);
        Assert.Equal(SnippetInsertMode.ReplaceFile, suggestion.SuggestedMode);
        Assert.Equal(1.0, suggestion.Confidence);
    }

    [Fact]
    public async Task SuggestLocationAsync_MethodSnippet_SuggestsMethodLocation()
    {
        // Arrange
        var filePath = Path.Combine(_testDirectory, "class_file.cs");
        var content = @"public class Test
{
    public void ExistingMethod()
    {
    }
}";
        File.WriteAllText(filePath, content);

        var snippet = @"public void NewMethod()
{
    // Implementation
}";

        // Act
        var suggestion = await _service.SuggestLocationAsync(filePath, snippet);

        // Assert
        Assert.NotNull(suggestion);
        Assert.True(
            suggestion.SuggestedMode == SnippetInsertMode.InsertBefore ||
            suggestion.SuggestedMode == SnippetInsertMode.InsertAfter);
    }

    [Fact]
    public async Task SuggestLocationAsync_MatchingMethod_SuggestsReplace()
    {
        // Arrange
        var filePath = Path.Combine(_testDirectory, "replace_method.cs");
        var content = @"public class Test
{
    public void MyMethod()
    {
        // Old implementation
    }
}";
        File.WriteAllText(filePath, content);

        var snippet = @"public void MyMethod()
{
    // New implementation
}";

        // Act
        var suggestion = await _service.SuggestLocationAsync(filePath, snippet);

        // Assert
        Assert.NotNull(suggestion);
        Assert.Equal(SnippetInsertMode.Replace, suggestion.SuggestedMode);
        Assert.NotNull(suggestion.SuggestedRange);
        Assert.True(suggestion.Confidence >= 0.8);
    }

    [Fact]
    public async Task SuggestLocationAsync_EmptySnippet_ReturnsNull()
    {
        // Arrange
        var filePath = Path.Combine(_testDirectory, "empty_snippet.cs");
        File.WriteAllText(filePath, "some content");

        // Act
        var suggestion = await _service.SuggestLocationAsync(filePath, "   \n   \n   ");

        // Assert
        Assert.Null(suggestion);
    }

    #endregion

    #region ValidateOptionsAsync Tests

    [Fact]
    public async Task ValidateOptionsAsync_ValidOptions_ReturnsValid()
    {
        // Arrange
        var filePath = Path.Combine(_testDirectory, "validate_valid.cs");
        File.WriteAllText(filePath, "line1\nline2\nline3");

        var options = SnippetApplyOptions.ReplaceLines(1, 2);

        // Act
        var result = await _service.ValidateOptionsAsync(filePath, options);

        // Assert
        Assert.True(result.IsValid);
        Assert.Empty(result.Issues);
    }

    [Fact]
    public async Task ValidateOptionsAsync_RangeBeyondFile_ReturnsWarning()
    {
        // Arrange
        var filePath = Path.Combine(_testDirectory, "validate_range.cs");
        File.WriteAllText(filePath, "line1\nline2");

        var options = SnippetApplyOptions.ReplaceLines(1, 10);

        // Act
        var result = await _service.ValidateOptionsAsync(filePath, options);

        // Assert
        Assert.True(result.IsValid); // Still valid but with warning
        Assert.True(result.HasWarnings);
        Assert.Contains(result.Warnings, w => w.Message.Contains("exceeds"));
    }

    [Fact]
    public async Task ValidateOptionsAsync_InvalidLineNumber_ReturnsError()
    {
        // Arrange
        var filePath = Path.Combine(_testDirectory, "validate_invalid.cs");
        File.WriteAllText(filePath, "line1\nline2");

        var options = SnippetApplyOptions.InsertAfterLine(-1);

        // Act
        var result = await _service.ValidateOptionsAsync(filePath, options);

        // Assert
        Assert.False(result.IsValid);
        Assert.Contains(result.Errors, e => e.Message.Contains(">= 1"));
    }

    #endregion
}
```

### SnippetApplyResult Tests

```csharp
// tests/SeniorIntern.Core.Tests/Models/SnippetApplyResultTests.cs
using SeniorIntern.Core.Models;
using Xunit;

namespace SeniorIntern.Core.Tests.Models;

public class SnippetApplyResultTests
{
    [Fact]
    public void Succeeded_SetsAllProperties()
    {
        // Arrange & Act
        var result = SnippetApplyResult.Succeeded(
            "/path/to/file.cs",
            SnippetApplyOptions.FullReplace,
            "/path/to/backup.cs",
            linesModified: 10,
            linesAdded: 15,
            linesRemoved: 5);

        // Assert
        Assert.True(result.IsSuccess);
        Assert.Equal("/path/to/file.cs", result.FilePath);
        Assert.NotNull(result.Options);
        Assert.Equal("/path/to/backup.cs", result.BackupPath);
        Assert.True(result.HasBackup);
        Assert.Equal(10, result.LinesModified);
        Assert.Equal(15, result.LinesAdded);
        Assert.Equal(5, result.LinesRemoved);
        Assert.Equal(10, result.NetLineChange);
        Assert.Null(result.ErrorMessage);
    }

    [Fact]
    public void Failed_SetsErrorProperties()
    {
        // Arrange & Act
        var result = SnippetApplyResult.Failed("/path/to/file.cs", "Something went wrong");

        // Assert
        Assert.False(result.IsSuccess);
        Assert.Equal("/path/to/file.cs", result.FilePath);
        Assert.Equal("Something went wrong", result.ErrorMessage);
        Assert.Null(result.Options);
        Assert.False(result.HasBackup);
    }

    [Fact]
    public void NetLineChange_CalculatesCorrectly()
    {
        // Arrange & Act
        var added = SnippetApplyResult.Succeeded("f.cs", SnippetApplyOptions.AppendToFile, null,
            linesModified: 5, linesAdded: 10, linesRemoved: 3);

        var removed = SnippetApplyResult.Succeeded("f.cs", SnippetApplyOptions.AppendToFile, null,
            linesModified: 5, linesAdded: 2, linesRemoved: 8);

        // Assert
        Assert.Equal(7, added.NetLineChange);
        Assert.Equal(-6, removed.NetLineChange);
    }
}
```

### SnippetLocationSuggestion Tests

```csharp
// tests/SeniorIntern.Core.Tests/Models/SnippetLocationSuggestionTests.cs
using SeniorIntern.Core.Models;
using Xunit;

namespace SeniorIntern.Core.Tests.Models;

public class SnippetLocationSuggestionTests
{
    [Fact]
    public void ToApplyOptions_Replace_CreatesCorrectOptions()
    {
        // Arrange
        var suggestion = new SnippetLocationSuggestion
        {
            SuggestedMode = SnippetInsertMode.Replace,
            SuggestedRange = new LineRange(5, 10),
            Confidence = 0.8,
            Reason = "Found matching method"
        };

        // Act
        var options = suggestion.ToApplyOptions();

        // Assert
        Assert.Equal(SnippetInsertMode.Replace, options.InsertMode);
        Assert.NotNull(options.ReplaceRange);
        Assert.Equal(5, options.ReplaceRange.Value.StartLine);
        Assert.Equal(10, options.ReplaceRange.Value.EndLine);
    }

    [Fact]
    public void ToApplyOptions_InsertAfter_CreatesCorrectOptions()
    {
        // Arrange
        var suggestion = new SnippetLocationSuggestion
        {
            SuggestedMode = SnippetInsertMode.InsertAfter,
            SuggestedLine = 25,
            Confidence = 0.6,
            Reason = "Insert after properties"
        };

        // Act
        var options = suggestion.ToApplyOptions();

        // Assert
        Assert.Equal(SnippetInsertMode.InsertAfter, options.InsertMode);
        Assert.Equal(25, options.TargetLine);
    }

    [Theory]
    [InlineData(0.7, true, false)]
    [InlineData(0.8, true, false)]
    [InlineData(0.69, false, false)]
    [InlineData(0.39, false, true)]
    [InlineData(0.4, false, false)]
    public void ConfidenceLevels_ClassifyCorrectly(
        double confidence,
        bool expectedHigh,
        bool expectedLow)
    {
        // Arrange
        var suggestion = new SnippetLocationSuggestion
        {
            SuggestedMode = SnippetInsertMode.Append,
            Confidence = confidence,
            Reason = "Test"
        };

        // Assert
        Assert.Equal(expectedHigh, suggestion.IsHighConfidence);
        Assert.Equal(expectedLow, suggestion.IsLowConfidence);
    }
}
```

---

## Files to Create

| File Path | Type | Purpose |
|-----------|------|---------|
| `src/SeniorIntern.Core/Interfaces/ISnippetApplyService.cs` | Interface | Service contract for snippet operations |
| `src/SeniorIntern.Services/SnippetApplyService.cs` | Class | Main service implementation |
| `src/SeniorIntern.Core/Models/SnippetApplyResult.cs` | Record | Result model for apply operations |
| `src/SeniorIntern.Core/Models/SnippetApplyPreview.cs` | Record | Preview model with diff and warnings |
| `src/SeniorIntern.Core/Models/SnippetLocationSuggestion.cs` | Record | Suggestion model for smart insertion |
| `src/SeniorIntern.Core/Models/SnippetOptionsValidation.cs` | Records | Validation result and issue models |
| `src/SeniorIntern.Core/Exceptions/SnippetApplyException.cs` | Exception | Specialized exception for apply failures |
| `tests/SeniorIntern.Services.Tests/SnippetApplyServiceTests.cs` | Tests | Service unit tests |
| `tests/SeniorIntern.Core.Tests/Models/SnippetApplyResultTests.cs` | Tests | Result model tests |
| `tests/SeniorIntern.Core.Tests/Models/SnippetLocationSuggestionTests.cs` | Tests | Suggestion model tests |

## Files to Modify

| File Path | Changes |
|-----------|---------|
| `src/SeniorIntern.Services/ServiceCollectionExtensions.cs` | Add `AddSnippetApplyService()` registration |
| `src/SeniorIntern.Core/Models/AppSettings.cs` | Add `RequireBackupSuccess` property (bool, default: false) |

---

## Dependencies

### Internal Dependencies (from previous v0.4.x specifications)

| Component | Source | Usage |
|-----------|--------|-------|
| `IDiffService` | v0.4.2 | Computing diffs between original and result content |
| `DiffResult` | v0.4.2 | Diff representation in results and previews |
| `IBackupService` | v0.4.3 | Creating file backups before modifications |
| `ISettingsService` | v0.4.5a | Accessing backup and apply settings |
| `AppSettings` | v0.4.5a | Settings for backup behavior |
| `LineRange` | v0.4.5c | Line range representation |
| `SnippetInsertMode` | v0.4.5c | Insert mode enumeration |
| `SnippetApplyOptions` | v0.4.5c | Options for applying snippets |
| `SnippetAnchor` | v0.4.5c | Anchor-based location finding |
| `IndentationStyle` | v0.4.5c | Indentation detection result |
| `SnippetContext` | v0.4.5c | Context for anchor resolution |

### External Dependencies

| Package | Version | Purpose |
|---------|---------|---------|
| `Microsoft.Extensions.Logging.Abstractions` | 8.0.0+ | Optional logging support |

---

## Acceptance Criteria

### Functional Requirements

1. **Apply Operations**
   - [ ] ReplaceFile creates new files if they don't exist
   - [ ] Replace correctly modifies specified line ranges
   - [ ] InsertBefore/InsertAfter insert at correct positions
   - [ ] Append adds content at end of file
   - [ ] Prepend adds content at beginning of file
   - [ ] All operations preserve file encoding

2. **Preview Generation**
   - [ ] Preview returns result without modifying files
   - [ ] Preview includes accurate diff computation
   - [ ] Preview reports correct line add/remove counts
   - [ ] Preview generates warnings for edge cases
   - [ ] Preview handles non-existent files gracefully

3. **Indentation Handling**
   - [ ] Detects tabs vs spaces correctly
   - [ ] Detects spaces per indent (2, 4, etc.)
   - [ ] Preserves indentation when applying snippets
   - [ ] Respects indentation override option
   - [ ] Returns default for empty/new files

4. **Location Suggestions**
   - [ ] Suggests ReplaceFile for new files
   - [ ] Detects method signatures and suggests replacement
   - [ ] Detects class/interface declarations
   - [ ] Provides confidence scores for suggestions
   - [ ] Handles empty snippets gracefully

5. **Backup Integration**
   - [ ] Creates backup when enabled in settings
   - [ ] Skips backup for new files
   - [ ] Returns backup path in result
   - [ ] Handles backup failures according to settings

6. **Validation**
   - [ ] Validates line ranges against file length
   - [ ] Validates anchor patterns can be found
   - [ ] Returns appropriate severity (error/warning)
   - [ ] Validates before applying changes

### Non-Functional Requirements

1. **Performance**
   - [ ] Preview generation < 100ms for files < 10,000 lines
   - [ ] Indentation detection < 50ms for typical files
   - [ ] Location suggestion < 100ms

2. **Error Handling**
   - [ ] Returns failed result instead of throwing for most errors
   - [ ] Throws SnippetApplyException for critical failures
   - [ ] Provides meaningful error messages
   - [ ] Cancellation is properly supported

3. **Thread Safety**
   - [ ] Service is safe to use from multiple threads
   - [ ] File operations use proper async patterns

---

## Design Decisions

### 1. Result Object Pattern

**Decision**: Use `SnippetApplyResult` with factory methods instead of throwing exceptions.

**Rationale**:
- Apply operations commonly fail due to validation, missing files, etc.
- Result objects make failure handling explicit and type-safe
- Easier to compose with UI layer
- Exceptions reserved for truly exceptional conditions (disk full, permission denied)

**Trade-offs**:
- (+) Explicit error handling in calling code
- (+) Can include rich failure information
- (-) Caller must check IsSuccess
- (-) Slightly more verbose

### 2. Preview Before Apply

**Decision**: Always generate preview internally before applying.

**Rationale**:
- Ensures consistency between preview and apply results
- Validates that the operation would succeed
- Provides accurate metrics for the result
- Single implementation of transformation logic

**Trade-offs**:
- (+) Guaranteed consistency
- (+) Early failure detection
- (-) Some redundant computation
- (-) Slight performance overhead (negligible for typical files)

### 3. Regex-Based Pattern Detection

**Decision**: Use compiled regex patterns for code structure detection.

**Rationale**:
- Patterns are used repeatedly for location suggestion
- Compiled regex provides better performance
- Regex is flexible enough for common C# patterns
- No need for full parsing for suggestion purposes

**Trade-offs**:
- (+) Good performance
- (+) Flexible pattern matching
- (-) May miss edge cases in complex code
- (-) Language-specific patterns (C# focused)

### 4. Indentation GCD Algorithm

**Decision**: Detect spaces-per-indent by computing GCD of observed indentations.

**Rationale**:
- Handles inconsistent indentation gracefully
- Works for 2, 4, or other space counts
- Simple and efficient algorithm
- Provides reasonable results even with mixed indentation

**Trade-offs**:
- (+) Handles real-world messy code
- (+) Language-agnostic
- (-) May give wrong result for intentional irregular indentation
- (-) GCD of 1 requires fallback to default

### 5. Confidence Scores for Suggestions

**Decision**: Include confidence scores (0.0-1.0) in location suggestions.

**Rationale**:
- UI can present high-confidence suggestions automatically
- Low-confidence suggestions can prompt user confirmation
- Enables sorting/prioritizing multiple suggestions
- Makes the heuristic nature explicit

**Trade-offs**:
- (+) Enables nuanced UI behavior
- (+) User can gauge reliability
- (-) Thresholds are somewhat arbitrary
- (-) Confidence may not always correlate with correctness

### 6. Lazy Anchor Resolution

**Decision**: Resolve anchors during preview/apply, not at options creation.

**Rationale**:
- File content may change between option creation and apply
- Allows options to be created before file exists
- Keeps anchor resolution logic in one place
- Enables caching of resolved locations

**Trade-offs**:
- (+) Options remain valid across file changes
- (+) Centralized resolution logic
- (-) Anchor errors discovered late
- (-) Options validation more complex

---

## Future Considerations

### Potential Enhancements

1. **Multi-File Operations**
   - Apply same snippet to multiple files
   - Batch preview generation
   - Transactional apply (all-or-nothing)

2. **Language-Specific Detection**
   - Specialized patterns for JavaScript, Python, etc.
   - Integration with language servers
   - Syntax-aware insertion points

3. **Undo Integration**
   - Direct integration with undo service
   - Automatic undo point creation
   - Multi-step undo for complex operations

4. **Smart Indentation**
   - Context-aware indentation adjustment
   - Automatic brace/block completion
   - Format-on-apply option

5. **Conflict Detection**
   - Detect if file changed since last read
   - Merge conflict detection
   - Interactive conflict resolution
