# v0.4.3d: Undo System - Design Specification

**Status**: _IMPLEMENTED_

## Executive Summary

This specification details the **Undo System** for The Senior Intern's Apply Changes Workflow. The `UndoManager` coordinates undo operations with time-based expiration, providing a user-friendly experience where applied changes can be reverted within a configurable time window (default: 30 minutes). The system integrates with the `FileChangeService` to track changes, provides real-time countdown timers for pending undos, and raises events for UI notifications when undos become available or expire.

### Key Deliverables

| Component | Type | Purpose |
|-----------|------|---------|
| `IUndoManager` | Interface | Contract for undo management operations |
| `UndoManager` | Class | Main undo coordination with timer-based expiration |
| `UndoState` | Class | State tracking for a single undoable change |
| `UndoOptions` | Record | Configuration for undo behavior |
| `UndoAvailableEventArgs` | EventArgs | Event data when undo becomes available |
| `UndoExpiredEventArgs` | EventArgs | Event data when undo window expires |
| `UndoCompletedEventArgs` | EventArgs | Event data when undo is performed |
| `UndoCountdownViewModel` | ViewModel | UI binding for countdown display |

---

## Feature Overview

```
v0.4.3d: Undo System
├── Manager Interface (IUndoManager)
│   ├── Undo Operations
│   │   ├── UndoAsync (by file path)
│   │   ├── UndoByIdAsync (by change ID)
│   │   ├── UndoAllAsync (all pending)
│   │   └── UndoMultipleAsync (batch)
│   ├── Query Operations
│   │   ├── CanUndo
│   │   ├── GetTimeRemaining
│   │   ├── GetUndoState
│   │   ├── GetAllPendingUndos
│   │   └── GetPendingUndoCount
│   ├── Timer Management
│   │   ├── StartCountdown
│   │   ├── PauseCountdown
│   │   ├── ResumeCountdown
│   │   └── ExtendTime
│   ├── Events
│   │   ├── UndoAvailable
│   │   ├── UndoExpired
│   │   ├── UndoCompleted
│   │   ├── TimeRemainingChanged
│   │   └── AllUndosExpired
│   └── Configuration
│       └── UndoWindow (TimeSpan)
├── Undo State Tracking
│   ├── UndoState
│   │   ├── ChangeId (Guid)
│   │   ├── FilePath
│   │   ├── RelativePath
│   │   ├── ChangeType
│   │   ├── CreatedAt
│   │   ├── ExpiresAt
│   │   ├── TimeRemaining
│   │   ├── IsExpired
│   │   ├── IsPaused
│   │   └── ChangeRecord reference
│   └── State Management
│       ├── Track new changes
│       ├── Remove on undo/expire
│       └── Update remaining time
├── Timer System
│   ├── Per-Change Timers
│   │   ├── Created on FileChanged event
│   │   ├── Fires on expiration
│   │   └── Cleanup on undo
│   ├── UI Update Timer
│   │   ├── Fires every second
│   │   ├── Updates TimeRemaining
│   │   └── Raises TimeRemainingChanged
│   └── Cleanup Timer
│       ├── Fires every minute
│       ├── Removes expired entries
│       └── Raises batch expired events
├── UI Integration
│   ├── UndoCountdownViewModel
│   │   ├── TimeRemaining (formatted)
│   │   ├── Progress (0-100%)
│   │   ├── IsExpiringSoon (< 60s)
│   │   ├── CanUndo
│   │   └── UndoCommand
│   ├── Toast Notifications
│   │   ├── "Undo available" on apply
│   │   ├── "Undo expired" on timeout
│   │   └── "Change reverted" on undo
│   └── Status Bar Integration
│       ├── Pending undo count
│       └── Quick undo button
└── Configuration (UndoOptions)
    ├── UndoWindow (default: 30 min)
    ├── ShowNotifications (default: true)
    ├── PlaySoundOnExpire (default: false)
    ├── AutoPauseOnUserActivity (default: false)
    ├── MaxPendingUndos (default: 100)
    └── CleanupInterval (default: 1 min)
```

---

## Architecture Diagrams

### Undo System Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                            Undo System Flow                                  │
└─────────────────────────────────────────────────────────────────────────────┘

                      FileChangeService
                            │
                            │ FileChanged event
                            ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                           UndoManager                                        │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │                      OnFileChanged Handler                             │  │
│  │                                                                        │  │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐   │  │
│  │  │   Create    │─▶│   Start     │─▶│   Raise     │─▶│   Update    │   │  │
│  │  │  UndoState  │  │   Timer     │  │   Event     │  │     UI      │   │  │
│  │  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘   │  │
│  │                                                                        │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │                         Timer Callbacks                                │  │
│  │                                                                        │  │
│  │  ┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐    │  │
│  │  │  UI Update      │    │  Expiration     │    │   Cleanup       │    │  │
│  │  │  (every 1s)     │    │  (per change)   │    │  (every 1min)   │    │  │
│  │  │                 │    │                 │    │                 │    │  │
│  │  │ Update          │    │ Remove state    │    │ Remove expired  │    │  │
│  │  │ TimeRemaining   │    │ Raise expired   │    │ entries         │    │  │
│  │  │ Raise event     │    │ event           │    │                 │    │  │
│  │  └─────────────────┘    └─────────────────┘    └─────────────────┘    │  │
│  │                                                                        │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────┘
                            │
              ┌─────────────┴─────────────┐
              ▼                           ▼
       UndoAvailable              TimeRemainingChanged
          Event                        Event
              │                           │
              └─────────────┬─────────────┘
                            ▼
                    ┌─────────────┐
                    │     UI      │
                    │  (Toast,    │
                    │  StatusBar, │
                    │  Dialog)    │
                    └─────────────┘
```

### State Lifecycle

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         Undo State Lifecycle                                 │
└─────────────────────────────────────────────────────────────────────────────┘

                              File Changed
                                   │
                                   ▼
                         ┌─────────────────┐
                         │     Created     │
                         │  (UndoState)    │
                         └────────┬────────┘
                                  │
                                  ▼
         ┌────────────────────────────────────────────────┐
         │                    Active                       │
         │  • Timer running                               │
         │  • TimeRemaining decreasing                    │
         │  • CanUndo = true                              │
         └────────────────────────┬───────────────────────┘
                                  │
          ┌───────────────────────┼───────────────────────┐
          │                       │                       │
          ▼                       ▼                       ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   User Undo     │    │  Timer Expired  │    │   Paused        │
│                 │    │                 │    │  (optional)     │
│ • Restore file  │    │ • CanUndo=false │    │ • Timer stopped │
│ • Remove state  │    │ • Remove state  │    │ • Can resume    │
│ • Raise event   │    │ • Raise event   │    │                 │
└────────┬────────┘    └────────┬────────┘    └────────┬────────┘
         │                      │                      │
         ▼                      ▼                      │
┌─────────────────┐    ┌─────────────────┐            │
│    Completed    │    │    Expired      │            │
│   (removed)     │    │   (removed)     │◀───────────┘
└─────────────────┘    └─────────────────┘       (on resume & expire)
```

### UI Integration Architecture

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        UI Integration Architecture                           │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│                              UndoManager                                     │
│                                                                             │
│  Events:                                                                    │
│  ├── UndoAvailable ────────────────┬─────────────────────────────────────┐  │
│  ├── UndoExpired ──────────────────┤                                     │  │
│  ├── UndoCompleted ────────────────┤                                     │  │
│  ├── TimeRemainingChanged ─────────┤                                     │  │
│  └── AllUndosExpired ──────────────┤                                     │  │
│                                    │                                     │  │
└────────────────────────────────────┼─────────────────────────────────────┘  │
                                     │                                        │
                                     ▼                                        │
┌─────────────────────────────────────────────────────────────────────────────┐
│                        UndoCountdownViewModel                                │
│                                                                             │
│  Properties:                           Commands:                            │
│  ├── TimeRemaining: "28:45"           ├── UndoCommand                      │
│  ├── TimeRemainingSeconds: 1725       ├── DismissCommand                   │
│  ├── Progress: 95.8%                  └── ExtendTimeCommand                │
│  ├── IsExpiringSoon: false                                                 │
│  ├── IsExpired: false                                                      │
│  ├── CanUndo: true                                                         │
│  ├── FileName: "UserService.cs"                                            │
│  └── ChangeDescription: "Modified"                                         │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
         │                    │                    │
         ▼                    ▼                    ▼
┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐
│  Toast          │  │  Status Bar     │  │  Undo Panel     │
│  Notification   │  │  Widget         │  │  (Message List) │
│                 │  │                 │  │                 │
│ ┌─────────────┐ │  │ [Undo: 3]       │  │ ┌─────────────┐ │
│ │ Applied     │ │  │ [28:45]         │  │ │ File1.cs    │ │
│ │ UserService │ │  │ [⟲ Undo]        │  │ │ Modified    │ │
│ │             │ │  │                 │  │ │ 28:45 ⟲    │ │
│ │ [Undo 28:45]│ │  │                 │  │ ├─────────────┤ │
│ └─────────────┘ │  │                 │  │ │ File2.cs    │ │
└─────────────────┘  └─────────────────┘  │ │ Created     │ │
                                          │ │ 15:30 ⟲    │ │
                                          │ └─────────────┘ │
                                          └─────────────────┘
```

### Timer Management

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          Timer Management                                    │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│                              UndoManager                                     │
│                                                                             │
│  Timer 1: UI Update Timer (DispatcherTimer or IDisposable Timer)            │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  Interval: 1 second                                                   │  │
│  │  Purpose: Update TimeRemaining for all active undos                   │  │
│  │  Action: Raise TimeRemainingChanged event for UI binding              │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
│  Timer 2: Cleanup Timer (System.Threading.Timer)                            │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  Interval: 1 minute                                                   │  │
│  │  Purpose: Remove expired entries, backup cleanup triggers             │  │
│  │  Action: Scan all states, remove expired, raise batch events          │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
│  Timer 3: Per-Change Expiration (CancellationTokenSource + Task.Delay)      │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  Duration: Remaining time until expiration                            │  │
│  │  Purpose: Precise expiration notification per change                  │  │
│  │  Action: Mark expired, raise UndoExpired event                        │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
│  Thread Safety:                                                             │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  • ConcurrentDictionary for state storage                             │  │
│  │  • Lock for state transitions                                         │  │
│  │  • UI updates marshaled to dispatcher                                 │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Detailed Design

### IUndoManager Interface

```csharp
// src/SeniorIntern.Core/Interfaces/IUndoManager.cs
namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Manages undo operations with time-based expiration.
/// </summary>
/// <remarks>
/// The undo manager provides:
/// <list type="bullet">
///   <item>Time-windowed undo capability (default: 30 minutes)</item>
///   <item>Real-time countdown tracking for UI display</item>
///   <item>Event notifications for undo availability and expiration</item>
///   <item>Batch undo operations for multiple changes</item>
///   <item>Optional pause/resume functionality</item>
/// </list>
/// </remarks>
public interface IUndoManager : IDisposable
{
    #region Properties

    /// <summary>
    /// Gets the configured undo time window.
    /// </summary>
    TimeSpan UndoWindow { get; }

    /// <summary>
    /// Gets the number of pending undos.
    /// </summary>
    int PendingUndoCount { get; }

    /// <summary>
    /// Gets whether any undos are available.
    /// </summary>
    bool HasPendingUndos { get; }

    #endregion

    #region Undo Operations

    /// <summary>
    /// Undo the last change to a file.
    /// </summary>
    /// <param name="filePath">The absolute path to the file.</param>
    /// <returns>True if undo succeeded, false otherwise.</returns>
    Task<bool> UndoAsync(string filePath);

    /// <summary>
    /// Undo a specific change by ID.
    /// </summary>
    /// <param name="changeId">The unique identifier of the change.</param>
    /// <returns>True if undo succeeded, false otherwise.</returns>
    Task<bool> UndoByIdAsync(Guid changeId);

    /// <summary>
    /// Undo all pending changes.
    /// </summary>
    /// <returns>Number of changes successfully undone.</returns>
    Task<int> UndoAllAsync();

    /// <summary>
    /// Undo multiple changes by ID.
    /// </summary>
    /// <param name="changeIds">The change IDs to undo.</param>
    /// <returns>Number of changes successfully undone.</returns>
    Task<int> UndoMultipleAsync(IEnumerable<Guid> changeIds);

    #endregion

    #region Query Operations

    /// <summary>
    /// Check if undo is available for a file.
    /// </summary>
    /// <param name="filePath">The absolute path to the file.</param>
    /// <returns>True if undo is available and not expired.</returns>
    bool CanUndo(string filePath);

    /// <summary>
    /// Check if undo is available for a change ID.
    /// </summary>
    /// <param name="changeId">The change ID to check.</param>
    /// <returns>True if undo is available and not expired.</returns>
    bool CanUndoById(Guid changeId);

    /// <summary>
    /// Get time remaining for undo on a file.
    /// </summary>
    /// <param name="filePath">The absolute path to the file.</param>
    /// <returns>Time remaining, or TimeSpan.Zero if not available.</returns>
    TimeSpan GetTimeRemaining(string filePath);

    /// <summary>
    /// Get time remaining for a specific change.
    /// </summary>
    /// <param name="changeId">The change ID to check.</param>
    /// <returns>Time remaining, or TimeSpan.Zero if not available.</returns>
    TimeSpan GetTimeRemainingById(Guid changeId);

    /// <summary>
    /// Get the undo state for a file.
    /// </summary>
    /// <param name="filePath">The absolute path to the file.</param>
    /// <returns>Undo state, or null if not available.</returns>
    UndoState? GetUndoState(string filePath);

    /// <summary>
    /// Get the undo state for a change ID.
    /// </summary>
    /// <param name="changeId">The change ID to get state for.</param>
    /// <returns>Undo state, or null if not available.</returns>
    UndoState? GetUndoStateById(Guid changeId);

    /// <summary>
    /// Get all pending undo states.
    /// </summary>
    /// <returns>List of pending undo states, ordered by expiration time.</returns>
    IReadOnlyList<UndoState> GetAllPendingUndos();

    #endregion

    #region Timer Management

    /// <summary>
    /// Pause the countdown for a specific undo.
    /// </summary>
    /// <param name="changeId">The change ID to pause.</param>
    /// <returns>True if paused successfully.</returns>
    bool PauseCountdown(Guid changeId);

    /// <summary>
    /// Resume the countdown for a paused undo.
    /// </summary>
    /// <param name="changeId">The change ID to resume.</param>
    /// <returns>True if resumed successfully.</returns>
    bool ResumeCountdown(Guid changeId);

    /// <summary>
    /// Extend the undo time for a change.
    /// </summary>
    /// <param name="changeId">The change ID to extend.</param>
    /// <param name="additionalTime">Time to add to the countdown.</param>
    /// <returns>True if extended successfully.</returns>
    bool ExtendTime(Guid changeId, TimeSpan additionalTime);

    /// <summary>
    /// Dismiss an undo without performing it.
    /// </summary>
    /// <param name="changeId">The change ID to dismiss.</param>
    /// <returns>True if dismissed successfully.</returns>
    bool Dismiss(Guid changeId);

    #endregion

    #region Events

    /// <summary>
    /// Raised when an undo becomes available after a file change.
    /// </summary>
    event EventHandler<UndoAvailableEventArgs>? UndoAvailable;

    /// <summary>
    /// Raised when an undo time window expires.
    /// </summary>
    event EventHandler<UndoExpiredEventArgs>? UndoExpired;

    /// <summary>
    /// Raised when an undo operation completes.
    /// </summary>
    event EventHandler<UndoCompletedEventArgs>? UndoCompleted;

    /// <summary>
    /// Raised periodically (every second) with updated time remaining.
    /// </summary>
    event EventHandler<TimeRemainingChangedEventArgs>? TimeRemainingChanged;

    /// <summary>
    /// Raised when all pending undos have expired or been completed.
    /// </summary>
    event EventHandler? AllUndosExpired;

    #endregion
}
```

### UndoState Model

```csharp
// src/SeniorIntern.Core/Models/UndoState.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Represents the state of a single undoable change.
/// </summary>
public sealed class UndoState
{
    /// <summary>
    /// Unique identifier for the change.
    /// </summary>
    public Guid ChangeId { get; init; }

    /// <summary>
    /// Absolute path to the changed file.
    /// </summary>
    public string FilePath { get; init; } = string.Empty;

    /// <summary>
    /// Relative path within the workspace.
    /// </summary>
    public string RelativePath { get; init; } = string.Empty;

    /// <summary>
    /// Type of change (Created, Modified, Deleted).
    /// </summary>
    public FileChangeType ChangeType { get; init; }

    /// <summary>
    /// When the change was made.
    /// </summary>
    public DateTime CreatedAt { get; init; }

    /// <summary>
    /// When the undo window expires.
    /// </summary>
    public DateTime ExpiresAt { get; init; }

    /// <summary>
    /// Description of the change.
    /// </summary>
    public string Description { get; init; } = string.Empty;

    /// <summary>
    /// Code block ID that caused this change (if applicable).
    /// </summary>
    public Guid? CodeBlockId { get; init; }

    /// <summary>
    /// Message ID that contained the code block (if applicable).
    /// </summary>
    public Guid? MessageId { get; init; }

    /// <summary>
    /// Whether the countdown is currently paused.
    /// </summary>
    public bool IsPaused { get; internal set; }

    /// <summary>
    /// When the countdown was paused (if paused).
    /// </summary>
    public DateTime? PausedAt { get; internal set; }

    /// <summary>
    /// Total time the countdown has been paused.
    /// </summary>
    public TimeSpan TotalPausedTime { get; internal set; }

    /// <summary>
    /// Reference to the underlying change record.
    /// </summary>
    public FileChangeRecord? ChangeRecord { get; init; }

    /// <summary>
    /// Gets whether the undo has expired.
    /// </summary>
    public bool IsExpired => !IsPaused && DateTime.UtcNow >= EffectiveExpiresAt;

    /// <summary>
    /// Gets the effective expiration time (accounting for pause time).
    /// </summary>
    public DateTime EffectiveExpiresAt => ExpiresAt + TotalPausedTime +
        (IsPaused && PausedAt.HasValue ? DateTime.UtcNow - PausedAt.Value : TimeSpan.Zero);

    /// <summary>
    /// Gets the time remaining until expiration.
    /// </summary>
    public TimeSpan TimeRemaining
    {
        get
        {
            if (IsPaused)
                return ExpiresAt + TotalPausedTime - (PausedAt ?? DateTime.UtcNow);

            var remaining = EffectiveExpiresAt - DateTime.UtcNow;
            return remaining > TimeSpan.Zero ? remaining : TimeSpan.Zero;
        }
    }

    /// <summary>
    /// Gets the progress percentage (100% = just started, 0% = expired).
    /// </summary>
    public double ProgressPercentage
    {
        get
        {
            var totalWindow = ExpiresAt - CreatedAt;
            if (totalWindow.TotalSeconds <= 0)
                return 0;

            var elapsed = DateTime.UtcNow - CreatedAt - TotalPausedTime;
            if (IsPaused && PausedAt.HasValue)
                elapsed = PausedAt.Value - CreatedAt - TotalPausedTime;

            var remaining = totalWindow - elapsed;
            return Math.Max(0, Math.Min(100, (remaining.TotalSeconds / totalWindow.TotalSeconds) * 100));
        }
    }

    /// <summary>
    /// Gets whether the undo is expiring soon (less than 60 seconds).
    /// </summary>
    public bool IsExpiringSoon => TimeRemaining.TotalSeconds > 0 && TimeRemaining.TotalSeconds <= 60;

    /// <summary>
    /// Gets the filename portion of the file path.
    /// </summary>
    public string FileName => Path.GetFileName(FilePath);

    /// <summary>
    /// Gets a formatted time remaining string (e.g., "28:45").
    /// </summary>
    public string FormattedTimeRemaining
    {
        get
        {
            var time = TimeRemaining;
            if (time.TotalHours >= 1)
                return time.ToString(@"h\:mm\:ss");
            return time.ToString(@"mm\:ss");
        }
    }
}
```

### UndoOptions Model

```csharp
// src/SeniorIntern.Core/Models/UndoOptions.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Configuration options for the undo system.
/// </summary>
public sealed record UndoOptions
{
    /// <summary>
    /// Time window during which undo is available.
    /// </summary>
    /// <remarks>
    /// Default: 30 minutes.
    /// </remarks>
    public TimeSpan UndoWindow { get; init; } = TimeSpan.FromMinutes(30);

    /// <summary>
    /// Whether to show toast notifications for undo events.
    /// </summary>
    /// <remarks>
    /// Default: true.
    /// </remarks>
    public bool ShowNotifications { get; init; } = true;

    /// <summary>
    /// Whether to play a sound when undo expires.
    /// </summary>
    /// <remarks>
    /// Default: false.
    /// </remarks>
    public bool PlaySoundOnExpire { get; init; } = false;

    /// <summary>
    /// Whether to automatically pause countdown on user activity.
    /// </summary>
    /// <remarks>
    /// When enabled, countdown pauses while user is actively editing.
    /// Default: false.
    /// </remarks>
    public bool AutoPauseOnUserActivity { get; init; } = false;

    /// <summary>
    /// Maximum number of pending undos to track.
    /// </summary>
    /// <remarks>
    /// Oldest undos are removed when limit is exceeded.
    /// Default: 100.
    /// </remarks>
    public int MaxPendingUndos { get; init; } = 100;

    /// <summary>
    /// Interval for cleanup timer.
    /// </summary>
    /// <remarks>
    /// Default: 1 minute.
    /// </remarks>
    public TimeSpan CleanupInterval { get; init; } = TimeSpan.FromMinutes(1);

    /// <summary>
    /// Interval for UI update timer.
    /// </summary>
    /// <remarks>
    /// Default: 1 second.
    /// </remarks>
    public TimeSpan UiUpdateInterval { get; init; } = TimeSpan.FromSeconds(1);

    /// <summary>
    /// Warning threshold for expiring soon indicator.
    /// </summary>
    /// <remarks>
    /// Default: 60 seconds.
    /// </remarks>
    public TimeSpan ExpiringSoonThreshold { get; init; } = TimeSpan.FromSeconds(60);

    /// <summary>
    /// Whether to allow extending undo time.
    /// </summary>
    /// <remarks>
    /// Default: true.
    /// </remarks>
    public bool AllowExtendTime { get; init; } = true;

    /// <summary>
    /// Maximum time that undo can be extended.
    /// </summary>
    /// <remarks>
    /// Default: 1 hour total from original change.
    /// </remarks>
    public TimeSpan MaxExtendedTime { get; init; } = TimeSpan.FromHours(1);

    /// <summary>
    /// Default undo options.
    /// </summary>
    public static UndoOptions Default { get; } = new();

    /// <summary>
    /// Quick undo options (shorter window).
    /// </summary>
    public static UndoOptions Quick { get; } = new()
    {
        UndoWindow = TimeSpan.FromMinutes(5),
        ExpiringSoonThreshold = TimeSpan.FromSeconds(30)
    };

    /// <summary>
    /// Extended undo options (longer window).
    /// </summary>
    public static UndoOptions Extended { get; } = new()
    {
        UndoWindow = TimeSpan.FromHours(1),
        MaxExtendedTime = TimeSpan.FromHours(2)
    };
}
```

### Event Arguments

```csharp
// src/SeniorIntern.Core/Models/UndoEvents.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Event args raised when an undo becomes available.
/// </summary>
public sealed class UndoAvailableEventArgs : EventArgs
{
    /// <summary>
    /// Absolute path to the changed file.
    /// </summary>
    public required string FilePath { get; init; }

    /// <summary>
    /// Relative path within the workspace.
    /// </summary>
    public required string RelativePath { get; init; }

    /// <summary>
    /// Type of change that was made.
    /// </summary>
    public required FileChangeType ChangeType { get; init; }

    /// <summary>
    /// When the undo window expires.
    /// </summary>
    public required DateTime ExpiresAt { get; init; }

    /// <summary>
    /// Unique identifier of the change.
    /// </summary>
    public required Guid ChangeId { get; init; }

    /// <summary>
    /// The full undo state.
    /// </summary>
    public required UndoState UndoState { get; init; }
}

/// <summary>
/// Event args raised when an undo time window expires.
/// </summary>
public sealed class UndoExpiredEventArgs : EventArgs
{
    /// <summary>
    /// Absolute path to the file.
    /// </summary>
    public required string FilePath { get; init; }

    /// <summary>
    /// Unique identifier of the expired change.
    /// </summary>
    public required Guid ChangeId { get; init; }

    /// <summary>
    /// The original change record.
    /// </summary>
    public required FileChangeRecord ChangeRecord { get; init; }

    /// <summary>
    /// When the change was originally made.
    /// </summary>
    public required DateTime ChangedAt { get; init; }

    /// <summary>
    /// When the undo window expired.
    /// </summary>
    public required DateTime ExpiredAt { get; init; }
}

/// <summary>
/// Event args raised when an undo operation completes.
/// </summary>
public sealed class UndoCompletedEventArgs : EventArgs
{
    /// <summary>
    /// Absolute path to the file.
    /// </summary>
    public required string FilePath { get; init; }

    /// <summary>
    /// Relative path within the workspace.
    /// </summary>
    public required string RelativePath { get; init; }

    /// <summary>
    /// Unique identifier of the undone change.
    /// </summary>
    public required Guid ChangeId { get; init; }

    /// <summary>
    /// Type of change that was undone.
    /// </summary>
    public required FileChangeType ChangeType { get; init; }

    /// <summary>
    /// Whether the undo was successful.
    /// </summary>
    public required bool Success { get; init; }

    /// <summary>
    /// Error message if undo failed.
    /// </summary>
    public string? ErrorMessage { get; init; }
}

/// <summary>
/// Event args raised when time remaining changes (every second).
/// </summary>
public sealed class TimeRemainingChangedEventArgs : EventArgs
{
    /// <summary>
    /// All current undo states with updated time remaining.
    /// </summary>
    public required IReadOnlyList<UndoState> UndoStates { get; init; }

    /// <summary>
    /// States that will expire soon (within threshold).
    /// </summary>
    public required IReadOnlyList<UndoState> ExpiringSoon { get; init; }

    /// <summary>
    /// Total number of pending undos.
    /// </summary>
    public required int TotalCount { get; init; }
}
```

### UndoManager Implementation

```csharp
// src/SeniorIntern.Services/UndoManager.cs
using System.Collections.Concurrent;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;

namespace SeniorIntern.Services;

/// <summary>
/// Manages undo operations with time-based expiration.
/// </summary>
public sealed class UndoManager : IUndoManager
{
    private readonly IFileChangeService _changeService;
    private readonly ILogger<UndoManager>? _logger;
    private readonly UndoOptions _options;

    // State storage: ChangeId -> UndoState
    private readonly ConcurrentDictionary<Guid, UndoState> _undoStates = new();

    // File path to ChangeId mapping for quick lookup
    private readonly ConcurrentDictionary<string, Guid> _fileToChangeId = new();

    // Expiration timers: ChangeId -> CancellationTokenSource
    private readonly ConcurrentDictionary<Guid, CancellationTokenSource> _expirationTimers = new();

    // Lock for state transitions
    private readonly object _stateLock = new();

    // Timers
    private readonly Timer _cleanupTimer;
    private readonly Timer _uiUpdateTimer;

    private bool _disposed;

    /// <inheritdoc />
    public TimeSpan UndoWindow => _options.UndoWindow;

    /// <inheritdoc />
    public int PendingUndoCount => _undoStates.Count;

    /// <inheritdoc />
    public bool HasPendingUndos => !_undoStates.IsEmpty;

    /// <inheritdoc />
    public event EventHandler<UndoAvailableEventArgs>? UndoAvailable;

    /// <inheritdoc />
    public event EventHandler<UndoExpiredEventArgs>? UndoExpired;

    /// <inheritdoc />
    public event EventHandler<UndoCompletedEventArgs>? UndoCompleted;

    /// <inheritdoc />
    public event EventHandler<TimeRemainingChangedEventArgs>? TimeRemainingChanged;

    /// <inheritdoc />
    public event EventHandler? AllUndosExpired;

    /// <summary>
    /// Initializes a new instance of the UndoManager.
    /// </summary>
    /// <param name="changeService">The file change service to coordinate with.</param>
    /// <param name="options">Configuration options.</param>
    /// <param name="logger">Optional logger for diagnostics.</param>
    public UndoManager(
        IFileChangeService changeService,
        UndoOptions? options = null,
        ILogger<UndoManager>? logger = null)
    {
        _changeService = changeService ?? throw new ArgumentNullException(nameof(changeService));
        _options = options ?? UndoOptions.Default;
        _logger = logger;

        // Subscribe to file change events
        _changeService.FileChanged += OnFileChanged;
        _changeService.ChangeUndone += OnChangeUndone;

        // Start cleanup timer
        _cleanupTimer = new Timer(
            OnCleanupTimer,
            null,
            _options.CleanupInterval,
            _options.CleanupInterval);

        // Start UI update timer
        _uiUpdateTimer = new Timer(
            OnUiUpdateTimer,
            null,
            _options.UiUpdateInterval,
            _options.UiUpdateInterval);

        _logger?.LogDebug(
            "UndoManager initialized with {UndoWindow} window",
            _options.UndoWindow);
    }

    #region Event Handlers

    private void OnFileChanged(object? sender, FileChangedEventArgs e)
    {
        if (!e.CanUndo)
            return;

        lock (_stateLock)
        {
            // Remove any existing state for this file
            if (_fileToChangeId.TryRemove(e.FilePath, out var oldId))
            {
                RemoveState(oldId);
            }

            // Enforce max pending undos
            while (_undoStates.Count >= _options.MaxPendingUndos)
            {
                var oldest = _undoStates.Values
                    .OrderBy(s => s.CreatedAt)
                    .FirstOrDefault();

                if (oldest != null)
                {
                    RemoveState(oldest.ChangeId);
                }
            }

            // Create new undo state
            var changeId = Guid.NewGuid();
            var expiresAt = DateTime.UtcNow + _options.UndoWindow;

            var state = new UndoState
            {
                ChangeId = changeId,
                FilePath = e.FilePath,
                RelativePath = e.RelativePath,
                ChangeType = e.ChangeType,
                CreatedAt = DateTime.UtcNow,
                ExpiresAt = expiresAt,
                Description = GetChangeDescription(e.ChangeType, e.RelativePath),
                CodeBlockId = e.CodeBlockId,
                MessageId = e.MessageId,
                ChangeRecord = GetChangeRecord(e.FilePath)
            };

            _undoStates[changeId] = state;
            _fileToChangeId[e.FilePath] = changeId;

            // Start expiration timer
            StartExpirationTimer(state);

            _logger?.LogDebug(
                "Undo available for {FilePath}, expires at {ExpiresAt}",
                e.RelativePath, expiresAt);

            // Raise event
            UndoAvailable?.Invoke(this, new UndoAvailableEventArgs
            {
                FilePath = e.FilePath,
                RelativePath = e.RelativePath,
                ChangeType = e.ChangeType,
                ExpiresAt = expiresAt,
                ChangeId = changeId,
                UndoState = state
            });
        }
    }

    private void OnChangeUndone(object? sender, FileChangeUndoneEventArgs e)
    {
        // State already removed by UndoAsync, just log
        _logger?.LogDebug("Change undone for {FilePath}", e.FilePath);
    }

    private void OnCleanupTimer(object? state)
    {
        CleanupExpiredStates();
    }

    private void OnUiUpdateTimer(object? state)
    {
        RaiseTimeRemainingChanged();
    }

    #endregion

    #region Undo Operations

    /// <inheritdoc />
    public async Task<bool> UndoAsync(string filePath)
    {
        if (string.IsNullOrEmpty(filePath))
            return false;

        if (!_fileToChangeId.TryGetValue(filePath, out var changeId))
        {
            _logger?.LogDebug("No undo state for {FilePath}", filePath);
            return false;
        }

        return await UndoByIdAsync(changeId);
    }

    /// <inheritdoc />
    public async Task<bool> UndoByIdAsync(Guid changeId)
    {
        if (!_undoStates.TryGetValue(changeId, out var state))
        {
            _logger?.LogDebug("Undo state not found for {ChangeId}", changeId);
            return false;
        }

        if (state.IsExpired)
        {
            _logger?.LogDebug("Undo expired for {ChangeId}", changeId);
            RemoveState(changeId);
            return false;
        }

        try
        {
            // Perform the undo via FileChangeService
            var success = await _changeService.UndoChangeAsync(
                state.ChangeRecord?.Id ?? changeId);

            // Remove state regardless of outcome
            RemoveState(changeId);

            // Raise completion event
            UndoCompleted?.Invoke(this, new UndoCompletedEventArgs
            {
                FilePath = state.FilePath,
                RelativePath = state.RelativePath,
                ChangeId = changeId,
                ChangeType = state.ChangeType,
                Success = success
            });

            if (success)
            {
                _logger?.LogInformation(
                    "Undo completed for {FilePath}",
                    state.RelativePath);
            }
            else
            {
                _logger?.LogWarning(
                    "Undo failed for {FilePath}",
                    state.RelativePath);
            }

            // Check if all undos are gone
            if (_undoStates.IsEmpty)
            {
                AllUndosExpired?.Invoke(this, EventArgs.Empty);
            }

            return success;
        }
        catch (Exception ex)
        {
            _logger?.LogError(ex, "Error during undo for {FilePath}", state.FilePath);

            UndoCompleted?.Invoke(this, new UndoCompletedEventArgs
            {
                FilePath = state.FilePath,
                RelativePath = state.RelativePath,
                ChangeId = changeId,
                ChangeType = state.ChangeType,
                Success = false,
                ErrorMessage = ex.Message
            });

            return false;
        }
    }

    /// <inheritdoc />
    public async Task<int> UndoAllAsync()
    {
        var changeIds = _undoStates.Keys.ToList();
        return await UndoMultipleAsync(changeIds);
    }

    /// <inheritdoc />
    public async Task<int> UndoMultipleAsync(IEnumerable<Guid> changeIds)
    {
        var successCount = 0;

        foreach (var changeId in changeIds)
        {
            if (await UndoByIdAsync(changeId))
            {
                successCount++;
            }
        }

        return successCount;
    }

    #endregion

    #region Query Operations

    /// <inheritdoc />
    public bool CanUndo(string filePath)
    {
        if (string.IsNullOrEmpty(filePath))
            return false;

        if (!_fileToChangeId.TryGetValue(filePath, out var changeId))
            return false;

        return CanUndoById(changeId);
    }

    /// <inheritdoc />
    public bool CanUndoById(Guid changeId)
    {
        if (!_undoStates.TryGetValue(changeId, out var state))
            return false;

        return !state.IsExpired;
    }

    /// <inheritdoc />
    public TimeSpan GetTimeRemaining(string filePath)
    {
        if (string.IsNullOrEmpty(filePath))
            return TimeSpan.Zero;

        if (!_fileToChangeId.TryGetValue(filePath, out var changeId))
            return TimeSpan.Zero;

        return GetTimeRemainingById(changeId);
    }

    /// <inheritdoc />
    public TimeSpan GetTimeRemainingById(Guid changeId)
    {
        if (!_undoStates.TryGetValue(changeId, out var state))
            return TimeSpan.Zero;

        return state.TimeRemaining;
    }

    /// <inheritdoc />
    public UndoState? GetUndoState(string filePath)
    {
        if (string.IsNullOrEmpty(filePath))
            return null;

        if (!_fileToChangeId.TryGetValue(filePath, out var changeId))
            return null;

        return GetUndoStateById(changeId);
    }

    /// <inheritdoc />
    public UndoState? GetUndoStateById(Guid changeId)
    {
        return _undoStates.TryGetValue(changeId, out var state) ? state : null;
    }

    /// <inheritdoc />
    public IReadOnlyList<UndoState> GetAllPendingUndos()
    {
        return _undoStates.Values
            .Where(s => !s.IsExpired)
            .OrderBy(s => s.ExpiresAt)
            .ToList();
    }

    #endregion

    #region Timer Management

    /// <inheritdoc />
    public bool PauseCountdown(Guid changeId)
    {
        if (!_undoStates.TryGetValue(changeId, out var state))
            return false;

        if (state.IsPaused || state.IsExpired)
            return false;

        lock (_stateLock)
        {
            state.IsPaused = true;
            state.PausedAt = DateTime.UtcNow;

            // Cancel expiration timer
            if (_expirationTimers.TryRemove(changeId, out var cts))
            {
                cts.Cancel();
                cts.Dispose();
            }

            _logger?.LogDebug("Paused countdown for {ChangeId}", changeId);
            return true;
        }
    }

    /// <inheritdoc />
    public bool ResumeCountdown(Guid changeId)
    {
        if (!_undoStates.TryGetValue(changeId, out var state))
            return false;

        if (!state.IsPaused)
            return false;

        lock (_stateLock)
        {
            // Calculate paused duration
            if (state.PausedAt.HasValue)
            {
                state.TotalPausedTime += DateTime.UtcNow - state.PausedAt.Value;
            }

            state.IsPaused = false;
            state.PausedAt = null;

            // Restart expiration timer
            StartExpirationTimer(state);

            _logger?.LogDebug("Resumed countdown for {ChangeId}", changeId);
            return true;
        }
    }

    /// <inheritdoc />
    public bool ExtendTime(Guid changeId, TimeSpan additionalTime)
    {
        if (!_options.AllowExtendTime)
            return false;

        if (!_undoStates.TryGetValue(changeId, out var state))
            return false;

        if (state.IsExpired)
            return false;

        lock (_stateLock)
        {
            // Check max extended time limit
            var newExpiresAt = state.ExpiresAt + additionalTime;
            var totalTime = newExpiresAt - state.CreatedAt;

            if (totalTime > _options.MaxExtendedTime)
            {
                _logger?.LogDebug(
                    "Cannot extend beyond max time for {ChangeId}",
                    changeId);
                return false;
            }

            // Cancel current timer
            if (_expirationTimers.TryRemove(changeId, out var cts))
            {
                cts.Cancel();
                cts.Dispose();
            }

            // Update state (create new since it's init-only)
            var newState = new UndoState
            {
                ChangeId = state.ChangeId,
                FilePath = state.FilePath,
                RelativePath = state.RelativePath,
                ChangeType = state.ChangeType,
                CreatedAt = state.CreatedAt,
                ExpiresAt = newExpiresAt,
                Description = state.Description,
                CodeBlockId = state.CodeBlockId,
                MessageId = state.MessageId,
                IsPaused = state.IsPaused,
                PausedAt = state.PausedAt,
                TotalPausedTime = state.TotalPausedTime,
                ChangeRecord = state.ChangeRecord
            };

            _undoStates[changeId] = newState;

            // Start new timer
            if (!newState.IsPaused)
            {
                StartExpirationTimer(newState);
            }

            _logger?.LogDebug(
                "Extended time for {ChangeId} by {AdditionalTime}",
                changeId, additionalTime);

            return true;
        }
    }

    /// <inheritdoc />
    public bool Dismiss(Guid changeId)
    {
        if (!_undoStates.ContainsKey(changeId))
            return false;

        RemoveState(changeId);
        _logger?.LogDebug("Dismissed undo for {ChangeId}", changeId);

        if (_undoStates.IsEmpty)
        {
            AllUndosExpired?.Invoke(this, EventArgs.Empty);
        }

        return true;
    }

    private void StartExpirationTimer(UndoState state)
    {
        var delay = state.TimeRemaining;
        if (delay <= TimeSpan.Zero)
        {
            // Already expired
            HandleExpiration(state.ChangeId);
            return;
        }

        var cts = new CancellationTokenSource();
        _expirationTimers[state.ChangeId] = cts;

        _ = Task.Run(async () =>
        {
            try
            {
                await Task.Delay(delay, cts.Token);
                HandleExpiration(state.ChangeId);
            }
            catch (OperationCanceledException)
            {
                // Timer was cancelled (paused, extended, or undo performed)
            }
        });
    }

    private void HandleExpiration(Guid changeId)
    {
        if (!_undoStates.TryGetValue(changeId, out var state))
            return;

        _logger?.LogDebug("Undo expired for {FilePath}", state.RelativePath);

        // Raise expired event before removing
        UndoExpired?.Invoke(this, new UndoExpiredEventArgs
        {
            FilePath = state.FilePath,
            ChangeId = changeId,
            ChangeRecord = state.ChangeRecord!,
            ChangedAt = state.CreatedAt,
            ExpiredAt = DateTime.UtcNow
        });

        RemoveState(changeId);

        if (_undoStates.IsEmpty)
        {
            AllUndosExpired?.Invoke(this, EventArgs.Empty);
        }
    }

    #endregion

    #region Helper Methods

    private void RemoveState(Guid changeId)
    {
        if (_undoStates.TryRemove(changeId, out var state))
        {
            _fileToChangeId.TryRemove(state.FilePath, out _);
        }

        if (_expirationTimers.TryRemove(changeId, out var cts))
        {
            cts.Cancel();
            cts.Dispose();
        }
    }

    private void CleanupExpiredStates()
    {
        var expired = _undoStates.Values
            .Where(s => s.IsExpired)
            .ToList();

        foreach (var state in expired)
        {
            HandleExpiration(state.ChangeId);
        }
    }

    private void RaiseTimeRemainingChanged()
    {
        var states = _undoStates.Values
            .Where(s => !s.IsExpired)
            .OrderBy(s => s.ExpiresAt)
            .ToList();

        if (states.Count == 0 && !_undoStates.IsEmpty)
        {
            // All states just expired
            CleanupExpiredStates();
            return;
        }

        var expiringSoon = states
            .Where(s => s.IsExpiringSoon)
            .ToList();

        TimeRemainingChanged?.Invoke(this, new TimeRemainingChangedEventArgs
        {
            UndoStates = states,
            ExpiringSoon = expiringSoon,
            TotalCount = states.Count
        });
    }

    private FileChangeRecord? GetChangeRecord(string filePath)
    {
        var history = _changeService.GetChangeHistory(filePath, 1);
        return history.Count > 0 ? history[0] : null;
    }

    private static string GetChangeDescription(FileChangeType changeType, string relativePath)
    {
        var fileName = Path.GetFileName(relativePath);
        return changeType switch
        {
            FileChangeType.Created => $"Created {fileName}",
            FileChangeType.Modified => $"Modified {fileName}",
            FileChangeType.Deleted => $"Deleted {fileName}",
            FileChangeType.Renamed => $"Renamed {fileName}",
            _ => $"Changed {fileName}"
        };
    }

    #endregion

    #region IDisposable

    /// <inheritdoc />
    public void Dispose()
    {
        if (_disposed)
            return;

        _disposed = true;

        // Unsubscribe from events
        _changeService.FileChanged -= OnFileChanged;
        _changeService.ChangeUndone -= OnChangeUndone;

        // Stop timers
        _cleanupTimer.Dispose();
        _uiUpdateTimer.Dispose();

        // Cancel all expiration timers
        foreach (var cts in _expirationTimers.Values)
        {
            cts.Cancel();
            cts.Dispose();
        }

        _expirationTimers.Clear();
        _undoStates.Clear();
        _fileToChangeId.Clear();

        _logger?.LogDebug("UndoManager disposed");
    }

    #endregion
}
```

### UndoCountdownViewModel

```csharp
// src/SeniorIntern.Desktop/ViewModels/UndoCountdownViewModel.cs
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;

namespace SeniorIntern.Desktop.ViewModels;

/// <summary>
/// ViewModel for displaying undo countdown in the UI.
/// </summary>
public partial class UndoCountdownViewModel : ViewModelBase, IDisposable
{
    private readonly IUndoManager _undoManager;
    private readonly Guid _changeId;

    [ObservableProperty]
    private string _fileName = string.Empty;

    [ObservableProperty]
    private string _changeDescription = string.Empty;

    [ObservableProperty]
    private string _formattedTimeRemaining = "00:00";

    [ObservableProperty]
    private double _progressPercentage = 100;

    [ObservableProperty]
    private bool _isExpiringSoon;

    [ObservableProperty]
    private bool _isExpired;

    [ObservableProperty]
    private bool _isPaused;

    [ObservableProperty]
    private bool _canUndo = true;

    [ObservableProperty]
    private bool _isUndoing;

    public UndoCountdownViewModel(IUndoManager undoManager, UndoState state)
    {
        _undoManager = undoManager;
        _changeId = state.ChangeId;

        FileName = state.FileName;
        ChangeDescription = state.Description;

        UpdateFromState(state);

        // Subscribe to time updates
        _undoManager.TimeRemainingChanged += OnTimeRemainingChanged;
        _undoManager.UndoExpired += OnUndoExpired;
    }

    private void OnTimeRemainingChanged(object? sender, TimeRemainingChangedEventArgs e)
    {
        var state = e.UndoStates.FirstOrDefault(s => s.ChangeId == _changeId);
        if (state != null)
        {
            UpdateFromState(state);
        }
    }

    private void OnUndoExpired(object? sender, UndoExpiredEventArgs e)
    {
        if (e.ChangeId == _changeId)
        {
            IsExpired = true;
            CanUndo = false;
            FormattedTimeRemaining = "Expired";
            ProgressPercentage = 0;
        }
    }

    private void UpdateFromState(UndoState state)
    {
        FormattedTimeRemaining = state.FormattedTimeRemaining;
        ProgressPercentage = state.ProgressPercentage;
        IsExpiringSoon = state.IsExpiringSoon;
        IsExpired = state.IsExpired;
        IsPaused = state.IsPaused;
        CanUndo = !state.IsExpired && !IsUndoing;
    }

    [RelayCommand(CanExecute = nameof(CanExecuteUndo))]
    private async Task UndoAsync()
    {
        if (IsUndoing || IsExpired)
            return;

        try
        {
            IsUndoing = true;
            CanUndo = false;

            await _undoManager.UndoByIdAsync(_changeId);
        }
        finally
        {
            IsUndoing = false;
        }
    }

    private bool CanExecuteUndo() => CanUndo && !IsExpired && !IsUndoing;

    [RelayCommand]
    private void Pause()
    {
        if (!IsPaused)
        {
            _undoManager.PauseCountdown(_changeId);
            IsPaused = true;
        }
    }

    [RelayCommand]
    private void Resume()
    {
        if (IsPaused)
        {
            _undoManager.ResumeCountdown(_changeId);
            IsPaused = false;
        }
    }

    [RelayCommand]
    private void ExtendTime()
    {
        _undoManager.ExtendTime(_changeId, TimeSpan.FromMinutes(10));
    }

    [RelayCommand]
    private void Dismiss()
    {
        _undoManager.Dismiss(_changeId);
    }

    public void Dispose()
    {
        _undoManager.TimeRemainingChanged -= OnTimeRemainingChanged;
        _undoManager.UndoExpired -= OnUndoExpired;
    }
}
```

### Dependency Injection Registration

```csharp
// src/SeniorIntern.Desktop/Extensions/ServiceCollectionExtensions.cs
using Microsoft.Extensions.DependencyInjection;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Services;

namespace SeniorIntern.Desktop.Extensions;

public static partial class ServiceCollectionExtensions
{
    /// <summary>
    /// Registers undo services with default options.
    /// </summary>
    public static IServiceCollection AddUndoServices(this IServiceCollection services)
    {
        return AddUndoServices(services, UndoOptions.Default);
    }

    /// <summary>
    /// Registers undo services with custom options.
    /// </summary>
    public static IServiceCollection AddUndoServices(
        this IServiceCollection services,
        UndoOptions options)
    {
        services.AddSingleton(options);
        services.AddSingleton<IUndoManager, UndoManager>();

        return services;
    }
}
```

---

## Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/IUndoManager.cs` | Undo manager interface |
| `src/SeniorIntern.Core/Models/UndoState.cs` | Undo state model |
| `src/SeniorIntern.Core/Models/UndoOptions.cs` | Configuration options |
| `src/SeniorIntern.Core/Models/UndoEvents.cs` | Event argument classes |
| `src/SeniorIntern.Services/UndoManager.cs` | Undo manager implementation |
| `src/SeniorIntern.Desktop/ViewModels/UndoCountdownViewModel.cs` | UI ViewModel |

## Files to Modify

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/Extensions/ServiceCollectionExtensions.cs` | Register undo services |

---

## Testing Strategy

### Unit Tests

```csharp
// tests/SeniorIntern.Services.Tests/UndoManagerTests.cs
using Moq;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Services;
using Xunit;

namespace SeniorIntern.Services.Tests;

public class UndoManagerTests : IDisposable
{
    private readonly Mock<IFileChangeService> _changeServiceMock;
    private readonly UndoManager _undoManager;
    private readonly UndoOptions _options;

    public UndoManagerTests()
    {
        _changeServiceMock = new Mock<IFileChangeService>();
        _options = new UndoOptions
        {
            UndoWindow = TimeSpan.FromMinutes(5),
            CleanupInterval = TimeSpan.FromSeconds(30),
            UiUpdateInterval = TimeSpan.FromMilliseconds(100)
        };

        _undoManager = new UndoManager(
            _changeServiceMock.Object,
            _options);
    }

    public void Dispose()
    {
        _undoManager.Dispose();
    }

    #region Event Handling Tests

    [Fact]
    public void OnFileChanged_WithCanUndo_RaisesUndoAvailable()
    {
        // Arrange
        UndoAvailableEventArgs? capturedArgs = null;
        _undoManager.UndoAvailable += (s, e) => capturedArgs = e;

        var eventArgs = new FileChangedEventArgs
        {
            FilePath = "/workspace/test.cs",
            RelativePath = "test.cs",
            ChangeType = FileChangeType.Modified,
            CanUndo = true
        };

        // Act
        _changeServiceMock.Raise(c => c.FileChanged += null, eventArgs);

        // Assert
        Assert.NotNull(capturedArgs);
        Assert.Equal("/workspace/test.cs", capturedArgs.FilePath);
        Assert.Equal(FileChangeType.Modified, capturedArgs.ChangeType);
        Assert.True(_undoManager.HasPendingUndos);
    }

    [Fact]
    public void OnFileChanged_WithoutCanUndo_DoesNotRaiseEvent()
    {
        // Arrange
        var eventRaised = false;
        _undoManager.UndoAvailable += (s, e) => eventRaised = true;

        var eventArgs = new FileChangedEventArgs
        {
            FilePath = "/workspace/test.cs",
            RelativePath = "test.cs",
            ChangeType = FileChangeType.Modified,
            CanUndo = false
        };

        // Act
        _changeServiceMock.Raise(c => c.FileChanged += null, eventArgs);

        // Assert
        Assert.False(eventRaised);
        Assert.False(_undoManager.HasPendingUndos);
    }

    #endregion

    #region Query Tests

    [Fact]
    public void CanUndo_WithPendingState_ReturnsTrue()
    {
        // Arrange
        SimulateFileChange("/workspace/test.cs", "test.cs");

        // Act
        var canUndo = _undoManager.CanUndo("/workspace/test.cs");

        // Assert
        Assert.True(canUndo);
    }

    [Fact]
    public void CanUndo_WithoutPendingState_ReturnsFalse()
    {
        // Act
        var canUndo = _undoManager.CanUndo("/workspace/nonexistent.cs");

        // Assert
        Assert.False(canUndo);
    }

    [Fact]
    public void GetTimeRemaining_WithPendingState_ReturnsPositive()
    {
        // Arrange
        SimulateFileChange("/workspace/test.cs", "test.cs");

        // Act
        var timeRemaining = _undoManager.GetTimeRemaining("/workspace/test.cs");

        // Assert
        Assert.True(timeRemaining > TimeSpan.Zero);
        Assert.True(timeRemaining <= _options.UndoWindow);
    }

    [Fact]
    public void GetAllPendingUndos_ReturnsAllStates()
    {
        // Arrange
        SimulateFileChange("/workspace/file1.cs", "file1.cs");
        SimulateFileChange("/workspace/file2.cs", "file2.cs");
        SimulateFileChange("/workspace/file3.cs", "file3.cs");

        // Act
        var pending = _undoManager.GetAllPendingUndos();

        // Assert
        Assert.Equal(3, pending.Count);
    }

    #endregion

    #region Undo Operation Tests

    [Fact]
    public async Task UndoAsync_WithPendingState_CallsChangeService()
    {
        // Arrange
        SimulateFileChange("/workspace/test.cs", "test.cs");

        _changeServiceMock
            .Setup(c => c.UndoChangeAsync(It.IsAny<Guid>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(true);

        // Act
        var result = await _undoManager.UndoAsync("/workspace/test.cs");

        // Assert
        Assert.True(result);
        _changeServiceMock.Verify(
            c => c.UndoChangeAsync(It.IsAny<Guid>(), It.IsAny<CancellationToken>()),
            Times.Once);
    }

    [Fact]
    public async Task UndoAsync_RemovesStateAfterCompletion()
    {
        // Arrange
        SimulateFileChange("/workspace/test.cs", "test.cs");

        _changeServiceMock
            .Setup(c => c.UndoChangeAsync(It.IsAny<Guid>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(true);

        // Act
        await _undoManager.UndoAsync("/workspace/test.cs");

        // Assert
        Assert.False(_undoManager.CanUndo("/workspace/test.cs"));
        Assert.Equal(0, _undoManager.PendingUndoCount);
    }

    [Fact]
    public async Task UndoAsync_RaisesUndoCompletedEvent()
    {
        // Arrange
        SimulateFileChange("/workspace/test.cs", "test.cs");

        _changeServiceMock
            .Setup(c => c.UndoChangeAsync(It.IsAny<Guid>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(true);

        UndoCompletedEventArgs? capturedArgs = null;
        _undoManager.UndoCompleted += (s, e) => capturedArgs = e;

        // Act
        await _undoManager.UndoAsync("/workspace/test.cs");

        // Assert
        Assert.NotNull(capturedArgs);
        Assert.True(capturedArgs.Success);
        Assert.Equal("/workspace/test.cs", capturedArgs.FilePath);
    }

    [Fact]
    public async Task UndoAllAsync_UndoesAllPendingChanges()
    {
        // Arrange
        SimulateFileChange("/workspace/file1.cs", "file1.cs");
        SimulateFileChange("/workspace/file2.cs", "file2.cs");

        _changeServiceMock
            .Setup(c => c.UndoChangeAsync(It.IsAny<Guid>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(true);

        // Act
        var count = await _undoManager.UndoAllAsync();

        // Assert
        Assert.Equal(2, count);
        Assert.Equal(0, _undoManager.PendingUndoCount);
    }

    #endregion

    #region Timer Management Tests

    [Fact]
    public void PauseCountdown_StopsTimer()
    {
        // Arrange
        SimulateFileChange("/workspace/test.cs", "test.cs");
        var state = _undoManager.GetUndoState("/workspace/test.cs");
        var changeId = state!.ChangeId;

        // Act
        var result = _undoManager.PauseCountdown(changeId);

        // Assert
        Assert.True(result);
        var updatedState = _undoManager.GetUndoStateById(changeId);
        Assert.True(updatedState!.IsPaused);
    }

    [Fact]
    public void ResumeCountdown_RestartsTimer()
    {
        // Arrange
        SimulateFileChange("/workspace/test.cs", "test.cs");
        var state = _undoManager.GetUndoState("/workspace/test.cs");
        var changeId = state!.ChangeId;

        _undoManager.PauseCountdown(changeId);

        // Act
        var result = _undoManager.ResumeCountdown(changeId);

        // Assert
        Assert.True(result);
        var updatedState = _undoManager.GetUndoStateById(changeId);
        Assert.False(updatedState!.IsPaused);
    }

    [Fact]
    public void ExtendTime_IncreasesExpiration()
    {
        // Arrange
        SimulateFileChange("/workspace/test.cs", "test.cs");
        var state = _undoManager.GetUndoState("/workspace/test.cs");
        var changeId = state!.ChangeId;
        var originalExpires = state.ExpiresAt;

        // Act
        var result = _undoManager.ExtendTime(changeId, TimeSpan.FromMinutes(10));

        // Assert
        Assert.True(result);
        var updatedState = _undoManager.GetUndoStateById(changeId);
        Assert.True(updatedState!.ExpiresAt > originalExpires);
    }

    [Fact]
    public void Dismiss_RemovesState()
    {
        // Arrange
        SimulateFileChange("/workspace/test.cs", "test.cs");
        var state = _undoManager.GetUndoState("/workspace/test.cs");
        var changeId = state!.ChangeId;

        // Act
        var result = _undoManager.Dismiss(changeId);

        // Assert
        Assert.True(result);
        Assert.False(_undoManager.CanUndoById(changeId));
    }

    #endregion

    #region Expiration Tests

    [Fact]
    public async Task ExpiredUndo_RaisesUndoExpiredEvent()
    {
        // Arrange
        var shortOptions = new UndoOptions
        {
            UndoWindow = TimeSpan.FromMilliseconds(100),
            CleanupInterval = TimeSpan.FromMilliseconds(50)
        };

        using var manager = new UndoManager(
            _changeServiceMock.Object,
            shortOptions);

        UndoExpiredEventArgs? capturedArgs = null;
        manager.UndoExpired += (s, e) => capturedArgs = e;

        // Simulate file change
        var eventArgs = new FileChangedEventArgs
        {
            FilePath = "/workspace/test.cs",
            RelativePath = "test.cs",
            ChangeType = FileChangeType.Modified,
            CanUndo = true
        };
        _changeServiceMock.Raise(c => c.FileChanged += null, eventArgs);

        // Act - wait for expiration
        await Task.Delay(300);

        // Assert
        Assert.NotNull(capturedArgs);
        Assert.Equal("/workspace/test.cs", capturedArgs.FilePath);
    }

    [Fact]
    public async Task AllUndosExpired_RaisesAllUndosExpiredEvent()
    {
        // Arrange
        var shortOptions = new UndoOptions
        {
            UndoWindow = TimeSpan.FromMilliseconds(100),
            CleanupInterval = TimeSpan.FromMilliseconds(50)
        };

        using var manager = new UndoManager(
            _changeServiceMock.Object,
            shortOptions);

        var eventRaised = false;
        manager.AllUndosExpired += (s, e) => eventRaised = true;

        // Simulate file change
        var eventArgs = new FileChangedEventArgs
        {
            FilePath = "/workspace/test.cs",
            RelativePath = "test.cs",
            ChangeType = FileChangeType.Modified,
            CanUndo = true
        };
        _changeServiceMock.Raise(c => c.FileChanged += null, eventArgs);

        // Act - wait for expiration
        await Task.Delay(300);

        // Assert
        Assert.True(eventRaised);
    }

    #endregion

    #region Helper Methods

    private void SimulateFileChange(string filePath, string relativePath)
    {
        var eventArgs = new FileChangedEventArgs
        {
            FilePath = filePath,
            RelativePath = relativePath,
            ChangeType = FileChangeType.Modified,
            CanUndo = true
        };

        _changeServiceMock.Raise(c => c.FileChanged += null, eventArgs);
    }

    #endregion
}
```

### UndoState Tests

```csharp
// tests/SeniorIntern.Core.Tests/UndoStateTests.cs
namespace SeniorIntern.Core.Tests;

public class UndoStateTests
{
    [Fact]
    public void TimeRemaining_NotExpired_ReturnsPositive()
    {
        // Arrange
        var state = new UndoState
        {
            CreatedAt = DateTime.UtcNow,
            ExpiresAt = DateTime.UtcNow.AddMinutes(30)
        };

        // Act
        var remaining = state.TimeRemaining;

        // Assert
        Assert.True(remaining > TimeSpan.Zero);
    }

    [Fact]
    public void TimeRemaining_Expired_ReturnsZero()
    {
        // Arrange
        var state = new UndoState
        {
            CreatedAt = DateTime.UtcNow.AddMinutes(-60),
            ExpiresAt = DateTime.UtcNow.AddMinutes(-30)
        };

        // Act
        var remaining = state.TimeRemaining;

        // Assert
        Assert.Equal(TimeSpan.Zero, remaining);
    }

    [Fact]
    public void IsExpired_BeforeExpiration_ReturnsFalse()
    {
        // Arrange
        var state = new UndoState
        {
            CreatedAt = DateTime.UtcNow,
            ExpiresAt = DateTime.UtcNow.AddMinutes(30)
        };

        // Assert
        Assert.False(state.IsExpired);
    }

    [Fact]
    public void IsExpired_AfterExpiration_ReturnsTrue()
    {
        // Arrange
        var state = new UndoState
        {
            CreatedAt = DateTime.UtcNow.AddMinutes(-60),
            ExpiresAt = DateTime.UtcNow.AddMinutes(-30)
        };

        // Assert
        Assert.True(state.IsExpired);
    }

    [Fact]
    public void ProgressPercentage_JustCreated_NearHundred()
    {
        // Arrange
        var state = new UndoState
        {
            CreatedAt = DateTime.UtcNow,
            ExpiresAt = DateTime.UtcNow.AddMinutes(30)
        };

        // Assert
        Assert.True(state.ProgressPercentage > 99);
    }

    [Fact]
    public void ProgressPercentage_HalfwayThrough_NearFifty()
    {
        // Arrange
        var state = new UndoState
        {
            CreatedAt = DateTime.UtcNow.AddMinutes(-15),
            ExpiresAt = DateTime.UtcNow.AddMinutes(15)
        };

        // Assert
        Assert.InRange(state.ProgressPercentage, 45, 55);
    }

    [Fact]
    public void FormattedTimeRemaining_UnderOneHour_ShowsMinutesSeconds()
    {
        // Arrange
        var state = new UndoState
        {
            CreatedAt = DateTime.UtcNow,
            ExpiresAt = DateTime.UtcNow.AddMinutes(30)
        };

        // Assert
        Assert.Matches(@"\d{2}:\d{2}", state.FormattedTimeRemaining);
    }

    [Fact]
    public void IsExpiringSoon_UnderThreshold_ReturnsTrue()
    {
        // Arrange
        var state = new UndoState
        {
            CreatedAt = DateTime.UtcNow.AddMinutes(-29),
            ExpiresAt = DateTime.UtcNow.AddSeconds(30)
        };

        // Assert
        Assert.True(state.IsExpiringSoon);
    }
}
```

---

## Acceptance Criteria

### Functional Requirements

- [ ] `UndoAvailable` event raised when file change with `CanUndo=true` occurs
- [ ] `UndoExpired` event raised when undo window passes
- [ ] `UndoCompleted` event raised when undo operation finishes
- [ ] `TimeRemainingChanged` event raised every second
- [ ] `UndoAsync` restores file to previous state
- [ ] `UndoByIdAsync` finds and undoes specific change
- [ ] `UndoAllAsync` undoes all pending changes
- [ ] `CanUndo` returns correct availability status
- [ ] `GetTimeRemaining` returns accurate countdown
- [ ] `GetAllPendingUndos` returns all active states

### Timer Requirements

- [ ] Expiration timer fires at correct time per change
- [ ] UI update timer fires every second
- [ ] Cleanup timer removes expired states
- [ ] Paused countdown does not expire
- [ ] Resumed countdown continues with adjusted time
- [ ] Extended time increases expiration correctly

### State Management Requirements

- [ ] State created on file change event
- [ ] State removed on undo completion
- [ ] State removed on expiration
- [ ] State removed on dismiss
- [ ] Max pending undos enforced (oldest removed)
- [ ] File-to-changeId mapping maintained

### UI Integration Requirements

- [ ] `UndoCountdownViewModel` updates in real-time
- [ ] Progress percentage decreases over time
- [ ] IsExpiringSoon activates at threshold
- [ ] Undo command disabled when expired
- [ ] Pause/Resume toggles countdown

### Event Requirements

- [ ] All events include required properties
- [ ] Events raised on correct thread for UI
- [ ] `AllUndosExpired` raised when last undo completes/expires

---

## Design Decisions

### Decision 1: Per-Change Expiration Timers

**Choice**: Individual `Task.Delay` with `CancellationTokenSource` per change

**Rationale**:
- Precise expiration time per change
- Can be cancelled on undo/pause/extend
- Doesn't require polling for each check
- Scales well with few active undos

**Alternatives Considered**:
- Single timer checking all: Less precise, more polling
- `System.Timers.Timer` per change: More resource intensive
- Only cleanup timer: Imprecise expiration notifications

### Decision 2: Dual Timer System

**Choice**: Separate UI update (1s) and cleanup (1min) timers

**Rationale**:
- UI needs frequent updates for countdown display
- Cleanup doesn't need to run as often
- Separates concerns
- Reduces unnecessary work

**Alternatives Considered**:
- Single timer for both: Either too frequent or too slow
- Only on-demand: UI wouldn't update smoothly

### Decision 3: ConcurrentDictionary for State Storage

**Choice**: `ConcurrentDictionary<Guid, UndoState>` with separate file path mapping

**Rationale**:
- Thread-safe without full locking
- O(1) lookup by change ID
- Separate mapping allows file path lookup
- Handles concurrent file changes

**Alternatives Considered**:
- Single dictionary with lock: Simpler but more contention
- Immutable collections: More allocation on updates
- Database: Overkill for transient state

### Decision 4: TimeSpan-Based Progress

**Choice**: Calculate progress as percentage of remaining vs total time

**Rationale**:
- Intuitive for progress bars
- Accounts for pause time
- Works with any undo window duration
- Easy to understand (100% = just started)

**Alternatives Considered**:
- Time-based string only: Less visual
- Absolute time display: Harder to gauge urgency

### Decision 5: Pause/Resume Capability

**Choice**: Optional pause with accumulated pause time

**Rationale**:
- User control over expiration
- Useful when stepping away briefly
- Accumulated time handles multiple pauses
- Doesn't extend beyond original window by default

**Alternatives Considered**:
- No pause: Less flexible
- Reset timer on resume: Could be abused
- Infinite pause: Defeats purpose of time window

### Decision 6: Event-Driven UI Updates

**Choice**: `TimeRemainingChanged` event with all states

**Rationale**:
- Single event for all countdown updates
- UI can decide what to display
- Efficient batch update
- Includes expiring-soon list

**Alternatives Considered**:
- Per-state events: Too many events
- Observable properties: Complex with multiple states
- Direct UI polling: Tight coupling

---

## Dependencies

### Required Services

| Service | Interface | Purpose |
|---------|-----------|---------|
| File Change Service | `IFileChangeService` | Perform actual undo operations |
| Logger | `ILogger<UndoManager>` | Diagnostic logging (optional) |

### NuGet Packages

| Package | Version | Purpose |
|---------|---------|---------|
| `Microsoft.Extensions.Logging.Abstractions` | 8.0+ | ILogger interface |
| `CommunityToolkit.Mvvm` | 8.0+ | MVVM components for ViewModel |

---

## Future Considerations

1. **Redo support**: Re-apply undone changes
2. **Persistent undo**: Save undo state across sessions
3. **Grouped undo**: Undo multiple related changes together
4. **Undo preview**: Show what will change before undoing
5. **Keyboard shortcuts**: Global shortcuts for quick undo
6. **Sound notifications**: Audio feedback for expiration
7. **System tray integration**: Notifications when app is minimized
8. **Undo history view**: Full history with timestamps
