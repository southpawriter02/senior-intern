# Design Specification: The Senior Intern v0.4.1e "File Path Inference"

**Status**: _IMPLEMENTED_

## Executive Summary

This document provides a comprehensive implementation specification for v0.4.1e, which implements intelligent file path inference for code blocks extracted from LLM responses. This service analyzes code content, conversation context, and attached files to determine where generated code should be applied in the workspace.

### v0.4.1e Scope

- Create `IFilePathInferenceService` interface for path inference operations
- Implement multi-strategy path inference (explicit, context-based, content-based)
- Implement type/class name extraction for various programming languages
- Create confidence scoring system for inferred paths
- Handle edge cases: new files, renamed types, partial matches
- Integrate with `FileContext` model from v0.3.4

### Key Deliverables

| Deliverable | Description |
|-------------|-------------|
| IFilePathInferenceService | Interface for file path inference operations |
| FilePathInferenceService | Full implementation with multi-strategy inference |
| PathInferenceResult | Result model with path, confidence, and strategy used |
| InferenceStrategy | Enum describing which strategy produced the result |
| TypeNameExtractor | Helper class for extracting type names from code |

---

## Prerequisites

Before implementing v0.4.1e, ensure:

- v0.4.1a is complete (CodeBlock, CodeProposal models)
- v0.4.1b is complete (ICodeBlockParserService)
- v0.4.1c is complete (ILanguageDetectionService)
- v0.4.1d is complete (IBlockClassificationService)
- v0.3.4 is complete (FileContext model for attached files)

---

## Feature Overview

```
┌───────────────────────────────────────────────────────────────────────┐
│                    v0.4.1e Feature Tree                                │
├───────────────────────────────────────────────────────────────────────┤
│                                                                        │
│  IFilePathInferenceService                                             │
│  ├── Primary Methods                                                   │
│  │   ├── InferTargetFilePath(block, context) → PathInferenceResult    │
│  │   │   ├── Strategy 1: Explicit path (from fence or comment)       │
│  │   │   ├── Strategy 2: Single context (one attached file)          │
│  │   │   ├── Strategy 3: Language match (match by file extension)    │
│  │   │   ├── Strategy 4: Type name match (find file by class name)   │
│  │   │   ├── Strategy 5: Content similarity (fuzzy matching)         │
│  │   │   └── Strategy 6: Generate new path (create from type name)   │
│  │   │                                                                 │
│  │   ├── InferFileNameFromContent(content, language) → string?       │
│  │   │   ├── Extract primary type/class name                         │
│  │   │   ├── Handle multiple declarations (pick first public)        │
│  │   │   └── Language-specific patterns                              │
│  │   │                                                                 │
│  │   ├── GetConfidenceScore(block, path, strategy) → float           │
│  │   │   ├── Explicit path: 1.0                                      │
│  │   │   ├── Single context: 0.95                                    │
│  │   │   ├── Language match: 0.85                                    │
│  │   │   ├── Type name match: 0.75                                   │
│  │   │   ├── Content similarity: 0.60                                │
│  │   │   └── Generated new: 0.50                                     │
│  │   │                                                                 │
│  │   └── GetExtensionForLanguage(language) → string?                 │
│  │                                                                     │
│  └── Events                                                            │
│      ├── PathInferred (EventHandler<PathInferredEventArgs>)           │
│      └── InferenceAmbiguous (EventHandler<AmbiguousPathEventArgs>)    │
│                                                                        │
│  TypeNameExtractor (Internal Helper)                                   │
│  ├── ExtractPrimaryTypeName(content, language) → string?             │
│  ├── ExtractAllTypeNames(content, language) → string[]               │
│  ├── GetNamespacePrefix(content, language) → string?                 │
│  └── BuildSuggestedPath(typeName, namespace, language) → string      │
│                                                                        │
└───────────────────────────────────────────────────────────────────────┘
```

---

## Architecture Diagrams

### Inference Strategy Cascade

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    Path Inference Strategy Cascade                       │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  Input: CodeBlock + IReadOnlyList<FileContext>                          │
│                            │                                             │
│                            ▼                                             │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │ Strategy 1: Explicit Path                                        │   │
│  │ Check if block already has TargetFilePath set (from fence/comment) │   │
│  │ Confidence: 1.0                                                   │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                            │ not found                                   │
│                            ▼                                             │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │ Strategy 2: Single Context                                        │   │
│  │ If exactly one file attached, assume it's the target              │   │
│  │ Confidence: 0.95                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                            │ not found                                   │
│                            ▼                                             │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │ Strategy 3: Language Match                                        │   │
│  │ Match block language to attached file extensions                  │   │
│  │ Confidence: 0.85                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                            │ not found or ambiguous                      │
│                            ▼                                             │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │ Strategy 4: Type Name Match                                       │   │
│  │ Extract class/type name from content, match to attached files     │   │
│  │ Confidence: 0.75                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                            │ not found                                   │
│                            ▼                                             │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │ Strategy 5: Content Similarity                                    │   │
│  │ Compare code patterns, imports, namespace with attached files     │   │
│  │ Confidence: 0.60                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                            │ not found                                   │
│                            ▼                                             │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │ Strategy 6: Generate New Path                                     │   │
│  │ Build path from type name + language extension                    │   │
│  │ Confidence: 0.50                                                  │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                            │ not possible                                │
│                            ▼                                             │
│                   Return null (no path inferred)                         │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### Type Name Extraction Flow

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    Type Name Extraction Flow                             │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  Input: string content, string language                                  │
│                            │                                             │
│                            ▼                                             │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │ 1. Get Language-Specific Patterns                                 │   │
│  │    ├── C#:     class, record, struct, interface, enum            │   │
│  │    ├── Java:   class, interface, enum, record                    │   │
│  │    ├── TS/JS:  class, interface, function, const                 │   │
│  │    ├── Python: class, def (for modules)                          │   │
│  │    ├── Go:     type struct, type interface, func                 │   │
│  │    └── Rust:   struct, enum, trait, fn                           │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                            │                                             │
│                            ▼                                             │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │ 2. Apply Patterns in Priority Order                               │   │
│  │    ├── Public types first                                         │   │
│  │    ├── Classes before interfaces                                  │   │
│  │    └── First match wins                                           │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                            │                                             │
│                            ▼                                             │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │ 3. Extract Namespace/Module (if applicable)                       │   │
│  │    ├── C#:     namespace X.Y.Z → "X/Y/Z"                         │   │
│  │    ├── Java:   package x.y.z → "x/y/z"                           │   │
│  │    ├── Python: from x.y import z → "x/y"                         │   │
│  │    └── Go:     package main → ""                                 │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                            │                                             │
│                            ▼                                             │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │ 4. Build Suggested Path                                           │   │
│  │    namespace/TypeName.extension                                   │   │
│  │    Example: "Services/UserService.cs"                             │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### Context Matching Flow

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    Context Matching Flow                                 │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  FileContext[] attachedContext                                           │
│  ┌────────────────────────────────────────────────────────────────────┐ │
│  │ FileContext {                                                      │ │
│  │   FilePath: "src/Services/UserService.cs"                         │ │
│  │   Language: "csharp"                                              │ │
│  │   Content: "public class UserService : IUserService { ... }"      │ │
│  │ }                                                                  │ │
│  └────────────────────────────────────────────────────────────────────┘ │
│                            │                                             │
│                            ▼                                             │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │ Match Criteria (evaluated in order):                              │   │
│  │                                                                   │   │
│  │ 1. Exact Type Match                                               │   │
│  │    ExtractTypeName(block.Content) == GetFileName(context.Path)    │   │
│  │    "UserService" matches "UserService.cs"                         │   │
│  │    → Confidence: 0.90                                             │   │
│  │                                                                   │   │
│  │ 2. Partial Type Match                                             │   │
│  │    FileName contains TypeName OR TypeName contains FileName       │   │
│  │    "UserService" partially matches "IUserService.cs"              │   │
│  │    → Confidence: 0.70                                             │   │
│  │                                                                   │   │
│  │ 3. Extension Match (multiple files)                               │   │
│  │    block.Language == GetLanguageFromExtension(context.Path)       │   │
│  │    Filter to files with matching language                         │   │
│  │    → Confidence: 0.60 (ambiguous, user may need to pick)          │   │
│  │                                                                   │   │
│  │ 4. Content Similarity                                             │   │
│  │    Compare imports, namespace, method signatures                  │   │
│  │    → Confidence: 0.50                                             │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                            │                                             │
│                            ▼                                             │
│  Return best match with highest confidence                               │
│  (or raise AmbiguousPath event if multiple high-confidence matches)      │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## Directory Structure

After v0.4.1e implementation:

```
src/SeniorIntern.Core/
├── Interfaces/
│   └── IFilePathInferenceService.cs             (NEW)
├── Models/
│   ├── PathInferenceResult.cs                   (NEW)
│   └── InferenceStrategy.cs                     (NEW)
└── Events/
    └── PathInferenceEvents.cs                   (NEW)

src/SeniorIntern.Services/
├── FilePathInferenceService.cs                  (NEW)
└── Helpers/
    └── TypeNameExtractor.cs                     (NEW)

tests/SeniorIntern.Services.Tests/
└── FilePathInferenceServiceTests.cs             (NEW)
```

---

## Implementation Details

### Task 1: Create PathInferenceResult Model

**File:** `src/SeniorIntern.Core/Models/PathInferenceResult.cs`

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Result of a file path inference operation.
/// </summary>
public sealed class PathInferenceResult
{
    /// <summary>
    /// The inferred file path (relative to workspace root).
    /// Null if no path could be inferred.
    /// </summary>
    public string? Path { get; init; }

    /// <summary>
    /// Confidence score for the inference (0.0 to 1.0).
    /// Higher values indicate more reliable inference.
    /// </summary>
    public float Confidence { get; init; }

    /// <summary>
    /// The strategy that produced this result.
    /// </summary>
    public InferenceStrategy Strategy { get; init; }

    /// <summary>
    /// Whether a path was successfully inferred.
    /// </summary>
    public bool IsSuccess => !string.IsNullOrEmpty(Path);

    /// <summary>
    /// Whether this inference is ambiguous (multiple possible matches).
    /// </summary>
    public bool IsAmbiguous { get; init; }

    /// <summary>
    /// Alternative paths if the inference was ambiguous.
    /// </summary>
    public IReadOnlyList<string> AlternativePaths { get; init; } = Array.Empty<string>();

    /// <summary>
    /// Whether this path represents a new file to be created.
    /// </summary>
    public bool IsNewFile { get; init; }

    /// <summary>
    /// The type name extracted from content (if applicable).
    /// </summary>
    public string? ExtractedTypeName { get; init; }

    /// <summary>
    /// Human-readable explanation of how the path was inferred.
    /// </summary>
    public string? Explanation { get; init; }

    /// <summary>
    /// Creates a successful result.
    /// </summary>
    public static PathInferenceResult Success(
        string path,
        float confidence,
        InferenceStrategy strategy,
        string? explanation = null) => new()
    {
        Path = path,
        Confidence = confidence,
        Strategy = strategy,
        Explanation = explanation
    };

    /// <summary>
    /// Creates a result indicating no path could be inferred.
    /// </summary>
    public static PathInferenceResult NotFound(string? explanation = null) => new()
    {
        Path = null,
        Confidence = 0,
        Strategy = InferenceStrategy.None,
        Explanation = explanation ?? "Unable to infer target file path"
    };

    /// <summary>
    /// Creates an ambiguous result with multiple possible paths.
    /// </summary>
    public static PathInferenceResult Ambiguous(
        IReadOnlyList<string> paths,
        string? explanation = null) => new()
    {
        Path = paths.FirstOrDefault(),
        Confidence = 0.5f,
        Strategy = InferenceStrategy.Ambiguous,
        IsAmbiguous = true,
        AlternativePaths = paths,
        Explanation = explanation ?? $"Multiple possible targets: {string.Join(", ", paths)}"
    };

    /// <summary>
    /// Creates a result for a new file to be created.
    /// </summary>
    public static PathInferenceResult NewFile(
        string path,
        float confidence,
        string? typeName = null,
        string? explanation = null) => new()
    {
        Path = path,
        Confidence = confidence,
        Strategy = InferenceStrategy.GeneratedNew,
        IsNewFile = true,
        ExtractedTypeName = typeName,
        Explanation = explanation ?? $"New file will be created: {path}"
    };
}

/// <summary>
/// Describes which strategy was used to infer a file path.
/// </summary>
public enum InferenceStrategy
{
    /// <summary>No strategy was applicable.</summary>
    None,

    /// <summary>Path was explicitly specified in fence or comment.</summary>
    ExplicitPath,

    /// <summary>Single file was attached to conversation.</summary>
    SingleContext,

    /// <summary>Matched by programming language.</summary>
    LanguageMatch,

    /// <summary>Matched by extracted type/class name.</summary>
    TypeNameMatch,

    /// <summary>Matched by content similarity analysis.</summary>
    ContentSimilarity,

    /// <summary>Generated a new path from type name.</summary>
    GeneratedNew,

    /// <summary>Multiple paths matched with similar confidence.</summary>
    Ambiguous
}
```

---

### Task 2: Create Path Inference Events

**File:** `src/SeniorIntern.Core/Events/PathInferenceEvents.cs`

```csharp
namespace SeniorIntern.Core.Events;

using SeniorIntern.Core.Models;

/// <summary>
/// Event args for when a path is successfully inferred.
/// </summary>
public sealed class PathInferredEventArgs : EventArgs
{
    /// <summary>The code block that was analyzed.</summary>
    public required CodeBlock CodeBlock { get; init; }

    /// <summary>The inference result.</summary>
    public required PathInferenceResult Result { get; init; }

    /// <summary>Time taken to perform inference.</summary>
    public TimeSpan Duration { get; init; }
}

/// <summary>
/// Event args for when path inference is ambiguous.
/// </summary>
public sealed class AmbiguousPathEventArgs : EventArgs
{
    /// <summary>The code block that was analyzed.</summary>
    public required CodeBlock CodeBlock { get; init; }

    /// <summary>The possible target paths.</summary>
    public required IReadOnlyList<string> PossiblePaths { get; init; }

    /// <summary>Confidence scores for each path.</summary>
    public required IReadOnlyList<float> Confidences { get; init; }

    /// <summary>
    /// Set this to the selected path to resolve the ambiguity.
    /// If not set, the first path will be used.
    /// </summary>
    public string? SelectedPath { get; set; }
}

/// <summary>
/// Event args for when path inference fails.
/// </summary>
public sealed class PathInferenceFailedEventArgs : EventArgs
{
    /// <summary>The code block that was analyzed.</summary>
    public required CodeBlock CodeBlock { get; init; }

    /// <summary>Reason for failure.</summary>
    public required string Reason { get; init; }

    /// <summary>
    /// Set this to manually specify a path.
    /// </summary>
    public string? ManualPath { get; set; }
}
```

---

### Task 3: Create IFilePathInferenceService Interface

**File:** `src/SeniorIntern.Core/Interfaces/IFilePathInferenceService.cs`

```csharp
namespace SeniorIntern.Core.Interfaces;

using SeniorIntern.Core.Events;
using SeniorIntern.Core.Models;

/// <summary>
/// Service for inferring target file paths for code blocks.
/// </summary>
/// <remarks>
/// <para>Uses a cascade of strategies to determine the most likely target file:</para>
/// <list type="number">
///   <item><description>Explicit path from fence syntax or file comment</description></item>
///   <item><description>Single attached file context</description></item>
///   <item><description>Language matching with attached files</description></item>
///   <item><description>Type/class name matching</description></item>
///   <item><description>Content similarity analysis</description></item>
///   <item><description>Generate new path from extracted type name</description></item>
/// </list>
/// </remarks>
public interface IFilePathInferenceService
{
    #region Primary Methods

    /// <summary>
    /// Infer the target file path for a code block.
    /// </summary>
    /// <param name="block">The code block to analyze.</param>
    /// <param name="attachedContext">Files attached to the conversation.</param>
    /// <returns>Inference result with path, confidence, and strategy.</returns>
    PathInferenceResult InferTargetFilePath(
        CodeBlock block,
        IReadOnlyList<FileContext> attachedContext);

    /// <summary>
    /// Infer target paths for multiple code blocks at once.
    /// </summary>
    /// <remarks>
    /// Batch processing allows for cross-block analysis, such as
    /// detecting when multiple blocks target the same file.
    /// </remarks>
    IReadOnlyList<PathInferenceResult> InferTargetFilePaths(
        IReadOnlyList<CodeBlock> blocks,
        IReadOnlyList<FileContext> attachedContext);

    /// <summary>
    /// Extract the primary type/class name from code content.
    /// </summary>
    /// <param name="content">The code content.</param>
    /// <param name="language">The programming language.</param>
    /// <returns>Extracted type name or null.</returns>
    string? InferFileNameFromContent(string content, string? language);

    /// <summary>
    /// Get all type names declared in the content.
    /// </summary>
    IReadOnlyList<string> ExtractAllTypeNames(string content, string? language);

    /// <summary>
    /// Get the appropriate file extension for a language.
    /// </summary>
    string? GetExtensionForLanguage(string? language);

    #endregion

    #region Configuration

    /// <summary>
    /// Minimum confidence threshold for accepting an inferred path.
    /// Paths below this threshold will be marked as ambiguous.
    /// Default: 0.6
    /// </summary>
    float MinimumConfidenceThreshold { get; set; }

    /// <summary>
    /// Whether to suggest new file paths when no match is found.
    /// Default: true
    /// </summary>
    bool AllowNewFileSuggestions { get; set; }

    /// <summary>
    /// Base directory for new file suggestions (relative to workspace).
    /// Default: "src"
    /// </summary>
    string NewFileBaseDirectory { get; set; }

    #endregion

    #region Events

    /// <summary>
    /// Raised when a path is successfully inferred.
    /// </summary>
    event EventHandler<PathInferredEventArgs>? PathInferred;

    /// <summary>
    /// Raised when multiple paths match with similar confidence.
    /// </summary>
    event EventHandler<AmbiguousPathEventArgs>? InferenceAmbiguous;

    /// <summary>
    /// Raised when no path could be inferred.
    /// </summary>
    event EventHandler<PathInferenceFailedEventArgs>? InferenceFailed;

    #endregion
}
```

---

### Task 4: Create TypeNameExtractor Helper

**File:** `src/SeniorIntern.Services/Helpers/TypeNameExtractor.cs`

```csharp
namespace SeniorIntern.Services.Helpers;

using System.Text.RegularExpressions;

/// <summary>
/// Helper class for extracting type/class names from code content.
/// </summary>
internal static partial class TypeNameExtractor
{
    #region Compiled Regex Patterns

    // C# patterns
    [GeneratedRegex(
        @"(?:public|internal|private|protected)?\s*(?:sealed|abstract|static|partial)?\s*(?:class|record|struct)\s+(\w+)",
        RegexOptions.Compiled)]
    private static partial Regex CSharpClassPattern();

    [GeneratedRegex(
        @"(?:public|internal)?\s*interface\s+(I\w+)",
        RegexOptions.Compiled)]
    private static partial Regex CSharpInterfacePattern();

    [GeneratedRegex(
        @"(?:public|internal)?\s*enum\s+(\w+)",
        RegexOptions.Compiled)]
    private static partial Regex CSharpEnumPattern();

    [GeneratedRegex(
        @"namespace\s+([\w.]+)",
        RegexOptions.Compiled)]
    private static partial Regex CSharpNamespacePattern();

    // TypeScript/JavaScript patterns
    [GeneratedRegex(
        @"(?:export\s+)?(?:default\s+)?(?:abstract\s+)?class\s+(\w+)",
        RegexOptions.Compiled)]
    private static partial Regex TsJsClassPattern();

    [GeneratedRegex(
        @"(?:export\s+)?interface\s+(\w+)",
        RegexOptions.Compiled)]
    private static partial Regex TsJsInterfacePattern();

    [GeneratedRegex(
        @"(?:export\s+)?(?:async\s+)?function\s+(\w+)",
        RegexOptions.Compiled)]
    private static partial Regex TsJsFunctionPattern();

    [GeneratedRegex(
        @"(?:export\s+)?const\s+(\w+)\s*=",
        RegexOptions.Compiled)]
    private static partial Regex TsJsConstPattern();

    // Python patterns
    [GeneratedRegex(
        @"class\s+(\w+)\s*[:\(]",
        RegexOptions.Compiled)]
    private static partial Regex PythonClassPattern();

    [GeneratedRegex(
        @"def\s+(\w+)\s*\(",
        RegexOptions.Compiled)]
    private static partial Regex PythonFunctionPattern();

    // Java patterns
    [GeneratedRegex(
        @"(?:public|private|protected)?\s*(?:final|abstract)?\s*class\s+(\w+)",
        RegexOptions.Compiled)]
    private static partial Regex JavaClassPattern();

    [GeneratedRegex(
        @"(?:public)?\s*interface\s+(\w+)",
        RegexOptions.Compiled)]
    private static partial Regex JavaInterfacePattern();

    [GeneratedRegex(
        @"package\s+([\w.]+)",
        RegexOptions.Compiled)]
    private static partial Regex JavaPackagePattern();

    // Go patterns
    [GeneratedRegex(
        @"type\s+(\w+)\s+struct",
        RegexOptions.Compiled)]
    private static partial Regex GoStructPattern();

    [GeneratedRegex(
        @"type\s+(\w+)\s+interface",
        RegexOptions.Compiled)]
    private static partial Regex GoInterfacePattern();

    [GeneratedRegex(
        @"func\s+(\w+)\s*\(",
        RegexOptions.Compiled)]
    private static partial Regex GoFunctionPattern();

    [GeneratedRegex(
        @"package\s+(\w+)",
        RegexOptions.Compiled)]
    private static partial Regex GoPackagePattern();

    // Rust patterns
    [GeneratedRegex(
        @"(?:pub\s+)?struct\s+(\w+)",
        RegexOptions.Compiled)]
    private static partial Regex RustStructPattern();

    [GeneratedRegex(
        @"(?:pub\s+)?enum\s+(\w+)",
        RegexOptions.Compiled)]
    private static partial Regex RustEnumPattern();

    [GeneratedRegex(
        @"(?:pub\s+)?trait\s+(\w+)",
        RegexOptions.Compiled)]
    private static partial Regex RustTraitPattern();

    [GeneratedRegex(
        @"mod\s+(\w+)",
        RegexOptions.Compiled)]
    private static partial Regex RustModPattern();

    #endregion

    /// <summary>
    /// Extract the primary (first public) type name from code.
    /// </summary>
    public static string? ExtractPrimaryTypeName(string content, string? language)
    {
        if (string.IsNullOrWhiteSpace(content) || string.IsNullOrEmpty(language))
            return null;

        var patterns = GetPatterns(language);
        foreach (var pattern in patterns)
        {
            var match = pattern.Match(content);
            if (match.Success && match.Groups.Count > 1)
            {
                return match.Groups[1].Value;
            }
        }

        return null;
    }

    /// <summary>
    /// Extract all type names declared in the content.
    /// </summary>
    public static IReadOnlyList<string> ExtractAllTypeNames(string content, string? language)
    {
        if (string.IsNullOrWhiteSpace(content) || string.IsNullOrEmpty(language))
            return Array.Empty<string>();

        var results = new HashSet<string>(StringComparer.Ordinal);
        var patterns = GetPatterns(language);

        foreach (var pattern in patterns)
        {
            foreach (Match match in pattern.Matches(content))
            {
                if (match.Success && match.Groups.Count > 1)
                {
                    results.Add(match.Groups[1].Value);
                }
            }
        }

        return results.ToList();
    }

    /// <summary>
    /// Extract namespace/package from code.
    /// </summary>
    public static string? ExtractNamespace(string content, string? language)
    {
        if (string.IsNullOrWhiteSpace(content) || string.IsNullOrEmpty(language))
            return null;

        var pattern = language.ToLowerInvariant() switch
        {
            "csharp" or "cs" => CSharpNamespacePattern(),
            "java" => JavaPackagePattern(),
            "go" or "golang" => GoPackagePattern(),
            _ => null
        };

        if (pattern == null)
            return null;

        var match = pattern.Match(content);
        return match.Success && match.Groups.Count > 1
            ? match.Groups[1].Value
            : null;
    }

    /// <summary>
    /// Build a suggested file path from type name and namespace.
    /// </summary>
    public static string BuildSuggestedPath(
        string typeName,
        string? namespaceOrPackage,
        string extension)
    {
        if (string.IsNullOrEmpty(namespaceOrPackage))
        {
            return $"{typeName}{extension}";
        }

        // Convert namespace to path (e.g., "SeniorIntern.Core.Models" -> "SeniorIntern/Core/Models")
        var pathPrefix = namespaceOrPackage.Replace('.', '/');
        return $"{pathPrefix}/{typeName}{extension}";
    }

    /// <summary>
    /// Get the extraction patterns for a language, ordered by priority.
    /// </summary>
    private static Regex[] GetPatterns(string? language)
    {
        return language?.ToLowerInvariant() switch
        {
            "csharp" or "cs" => new[]
            {
                CSharpClassPattern(),
                CSharpInterfacePattern(),
                CSharpEnumPattern()
            },

            "typescript" or "ts" or "javascript" or "js" => new[]
            {
                TsJsClassPattern(),
                TsJsInterfacePattern(),
                TsJsFunctionPattern(),
                TsJsConstPattern()
            },

            "python" or "py" => new[]
            {
                PythonClassPattern(),
                PythonFunctionPattern()
            },

            "java" => new[]
            {
                JavaClassPattern(),
                JavaInterfacePattern()
            },

            "go" or "golang" => new[]
            {
                GoStructPattern(),
                GoInterfacePattern(),
                GoFunctionPattern()
            },

            "rust" or "rs" => new[]
            {
                RustStructPattern(),
                RustEnumPattern(),
                RustTraitPattern()
            },

            _ => Array.Empty<Regex>()
        };
    }
}
```

---

### Task 5: Create FilePathInferenceService Implementation

**File:** `src/SeniorIntern.Services/FilePathInferenceService.cs`

```csharp
namespace SeniorIntern.Services;

using System.Diagnostics;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Events;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Services.Helpers;

/// <summary>
/// Service for inferring target file paths for code blocks.
/// </summary>
public sealed class FilePathInferenceService : IFilePathInferenceService
{
    private readonly ILanguageDetectionService _languageService;
    private readonly ILogger<FilePathInferenceService>? _logger;

    public float MinimumConfidenceThreshold { get; set; } = 0.6f;
    public bool AllowNewFileSuggestions { get; set; } = true;
    public string NewFileBaseDirectory { get; set; } = "src";

    public event EventHandler<PathInferredEventArgs>? PathInferred;
    public event EventHandler<AmbiguousPathEventArgs>? InferenceAmbiguous;
    public event EventHandler<PathInferenceFailedEventArgs>? InferenceFailed;

    public FilePathInferenceService(
        ILanguageDetectionService languageService,
        ILogger<FilePathInferenceService>? logger = null)
    {
        _languageService = languageService;
        _logger = logger;
    }

    #region Primary Methods

    public PathInferenceResult InferTargetFilePath(
        CodeBlock block,
        IReadOnlyList<FileContext> attachedContext)
    {
        var stopwatch = Stopwatch.StartNew();

        try
        {
            // Strategy 1: Explicit path already set
            if (!string.IsNullOrEmpty(block.TargetFilePath))
            {
                var result = PathInferenceResult.Success(
                    NormalizePath(block.TargetFilePath),
                    1.0f,
                    InferenceStrategy.ExplicitPath,
                    "Path explicitly specified in code block");

                RaisePathInferred(block, result, stopwatch.Elapsed);
                return result;
            }

            // Strategy 2: Single attached context
            if (attachedContext.Count == 1)
            {
                var result = PathInferenceResult.Success(
                    attachedContext[0].FilePath,
                    0.95f,
                    InferenceStrategy.SingleContext,
                    "Single file attached to conversation");

                RaisePathInferred(block, result, stopwatch.Elapsed);
                return result;
            }

            // Strategy 3: Language match
            if (!string.IsNullOrEmpty(block.Language) && attachedContext.Count > 0)
            {
                var languageMatchResult = TryLanguageMatch(block, attachedContext);
                if (languageMatchResult != null)
                {
                    RaisePathInferred(block, languageMatchResult, stopwatch.Elapsed);
                    return languageMatchResult;
                }
            }

            // Strategy 4: Type name match
            var typeName = InferFileNameFromContent(block.Content, block.Language);
            if (!string.IsNullOrEmpty(typeName) && attachedContext.Count > 0)
            {
                var typeMatchResult = TryTypeNameMatch(typeName, block, attachedContext);
                if (typeMatchResult != null)
                {
                    RaisePathInferred(block, typeMatchResult, stopwatch.Elapsed);
                    return typeMatchResult;
                }
            }

            // Strategy 5: Content similarity (if we have attached context)
            if (attachedContext.Count > 0)
            {
                var similarityResult = TryContentSimilarity(block, attachedContext);
                if (similarityResult != null)
                {
                    RaisePathInferred(block, similarityResult, stopwatch.Elapsed);
                    return similarityResult;
                }
            }

            // Strategy 6: Generate new path
            if (AllowNewFileSuggestions && !string.IsNullOrEmpty(typeName))
            {
                var newFileResult = GenerateNewFilePath(typeName, block);
                if (newFileResult != null)
                {
                    RaisePathInferred(block, newFileResult, stopwatch.Elapsed);
                    return newFileResult;
                }
            }

            // No path could be inferred
            var notFoundResult = PathInferenceResult.NotFound(
                "Could not determine target file from content or context");

            RaiseInferenceFailed(block, notFoundResult.Explanation!);
            return notFoundResult;
        }
        catch (Exception ex)
        {
            _logger?.LogError(ex, "Error during path inference for block {BlockId}", block.Id);
            var errorResult = PathInferenceResult.NotFound($"Inference error: {ex.Message}");
            RaiseInferenceFailed(block, errorResult.Explanation!);
            return errorResult;
        }
    }

    public IReadOnlyList<PathInferenceResult> InferTargetFilePaths(
        IReadOnlyList<CodeBlock> blocks,
        IReadOnlyList<FileContext> attachedContext)
    {
        var results = new List<PathInferenceResult>(blocks.Count);
        var usedPaths = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

        foreach (var block in blocks)
        {
            var result = InferTargetFilePath(block, attachedContext);

            // Check for conflicts with already-inferred paths
            if (result.IsSuccess && !result.IsNewFile)
            {
                if (usedPaths.Contains(result.Path!))
                {
                    // Multiple blocks targeting same file - this is fine for snippets
                    _logger?.LogDebug(
                        "Multiple blocks target same file: {Path}",
                        result.Path);
                }
                usedPaths.Add(result.Path!);
            }

            results.Add(result);
        }

        return results;
    }

    public string? InferFileNameFromContent(string content, string? language)
    {
        return TypeNameExtractor.ExtractPrimaryTypeName(content, language);
    }

    public IReadOnlyList<string> ExtractAllTypeNames(string content, string? language)
    {
        return TypeNameExtractor.ExtractAllTypeNames(content, language);
    }

    public string? GetExtensionForLanguage(string? language)
    {
        return _languageService.GetFileExtension(language ?? "");
    }

    #endregion

    #region Inference Strategies

    private PathInferenceResult? TryLanguageMatch(
        CodeBlock block,
        IReadOnlyList<FileContext> contexts)
    {
        var matchingFiles = new List<(string Path, float Confidence)>();

        foreach (var ctx in contexts)
        {
            // Match by explicit language property
            if (!string.IsNullOrEmpty(ctx.Language) &&
                ctx.Language.Equals(block.Language, StringComparison.OrdinalIgnoreCase))
            {
                matchingFiles.Add((ctx.FilePath, 0.85f));
                continue;
            }

            // Match by file extension
            var ext = Path.GetExtension(ctx.FilePath);
            var langFromExt = _languageService.GetLanguageForExtension(ext);
            if (!string.IsNullOrEmpty(langFromExt) &&
                langFromExt.Equals(block.Language, StringComparison.OrdinalIgnoreCase))
            {
                matchingFiles.Add((ctx.FilePath, 0.80f));
            }
        }

        if (matchingFiles.Count == 0)
            return null;

        if (matchingFiles.Count == 1)
        {
            return PathInferenceResult.Success(
                matchingFiles[0].Path,
                matchingFiles[0].Confidence,
                InferenceStrategy.LanguageMatch,
                $"Matched by language: {block.Language}");
        }

        // Multiple matches - could be ambiguous
        if (matchingFiles.Count <= 3)
        {
            var ambiguousArgs = new AmbiguousPathEventArgs
            {
                CodeBlock = block,
                PossiblePaths = matchingFiles.Select(m => m.Path).ToList(),
                Confidences = matchingFiles.Select(m => m.Confidence).ToList()
            };

            InferenceAmbiguous?.Invoke(this, ambiguousArgs);

            // If handler selected a path, use it
            if (!string.IsNullOrEmpty(ambiguousArgs.SelectedPath))
            {
                return PathInferenceResult.Success(
                    ambiguousArgs.SelectedPath,
                    0.85f,
                    InferenceStrategy.LanguageMatch,
                    "User selected from ambiguous matches");
            }

            return PathInferenceResult.Ambiguous(
                matchingFiles.Select(m => m.Path).ToList(),
                $"Multiple {block.Language} files attached");
        }

        return null; // Too many matches to be useful
    }

    private PathInferenceResult? TryTypeNameMatch(
        string typeName,
        CodeBlock block,
        IReadOnlyList<FileContext> contexts)
    {
        foreach (var ctx in contexts)
        {
            var fileName = Path.GetFileNameWithoutExtension(ctx.FilePath);

            // Exact match
            if (fileName.Equals(typeName, StringComparison.OrdinalIgnoreCase))
            {
                return PathInferenceResult.Success(
                    ctx.FilePath,
                    0.90f,
                    InferenceStrategy.TypeNameMatch,
                    $"Exact type name match: {typeName}");
            }

            // Partial match (file contains type name or vice versa)
            if (fileName.Contains(typeName, StringComparison.OrdinalIgnoreCase) ||
                typeName.Contains(fileName, StringComparison.OrdinalIgnoreCase))
            {
                return PathInferenceResult.Success(
                    ctx.FilePath,
                    0.75f,
                    InferenceStrategy.TypeNameMatch,
                    $"Partial type name match: {typeName} ~ {fileName}");
            }
        }

        return null;
    }

    private PathInferenceResult? TryContentSimilarity(
        CodeBlock block,
        IReadOnlyList<FileContext> contexts)
    {
        // Extract namespace/imports from block
        var blockNamespace = TypeNameExtractor.ExtractNamespace(
            block.Content, block.Language);

        if (string.IsNullOrEmpty(blockNamespace))
            return null;

        foreach (var ctx in contexts)
        {
            if (string.IsNullOrEmpty(ctx.Content))
                continue;

            // Check if context file has matching namespace
            var ctxNamespace = TypeNameExtractor.ExtractNamespace(
                ctx.Content, ctx.Language ?? block.Language);

            if (!string.IsNullOrEmpty(ctxNamespace) &&
                blockNamespace.Equals(ctxNamespace, StringComparison.OrdinalIgnoreCase))
            {
                return PathInferenceResult.Success(
                    ctx.FilePath,
                    0.70f,
                    InferenceStrategy.ContentSimilarity,
                    $"Matching namespace: {blockNamespace}");
            }

            // Check if block appears to be modifying code from context
            if (ctx.Content.Contains(block.Content.Split('\n')[0].Trim()))
            {
                return PathInferenceResult.Success(
                    ctx.FilePath,
                    0.60f,
                    InferenceStrategy.ContentSimilarity,
                    "Content appears to modify attached file");
            }
        }

        return null;
    }

    private PathInferenceResult? GenerateNewFilePath(string typeName, CodeBlock block)
    {
        var extension = GetExtensionForLanguage(block.Language);
        if (string.IsNullOrEmpty(extension))
            return null;

        // Try to extract namespace for path generation
        var namespaceStr = TypeNameExtractor.ExtractNamespace(
            block.Content, block.Language);

        string path;
        if (!string.IsNullOrEmpty(namespaceStr))
        {
            // Convert namespace to path structure
            path = TypeNameExtractor.BuildSuggestedPath(
                typeName, namespaceStr, extension);
        }
        else
        {
            // Use base directory + type name
            path = string.IsNullOrEmpty(NewFileBaseDirectory)
                ? $"{typeName}{extension}"
                : $"{NewFileBaseDirectory}/{typeName}{extension}";
        }

        return PathInferenceResult.NewFile(
            NormalizePath(path),
            0.50f,
            typeName,
            $"Suggested new file for type: {typeName}");
    }

    #endregion

    #region Helper Methods

    private static string NormalizePath(string path)
    {
        return path.Trim()
            .Replace('\\', '/')
            .TrimStart('/');
    }

    private void RaisePathInferred(
        CodeBlock block,
        PathInferenceResult result,
        TimeSpan duration)
    {
        _logger?.LogDebug(
            "Inferred path for block {BlockId}: {Path} (confidence: {Confidence}, strategy: {Strategy})",
            block.Id, result.Path, result.Confidence, result.Strategy);

        PathInferred?.Invoke(this, new PathInferredEventArgs
        {
            CodeBlock = block,
            Result = result,
            Duration = duration
        });
    }

    private void RaiseInferenceFailed(CodeBlock block, string reason)
    {
        _logger?.LogDebug(
            "Path inference failed for block {BlockId}: {Reason}",
            block.Id, reason);

        var args = new PathInferenceFailedEventArgs
        {
            CodeBlock = block,
            Reason = reason
        };

        InferenceFailed?.Invoke(this, args);

        // Handler could have provided a manual path
        if (!string.IsNullOrEmpty(args.ManualPath))
        {
            _logger?.LogDebug(
                "Manual path provided for block {BlockId}: {Path}",
                block.Id, args.ManualPath);
        }
    }

    #endregion
}
```

---

### Task 6: Register Service in DI

**File to Modify:** `src/SeniorIntern.Desktop/Extensions/ServiceCollectionExtensions.cs`

**Changes Required:**

```csharp
// Add to the ConfigureServices method:

// v0.4.1e: File path inference
services.AddSingleton<IFilePathInferenceService, FilePathInferenceService>();
```

---

## Unit Testing Requirements

### Test File: `tests/SeniorIntern.Services.Tests/FilePathInferenceServiceTests.cs`

```csharp
namespace SeniorIntern.Services.Tests;

using Moq;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using Xunit;

public class FilePathInferenceServiceTests
{
    private readonly Mock<ILanguageDetectionService> _mockLanguageService;
    private readonly FilePathInferenceService _service;

    public FilePathInferenceServiceTests()
    {
        _mockLanguageService = new Mock<ILanguageDetectionService>();
        SetupDefaultLanguageMappings();
        _service = new FilePathInferenceService(_mockLanguageService.Object);
    }

    private void SetupDefaultLanguageMappings()
    {
        _mockLanguageService.Setup(s => s.GetFileExtension("csharp")).Returns(".cs");
        _mockLanguageService.Setup(s => s.GetFileExtension("typescript")).Returns(".ts");
        _mockLanguageService.Setup(s => s.GetFileExtension("python")).Returns(".py");
        _mockLanguageService.Setup(s => s.GetLanguageForExtension(".cs")).Returns("csharp");
        _mockLanguageService.Setup(s => s.GetLanguageForExtension(".ts")).Returns("typescript");
        _mockLanguageService.Setup(s => s.GetLanguageForExtension(".py")).Returns("python");
    }

    #region Strategy 1: Explicit Path

    [Fact]
    public void InferTargetFilePath_WithExplicitPath_ReturnsExplicitPath()
    {
        var block = new CodeBlock
        {
            Content = "public class Test { }",
            Language = "csharp",
            TargetFilePath = "src/Models/Test.cs"
        };

        var result = _service.InferTargetFilePath(block, Array.Empty<FileContext>());

        Assert.True(result.IsSuccess);
        Assert.Equal("src/Models/Test.cs", result.Path);
        Assert.Equal(1.0f, result.Confidence);
        Assert.Equal(InferenceStrategy.ExplicitPath, result.Strategy);
    }

    [Fact]
    public void InferTargetFilePath_NormalizesBackslashes()
    {
        var block = new CodeBlock
        {
            Content = "public class Test { }",
            Language = "csharp",
            TargetFilePath = "src\\Models\\Test.cs"
        };

        var result = _service.InferTargetFilePath(block, Array.Empty<FileContext>());

        Assert.Equal("src/Models/Test.cs", result.Path);
    }

    #endregion

    #region Strategy 2: Single Context

    [Fact]
    public void InferTargetFilePath_WithSingleContext_ReturnsContextPath()
    {
        var block = new CodeBlock
        {
            Content = "public class Test { }",
            Language = "csharp"
        };
        var context = new[] { new FileContext { FilePath = "src/Services/UserService.cs" } };

        var result = _service.InferTargetFilePath(block, context);

        Assert.True(result.IsSuccess);
        Assert.Equal("src/Services/UserService.cs", result.Path);
        Assert.Equal(0.95f, result.Confidence);
        Assert.Equal(InferenceStrategy.SingleContext, result.Strategy);
    }

    #endregion

    #region Strategy 3: Language Match

    [Fact]
    public void InferTargetFilePath_MatchesByLanguage()
    {
        var block = new CodeBlock
        {
            Content = "public class Test { }",
            Language = "csharp"
        };
        var context = new[]
        {
            new FileContext { FilePath = "app.ts", Language = "typescript" },
            new FileContext { FilePath = "src/Model.cs", Language = "csharp" }
        };

        var result = _service.InferTargetFilePath(block, context);

        Assert.True(result.IsSuccess);
        Assert.Equal("src/Model.cs", result.Path);
        Assert.Equal(InferenceStrategy.LanguageMatch, result.Strategy);
    }

    [Fact]
    public void InferTargetFilePath_MatchesByExtension_WhenNoExplicitLanguage()
    {
        var block = new CodeBlock
        {
            Content = "class Test {}",
            Language = "typescript"
        };
        var context = new[]
        {
            new FileContext { FilePath = "src/utils.ts" },
            new FileContext { FilePath = "README.md" }
        };

        var result = _service.InferTargetFilePath(block, context);

        Assert.True(result.IsSuccess);
        Assert.Equal("src/utils.ts", result.Path);
    }

    [Fact]
    public void InferTargetFilePath_ReturnsAmbiguous_WhenMultipleLanguageMatches()
    {
        var block = new CodeBlock
        {
            Content = "public class Test { }",
            Language = "csharp"
        };
        var context = new[]
        {
            new FileContext { FilePath = "src/A.cs", Language = "csharp" },
            new FileContext { FilePath = "src/B.cs", Language = "csharp" }
        };

        var result = _service.InferTargetFilePath(block, context);

        Assert.True(result.IsAmbiguous);
        Assert.Equal(2, result.AlternativePaths.Count);
    }

    #endregion

    #region Strategy 4: Type Name Match

    [Fact]
    public void InferTargetFilePath_MatchesByTypeName_ExactMatch()
    {
        var block = new CodeBlock
        {
            Content = "public class UserService { }",
            Language = "csharp"
        };
        var context = new[]
        {
            new FileContext { FilePath = "src/Services/UserService.cs" },
            new FileContext { FilePath = "src/Services/OrderService.cs" }
        };

        var result = _service.InferTargetFilePath(block, context);

        Assert.True(result.IsSuccess);
        Assert.Equal("src/Services/UserService.cs", result.Path);
        Assert.Equal(0.90f, result.Confidence);
        Assert.Equal(InferenceStrategy.TypeNameMatch, result.Strategy);
    }

    [Fact]
    public void InferTargetFilePath_MatchesByTypeName_PartialMatch()
    {
        var block = new CodeBlock
        {
            Content = "public interface IUserService { }",
            Language = "csharp"
        };
        var context = new[]
        {
            new FileContext { FilePath = "src/Services/UserService.cs" }
        };

        // IUserService contains "UserService"
        var result = _service.InferTargetFilePath(block, context);

        Assert.True(result.IsSuccess);
        Assert.Equal("src/Services/UserService.cs", result.Path);
        Assert.Equal(0.75f, result.Confidence);
    }

    #endregion

    #region Strategy 6: Generate New Path

    [Fact]
    public void InferTargetFilePath_GeneratesNewPath_WhenNoContextMatch()
    {
        var block = new CodeBlock
        {
            Content = "public class NewFeature { }",
            Language = "csharp"
        };

        var result = _service.InferTargetFilePath(block, Array.Empty<FileContext>());

        Assert.True(result.IsSuccess);
        Assert.True(result.IsNewFile);
        Assert.Equal("src/NewFeature.cs", result.Path);
        Assert.Equal(0.50f, result.Confidence);
        Assert.Equal(InferenceStrategy.GeneratedNew, result.Strategy);
    }

    [Fact]
    public void InferTargetFilePath_GeneratesPathWithNamespace()
    {
        var block = new CodeBlock
        {
            Content = @"
                namespace SeniorIntern.Core.Models;
                public class User { }",
            Language = "csharp"
        };

        var result = _service.InferTargetFilePath(block, Array.Empty<FileContext>());

        Assert.True(result.IsSuccess);
        Assert.True(result.IsNewFile);
        Assert.Equal("SeniorIntern/Core/Models/User.cs", result.Path);
    }

    [Fact]
    public void InferTargetFilePath_DisablesNewFileSuggestions_WhenConfigured()
    {
        _service.AllowNewFileSuggestions = false;

        var block = new CodeBlock
        {
            Content = "public class NewFeature { }",
            Language = "csharp"
        };

        var result = _service.InferTargetFilePath(block, Array.Empty<FileContext>());

        Assert.False(result.IsSuccess);
        Assert.False(result.IsNewFile);
    }

    #endregion

    #region InferFileNameFromContent

    [Theory]
    [InlineData("public class UserService { }", "csharp", "UserService")]
    [InlineData("internal sealed class DataProcessor { }", "csharp", "DataProcessor")]
    [InlineData("public interface IRepository { }", "csharp", "IRepository")]
    [InlineData("public record Person(string Name);", "csharp", "Person")]
    [InlineData("export class ApiClient { }", "typescript", "ApiClient")]
    [InlineData("export interface IConfig { }", "typescript", "IConfig")]
    [InlineData("class DataLoader:\n    pass", "python", "DataLoader")]
    [InlineData("type UserStore struct { }", "go", "UserStore")]
    [InlineData("pub struct Config { }", "rust", "Config")]
    public void InferFileNameFromContent_ExtractsTypeName(
        string content, string language, string expected)
    {
        var result = _service.InferFileNameFromContent(content, language);
        Assert.Equal(expected, result);
    }

    [Fact]
    public void InferFileNameFromContent_ReturnsNull_ForUnknownLanguage()
    {
        var result = _service.InferFileNameFromContent("some code", "unknown");
        Assert.Null(result);
    }

    [Fact]
    public void InferFileNameFromContent_ReturnsNull_ForEmptyContent()
    {
        var result = _service.InferFileNameFromContent("", "csharp");
        Assert.Null(result);
    }

    #endregion

    #region ExtractAllTypeNames

    [Fact]
    public void ExtractAllTypeNames_ReturnsMultipleTypes()
    {
        var content = @"
            public class User { }
            public class Order { }
            public interface IRepository { }
        ";

        var results = _service.ExtractAllTypeNames(content, "csharp");

        Assert.Equal(3, results.Count);
        Assert.Contains("User", results);
        Assert.Contains("Order", results);
        Assert.Contains("IRepository", results);
    }

    #endregion

    #region Events

    [Fact]
    public void InferTargetFilePath_RaisesPathInferredEvent()
    {
        PathInferredEventArgs? eventArgs = null;
        _service.PathInferred += (s, e) => eventArgs = e;

        var block = new CodeBlock
        {
            Content = "public class Test { }",
            Language = "csharp",
            TargetFilePath = "test.cs"
        };

        _service.InferTargetFilePath(block, Array.Empty<FileContext>());

        Assert.NotNull(eventArgs);
        Assert.Equal(block, eventArgs.CodeBlock);
        Assert.NotNull(eventArgs.Result);
        Assert.True(eventArgs.Duration > TimeSpan.Zero);
    }

    [Fact]
    public void InferTargetFilePath_RaisesAmbiguousEvent_WhenMultipleMatches()
    {
        AmbiguousPathEventArgs? eventArgs = null;
        _service.InferenceAmbiguous += (s, e) => eventArgs = e;

        var block = new CodeBlock
        {
            Content = "public class Test { }",
            Language = "csharp"
        };
        var context = new[]
        {
            new FileContext { FilePath = "A.cs", Language = "csharp" },
            new FileContext { FilePath = "B.cs", Language = "csharp" }
        };

        _service.InferTargetFilePath(block, context);

        Assert.NotNull(eventArgs);
        Assert.Equal(2, eventArgs.PossiblePaths.Count);
    }

    [Fact]
    public void InferTargetFilePath_RaisesFailedEvent_WhenNoMatch()
    {
        _service.AllowNewFileSuggestions = false;

        PathInferenceFailedEventArgs? eventArgs = null;
        _service.InferenceFailed += (s, e) => eventArgs = e;

        var block = new CodeBlock
        {
            Content = "some random code",
            Language = null
        };

        _service.InferTargetFilePath(block, Array.Empty<FileContext>());

        Assert.NotNull(eventArgs);
        Assert.NotNull(eventArgs.Reason);
    }

    [Fact]
    public void InferTargetFilePath_UsesManualPath_FromFailedEventHandler()
    {
        _service.AllowNewFileSuggestions = false;

        _service.InferenceFailed += (s, e) =>
        {
            e.ManualPath = "manually/specified/path.txt";
        };

        var block = new CodeBlock
        {
            Content = "some code",
            Language = null
        };

        // The event handler sets a manual path, but the result still reflects failure
        // The manual path is available for the caller to handle
        var result = _service.InferTargetFilePath(block, Array.Empty<FileContext>());

        Assert.False(result.IsSuccess);
    }

    #endregion

    #region Batch Processing

    [Fact]
    public void InferTargetFilePaths_ProcessesMultipleBlocks()
    {
        var blocks = new[]
        {
            new CodeBlock { Content = "class A { }", Language = "csharp" },
            new CodeBlock { Content = "class B { }", Language = "csharp" }
        };

        var results = _service.InferTargetFilePaths(blocks, Array.Empty<FileContext>());

        Assert.Equal(2, results.Count);
        Assert.All(results, r => Assert.True(r.IsSuccess));
    }

    #endregion
}
```

### Test File: `tests/SeniorIntern.Services.Tests/Helpers/TypeNameExtractorTests.cs`

```csharp
namespace SeniorIntern.Services.Tests.Helpers;

using SeniorIntern.Services.Helpers;
using Xunit;

public class TypeNameExtractorTests
{
    #region C# Type Extraction

    [Theory]
    [InlineData("public class User { }", "User")]
    [InlineData("internal sealed class DataService { }", "DataService")]
    [InlineData("public abstract class BaseEntity { }", "BaseEntity")]
    [InlineData("public partial class PartialClass { }", "PartialClass")]
    [InlineData("public static class Extensions { }", "Extensions")]
    [InlineData("public record UserDto(string Name);", "UserDto")]
    [InlineData("public struct Point { }", "Point")]
    [InlineData("public readonly struct ImmutablePoint { }", "ImmutablePoint")]
    public void ExtractPrimaryTypeName_CSharp_Classes(string content, string expected)
    {
        var result = TypeNameExtractor.ExtractPrimaryTypeName(content, "csharp");
        Assert.Equal(expected, result);
    }

    [Theory]
    [InlineData("public interface IUserService { }", "IUserService")]
    [InlineData("internal interface IRepository<T> { }", "IRepository")]
    public void ExtractPrimaryTypeName_CSharp_Interfaces(string content, string expected)
    {
        var result = TypeNameExtractor.ExtractPrimaryTypeName(content, "csharp");
        Assert.Equal(expected, result);
    }

    [Theory]
    [InlineData("public enum Status { Active, Inactive }", "Status")]
    [InlineData("internal enum ErrorCode { None = 0 }", "ErrorCode")]
    public void ExtractPrimaryTypeName_CSharp_Enums(string content, string expected)
    {
        var result = TypeNameExtractor.ExtractPrimaryTypeName(content, "csharp");
        Assert.Equal(expected, result);
    }

    #endregion

    #region TypeScript/JavaScript Type Extraction

    [Theory]
    [InlineData("export class UserService { }", "UserService")]
    [InlineData("export default class ApiClient { }", "ApiClient")]
    [InlineData("class InternalHelper { }", "InternalHelper")]
    [InlineData("export abstract class BaseComponent { }", "BaseComponent")]
    public void ExtractPrimaryTypeName_TypeScript_Classes(string content, string expected)
    {
        var result = TypeNameExtractor.ExtractPrimaryTypeName(content, "typescript");
        Assert.Equal(expected, result);
    }

    [Theory]
    [InlineData("export interface IConfig { }", "IConfig")]
    [InlineData("interface LocalState { }", "LocalState")]
    public void ExtractPrimaryTypeName_TypeScript_Interfaces(string content, string expected)
    {
        var result = TypeNameExtractor.ExtractPrimaryTypeName(content, "typescript");
        Assert.Equal(expected, result);
    }

    [Theory]
    [InlineData("export function processData() { }", "processData")]
    [InlineData("export async function fetchUser() { }", "fetchUser")]
    [InlineData("function helperFn() { }", "helperFn")]
    public void ExtractPrimaryTypeName_TypeScript_Functions(string content, string expected)
    {
        var result = TypeNameExtractor.ExtractPrimaryTypeName(content, "typescript");
        Assert.Equal(expected, result);
    }

    #endregion

    #region Python Type Extraction

    [Theory]
    [InlineData("class DataLoader:\n    pass", "DataLoader")]
    [InlineData("class UserService(BaseService):\n    pass", "UserService")]
    public void ExtractPrimaryTypeName_Python_Classes(string content, string expected)
    {
        var result = TypeNameExtractor.ExtractPrimaryTypeName(content, "python");
        Assert.Equal(expected, result);
    }

    [Theory]
    [InlineData("def process_data():\n    pass", "process_data")]
    [InlineData("async def fetch_user():\n    pass", "fetch_user")]
    public void ExtractPrimaryTypeName_Python_Functions(string content, string expected)
    {
        var result = TypeNameExtractor.ExtractPrimaryTypeName(content, "python");
        Assert.Equal(expected, result);
    }

    #endregion

    #region Go Type Extraction

    [Theory]
    [InlineData("type UserStore struct {\n}", "UserStore")]
    [InlineData("type Config struct {\n    Port int\n}", "Config")]
    public void ExtractPrimaryTypeName_Go_Structs(string content, string expected)
    {
        var result = TypeNameExtractor.ExtractPrimaryTypeName(content, "go");
        Assert.Equal(expected, result);
    }

    [Theory]
    [InlineData("type Repository interface {\n}", "Repository")]
    public void ExtractPrimaryTypeName_Go_Interfaces(string content, string expected)
    {
        var result = TypeNameExtractor.ExtractPrimaryTypeName(content, "go");
        Assert.Equal(expected, result);
    }

    #endregion

    #region Rust Type Extraction

    [Theory]
    [InlineData("pub struct Config {\n}", "Config")]
    [InlineData("struct InternalData {}", "InternalData")]
    public void ExtractPrimaryTypeName_Rust_Structs(string content, string expected)
    {
        var result = TypeNameExtractor.ExtractPrimaryTypeName(content, "rust");
        Assert.Equal(expected, result);
    }

    [Theory]
    [InlineData("pub enum Status { Active, Inactive }", "Status")]
    [InlineData("enum ErrorKind { IoError, ParseError }", "ErrorKind")]
    public void ExtractPrimaryTypeName_Rust_Enums(string content, string expected)
    {
        var result = TypeNameExtractor.ExtractPrimaryTypeName(content, "rust");
        Assert.Equal(expected, result);
    }

    [Theory]
    [InlineData("pub trait Repository {\n}", "Repository")]
    [InlineData("trait InternalBehavior {}", "InternalBehavior")]
    public void ExtractPrimaryTypeName_Rust_Traits(string content, string expected)
    {
        var result = TypeNameExtractor.ExtractPrimaryTypeName(content, "rust");
        Assert.Equal(expected, result);
    }

    #endregion

    #region Namespace Extraction

    [Theory]
    [InlineData("namespace SeniorIntern.Core.Models;", "csharp", "SeniorIntern.Core.Models")]
    [InlineData("namespace MyApp { class X {} }", "csharp", "MyApp")]
    [InlineData("package com.example.models;", "java", "com.example.models")]
    [InlineData("package main", "go", "main")]
    public void ExtractNamespace_ExtractsCorrectly(
        string content, string language, string expected)
    {
        var result = TypeNameExtractor.ExtractNamespace(content, language);
        Assert.Equal(expected, result);
    }

    [Fact]
    public void ExtractNamespace_ReturnsNull_WhenNoNamespace()
    {
        var result = TypeNameExtractor.ExtractNamespace("public class Foo {}", "csharp");
        Assert.Null(result);
    }

    #endregion

    #region ExtractAllTypeNames

    [Fact]
    public void ExtractAllTypeNames_FindsAllTypes()
    {
        var content = @"
            namespace Test;
            public class User { }
            public class Order { }
            public interface IRepository { }
            public enum Status { }
        ";

        var results = TypeNameExtractor.ExtractAllTypeNames(content, "csharp");

        Assert.Equal(4, results.Count);
        Assert.Contains("User", results);
        Assert.Contains("Order", results);
        Assert.Contains("IRepository", results);
        Assert.Contains("Status", results);
    }

    [Fact]
    public void ExtractAllTypeNames_ReturnsEmpty_ForNullLanguage()
    {
        var results = TypeNameExtractor.ExtractAllTypeNames("class Foo {}", null);
        Assert.Empty(results);
    }

    #endregion

    #region BuildSuggestedPath

    [Fact]
    public void BuildSuggestedPath_WithNamespace_CreatesFullPath()
    {
        var path = TypeNameExtractor.BuildSuggestedPath(
            "UserService",
            "SeniorIntern.Core.Services",
            ".cs");

        Assert.Equal("SeniorIntern/Core/Services/UserService.cs", path);
    }

    [Fact]
    public void BuildSuggestedPath_WithoutNamespace_CreatesSimplePath()
    {
        var path = TypeNameExtractor.BuildSuggestedPath(
            "Helper",
            null,
            ".cs");

        Assert.Equal("Helper.cs", path);
    }

    #endregion

    #region Edge Cases

    [Theory]
    [InlineData(null)]
    [InlineData("")]
    [InlineData("   ")]
    public void ExtractPrimaryTypeName_ReturnsNull_ForEmptyContent(string? content)
    {
        var result = TypeNameExtractor.ExtractPrimaryTypeName(content!, "csharp");
        Assert.Null(result);
    }

    [Fact]
    public void ExtractPrimaryTypeName_ReturnsNull_ForUnknownLanguage()
    {
        var result = TypeNameExtractor.ExtractPrimaryTypeName(
            "class Foo {}", "cobol");
        Assert.Null(result);
    }

    [Fact]
    public void ExtractPrimaryTypeName_HandlesGenericTypes()
    {
        var result = TypeNameExtractor.ExtractPrimaryTypeName(
            "public class Repository<T> where T : class { }",
            "csharp");

        // Should extract "Repository" not "Repository<T>"
        Assert.Equal("Repository", result);
    }

    #endregion
}
```

---

## Test Count Summary

| Component | Test Count | Focus Areas |
|-----------|------------|-------------|
| Explicit Path Strategy | 2 | Direct path, normalization |
| Single Context Strategy | 1 | Automatic assignment |
| Language Match Strategy | 3 | Exact match, extension match, ambiguous |
| Type Name Match Strategy | 2 | Exact match, partial match |
| Generated New Path Strategy | 3 | Basic, with namespace, disabled |
| InferFileNameFromContent | 3 | Multiple languages, null cases |
| ExtractAllTypeNames | 1 | Multiple types |
| Events | 4 | PathInferred, Ambiguous, Failed, ManualPath |
| Batch Processing | 1 | Multiple blocks |
| TypeNameExtractor - C# | 6 | Classes, interfaces, enums |
| TypeNameExtractor - TS/JS | 6 | Classes, interfaces, functions |
| TypeNameExtractor - Python | 4 | Classes, functions |
| TypeNameExtractor - Go | 3 | Structs, interfaces |
| TypeNameExtractor - Rust | 6 | Structs, enums, traits |
| Namespace Extraction | 5 | Various languages, null |
| BuildSuggestedPath | 2 | With/without namespace |
| Edge Cases | 4 | Empty, null, unknown, generics |
| **Total** | **56** | |

---

## Files Summary

### Files to Create (5)

| File | Purpose | Lines (approx) |
|------|---------|----------------|
| `src/SeniorIntern.Core/Models/PathInferenceResult.cs` | Result model with confidence | 110 |
| `src/SeniorIntern.Core/Events/PathInferenceEvents.cs` | Event args for inference | 70 |
| `src/SeniorIntern.Core/Interfaces/IFilePathInferenceService.cs` | Service interface | 95 |
| `src/SeniorIntern.Services/Helpers/TypeNameExtractor.cs` | Type extraction helper | 220 |
| `src/SeniorIntern.Services/FilePathInferenceService.cs` | Main implementation | 320 |

### Files to Modify (1)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/Extensions/ServiceCollectionExtensions.cs` | Register IFilePathInferenceService |

---

## Acceptance Criteria

| ID | Criterion | Verification |
|----|-----------|--------------|
| AC-1 | Explicit paths (fence/comment) return confidence 1.0 | Unit test |
| AC-2 | Single attached context returns that file path | Unit test |
| AC-3 | Language matching finds files by extension | Unit test |
| AC-4 | Type name extraction works for C#, TS, Python, Java, Go, Rust | Unit tests |
| AC-5 | Exact type name match returns confidence ≥ 0.90 | Unit test |
| AC-6 | Partial type name match returns confidence ≥ 0.75 | Unit test |
| AC-7 | Ambiguous matches raise InferenceAmbiguous event | Unit test |
| AC-8 | New file suggestions include namespace in path | Unit test |
| AC-9 | Path normalization converts backslashes to forward slashes | Unit test |
| AC-10 | MinimumConfidenceThreshold is configurable | Code inspection |
| AC-11 | AllowNewFileSuggestions can be disabled | Unit test |
| AC-12 | PathInferred event includes timing information | Unit test |
| AC-13 | Failed inference raises InferenceFailed event | Unit test |
| AC-14 | Batch processing handles multiple blocks | Unit test |
| AC-15 | Empty/null content returns null gracefully | Unit test |
| AC-16 | Unknown languages return null gracefully | Unit test |

---

## Design Decisions

| Decision | Rationale |
|----------|-----------|
| Cascade strategy approach | Allows fallback when primary strategies fail; most specific wins |
| Confidence scores 0-1 | Standard probability range, easy to compare and threshold |
| Generated regex patterns | Performance optimization, compile-time validation |
| Separate TypeNameExtractor | Single responsibility, testable in isolation |
| Events for ambiguous cases | Allows UI to prompt user for selection |
| AllowNewFileSuggestions config | Some workflows may not want file creation suggestions |
| Namespace-to-path conversion | Follows standard project structure conventions |
| Priority: public types first | Matches common file naming conventions (file = primary type) |

---

## Edge Cases and Error Handling

### Edge Case 1: Generic Types

```csharp
// Input: "public class Repository<T> where T : class { }"
// Expected: "Repository" (not "Repository<T>")
```

The regex patterns capture only the identifier, not generic parameters.

### Edge Case 2: Multiple Types in One Block

```csharp
// Input:
// public class User { }
// public class Order { }

// Strategy: Use first public type for file name
// ExtractAllTypeNames available for advanced scenarios
```

### Edge Case 3: Nested Types

```csharp
// Input:
// public class Outer {
//     public class Inner { }
// }

// Strategy: Use outermost type (Outer)
```

### Edge Case 4: No Type Declaration (Snippet)

```csharp
// Input: "Console.WriteLine(\"Hello\");"
// Strategy: Falls through to language match or fails
```

### Error Handling

| Scenario | Handling |
|----------|----------|
| Null content | Return null, no exception |
| Unknown language | Return null, no exception |
| Regex timeout | Not expected (simple patterns), but would return null |
| File path normalization | Replace backslashes, trim slashes |
| Empty attached context | Skip context-based strategies |

---

## Integration Points

### Upstream Dependencies

| Component | Dependency |
|-----------|------------|
| v0.4.1a | CodeBlock model |
| v0.4.1c | ILanguageDetectionService |
| v0.3.4 | FileContext model |

### Downstream Consumers

| Component | Usage |
|-----------|-------|
| v0.4.1b | CodeBlockParserService uses for CreateProposal |
| v0.4.1g | ChatMessageViewModel displays inferred paths |
| v0.4.2 | DiffService uses paths to load original files |
| v0.4.3 | ApplyChangesWorkflow uses paths to write files |

---

## Performance Considerations

| Aspect | Approach |
|--------|----------|
| Regex compilation | Use `[GeneratedRegex]` for compile-time optimization |
| Multiple blocks | Batch API allows single-pass context analysis |
| Large files | Content similarity only uses first line for quick check |
| Many attached files | Language match filters before type match |

---

## Dependencies

| Part | Dependency Description |
|------|------------------------|
| v0.4.1a | CodeBlock, CodeProposal models |
| v0.4.1c | ILanguageDetectionService for extension mapping |
| v0.3.4 | FileContext model for attached file information |

---

## Next Steps

With v0.4.1e complete, the path inference capability is ready. Proceed to:

| Part | Status | Description |
|------|--------|-------------|
| v0.4.1a | Complete | Core models |
| v0.4.1b | Complete | Parser service |
| v0.4.1c | Complete | Language detection |
| v0.4.1d | Complete | Block classification |
| v0.4.1e | **Complete** | File path inference |
| v0.4.1f | Next | Streaming parser |
| v0.4.1g | Pending | ViewModel integration |
| v0.4.1h | Pending | UI rendering |

**Proceed to v0.4.1f: Streaming Parser**
- Implement incremental parsing during LLM token streaming
- Enable early UI updates as code blocks are detected
- Support partial block preview during generation
