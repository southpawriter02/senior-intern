# v0.4.3f: Apply Dialog - Design Specification

**Status**: _IMPLEMENTED_

## Executive Summary

This specification details the implementation of the **Apply Dialog** for The Senior Intern's Apply Changes Workflow. The Apply Dialog provides a confirmation interface that displays a diff preview before applying code changes, allowing users to review modifications, toggle backup options, and confirm or cancel the operation with clear visual feedback.

### Key Deliverables
- `ApplyChangesDialogViewModel` with MVVM pattern using CommunityToolkit.Mvvm
- `ApplyChangesDialog.axaml` Avalonia window with diff preview and controls
- `ApplyChangesDialog.axaml.cs` code-behind with static `ShowAsync` factory method
- Integration with `DiffViewerPanel` for embedded diff visualization
- Loading states, error handling, and keyboard shortcuts

---

## Feature Overview

```
v0.4.3f: Apply Dialog
├── ViewModel (ApplyChangesDialogViewModel)
│   ├── Observable Properties
│   │   ├── DiffViewModel (embedded diff viewer)
│   │   ├── CodeBlock (the proposed change)
│   │   ├── FileName / FilePath (display info)
│   │   ├── IsNewFile (new file indicator)
│   │   ├── CreateBackup (user option)
│   │   ├── IsApplying (loading state)
│   │   ├── ErrorMessage (error display)
│   │   └── Result (apply operation result)
│   └── Commands
│       ├── ApplyCommand (execute apply)
│       └── CancelCommand (close without changes)
├── View (ApplyChangesDialog.axaml)
│   ├── Diff Preview Area (DiffViewerPanel)
│   └── Footer Controls
│       ├── Options (backup checkbox, new file badge)
│       ├── Error Message Display
│       └── Action Buttons (Cancel, Apply)
├── Code-Behind (ApplyChangesDialog.axaml.cs)
│   └── Static ShowAsync Factory Method
├── Keyboard Shortcuts
│   ├── Enter → Apply Changes
│   └── Escape → Cancel
└── Visual States
    ├── Default (ready to apply)
    ├── Applying (loading spinner)
    ├── Error (error message displayed)
    └── New File (creation badge visible)
```

---

## Architecture Diagrams

### Component Interaction

```
┌─────────────────────────────────────────────────────────────────┐
│                       Apply Dialog Flow                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌──────────────────┐                                           │
│  │  Calling Code    │                                           │
│  │ (MainViewModel)  │                                           │
│  └────────┬─────────┘                                           │
│           │ await ApplyChangesDialog.ShowAsync(...)             │
│           ▼                                                      │
│  ┌──────────────────────────────────────────────────────┐       │
│  │              ApplyChangesDialog                       │       │
│  │  ┌─────────────────────────────────────────────────┐ │       │
│  │  │         ApplyChangesDialogViewModel              │ │       │
│  │  │                                                  │ │       │
│  │  │  ┌──────────────┐    ┌───────────────────────┐  │ │       │
│  │  │  │ DiffViewModel │◀──│  DiffViewerPanel      │  │ │       │
│  │  │  └──────────────┘    │  (embedded view)       │  │ │       │
│  │  │         │            └───────────────────────┘  │ │       │
│  │  │         │                                       │ │       │
│  │  │  ┌──────▼──────┐                               │ │       │
│  │  │  │ ApplyCommand │──▶ IFileChangeService        │ │       │
│  │  │  └─────────────┘                               │ │       │
│  │  └─────────────────────────────────────────────────┘ │       │
│  └──────────────────────────────────────────────────────┘       │
│           │                                                      │
│           │ Returns ApplyResult? (null if cancelled)            │
│           ▼                                                      │
│  ┌──────────────────┐                                           │
│  │  Calling Code    │                                           │
│  │ handles result   │                                           │
│  └──────────────────┘                                           │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Dialog Layout Structure

```
┌─────────────────────────────────────────────────────────────────┐
│  Apply Changes                                           [─][□][×]│
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │                                                            │  │
│  │                    DiffViewerPanel                         │  │
│  │                                                            │  │
│  │   1  - old line removed                                   │  │
│  │   2  + new line added                                     │  │
│  │   3    unchanged context                                  │  │
│  │   4  ~ modified line                                      │  │
│  │                                                            │  │
│  │                         ...                                │  │
│  │                                                            │  │
│  └───────────────────────────────────────────────────────────┘  │
│                                                                  │
├─────────────────────────────────────────────────────────────────┤
│  ☑ Create backup    [New file will be created]    [Error msg]   │
│                                                                  │
│                                      [ Cancel ]  [ Apply Changes ]│
└─────────────────────────────────────────────────────────────────┘
```

### State Machine

```
┌─────────────────────────────────────────────────────────────────┐
│                    Dialog State Machine                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│                    ┌───────────────┐                            │
│                    │    READY      │                            │
│                    │  IsApplying   │                            │
│                    │   = false     │                            │
│                    └───────┬───────┘                            │
│                            │                                     │
│            ┌───────────────┼───────────────┐                    │
│            │               │               │                    │
│            ▼               ▼               ▼                    │
│   ┌────────────────┐ ┌──────────┐ ┌────────────────┐           │
│   │ User clicks    │ │ User     │ │ User presses   │           │
│   │ Apply button   │ │ cancels  │ │ Escape         │           │
│   └────────┬───────┘ └────┬─────┘ └────────┬───────┘           │
│            │              │                │                    │
│            ▼              │                │                    │
│   ┌────────────────┐      │                │                    │
│   │   APPLYING     │      │                │                    │
│   │  IsApplying    │      │                │                    │
│   │   = true       │      │                │                    │
│   │  [spinner]     │      │                │                    │
│   └────────┬───────┘      │                │                    │
│            │              │                │                    │
│     ┌──────┴──────┐       │                │                    │
│     │             │       │                │                    │
│     ▼             ▼       ▼                ▼                    │
│ ┌────────┐   ┌────────┐  ┌────────────────────┐                │
│ │SUCCESS │   │ ERROR  │  │     CANCELLED      │                │
│ │        │   │        │  │                    │                │
│ │ Close  │   │ Show   │  │ Close(null)        │                │
│ │(Result)│   │message │  └────────────────────┘                │
│ └────────┘   │ Stay   │                                        │
│              │ open   │                                        │
│              └────────┘                                        │
│                  │                                              │
│                  ▼                                              │
│           ┌───────────────┐                                    │
│           │ User can retry│                                    │
│           │ or cancel     │                                    │
│           └───────────────┘                                    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## Detailed Design

### 1. ApplyChangesDialogViewModel

```csharp
// src/SeniorIntern.Desktop/ViewModels/ApplyChangesDialogViewModel.cs
using System.IO;
using Avalonia.Controls;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using SeniorIntern.Core.Models;
using SeniorIntern.Services.Interfaces;
using SeniorIntern.Services.Models;

namespace SeniorIntern.Desktop.ViewModels;

/// <summary>
/// ViewModel for the Apply Changes confirmation dialog.
/// Manages diff preview display and apply operation execution.
/// </summary>
public partial class ApplyChangesDialogViewModel : ViewModelBase
{
    private readonly IFileChangeService _changeService;
    private readonly IWorkspaceService _workspaceService;
    private readonly Window _dialog;

    #region Observable Properties

    /// <summary>
    /// Gets the embedded diff viewer ViewModel.
    /// </summary>
    [ObservableProperty]
    private DiffViewerViewModel _diffViewModel;

    /// <summary>
    /// Gets the code block being applied.
    /// </summary>
    [ObservableProperty]
    private CodeBlock _codeBlock;

    /// <summary>
    /// Gets the file name (without path) for display.
    /// </summary>
    [ObservableProperty]
    private string _fileName = string.Empty;

    /// <summary>
    /// Gets the full file path for display.
    /// </summary>
    [ObservableProperty]
    private string _filePath = string.Empty;

    /// <summary>
    /// Gets whether this operation will create a new file.
    /// </summary>
    [ObservableProperty]
    private bool _isNewFile;

    /// <summary>
    /// Gets or sets whether to create a backup before applying.
    /// Default: true
    /// </summary>
    [ObservableProperty]
    private bool _createBackup = true;

    /// <summary>
    /// Gets whether an apply operation is currently in progress.
    /// </summary>
    [ObservableProperty]
    private bool _isApplying;

    /// <summary>
    /// Gets the current error message, if any.
    /// </summary>
    [ObservableProperty]
    private string? _errorMessage;

    /// <summary>
    /// Gets the result of the apply operation.
    /// </summary>
    [ObservableProperty]
    private ApplyResult? _result;

    #endregion

    #region Computed Properties

    /// <summary>
    /// Gets whether the Apply button should be enabled.
    /// </summary>
    public bool CanApply => !IsApplying;

    /// <summary>
    /// Gets whether the Cancel button should be enabled.
    /// </summary>
    public bool CanCancel => !IsApplying;

    /// <summary>
    /// Gets the text to display on the Apply button.
    /// </summary>
    public string ApplyButtonText => IsApplying ? "Applying..." : "Apply Changes";

    /// <summary>
    /// Gets whether the error message should be visible.
    /// </summary>
    public bool ShowError => !string.IsNullOrEmpty(ErrorMessage);

    /// <summary>
    /// Gets a summary of the changes for accessibility.
    /// </summary>
    public string ChangesSummary => DiffViewModel?.ChangesSummary ?? "No changes";

    #endregion

    /// <summary>
    /// Initializes a new instance of the ApplyChangesDialogViewModel.
    /// </summary>
    /// <param name="changeService">Service for applying file changes.</param>
    /// <param name="workspaceService">Service for workspace path resolution.</param>
    /// <param name="diffService">Service for diff computation.</param>
    /// <param name="inlineDiffService">Service for inline diff rendering.</param>
    /// <param name="codeBlock">The code block to apply.</param>
    /// <param name="diff">The pre-computed diff result.</param>
    /// <param name="dialog">The dialog window instance.</param>
    public ApplyChangesDialogViewModel(
        IFileChangeService changeService,
        IWorkspaceService workspaceService,
        IDiffService diffService,
        IInlineDiffService inlineDiffService,
        CodeBlock codeBlock,
        DiffResult diff,
        Window dialog)
    {
        _changeService = changeService ?? throw new ArgumentNullException(nameof(changeService));
        _workspaceService = workspaceService ?? throw new ArgumentNullException(nameof(workspaceService));
        _dialog = dialog ?? throw new ArgumentNullException(nameof(dialog));
        _codeBlock = codeBlock ?? throw new ArgumentNullException(nameof(codeBlock));

        // Extract file information
        FileName = Path.GetFileName(codeBlock.TargetFilePath ?? "Unknown");
        FilePath = codeBlock.TargetFilePath ?? string.Empty;
        IsNewFile = diff.IsNewFile;

        // Initialize diff viewer
        DiffViewModel = new DiffViewerViewModel(diffService, inlineDiffService);
        DiffViewModel.LoadDiff(diff);

        // Wire up property change notifications for computed properties
        PropertyChanged += (_, e) =>
        {
            if (e.PropertyName == nameof(IsApplying))
            {
                OnPropertyChanged(nameof(CanApply));
                OnPropertyChanged(nameof(CanCancel));
                OnPropertyChanged(nameof(ApplyButtonText));
            }
            else if (e.PropertyName == nameof(ErrorMessage))
            {
                OnPropertyChanged(nameof(ShowError));
            }
        };
    }

    #region Commands

    /// <summary>
    /// Executes the apply operation.
    /// </summary>
    [RelayCommand(CanExecute = nameof(CanApply))]
    private async Task ApplyAsync(CancellationToken ct)
    {
        if (IsApplying) return;

        try
        {
            IsApplying = true;
            ErrorMessage = null;

            var options = new ApplyOptions
            {
                CreateBackup = CreateBackup,
                ShowConfirmationDialog = false, // Already in dialog
                CheckForConflicts = true
            };

            Result = await _changeService.ApplyCodeBlockAsync(
                CodeBlock,
                _workspaceService.CurrentWorkspacePath,
                options,
                ct);

            if (Result.Success)
            {
                _dialog.Close(Result);
            }
            else if (Result.IsConflict)
            {
                ErrorMessage = $"Conflict detected: {Result.ErrorMessage}";
            }
            else
            {
                ErrorMessage = Result.ErrorMessage ?? "Failed to apply changes";
            }
        }
        catch (OperationCanceledException)
        {
            ErrorMessage = "Operation was cancelled";
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Unexpected error: {ex.Message}";
        }
        finally
        {
            IsApplying = false;
        }
    }

    /// <summary>
    /// Cancels the dialog without applying changes.
    /// </summary>
    [RelayCommand(CanExecute = nameof(CanCancel))]
    private void Cancel()
    {
        _dialog.Close(null);
    }

    #endregion
}
```

### 2. ApplyChangesDialog.axaml (View)

```xml
<!-- src/SeniorIntern.Desktop/Views/ApplyChangesDialog.axaml -->
<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:vm="using:SeniorIntern.Desktop.ViewModels"
        xmlns:views="using:SeniorIntern.Desktop.Views"
        xmlns:converters="using:SeniorIntern.Desktop.Converters"
        mc:Ignorable="d"
        x:Class="SeniorIntern.Desktop.Views.ApplyChangesDialog"
        x:DataType="vm:ApplyChangesDialogViewModel"
        Title="Apply Changes"
        Width="900"
        Height="650"
        MinWidth="600"
        MinHeight="400"
        WindowStartupLocation="CenterOwner"
        CanResize="True"
        SystemDecorations="Full"
        ExtendClientAreaToDecorationsHint="False"
        ShowInTaskbar="False">

    <Window.Resources>
        <converters:BoolToStringConverter x:Key="BoolToStringConverter" />
    </Window.Resources>

    <Window.KeyBindings>
        <KeyBinding Gesture="Escape" Command="{Binding CancelCommand}" />
        <KeyBinding Gesture="Enter" Command="{Binding ApplyCommand}" />
    </Window.KeyBindings>

    <Grid RowDefinitions="Auto, *, Auto">

        <!-- Header -->
        <Border Grid.Row="0"
                Background="{DynamicResource SurfaceBackground}"
                BorderBrush="{DynamicResource BorderBrush}"
                BorderThickness="0,0,0,1"
                Padding="16,12">
            <Grid ColumnDefinitions="Auto, *, Auto">
                <!-- File Icon -->
                <PathIcon Grid.Column="0"
                          Data="{StaticResource DocumentIcon}"
                          Width="20"
                          Height="20"
                          Foreground="{DynamicResource TextMuted}"
                          Margin="0,0,12,0" />

                <!-- File Info -->
                <StackPanel Grid.Column="1" VerticalAlignment="Center">
                    <TextBlock Text="{Binding FileName}"
                               FontWeight="SemiBold"
                               FontSize="14" />
                    <TextBlock Text="{Binding FilePath}"
                               FontSize="11"
                               Foreground="{DynamicResource TextMuted}"
                               TextTrimming="CharacterEllipsis"
                               ToolTip.Tip="{Binding FilePath}" />
                </StackPanel>

                <!-- Changes Summary -->
                <TextBlock Grid.Column="2"
                           Text="{Binding ChangesSummary}"
                           FontSize="12"
                           Foreground="{DynamicResource TextMuted}"
                           VerticalAlignment="Center" />
            </Grid>
        </Border>

        <!-- Diff Preview -->
        <views:DiffViewerPanel Grid.Row="1"
                               DataContext="{Binding DiffViewModel}"
                               Margin="0" />

        <!-- Footer -->
        <Border Grid.Row="2"
                Background="{DynamicResource SurfaceBackground}"
                BorderBrush="{DynamicResource BorderBrush}"
                BorderThickness="0,1,0,0"
                Padding="16,12">
            <Grid ColumnDefinitions="Auto, *, Auto">

                <!-- Left: Options -->
                <StackPanel Grid.Column="0"
                            Orientation="Horizontal"
                            Spacing="16"
                            VerticalAlignment="Center">

                    <!-- Backup Checkbox -->
                    <CheckBox Content="Create backup"
                              IsChecked="{Binding CreateBackup}"
                              IsEnabled="{Binding !IsApplying}"
                              ToolTip.Tip="Save a backup copy before modifying the file. Allows undo." />

                    <!-- New File Badge -->
                    <Border Classes="info-badge"
                            IsVisible="{Binding IsNewFile}"
                            Padding="8,4"
                            CornerRadius="4"
                            Background="{DynamicResource DiffAddedBackgroundBrush}">
                        <StackPanel Orientation="Horizontal" Spacing="6">
                            <PathIcon Data="{StaticResource PlusIcon}"
                                      Width="12"
                                      Height="12"
                                      Foreground="{DynamicResource DiffAddedForegroundBrush}" />
                            <TextBlock Text="New file will be created"
                                       FontSize="12"
                                       Foreground="{DynamicResource DiffAddedForegroundBrush}" />
                        </StackPanel>
                    </Border>
                </StackPanel>

                <!-- Center: Error Message -->
                <Border Grid.Column="1"
                        IsVisible="{Binding ShowError}"
                        Background="{DynamicResource ErrorBackgroundSubtle}"
                        CornerRadius="4"
                        Padding="12,6"
                        Margin="16,0"
                        VerticalAlignment="Center">
                    <StackPanel Orientation="Horizontal" Spacing="8">
                        <PathIcon Data="{StaticResource ErrorIcon}"
                                  Width="16"
                                  Height="16"
                                  Foreground="{DynamicResource ErrorForeground}" />
                        <TextBlock Text="{Binding ErrorMessage}"
                                   Foreground="{DynamicResource ErrorForeground}"
                                   TextWrapping="Wrap"
                                   MaxWidth="400"
                                   VerticalAlignment="Center" />
                    </StackPanel>
                </Border>

                <!-- Right: Action Buttons -->
                <StackPanel Grid.Column="2"
                            Orientation="Horizontal"
                            Spacing="8"
                            VerticalAlignment="Center">

                    <!-- Cancel Button -->
                    <Button Content="Cancel"
                            Command="{Binding CancelCommand}"
                            IsEnabled="{Binding CanCancel}"
                            MinWidth="80"
                            Classes="secondary" />

                    <!-- Apply Button -->
                    <Button Command="{Binding ApplyCommand}"
                            IsEnabled="{Binding CanApply}"
                            MinWidth="120"
                            Classes="accent primary">
                        <StackPanel Orientation="Horizontal" Spacing="8">
                            <!-- Loading Spinner -->
                            <Border IsVisible="{Binding IsApplying}"
                                    Width="16"
                                    Height="16">
                                <PathIcon Data="{StaticResource SpinnerIcon}"
                                          Width="16"
                                          Height="16"
                                          Classes="spinning"
                                          Foreground="{DynamicResource AccentForeground}" />
                            </Border>

                            <!-- Button Text -->
                            <TextBlock Text="{Binding ApplyButtonText}" />
                        </StackPanel>
                    </Button>
                </StackPanel>
            </Grid>
        </Border>
    </Grid>
</Window>
```

### 3. ApplyChangesDialog.axaml.cs (Code-Behind)

```csharp
// src/SeniorIntern.Desktop/Views/ApplyChangesDialog.axaml.cs
using Avalonia.Controls;
using SeniorIntern.Core.Models;
using SeniorIntern.Desktop.ViewModels;
using SeniorIntern.Services.Interfaces;
using SeniorIntern.Services.Models;

namespace SeniorIntern.Desktop.Views;

/// <summary>
/// Apply Changes confirmation dialog window.
/// Shows diff preview and allows user to confirm or cancel the apply operation.
/// </summary>
public partial class ApplyChangesDialog : Window
{
    /// <summary>
    /// Initializes a new instance of the ApplyChangesDialog.
    /// </summary>
    public ApplyChangesDialog()
    {
        InitializeComponent();
    }

    /// <summary>
    /// Shows the Apply Changes dialog and returns the result.
    /// </summary>
    /// <param name="parent">The parent window.</param>
    /// <param name="codeBlock">The code block to apply.</param>
    /// <param name="diff">The pre-computed diff result.</param>
    /// <param name="changeService">Service for applying changes.</param>
    /// <param name="workspaceService">Service for workspace path resolution.</param>
    /// <param name="diffService">Service for diff computation.</param>
    /// <param name="inlineDiffService">Service for inline diff rendering.</param>
    /// <returns>The ApplyResult if applied successfully, or null if cancelled.</returns>
    public static async Task<ApplyResult?> ShowAsync(
        Window parent,
        CodeBlock codeBlock,
        DiffResult diff,
        IFileChangeService changeService,
        IWorkspaceService workspaceService,
        IDiffService diffService,
        IInlineDiffService inlineDiffService)
    {
        ArgumentNullException.ThrowIfNull(parent);
        ArgumentNullException.ThrowIfNull(codeBlock);
        ArgumentNullException.ThrowIfNull(diff);
        ArgumentNullException.ThrowIfNull(changeService);
        ArgumentNullException.ThrowIfNull(workspaceService);
        ArgumentNullException.ThrowIfNull(diffService);
        ArgumentNullException.ThrowIfNull(inlineDiffService);

        var dialog = new ApplyChangesDialog
        {
            DataContext = new ApplyChangesDialogViewModel(
                changeService,
                workspaceService,
                diffService,
                inlineDiffService,
                codeBlock,
                diff,
                dialog: null!) // Will be set below
        };

        // Set the dialog reference in the ViewModel
        // This is needed because we can't pass 'dialog' to constructor before it's created
        if (dialog.DataContext is ApplyChangesDialogViewModel vm)
        {
            // Use reflection or a setter to update the dialog reference
            // Alternative: Use a two-phase initialization
            vm.SetDialogWindow(dialog);
        }

        return await dialog.ShowDialog<ApplyResult?>(parent);
    }

    /// <summary>
    /// Shows the Apply Changes dialog using dependency injection container.
    /// </summary>
    /// <param name="parent">The parent window.</param>
    /// <param name="codeBlock">The code block to apply.</param>
    /// <param name="diff">The pre-computed diff result.</param>
    /// <param name="serviceProvider">The DI service provider.</param>
    /// <returns>The ApplyResult if applied successfully, or null if cancelled.</returns>
    public static async Task<ApplyResult?> ShowAsync(
        Window parent,
        CodeBlock codeBlock,
        DiffResult diff,
        IServiceProvider serviceProvider)
    {
        ArgumentNullException.ThrowIfNull(serviceProvider);

        var changeService = serviceProvider.GetRequiredService<IFileChangeService>();
        var workspaceService = serviceProvider.GetRequiredService<IWorkspaceService>();
        var diffService = serviceProvider.GetRequiredService<IDiffService>();
        var inlineDiffService = serviceProvider.GetRequiredService<IInlineDiffService>();

        return await ShowAsync(
            parent,
            codeBlock,
            diff,
            changeService,
            workspaceService,
            diffService,
            inlineDiffService);
    }
}
```

### 4. ViewModel Extension for Dialog Reference

```csharp
// Addition to ApplyChangesDialogViewModel for dialog reference setting
public partial class ApplyChangesDialogViewModel
{
    private Window? _dialogWindow;

    /// <summary>
    /// Sets the dialog window reference.
    /// Called after construction when using the static factory method.
    /// </summary>
    internal void SetDialogWindow(Window dialog)
    {
        _dialogWindow = dialog ?? throw new ArgumentNullException(nameof(dialog));
    }

    /// <summary>
    /// Gets the dialog window, preferring the constructor-injected instance.
    /// </summary>
    private Window Dialog => _dialogWindow ?? _dialog;
}
```

### 5. BoolToStringConverter

```csharp
// src/SeniorIntern.Desktop/Converters/BoolToStringConverter.cs
using System.Globalization;
using Avalonia.Data.Converters;

namespace SeniorIntern.Desktop.Converters;

/// <summary>
/// Converts a boolean value to one of two strings.
/// Parameter format: "TrueValue|FalseValue"
/// </summary>
public class BoolToStringConverter : IValueConverter
{
    /// <summary>
    /// Converts a boolean to a string based on the parameter.
    /// </summary>
    public object? Convert(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        if (value is not bool boolValue || parameter is not string paramString)
        {
            return value?.ToString() ?? string.Empty;
        }

        var parts = paramString.Split('|');
        if (parts.Length != 2)
        {
            return value.ToString();
        }

        return boolValue ? parts[0] : parts[1];
    }

    /// <summary>
    /// Not implemented - one-way binding only.
    /// </summary>
    public object? ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        throw new NotImplementedException();
    }
}
```

### 6. Dialog Styles

```xml
<!-- src/SeniorIntern.Desktop/Styles/DialogStyles.axaml -->
<Styles xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">

    <!-- Spinning Animation for Loading Indicator -->
    <Style Selector="PathIcon.spinning">
        <Style.Animations>
            <Animation Duration="0:0:1" IterationCount="Infinite">
                <KeyFrame Cue="0%">
                    <Setter Property="RenderTransform">
                        <RotateTransform Angle="0" />
                    </Setter>
                </KeyFrame>
                <KeyFrame Cue="100%">
                    <Setter Property="RenderTransform">
                        <RotateTransform Angle="360" />
                    </Setter>
                </KeyFrame>
            </Animation>
        </Style.Animations>
        <Setter Property="RenderTransformOrigin" Value="0.5, 0.5" />
    </Style>

    <!-- Primary/Accent Button Style -->
    <Style Selector="Button.accent">
        <Setter Property="Background" Value="{DynamicResource AccentBrush}" />
        <Setter Property="Foreground" Value="{DynamicResource AccentForeground}" />
        <Setter Property="BorderBrush" Value="{DynamicResource AccentBrush}" />
    </Style>

    <Style Selector="Button.accent:pointerover">
        <Setter Property="Background" Value="{DynamicResource AccentHoverBrush}" />
    </Style>

    <Style Selector="Button.accent:pressed">
        <Setter Property="Background" Value="{DynamicResource AccentPressedBrush}" />
    </Style>

    <Style Selector="Button.accent:disabled">
        <Setter Property="Opacity" Value="0.5" />
    </Style>

    <!-- Secondary Button Style -->
    <Style Selector="Button.secondary">
        <Setter Property="Background" Value="Transparent" />
        <Setter Property="BorderBrush" Value="{DynamicResource BorderBrush}" />
    </Style>

    <Style Selector="Button.secondary:pointerover">
        <Setter Property="Background" Value="{DynamicResource SurfaceHoverBrush}" />
    </Style>

    <!-- Info Badge Style -->
    <Style Selector="Border.info-badge">
        <Setter Property="CornerRadius" Value="4" />
        <Setter Property="Padding" Value="8,4" />
    </Style>

</Styles>
```

### 7. Required Icon Resources

```xml
<!-- src/SeniorIntern.Desktop/Resources/Icons.axaml (additions) -->
<ResourceDictionary xmlns="https://github.com/avaloniaui"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">

    <!-- Document Icon -->
    <StreamGeometry x:Key="DocumentIcon">
        M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z
    </StreamGeometry>

    <!-- Plus Icon -->
    <StreamGeometry x:Key="PlusIcon">
        M19,13H13V19H11V13H5V11H11V5H13V11H19V13Z
    </StreamGeometry>

    <!-- Error Icon -->
    <StreamGeometry x:Key="ErrorIcon">
        M13,13H11V7H13M13,17H11V15H13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z
    </StreamGeometry>

    <!-- Spinner Icon -->
    <StreamGeometry x:Key="SpinnerIcon">
        M12,4V2A10,10 0 0,0 2,12H4A8,8 0 0,1 12,4Z
    </StreamGeometry>

</ResourceDictionary>
```

### 8. Integration Example

```csharp
// Example: How to show the Apply Changes dialog from MainViewModel
public partial class MainViewModel : ViewModelBase
{
    private readonly IServiceProvider _serviceProvider;
    private readonly IDiffService _diffService;

    [RelayCommand]
    private async Task ApplyCodeBlockAsync(CodeBlock codeBlock)
    {
        // Get the main window
        var mainWindow = App.Current?.ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop
            ? desktop.MainWindow
            : null;

        if (mainWindow is null) return;

        // Compute the diff
        var currentContent = await GetCurrentFileContentAsync(codeBlock.TargetFilePath);
        var diff = await _diffService.ComputeDiffAsync(
            currentContent,
            codeBlock.Content,
            codeBlock.TargetFilePath);

        // Show the dialog
        var result = await ApplyChangesDialog.ShowAsync(
            mainWindow,
            codeBlock,
            diff,
            _serviceProvider);

        if (result is not null && result.Success)
        {
            // Handle successful apply
            await ShowNotificationAsync("Changes applied successfully!");

            // Trigger undo availability
            UndoManager.RegisterUndo(result.ChangeId, codeBlock.TargetFilePath);
        }
        else if (result is not null && result.IsConflict)
        {
            // Handle conflict - might show conflict dialog
            await HandleConflictAsync(codeBlock, result);
        }
        // null result means user cancelled - no action needed
    }
}
```

---

## Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/ViewModels/ApplyChangesDialogViewModel.cs` | Dialog ViewModel with apply logic |
| `src/SeniorIntern.Desktop/Views/ApplyChangesDialog.axaml` | Dialog UI definition |
| `src/SeniorIntern.Desktop/Views/ApplyChangesDialog.axaml.cs` | Dialog code-behind with ShowAsync |
| `src/SeniorIntern.Desktop/Converters/BoolToStringConverter.cs` | Boolean to string converter |
| `src/SeniorIntern.Desktop/Styles/DialogStyles.axaml` | Shared dialog styles |

## Files to Modify

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/Resources/Icons.axaml` | Add DocumentIcon, PlusIcon, ErrorIcon, SpinnerIcon |
| `src/SeniorIntern.Desktop/App.axaml` | Include DialogStyles.axaml in merged dictionaries |
| `src/SeniorIntern.Desktop/ViewModels/MainViewModel.cs` | Add ApplyCodeBlockCommand integration |

---

## Testing Strategy

### Unit Tests

```csharp
// tests/SeniorIntern.Desktop.Tests/ViewModels/ApplyChangesDialogViewModelTests.cs
namespace SeniorIntern.Desktop.Tests.ViewModels;

public class ApplyChangesDialogViewModelTests
{
    private readonly Mock<IFileChangeService> _mockChangeService;
    private readonly Mock<IWorkspaceService> _mockWorkspaceService;
    private readonly Mock<IDiffService> _mockDiffService;
    private readonly Mock<IInlineDiffService> _mockInlineDiffService;
    private readonly Mock<Window> _mockDialog;

    public ApplyChangesDialogViewModelTests()
    {
        _mockChangeService = new Mock<IFileChangeService>();
        _mockWorkspaceService = new Mock<IWorkspaceService>();
        _mockDiffService = new Mock<IDiffService>();
        _mockInlineDiffService = new Mock<IInlineDiffService>();
        _mockDialog = new Mock<Window>();

        _mockWorkspaceService.Setup(ws => ws.CurrentWorkspacePath)
            .Returns("/workspace");
    }

    private ApplyChangesDialogViewModel CreateViewModel(
        CodeBlock? codeBlock = null,
        DiffResult? diff = null)
    {
        codeBlock ??= new CodeBlock
        {
            TargetFilePath = "/workspace/test.cs",
            Content = "new content"
        };

        diff ??= new DiffResult
        {
            IsNewFile = false,
            Hunks = new List<DiffHunk>()
        };

        return new ApplyChangesDialogViewModel(
            _mockChangeService.Object,
            _mockWorkspaceService.Object,
            _mockDiffService.Object,
            _mockInlineDiffService.Object,
            codeBlock,
            diff,
            _mockDialog.Object);
    }

    #region Initialization Tests

    [Fact]
    public void Constructor_ExtractsFileNameFromPath()
    {
        // Arrange
        var codeBlock = new CodeBlock { TargetFilePath = "/path/to/MyFile.cs" };

        // Act
        var vm = CreateViewModel(codeBlock: codeBlock);

        // Assert
        Assert.Equal("MyFile.cs", vm.FileName);
    }

    [Fact]
    public void Constructor_SetsFilePath()
    {
        // Arrange
        var codeBlock = new CodeBlock { TargetFilePath = "/path/to/MyFile.cs" };

        // Act
        var vm = CreateViewModel(codeBlock: codeBlock);

        // Assert
        Assert.Equal("/path/to/MyFile.cs", vm.FilePath);
    }

    [Fact]
    public void Constructor_SetsIsNewFileFromDiff()
    {
        // Arrange
        var diff = new DiffResult { IsNewFile = true };

        // Act
        var vm = CreateViewModel(diff: diff);

        // Assert
        Assert.True(vm.IsNewFile);
    }

    [Fact]
    public void Constructor_DefaultsCreateBackupToTrue()
    {
        // Act
        var vm = CreateViewModel();

        // Assert
        Assert.True(vm.CreateBackup);
    }

    [Fact]
    public void Constructor_InitializesDiffViewModel()
    {
        // Act
        var vm = CreateViewModel();

        // Assert
        Assert.NotNull(vm.DiffViewModel);
    }

    [Fact]
    public void Constructor_NullChangeService_ThrowsArgumentNullException()
    {
        // Act & Assert
        Assert.Throws<ArgumentNullException>(() => new ApplyChangesDialogViewModel(
            null!,
            _mockWorkspaceService.Object,
            _mockDiffService.Object,
            _mockInlineDiffService.Object,
            new CodeBlock(),
            new DiffResult(),
            _mockDialog.Object));
    }

    #endregion

    #region ApplyCommand Tests

    [Fact]
    public async Task ApplyCommand_WhenSuccessful_ClosesDialogWithResult()
    {
        // Arrange
        var vm = CreateViewModel();
        var expectedResult = ApplyResult.Success("change-id");

        _mockChangeService
            .Setup(cs => cs.ApplyCodeBlockAsync(
                It.IsAny<CodeBlock>(),
                It.IsAny<string>(),
                It.IsAny<ApplyOptions>(),
                It.IsAny<CancellationToken>()))
            .ReturnsAsync(expectedResult);

        // Act
        await vm.ApplyCommand.ExecuteAsync(null);

        // Assert
        Assert.Equal(expectedResult, vm.Result);
        _mockDialog.Verify(d => d.Close(expectedResult), Times.Once);
    }

    [Fact]
    public async Task ApplyCommand_WhenFailed_ShowsErrorMessage()
    {
        // Arrange
        var vm = CreateViewModel();
        var failedResult = ApplyResult.Failure("Something went wrong");

        _mockChangeService
            .Setup(cs => cs.ApplyCodeBlockAsync(
                It.IsAny<CodeBlock>(),
                It.IsAny<string>(),
                It.IsAny<ApplyOptions>(),
                It.IsAny<CancellationToken>()))
            .ReturnsAsync(failedResult);

        // Act
        await vm.ApplyCommand.ExecuteAsync(null);

        // Assert
        Assert.Equal("Something went wrong", vm.ErrorMessage);
        _mockDialog.Verify(d => d.Close(It.IsAny<object>()), Times.Never);
    }

    [Fact]
    public async Task ApplyCommand_SetsIsApplyingDuringOperation()
    {
        // Arrange
        var vm = CreateViewModel();
        var tcs = new TaskCompletionSource<ApplyResult>();

        _mockChangeService
            .Setup(cs => cs.ApplyCodeBlockAsync(
                It.IsAny<CodeBlock>(),
                It.IsAny<string>(),
                It.IsAny<ApplyOptions>(),
                It.IsAny<CancellationToken>()))
            .Returns(tcs.Task);

        // Act
        var applyTask = vm.ApplyCommand.ExecuteAsync(null);
        Assert.True(vm.IsApplying);

        tcs.SetResult(ApplyResult.Success("id"));
        await applyTask;

        // Assert
        Assert.False(vm.IsApplying);
    }

    [Fact]
    public async Task ApplyCommand_PassesBackupOptionToService()
    {
        // Arrange
        var vm = CreateViewModel();
        vm.CreateBackup = false;

        ApplyOptions? capturedOptions = null;
        _mockChangeService
            .Setup(cs => cs.ApplyCodeBlockAsync(
                It.IsAny<CodeBlock>(),
                It.IsAny<string>(),
                It.IsAny<ApplyOptions>(),
                It.IsAny<CancellationToken>()))
            .Callback<CodeBlock, string, ApplyOptions, CancellationToken>(
                (_, _, opts, _) => capturedOptions = opts)
            .ReturnsAsync(ApplyResult.Success("id"));

        // Act
        await vm.ApplyCommand.ExecuteAsync(null);

        // Assert
        Assert.NotNull(capturedOptions);
        Assert.False(capturedOptions.CreateBackup);
    }

    [Fact]
    public async Task ApplyCommand_WhenAlreadyApplying_DoesNothing()
    {
        // Arrange
        var vm = CreateViewModel();
        var tcs = new TaskCompletionSource<ApplyResult>();

        _mockChangeService
            .Setup(cs => cs.ApplyCodeBlockAsync(
                It.IsAny<CodeBlock>(),
                It.IsAny<string>(),
                It.IsAny<ApplyOptions>(),
                It.IsAny<CancellationToken>()))
            .Returns(tcs.Task);

        // Start first apply
        var firstApply = vm.ApplyCommand.ExecuteAsync(null);

        // Act - try to apply again
        await vm.ApplyCommand.ExecuteAsync(null);

        // Assert - should only be called once
        _mockChangeService.Verify(
            cs => cs.ApplyCodeBlockAsync(
                It.IsAny<CodeBlock>(),
                It.IsAny<string>(),
                It.IsAny<ApplyOptions>(),
                It.IsAny<CancellationToken>()),
            Times.Once);

        tcs.SetResult(ApplyResult.Success("id"));
        await firstApply;
    }

    [Fact]
    public async Task ApplyCommand_OnException_ShowsErrorMessage()
    {
        // Arrange
        var vm = CreateViewModel();

        _mockChangeService
            .Setup(cs => cs.ApplyCodeBlockAsync(
                It.IsAny<CodeBlock>(),
                It.IsAny<string>(),
                It.IsAny<ApplyOptions>(),
                It.IsAny<CancellationToken>()))
            .ThrowsAsync(new IOException("Disk is full"));

        // Act
        await vm.ApplyCommand.ExecuteAsync(null);

        // Assert
        Assert.Contains("Disk is full", vm.ErrorMessage);
        Assert.False(vm.IsApplying);
    }

    [Fact]
    public async Task ApplyCommand_ClearsErrorMessageOnRetry()
    {
        // Arrange
        var vm = CreateViewModel();
        vm.SetPrivateField("_errorMessage", "Previous error");

        _mockChangeService
            .Setup(cs => cs.ApplyCodeBlockAsync(
                It.IsAny<CodeBlock>(),
                It.IsAny<string>(),
                It.IsAny<ApplyOptions>(),
                It.IsAny<CancellationToken>()))
            .ReturnsAsync(ApplyResult.Success("id"));

        // Act
        await vm.ApplyCommand.ExecuteAsync(null);

        // Assert - error should be cleared before operation
        Assert.Null(vm.ErrorMessage);
    }

    [Fact]
    public async Task ApplyCommand_WhenConflict_ShowsConflictError()
    {
        // Arrange
        var vm = CreateViewModel();
        var conflictResult = ApplyResult.Conflict(
            ConflictReason.ContentModified,
            "File was modified",
            DateTime.UtcNow,
            DateTime.UtcNow.AddMinutes(-5));

        _mockChangeService
            .Setup(cs => cs.ApplyCodeBlockAsync(
                It.IsAny<CodeBlock>(),
                It.IsAny<string>(),
                It.IsAny<ApplyOptions>(),
                It.IsAny<CancellationToken>()))
            .ReturnsAsync(conflictResult);

        // Act
        await vm.ApplyCommand.ExecuteAsync(null);

        // Assert
        Assert.Contains("Conflict", vm.ErrorMessage);
        _mockDialog.Verify(d => d.Close(It.IsAny<object>()), Times.Never);
    }

    #endregion

    #region CancelCommand Tests

    [Fact]
    public void CancelCommand_ClosesDialogWithNull()
    {
        // Arrange
        var vm = CreateViewModel();

        // Act
        vm.CancelCommand.Execute(null);

        // Assert
        _mockDialog.Verify(d => d.Close(null), Times.Once);
    }

    [Fact]
    public async Task CancelCommand_DisabledWhileApplying()
    {
        // Arrange
        var vm = CreateViewModel();
        var tcs = new TaskCompletionSource<ApplyResult>();

        _mockChangeService
            .Setup(cs => cs.ApplyCodeBlockAsync(
                It.IsAny<CodeBlock>(),
                It.IsAny<string>(),
                It.IsAny<ApplyOptions>(),
                It.IsAny<CancellationToken>()))
            .Returns(tcs.Task);

        // Act
        var applyTask = vm.ApplyCommand.ExecuteAsync(null);

        // Assert
        Assert.False(vm.CanCancel);

        tcs.SetResult(ApplyResult.Success("id"));
        await applyTask;

        Assert.True(vm.CanCancel);
    }

    #endregion

    #region Computed Property Tests

    [Fact]
    public void ApplyButtonText_WhenNotApplying_ShowsApplyChanges()
    {
        // Arrange
        var vm = CreateViewModel();

        // Assert
        Assert.Equal("Apply Changes", vm.ApplyButtonText);
    }

    [Fact]
    public async Task ApplyButtonText_WhenApplying_ShowsApplying()
    {
        // Arrange
        var vm = CreateViewModel();
        var tcs = new TaskCompletionSource<ApplyResult>();

        _mockChangeService
            .Setup(cs => cs.ApplyCodeBlockAsync(
                It.IsAny<CodeBlock>(),
                It.IsAny<string>(),
                It.IsAny<ApplyOptions>(),
                It.IsAny<CancellationToken>()))
            .Returns(tcs.Task);

        // Act
        var applyTask = vm.ApplyCommand.ExecuteAsync(null);

        // Assert
        Assert.Equal("Applying...", vm.ApplyButtonText);

        tcs.SetResult(ApplyResult.Success("id"));
        await applyTask;
    }

    [Fact]
    public void ShowError_WhenErrorMessageNull_ReturnsFalse()
    {
        // Arrange
        var vm = CreateViewModel();

        // Assert
        Assert.False(vm.ShowError);
    }

    [Fact]
    public void ShowError_WhenErrorMessageSet_ReturnsTrue()
    {
        // Arrange
        var vm = CreateViewModel();
        vm.SetPrivateField("_errorMessage", "Some error");

        // Assert
        Assert.True(vm.ShowError);
    }

    #endregion
}
```

### Integration Tests

```csharp
// tests/SeniorIntern.Desktop.Tests/Integration/ApplyChangesDialogIntegrationTests.cs
namespace SeniorIntern.Desktop.Tests.Integration;

public class ApplyChangesDialogIntegrationTests
{
    [Fact]
    public async Task ShowAsync_WithValidParameters_CreatesDialog()
    {
        // This would be an Avalonia headless test
        // Requires Avalonia.Headless package

        await using var app = await AppBuilder.Configure<TestApp>()
            .UseHeadless()
            .StartWithClassicDesktopLifetime(Array.Empty<string>());

        // ... test dialog creation and interaction
    }
}
```

### UI Automation Tests

```csharp
// tests/SeniorIntern.Desktop.Tests/UITests/ApplyDialogUITests.cs
namespace SeniorIntern.Desktop.Tests.UITests;

public class ApplyDialogUITests
{
    [Fact]
    public void Dialog_HasCorrectInitialState()
    {
        // Test that:
        // - Backup checkbox is checked by default
        // - Apply button is enabled
        // - Cancel button is enabled
        // - Error message is not visible
        // - Spinner is not visible
    }

    [Fact]
    public void NewFileBadge_VisibleWhenIsNewFile()
    {
        // Test that the "New file will be created" badge appears
        // when IsNewFile is true
    }

    [Fact]
    public void KeyboardShortcuts_Work()
    {
        // Test that:
        // - Enter triggers Apply
        // - Escape triggers Cancel
    }
}
```

---

## Acceptance Criteria

### Functional Requirements

- [ ] **Dialog displays diff preview** - Embedded DiffViewerPanel shows the proposed changes
- [ ] **Header shows file information** - File name, path, and changes summary displayed
- [ ] **Backup checkbox toggles option** - User can enable/disable backup before applying
- [ ] **New file badge visible when appropriate** - Shows "New file will be created" for new files
- [ ] **Apply button triggers operation** - Clicking Apply calls FileChangeService
- [ ] **Cancel closes without changes** - Clicking Cancel or pressing Escape closes with null
- [ ] **Error messages displayed** - Failures show error message in footer
- [ ] **Loading state shown during apply** - Spinner visible, buttons disabled while applying
- [ ] **Keyboard shortcuts work** - Enter for Apply, Escape for Cancel
- [ ] **Dialog is resizable** - User can resize to see more of the diff
- [ ] **Dialog centers on parent** - Window appears centered over main window

### Non-Functional Requirements

- [ ] **Responsive UI** - Apply operation doesn't freeze the UI
- [ ] **Accessible** - Keyboard navigation works, screen reader compatible
- [ ] **Theme-aware** - Uses DynamicResource for all colors
- [ ] **Consistent styling** - Follows application design system

### Integration Requirements

- [ ] **Static ShowAsync method** - Easy to call from any ViewModel
- [ ] **DI-friendly overload** - Can use IServiceProvider for dependencies
- [ ] **Returns ApplyResult or null** - Clear contract for callers
- [ ] **Works with DiffViewerPanel** - Embeds existing diff viewer component

---

## Design Decisions

### 1. Static Factory Method (ShowAsync)

**Decision**: Use a static `ShowAsync` method on the dialog class for instantiation.

**Rationale**:
- Simplifies calling code - one line to show dialog and get result
- Encapsulates ViewModel creation and wiring
- Follows common Avalonia dialog patterns
- Provides overloads for both explicit dependencies and DI container

**Alternative Considered**:
- ViewModel-first approach with ViewLocator - more complex for modal dialogs

### 2. Embedded DiffViewerPanel

**Decision**: Embed the existing `DiffViewerPanel` UserControl in the dialog.

**Rationale**:
- Reuses existing diff visualization code
- Consistent look and feel with standalone diff viewer
- Reduces code duplication
- Single source of truth for diff rendering

**Trade-offs**:
- Tight coupling between dialog and diff viewer
- May need to adjust diff viewer for embedded context

### 3. Window Reference in ViewModel

**Decision**: Pass the Window to ViewModel for Close() calls.

**Rationale**:
- ViewModel needs to close dialog on success
- Direct reference is simplest approach
- Two-phase initialization handles circular reference

**Alternatives Considered**:
- Messenger/EventAggregator pattern - adds complexity
- IDialogService abstraction - overkill for single dialog
- Close event from ViewModel - still needs window reference

### 4. Dual-Binding for Button State

**Decision**: Use both `IsEnabled` binding and `CanExecute` on commands.

**Rationale**:
- Commands provide CanExecute for programmatic checks
- IsEnabled binding gives immediate visual feedback
- Belt-and-suspenders approach for reliability

### 5. Error Display in Footer

**Decision**: Show error messages inline in the dialog footer.

**Rationale**:
- Keeps error visible without obscuring diff
- User can see error and retry without closing dialog
- Follows established UI pattern for form errors

**Alternative Considered**:
- Modal error dialog - disrupts workflow for common errors
- Toast notification - may not be noticed

### 6. CreateBackup Default True

**Decision**: Default the backup checkbox to checked (true).

**Rationale**:
- Safe default - users can undo if something goes wrong
- Matches user expectation for destructive operations
- Experienced users can uncheck if they prefer

---

## Accessibility Considerations

### Keyboard Navigation

| Key | Action |
|-----|--------|
| Tab | Move focus between controls |
| Enter | Execute Apply command |
| Escape | Execute Cancel command |
| Space | Toggle checkbox when focused |

### Screen Reader Support

- Dialog has descriptive title "Apply Changes"
- File name and path announced in header
- Error messages use ARIA live region semantics
- Button states (enabled/disabled) announced

### Visual Accessibility

- Sufficient color contrast for all text
- Focus indicators visible on all interactive elements
- Error states use both color and icon
- Loading state has visible spinner (not just disabled buttons)

---

## Performance Considerations

### Diff Loading

- Diff is pre-computed before dialog opens
- DiffViewerPanel virtualizes for large diffs
- No additional file I/O during dialog display

### Apply Operation

- Runs on background thread (async)
- UI remains responsive during apply
- Can be cancelled (CancellationToken support)

### Memory

- Dialog and ViewModel disposed after close
- No memory leaks from event subscriptions

---

## Future Enhancements

1. **Partial apply** - Allow selecting specific hunks to apply
2. **Side-by-side diff mode** - Toggle between inline and side-by-side views
3. **Syntax highlighting in diff** - Enhance code readability
4. **Apply history** - Show recent applies with undo capability
5. **Batch apply** - Apply multiple code blocks at once
6. **Conflict resolution inline** - Handle conflicts within dialog
