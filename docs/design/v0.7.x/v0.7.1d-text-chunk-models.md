# Design Specification: AIntern v0.7.1d "Text Chunk Models"

## Overview

**Version**: v0.7.1d
**Parent**: v0.7.1 Embedding Foundation
**Focus**: Defining comprehensive data models for text chunks with metadata for code understanding and retrieval

### Purpose

This sub-version introduces the core data models for representing text and code chunks in the RAG (Retrieval-Augmented Generation) system:
1. `TextChunk` - Main chunk model with comprehensive metadata for embedding and retrieval
2. `ChunkType` - Enum classifying the type of content in a chunk
3. `SymbolType` - Enum classifying code symbol types for semantic understanding
4. `ChunkingOptions` - Configuration options for the chunking process
5. `ChunkPreprocessing` - Text preprocessing settings before chunking

### Dependencies

**From v0.7.1a (Embedding Service Interface)**:
- No direct code dependencies (models are independent)
- Conceptual alignment with embedding workflow

**From v0.7.1b/v0.7.1c (Embedding Implementations)**:
- Embedding services will consume `TextChunk` instances for embedding generation
- `ITokenizerService.CountTokens()` informs `TokenCount` property

**External Dependencies**:
- System - Core types (Guid, etc.)
- System.Collections.Generic - Collection interfaces

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                   v0.7.1d Text Chunk Models                                   │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                        Model Layer                                        │ │
│  │  src/AIntern.Core/Models/                                                 │ │
│  ├─────────────────────────────────────────────────────────────────────────┤ │
│  │                                                                          │ │
│  │  ┌────────────────────────────────────────────────────────────────────┐ │ │
│  │  │                          TextChunk                                   │ │ │
│  │  │  Main chunk model with comprehensive metadata                        │ │ │
│  │  │  ┌─────────────────────────────────────────────────────────────┐   │ │ │
│  │  │  │  Identity & Content:                                        │   │ │ │
│  │  │  │  ├── Id: Guid (auto-generated)                              │   │ │ │
│  │  │  │  └── Content: string                                        │   │ │ │
│  │  │  └─────────────────────────────────────────────────────────────┘   │ │ │
│  │  │  ┌─────────────────────────────────────────────────────────────┐   │ │ │
│  │  │  │  Source Location:                                           │   │ │ │
│  │  │  │  ├── FilePath: string (relative to workspace)               │   │ │ │
│  │  │  │  ├── AbsolutePath: string? (for file operations)            │   │ │ │
│  │  │  │  ├── StartLine / EndLine: int (1-based, inclusive)          │   │ │ │
│  │  │  │  └── StartOffset / EndOffset: int (character offsets)       │   │ │ │
│  │  │  └─────────────────────────────────────────────────────────────┘   │ │ │
│  │  │  ┌─────────────────────────────────────────────────────────────┐   │ │ │
│  │  │  │  Content Classification:                                    │   │ │ │
│  │  │  │  ├── Type: ChunkType (Code, Comment, Markdown, etc.)        │   │ │ │
│  │  │  │  └── Language: string? (csharp, python, etc.)               │   │ │ │
│  │  │  └─────────────────────────────────────────────────────────────┘   │ │ │
│  │  │  ┌─────────────────────────────────────────────────────────────┐   │ │ │
│  │  │  │  Code Symbol Information:                                   │   │ │ │
│  │  │  │  ├── SymbolName: string? (method/class name)                │   │ │ │
│  │  │  │  ├── SymbolType: SymbolType? (Class, Method, etc.)          │   │ │ │
│  │  │  │  ├── QualifiedName: string? (full path)                     │   │ │ │
│  │  │  │  ├── ParentSymbol: string? (containing class)               │   │ │ │
│  │  │  │  └── Namespace: string? (namespace/module)                  │   │ │ │
│  │  │  └─────────────────────────────────────────────────────────────┘   │ │ │
│  │  │  ┌─────────────────────────────────────────────────────────────┐   │ │ │
│  │  │  │  Chunk Metadata:                                            │   │ │ │
│  │  │  │  ├── TokenCount: int (for embedding limits)                 │   │ │ │
│  │  │  │  ├── SequenceNumber: int (ordering within file)             │   │ │ │
│  │  │  │  └── HasOverlap: bool (overlaps with previous)              │   │ │ │
│  │  │  └─────────────────────────────────────────────────────────────┘   │ │ │
│  │  │  ┌─────────────────────────────────────────────────────────────┐   │ │ │
│  │  │  │  Additional Information:                                    │   │ │ │
│  │  │  │  ├── Summary: string? (docstring/description)               │   │ │ │
│  │  │  │  ├── Tags: IReadOnlyList<string>?                           │   │ │ │
│  │  │  │  └── Metadata: IReadOnlyDictionary<string, string>?         │   │ │ │
│  │  │  └─────────────────────────────────────────────────────────────┘   │ │ │
│  │  │  ┌─────────────────────────────────────────────────────────────┐   │ │ │
│  │  │  │  Computed Properties:                                       │   │ │ │
│  │  │  │  ├── LineCount: int (EndLine - StartLine + 1)               │   │ │ │
│  │  │  │  ├── Length: int (Content.Length)                           │   │ │ │
│  │  │  │  └── LocationString: string ("file:line" format)            │   │ │ │
│  │  │  └─────────────────────────────────────────────────────────────┘   │ │ │
│  │  │  ┌─────────────────────────────────────────────────────────────┐   │ │ │
│  │  │  │  Methods:                                                   │   │ │ │
│  │  │  │  └── WithContent(newContent) → TextChunk (modified copy)    │   │ │ │
│  │  │  └─────────────────────────────────────────────────────────────┘   │ │ │
│  │  └────────────────────────────────────────────────────────────────────┘ │ │
│  │                                                                          │ │
│  │  ┌────────────────────────────────────────────────────────────────────┐ │ │
│  │  │                          ChunkType                                   │ │ │
│  │  │  Enum for content type classification                                │ │ │
│  │  │  ┌─────────────────────────────────────────────────────────────┐   │ │ │
│  │  │  │  Values:                                                    │   │ │ │
│  │  │  │  ├── Code           - Executable code (functions, methods)  │   │ │ │
│  │  │  │  ├── Comment        - Code comments (single/block)          │   │ │ │
│  │  │  │  ├── Documentation  - Docstrings, XML docs, JSDoc           │   │ │ │
│  │  │  │  ├── Markdown       - Markdown content                      │   │ │ │
│  │  │  │  ├── PlainText      - Plain text content                    │   │ │ │
│  │  │  │  ├── Config         - Configuration files (JSON, YAML)      │   │ │ │
│  │  │  │  ├── Mixed          - Code with inline comments             │   │ │ │
│  │  │  │  ├── Import         - Import/using statements               │   │ │ │
│  │  │  │  ├── TypeDefinition - Class/interface definitions           │   │ │ │
│  │  │  │  └── Test           - Test code                             │   │ │ │
│  │  │  └─────────────────────────────────────────────────────────────┘   │ │ │
│  │  └────────────────────────────────────────────────────────────────────┘ │ │
│  │                                                                          │ │
│  │  ┌────────────────────────────────────────────────────────────────────┐ │ │
│  │  │                          SymbolType                                  │ │ │
│  │  │  Enum for code symbol classification                                 │ │ │
│  │  │  ┌─────────────────────────────────────────────────────────────┐   │ │ │
│  │  │  │  Type Definitions:                                          │   │ │ │
│  │  │  │  ├── Namespace      - Namespace declaration                 │   │ │ │
│  │  │  │  ├── Class          - Class definition                      │   │ │ │
│  │  │  │  ├── Struct         - Struct/record definition              │   │ │ │
│  │  │  │  ├── Interface      - Interface definition                  │   │ │ │
│  │  │  │  ├── Enum           - Enum definition                       │   │ │ │
│  │  │  │  ├── Delegate       - Delegate type                         │   │ │ │
│  │  │  │  ├── TypeAlias      - Type alias                            │   │ │ │
│  │  │  │  └── Module         - Module (JS/TS/Python)                 │   │ │ │
│  │  │  └─────────────────────────────────────────────────────────────┘   │ │ │
│  │  │  ┌─────────────────────────────────────────────────────────────┐   │ │ │
│  │  │  │  Member Definitions:                                        │   │ │ │
│  │  │  │  ├── Method         - Method definition (in class/struct)   │   │ │ │
│  │  │  │  ├── Function       - Standalone function                   │   │ │ │
│  │  │  │  ├── Property       - Property definition                   │   │ │ │
│  │  │  │  ├── Field          - Field definition                      │   │ │ │
│  │  │  │  ├── Constructor    - Constructor                           │   │ │ │
│  │  │  │  ├── Destructor     - Destructor/finalizer                  │   │ │ │
│  │  │  │  ├── Event          - Event definition                      │   │ │ │
│  │  │  │  ├── Operator       - Operator overload                     │   │ │ │
│  │  │  │  ├── Indexer        - Indexer                               │   │ │ │
│  │  │  │  ├── Constant       - Constant definition                   │   │ │ │
│  │  │  │  └── Lambda         - Lambda/closure                        │   │ │ │
│  │  │  └─────────────────────────────────────────────────────────────┘   │ │ │
│  │  │  ┌─────────────────────────────────────────────────────────────┐   │ │ │
│  │  │  │  Other:                                                     │   │ │ │
│  │  │  │  ├── Import         - Import/using statement                │   │ │ │
│  │  │  │  └── Other          - Unknown/unclassified symbol           │   │ │ │
│  │  │  └─────────────────────────────────────────────────────────────┘   │ │ │
│  │  └────────────────────────────────────────────────────────────────────┘ │ │
│  │                                                                          │ │
│  │  ┌────────────────────────────────────────────────────────────────────┐ │ │
│  │  │                      ChunkingOptions                                 │ │ │
│  │  │  Configuration options for text chunking                             │ │ │
│  │  │  ┌─────────────────────────────────────────────────────────────┐   │ │ │
│  │  │  │  Size Configuration:                                        │   │ │ │
│  │  │  │  ├── TargetChunkSize: int (512) - Target tokens per chunk   │   │ │ │
│  │  │  │  ├── ChunkOverlap: int (64) - Overlap between chunks        │   │ │ │
│  │  │  │  ├── MinChunkSize: int (50) - Minimum chunk size            │   │ │ │
│  │  │  │  └── MaxChunkSize: int (1024) - Maximum chunk size          │   │ │ │
│  │  │  └─────────────────────────────────────────────────────────────┘   │ │ │
│  │  │  ┌─────────────────────────────────────────────────────────────┐   │ │ │
│  │  │  │  Metadata Options:                                          │   │ │ │
│  │  │  │  ├── IncludeFilePath: bool (true)                           │   │ │ │
│  │  │  │  └── IncludeLineNumbers: bool (true)                        │   │ │ │
│  │  │  └─────────────────────────────────────────────────────────────┘   │ │ │
│  │  │  ┌─────────────────────────────────────────────────────────────┐   │ │ │
│  │  │  │  Semantic Options:                                          │   │ │ │
│  │  │  │  ├── UseSemanticChunking: bool (true)                       │   │ │ │
│  │  │  │  ├── ExtractSymbols: bool (true)                            │   │ │ │
│  │  │  │  └── PreserveFunctionBodies: bool (true)                    │   │ │ │
│  │  │  └─────────────────────────────────────────────────────────────┘   │ │ │
│  │  │  ┌─────────────────────────────────────────────────────────────┐   │ │ │
│  │  │  │  Documentation Options:                                     │   │ │ │
│  │  │  │  ├── IncludeDocumentation: bool (true)                      │   │ │ │
│  │  │  │  └── SeparateDocumentationChunks: bool (false)              │   │ │ │
│  │  │  └─────────────────────────────────────────────────────────────┘   │ │ │
│  │  │  ┌─────────────────────────────────────────────────────────────┐   │ │ │
│  │  │  │  Filtering & Preprocessing:                                 │   │ │ │
│  │  │  │  ├── Preprocessing: ChunkPreprocessing                      │   │ │ │
│  │  │  │  ├── IncludePatterns: IReadOnlyList<string>?                │   │ │ │
│  │  │  │  └── ExcludePatterns: IReadOnlyList<string>?                │   │ │ │
│  │  │  └─────────────────────────────────────────────────────────────┘   │ │ │
│  │  └────────────────────────────────────────────────────────────────────┘ │ │
│  │                                                                          │ │
│  │  ┌────────────────────────────────────────────────────────────────────┐ │ │
│  │  │                      ChunkPreprocessing                              │ │ │
│  │  │  Text preprocessing options                                          │ │ │
│  │  │  ┌─────────────────────────────────────────────────────────────┐   │ │ │
│  │  │  │  Static Properties:                                         │   │ │ │
│  │  │  │  └── Default: ChunkPreprocessing (common settings)          │   │ │ │
│  │  │  └─────────────────────────────────────────────────────────────┘   │ │ │
│  │  │  ┌─────────────────────────────────────────────────────────────┐   │ │ │
│  │  │  │  Whitespace Options:                                        │   │ │ │
│  │  │  │  ├── NormalizeWhitespace: bool (true in Default)            │   │ │ │
│  │  │  │  ├── RemoveEmptyLines: bool (false in Default)              │   │ │ │
│  │  │  │  ├── CollapseMultipleNewlines: bool (true in Default)       │   │ │ │
│  │  │  │  ├── TrimLines: bool (true in Default)                      │   │ │ │
│  │  │  │  └── MaxConsecutiveEmptyLines: int (2 in Default)           │   │ │ │
│  │  │  └─────────────────────────────────────────────────────────────┘   │ │ │
│  │  │  ┌─────────────────────────────────────────────────────────────┐   │ │ │
│  │  │  │  Content Options:                                           │   │ │ │
│  │  │  │  └── RemoveLicenseHeaders: bool (true in Default)           │   │ │ │
│  │  │  └─────────────────────────────────────────────────────────────┘   │ │ │
│  │  └────────────────────────────────────────────────────────────────────┘ │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Specifications

### Files to Create

| File | Purpose |
|------|---------|
| `src/AIntern.Core/Models/TextChunk.cs` | Main chunk model with comprehensive metadata |
| `src/AIntern.Core/Models/ChunkType.cs` | ChunkType and SymbolType enum definitions |
| `src/AIntern.Core/Models/ChunkingOptions.cs` | Configuration options and preprocessing settings |

### Files to Modify

None - this sub-version introduces new model files only.

---

## Detailed Implementation

### File: `src/AIntern.Core/Models/TextChunk.cs`

```csharp
using System;
using System.Collections.Generic;

namespace AIntern.Core.Models;

/// <summary>
/// A chunk of text/code with metadata for embedding and retrieval.
/// </summary>
/// <remarks>
/// <para>
/// TextChunk is the fundamental unit of content in the RAG system. Each chunk
/// represents a semantically meaningful segment of text or code that can be
/// independently embedded and retrieved.
/// </para>
/// <para>
/// The model uses init-only properties for immutability, ensuring thread-safety
/// when chunks are processed by embedding services. The <see cref="WithContent"/>
/// method provides a way to create modified copies when preprocessing is needed.
/// </para>
/// </remarks>
public sealed class TextChunk
{
    /// <summary>
    /// Unique identifier for this chunk.
    /// </summary>
    /// <remarks>
    /// Auto-generated on construction. Used as the primary key when storing
    /// chunks in the vector database and for deduplication during retrieval.
    /// </remarks>
    public Guid Id { get; init; } = Guid.NewGuid();

    /// <summary>
    /// The actual text content of the chunk.
    /// </summary>
    /// <remarks>
    /// This is the raw content that will be passed to the embedding service.
    /// May be preprocessed (whitespace normalized, license headers removed, etc.)
    /// based on <see cref="ChunkPreprocessing"/> settings.
    /// </remarks>
    public string Content { get; init; } = string.Empty;

    /// <summary>
    /// Source file path (relative to workspace root).
    /// </summary>
    /// <remarks>
    /// Used for display, navigation, and filtering. Relative paths ensure
    /// portability across different machines and workspace locations.
    /// </remarks>
    public string FilePath { get; init; } = string.Empty;

    /// <summary>
    /// Absolute file path (for file operations).
    /// </summary>
    /// <remarks>
    /// Used when the chunk needs to reference the actual file on disk,
    /// such as when opening the file in an editor or re-reading content.
    /// May be null if the chunk was created from in-memory content.
    /// </remarks>
    public string? AbsolutePath { get; init; }

    /// <summary>
    /// Starting line number in the source file (1-based).
    /// </summary>
    /// <remarks>
    /// Line numbers are 1-based to match editor conventions. Used for
    /// navigation and display in <see cref="LocationString"/>.
    /// </remarks>
    public int StartLine { get; init; }

    /// <summary>
    /// Ending line number in the source file (1-based, inclusive).
    /// </summary>
    /// <remarks>
    /// Inclusive end line allows accurate calculation of <see cref="LineCount"/>.
    /// A single-line chunk has StartLine == EndLine.
    /// </remarks>
    public int EndLine { get; init; }

    /// <summary>
    /// Character offset from the start of the file.
    /// </summary>
    /// <remarks>
    /// Zero-based character offset. Used for precise positioning when
    /// highlighting or extracting content from the original file.
    /// </remarks>
    public int StartOffset { get; init; }

    /// <summary>
    /// End character offset (exclusive).
    /// </summary>
    /// <remarks>
    /// The character position immediately after the last character in the chunk.
    /// Content.Length should equal EndOffset - StartOffset.
    /// </remarks>
    public int EndOffset { get; init; }

    /// <summary>
    /// Type of content in this chunk.
    /// </summary>
    /// <remarks>
    /// Used to categorize chunks for filtering and prioritization during retrieval.
    /// For example, code queries might prioritize <see cref="ChunkType.Code"/> chunks
    /// over <see cref="ChunkType.Comment"/> chunks.
    /// </remarks>
    public ChunkType Type { get; init; } = ChunkType.Code;

    /// <summary>
    /// Programming language of the content (if applicable).
    /// </summary>
    /// <remarks>
    /// Language identifier string (e.g., "csharp", "python", "typescript").
    /// Determined by file extension during chunking. Null for non-code content.
    /// </remarks>
    public string? Language { get; init; }

    /// <summary>
    /// Symbol name if this chunk represents a specific code symbol.
    /// </summary>
    /// <remarks>
    /// The simple name of the code symbol (e.g., "DoSomething" for a method,
    /// "MyClass" for a class). Null if the chunk doesn't represent a distinct symbol.
    /// </remarks>
    public string? SymbolName { get; init; }

    /// <summary>
    /// Type of symbol (class, method, function, etc.).
    /// </summary>
    /// <remarks>
    /// Provides semantic information about what kind of code construct this chunk
    /// represents. Used for filtering (e.g., "find all methods that...").
    /// </remarks>
    public SymbolType? SymbolType { get; init; }

    /// <summary>
    /// Fully qualified symbol name.
    /// </summary>
    /// <remarks>
    /// The complete path to the symbol including namespace and parent types
    /// (e.g., "AIntern.Core.Models.TextChunk.WithContent"). Used for precise
    /// symbol lookup and disambiguation.
    /// </remarks>
    public string? QualifiedName { get; init; }

    /// <summary>
    /// Parent symbol name (e.g., class containing a method).
    /// </summary>
    /// <remarks>
    /// The simple name of the containing symbol. For a method, this would be
    /// the class name. For a nested class, this would be the outer class name.
    /// </remarks>
    public string? ParentSymbol { get; init; }

    /// <summary>
    /// Namespace or module containing the symbol.
    /// </summary>
    /// <remarks>
    /// The namespace (C#), module (Python), or package (Java/Kotlin) containing
    /// this code. Used for organizational context and filtering.
    /// </remarks>
    public string? Namespace { get; init; }

    /// <summary>
    /// Approximate token count for this chunk.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Token count is calculated during chunking using the configured tokenizer.
    /// This value is used to ensure chunks fit within embedding model limits
    /// and to estimate costs for embedding generation.
    /// </para>
    /// <para>
    /// The count is approximate because different tokenizers may produce slightly
    /// different results. The chunking service targets <see cref="ChunkingOptions.TargetChunkSize"/>
    /// tokens per chunk.
    /// </para>
    /// </remarks>
    public int TokenCount { get; init; }

    /// <summary>
    /// Sequence number within the file (for ordering overlapping chunks).
    /// </summary>
    /// <remarks>
    /// Zero-based index indicating the chunk's position in the file's chunk sequence.
    /// Used to maintain document order when reconstructing context from multiple
    /// retrieved chunks.
    /// </remarks>
    public int SequenceNumber { get; init; }

    /// <summary>
    /// Whether this chunk overlaps with the previous chunk.
    /// </summary>
    /// <remarks>
    /// When <see cref="ChunkingOptions.ChunkOverlap"/> is greater than zero,
    /// consecutive chunks share some content at their boundaries. This flag
    /// indicates that this chunk's beginning overlaps with the previous chunk's end.
    /// </remarks>
    public bool HasOverlap { get; init; }

    /// <summary>
    /// Summary or docstring for this chunk (if available).
    /// </summary>
    /// <remarks>
    /// Extracted documentation such as XML doc summary, Python docstring,
    /// or JSDoc description. Provides human-readable context about the chunk's
    /// purpose without examining the code itself.
    /// </remarks>
    public string? Summary { get; init; }

    /// <summary>
    /// Tags for additional categorization.
    /// </summary>
    /// <remarks>
    /// User-defined or automatically extracted tags for filtering and organization.
    /// Examples: ["async", "deprecated", "public-api", "test", "utility"].
    /// </remarks>
    public IReadOnlyList<string>? Tags { get; init; }

    /// <summary>
    /// Additional metadata as key-value pairs.
    /// </summary>
    /// <remarks>
    /// Extensible storage for custom metadata not covered by other properties.
    /// Common uses include git blame information, modification timestamps,
    /// or framework-specific annotations.
    /// </remarks>
    public IReadOnlyDictionary<string, string>? Metadata { get; init; }

    /// <summary>
    /// Number of lines in this chunk.
    /// </summary>
    /// <remarks>
    /// Computed from StartLine and EndLine. Useful for estimating chunk size
    /// and complexity without examining the content.
    /// </remarks>
    public int LineCount => EndLine - StartLine + 1;

    /// <summary>
    /// Character length of the content.
    /// </summary>
    /// <remarks>
    /// Convenience property equivalent to Content.Length. Used for quick
    /// size estimation and validation.
    /// </remarks>
    public int Length => Content.Length;

    /// <summary>
    /// Create a location string for display (file:line).
    /// </summary>
    /// <remarks>
    /// <para>
    /// Produces a human-readable location string suitable for display in UI
    /// or log output. Single-line chunks show "file:line", multi-line chunks
    /// show "file:startLine-endLine".
    /// </para>
    /// <para>
    /// Examples:
    /// <list type="bullet">
    /// <item><c>src/Models/TextChunk.cs:42</c></item>
    /// <item><c>src/Models/TextChunk.cs:42-58</c></item>
    /// </list>
    /// </para>
    /// </remarks>
    public string LocationString => StartLine == EndLine
        ? $"{FilePath}:{StartLine}"
        : $"{FilePath}:{StartLine}-{EndLine}";

    /// <summary>
    /// Create a copy with updated content (for preprocessing).
    /// </summary>
    /// <param name="newContent">The new content string.</param>
    /// <returns>A new TextChunk with the updated content and all other properties preserved.</returns>
    /// <remarks>
    /// <para>
    /// This method is used during preprocessing to create modified versions of chunks
    /// while preserving all metadata. The original chunk remains unchanged due to the
    /// immutable design.
    /// </para>
    /// <para>
    /// Note that TokenCount is preserved from the original chunk and may not accurately
    /// reflect the new content. Re-tokenization may be needed if the content changed
    /// significantly.
    /// </para>
    /// </remarks>
    public TextChunk WithContent(string newContent) => new()
    {
        Id = Id,
        Content = newContent,
        FilePath = FilePath,
        AbsolutePath = AbsolutePath,
        StartLine = StartLine,
        EndLine = EndLine,
        StartOffset = StartOffset,
        EndOffset = EndOffset,
        Type = Type,
        Language = Language,
        SymbolName = SymbolName,
        SymbolType = SymbolType,
        QualifiedName = QualifiedName,
        ParentSymbol = ParentSymbol,
        Namespace = Namespace,
        TokenCount = TokenCount,
        SequenceNumber = SequenceNumber,
        HasOverlap = HasOverlap,
        Summary = Summary,
        Tags = Tags,
        Metadata = Metadata
    };
}
```

### File: `src/AIntern.Core/Models/ChunkType.cs`

```csharp
namespace AIntern.Core.Models;

/// <summary>
/// Types of content that can be chunked.
/// </summary>
/// <remarks>
/// <para>
/// ChunkType categorizes the nature of content within a <see cref="TextChunk"/>.
/// This classification enables:
/// </para>
/// <list type="bullet">
/// <item>Filtering chunks during retrieval (e.g., "only return code chunks")</item>
/// <item>Applying different chunking strategies based on content type</item>
/// <item>Prioritizing certain content types in search results</item>
/// <item>Generating appropriate prompts when presenting chunks to the LLM</item>
/// </list>
/// </remarks>
public enum ChunkType
{
    /// <summary>
    /// Executable code (functions, methods, etc.).
    /// </summary>
    /// <remarks>
    /// Primary code content that can be executed or compiled. Includes function
    /// bodies, class implementations, and standalone statements.
    /// </remarks>
    Code,

    /// <summary>
    /// Code comments (single-line or block).
    /// </summary>
    /// <remarks>
    /// Comments within code files that are not documentation strings.
    /// Includes // comments, /* */ blocks, and # comments in scripts.
    /// </remarks>
    Comment,

    /// <summary>
    /// Documentation (docstrings, XML docs, JSDoc, etc.).
    /// </summary>
    /// <remarks>
    /// Structured documentation attached to code symbols. Includes:
    /// <list type="bullet">
    /// <item>C# XML documentation comments (/// summary)</item>
    /// <item>Python docstrings ("""...""")</item>
    /// <item>JavaScript/TypeScript JSDoc (/** ... */)</item>
    /// <item>Java Javadoc</item>
    /// </list>
    /// </remarks>
    Documentation,

    /// <summary>
    /// Markdown content.
    /// </summary>
    /// <remarks>
    /// Content from .md files including README, documentation, and notes.
    /// May be chunked differently to preserve heading structure.
    /// </remarks>
    Markdown,

    /// <summary>
    /// Plain text content.
    /// </summary>
    /// <remarks>
    /// Unstructured text files (.txt) or content that doesn't fit other categories.
    /// Chunked by paragraph or sentence boundaries.
    /// </remarks>
    PlainText,

    /// <summary>
    /// Configuration files (JSON, YAML, XML, etc.).
    /// </summary>
    /// <remarks>
    /// Structured configuration content. Includes:
    /// <list type="bullet">
    /// <item>JSON configuration files</item>
    /// <item>YAML/YML files</item>
    /// <item>XML configuration</item>
    /// <item>TOML files</item>
    /// <item>.env files</item>
    /// </list>
    /// </remarks>
    Config,

    /// <summary>
    /// Mixed content (code with inline comments).
    /// </summary>
    /// <remarks>
    /// Chunks that contain both executable code and comments interleaved.
    /// Used when chunking preserves context by keeping comments with their
    /// associated code.
    /// </remarks>
    Mixed,

    /// <summary>
    /// Import/using statements.
    /// </summary>
    /// <remarks>
    /// Module import declarations at the top of files. Includes:
    /// <list type="bullet">
    /// <item>C# using statements</item>
    /// <item>Python import/from statements</item>
    /// <item>JavaScript/TypeScript import statements</item>
    /// <item>Java import statements</item>
    /// </list>
    /// </remarks>
    Import,

    /// <summary>
    /// Type definitions (classes, interfaces, etc.).
    /// </summary>
    /// <remarks>
    /// Chunks representing complete type definitions without their member
    /// implementations. Used when <see cref="ChunkingOptions.ExtractSymbols"/>
    /// creates separate chunks for type signatures.
    /// </remarks>
    TypeDefinition,

    /// <summary>
    /// Test code.
    /// </summary>
    /// <remarks>
    /// Code identified as test code based on file location (test directories),
    /// naming conventions (*Test.cs, *_test.py), or test framework attributes/decorators.
    /// </remarks>
    Test
}

/// <summary>
/// Types of code symbols.
/// </summary>
/// <remarks>
/// <para>
/// SymbolType provides fine-grained classification of code constructs within a
/// <see cref="TextChunk"/>. This enables:
/// </para>
/// <list type="bullet">
/// <item>Precise filtering (e.g., "find all async methods")</item>
/// <item>Building code navigation and symbol tables</item>
/// <item>Understanding code structure for semantic chunking</item>
/// <item>Generating accurate code summaries</item>
/// </list>
/// <para>
/// The enum covers symbols across multiple programming paradigms:
/// object-oriented, functional, and procedural.
/// </para>
/// </remarks>
public enum SymbolType
{
    /// <summary>
    /// Namespace declaration.
    /// </summary>
    /// <remarks>
    /// Namespace or package declarations. In C#: <c>namespace Foo.Bar;</c>
    /// In Java: <c>package foo.bar;</c>
    /// </remarks>
    Namespace,

    /// <summary>
    /// Class definition.
    /// </summary>
    /// <remarks>
    /// Class declarations in object-oriented languages. Includes abstract classes,
    /// sealed classes, partial classes, and generic classes.
    /// </remarks>
    Class,

    /// <summary>
    /// Struct/record definition.
    /// </summary>
    /// <remarks>
    /// Value types and record types. In C#: <c>struct</c>, <c>record</c>,
    /// <c>record struct</c>. In Rust: <c>struct</c>.
    /// </remarks>
    Struct,

    /// <summary>
    /// Interface definition.
    /// </summary>
    /// <remarks>
    /// Interface contracts. In C#/Java: <c>interface</c>. In TypeScript: <c>interface</c>.
    /// In Go: implicitly defined by method sets.
    /// </remarks>
    Interface,

    /// <summary>
    /// Enum definition.
    /// </summary>
    /// <remarks>
    /// Enumeration type definitions. Includes C# enums, Java enums,
    /// TypeScript enums, and Rust enums.
    /// </remarks>
    Enum,

    /// <summary>
    /// Method definition (in a class/struct).
    /// </summary>
    /// <remarks>
    /// Instance or static methods that belong to a type. Distinguished from
    /// <see cref="Function"/> by membership in a class/struct/interface.
    /// </remarks>
    Method,

    /// <summary>
    /// Standalone function.
    /// </summary>
    /// <remarks>
    /// Functions not attached to a type. Common in Python, JavaScript,
    /// Go, Rust, and C. In C#, refers to local functions.
    /// </remarks>
    Function,

    /// <summary>
    /// Property definition.
    /// </summary>
    /// <remarks>
    /// Property accessors in C#, TypeScript, Python (@property), and Kotlin.
    /// Includes auto-properties, computed properties, and property with backing fields.
    /// </remarks>
    Property,

    /// <summary>
    /// Field definition.
    /// </summary>
    /// <remarks>
    /// Member variables of a type. Includes instance fields, static fields,
    /// and readonly fields.
    /// </remarks>
    Field,

    /// <summary>
    /// Constructor.
    /// </summary>
    /// <remarks>
    /// Type constructors including parameterless, parameterized, static constructors,
    /// and primary constructors (C# records, Kotlin).
    /// </remarks>
    Constructor,

    /// <summary>
    /// Destructor/finalizer.
    /// </summary>
    /// <remarks>
    /// Cleanup code executed during object finalization. In C#: <c>~ClassName()</c>.
    /// In C++: <c>~ClassName()</c>. In Python: <c>__del__</c>.
    /// </remarks>
    Destructor,

    /// <summary>
    /// Event definition.
    /// </summary>
    /// <remarks>
    /// Event declarations in C#. Also covers EventEmitter patterns in JavaScript
    /// and signal/slot mechanisms.
    /// </remarks>
    Event,

    /// <summary>
    /// Delegate type.
    /// </summary>
    /// <remarks>
    /// Type-safe function pointer definitions. Primarily C# delegates.
    /// Also covers function types in TypeScript and callback types in other languages.
    /// </remarks>
    Delegate,

    /// <summary>
    /// Operator overload.
    /// </summary>
    /// <remarks>
    /// Custom operator implementations. In C#: <c>operator +</c>, <c>implicit operator</c>.
    /// In Python: <c>__add__</c>, <c>__eq__</c>. In Rust: trait implementations.
    /// </remarks>
    Operator,

    /// <summary>
    /// Indexer.
    /// </summary>
    /// <remarks>
    /// Index accessor definitions. In C#: <c>this[int index]</c>.
    /// In Python: <c>__getitem__</c>/<c>__setitem__</c>.
    /// </remarks>
    Indexer,

    /// <summary>
    /// Import/using statement.
    /// </summary>
    /// <remarks>
    /// Module import declarations treated as symbols. Enables tracking
    /// dependencies and understanding module relationships.
    /// </remarks>
    Import,

    /// <summary>
    /// Constant definition.
    /// </summary>
    /// <remarks>
    /// Compile-time constant values. In C#: <c>const</c>. In Java: <c>static final</c>.
    /// In JavaScript/TypeScript: <c>const</c> with primitive values.
    /// </remarks>
    Constant,

    /// <summary>
    /// Type alias.
    /// </summary>
    /// <remarks>
    /// Type alias or typedef declarations. In C#: <c>using Alias = Type;</c>.
    /// In TypeScript: <c>type Alias = ...</c>. In Rust: <c>type Alias = ...</c>.
    /// </remarks>
    TypeAlias,

    /// <summary>
    /// Module (JS/TS/Python).
    /// </summary>
    /// <remarks>
    /// Module-level symbol representing the file/module itself. Used when
    /// chunking treats an entire module as a symbol for navigation purposes.
    /// </remarks>
    Module,

    /// <summary>
    /// Lambda/closure.
    /// </summary>
    /// <remarks>
    /// Anonymous functions and closures. In C#: <c>x => x + 1</c>.
    /// In JavaScript: arrow functions and function expressions.
    /// In Python: lambda expressions.
    /// </remarks>
    Lambda,

    /// <summary>
    /// Unknown or unclassified symbol.
    /// </summary>
    /// <remarks>
    /// Fallback for symbols that don't fit other categories. Used when
    /// parsing encounters an unrecognized construct or when language-specific
    /// features lack a specific enum value.
    /// </remarks>
    Other
}
```

### File: `src/AIntern.Core/Models/ChunkingOptions.cs`

```csharp
using System.Collections.Generic;

namespace AIntern.Core.Models;

/// <summary>
/// Configuration options for text chunking.
/// </summary>
/// <remarks>
/// <para>
/// ChunkingOptions controls how documents are split into <see cref="TextChunk"/> instances.
/// The default values are optimized for code embedding with common embedding models
/// that have 512-token context windows.
/// </para>
/// <para>
/// Key considerations when configuring:
/// </para>
/// <list type="bullet">
/// <item><b>Token Limits</b>: Most embedding models have a maximum input length (typically 512 tokens).
/// <see cref="MaxChunkSize"/> should stay within this limit.</item>
/// <item><b>Semantic Coherence</b>: <see cref="UseSemanticChunking"/> preserves code structure
/// (functions, classes) as single chunks when possible.</item>
/// <item><b>Context Overlap</b>: <see cref="ChunkOverlap"/> ensures important context
/// isn't lost at chunk boundaries.</item>
/// <item><b>Retrieval Quality</b>: Smaller chunks improve retrieval precision but may lose context.
/// Larger chunks provide more context but may dilute relevance signals.</item>
/// </list>
/// </remarks>
public sealed class ChunkingOptions
{
    /// <summary>
    /// Target chunk size in tokens (approximate).
    /// The chunker will try to create chunks close to this size.
    /// </summary>
    /// <remarks>
    /// <para>
    /// The chunking service attempts to create chunks of approximately this size.
    /// Actual chunk sizes may vary due to:
    /// </para>
    /// <list type="bullet">
    /// <item>Semantic boundaries (function ends, paragraph breaks)</item>
    /// <item>Minimum size constraints (<see cref="MinChunkSize"/>)</item>
    /// <item>Maximum size limits (<see cref="MaxChunkSize"/>)</item>
    /// <item>Code structure preservation (<see cref="PreserveFunctionBodies"/>)</item>
    /// </list>
    /// <para>
    /// Default value of 512 aligns with common embedding model context windows
    /// (BERT-based models, sentence-transformers).
    /// </para>
    /// </remarks>
    public int TargetChunkSize { get; init; } = 512;

    /// <summary>
    /// Number of tokens to overlap between consecutive chunks.
    /// Overlap helps maintain context across chunk boundaries.
    /// </summary>
    /// <remarks>
    /// <para>
    /// When chunking sequentially, this many tokens from the end of one chunk
    /// are included at the beginning of the next chunk. This ensures:
    /// </para>
    /// <list type="bullet">
    /// <item>Context continuity across boundaries</item>
    /// <item>Better retrieval when relevant content spans chunk boundaries</item>
    /// <item>Reduced information loss from arbitrary splits</item>
    /// </list>
    /// <para>
    /// Trade-off: Higher overlap increases storage and embedding costs.
    /// Default of 64 tokens (12.5% of target size) balances context preservation
    /// with efficiency.
    /// </para>
    /// </remarks>
    public int ChunkOverlap { get; init; } = 64;

    /// <summary>
    /// Minimum chunk size in tokens.
    /// Chunks smaller than this will be merged or discarded.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Very small chunks often lack sufficient context for meaningful embedding.
    /// Chunks below this threshold are:
    /// </para>
    /// <list type="bullet">
    /// <item>Merged with adjacent chunks if possible</item>
    /// <item>Discarded if they cannot be merged and contain only whitespace/trivial content</item>
    /// </list>
    /// <para>
    /// Default of 50 tokens ensures chunks have enough content to be useful
    /// in retrieval without being too noisy.
    /// </para>
    /// </remarks>
    public int MinChunkSize { get; init; } = 50;

    /// <summary>
    /// Maximum chunk size in tokens (hard limit).
    /// Chunks will be split if they exceed this size.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Hard upper limit enforced regardless of semantic boundaries.
    /// Content exceeding this limit is split at the nearest appropriate boundary.
    /// </para>
    /// <para>
    /// This should not exceed the embedding model's maximum input length.
    /// Default of 1024 provides headroom above typical 512-token model limits
    /// for occasional larger semantic units while ensuring content fits
    /// in 2048-token models.
    /// </para>
    /// </remarks>
    public int MaxChunkSize { get; init; } = 1024;

    /// <summary>
    /// Whether to include file path in chunk metadata.
    /// </summary>
    /// <remarks>
    /// When true, the <see cref="TextChunk.FilePath"/> property is populated.
    /// Useful for filtering, navigation, and providing context in retrieval results.
    /// </remarks>
    public bool IncludeFilePath { get; init; } = true;

    /// <summary>
    /// Whether to include line numbers in chunk metadata.
    /// </summary>
    /// <remarks>
    /// When true, <see cref="TextChunk.StartLine"/> and <see cref="TextChunk.EndLine"/>
    /// are populated. Enables navigation to specific locations and provides
    /// context about chunk position within the file.
    /// </remarks>
    public bool IncludeLineNumbers { get; init; } = true;

    /// <summary>
    /// Whether to use semantic chunking (by code structure) when possible.
    /// Falls back to line-based chunking for unknown languages.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Semantic chunking respects code structure:
    /// </para>
    /// <list type="bullet">
    /// <item>Functions/methods as atomic units</item>
    /// <item>Classes with their members</item>
    /// <item>Logical sections based on blank lines and indentation</item>
    /// </list>
    /// <para>
    /// When disabled or unavailable (unknown language), falls back to
    /// line-based chunking that splits at line boundaries based on token count.
    /// </para>
    /// </remarks>
    public bool UseSemanticChunking { get; init; } = true;

    /// <summary>
    /// Whether to extract and index symbol names separately.
    /// </summary>
    /// <remarks>
    /// <para>
    /// When enabled, the chunking service extracts code symbols and populates:
    /// </para>
    /// <list type="bullet">
    /// <item><see cref="TextChunk.SymbolName"/></item>
    /// <item><see cref="TextChunk.SymbolType"/></item>
    /// <item><see cref="TextChunk.QualifiedName"/></item>
    /// <item><see cref="TextChunk.ParentSymbol"/></item>
    /// <item><see cref="TextChunk.Namespace"/></item>
    /// </list>
    /// <para>
    /// Enables symbol-based search and navigation features.
    /// </para>
    /// </remarks>
    public bool ExtractSymbols { get; init; } = true;

    /// <summary>
    /// Whether to preserve full method/function bodies in single chunks.
    /// If false, large functions will be split.
    /// </summary>
    /// <remarks>
    /// <para>
    /// When true, functions smaller than <see cref="MaxChunkSize"/> are kept as
    /// single chunks even if they exceed <see cref="TargetChunkSize"/>.
    /// </para>
    /// <para>
    /// Trade-offs:
    /// </para>
    /// <list type="bullet">
    /// <item><b>True</b>: Better semantic coherence, complete function context,
    /// but potentially larger chunks</item>
    /// <item><b>False</b>: More uniform chunk sizes, but functions may be split
    /// mid-logic</item>
    /// </list>
    /// </remarks>
    public bool PreserveFunctionBodies { get; init; } = true;

    /// <summary>
    /// Whether to include documentation/comments with code.
    /// </summary>
    /// <remarks>
    /// When true, documentation comments (XML docs, docstrings, JSDoc) are
    /// included in the same chunk as the code they document. This provides
    /// richer context for understanding the code's purpose.
    /// </remarks>
    public bool IncludeDocumentation { get; init; } = true;

    /// <summary>
    /// Whether to create separate chunks for comments/docs.
    /// </summary>
    /// <remarks>
    /// <para>
    /// When true, documentation and comments are extracted into separate
    /// <see cref="TextChunk"/> instances with <see cref="ChunkType.Documentation"/>
    /// or <see cref="ChunkType.Comment"/> types.
    /// </para>
    /// <para>
    /// This enables independent retrieval of documentation, which can be useful
    /// when answering "what does X do?" questions without needing the implementation.
    /// </para>
    /// <para>
    /// Note: This setting is independent of <see cref="IncludeDocumentation"/>.
    /// Both can be true to include docs with code AND create separate doc chunks.
    /// </para>
    /// </remarks>
    public bool SeparateDocumentationChunks { get; init; } = false;

    /// <summary>
    /// Preprocessing steps to apply to text before chunking.
    /// </summary>
    /// <remarks>
    /// Preprocessing normalizes content before chunking to improve embedding
    /// quality and reduce noise. See <see cref="ChunkPreprocessing"/> for
    /// available options.
    /// </remarks>
    public ChunkPreprocessing Preprocessing { get; init; } = ChunkPreprocessing.Default;

    /// <summary>
    /// File patterns to include (if using glob patterns).
    /// </summary>
    /// <remarks>
    /// <para>
    /// Glob patterns specifying which files to chunk. Examples:
    /// </para>
    /// <list type="bullet">
    /// <item><c>**/*.cs</c> - All C# files</item>
    /// <item><c>src/**/*.ts</c> - TypeScript files in src directory</item>
    /// <item><c>*.md</c> - Markdown files in root only</item>
    /// </list>
    /// <para>
    /// When null, all files in the target directory are considered
    /// (subject to <see cref="ExcludePatterns"/>).
    /// </para>
    /// </remarks>
    public IReadOnlyList<string>? IncludePatterns { get; init; }

    /// <summary>
    /// File patterns to exclude.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Glob patterns specifying files to skip. Applied after <see cref="IncludePatterns"/>.
    /// Common exclusions:
    /// </para>
    /// <list type="bullet">
    /// <item><c>**/bin/**</c> - Build output</item>
    /// <item><c>**/obj/**</c> - Intermediate files</item>
    /// <item><c>**/node_modules/**</c> - NPM packages</item>
    /// <item><c>**/*.min.js</c> - Minified files</item>
    /// <item><c>**/packages/**</c> - NuGet packages</item>
    /// </list>
    /// </remarks>
    public IReadOnlyList<string>? ExcludePatterns { get; init; }
}

/// <summary>
/// Text preprocessing options.
/// </summary>
/// <remarks>
/// <para>
/// ChunkPreprocessing defines transformations applied to text content before
/// chunking. Preprocessing helps:
/// </para>
/// <list type="bullet">
/// <item>Normalize whitespace for consistent tokenization</item>
/// <item>Remove boilerplate content (license headers) that adds noise</item>
/// <item>Reduce redundant whitespace that wastes tokens</item>
/// </list>
/// <para>
/// Use <see cref="Default"/> for common preprocessing settings suitable
/// for most codebases.
/// </para>
/// </remarks>
public sealed class ChunkPreprocessing
{
    /// <summary>
    /// Default preprocessing settings.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Provides sensible defaults for code preprocessing:
    /// </para>
    /// <list type="bullet">
    /// <item>Normalizes whitespace (tabs to spaces)</item>
    /// <item>Preserves empty lines but collapses excessive sequences</item>
    /// <item>Trims trailing whitespace from lines</item>
    /// <item>Removes license headers that add noise</item>
    /// </list>
    /// </remarks>
    public static ChunkPreprocessing Default { get; } = new()
    {
        NormalizeWhitespace = true,
        RemoveEmptyLines = false,
        CollapseMultipleNewlines = true,
        TrimLines = true,
        RemoveLicenseHeaders = true,
        MaxConsecutiveEmptyLines = 2
    };

    /// <summary>
    /// Whether to normalize whitespace (tabs to spaces, etc.).
    /// </summary>
    /// <remarks>
    /// <para>
    /// When true, normalizes various whitespace characters:
    /// </para>
    /// <list type="bullet">
    /// <item>Tabs converted to spaces (configurable width)</item>
    /// <item>Non-breaking spaces to regular spaces</item>
    /// <item>Windows line endings (CRLF) to Unix (LF)</item>
    /// </list>
    /// <para>
    /// Normalization ensures consistent tokenization regardless of editor settings.
    /// </para>
    /// </remarks>
    public bool NormalizeWhitespace { get; init; }

    /// <summary>
    /// Whether to remove empty lines entirely.
    /// </summary>
    /// <remarks>
    /// <para>
    /// When true, all empty lines (lines with only whitespace) are removed.
    /// This can significantly reduce token count but may lose meaningful
    /// visual structure in the code.
    /// </para>
    /// <para>
    /// Consider using <see cref="CollapseMultipleNewlines"/> instead for
    /// a less aggressive approach.
    /// </para>
    /// </remarks>
    public bool RemoveEmptyLines { get; init; }

    /// <summary>
    /// Whether to collapse multiple consecutive newlines.
    /// </summary>
    /// <remarks>
    /// When true, sequences of empty lines are reduced to at most
    /// <see cref="MaxConsecutiveEmptyLines"/> empty lines. Preserves
    /// visual structure while eliminating excessive whitespace.
    /// </remarks>
    public bool CollapseMultipleNewlines { get; init; }

    /// <summary>
    /// Whether to trim leading/trailing whitespace from lines.
    /// </summary>
    /// <remarks>
    /// <para>
    /// When true, removes:
    /// </para>
    /// <list type="bullet">
    /// <item>Trailing whitespace from all lines</item>
    /// <item>Leading whitespace only from completely blank lines</item>
    /// </list>
    /// <para>
    /// Note: Indentation is preserved for code structure. Only truly trailing
    /// spaces (after content) and leading spaces on empty lines are trimmed.
    /// </para>
    /// </remarks>
    public bool TrimLines { get; init; }

    /// <summary>
    /// Whether to remove license/copyright headers.
    /// </summary>
    /// <remarks>
    /// <para>
    /// When true, attempts to detect and remove license headers at the
    /// beginning of files. Detection patterns include:
    /// </para>
    /// <list type="bullet">
    /// <item>Block comments containing "license", "copyright", "MIT", "Apache", etc.</item>
    /// <item>Shebang lines followed by license text</item>
    /// <item>Standard license header formats</item>
    /// </list>
    /// <para>
    /// License headers are typically identical across files and add noise
    /// without providing useful semantic information for retrieval.
    /// </para>
    /// </remarks>
    public bool RemoveLicenseHeaders { get; init; }

    /// <summary>
    /// Maximum consecutive empty lines to allow.
    /// </summary>
    /// <remarks>
    /// Used when <see cref="CollapseMultipleNewlines"/> is true. Sequences
    /// of more than this many empty lines are collapsed to this limit.
    /// Default of 2 preserves visual separation between major code sections.
    /// </remarks>
    public int MaxConsecutiveEmptyLines { get; init; }
}
```

---

## Usage Examples

### Creating a TextChunk

```csharp
// Creating a chunk from code analysis
var chunk = new TextChunk
{
    Content = @"public int Add(int a, int b)
{
    return a + b;
}",
    FilePath = "src/Math/Calculator.cs",
    AbsolutePath = "/workspace/src/Math/Calculator.cs",
    StartLine = 15,
    EndLine = 18,
    StartOffset = 342,
    EndOffset = 396,
    Type = ChunkType.Code,
    Language = "csharp",
    SymbolName = "Add",
    SymbolType = SymbolType.Method,
    QualifiedName = "AIntern.Math.Calculator.Add",
    ParentSymbol = "Calculator",
    Namespace = "AIntern.Math",
    TokenCount = 28,
    SequenceNumber = 3,
    HasOverlap = false,
    Summary = "Adds two integers and returns the result.",
    Tags = new[] { "public", "pure-function" }
};

// Accessing computed properties
Console.WriteLine(chunk.LocationString);  // "src/Math/Calculator.cs:15-18"
Console.WriteLine(chunk.LineCount);       // 4
Console.WriteLine(chunk.Length);          // 54
```

### Using ChunkingOptions

```csharp
// Default options for code embedding
var defaultOptions = new ChunkingOptions();

// Custom options for documentation-heavy codebase
var docOptions = new ChunkingOptions
{
    TargetChunkSize = 384,
    ChunkOverlap = 48,
    SeparateDocumentationChunks = true,
    IncludeDocumentation = true,
    ExcludePatterns = new[]
    {
        "**/bin/**",
        "**/obj/**",
        "**/node_modules/**",
        "**/*.generated.cs"
    }
};

// Options for large functions
var largeFunctionOptions = new ChunkingOptions
{
    PreserveFunctionBodies = false,  // Allow splitting large functions
    MaxChunkSize = 768,
    TargetChunkSize = 512
};
```

### Custom Preprocessing

```csharp
// Minimal preprocessing (preserve original formatting)
var minimalPreprocessing = new ChunkPreprocessing
{
    NormalizeWhitespace = false,
    RemoveEmptyLines = false,
    CollapseMultipleNewlines = false,
    TrimLines = false,
    RemoveLicenseHeaders = false,
    MaxConsecutiveEmptyLines = int.MaxValue
};

// Aggressive preprocessing (minimize tokens)
var aggressivePreprocessing = new ChunkPreprocessing
{
    NormalizeWhitespace = true,
    RemoveEmptyLines = true,
    CollapseMultipleNewlines = true,
    TrimLines = true,
    RemoveLicenseHeaders = true,
    MaxConsecutiveEmptyLines = 1
};

var options = new ChunkingOptions
{
    Preprocessing = aggressivePreprocessing
};
```

### Using WithContent for Preprocessing

```csharp
var originalChunk = new TextChunk
{
    Content = "  function foo() {  \n    return 42;  \n  }  ",
    FilePath = "src/utils.js",
    StartLine = 10,
    EndLine = 12,
    TokenCount = 15
};

// Preprocess the content
var trimmedContent = originalChunk.Content
    .Replace("  ", " ")
    .Trim();

// Create modified copy preserving metadata
var preprocessedChunk = originalChunk.WithContent(trimmedContent);

// Original unchanged
Console.WriteLine(originalChunk.Content.Length);     // 44
Console.WriteLine(preprocessedChunk.Content.Length); // 32 (after trimming)
Console.WriteLine(preprocessedChunk.StartLine);      // 10 (preserved)
```

---

## Integration Points

### With Embedding Services (v0.7.1b/v0.7.1c)

```csharp
// TextChunk flows to embedding service
public async Task<float[]> EmbedChunkAsync(
    IEmbeddingService embeddingService,
    TextChunk chunk,
    CancellationToken ct = default)
{
    // Embedding service processes chunk content
    return await embeddingService.EmbedAsync(chunk.Content, ct);
}

// Batch embedding with progress
public async Task<IReadOnlyList<(TextChunk Chunk, float[] Embedding)>> EmbedChunksAsync(
    IEmbeddingService embeddingService,
    IReadOnlyList<TextChunk> chunks,
    IProgress<EmbeddingProgress>? progress = null,
    CancellationToken ct = default)
{
    var contents = chunks.Select(c => c.Content).ToList();
    var embeddings = await embeddingService.EmbedBatchAsync(contents, progress, ct);

    return chunks.Zip(embeddings, (chunk, embedding) => (chunk, embedding)).ToList();
}
```

### With Future Chunking Service (v0.7.1e)

```csharp
// Chunking service produces TextChunk instances
public interface IChunkingService
{
    IReadOnlyList<TextChunk> ChunkDocument(
        string content,
        string filePath,
        ChunkingOptions options);
}

// Usage
var service = new ChunkingService(logger, strategies);
var chunks = service.ChunkDocument(fileContent, "src/Program.cs", new ChunkingOptions());

foreach (var chunk in chunks)
{
    Console.WriteLine($"{chunk.LocationString}: {chunk.SymbolName ?? "(no symbol)"} ({chunk.Type})");
}
```

### With Vector Storage (Future)

```csharp
// Chunks stored with their embeddings
public class StoredChunk
{
    public Guid Id { get; init; }
    public TextChunk Chunk { get; init; }
    public float[] Embedding { get; init; }
    public DateTime IndexedAt { get; init; }
}

// Retrieval returns chunks
public interface IVectorStore
{
    Task<IReadOnlyList<(TextChunk Chunk, float Score)>> SearchAsync(
        float[] queryEmbedding,
        int topK = 10,
        ChunkType? typeFilter = null,
        CancellationToken ct = default);
}
```

---

## Testing Strategy

### Unit Tests

```csharp
public class TextChunkTests
{
    [Fact]
    public void LineCount_SingleLine_ReturnsOne()
    {
        var chunk = new TextChunk { StartLine = 10, EndLine = 10 };
        Assert.Equal(1, chunk.LineCount);
    }

    [Fact]
    public void LineCount_MultipleLines_ReturnsCorrectCount()
    {
        var chunk = new TextChunk { StartLine = 10, EndLine = 25 };
        Assert.Equal(16, chunk.LineCount);
    }

    [Fact]
    public void LocationString_SingleLine_FormatsCorrectly()
    {
        var chunk = new TextChunk { FilePath = "src/Foo.cs", StartLine = 42, EndLine = 42 };
        Assert.Equal("src/Foo.cs:42", chunk.LocationString);
    }

    [Fact]
    public void LocationString_MultipleLines_FormatsCorrectly()
    {
        var chunk = new TextChunk { FilePath = "src/Foo.cs", StartLine = 10, EndLine = 20 };
        Assert.Equal("src/Foo.cs:10-20", chunk.LocationString);
    }

    [Fact]
    public void Length_ReturnsContentLength()
    {
        var chunk = new TextChunk { Content = "Hello, World!" };
        Assert.Equal(13, chunk.Length);
    }

    [Fact]
    public void WithContent_PreservesAllMetadata()
    {
        var original = new TextChunk
        {
            Id = Guid.NewGuid(),
            Content = "original",
            FilePath = "test.cs",
            StartLine = 1,
            EndLine = 5,
            Type = ChunkType.Code,
            Language = "csharp",
            SymbolName = "Test",
            TokenCount = 10
        };

        var modified = original.WithContent("modified");

        Assert.Equal(original.Id, modified.Id);
        Assert.Equal("modified", modified.Content);
        Assert.Equal(original.FilePath, modified.FilePath);
        Assert.Equal(original.StartLine, modified.StartLine);
        Assert.Equal(original.Type, modified.Type);
        Assert.Equal(original.SymbolName, modified.SymbolName);
    }

    [Fact]
    public void Id_AutoGeneratedOnConstruction()
    {
        var chunk1 = new TextChunk();
        var chunk2 = new TextChunk();

        Assert.NotEqual(Guid.Empty, chunk1.Id);
        Assert.NotEqual(chunk1.Id, chunk2.Id);
    }
}

public class ChunkingOptionsTests
{
    [Fact]
    public void DefaultValues_AreReasonable()
    {
        var options = new ChunkingOptions();

        Assert.Equal(512, options.TargetChunkSize);
        Assert.Equal(64, options.ChunkOverlap);
        Assert.Equal(50, options.MinChunkSize);
        Assert.Equal(1024, options.MaxChunkSize);
        Assert.True(options.UseSemanticChunking);
        Assert.True(options.ExtractSymbols);
        Assert.True(options.PreserveFunctionBodies);
    }

    [Fact]
    public void Preprocessing_Default_HasExpectedSettings()
    {
        var preprocessing = ChunkPreprocessing.Default;

        Assert.True(preprocessing.NormalizeWhitespace);
        Assert.False(preprocessing.RemoveEmptyLines);
        Assert.True(preprocessing.CollapseMultipleNewlines);
        Assert.True(preprocessing.TrimLines);
        Assert.True(preprocessing.RemoveLicenseHeaders);
        Assert.Equal(2, preprocessing.MaxConsecutiveEmptyLines);
    }
}

public class ChunkTypeTests
{
    [Theory]
    [InlineData(ChunkType.Code)]
    [InlineData(ChunkType.Comment)]
    [InlineData(ChunkType.Documentation)]
    [InlineData(ChunkType.Markdown)]
    [InlineData(ChunkType.PlainText)]
    [InlineData(ChunkType.Config)]
    [InlineData(ChunkType.Mixed)]
    [InlineData(ChunkType.Import)]
    [InlineData(ChunkType.TypeDefinition)]
    [InlineData(ChunkType.Test)]
    public void AllChunkTypes_AreDefined(ChunkType type)
    {
        Assert.True(Enum.IsDefined(typeof(ChunkType), type));
    }
}

public class SymbolTypeTests
{
    [Fact]
    public void AllSymbolTypes_AreDefined()
    {
        var expectedTypes = new[]
        {
            SymbolType.Namespace, SymbolType.Class, SymbolType.Struct,
            SymbolType.Interface, SymbolType.Enum, SymbolType.Method,
            SymbolType.Function, SymbolType.Property, SymbolType.Field,
            SymbolType.Constructor, SymbolType.Destructor, SymbolType.Event,
            SymbolType.Delegate, SymbolType.Operator, SymbolType.Indexer,
            SymbolType.Import, SymbolType.Constant, SymbolType.TypeAlias,
            SymbolType.Module, SymbolType.Lambda, SymbolType.Other
        };

        foreach (var type in expectedTypes)
        {
            Assert.True(Enum.IsDefined(typeof(SymbolType), type));
        }
    }
}
```

---

## Acceptance Criteria

- [ ] TextChunk model contains all necessary properties for embedding and retrieval
- [ ] ChunkType enum covers all content types (Code, Comment, Documentation, Markdown, PlainText, Config, Mixed, Import, TypeDefinition, Test)
- [ ] SymbolType enum covers all code symbol types (21 values from Namespace to Other)
- [ ] ChunkingOptions provides comprehensive configuration for chunking behavior
- [ ] ChunkPreprocessing options defined with sensible defaults
- [ ] Helper properties (LineCount, Length, LocationString) compute correctly
- [ ] WithContent method creates proper copies preserving all metadata
- [ ] All models use init-only properties for immutability
- [ ] Comprehensive XML documentation on all public types and members
- [ ] Unit tests validate all computed properties and edge cases

---

## Version History

| Version | Date | Changes |
|---------|------|---------|
| v0.7.1d | TBD | Initial text chunk model definitions |
