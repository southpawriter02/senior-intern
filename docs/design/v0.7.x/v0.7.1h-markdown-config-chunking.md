# Design Specification: AIntern v0.7.1h "Markdown & Config File Chunking"

## Overview

**Version**: v0.7.1h
**Parent**: v0.7.1 Embedding Foundation
**Focus**: Complete document chunking strategies for Markdown, plain text, and configuration files

### Purpose

This version consolidates and extends the document chunking strategies:
1. Ensure `MarkdownChunkingStrategy` (from v0.7.1g) splits by headings correctly
2. Ensure `PlainTextChunkingStrategy` (from v0.7.1g) handles generic text
3. Create `ConfigFileChunkingStrategy` for JSON, YAML, XML, TOML, INI, ENV files
4. Maintain overlap between chunks for context preservation
5. Ensure all strategies use token estimation for accurate sizing

### Dependencies

**From v0.7.1g (Language-Specific Chunkers)**:
- `MarkdownChunkingStrategy` class (already implemented)
- `PlainTextChunkingStrategy` class (already implemented)

**From v0.7.1e (Chunking Service Interface)**:
- `IChunkingStrategy` interface
- `IChunkingService` for token estimation

**From v0.7.1d (Text Chunk Models)**:
- `TextChunk` model
- `ChunkType` enum (includes `ChunkType.Config`)
- `ChunkingOptions` class

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│              v0.7.1h Config File Chunking Architecture                        │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Complete Document Chunking Strategy Set:                                    │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  Priority Order (for non-code files):                                   │ │
│  │                                                                          │ │
│  │  ┌───────────────────────────────┐                                      │ │
│  │  │ MarkdownChunkingStrategy      │  Priority: 150                       │ │
│  │  │ .md, .markdown, .mdx          │  Heading-based splitting             │ │
│  │  └───────────────────────────────┘                                      │ │
│  │                 ↓                                                        │ │
│  │  ┌───────────────────────────────┐                                      │ │
│  │  │ ConfigFileChunkingStrategy    │  Priority: 120  ← NEW                │ │
│  │  │ .json, .yaml, .yml, .xml      │  Preserve whole file if possible     │ │
│  │  │ .toml, .ini, .env             │                                       │ │
│  │  └───────────────────────────────┘                                      │ │
│  │                 ↓                                                        │ │
│  │  ┌───────────────────────────────┐                                      │ │
│  │  │ PlainTextChunkingStrategy     │  Priority: 0                         │ │
│  │  │ .txt, .text, .log             │  Universal fallback                  │ │
│  │  │ (+ ANY file type)             │                                       │ │
│  │  └───────────────────────────────┘                                      │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  ConfigFileChunkingStrategy Logic:                                           │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  Input: Config file content                                              │ │
│  │           │                                                              │ │
│  │           ↓                                                              │ │
│  │  ┌─────────────────────────────────────────────────────────────────────┐│ │
│  │  │ Estimate token count                                                 ││ │
│  │  └─────────────────────────────────────────────────────────────────────┘│ │
│  │           │                                                              │ │
│  │           ↓                                                              │ │
│  │  ┌─────────────────────────────────────────────────────────────────────┐│ │
│  │  │ IF tokenCount <= MaxChunkSize:                                       ││ │
│  │  │   → Return single chunk with entire file content                     ││ │
│  │  │   → Preserves structural integrity (JSON objects, YAML docs)         ││ │
│  │  └─────────────────────────────────────────────────────────────────────┘│ │
│  │           │                                                              │ │
│  │           ↓ (only if too large)                                         │ │
│  │  ┌─────────────────────────────────────────────────────────────────────┐│ │
│  │  │ ELSE: ChunkByLines()                                                 ││ │
│  │  │   → Line-based chunking with token estimation                        ││ │
│  │  │   → Respects TargetChunkSize and MinChunkSize                        ││ │
│  │  └─────────────────────────────────────────────────────────────────────┘│ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Strategy Summary

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                  Document Strategy Summary (v0.7.1h)                          │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Strategy              │ Pri  │ Extensions            │ Chunking Logic       │
│  ──────────────────────│──────│───────────────────────│───────────────────── │
│  MarkdownChunking      │ 150  │ .md,.markdown,.mdx    │ By headings          │
│  ConfigFileChunking    │ 120  │ .json,.yaml,.yml,.xml │ Whole file OR lines  │
│                        │      │ .toml,.ini,.env       │                      │
│  PlainTextChunking     │ 0    │ .txt,.text,.log (ANY) │ Line-based + overlap │
│                                                                              │
│  Note: Language-specific strategies (C#, TypeScript, Python) have           │
│        Priority 200 and handle code files before these document strategies.  │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Config File Formats

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                      Supported Configuration Formats                          │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Format   │ Extension(s)  │ Description                 │ ChunkType          │
│  ─────────│───────────────│─────────────────────────────│─────────────────── │
│  JSON     │ .json         │ JavaScript Object Notation  │ Config             │
│  YAML     │ .yaml, .yml   │ YAML Ain't Markup Language  │ Config             │
│  XML      │ .xml          │ Extensible Markup Language  │ Config             │
│  TOML     │ .toml         │ Tom's Obvious Minimal Lang  │ Config             │
│  INI      │ .ini          │ Initialization files        │ Config             │
│  ENV      │ .env          │ Environment variables       │ Config             │
│                                                                              │
│  Design Philosophy:                                                          │
│  ──────────────────                                                          │
│  - Config files are usually small enough to fit in a single chunk           │
│  - Splitting JSON/YAML mid-object destroys structural meaning               │
│  - Prefer whole-file chunks when under MaxChunkSize                         │
│  - Fall back to line-based splitting only for very large configs            │
│  - Set Language to extension (e.g., "json", "yaml")                          │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Specifications

### 1. ConfigFileChunkingStrategy.cs

**Location**: `src/SeniorIntern.Services/Chunking/ConfigFileChunkingStrategy.cs`

```csharp
namespace SeniorIntern.Services.Chunking;

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;

/// <summary>
/// Chunking strategy for configuration files (JSON, YAML, XML, TOML, INI, ENV).
/// </summary>
/// <remarks>
/// <para>
/// Configuration files typically have structural meaning that spans the entire
/// file (e.g., a JSON object, a YAML document). This strategy prioritizes
/// keeping configuration files as single chunks when possible.
/// </para>
/// <para>
/// Strategy:
/// <list type="number">
///   <item>If file fits within MaxChunkSize tokens → single chunk</item>
///   <item>If file exceeds MaxChunkSize → fall back to line-based chunking</item>
/// </list>
/// </para>
/// <para>
/// The Language property is set to the file extension (e.g., "json", "yaml")
/// for downstream processing and syntax highlighting.
/// </para>
/// </remarks>
public sealed class ConfigFileChunkingStrategy : IChunkingStrategy
{
    private readonly ILogger<ConfigFileChunkingStrategy> _logger;
    private readonly IChunkingService _chunkingService;

    /// <summary>
    /// Supported configuration file extensions.
    /// </summary>
    private static readonly HashSet<string> _extensions = new(StringComparer.OrdinalIgnoreCase)
    {
        ".json",    // JSON - JavaScript Object Notation
        ".yaml",    // YAML - YAML Ain't Markup Language
        ".yml",     // YAML (alternate extension)
        ".xml",     // XML - Extensible Markup Language
        ".toml",    // TOML - Tom's Obvious Minimal Language
        ".ini",     // INI - Initialization files
        ".env"      // ENV - Environment variable files
    };

    #region Properties

    /// <inheritdoc />
    public string Name => "ConfigFile";

    /// <inheritdoc />
    public IReadOnlySet<string> SupportedExtensions => _extensions;

    /// <inheritdoc />
    public int Priority => 120; // Between Markdown (150) and PlainText (0)

    #endregion

    #region Constructor

    /// <summary>
    /// Initializes a new instance of the ConfigFileChunkingStrategy.
    /// </summary>
    /// <param name="logger">Logger instance.</param>
    /// <param name="chunkingService">Chunking service for token estimation.</param>
    public ConfigFileChunkingStrategy(
        ILogger<ConfigFileChunkingStrategy> logger,
        IChunkingService chunkingService)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _chunkingService = chunkingService ?? throw new ArgumentNullException(nameof(chunkingService));
    }

    #endregion

    #region IChunkingStrategy Implementation

    /// <inheritdoc />
    public bool CanHandle(string filePath)
    {
        var extension = Path.GetExtension(filePath);
        return SupportedExtensions.Contains(extension);
    }

    /// <inheritdoc />
    public IReadOnlyList<TextChunk> Chunk(
        string content,
        string filePath,
        ChunkingOptions options)
    {
        ArgumentNullException.ThrowIfNull(content);
        ArgumentNullException.ThrowIfNull(filePath);
        ArgumentNullException.ThrowIfNull(options);

        if (string.IsNullOrEmpty(content))
        {
            _logger.LogDebug("Empty config file: {File}", filePath);
            return Array.Empty<TextChunk>();
        }

        var tokenCount = _chunkingService.EstimateTokenCount(content);
        var extension = Path.GetExtension(filePath).TrimStart('.').ToLowerInvariant();

        _logger.LogDebug(
            "Config file {File}: {Tokens} tokens (max: {Max})",
            filePath, tokenCount, options.MaxChunkSize);

        // Strategy: Keep config files as single chunks when possible
        // This preserves structural integrity (JSON objects, YAML documents, etc.)
        if (tokenCount <= options.MaxChunkSize)
        {
            return CreateSingleChunk(content, filePath, extension, tokenCount);
        }

        // File too large - fall back to line-based chunking
        _logger.LogDebug(
            "Config file {File} exceeds max size, using line-based chunking",
            filePath);

        return ChunkByLines(content, filePath, extension, options);
    }

    #endregion

    #region Private Methods

    /// <summary>
    /// Create a single chunk containing the entire file.
    /// </summary>
    private static IReadOnlyList<TextChunk> CreateSingleChunk(
        string content,
        string filePath,
        string language,
        int tokenCount)
    {
        var lineCount = content.Count(c => c == '\n') + 1;

        return new[]
        {
            new TextChunk
            {
                Content = content,
                FilePath = filePath,
                StartLine = 1,
                EndLine = lineCount,
                StartOffset = 0,
                EndOffset = content.Length,
                Type = ChunkType.Config,
                Language = language,
                TokenCount = tokenCount,
                SequenceNumber = 0
            }
        };
    }

    /// <summary>
    /// Chunk large config files by lines.
    /// </summary>
    private IReadOnlyList<TextChunk> ChunkByLines(
        string content,
        string filePath,
        string language,
        ChunkingOptions options)
    {
        var chunks = new List<TextChunk>();
        var lines = content.Split('\n');
        var currentChunk = new StringBuilder();
        var startLine = 1;
        var startOffset = 0;
        var currentOffset = 0;
        var currentTokens = 0;
        var sequenceNumber = 0;
        var lineNumber = 0;

        foreach (var line in lines)
        {
            lineNumber++;
            var lineTokens = _chunkingService.EstimateTokenCount(line);

            // Check if adding this line would exceed target size
            if (currentTokens + lineTokens > options.TargetChunkSize && currentChunk.Length > 0)
            {
                // Emit current chunk
                var chunkContent = currentChunk.ToString().TrimEnd();
                var chunkLineCount = chunkContent.Count(c => c == '\n') + 1;

                chunks.Add(new TextChunk
                {
                    Content = chunkContent,
                    FilePath = filePath,
                    StartLine = startLine,
                    EndLine = startLine + chunkLineCount - 1,
                    StartOffset = startOffset,
                    EndOffset = currentOffset,
                    Type = ChunkType.Config,
                    Language = language,
                    TokenCount = currentTokens,
                    SequenceNumber = sequenceNumber++
                });

                // Reset for new chunk
                currentChunk.Clear();
                startLine = lineNumber;
                startOffset = currentOffset;
                currentTokens = 0;
            }

            // Append line to current chunk
            currentChunk.AppendLine(line);
            currentOffset += line.Length + 1;
            currentTokens += lineTokens;
        }

        // Emit final chunk if it meets minimum size
        if (currentChunk.Length > 0 && currentTokens >= options.MinChunkSize)
        {
            var chunkContent = currentChunk.ToString().TrimEnd();

            chunks.Add(new TextChunk
            {
                Content = chunkContent,
                FilePath = filePath,
                StartLine = startLine,
                EndLine = lines.Length,
                StartOffset = startOffset,
                EndOffset = content.Length,
                Type = ChunkType.Config,
                Language = language,
                TokenCount = currentTokens,
                SequenceNumber = sequenceNumber
            });
        }

        _logger.LogDebug(
            "Config file {File} chunked into {Count} chunks",
            filePath, chunks.Count);

        return chunks;
    }

    #endregion
}
```

---

## Updated DI Registration

The DI registration from v0.7.1f should be updated to include the ConfigFileChunkingStrategy:

```csharp
/// <summary>
/// Add all chunking services and strategies to the service collection.
/// </summary>
public static IServiceCollection AddChunkingServices(this IServiceCollection services)
{
    // Register main chunking service
    services.AddSingleton<IChunkingService, ChunkingService>();

    // Register language-specific strategies (Priority 200)
    services.AddSingleton<IChunkingStrategy, CSharpChunkingStrategy>();
    services.AddSingleton<IChunkingStrategy, TypeScriptChunkingStrategy>();
    services.AddSingleton<IChunkingStrategy, PythonChunkingStrategy>();

    // Register document strategies
    services.AddSingleton<IChunkingStrategy, MarkdownChunkingStrategy>();      // Priority 150
    services.AddSingleton<IChunkingStrategy, ConfigFileChunkingStrategy>();     // Priority 120 ← NEW
    
    // Register base strategies
    services.AddSingleton<IChunkingStrategy, CodeAwareChunkingStrategy>();      // Priority 100
    services.AddSingleton<IChunkingStrategy, PlainTextChunkingStrategy>();      // Priority 0

    return services;
}
```

---

## Chunking Strategy Priority Summary

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                     Complete Strategy Priority Table                          │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Priority │ Strategy                    │ Extensions                         │
│  ─────────│─────────────────────────────│─────────────────────────────────── │
│  200      │ CSharpChunkingStrategy      │ .cs                                │
│  200      │ TypeScriptChunkingStrategy  │ .ts,.tsx,.js,.jsx,.mjs             │
│  200      │ PythonChunkingStrategy      │ .py,.pyi                           │
│  150      │ MarkdownChunkingStrategy    │ .md,.markdown,.mdx                 │
│  120      │ ConfigFileChunkingStrategy  │ .json,.yaml,.yml,.xml,.toml,.ini,.env│
│  100      │ CodeAwareChunkingStrategy   │ .cs,.fs,.vb,.ts,.tsx,.js,.jsx,.py, │
│           │                             │ .java,.kt,.go,.rs,.cpp,.hpp,...    │
│  0        │ PlainTextChunkingStrategy   │ .txt,.text,.log (+ ANY)            │
│                                                                              │
│  Resolution Order:                                                           │
│  1. Strategies are sorted by Priority (descending)                           │
│  2. First strategy where CanHandle(filePath) returns true is selected        │
│  3. PlainTextChunkingStrategy always returns true (universal fallback)       │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Config File Examples

### Example 1: Small JSON (Single Chunk)

**Input**: `config.json` (150 tokens)
```json
{
  "appSettings": {
    "theme": "dark",
    "language": "en-US",
    "autoSave": true
  }
}
```

**Output**: 1 chunk with entire file

### Example 2: Large YAML (Multiple Chunks)

**Input**: `kubernetes.yaml` (2000 tokens, MaxChunkSize = 1024)

**Output**: 2+ chunks, split by lines

### Example 3: Environment File

**Input**: `.env` (50 tokens)
```
DATABASE_URL=postgres://localhost/db
API_KEY=secret123
DEBUG=true
```

**Output**: 1 chunk with entire file

---

## Unit Test Plan

| Test | Description |
|------|-------------|
| `CanHandle_JsonFile_ReturnsTrue` | Extension matching |
| `CanHandle_YamlFile_ReturnsTrue` | .yaml and .yml |
| `CanHandle_XmlFile_ReturnsTrue` | XML extension |
| `CanHandle_TomlFile_ReturnsTrue` | TOML extension |
| `CanHandle_IniFile_ReturnsTrue` | INI extension |
| `CanHandle_EnvFile_ReturnsTrue` | .env extension |
| `CanHandle_CsFile_ReturnsFalse` | Code file excluded |
| `Chunk_SmallFile_SingleChunk` | Whole file preserved |
| `Chunk_LargeFile_MultipleChunks` | Falls back to lines |
| `Chunk_EmptyFile_EmptyList` | Edge case |
| `Chunk_SetsChunkTypeConfig` | ChunkType verification |
| `Chunk_SetsLanguageFromExtension` | Language property |
| `Chunk_RespectsTargetChunkSize` | Token sizing |
| `Chunk_RespectsMinChunkSize` | Minimum filtering |
| `ChunkByLines_CalculatesOffsetsCorrectly` | Offset tracking |

---

## File Summary

| File | Location | Purpose | Lines |
|------|----------|---------|-------|
| `ConfigFileChunkingStrategy.cs` | `Services/Chunking/` | Config file strategy | ~180 |

**Note**: MarkdownChunkingStrategy and PlainTextChunkingStrategy were already implemented in v0.7.1g.

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | MarkdownChunkingStrategy splits by headings (from v0.7.1g) |
| AC-2 | PlainTextChunkingStrategy handles generic text (from v0.7.1g) |
| AC-3 | ConfigFileChunkingStrategy preserves config files when possible |
| AC-4 | ConfigFileChunkingStrategy falls back to line-based for large files |
| AC-5 | Overlap maintained between chunks (PlainText) |
| AC-6 | All strategies use token estimation |
| AC-7 | ChunkType.Config used for config files |
| AC-8 | Language property set to file extension |

---

## Changelog Entry

```markdown
## v0.7.1h - Markdown & Config File Chunking

### Added
- `ConfigFileChunkingStrategy` (Priority 120)
  - Supported extensions: .json, .yaml, .yml, .xml, .toml, .ini, .env
  - Single-chunk strategy for small config files
  - Line-based fallback for large config files
  - Sets ChunkType.Config for all chunks
  - Sets Language to file extension (e.g., "json", "yaml")
  - Priority 120 (between Markdown and Code)

### Strategy Priority Order (Complete)
| Priority | Strategy | Purpose |
|----------|----------|---------|
| 200 | CSharp/TypeScript/Python | Language-specific code |
| 150 | Markdown | Documentation |
| 120 | ConfigFile | Configuration files |
| 100 | CodeAware | Generic code |
| 0 | PlainText | Universal fallback |

### Design Philosophy
- Config files have structural meaning across the file
- Prefer whole-file chunks to preserve JSON/YAML/XML structure
- Line-based splitting only when file exceeds MaxChunkSize
- Extension used as Language for syntax highlighting

### Dependencies
- Relies on IChunkingService.EstimateTokenCount()
- Uses ChunkingOptions.MaxChunkSize for threshold
- Uses ChunkingOptions.TargetChunkSize for line chunking
```

---

## Timeline Estimate

| Version | Estimated Effort |
|---------|------------------|
| v0.7.1h | 0.5 day |
