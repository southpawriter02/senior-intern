# Design Specification: AIntern v0.7.3a "Indexing Service Interface"

## Overview

**Version**: v0.7.3a
**Parent**: v0.7.3 Indexing Pipeline
**Focus**: Define the core interfaces and contracts for workspace indexing operations

### Purpose

This sub-version defines the foundational interfaces for the indexing pipeline:
1. `IIndexingService` - Main orchestrator for workspace indexing operations
2. `IIndexingJobQueue` - Queue management for background indexing jobs
3. `IFileWatcherService` - File system monitoring for automatic re-indexing
4. `IGitignoreParser` / `IGitignoreMatcher` - Pattern matching for file filtering

### Dependencies

**From v0.7.1 (Embedding Foundation)**:
- `IEmbeddingService` for generating embeddings (v0.7.1a)
- `IChunkingService` for text chunking (v0.7.1e)
- `TextChunk` model (v0.7.1d)
- `ChunkingOptions` model (v0.7.1d)

**From v0.7.2 (Vector Storage)**:
- `IVectorStore` for storing embeddings (v0.7.2a)
- `VectorIndex` model (v0.7.2b)
- `IndexedFile` model (v0.7.2h)
- `FileChangeSet` model (v0.7.2h)

**Forward References (defined in later v0.7.3 sub-versions)**:
- `IndexingOptions` (v0.7.3b)
- `IndexingProgress` (v0.7.3b)
- `IndexingResult` (v0.7.3b)
- `IndexingJob` (v0.7.3b)
- `IndexSyncResult` (v0.7.3b)
- `IndexingStatus` enum (v0.7.3b)

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                     v0.7.3a Indexing Service Interfaces                       │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  src/SeniorIntern.Core/Interfaces/                                           │
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │                                                                          ││
│  │  IIndexingService                                                        ││
│  │  ├── Properties                                                          ││
│  │  │   ├── Status: IndexingStatus                                          ││
│  │  │   ├── IsIndexing: bool                                                ││
│  │  │   └── CurrentJob: IndexingJob?                                        ││
│  │  │                                                                        ││
│  │  ├── Workspace Indexing                                                  ││
│  │  │   ├── IndexWorkspaceAsync()     → Full workspace indexing             ││
│  │  │   └── QueueWorkspaceIndexing()  → Background queue                    ││
│  │  │                                                                        ││
│  │  ├── Incremental Updates                                                 ││
│  │  │   ├── UpdateIndexAsync()        → Update changed files only           ││
│  │  │   ├── IndexFilesAsync()         → Index specific files                ││
│  │  │   └── ReindexFileAsync()        → Re-index single file                ││
│  │  │                                                                        ││
│  │  ├── File Management                                                     ││
│  │  │   ├── RemoveFilesAsync()        → Remove files from index             ││
│  │  │   └── SyncIndexAsync()          → Full synchronization                ││
│  │  │                                                                        ││
│  │  ├── Job Control                                                         ││
│  │  │   ├── CancelIndexing()          → Cancel current operation            ││
│  │  │   ├── PauseIndexing()           → Pause current operation             ││
│  │  │   ├── ResumeIndexing()          → Resume paused operation             ││
│  │  │   ├── GetJob()                  → Get job by ID                       ││
│  │  │   ├── GetActiveJobs()           → List active jobs                    ││
│  │  │   └── CancelJob()               → Cancel specific job                 ││
│  │  │                                                                        ││
│  │  └── Events                                                              ││
│  │      ├── StateChanged              → Status transitions                  ││
│  │      ├── FileIndexed               → File completion                     ││
│  │      ├── FileError                 → File failure                        ││
│  │      ├── JobStarted                → Job begins                          ││
│  │      ├── JobCompleted              → Job ends                            ││
│  │      └── ProgressUpdated           → Progress reports                    ││
│  │                                                                          ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │  IIndexingJobQueue                                                       ││
│  │  ├── Properties: QueueLength, IsProcessing                               ││
│  │  ├── Operations: Enqueue, TryDequeue, DequeueAsync, Remove, Clear       ││
│  │  ├── Query: GetQueuedJobs, Prioritize                                    ││
│  │  └── Events: JobEnqueued, JobDequeued                                    ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │  IFileWatcherService : IAsyncDisposable                                  ││
│  │  ├── Properties: IsEnabled, WatchedWorkspaces                            ││
│  │  ├── Control: StartWatching, StopWatching, StopAll, SetEnabled          ││
│  │  ├── Query: GetPendingChanges                                            ││
│  │  └── Events: ChangesDetected                                             ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │  IGitignoreParser                                                        ││
│  │  ├── LoadFromFile()     → Load single .gitignore                         ││
│  │  ├── LoadFromContent()  → Parse gitignore content                        ││
│  │  └── LoadFromDirectory() → Load all .gitignore files recursively        ││
│  │                                                                          ││
│  │  IGitignoreMatcher                                                       ││
│  │  ├── Properties: PatternCount                                            ││
│  │  ├── IsIgnored()        → Check single path                              ││
│  │  ├── Filter()           → Filter path collection                         ││
│  │  └── GetPatterns()      → List all patterns                              ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
│  Supporting Models (defined inline):                                         │
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │  FileWatchOptions         → Debounce, patterns, auto-reindex settings    ││
│  │  FileChangesDetectedEventArgs → Batch of detected file changes           ││
│  │  FileChange               → Single file change with type                 ││
│  │  FileChangeType (enum)    → Created, Modified, Deleted, Renamed          ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Interface Relationships

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                        Indexing Pipeline Flow                                 │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  User/UI                                                                     │
│     │                                                                        │
│     ▼                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                        IIndexingService                                  │ │
│  │  ┌───────────────────┐                                                  │ │
│  │  │ IndexWorkspaceAsync│ ──────────────────────────────────────────┐     │ │
│  │  └───────────────────┘                                            │     │ │
│  │           │                                                        │     │ │
│  │           ▼                                                        ▼     │ │
│  │  ┌───────────────────┐    ┌───────────────────┐    ┌─────────────────┐ │ │
│  │  │ IGitignoreParser  │───▶│ File Scanning     │───▶│ IChunkingService│ │ │
│  │  │ (Filter files)    │    │                   │    │ (from v0.7.1)   │ │ │
│  │  └───────────────────┘    └───────────────────┘    └────────┬────────┘ │ │
│  │                                                              │          │ │
│  │                                                              ▼          │ │
│  │                                   ┌───────────────────────────────────┐ │ │
│  │                                   │        IEmbeddingService          │ │ │
│  │                                   │        (from v0.7.1)              │ │ │
│  │                                   └──────────────┬────────────────────┘ │ │
│  │                                                  │                      │ │
│  │                                                  ▼                      │ │
│  │                                   ┌───────────────────────────────────┐ │ │
│  │                                   │          IVectorStore             │ │ │
│  │                                   │          (from v0.7.2)            │ │ │
│  │                                   └───────────────────────────────────┘ │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  Background Processing                                                       │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  ┌───────────────────┐    ┌───────────────────┐                         │ │
│  │  │IFileWatcherService│───▶│ IIndexingJobQueue │───▶ IIndexingService   │ │
│  │  │  (detect changes) │    │   (queue jobs)    │     (process jobs)     │ │
│  │  └───────────────────┘    └───────────────────┘                         │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/IIndexingService.cs` | Main indexing orchestrator interface |
| `src/SeniorIntern.Core/Interfaces/IIndexingJobQueue.cs` | Background job queue interface |
| `src/SeniorIntern.Core/Interfaces/IFileWatcherService.cs` | File system watcher interface |
| `src/SeniorIntern.Core/Interfaces/IGitignoreParser.cs` | Gitignore parsing interfaces |

---

## Detailed Specifications

### 1. IIndexingService.cs

**Location**: `src/SeniorIntern.Core/Interfaces/IIndexingService.cs`

```csharp
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using SeniorIntern.Core.Models;

namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Service for indexing workspace files into the vector store.
/// Provides full workspace indexing, incremental updates, and file management.
/// </summary>
/// <remarks>
/// <para>
/// The indexing service orchestrates the complete indexing pipeline:
/// <list type="number">
///   <item>Scan workspace for files matching include/exclude patterns</item>
///   <item>Filter files using .gitignore rules</item>
///   <item>Detect changed files for incremental updates</item>
///   <item>Chunk file contents using IChunkingService</item>
///   <item>Generate embeddings using IEmbeddingService</item>
///   <item>Store embeddings in IVectorStore</item>
/// </list>
/// </para>
/// <para>
/// Thread safety: The service serializes indexing operations using internal locks.
/// Only one indexing operation can run at a time. Background jobs are queued
/// and processed sequentially.
/// </para>
/// </remarks>
public interface IIndexingService
{
    #region Properties

    /// <summary>
    /// Current status of the indexing service.
    /// </summary>
    IndexingStatus Status { get; }

    /// <summary>
    /// Whether an indexing operation is currently in progress.
    /// </summary>
    /// <remarks>
    /// Returns true when Status is Indexing, Scanning, or similar active states.
    /// </remarks>
    bool IsIndexing { get; }

    /// <summary>
    /// The currently active indexing job, if any.
    /// </summary>
    IndexingJob? CurrentJob { get; }

    #endregion

    #region Workspace Indexing

    /// <summary>
    /// Index an entire workspace directory.
    /// Creates a new index or updates an existing one.
    /// </summary>
    /// <param name="workspacePath">Absolute path to the workspace directory.</param>
    /// <param name="options">Indexing configuration options.</param>
    /// <param name="progress">Optional progress reporter.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>Result of the indexing operation.</returns>
    /// <exception cref="ArgumentException">If workspace path is invalid.</exception>
    /// <exception cref="InvalidOperationException">If another operation is in progress.</exception>
    /// <exception cref="InvalidOperationException">If no embedding model is loaded.</exception>
    Task<IndexingResult> IndexWorkspaceAsync(
        string workspacePath,
        IndexingOptions options,
        IProgress<IndexingProgress>? progress = null,
        CancellationToken ct = default);

    /// <summary>
    /// Queue a workspace indexing job for background processing.
    /// </summary>
    /// <param name="workspacePath">Absolute path to the workspace directory.</param>
    /// <param name="options">Indexing configuration options.</param>
    /// <returns>The queued job information.</returns>
    /// <remarks>
    /// The job is added to the background queue and will be processed
    /// when the service is available. Use <see cref="GetJob"/> to check status.
    /// </remarks>
    IndexingJob QueueWorkspaceIndexing(
        string workspacePath,
        IndexingOptions options);

    #endregion

    #region Incremental Updates

    /// <summary>
    /// Update an existing index with only changed files.
    /// </summary>
    /// <param name="indexId">ID of the index to update.</param>
    /// <param name="progress">Optional progress reporter.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>Result of the update operation.</returns>
    /// <exception cref="ArgumentException">If index is not found.</exception>
    Task<IndexingResult> UpdateIndexAsync(
        string indexId,
        IProgress<IndexingProgress>? progress = null,
        CancellationToken ct = default);

    /// <summary>
    /// Index specific files within an existing index.
    /// </summary>
    /// <param name="indexId">ID of the index to update.</param>
    /// <param name="filePaths">Relative paths to the files to index.</param>
    /// <param name="progress">Optional progress reporter.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>Result of the indexing operation.</returns>
    Task<IndexingResult> IndexFilesAsync(
        string indexId,
        IEnumerable<string> filePaths,
        IProgress<IndexingProgress>? progress = null,
        CancellationToken ct = default);

    /// <summary>
    /// Re-index a specific file (remove old chunks and create new ones).
    /// </summary>
    /// <param name="indexId">ID of the index.</param>
    /// <param name="filePath">Relative path to the file.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>Number of chunks created.</returns>
    Task<int> ReindexFileAsync(
        string indexId,
        string filePath,
        CancellationToken ct = default);

    #endregion

    #region File Management

    /// <summary>
    /// Remove files from an index.
    /// </summary>
    /// <param name="indexId">ID of the index.</param>
    /// <param name="filePaths">Relative paths to remove.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>Number of chunks removed.</returns>
    Task<int> RemoveFilesAsync(
        string indexId,
        IEnumerable<string> filePaths,
        CancellationToken ct = default);

    /// <summary>
    /// Synchronize index with filesystem (add new, update changed, remove deleted).
    /// </summary>
    /// <param name="indexId">ID of the index to sync.</param>
    /// <param name="progress">Optional progress reporter.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>Sync operation result.</returns>
    Task<IndexSyncResult> SyncIndexAsync(
        string indexId,
        IProgress<IndexingProgress>? progress = null,
        CancellationToken ct = default);

    #endregion

    #region Job Control

    /// <summary>
    /// Cancel the current indexing operation.
    /// </summary>
    void CancelIndexing();

    /// <summary>
    /// Pause the current indexing operation.
    /// </summary>
    void PauseIndexing();

    /// <summary>
    /// Resume a paused indexing operation.
    /// </summary>
    void ResumeIndexing();

    /// <summary>
    /// Get status of a specific job.
    /// </summary>
    /// <param name="jobId">The job ID to query.</param>
    /// <returns>Job status if found.</returns>
    IndexingJob? GetJob(string jobId);

    /// <summary>
    /// Get all pending and active jobs.
    /// </summary>
    IReadOnlyList<IndexingJob> GetActiveJobs();

    /// <summary>
    /// Cancel a specific queued job.
    /// </summary>
    /// <param name="jobId">The job ID to cancel.</param>
    /// <returns>True if job was found and cancelled.</returns>
    bool CancelJob(string jobId);

    #endregion

    #region Events

    /// <summary>
    /// Raised when indexing status changes.
    /// </summary>
    event EventHandler<IndexingStateChangedEventArgs>? StateChanged;

    /// <summary>
    /// Raised when a file is successfully indexed.
    /// </summary>
    event EventHandler<FileIndexedEventArgs>? FileIndexed;

    /// <summary>
    /// Raised when a file indexing fails.
    /// </summary>
    event EventHandler<FileIndexingErrorEventArgs>? FileError;

    /// <summary>
    /// Raised when an indexing job starts.
    /// </summary>
    event EventHandler<IndexingJobEventArgs>? JobStarted;

    /// <summary>
    /// Raised when an indexing job completes.
    /// </summary>
    event EventHandler<IndexingJobCompletedEventArgs>? JobCompleted;

    /// <summary>
    /// Raised periodically with progress updates.
    /// </summary>
    event EventHandler<IndexingProgressEventArgs>? ProgressUpdated;

    #endregion
}
```

### 2. IIndexingJobQueue.cs

**Location**: `src/SeniorIntern.Core/Interfaces/IIndexingJobQueue.cs`

```csharp
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using SeniorIntern.Core.Models;

namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Queue for managing background indexing jobs.
/// </summary>
/// <remarks>
/// <para>
/// Provides a thread-safe priority queue for indexing jobs. Jobs are processed
/// in priority order (higher priority first), with FIFO ordering for same-priority jobs.
/// </para>
/// <para>
/// The queue supports async consumption via <see cref="DequeueAsync"/>, allowing
/// background workers to wait for new jobs without polling.
/// </para>
/// </remarks>
public interface IIndexingJobQueue
{
    /// <summary>
    /// Number of jobs currently in the queue.
    /// </summary>
    int QueueLength { get; }

    /// <summary>
    /// Whether the queue is currently processing jobs.
    /// </summary>
    bool IsProcessing { get; }

    /// <summary>
    /// Enqueue a new indexing job.
    /// </summary>
    /// <param name="job">The job to enqueue.</param>
    void Enqueue(IndexingJob job);

    /// <summary>
    /// Try to dequeue the next job without waiting.
    /// </summary>
    /// <param name="job">The dequeued job if available.</param>
    /// <returns>True if a job was dequeued.</returns>
    bool TryDequeue(out IndexingJob? job);

    /// <summary>
    /// Wait for and dequeue the next job.
    /// </summary>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>The next job in queue.</returns>
    /// <exception cref="OperationCanceledException">If cancelled while waiting.</exception>
    Task<IndexingJob> DequeueAsync(CancellationToken ct = default);

    /// <summary>
    /// Get all jobs in the queue without removing them.
    /// </summary>
    IReadOnlyList<IndexingJob> GetQueuedJobs();

    /// <summary>
    /// Remove a specific job from the queue.
    /// </summary>
    /// <param name="jobId">ID of the job to remove.</param>
    /// <returns>True if job was found and removed.</returns>
    bool Remove(string jobId);

    /// <summary>
    /// Clear all jobs from the queue.
    /// </summary>
    void Clear();

    /// <summary>
    /// Prioritize a job (move to front of queue).
    /// </summary>
    /// <param name="jobId">ID of the job to prioritize.</param>
    /// <returns>True if job was found and prioritized.</returns>
    bool Prioritize(string jobId);

    /// <summary>
    /// Raised when a job is enqueued.
    /// </summary>
    event EventHandler<IndexingJobEventArgs>? JobEnqueued;

    /// <summary>
    /// Raised when a job is dequeued for processing.
    /// </summary>
    event EventHandler<IndexingJobEventArgs>? JobDequeued;
}
```

### 3. IFileWatcherService.cs

**Location**: `src/SeniorIntern.Core/Interfaces/IFileWatcherService.cs`

```csharp
using System;
using System.Collections.Generic;

namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Service for watching file system changes and triggering re-indexing.
/// </summary>
/// <remarks>
/// <para>
/// Uses FileSystemWatcher internally to monitor workspace directories for changes.
/// Changes are debounced and batched before triggering re-indexing to avoid
/// excessive processing during rapid file modifications (e.g., git operations).
/// </para>
/// </remarks>
public interface IFileWatcherService : IAsyncDisposable
{
    /// <summary>
    /// Whether file watching is currently enabled globally.
    /// </summary>
    bool IsEnabled { get; }

    /// <summary>
    /// Workspaces currently being watched.
    /// </summary>
    IReadOnlyList<string> WatchedWorkspaces { get; }

    /// <summary>
    /// Start watching a workspace for file changes.
    /// </summary>
    /// <param name="indexId">ID of the index to update on changes.</param>
    /// <param name="workspacePath">Absolute path to watch.</param>
    /// <param name="options">Watch configuration options.</param>
    void StartWatching(
        string indexId,
        string workspacePath,
        FileWatchOptions? options = null);

    /// <summary>
    /// Stop watching a workspace.
    /// </summary>
    /// <param name="workspacePath">Path to stop watching.</param>
    void StopWatching(string workspacePath);

    /// <summary>
    /// Stop watching all workspaces.
    /// </summary>
    void StopAll();

    /// <summary>
    /// Enable or disable all file watching globally.
    /// </summary>
    /// <param name="enabled">Whether to enable watching.</param>
    void SetEnabled(bool enabled);

    /// <summary>
    /// Get pending file changes that haven't been processed yet.
    /// </summary>
    /// <param name="workspacePath">Workspace to query.</param>
    /// <returns>List of pending relative file paths.</returns>
    IReadOnlyList<string> GetPendingChanges(string workspacePath);

    /// <summary>
    /// Raised when files change and need re-indexing.
    /// </summary>
    event EventHandler<FileChangesDetectedEventArgs>? ChangesDetected;
}

/// <summary>
/// Options for file watching behavior.
/// </summary>
public sealed class FileWatchOptions
{
    /// <summary>
    /// Delay in milliseconds before triggering re-indexing after changes.
    /// Helps batch rapid file changes.
    /// </summary>
    public int DebounceDelayMs { get; init; } = 2000;

    /// <summary>
    /// Whether to watch subdirectories.
    /// </summary>
    public bool IncludeSubdirectories { get; init; } = true;

    /// <summary>
    /// File patterns to watch (default: all files).
    /// </summary>
    public IReadOnlyList<string>? FilePatterns { get; init; }

    /// <summary>
    /// Patterns to exclude from watching.
    /// </summary>
    public IReadOnlyList<string>? ExcludePatterns { get; init; }

    /// <summary>
    /// Whether to automatically queue re-indexing on changes.
    /// </summary>
    public bool AutoReindex { get; init; } = true;

    /// <summary>
    /// Maximum number of changes to batch before triggering.
    /// </summary>
    public int MaxBatchSize { get; init; } = 100;
}

/// <summary>
/// Event args for file changes detection.
/// </summary>
public sealed class FileChangesDetectedEventArgs : EventArgs
{
    /// <summary>ID of the index affected by changes.</summary>
    public required string IndexId { get; init; }

    /// <summary>Path to the workspace being watched.</summary>
    public required string WorkspacePath { get; init; }

    /// <summary>Collection of detected file changes.</summary>
    public required IReadOnlyList<FileChange> Changes { get; init; }

    /// <summary>When the changes were detected.</summary>
    public DateTime DetectedAt { get; init; } = DateTime.UtcNow;
}

/// <summary>
/// Represents a single file change.
/// </summary>
public sealed class FileChange
{
    /// <summary>Relative path to the changed file.</summary>
    public required string FilePath { get; init; }

    /// <summary>Type of change detected.</summary>
    public required FileChangeType ChangeType { get; init; }

    /// <summary>Old path for rename operations.</summary>
    public string? OldPath { get; init; }

    /// <summary>When the change occurred.</summary>
    public DateTime ChangedAt { get; init; } = DateTime.UtcNow;
}

/// <summary>
/// Type of file change detected.
/// </summary>
public enum FileChangeType
{
    /// <summary>New file created.</summary>
    Created,

    /// <summary>Existing file modified.</summary>
    Modified,

    /// <summary>File deleted.</summary>
    Deleted,

    /// <summary>File renamed or moved.</summary>
    Renamed
}
```

### 4. IGitignoreParser.cs

**Location**: `src/SeniorIntern.Core/Interfaces/IGitignoreParser.cs`

```csharp
using System.Collections.Generic;

namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Parser for .gitignore files.
/// </summary>
/// <remarks>
/// <para>
/// Provides factory methods to create <see cref="IGitignoreMatcher"/> instances
/// from various sources: files, content strings, or directory trees.
/// </para>
/// <para>
/// Supports standard .gitignore syntax including:
/// <list type="bullet">
///   <item>Glob patterns (*, ?, **)</item>
///   <item>Negation patterns (!pattern)</item>
///   <item>Directory-only patterns (dir/)</item>
///   <item>Comments (#) and blank lines</item>
///   <item>Rooted patterns (/pattern)</item>
/// </list>
/// </para>
/// </remarks>
public interface IGitignoreParser
{
    /// <summary>
    /// Load gitignore patterns from a file.
    /// </summary>
    /// <param name="gitignorePath">Absolute path to the .gitignore file.</param>
    /// <returns>Matcher instance with loaded patterns.</returns>
    /// <exception cref="System.IO.FileNotFoundException">If file doesn't exist.</exception>
    IGitignoreMatcher LoadFromFile(string gitignorePath);

    /// <summary>
    /// Load gitignore patterns from content string.
    /// </summary>
    /// <param name="content">Gitignore file content.</param>
    /// <param name="basePath">Base path for relative pattern matching.</param>
    /// <returns>Matcher instance with loaded patterns.</returns>
    IGitignoreMatcher LoadFromContent(string content, string basePath);

    /// <summary>
    /// Load all gitignore files from a directory tree.
    /// </summary>
    /// <param name="rootPath">Root directory to search from.</param>
    /// <returns>Combined matcher for all found gitignore files.</returns>
    /// <remarks>
    /// Searches recursively for all .gitignore files and combines them
    /// into a single matcher, respecting directory hierarchy for pattern scope.
    /// </remarks>
    IGitignoreMatcher LoadFromDirectory(string rootPath);
}

/// <summary>
/// Matcher for gitignore patterns.
/// </summary>
/// <remarks>
/// <para>
/// Provides efficient matching of file paths against loaded gitignore patterns.
/// Patterns are evaluated in order with later patterns taking precedence.
/// </para>
/// </remarks>
public interface IGitignoreMatcher
{
    /// <summary>
    /// Number of patterns loaded in this matcher.
    /// </summary>
    int PatternCount { get; }

    /// <summary>
    /// Check if a path should be ignored.
    /// </summary>
    /// <param name="relativePath">Relative path from the repository root.</param>
    /// <param name="isDirectory">Whether the path is a directory.</param>
    /// <returns>True if the path should be ignored.</returns>
    /// <remarks>
    /// Path separators are normalized internally. Both forward and back slashes work.
    /// </remarks>
    bool IsIgnored(string relativePath, bool isDirectory = false);

    /// <summary>
    /// Filter a list of paths, removing ignored ones.
    /// </summary>
    /// <param name="relativePaths">Paths to filter.</param>
    /// <returns>Paths that are not ignored.</returns>
    IEnumerable<string> Filter(IEnumerable<string> relativePaths);

    /// <summary>
    /// Get all patterns as strings for debugging/display.
    /// </summary>
    IReadOnlyList<string> GetPatterns();
}
```

---

## Event Args Models

The following event argument classes are defined inline with `IIndexingService`:

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>Event args for indexing state changes.</summary>
public sealed class IndexingStateChangedEventArgs : EventArgs
{
    public IndexingStatus OldStatus { get; init; }
    public IndexingStatus NewStatus { get; init; }
}

/// <summary>Event args for successful file indexing.</summary>
public sealed class FileIndexedEventArgs : EventArgs
{
    public required string FilePath { get; init; }
    public int ChunkCount { get; init; }
    public bool Success { get; init; }
}

/// <summary>Event args for file indexing errors.</summary>
public sealed class FileIndexingErrorEventArgs : EventArgs
{
    public required string FilePath { get; init; }
    public required IndexingError Error { get; init; }
}

/// <summary>Event args for indexing job events.</summary>
public sealed class IndexingJobEventArgs : EventArgs
{
    public required IndexingJob Job { get; init; }
}

/// <summary>Event args for job completion.</summary>
public sealed class IndexingJobCompletedEventArgs : EventArgs
{
    public required IndexingJob Job { get; init; }
    public required IndexingResult Result { get; init; }
}

/// <summary>Event args for progress updates.</summary>
public sealed class IndexingProgressEventArgs : EventArgs
{
    public required IndexingProgress Progress { get; init; }
}
```

---

## Unit Testing Requirements

| Interface | Test Count | Focus Areas |
|-----------|------------|-------------|
| `IIndexingService` | 25-30 | Workspace indexing, incremental updates, job control, events |
| `IIndexingJobQueue` | 12-15 | Queue operations, priority, thread safety |
| `IFileWatcherService` | 15-18 | Watch lifecycle, debouncing, change detection |
| `IGitignoreParser` | 10-12 | Pattern loading, combined matching |
| `IGitignoreMatcher` | 15-20 | Pattern matching accuracy, edge cases |

**Total: ~77-95 tests**

---

## Acceptance Criteria

### Functional Requirements
- [ ] `IIndexingService` defines all workspace indexing operations
- [ ] `IIndexingJobQueue` provides thread-safe background job management
- [ ] `IFileWatcherService` supports debounced file change detection
- [ ] `IGitignoreParser` loads patterns from files and directories
- [ ] `IGitignoreMatcher` accurately matches gitignore patterns
- [ ] All event args models are defined with required properties
- [ ] All interfaces have comprehensive XML documentation

### Quality Requirements
- [ ] All public members have XML documentation comments
- [ ] Interface contracts are clearly defined in remarks
- [ ] No forward dependencies on implementation details
- [ ] Event patterns follow .NET conventions

---

## Future Considerations

Items explicitly deferred to later sub-versions:
- **v0.7.3b**: Concrete model implementations (`IndexingOptions`, `IndexingProgress`, etc.)
- **v0.7.3c**: `IndexingService` implementation
- **v0.7.3g**: `IndexingJobQueue` implementation
- **v0.7.3h**: `FileWatcherService` implementation
- **v0.7.3e**: `GitignoreParser` / `GitignoreMatcher` implementations
