# Design Specification: AIntern v0.7.2g "Vector Search Implementation"

## Overview

**Version**: v0.7.2g
**Parent**: v0.7.2 Vector Storage
**Focus**: Implement vector similarity search using sqlite-vec with support for filtering and deduplication

### Purpose

Implement the core vector search functionality:
1. Implement `SearchAsync` for single-index vector similarity search
2. Implement `SearchMultipleAsync` for cross-index search
3. Build dynamic SQL queries with metadata filtering
4. Support context expansion for search results
5. Implement result deduplication for overlapping chunks
6. Provide SIMD-accelerated vector helper utilities
7. Support result reranking with multiple scoring factors

### Dependencies

**From v0.7.2c (Search Models & Options)**:
- `VectorSearchOptions` for search configuration
- `ChunkSearchResult` for search results
- `VectorSearchAlgorithm` enum

**From v0.7.2f (Chunk Operations)**:
- `EmbeddingToBlob()` for query embedding serialization
- `ReadStoredChunkFromReader()` patterns

**From v0.7.1d (Text Chunk Models)**:
- `ChunkType` enum for filtering
- `SymbolType` enum for filtering

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                     v0.7.2g Vector Search Implementation                      │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Component Overview:                                                          │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  SqliteVectorStore.Search.cs (partial class extension)                   │ │
│  │  ├── SearchAsync()              ← Single-index vector search            │ │
│  │  ├── SearchMultipleAsync()      ← Cross-index search                    │ │
│  │  ├── BuildSearchQuery()         ← Dynamic SQL generation                │ │
│  │  ├── AddFilterParameters()      ← Parameterized filter values           │ │
│  │  ├── ExpandContextAsync()       ← Context line expansion                │ │
│  │  ├── DeduplicateResults()       ← Overlapping chunk removal             │ │
│  │  ├── FilterByFilePatterns()     ← Glob pattern matching                 │ │
│  │  └── DistanceToScore()          ← Distance → similarity conversion      │ │
│  │                                                                          │ │
│  │  VectorSearchHelper.cs (static helper class)                             │ │
│  │  ├── CosineSimilarity()         ← SIMD cosine similarity                │ │
│  │  ├── Normalize()                ← SIMD vector normalization             │ │
│  │  ├── L2Distance()               ← SIMD Euclidean distance               │ │
│  │  └── RerankResults()            ← Multi-factor reranking                │ │
│  │                                                                          │ │
│  │  RerankingOptions (model class)                                          │ │
│  │  ├── SimilarityWeight           ← Base similarity weight                │ │
│  │  ├── SymbolBoost                ← Symbol name boost                     │ │
│  │  ├── ChunkTypeBoost             ← Preferred type boost                  │ │
│  │  ├── RecencyWeight              ← Recency decay weight                  │ │
│  │  └── PreferredChunkTypes        ← Types to prefer                       │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Search Flow

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                           SearchAsync Flow                                    │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Input: indexId, queryEmbedding[], VectorSearchOptions                       │
│       │                                                                      │
│       ▼                                                                      │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  1. Validation & Preparation                                             │ │
│  │     • EnsureInitialized()                                                │ │
│  │     • SanitizeTableName(indexId)                                         │ │
│  │     • EmbeddingToBlob(queryEmbedding)                                    │ │
│  │     • Calculate fetchCount = TopK × 3 (over-fetch for filtering)         │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│       │                                                                      │
│       ▼                                                                      │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  2. Build Dynamic SQL Query                                              │ │
│  │     • BuildSearchQuery(sanitizedId, options)                             │ │
│  │     • AddFilterParameters(cmd, options)                                  │ │
│  │     • Filters applied at SQL level:                                      │ │
│  │       - Languages                                                         │ │
│  │       - ChunkTypes                                                        │ │
│  │       - SymbolTypes                                                       │ │
│  │       - SymbolNames                                                       │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│       │                                                                      │
│       ▼                                                                      │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  3. Execute sqlite-vec Search                                            │ │
│  │     • WHERE v.embedding MATCH @embedding AND k = @topK                   │ │
│  │     • ORDER BY v.distance ASC                                            │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│       │                                                                      │
│       ▼                                                                      │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  4. Process Results (per row)                                            │ │
│  │     • Get distance from reader                                           │ │
│  │     • score = DistanceToScore(distance)                                  │ │
│  │     • If score < MinScore → skip                                         │ │
│  │     • ReadStoredChunkFromSearchReader()                                  │ │
│  │     • Create ChunkSearchResult with rank                                 │ │
│  │     • If ExpandContext → ExpandContextAsync()                            │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│       │                                                                      │
│       ▼                                                                      │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  5. Post-Processing                                                      │ │
│  │     • If DeduplicateOverlapping:                                         │ │
│  │       └── DeduplicateResults(results, threshold)                        │ │
│  │     • If FilePatterns specified:                                         │ │
│  │       └── FilterByFilePatterns(results, patterns)                       │ │
│  │     • Take(TopK) → return final results                                  │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│       │                                                                      │
│       ▼                                                                      │
│  Output: IReadOnlyList<ChunkSearchResult>                                    │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Distance → Score Conversion

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                     Distance to Score Conversion                              │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  sqlite-vec returns L2 (Euclidean) distance: lower = more similar            │
│  We need a similarity score 0-1: higher = more similar                       │
│                                                                              │
│  Conversion Formula: score = e^(-distance)                                   │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  private static float DistanceToScore(float distance)                    │ │
│  │  {                                                                        │ │
│  │      return MathF.Exp(-distance);                                        │ │
│  │  }                                                                        │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  Conversion Examples:                                                         │
│  ┌────────────────┬───────────────┬─────────────────────────────────────────┐│
│  │ Distance       │ Score         │ Interpretation                          ││
│  │ ────────────── │ ────────────  │ ─────────────────────────────────────── ││
│  │ 0.0            │ 1.000         │ Exact match (identical vectors)        ││
│  │ 0.5            │ 0.607         │ Very similar                            ││
│  │ 1.0            │ 0.368         │ Moderately similar                      ││
│  │ 2.0            │ 0.135         │ Low similarity                          ││
│  │ 3.0            │ 0.050         │ Very low similarity                     ││
│  └────────────────┴───────────────┴─────────────────────────────────────────┘│
│                                                                              │
│  Why Exponential Decay?                                                       │
│  • Produces values in (0, 1] range naturally                                 │
│  • Smooth, continuous function                                               │
│  • More discriminating for smaller distances                                 │
│  • Works well with MinScore thresholds                                       │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Deduplication Algorithm

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                      Overlapping Chunk Deduplication                          │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Problem: Semantic chunking may produce overlapping chunks that match        │
│           similar queries, causing redundant results.                        │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  File: Program.cs                                                        │ │
│  │                                                                          │ │
│  │  Chunk A (lines 10-25, score 0.85):                                      │ │
│  │  ┌──────────────────────────────────────┐                                │ │
│  │  │  public void ProcessData()           │                                │ │
│  │  │  {                                   │                                │ │
│  │  │      // Process logic                │                                │ │
│  │  │  }                                   │                                │ │
│  │  └──────────────────────────────────────┘                                │ │
│  │                                                                          │ │
│  │  Chunk B (lines 15-30, score 0.82):  ← Overlaps with A!                  │ │
│  │  ┌──────────────────────────────────────┐                                │ │
│  │  │      // Process logic                │                                │ │
│  │  │  }                                   │                                │ │
│  │  │                                      │                                │ │
│  │  │  public void SaveData() ...          │                                │ │
│  │  └──────────────────────────────────────┘                                │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  Algorithm:                                                                   │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  1. Sort results by score (descending)                                   │ │
│  │  2. For each result:                                                      │ │
│  │     a. Check if it overlaps with any already-accepted result            │ │
│  │     b. Overlap check: same file AND line ranges overlap > threshold     │ │
│  │     c. If no significant overlap → accept result                        │ │
│  │     d. If overlaps → skip (lower score duplicate)                       │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  Overlap Calculation:                                                         │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  RangesOverlap(start1, end1, start2, end2, threshold):                   │ │
│  │                                                                          │ │
│  │      overlapStart = max(start1, start2)                                  │ │
│  │      overlapEnd   = min(end1, end2)                                      │ │
│  │      overlapSize  = max(0, overlapEnd - overlapStart + 1)                │ │
│  │      smallerRange = min(end1-start1+1, end2-start2+1)                    │ │
│  │                                                                          │ │
│  │      return (overlapSize / smallerRange) > threshold                     │ │
│  │                                                                          │ │
│  │  Example with threshold = 0.5:                                           │ │
│  │  • Chunk A: lines 10-25 (16 lines)                                       │ │
│  │  • Chunk B: lines 15-30 (16 lines)                                       │ │
│  │  • Overlap: lines 15-25 (11 lines)                                       │ │
│  │  • Ratio: 11/16 = 0.69 > 0.5 → OVERLAPS                                 │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## SIMD Vector Operations

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                    SIMD-Accelerated Vector Operations                         │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  VectorSearchHelper provides SIMD-optimized vector math:                     │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  Cosine Similarity: cos(θ) = (A·B) / (||A|| × ||B||)                    │ │
│  │                                                                          │ │
│  │  SIMD implementation processes Vector<float>.Count elements at once:    │ │
│  │  • x86/x64 with SSE: 4 floats at once                                   │ │
│  │  • x86/x64 with AVX: 8 floats at once                                   │ │
│  │  • ARM with NEON: 4 floats at once                                      │ │
│  │                                                                          │ │
│  │  for (; i < lastBlockIndex; i += Vector<float>.Count)                   │ │
│  │  {                                                                        │ │
│  │      var va = new Vector<float>(a.Slice(i, Vector<float>.Count));       │ │
│  │      var vb = new Vector<float>(b.Slice(i, Vector<float>.Count));       │ │
│  │      dotVec += va * vb;        // Parallel multiply-add                 │ │
│  │      normAVec += va * va;      // Parallel square                       │ │
│  │      normBVec += vb * vb;      // Parallel square                       │ │
│  │  }                                                                        │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  Performance Comparison (384-dim vectors):                                    │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │ Method          │ Time (scalar)  │ Time (SIMD)   │ Speedup            │  │
│  │ ─────────────── │ ───────────── │ ───────────── │ ────────────────── │  │
│  │ Cosine Sim      │ ~1.5 µs       │ ~0.2 µs       │ ~7.5x              │  │
│  │ L2 Distance     │ ~1.2 µs       │ ~0.15 µs      │ ~8x                │  │
│  │ Normalize       │ ~0.8 µs       │ ~0.1 µs       │ ~8x                │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│                                                                              │
│  Note: sqlite-vec performs distance calculation internally,                  │
│        but these helpers are useful for:                                     │
│        • Pre-normalization of query embeddings                              │
│        • Client-side similarity calculations                                │
│        • Reranking and score adjustments                                    │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Specifications

### 1. SqliteVectorStore.Search.cs

**Location**: `src/SeniorIntern.Services/VectorStore/SqliteVectorStore.Search.cs`

```csharp
namespace SeniorIntern.Services.VectorStore;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Data.Sqlite;
using SeniorIntern.Core.Models;

/// <summary>
/// Partial class containing vector search operations.
/// </summary>
public sealed partial class SqliteVectorStore
{
    #region Search Operations

    /// <inheritdoc />
    public async Task<IReadOnlyList<ChunkSearchResult>> SearchAsync(
        string indexId,
        float[] queryEmbedding,
        VectorSearchOptions options,
        CancellationToken ct = default)
    {
        EnsureInitialized();

        if (string.IsNullOrWhiteSpace(indexId))
            throw new ArgumentException("Index ID is required", nameof(indexId));

        if (queryEmbedding == null || queryEmbedding.Length == 0)
            throw new ArgumentException("Query embedding is required", nameof(queryEmbedding));

        options ??= new VectorSearchOptions();

        var sanitizedId = SanitizeTableName(indexId);
        var embeddingBlob = EmbeddingToBlob(queryEmbedding);

        // Over-fetch to allow for post-filtering and deduplication
        var fetchCount = Math.Max(options.TopK * 3, 50);

        _logger.LogDebug(
            "Searching index {IndexId} with TopK={TopK}, MinScore={MinScore}, FetchCount={FetchCount}",
            indexId, options.TopK, options.MinScore, fetchCount);

        var results = new List<ChunkSearchResult>();

        // Build and execute the search query
        var sql = BuildSearchQuery(sanitizedId, options);

        await using var cmd = _connection!.CreateCommand();
        cmd.CommandText = sql;
        cmd.Parameters.AddWithValue("@embedding", embeddingBlob);
        cmd.Parameters.AddWithValue("@topK", fetchCount);

        // Add filter parameters
        AddFilterParameters(cmd, options);

        await using var reader = await cmd.ExecuteReaderAsync(ct);
        var rank = 0;

        while (await reader.ReadAsync(ct))
        {
            var distance = reader.GetFloat(reader.GetOrdinal("distance"));
            var score = DistanceToScore(distance);

            // Apply minimum score filter
            if (score < options.MinScore)
            {
                _logger.LogDebug("Skipping result with score {Score} < MinScore {MinScore}", score, options.MinScore);
                continue;
            }

            rank++;
            var chunk = ReadStoredChunkFromSearchReader(reader);

            var result = new ChunkSearchResult
            {
                ChunkId = chunk.Id,
                IndexId = indexId,
                Score = score,
                Distance = distance,
                Chunk = chunk,
                Rank = rank
            };

            // Expand context if requested
            if (options.ExpandContext)
            {
                result = await ExpandContextAsync(result, options, ct);
            }

            results.Add(result);
        }

        _logger.LogDebug("Raw search returned {Count} results", results.Count);

        // Apply deduplication if requested
        if (options.DeduplicateOverlapping && results.Count > 0)
        {
            var beforeCount = results.Count;
            results = DeduplicateResults(results, options.DeduplicationThreshold);
            _logger.LogDebug("Deduplication reduced {Before} → {After} results", beforeCount, results.Count);
        }

        // Apply file pattern filters (post-query for glob support)
        if (options.FilePatterns?.Count > 0 && results.Count > 0)
        {
            var beforeCount = results.Count;
            results = FilterByFilePatterns(results, options.FilePatterns);
            _logger.LogDebug("File pattern filter reduced {Before} → {After} results", beforeCount, results.Count);
        }

        // Take top K and re-rank
        var finalResults = results.Take(options.TopK).ToList();
        for (int i = 0; i < finalResults.Count; i++)
        {
            finalResults[i] = finalResults[i] with { Rank = i + 1 };
        }

        _logger.LogInformation(
            "Search completed: {Count} results for index {IndexId}",
            finalResults.Count, indexId);

        // Record search in history
        await RecordSearchHistoryAsync(indexId, finalResults.Count, finalResults.FirstOrDefault()?.Score ?? 0, ct);

        return finalResults;
    }

    /// <inheritdoc />
    public async Task<IReadOnlyList<ChunkSearchResult>> SearchMultipleAsync(
        IEnumerable<string> indexIds,
        float[] queryEmbedding,
        VectorSearchOptions options,
        CancellationToken ct = default)
    {
        var indexList = indexIds?.ToList() ?? throw new ArgumentNullException(nameof(indexIds));
        if (indexList.Count == 0)
            throw new ArgumentException("At least one index ID is required", nameof(indexIds));

        _logger.LogDebug("Searching across {Count} indexes", indexList.Count);

        var allResults = new List<ChunkSearchResult>();

        // Search each index
        foreach (var indexId in indexList)
        {
            ct.ThrowIfCancellationRequested();
            var indexResults = await SearchAsync(indexId, queryEmbedding, options with { TopK = options.TopK * 2 }, ct);
            allResults.AddRange(indexResults);
        }

        // Re-sort by score across all indexes
        allResults = allResults
            .OrderByDescending(r => r.Score)
            .ToList();

        // Deduplicate across indexes if requested
        if (options.DeduplicateOverlapping && allResults.Count > 0)
        {
            allResults = DeduplicateResults(allResults, options.DeduplicationThreshold);
        }

        // Re-rank and take top K
        var finalResults = allResults.Take(options.TopK).ToList();
        for (int i = 0; i < finalResults.Count; i++)
        {
            finalResults[i] = finalResults[i] with { Rank = i + 1 };
        }

        _logger.LogInformation(
            "Multi-index search completed: {Count} results across {IndexCount} indexes",
            finalResults.Count, indexList.Count);

        return finalResults;
    }

    #endregion

    #region Query Building

    /// <summary>
    /// Builds the search SQL query with filters.
    /// </summary>
    private string BuildSearchQuery(string sanitizedIndexId, VectorSearchOptions options)
    {
        var sql = new StringBuilder();

        sql.AppendLine($"""
            SELECT
                v.id,
                v.distance,
                cm.index_id,
                cm.file_id,
                cm.content,
                cm.start_line,
                cm.end_line,
                cm.start_offset,
                cm.end_offset,
                cm.chunk_type,
                cm.language,
                cm.symbol_name,
                cm.symbol_type,
                cm.parent_symbol,
                cm.token_count,
                cm.indexed_at,
                if.file_path
            FROM vectors_{sanitizedIndexId} v
            JOIN chunk_metadata cm ON v.id = cm.id
            JOIN indexed_files if ON cm.file_id = if.id
            WHERE v.embedding MATCH @embedding
              AND k = @topK
            """);

        // Add SQL-level filters for efficiency
        if (options.Languages?.Count > 0)
        {
            var placeholders = string.Join(", ", options.Languages.Select((_, i) => $"@lang{i}"));
            sql.AppendLine($"  AND cm.language IN ({placeholders})");
        }

        if (options.ChunkTypes?.Count > 0)
        {
            var placeholders = string.Join(", ", options.ChunkTypes.Select((_, i) => $"@chunkType{i}"));
            sql.AppendLine($"  AND cm.chunk_type IN ({placeholders})");
        }

        if (options.SymbolTypes?.Count > 0)
        {
            var placeholders = string.Join(", ", options.SymbolTypes.Select((_, i) => $"@symbolType{i}"));
            sql.AppendLine($"  AND cm.symbol_type IN ({placeholders})");
        }

        if (options.SymbolNames?.Count > 0)
        {
            var placeholders = string.Join(", ", options.SymbolNames.Select((_, i) => $"@symbolName{i}"));
            sql.AppendLine($"  AND cm.symbol_name IN ({placeholders})");
        }

        sql.AppendLine("ORDER BY v.distance ASC");

        return sql.ToString();
    }

    /// <summary>
    /// Adds filter parameter values to the command.
    /// </summary>
    private static void AddFilterParameters(SqliteCommand cmd, VectorSearchOptions options)
    {
        if (options.Languages?.Count > 0)
        {
            for (int i = 0; i < options.Languages.Count; i++)
            {
                cmd.Parameters.AddWithValue($"@lang{i}", options.Languages[i]);
            }
        }

        if (options.ChunkTypes?.Count > 0)
        {
            for (int i = 0; i < options.ChunkTypes.Count; i++)
            {
                cmd.Parameters.AddWithValue($"@chunkType{i}", options.ChunkTypes[i].ToString());
            }
        }

        if (options.SymbolTypes?.Count > 0)
        {
            for (int i = 0; i < options.SymbolTypes.Count; i++)
            {
                cmd.Parameters.AddWithValue($"@symbolType{i}", options.SymbolTypes[i].ToString());
            }
        }

        if (options.SymbolNames?.Count > 0)
        {
            for (int i = 0; i < options.SymbolNames.Count; i++)
            {
                cmd.Parameters.AddWithValue($"@symbolName{i}", options.SymbolNames[i]);
            }
        }
    }

    #endregion

    #region Context Expansion

    /// <summary>
    /// Expands the search result with surrounding context lines.
    /// </summary>
    private async Task<ChunkSearchResult> ExpandContextAsync(
        ChunkSearchResult result,
        VectorSearchOptions options,
        CancellationToken ct)
    {
        // Calculate expanded line range
        var expandedStartLine = Math.Max(1, result.Chunk.StartLine - options.ContextLinesAbove);
        var expandedEndLine = result.Chunk.EndLine + options.ContextLinesBelow;

        // TODO: For full implementation, read file content and extract context
        // For now, return with expanded line numbers only
        return result with
        {
            ExpandedStartLine = expandedStartLine,
            ExpandedEndLine = expandedEndLine
        };
    }

    #endregion

    #region Deduplication

    /// <summary>
    /// Removes overlapping chunks, keeping the highest-scoring version.
    /// </summary>
    private static List<ChunkSearchResult> DeduplicateResults(
        List<ChunkSearchResult> results,
        float threshold)
    {
        var deduplicated = new List<ChunkSearchResult>();

        foreach (var result in results.OrderByDescending(r => r.Score))
        {
            var overlaps = deduplicated.Any(existing =>
                existing.Chunk.FilePath == result.Chunk.FilePath &&
                RangesOverlap(
                    existing.Chunk.StartLine, existing.Chunk.EndLine,
                    result.Chunk.StartLine, result.Chunk.EndLine,
                    threshold));

            if (!overlaps)
            {
                deduplicated.Add(result);
            }
        }

        return deduplicated;
    }

    /// <summary>
    /// Determines if two line ranges overlap beyond the threshold.
    /// </summary>
    private static bool RangesOverlap(
        int start1, int end1,
        int start2, int end2,
        float threshold)
    {
        var overlapStart = Math.Max(start1, start2);
        var overlapEnd = Math.Min(end1, end2);
        var overlap = Math.Max(0, overlapEnd - overlapStart + 1);
        var smallerRange = Math.Min(end1 - start1 + 1, end2 - start2 + 1);

        return smallerRange > 0 && (float)overlap / smallerRange > threshold;
    }

    #endregion

    #region File Pattern Filtering

    /// <summary>
    /// Filters results by glob file patterns.
    /// </summary>
    private static List<ChunkSearchResult> FilterByFilePatterns(
        List<ChunkSearchResult> results,
        IReadOnlyList<string> patterns)
    {
        return results.Where(r => patterns.Any(p => MatchGlob(r.Chunk.FilePath, p))).ToList();
    }

    /// <summary>
    /// Matches a file path against a glob pattern.
    /// </summary>
    private static bool MatchGlob(string path, string pattern)
    {
        // Convert glob to regex
        var regexPattern = "^" + Regex.Escape(pattern)
            .Replace(@"\*\*", ".*")      // ** matches any path
            .Replace(@"\*", "[^/]*")     // * matches filename chars
            .Replace(@"\?", ".")         // ? matches single char
            + "$";

        return Regex.IsMatch(path, regexPattern, RegexOptions.IgnoreCase);
    }

    #endregion

    #region Scoring

    /// <summary>
    /// Converts L2 distance to similarity score (0-1).
    /// </summary>
    /// <param name="distance">L2 distance from sqlite-vec.</param>
    /// <returns>Similarity score where higher is more similar.</returns>
    /// <remarks>
    /// Uses exponential decay: score = e^(-distance)
    /// - Distance 0 → Score 1.0 (exact match)
    /// - Distance 1 → Score 0.37
    /// - Distance 2 → Score 0.14
    /// </remarks>
    private static float DistanceToScore(float distance)
    {
        return MathF.Exp(-distance);
    }

    #endregion

    #region Search History

    /// <summary>
    /// Records a search in the history table for analytics.
    /// </summary>
    private async Task RecordSearchHistoryAsync(
        string indexId,
        int resultCount,
        float topScore,
        CancellationToken ct)
    {
        try
        {
            await using var cmd = _connection!.CreateCommand();
            cmd.CommandText = """
                INSERT INTO search_history (index_id, result_count, top_score, duration_ms)
                VALUES (@indexId, @resultCount, @topScore, 0)
                """;
            cmd.Parameters.AddWithValue("@indexId", indexId);
            cmd.Parameters.AddWithValue("@resultCount", resultCount);
            cmd.Parameters.AddWithValue("@topScore", topScore);
            await cmd.ExecuteNonQueryAsync(ct);
        }
        catch (Exception ex)
        {
            // Non-critical, just log
            _logger.LogWarning(ex, "Failed to record search history");
        }
    }

    #endregion

    #region Reader Methods

    /// <summary>
    /// Reads a StoredChunk from search query results.
    /// </summary>
    private static StoredChunk ReadStoredChunkFromSearchReader(SqliteDataReader reader)
    {
        return new StoredChunk
        {
            Id = reader.GetString(reader.GetOrdinal("id")),
            IndexId = reader.GetString(reader.GetOrdinal("index_id")),
            FileId = reader.GetString(reader.GetOrdinal("file_id")),
            Content = reader.GetString(reader.GetOrdinal("content")),
            FilePath = reader.GetString(reader.GetOrdinal("file_path")),
            StartLine = reader.GetInt32(reader.GetOrdinal("start_line")),
            EndLine = reader.GetInt32(reader.GetOrdinal("end_line")),
            StartOffset = reader.GetInt32(reader.GetOrdinal("start_offset")),
            EndOffset = reader.GetInt32(reader.GetOrdinal("end_offset")),
            ChunkType = Enum.Parse<ChunkType>(reader.GetString(reader.GetOrdinal("chunk_type"))),
            Language = reader.IsDBNull(reader.GetOrdinal("language"))
                ? null
                : reader.GetString(reader.GetOrdinal("language")),
            SymbolName = reader.IsDBNull(reader.GetOrdinal("symbol_name"))
                ? null
                : reader.GetString(reader.GetOrdinal("symbol_name")),
            SymbolType = reader.IsDBNull(reader.GetOrdinal("symbol_type"))
                ? null
                : Enum.Parse<SymbolType>(reader.GetString(reader.GetOrdinal("symbol_type"))),
            ParentSymbol = reader.IsDBNull(reader.GetOrdinal("parent_symbol"))
                ? null
                : reader.GetString(reader.GetOrdinal("parent_symbol")),
            TokenCount = reader.GetInt32(reader.GetOrdinal("token_count")),
            IndexedAt = DateTime.Parse(reader.GetString(reader.GetOrdinal("indexed_at")))
        };
    }

    #endregion
}
```

### 2. VectorSearchHelper.cs

**Location**: `src/SeniorIntern.Services/VectorStore/VectorSearchHelper.cs`

```csharp
namespace SeniorIntern.Services.VectorStore;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using SeniorIntern.Core.Models;

/// <summary>
/// SIMD-accelerated helper methods for vector search operations.
/// </summary>
public static class VectorSearchHelper
{
    #region Similarity Calculations

    /// <summary>
    /// Calculates cosine similarity between two vectors using SIMD.
    /// </summary>
    /// <param name="a">First vector.</param>
    /// <param name="b">Second vector.</param>
    /// <returns>Cosine similarity (-1 to 1, typically 0 to 1 for embeddings).</returns>
    /// <exception cref="ArgumentException">Vectors must have same dimension.</exception>
    public static float CosineSimilarity(ReadOnlySpan<float> a, ReadOnlySpan<float> b)
    {
        if (a.Length != b.Length)
            throw new ArgumentException("Vectors must have the same dimension");

        if (a.Length == 0)
            return 0;

        float dotProduct = 0;
        float normA = 0;
        float normB = 0;

        // Use SIMD if hardware supports it
        if (Vector.IsHardwareAccelerated && a.Length >= Vector<float>.Count)
        {
            var dotVec = Vector<float>.Zero;
            var normAVec = Vector<float>.Zero;
            var normBVec = Vector<float>.Zero;

            int i = 0;
            int lastBlockIndex = a.Length - (a.Length % Vector<float>.Count);

            for (; i < lastBlockIndex; i += Vector<float>.Count)
            {
                var va = new Vector<float>(a.Slice(i, Vector<float>.Count));
                var vb = new Vector<float>(b.Slice(i, Vector<float>.Count));

                dotVec += va * vb;
                normAVec += va * va;
                normBVec += vb * vb;
            }

            dotProduct = Vector.Sum(dotVec);
            normA = Vector.Sum(normAVec);
            normB = Vector.Sum(normBVec);

            // Handle remaining elements
            for (; i < a.Length; i++)
            {
                dotProduct += a[i] * b[i];
                normA += a[i] * a[i];
                normB += b[i] * b[i];
            }
        }
        else
        {
            // Scalar fallback
            for (int i = 0; i < a.Length; i++)
            {
                dotProduct += a[i] * b[i];
                normA += a[i] * a[i];
                normB += b[i] * b[i];
            }
        }

        var denominator = MathF.Sqrt(normA) * MathF.Sqrt(normB);
        return denominator > 0 ? dotProduct / denominator : 0;
    }

    /// <summary>
    /// Calculates L2 (Euclidean) distance between two vectors using SIMD.
    /// </summary>
    /// <param name="a">First vector.</param>
    /// <param name="b">Second vector.</param>
    /// <returns>Euclidean distance (0 to infinity).</returns>
    public static float L2Distance(ReadOnlySpan<float> a, ReadOnlySpan<float> b)
    {
        if (a.Length != b.Length)
            throw new ArgumentException("Vectors must have the same dimension");

        float sum = 0;

        if (Vector.IsHardwareAccelerated && a.Length >= Vector<float>.Count)
        {
            var sumVec = Vector<float>.Zero;
            int i = 0;
            int lastBlockIndex = a.Length - (a.Length % Vector<float>.Count);

            for (; i < lastBlockIndex; i += Vector<float>.Count)
            {
                var va = new Vector<float>(a.Slice(i, Vector<float>.Count));
                var vb = new Vector<float>(b.Slice(i, Vector<float>.Count));
                var diff = va - vb;
                sumVec += diff * diff;
            }

            sum = Vector.Sum(sumVec);

            for (; i < a.Length; i++)
            {
                var diff = a[i] - b[i];
                sum += diff * diff;
            }
        }
        else
        {
            for (int i = 0; i < a.Length; i++)
            {
                var diff = a[i] - b[i];
                sum += diff * diff;
            }
        }

        return MathF.Sqrt(sum);
    }

    #endregion

    #region Vector Operations

    /// <summary>
    /// Normalizes a vector to unit length in-place using SIMD.
    /// </summary>
    /// <param name="vector">Vector to normalize.</param>
    public static void Normalize(Span<float> vector)
    {
        float norm = 0;

        if (Vector.IsHardwareAccelerated && vector.Length >= Vector<float>.Count)
        {
            var normVec = Vector<float>.Zero;
            int i = 0;
            int lastBlockIndex = vector.Length - (vector.Length % Vector<float>.Count);

            for (; i < lastBlockIndex; i += Vector<float>.Count)
            {
                var v = new Vector<float>(vector.Slice(i, Vector<float>.Count));
                normVec += v * v;
            }

            norm = Vector.Sum(normVec);

            for (; i < vector.Length; i++)
            {
                norm += vector[i] * vector[i];
            }
        }
        else
        {
            foreach (var v in vector)
            {
                norm += v * v;
            }
        }

        norm = MathF.Sqrt(norm);

        if (norm > 0)
        {
            var invNorm = 1.0f / norm;
            for (int i = 0; i < vector.Length; i++)
            {
                vector[i] *= invNorm;
            }
        }
    }

    /// <summary>
    /// Creates a normalized copy of a vector.
    /// </summary>
    /// <param name="vector">Source vector.</param>
    /// <returns>New normalized vector.</returns>
    public static float[] Normalized(ReadOnlySpan<float> vector)
    {
        var result = vector.ToArray();
        Normalize(result);
        return result;
    }

    #endregion

    #region Reranking

    /// <summary>
    /// Reranks search results by combining multiple scoring factors.
    /// </summary>
    /// <param name="results">Results to rerank.</param>
    /// <param name="options">Reranking options.</param>
    /// <returns>Reranked results.</returns>
    public static IReadOnlyList<ChunkSearchResult> RerankResults(
        IEnumerable<ChunkSearchResult> results,
        RerankingOptions options)
    {
        var reranked = results
            .Select(r => r with
            {
                Score = CalculateCombinedScore(r, options)
            })
            .OrderByDescending(r => r.Score)
            .ToList();

        // Update ranks
        for (int i = 0; i < reranked.Count; i++)
        {
            reranked[i] = reranked[i] with { Rank = i + 1 };
        }

        return reranked;
    }

    private static float CalculateCombinedScore(ChunkSearchResult result, RerankingOptions options)
    {
        var score = result.Score * options.SimilarityWeight;

        // Boost for chunks with symbol names
        if (!string.IsNullOrEmpty(result.Chunk.SymbolName))
        {
            score += options.SymbolBoost;
        }

        // Boost for preferred chunk types
        if (options.PreferredChunkTypes?.Contains(result.Chunk.ChunkType) == true)
        {
            score += options.ChunkTypeBoost;
        }

        // Recency boost (more recent files score higher)
        if (options.RecencyWeight > 0)
        {
            var age = DateTime.UtcNow - result.Chunk.IndexedAt;
            var recencyScore = MathF.Exp(-(float)age.TotalDays / 30); // Decay over 30 days
            score += recencyScore * options.RecencyWeight;
        }

        return score;
    }

    #endregion
}
```

### 3. RerankingOptions.cs

**Location**: `src/SeniorIntern.Core/Models/RerankingOptions.cs`

```csharp
namespace SeniorIntern.Core.Models;

using System.Collections.Generic;

/// <summary>
/// Options for reranking search results.
/// </summary>
public sealed class RerankingOptions
{
    /// <summary>
    /// Weight for base vector similarity score.
    /// </summary>
    /// <remarks>Default: 1.0</remarks>
    public float SimilarityWeight { get; init; } = 1.0f;

    /// <summary>
    /// Boost for chunks that have symbol names.
    /// </summary>
    /// <remarks>Default: 0.1</remarks>
    public float SymbolBoost { get; init; } = 0.1f;

    /// <summary>
    /// Boost for preferred chunk types.
    /// </summary>
    /// <remarks>Default: 0.05</remarks>
    public float ChunkTypeBoost { get; init; } = 0.05f;

    /// <summary>
    /// Weight for recency scoring.
    /// </summary>
    /// <remarks>
    /// Set to 0 to disable recency boosting.
    /// Default: 0.0
    /// </remarks>
    public float RecencyWeight { get; init; } = 0.0f;

    /// <summary>
    /// Chunk types to prefer in results.
    /// </summary>
    public IReadOnlyList<ChunkType>? PreferredChunkTypes { get; init; }

    /// <summary>
    /// Default reranking options (no special boosting).
    /// </summary>
    public static RerankingOptions Default => new();

    /// <summary>
    /// Options optimized for code search.
    /// </summary>
    public static RerankingOptions ForCodeSearch => new()
    {
        SimilarityWeight = 1.0f,
        SymbolBoost = 0.15f,
        ChunkTypeBoost = 0.1f,
        PreferredChunkTypes = [ChunkType.Code, ChunkType.TypeDefinition]
    };
}
```

---

## Unit Test Plan

| Test | Description |
|------|-------------|
| `SearchAsync_EmptyIndex_ReturnsEmpty` | Empty index handling |
| `SearchAsync_WithMinScore_FiltersLowScores` | Score filtering |
| `SearchAsync_WithLanguageFilter_FiltersCorrectly` | Language filter |
| `SearchAsync_WithChunkTypeFilter_FiltersCorrectly` | Chunk type filter |
| `SearchAsync_WithFilePatterns_MatchesGlobs` | Glob matching |
| `SearchAsync_WithDeduplication_RemovesOverlaps` | Deduplication |
| `SearchMultipleAsync_CombinesResults_CorrectOrder` | Multi-index |
| `BuildSearchQuery_IncludesAllFilters` | SQL generation |
| `DistanceToScore_ConvertsCorrectly` | Score conversion |
| `DeduplicateResults_KeepsHighestScore` | Dedup algorithm |
| `RangesOverlap_CalculatesCorrectly` | Overlap detection |
| `MatchGlob_HandlesPatterns` | Glob matching |
| `CosineSimilarity_CalculatesCorrectly` | Vector math |
| `L2Distance_CalculatesCorrectly` | Vector math |
| `Normalize_ProducesUnitVector` | Normalization |
| `RerankResults_AppliesBoosts` | Reranking |

---

## File Summary

| File | Location | Purpose | Lines |
|------|----------|---------|-------|
| `SqliteVectorStore.Search.cs` | `Services/VectorStore/` | Search operations | ~400 |
| `VectorSearchHelper.cs` | `Services/VectorStore/` | SIMD vector utilities | ~200 |
| `RerankingOptions.cs` | `Core/Models/` | Reranking configuration | ~60 |

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | `SearchAsync` returns results ordered by similarity |
| AC-2 | MinScore filter excludes low-scoring results |
| AC-3 | Language, ChunkType, SymbolType filters work at SQL level |
| AC-4 | FilePatterns glob matching works correctly |
| AC-5 | Deduplication removes overlapping chunks |
| AC-6 | `SearchMultipleAsync` aggregates across indexes |
| AC-7 | Distance to score conversion produces valid range |
| AC-8 | SIMD helpers produce correct results |
| AC-9 | Reranking applies all boost factors |
| AC-10 | Search history is recorded |

---

## Changelog Entry

```markdown
## v0.7.2g - Vector Search Implementation

### Added
- `SqliteVectorStore.Search.cs` partial class
  - `SearchAsync()` - Single-index vector search
  - `SearchMultipleAsync()` - Cross-index search
  - `BuildSearchQuery()` - Dynamic SQL with filters
  - `AddFilterParameters()` - Parameterized filter values
  - `ExpandContextAsync()` - Context line expansion
  - `DeduplicateResults()` - Overlapping chunk removal
  - `FilterByFilePatterns()` - Glob pattern matching
  - `DistanceToScore()` - L2 distance → similarity
  - `RecordSearchHistoryAsync()` - Analytics recording

- `VectorSearchHelper.cs` static class
  - `CosineSimilarity()` - SIMD cosine similarity
  - `L2Distance()` - SIMD Euclidean distance
  - `Normalize()` - SIMD vector normalization
  - `RerankResults()` - Multi-factor reranking

- `RerankingOptions.cs` model
  - SimilarityWeight, SymbolBoost, ChunkTypeBoost
  - RecencyWeight for temporal boosting
  - PreferredChunkTypes for type preferences
  - ForCodeSearch preset

### Search Features
- SQL-level filtering for Languages, ChunkTypes, SymbolTypes, SymbolNames
- Post-query glob pattern filtering for FilePatterns
- Deduplication with configurable overlap threshold
- Over-fetching (3×) to handle post-filtering
- Search history recording for analytics

### Performance
- SIMD acceleration for vector operations
- Efficient SQL query with parameterized filters
- Lazy context expansion (only when requested)
```

---

## Timeline Estimate

| Version | Estimated Effort |
|---------|------------------|
| v0.7.2g | 1 day |
