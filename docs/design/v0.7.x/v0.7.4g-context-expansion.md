# Design Specification: AIntern v0.7.4g "Context Expansion"

## Overview

**Version**: v0.7.4g  
**Parent**: v0.7.4 Retrieval & Context  
**Focus**: Implement context expansion to include surrounding code lines for better understanding

### Purpose

This sub-version implements context expansion for retrieved chunks:
1. `IContextExpander` - Interface for expanding context around code chunks
2. `FileContextExpander` - Implementation that reads surrounding lines from source files

### Dependencies

**From v0.7.1d (TextChunk Models)**:
- `TextChunk` for chunk data structure with file path and line numbers

**From v0.7.4b (Query & Result Models)**:
- `KnowledgeChunk` for retrieval results that need expansion

**From v0.7.4a (Knowledge Service Interface)**:
- `IContextExpander` interface is defined in Core

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                     v0.7.4g Context Expansion                                 │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  src/SeniorIntern.Core/Interfaces/                                           │
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │  IContextExpander                                                        ││
│  │  ├── ExpandAsync(workspacePath, TextChunk, contextLines)                 ││
│  │  │   └── Returns: expanded content or original on failure                ││
│  │  └── ExpandAsync(workspacePath, KnowledgeChunk, contextLines)            ││
│  │      └── Overload for retrieval results                                  ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
│  src/SeniorIntern.Services/Knowledge/Context/                                │
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │                                                                          ││
│  │  FileContextExpander : IContextExpander                                  ││
│  │  ├── Dependencies                                                        ││
│  │  │   └── ILogger<FileContextExpander> _logger                            ││
│  │  │                                                                        ││
│  │  ├── Internal State                                                      ││
│  │  │   ├── _fileCache: ConcurrentDictionary<string, string[]>              ││
│  │  │   ├── _maxCacheSize: 100 files                                        ││
│  │  │   └── _cacheExpiration: 5 minutes                                     ││
│  │  │                                                                        ││
│  │  ├── ExpandAsync(TextChunk) → Main expansion logic                       ││
│  │  │   ├── Calculate expanded line range                                   ││
│  │  │   ├── Read file lines (with caching)                                  ││
│  │  │   └── Extract expanded content                                        ││
│  │  │                                                                        ││
│  │  ├── ExpandAsync(KnowledgeChunk) → Converts to TextChunk                 ││
│  │  │                                                                        ││
│  │  ├── Cache Management                                                    ││
│  │  │   ├── ClearCache() → Clear all cached files                           ││
│  │  │   └── InvalidateFile(path) → Remove specific file                     ││
│  │  │                                                                        ││
│  │  └── Private Helpers                                                     ││
│  │      └── GetFileLinesAsync() → Read with caching                         ││
│  │                                                                          ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Context Expansion Flow

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                        Context Expansion Pipeline                             │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Input: (workspacePath, chunk, contextLines)                                 │
│     │                                                                        │
│     ▼                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  1. Validate Input                                                       │ │
│  │     - If contextLines <= 0 → return chunk.Content (no expansion)         │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│     │                                                                        │
│     ▼                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  2. Build Full Path                                                      │ │
│  │     - fullPath = Path.Combine(workspacePath, chunk.FilePath)             │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│     │                                                                        │
│     ▼                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  3. Get File Lines (with caching)                                        │ │
│  │     - Check _fileCache for existing lines                                │ │
│  │     - If not cached:                                                     │ │
│  │       ├── Check File.Exists                                              │ │
│  │       ├── Read via File.ReadAllLinesAsync                                │ │
│  │       └── Cache if < 10k lines and cache not full                        │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│     │                                                                        │
│     ▼                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  4. Calculate Expanded Range                                             │ │
│  │     - startIndex = max(0, chunk.StartLine - contextLines - 1)            │ │
│  │     - endIndex = min(lines.Length, chunk.EndLine + contextLines)         │ │
│  │     Note: Convert 1-based line numbers to 0-based array indices          │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│     │                                                                        │
│     ▼                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  5. Extract Expanded Lines                                               │ │
│  │     - lines.Skip(startIndex).Take(endIndex - startIndex)                 │ │
│  │     - Join with newlines                                                 │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│     │                                                                        │
│     ▼                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  Exception Handling                                                      │ │
│  │  - On any failure: log warning, return chunk.Content unchanged           │ │
│  │  - Graceful degradation ensures expansion never breaks retrieval         │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│     │                                                                        │
│     ▼                                                                        │
│  Output: Expanded content string (or original on failure)                    │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Line Range Calculation

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                     Line Range Calculation Example                            │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Given: chunk.StartLine = 25, chunk.EndLine = 30, contextLines = 5           │
│                                                                              │
│  File contents (line numbers):                                               │
│  ┌──────────────────────────────────────────────────────────────────────┐    │
│  │  Line 1:  import { ... }                                             │    │
│  │  ...                                                                 │    │
│  │  Line 20: function helper() {      ← startIndex = 25-5-1 = 19 (0-idx)│    │
│  │  Line 21:   // ...                 ┐                                 │    │
│  │  Line 22:   // ...                 │ Context before                  │    │
│  │  Line 23:   // ...                 │                                 │    │
│  │  Line 24:   // ...                 ┘                                 │    │
│  │  Line 25:   matched code           ┐                                 │    │
│  │  Line 26:   matched code           │ Original chunk                  │    │
│  │  Line 27:   matched code           │ (lines 25-30)                   │    │
│  │  Line 28:   matched code           │                                 │    │
│  │  Line 29:   matched code           │                                 │    │
│  │  Line 30:   matched code           ┘                                 │    │
│  │  Line 31:   // ...                 ┐                                 │    │
│  │  Line 32:   // ...                 │ Context after                   │    │
│  │  Line 33:   // ...                 │                                 │    │
│  │  Line 34:   // ...                 │                                 │    │
│  │  Line 35:   return result;         ┘ endIndex = 30+5 = 35            │    │
│  │  Line 36: }                                                          │    │
│  │  ...                                                                 │    │
│  └──────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  Result: Lines 20-35 (16 lines total = 5 before + 6 chunk + 5 after)         │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Services/Knowledge/Context/FileContextExpander.cs` | Context expansion implementation with file caching |

### Interface Location

The `IContextExpander` interface is defined in Core per v0.7.4a:
- `src/SeniorIntern.Core/Interfaces/IContextExpander.cs`

---

## Detailed Specification

### FileContextExpander.cs

**Location**: `src/SeniorIntern.Services/Knowledge/Context/FileContextExpander.cs`

```csharp
using System;
using System.Collections.Concurrent;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;

namespace SeniorIntern.Services.Knowledge.Context;

/// <summary>
/// Expands context by reading surrounding lines from source files.
/// </summary>
/// <remarks>
/// <para>
/// This implementation:
/// <list type="bullet">
///   <item>Reads source files to get surrounding context lines</item>
///   <item>Caches file contents to improve performance</item>
///   <item>Gracefully falls back to original content on errors</item>
///   <item>Supports cache invalidation for file changes</item>
/// </list>
/// </para>
/// <para>
/// Thread Safety: All methods are thread-safe. The file cache uses
/// ConcurrentDictionary for concurrent access.
/// </para>
/// </remarks>
public sealed class FileContextExpander : IContextExpander
{
    private readonly ILogger<FileContextExpander> _logger;
    private readonly ConcurrentDictionary<string, CachedFileContent> _fileCache = new();
    private readonly int _maxCacheSize = 100;
    private readonly int _maxFileLinesForCache = 10000;
    private readonly TimeSpan _cacheExpiration = TimeSpan.FromMinutes(5);

    public FileContextExpander(ILogger<FileContextExpander> logger)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <summary>
    /// Gets the current number of files in the cache.
    /// </summary>
    public int CacheCount => _fileCache.Count;

    /// <inheritdoc />
    public async Task<string> ExpandAsync(
        string workspacePath,
        TextChunk chunk,
        int contextLines,
        CancellationToken ct = default)
    {
        // No expansion needed
        if (contextLines <= 0)
            return chunk.Content;

        try
        {
            var fullPath = Path.Combine(workspacePath, chunk.FilePath);
            var lines = await GetFileLinesAsync(fullPath, ct);

            if (lines == null || lines.Length == 0)
            {
                _logger.LogDebug("No lines found for expansion: {Path}", chunk.FilePath);
                return chunk.Content;
            }

            // Calculate expanded range (1-based to 0-based conversion)
            var startIndex = Math.Max(0, chunk.StartLine - contextLines - 1);
            var endIndex = Math.Min(lines.Length, chunk.EndLine + contextLines);

            // Validate range
            if (startIndex >= lines.Length || endIndex <= startIndex)
            {
                _logger.LogDebug("Invalid line range for expansion: {Start}-{End}", startIndex, endIndex);
                return chunk.Content;
            }

            // Extract expanded lines
            var expandedLines = lines
                .Skip(startIndex)
                .Take(endIndex - startIndex)
                .ToArray();

            var expanded = string.Join('\n', expandedLines);

            _logger.LogDebug(
                "Expanded context for {File}: lines {Start}-{End} → {ExpandedStart}-{ExpandedEnd}",
                chunk.FilePath,
                chunk.StartLine, chunk.EndLine,
                startIndex + 1, endIndex);

            return expanded;
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Failed to expand context for {File}", chunk.FilePath);
            return chunk.Content;
        }
    }

    /// <inheritdoc />
    public Task<string> ExpandAsync(
        string workspacePath,
        KnowledgeChunk chunk,
        int contextLines,
        CancellationToken ct = default)
    {
        // Convert KnowledgeChunk to TextChunk for expansion
        var textChunk = new TextChunk
        {
            Content = chunk.Content,
            FilePath = chunk.FilePath,
            StartLine = chunk.StartLine,
            EndLine = chunk.EndLine,
            Language = chunk.Language
        };

        return ExpandAsync(workspacePath, textChunk, contextLines, ct);
    }

    /// <summary>
    /// Clear all cached file contents.
    /// </summary>
    public void ClearCache()
    {
        _fileCache.Clear();
        _logger.LogDebug("File cache cleared");
    }

    /// <summary>
    /// Remove a specific file from the cache.
    /// Call when a file is modified to ensure fresh content.
    /// </summary>
    /// <param name="fullPath">Full path to the file to invalidate.</param>
    public void InvalidateFile(string fullPath)
    {
        if (_fileCache.TryRemove(fullPath, out _))
        {
            _logger.LogDebug("Cache invalidated for: {Path}", fullPath);
        }
    }

    /// <summary>
    /// Remove all cached files within a directory.
    /// Useful when a directory is modified.
    /// </summary>
    /// <param name="directoryPath">Directory path to invalidate.</param>
    public void InvalidateDirectory(string directoryPath)
    {
        var keysToRemove = _fileCache.Keys
            .Where(k => k.StartsWith(directoryPath, StringComparison.OrdinalIgnoreCase))
            .ToList();

        foreach (var key in keysToRemove)
        {
            _fileCache.TryRemove(key, out _);
        }

        if (keysToRemove.Count > 0)
        {
            _logger.LogDebug("Cache invalidated for {Count} files in: {Path}", 
                keysToRemove.Count, directoryPath);
        }
    }

    #region Private Helpers

    private async Task<string[]?> GetFileLinesAsync(string fullPath, CancellationToken ct)
    {
        // Check cache (with expiration)
        if (_fileCache.TryGetValue(fullPath, out var cached))
        {
            if (DateTime.UtcNow < cached.ExpiresAt)
            {
                return cached.Lines;
            }
            // Expired - remove from cache
            _fileCache.TryRemove(fullPath, out _);
        }

        // Check file exists
        if (!File.Exists(fullPath))
        {
            _logger.LogDebug("File not found for context expansion: {Path}", fullPath);
            return null;
        }

        try
        {
            var lines = await File.ReadAllLinesAsync(fullPath, ct);

            // Cache if file not too large and cache not full
            if (lines.Length <= _maxFileLinesForCache && _fileCache.Count < _maxCacheSize)
            {
                var cacheEntry = new CachedFileContent
                {
                    Lines = lines,
                    ExpiresAt = DateTime.UtcNow.Add(_cacheExpiration)
                };
                _fileCache.TryAdd(fullPath, cacheEntry);
            }

            return lines;
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Failed to read file for context expansion: {Path}", fullPath);
            return null;
        }
    }

    #endregion

    #region Nested Types

    private sealed class CachedFileContent
    {
        public required string[] Lines { get; init; }
        public required DateTime ExpiresAt { get; init; }
    }

    #endregion
}
```

---

## Unit Testing Requirements

| Component | Test Count | Focus Areas |
|-----------|------------|-------------|
| `FileContextExpander.ExpandAsync(TextChunk)` | 12-15 | Line range calculation, edge cases |
| `FileContextExpander.ExpandAsync(KnowledgeChunk)` | 3-4 | Conversion to TextChunk |
| `FileContextExpander.Cache*` | 6-8 | Caching, invalidation, expiration |
| `FileContextExpander.GetFileLinesAsync` | 4-5 | File read, cache behavior |

**Total: ~25-32 tests**

### Test Scenarios

```
ExpandAsync Tests:
├── ExpandAsync_ZeroContextLines_ReturnsOriginal
├── ExpandAsync_NegativeContextLines_ReturnsOriginal
├── ExpandAsync_ValidChunk_ExpandsCorrectly
├── ExpandAsync_StartOfFile_ClampsToZero
├── ExpandAsync_EndOfFile_ClampsToLength
├── ExpandAsync_FileNotFound_ReturnsOriginal
├── ExpandAsync_EmptyFile_ReturnsOriginal
├── ExpandAsync_SingleLineFile_HandlesCorrectly
├── ExpandAsync_LargeContextLines_IncludesWholeFile
├── ExpandAsync_KnowledgeChunk_ConvertsAndExpands
└── ExpandAsync_ReadError_ReturnsOriginalWithWarning

Cache Tests:
├── GetFileLinesAsync_CachesSmallFiles
├── GetFileLinesAsync_DoesNotCacheLargeFiles
├── GetFileLinesAsync_ReturnsFromCache
├── ClearCache_RemovesAllEntries
├── InvalidateFile_RemovesSpecificFile
├── InvalidateDirectory_RemovesAllFilesInDir
└── GetFileLinesAsync_RespectsCacheExpiration

Line Calculation Tests:
├── CalculateRange_CorrectForMiddleOfFile
├── CalculateRange_HandlesStartOfFile
├── CalculateRange_HandlesEndOfFile
└── CalculateRange_HandlesSmallFile
```

---

## Acceptance Criteria

### Functional Requirements
- [ ] `ExpandAsync` returns original content when `contextLines <= 0`
- [ ] `ExpandAsync` correctly calculates expanded line range
- [ ] `ExpandAsync` clamps to file boundaries (doesn't exceed file length)
- [ ] `ExpandAsync` converts 1-based line numbers to 0-based array indices
- [ ] `ExpandAsync` gracefully returns original content on errors
- [ ] File cache stores content for up to 5 minutes
- [ ] File cache limits to 100 files and 10k lines per file
- [ ] `InvalidateFile` removes specific file from cache
- [ ] `InvalidateDirectory` removes all files in a directory from cache
- [ ] `KnowledgeChunk` overload correctly converts to `TextChunk`

### Quality Requirements
- [ ] All public methods have XML documentation
- [ ] Thread-safe cache using `ConcurrentDictionary`
- [ ] Logging at Debug level for expansion operations
- [ ] Logging at Warning level for failures

---

## Future Considerations

Items deferred to later versions:
- **Future**: Smart expansion that follows code structure (expand to function/class boundaries)
- **Future**: Integration with file watcher for automatic cache invalidation
- **Future**: Configurable cache size and expiration via options
