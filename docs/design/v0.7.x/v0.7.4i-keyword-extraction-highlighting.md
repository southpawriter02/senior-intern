# Design Specification: AIntern v0.7.4i "Keyword Extraction & Highlighting"

## Overview

**Version**: v0.7.4i  
**Parent**: v0.7.4 Retrieval & Context  
**Focus**: Implement keyword extraction for queries and highlighting in search results

### Purpose

This sub-version implements keyword extraction and text highlighting:
1. `KeywordExtractor` - Extracts keywords from query strings for reranking and highlighting
2. `TextHighlighter` - Finds and applies highlight markers to matching text

### Dependencies

**From v0.7.4b (Query & Result Models)**:
- `TextHighlight` model for highlight positions

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                     v0.7.4i Keyword Extraction & Highlighting                 │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  src/SeniorIntern.Services/Knowledge/                                        │
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │                                                                          ││
│  │  KeywordExtractor                                                        ││
│  │  ├── Static Data                                                         ││
│  │  │   ├── StopWords: HashSet<string> (common words to filter)             ││
│  │  │   │   ├── English stop words (a, the, is, are, etc.)                  ││
│  │  │   │   └── Common programming keywords (function, method, class, etc.) ││
│  │  │   └── ProgrammingKeywords: HashSet<string> (preserved terms)          ││
│  │  │       └── Keywords to keep (async, await, interface, enum, etc.)      ││
│  │  │                                                                        ││
│  │  ├── Extract(query, includeCodeTerms) → List<string>                     ││
│  │  │   ├── Split on whitespace and delimiters                              ││
│  │  │   ├── Filter stop words (unless preserved)                            ││
│  │  │   ├── Split camelCase/PascalCase → ["User", "Service"]                ││
│  │  │   └── Split snake_case → ["user", "service"]                          ││
│  │  │                                                                        ││
│  │  ├── ExtractQuotedPhrases(query) → List<string>                          ││
│  │  │   └── Extract "exact phrase" matches from query                       ││
│  │  │                                                                        ││
│  │  └── Private Helpers                                                     ││
│  │      ├── HasMixedCase() → Detect camelCase/PascalCase                    ││
│  │      └── SplitCamelCase() → Split on uppercase boundaries                ││
│  │                                                                          ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │                                                                          ││
│  │  TextHighlighter                                                         ││
│  │  ├── Dependencies                                                        ││
│  │  │   └── KeywordExtractor _keywordExtractor                              ││
│  │  │                                                                        ││
│  │  ├── FindHighlights(content, query) → List<TextHighlight>                ││
│  │  │   ├── Find quoted phrase matches (exact)                              ││
│  │  │   ├── Find keyword matches (word boundary)                            ││
│  │  │   └── Remove overlapping highlights                                   ││
│  │  │                                                                        ││
│  │  ├── ApplyHighlights(content, highlights, openTag, closeTag)             ││
│  │  │   └── Insert markers at highlight positions                           ││
│  │  │                                                                        ││
│  │  └── Private Helpers                                                     ││
│  │      ├── FindMatches() → Regex match positions                           ││
│  │      └── RemoveOverlaps() → Deduplicate, prefer longer                   ││
│  │                                                                          ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Keyword Extraction Pipeline

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                        Keyword Extraction Pipeline                            │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Input: "Find the UserService authentication method"                         │
│     │                                                                        │
│     ▼                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  1. Tokenize                                                             │ │
│  │     - Split on: whitespace, punctuation [\s\.,;:!?\-\(\)\[\]{}"'`]       │ │
│  │     - Result: ["Find", "the", "UserService", "authentication", "method"] │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│     │                                                                        │
│     ▼                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  2. Filter Stop Words                                                    │ │
│  │     - Remove: "Find" (too short: 4 chars, but not in stop list)          │ │
│  │     - Remove: "the" (in StopWords)                                       │ │
│  │     - Keep: "UserService", "authentication", "method"                    │ │
│  │     - Note: "method" is in StopWords but NOT in ProgrammingKeywords      │ │
│  │     - Result: ["Find", "UserService", "authentication"]                  │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│     │                                                                        │
│     ▼                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  3. Split Compound Identifiers                                           │ │
│  │     - "UserService" → ["User", "Service"] (camelCase split)              │ │
│  │     - "user_service" → ["user", "service"] (snake_case split)            │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│     │                                                                        │
│     ▼                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  4. Deduplicate & Normalize                                              │ │
│  │     - Convert to lowercase                                               │ │
│  │     - Remove duplicates                                                  │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│     │                                                                        │
│     ▼                                                                        │
│  Output: ["find", "userservice", "authentication", "user", "service"]        │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Highlighting Pipeline

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                        Text Highlighting Pipeline                             │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Input: content = "public class UserService { ... }"                         │
│         query = "UserService \"public class\""                               │
│     │                                                                        │
│     ▼                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  1. Extract Quoted Phrases (Exact Match)                                 │ │
│  │     - Pattern: "([^"]+)"                                                 │ │
│  │     - Found: ["public class"]                                            │ │
│  │     - Match at position 0, length 12                                     │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│     │                                                                        │
│     ▼                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  2. Extract Keywords (Word Boundary Match)                               │ │
│  │     - Keywords: ["userservice", "user", "service"]                       │ │
│  │     - Pattern: \bUserService\b (case-insensitive)                        │ │
│  │     - Match at position 13, length 11                                    │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│     │                                                                        │
│     ▼                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  3. Remove Overlaps                                                      │ │
│  │     - Sort by start position, then by length (longer first)              │ │
│  │     - For overlapping highlights, keep the first (longer) one            │ │
│  │     - Ensures no double-highlighting                                     │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│     │                                                                        │
│     ▼                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  4. Apply Markers                                                        │ │
│  │     - Insert from end to start (preserves positions)                     │ │
│  │     - Default markers: ** (markdown bold)                                │ │
│  │     - Result: "**public class** **UserService** { ... }"                 │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│     │                                                                        │
│     ▼                                                                        │
│  Output: Highlighted content string                                          │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Services/Knowledge/KeywordExtractor.cs` | Query keyword extraction |
| `src/SeniorIntern.Services/Knowledge/TextHighlighter.cs` | Text highlighting with keywords |

---

## Detailed Specifications

### 1. KeywordExtractor.cs

**Location**: `src/SeniorIntern.Services/Knowledge/KeywordExtractor.cs`

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;

namespace SeniorIntern.Services.Knowledge;

/// <summary>
/// Extracts keywords from queries for highlighting and reranking.
/// </summary>
/// <remarks>
/// <para>
/// The extractor handles:
/// <list type="bullet">
///   <item>Stop word filtering (common English words)</item>
///   <item>Compound identifier splitting (camelCase, PascalCase, snake_case)</item>
///   <item>Quoted phrase extraction for exact matches</item>
///   <item>Programming keyword preservation</item>
/// </list>
/// </para>
/// </remarks>
public sealed class KeywordExtractor
{
    private static readonly HashSet<string> StopWords = new(StringComparer.OrdinalIgnoreCase)
    {
        // Common English stop words
        "a", "an", "the", "is", "are", "was", "were", "be", "been",
        "being", "have", "has", "had", "do", "does", "did", "will",
        "would", "could", "should", "may", "might", "must", "shall",
        "can", "need", "to", "of", "in", "for", "on", "with", "at",
        "by", "from", "as", "into", "through", "during", "before",
        "after", "where", "how", "what", "which", "who", "this",
        "that", "or", "and", "but", "if", "not", "all", "any",
        // Programming-related common words (filter these)
        "function", "method", "class", "var", "let", "const", "return",
        "public", "private", "protected", "static", "void", "int",
        "string", "bool", "true", "false", "null", "new", "get", "set"
    };

    private static readonly HashSet<string> ProgrammingKeywords = new(StringComparer.OrdinalIgnoreCase)
    {
        // Preserve these programming keywords even if common
        "async", "await", "interface", "abstract", "override", "virtual",
        "sealed", "readonly", "enum", "struct", "namespace",
        "using", "import", "export", "default", "extends", "implements"
    };

    /// <summary>
    /// Extract keywords from a query string.
    /// </summary>
    /// <param name="query">The query string.</param>
    /// <param name="includeCodeTerms">Whether to preserve code-related terms.</param>
    /// <returns>List of extracted keywords (lowercase, deduplicated).</returns>
    public IReadOnlyList<string> Extract(string query, bool includeCodeTerms = true)
    {
        if (string.IsNullOrWhiteSpace(query))
            return Array.Empty<string>();

        var keywords = new List<string>();

        // Split on whitespace and common delimiters
        var tokens = Regex.Split(query, @"[\s\.,;:!?\-\(\)\[\]{}""'`]+")
            .Where(t => !string.IsNullOrEmpty(t))
            .ToList();

        foreach (var token in tokens)
        {
            // Skip stop words unless they're programming keywords we want to keep
            if (StopWords.Contains(token) && !ProgrammingKeywords.Contains(token))
                continue;

            // Skip very short tokens
            if (token.Length < 2)
                continue;

            // Add the token
            keywords.Add(token.ToLowerInvariant());

            // Split camelCase/PascalCase
            if (HasMixedCase(token))
            {
                var parts = SplitCamelCase(token);
                keywords.AddRange(parts
                    .Where(p => p.Length >= 2 && !StopWords.Contains(p))
                    .Select(p => p.ToLowerInvariant()));
            }

            // Split snake_case
            if (token.Contains('_'))
            {
                var parts = token.Split('_', StringSplitOptions.RemoveEmptyEntries);
                keywords.AddRange(parts
                    .Where(p => p.Length >= 2 && !StopWords.Contains(p))
                    .Select(p => p.ToLowerInvariant()));
            }
        }

        return keywords.Distinct().ToList();
    }

    /// <summary>
    /// Extract quoted phrases as exact match terms.
    /// </summary>
    /// <param name="query">The query string.</param>
    /// <returns>List of quoted phrases.</returns>
    public IReadOnlyList<string> ExtractQuotedPhrases(string query)
    {
        if (string.IsNullOrWhiteSpace(query))
            return Array.Empty<string>();

        var phrases = new List<string>();
        var matches = Regex.Matches(query, @"""([^""]+)""");

        foreach (Match match in matches)
        {
            if (match.Groups.Count > 1 && !string.IsNullOrWhiteSpace(match.Groups[1].Value))
            {
                phrases.Add(match.Groups[1].Value);
            }
        }

        return phrases;
    }

    /// <summary>
    /// Extract all search terms (keywords and phrases).
    /// </summary>
    /// <param name="query">The query string.</param>
    /// <returns>Tuple of (keywords, phrases).</returns>
    public (IReadOnlyList<string> Keywords, IReadOnlyList<string> Phrases) ExtractAll(string query)
    {
        return (Extract(query), ExtractQuotedPhrases(query));
    }

    private static bool HasMixedCase(string word)
    {
        bool hasUpper = false, hasLower = false;
        foreach (var c in word)
        {
            if (char.IsUpper(c)) hasUpper = true;
            if (char.IsLower(c)) hasLower = true;
            if (hasUpper && hasLower) return true;
        }
        return false;
    }

    private static IEnumerable<string> SplitCamelCase(string input)
    {
        // Split "UserService" into ["User", "Service"]
        return Regex.Split(input, @"(?<!^)(?=[A-Z])")
            .Where(s => !string.IsNullOrEmpty(s));
    }
}
```

---

### 2. TextHighlighter.cs

**Location**: `src/SeniorIntern.Services/Knowledge/TextHighlighter.cs`

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using SeniorIntern.Core.Models;

namespace SeniorIntern.Services.Knowledge;

/// <summary>
/// Highlights keywords in text content.
/// </summary>
/// <remarks>
/// <para>
/// The highlighter:
/// <list type="bullet">
///   <item>Finds all keyword matches in content</item>
///   <item>Handles quoted phrases as exact matches</item>
///   <item>Removes overlapping highlights (prefers longer matches)</item>
///   <item>Applies customizable highlight markers</item>
/// </list>
/// </para>
/// </remarks>
public sealed class TextHighlighter
{
    private readonly KeywordExtractor _keywordExtractor;

    public TextHighlighter(KeywordExtractor keywordExtractor)
    {
        _keywordExtractor = keywordExtractor ?? throw new ArgumentNullException(nameof(keywordExtractor));
    }

    /// <summary>
    /// Find highlight positions for keywords in content.
    /// </summary>
    /// <param name="content">The content to search.</param>
    /// <param name="query">The original query.</param>
    /// <returns>List of highlight positions.</returns>
    public IReadOnlyList<TextHighlight> FindHighlights(string content, string query)
    {
        if (string.IsNullOrWhiteSpace(content) || string.IsNullOrWhiteSpace(query))
            return Array.Empty<TextHighlight>();

        var highlights = new List<TextHighlight>();

        // Find quoted phrase matches (exact)
        var phrases = _keywordExtractor.ExtractQuotedPhrases(query);
        foreach (var phrase in phrases)
        {
            highlights.AddRange(FindMatches(content, phrase, isExact: true));
        }

        // Find keyword matches (word boundary)
        var keywords = _keywordExtractor.Extract(query);
        foreach (var keyword in keywords)
        {
            highlights.AddRange(FindMatches(content, keyword, isExact: false));
        }

        return RemoveOverlaps(highlights);
    }

    /// <summary>
    /// Find highlight positions for specific keywords.
    /// </summary>
    /// <param name="content">The content to search.</param>
    /// <param name="keywords">Keywords to find.</param>
    /// <returns>List of highlight positions.</returns>
    public IReadOnlyList<TextHighlight> FindHighlightsForKeywords(
        string content, IEnumerable<string> keywords)
    {
        if (string.IsNullOrWhiteSpace(content))
            return Array.Empty<TextHighlight>();

        var highlights = new List<TextHighlight>();
        foreach (var keyword in keywords)
        {
            if (!string.IsNullOrWhiteSpace(keyword))
            {
                highlights.AddRange(FindMatches(content, keyword, isExact: false));
            }
        }

        return RemoveOverlaps(highlights);
    }

    /// <summary>
    /// Apply highlight markers to content.
    /// </summary>
    /// <param name="content">The content to highlight.</param>
    /// <param name="highlights">Highlight positions.</param>
    /// <param name="openTag">Opening tag/marker. Default: **</param>
    /// <param name="closeTag">Closing tag/marker. Default: **</param>
    /// <returns>Content with highlight markers inserted.</returns>
    public string ApplyHighlights(
        string content,
        IReadOnlyList<TextHighlight> highlights,
        string openTag = "**",
        string closeTag = "**")
    {
        if (string.IsNullOrEmpty(content) || highlights.Count == 0)
            return content;

        // Sort by position (descending) to insert from end to start
        var sortedHighlights = highlights
            .OrderByDescending(h => h.Start)
            .ToList();

        var result = content;
        foreach (var highlight in sortedHighlights)
        {
            var end = highlight.Start + highlight.Length;
            if (highlight.Start >= 0 && end <= result.Length)
            {
                result = result.Insert(end, closeTag);
                result = result.Insert(highlight.Start, openTag);
            }
        }

        return result;
    }

    /// <summary>
    /// Find highlights and apply markers in one step.
    /// </summary>
    public string HighlightContent(
        string content,
        string query,
        string openTag = "**",
        string closeTag = "**")
    {
        var highlights = FindHighlights(content, query);
        return ApplyHighlights(content, highlights, openTag, closeTag);
    }

    #region Private Helpers

    private static IEnumerable<TextHighlight> FindMatches(string content, string term, bool isExact)
    {
        if (string.IsNullOrEmpty(term))
            yield break;

        var pattern = isExact
            ? Regex.Escape(term)
            : $@"\b{Regex.Escape(term)}\b";

        MatchCollection matches;
        try
        {
            matches = Regex.Matches(content, pattern, RegexOptions.IgnoreCase);
        }
        catch (RegexMatchTimeoutException)
        {
            yield break;
        }

        foreach (Match match in matches)
        {
            yield return new TextHighlight
            {
                Start = match.Index,
                Length = match.Length,
                MatchedKeyword = term
            };
        }
    }

    private static IReadOnlyList<TextHighlight> RemoveOverlaps(List<TextHighlight> highlights)
    {
        if (highlights.Count <= 1)
            return highlights;

        // Sort by start position, then by length (longer first)
        var sorted = highlights
            .OrderBy(h => h.Start)
            .ThenByDescending(h => h.Length)
            .ToList();

        var result = new List<TextHighlight>();
        var currentEnd = -1;

        foreach (var highlight in sorted)
        {
            // Skip if this highlight overlaps with the previous one
            if (highlight.Start < currentEnd)
                continue;

            result.Add(highlight);
            currentEnd = highlight.Start + highlight.Length;
        }

        return result;
    }

    #endregion
}
```

---

## Stop Words Reference

### English Stop Words (Filtered)
```
a, an, the, is, are, was, were, be, been, being, have, has, had,
do, does, did, will, would, could, should, may, might, must, shall,
can, need, to, of, in, for, on, with, at, by, from, as, into,
through, during, before, after, where, how, what, which, who, this,
that, or, and, but, if, not, all, any
```

### Programming Words (Filtered)
```
function, method, class, var, let, const, return, public, private,
protected, static, void, int, string, bool, true, false, null,
new, get, set
```

### Programming Keywords (Preserved)
```
async, await, interface, abstract, override, virtual, sealed,
readonly, enum, struct, namespace, using, import, export,
default, extends, implements
```

---

## Unit Testing Requirements

| Component | Test Count | Focus Areas |
|-----------|------------|-------------|
| `KeywordExtractor.Extract` | 10-12 | Stop words, identifier splitting, edge cases |
| `KeywordExtractor.ExtractQuotedPhrases` | 4-5 | Quote patterns, empty handling |
| `TextHighlighter.FindHighlights` | 8-10 | Match finding, overlap removal |
| `TextHighlighter.ApplyHighlights` | 5-6 | Marker insertion, position handling |

**Total: ~27-33 tests**

### Test Scenarios

```
KeywordExtractor Tests:
├── Extract_EmptyQuery_ReturnsEmpty
├── Extract_SingleWord_ReturnsKeyword
├── Extract_StopWords_FiltersCorrectly
├── Extract_ProgrammingKeywords_Preserves
├── Extract_CamelCase_SplitsCorrectly
├── Extract_PascalCase_SplitsCorrectly
├── Extract_SnakeCase_SplitsCorrectly
├── Extract_ShortTokens_Skipped
├── Extract_Duplicates_Removed
├── ExtractQuotedPhrases_NoQuotes_ReturnsEmpty
├── ExtractQuotedPhrases_SinglePhrase_ReturnsPhrase
└── ExtractQuotedPhrases_MultiplePhrases_ReturnsAll

TextHighlighter Tests:
├── FindHighlights_EmptyContent_ReturnsEmpty
├── FindHighlights_NoMatches_ReturnsEmpty
├── FindHighlights_SingleMatch_ReturnsPosition
├── FindHighlights_MultipleMatches_ReturnsAll
├── FindHighlights_QuotedPhrase_ExactMatch
├── FindHighlights_Overlapping_RemovesDuplicates
├── ApplyHighlights_NoHighlights_ReturnsOriginal
├── ApplyHighlights_SingleHighlight_InsertsMarkers
├── ApplyHighlights_MultipleHighlights_AllMarked
├── ApplyHighlights_CustomMarkers_UsesProvided
└── HighlightContent_EndToEnd_Works
```

---

## Acceptance Criteria

### Functional Requirements
- [ ] `KeywordExtractor.Extract` filters stop words correctly
- [ ] `KeywordExtractor.Extract` preserves programming keywords (async, await, etc.)
- [ ] `KeywordExtractor.Extract` splits camelCase correctly
- [ ] `KeywordExtractor.Extract` splits snake_case correctly
- [ ] `KeywordExtractor.ExtractQuotedPhrases` extracts quoted text
- [ ] `TextHighlighter.FindHighlights` finds all keyword matches
- [ ] `TextHighlighter.FindHighlights` removes overlapping highlights
- [ ] `TextHighlighter.ApplyHighlights` inserts markers correctly
- [ ] Overlap removal prefers longer matches

### Quality Requirements
- [ ] All public methods have XML documentation
- [ ] Case-insensitive matching
- [ ] Word boundary matching for keywords (not phrases)
- [ ] Graceful handling of regex edge cases

---

## Future Considerations

Items deferred to later versions:
- **Future**: Stemming/lemmatization for better matching
- **Future**: Language-specific stop word lists
- **Future**: Synonym expansion for keywords
- **Future**: Fuzzy matching for typo tolerance
