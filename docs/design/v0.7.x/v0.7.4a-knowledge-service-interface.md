# Design Specification: AIntern v0.7.4a "Knowledge Service Interface"

## Overview

**Version**: v0.7.4a  
**Parent**: v0.7.4 Retrieval & Context  
**Focus**: Define the core interfaces and contracts for high-level knowledge retrieval operations

### Purpose

This sub-version defines the foundational interfaces for the retrieval and context layer:
1. `IKnowledgeService` - High-level orchestrator for RAG operations
2. `IRerankingStrategy` - Pluggable interface for result reranking algorithms
3. `IContextAssembler` - Interface for formatting retrieved knowledge into LLM prompts
4. `IContextExpander` - Interface for expanding context around matched chunks

### Dependencies

**From v0.7.1 (Embedding Foundation)**:
- `IEmbeddingService` for generating query embeddings (v0.7.1a)
- `TextChunk` model for chunk structure (v0.7.1d)

**From v0.7.2 (Vector Storage)**:
- `IVectorStore` for vector search operations (v0.7.2a)
- `VectorIndex` model (v0.7.2b)
- `ChunkSearchResult` model (v0.7.2c)
- `VectorSearchOptions` model (v0.7.2c)

**From v0.7.3 (Indexing Pipeline)**:
- `IIndexingService` for index status checking (v0.7.3a)

**Forward References (defined in later v0.7.4 sub-versions)**:
- `KnowledgeQueryOptions` (v0.7.4b)
- `KnowledgeQueryResult` (v0.7.4b)
- `KnowledgeChunk` (v0.7.4b)
- `KnowledgeIndexHealth` (v0.7.4b)
- `RelevantFile` (v0.7.4b)
- `ContextBuildOptions` (v0.7.4c)
- `ContextBuildResult` (v0.7.4c)

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                     v0.7.4a Knowledge Service Interfaces                      │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  src/SeniorIntern.Core/Interfaces/                                           │
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │                                                                          ││
│  │  IKnowledgeService                                                       ││
│  │  ├── Query Operations                                                    ││
│  │  │   ├── QueryAsync()                 → Semantic search with reranking   ││
│  │  │   └── FindRelevantFilesAsync()     → File-level relevance discovery  ││
│  │  │                                                                        ││
│  │  ├── Context Building                                                    ││
│  │  │   ├── BuildContextAsync()          → Query → chunks → context        ││
│  │  │   └── BuildContextFromChunksAsync() → Chunks → formatted context     ││
│  │  │                                                                        ││
│  │  ├── Index Status                                                        ││
│  │  │   ├── IsIndexedAsync()             → Check workspace index exists    ││
│  │  │   └── GetIndexHealthAsync()        → Index statistics & health       ││
│  │  │                                                                        ││
│  │  └── Query Assistance                                                    ││
│  │      └── GetQuerySuggestionsAsync()   → Symbol-based suggestions        ││
│  │                                                                          ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │  IRerankingStrategy                                                      ││
│  │  ├── Properties: Name, RequiresQueryText                                 ││
│  │  └── RerankAsync()     → Reorder and re-score search results            ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │  IContextAssembler                                                       ││
│  │  ├── AssembleAsync()         → Assemble chunks into context string      ││
│  │  ├── FormatChunk()           → Format single chunk for output           ││
│  │  └── EstimateTokens()        → Token count estimation                   ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │  IContextExpander                                                        ││
│  │  ├── ExpandAsync()           → Add surrounding lines to chunk           ││
│  │  └── ExpandBatchAsync()      → Batch expansion for multiple chunks      ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Interface Relationships

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                        Knowledge Retrieval Flow                               │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  User/Chat Interface                                                         │
│     │                                                                        │
│     │  "Where is the database connection handled?"                           │
│     ▼                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                       IKnowledgeService                                  │ │
│  │                                                                          │ │
│  │  QueryAsync() ────────────────────────────────────────────────────────┐  │ │
│  │       │                                                                │  │ │
│  │       ▼                                                                │  │ │
│  │  ┌───────────────────┐    ┌───────────────────┐                       │  │ │
│  │  │  IEmbeddingService│    │    IVectorStore   │                       │  │ │
│  │  │  (from v0.7.1)    │───▶│   (from v0.7.2)   │                       │  │ │
│  │  │  Generate query   │    │   Vector search   │                       │  │ │
│  │  │  embedding        │    │   Top-k results   │                       │  │ │
│  │  └───────────────────┘    └────────┬──────────┘                       │  │ │
│  │                                    │                                  │  │ │
│  │                                    ▼                                  │  │ │
│  │                     ┌───────────────────────────┐                     │  │ │
│  │                     │   IRerankingStrategy      │                     │  │ │
│  │                     │   KeywordBoost / RRF      │                     │  │ │
│  │                     │   Re-score results        │                     │  │ │
│  │                     └───────────────┬───────────┘                     │  │ │
│  │                                     │                                 │  │ │
│  │                                     ▼                                 │  │ │
│  │                     ┌───────────────────────────┐                     │  │ │
│  │                     │   IContextExpander        │                     │  │ │
│  │                     │   Add surrounding lines   │                     │  │ │
│  │                     └───────────────┬───────────┘                     │  │ │
│  │                                     │                                 │  │ │
│  │                                     ▼                                 │  │ │
│  │  BuildContextAsync() ◀─────────────────────────────────────────────────  │ │
│  │       │                                                                   │ │
│  │       ▼                                                                   │ │
│  │  ┌───────────────────────────────────────────────────────────────────┐   │ │
│  │  │                    IContextAssembler                               │   │ │
│  │  │   Format chunks → Apply token budgeting → Build context string    │   │ │
│  │  └───────────────────────────────────────────────────────────────────┘   │ │
│  └──────────────────────────────────────────────────────────────────────────┘ │
│                                     │                                        │
│                                     ▼                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                              Output                                      │ │
│  │  "The database connection is handled in src/Data/DbContext.cs..."       │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/IKnowledgeService.cs` | High-level knowledge retrieval orchestrator interface |
| `src/SeniorIntern.Core/Interfaces/IRerankingStrategy.cs` | Pluggable reranking algorithm interface |
| `src/SeniorIntern.Core/Interfaces/IContextAssembler.cs` | Context formatting and assembly interface |
| `src/SeniorIntern.Core/Interfaces/IContextExpander.cs` | Context expansion around matched chunks interface |

---

## Detailed Specifications

### 1. IKnowledgeService.cs

**Location**: `src/SeniorIntern.Core/Interfaces/IKnowledgeService.cs`

```csharp
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using SeniorIntern.Core.Models;

namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// High-level knowledge retrieval service for RAG (Retrieval-Augmented Generation).
/// Provides semantic search over indexed codebases and context assembly for LLM prompts.
/// </summary>
/// <remarks>
/// <para>
/// The knowledge service orchestrates the complete retrieval pipeline:
/// <list type="number">
///   <item>Generate query embedding using IEmbeddingService</item>
///   <item>Search vector store for similar chunks using IVectorStore</item>
///   <item>Apply reranking strategies to improve relevance</item>
///   <item>Expand context around matched chunks</item>
///   <item>Assemble formatted context for LLM prompts</item>
/// </list>
/// </para>
/// <para>
/// Thread safety: All methods are thread-safe. Query caching is implemented
/// internally to improve performance for repeated queries.
/// </para>
/// <para>
/// Performance considerations:
/// <list type="bullet">
///   <item>Query results are cached for 5 minutes by default</item>
///   <item>Batch operations are preferred over individual calls</item>
///   <item>Token estimation uses efficient character-based approximation</item>
/// </list>
/// </para>
/// </remarks>
/// <example>
/// Basic usage:
/// <code>
/// var result = await knowledgeService.QueryAsync(
///     "Where is authentication handled?",
///     new KnowledgeQueryOptions
///     {
///         WorkspacePath = "/path/to/workspace",
///         MaxResults = 10,
///         Reranking = RerankingStrategy.KeywordBoost
///     });
/// 
/// foreach (var chunk in result.Chunks)
/// {
///     Console.WriteLine($"{chunk.FilePath}:{chunk.StartLine} - {chunk.Relevance:P0}");
/// }
/// </code>
/// </example>
public interface IKnowledgeService
{
    #region Query Operations

    /// <summary>
    /// Query the knowledge base with a natural language question.
    /// Returns relevant code chunks with relevance scores.
    /// </summary>
    /// <param name="question">
    /// The natural language query or code search term.
    /// Examples: "Where is the database connection handled?",
    /// "UserService authentication", "async Task pattern".
    /// </param>
    /// <param name="options">
    /// Query options including workspace path, filters, and reranking strategy.
    /// See <see cref="KnowledgeQueryOptions"/> for available options.
    /// </param>
    /// <param name="ct">Cancellation token for async operation.</param>
    /// <returns>
    /// Query result containing:
    /// <list type="bullet">
    ///   <item>Relevant chunks ordered by relevance score</item>
    ///   <item>Unique file paths containing matches</item>
    ///   <item>Query timing and cache hit information</item>
    ///   <item>The generated query embedding (for debugging)</item>
    /// </list>
    /// </returns>
    /// <exception cref="ArgumentException">
    /// Thrown when question is null, empty, or whitespace.
    /// </exception>
    /// <exception cref="ArgumentException">
    /// Thrown when options.WorkspacePath is null or empty.
    /// </exception>
    /// <exception cref="InvalidOperationException">
    /// Thrown when no embedding model is loaded.
    /// </exception>
    /// <exception cref="KnowledgeQueryException">
    /// Thrown when query embedding generation fails.
    /// </exception>
    Task<KnowledgeQueryResult> QueryAsync(
        string question,
        KnowledgeQueryOptions options,
        CancellationToken ct = default);

    /// <summary>
    /// Get relevant files for a query without full content.
    /// Useful for showing file suggestions or navigation.
    /// </summary>
    /// <param name="query">The search query (natural language or code terms).</param>
    /// <param name="workspacePath">Absolute path to the workspace to search in.</param>
    /// <param name="maxFiles">Maximum number of files to return. Default: 10.</param>
    /// <param name="ct">Cancellation token for async operation.</param>
    /// <returns>
    /// List of relevant files with:
    /// <list type="bullet">
    ///   <item>File path relative to workspace</item>
    ///   <item>Aggregate relevance score</item>
    ///   <item>Number of matching chunks</item>
    ///   <item>Brief summary or preview</item>
    /// </list>
    /// </returns>
    /// <remarks>
    /// <para>
    /// This method aggregates chunk-level results by file, taking the
    /// maximum relevance score as the file's relevance. Files are sorted
    /// by relevance, then by match count.
    /// </para>
    /// <para>
    /// Uses a lower relevance threshold (0.4) than QueryAsync to capture
    /// more potential matches for file-level discovery.
    /// </para>
    /// </remarks>
    Task<IReadOnlyList<RelevantFile>> FindRelevantFilesAsync(
        string query,
        string workspacePath,
        int maxFiles = 10,
        CancellationToken ct = default);

    #endregion

    #region Context Building

    /// <summary>
    /// Build context string for an LLM prompt from retrieved knowledge.
    /// Assembles relevant code into a formatted context block with token budgeting.
    /// </summary>
    /// <param name="question">The user's question to retrieve context for.</param>
    /// <param name="options">
    /// Context building options including:
    /// <list type="bullet">
    ///   <item>Token budget and chunk limits</item>
    ///   <item>Output format (Markdown, XML, Plain, JSON)</item>
    ///   <item>Whether to include file headers and line numbers</item>
    ///   <item>Context expansion settings</item>
    /// </list>
    /// </param>
    /// <param name="ct">Cancellation token for async operation.</param>
    /// <returns>
    /// Formatted context string ready for LLM prompt injection.
    /// Returns empty string if no relevant content is found.
    /// </returns>
    /// <remarks>
    /// <para>
    /// This is a convenience method that combines QueryAsync and 
    /// BuildContextFromChunksAsync into a single call.
    /// </para>
    /// <para>
    /// The context is built by:
    /// <list type="number">
    ///   <item>Querying for relevant chunks</item>
    ///   <item>Optionally expanding context around matches</item>
    ///   <item>Formatting chunks according to options</item>
    ///   <item>Applying token budget constraints</item>
    /// </list>
    /// </para>
    /// </remarks>
    Task<string> BuildContextAsync(
        string question,
        ContextBuildOptions options,
        CancellationToken ct = default);

    /// <summary>
    /// Build context from pre-retrieved chunks (for custom retrieval pipelines).
    /// </summary>
    /// <param name="chunks">Pre-retrieved knowledge chunks to format.</param>
    /// <param name="options">Context building options.</param>
    /// <param name="ct">Cancellation token for async operation.</param>
    /// <returns>
    /// Formatted context string ready for LLM prompt injection.
    /// Returns empty string if chunks collection is empty.
    /// </returns>
    /// <remarks>
    /// Use this method when you have already retrieved chunks through
    /// a custom pipeline and just need formatting and token budgeting.
    /// </remarks>
    Task<string> BuildContextFromChunksAsync(
        IReadOnlyList<KnowledgeChunk> chunks,
        ContextBuildOptions options,
        CancellationToken ct = default);

    #endregion

    #region Index Status

    /// <summary>
    /// Check if knowledge base is available for a workspace.
    /// </summary>
    /// <param name="workspacePath">Absolute path to the workspace.</param>
    /// <param name="ct">Cancellation token for async operation.</param>
    /// <returns>True if the workspace has been indexed and an index exists.</returns>
    /// <remarks>
    /// This is a fast check that only verifies index existence, not health.
    /// Use <see cref="GetIndexHealthAsync"/> for detailed status information.
    /// </remarks>
    Task<bool> IsIndexedAsync(string workspacePath, CancellationToken ct = default);

    /// <summary>
    /// Get index health and statistics for a workspace.
    /// </summary>
    /// <param name="workspacePath">Absolute path to the workspace.</param>
    /// <param name="ct">Cancellation token for async operation.</param>
    /// <returns>
    /// Index health information including:
    /// <list type="bullet">
    ///   <item>Whether the workspace is indexed</item>
    ///   <item>Total files and chunks in the index</item>
    ///   <item>Number of stale (changed) files</item>
    ///   <item>Whether a reindex is recommended</item>
    ///   <item>Embedding model information</item>
    ///   <item>Index creation and update timestamps</item>
    /// </list>
    /// </returns>
    /// <remarks>
    /// Returns <see cref="KnowledgeIndexHealth.NotIndexed"/> if no index exists.
    /// The NeedsReindex flag is set when more than 30% of files are stale.
    /// </remarks>
    Task<KnowledgeIndexHealth> GetIndexHealthAsync(
        string workspacePath,
        CancellationToken ct = default);

    #endregion

    #region Query Assistance

    /// <summary>
    /// Get suggestions for similar queries based on indexed content.
    /// </summary>
    /// <param name="partialQuery">Partial query string to get suggestions for.</param>
    /// <param name="workspacePath">Workspace to search in.</param>
    /// <param name="maxSuggestions">Maximum number of suggestions to return. Default: 5.</param>
    /// <param name="ct">Cancellation token for async operation.</param>
    /// <returns>
    /// List of query suggestions based on indexed symbol names.
    /// Returns empty list if workspace is not indexed.
    /// </returns>
    /// <remarks>
    /// <para>
    /// Current implementation returns symbol names (classes, methods, etc.)
    /// that match the partial query. Future versions may incorporate:
    /// <list type="bullet">
    ///   <item>Query history</item>
    ///   <item>Common code patterns</item>
    ///   <item>Semantic similarity suggestions</item>
    /// </list>
    /// </para>
    /// </remarks>
    Task<IReadOnlyList<string>> GetQuerySuggestionsAsync(
        string partialQuery,
        string workspacePath,
        int maxSuggestions = 5,
        CancellationToken ct = default);

    #endregion
}
```

---

### 2. IRerankingStrategy.cs

**Location**: `src/SeniorIntern.Core/Interfaces/IRerankingStrategy.cs`

```csharp
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using SeniorIntern.Core.Models;

namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Interface for reranking search results to improve relevance.
/// </summary>
/// <remarks>
/// <para>
/// Reranking strategies take initial vector search results and reorder them
/// using additional signals beyond pure embedding similarity. Common strategies include:
/// <list type="bullet">
///   <item>KeywordBoost: Boost results containing exact query keywords</item>
///   <item>RRF: Reciprocal Rank Fusion combining multiple ranking signals</item>
///   <item>CrossEncoder: Use a cross-encoder model for pairwise relevance (future)</item>
/// </list>
/// </para>
/// <para>
/// Implementations should:
/// <list type="bullet">
///   <item>Preserve all results (don't filter, only reorder)</item>
///   <item>Update the Score property with the new relevance score</item>
///   <item>Preserve the OriginalScore for comparison</item>
///   <item>Return results sorted by new score (descending)</item>
/// </list>
/// </para>
/// </remarks>
public interface IRerankingStrategy
{
    /// <summary>
    /// The name of this reranking strategy.
    /// Used for logging, debugging, and UI display.
    /// </summary>
    /// <example>
    /// "Keyword Boost", "Reciprocal Rank Fusion", "Cross-Encoder"
    /// </example>
    string Name { get; }

    /// <summary>
    /// Whether this strategy requires the original query text.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Some strategies (like pure embedding-based reranking) don't need the
    /// original query text. Others (like keyword boost) need it to match
    /// keywords in results.
    /// </para>
    /// <para>
    /// When true, the query parameter in RerankAsync must be provided
    /// and non-empty.
    /// </para>
    /// </remarks>
    bool RequiresQueryText { get; }

    /// <summary>
    /// Rerank search results based on the strategy's algorithm.
    /// </summary>
    /// <param name="results">
    /// Original search results from vector search, ordered by embedding similarity.
    /// </param>
    /// <param name="query">
    /// The original query text. Required if <see cref="RequiresQueryText"/> is true.
    /// </param>
    /// <param name="ct">Cancellation token for async operation.</param>
    /// <returns>
    /// Reranked results with updated scores. The collection should contain
    /// the same items as the input, but reordered and with updated Score values.
    /// </returns>
    /// <exception cref="System.ArgumentNullException">
    /// Thrown when results is null.
    /// </exception>
    /// <exception cref="System.ArgumentException">
    /// Thrown when query is required but null or empty.
    /// </exception>
    /// <remarks>
    /// <para>
    /// The Score property should be updated to reflect the new ranking.
    /// The OriginalScore property should be preserved from the input.
    /// </para>
    /// <para>
    /// Return the results sorted by Score in descending order.
    /// </para>
    /// </remarks>
    Task<IReadOnlyList<ChunkSearchResult>> RerankAsync(
        IReadOnlyList<ChunkSearchResult> results,
        string query,
        CancellationToken ct = default);
}
```

---

### 3. IContextAssembler.cs

**Location**: `src/SeniorIntern.Core/Interfaces/IContextAssembler.cs`

```csharp
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using SeniorIntern.Core.Models;

namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Interface for assembling knowledge chunks into formatted context strings for LLM prompts.
/// </summary>
/// <remarks>
/// <para>
/// The context assembler is responsible for:
/// <list type="bullet">
///   <item>Formatting chunks according to the specified output format</item>
///   <item>Applying token budget constraints</item>
///   <item>Grouping chunks by file (optional)</item>
///   <item>Adding headers, separators, and structure</item>
/// </list>
/// </para>
/// <para>
/// Supported output formats:
/// <list type="bullet">
///   <item>Markdown: Code blocks with language tags and file headers</item>
///   <item>XML: Structured tags for models trained on XML</item>
///   <item>Plain: Minimal formatting for compatibility</item>
///   <item>JSON: Structured output for programmatic processing</item>
/// </list>
/// </para>
/// </remarks>
public interface IContextAssembler
{
    /// <summary>
    /// Assemble multiple chunks into a formatted context string.
    /// </summary>
    /// <param name="chunks">
    /// Knowledge chunks to assemble, typically ordered by relevance.
    /// </param>
    /// <param name="options">
    /// Context building options including format, token budget, and display settings.
    /// </param>
    /// <param name="ct">Cancellation token for async operation.</param>
    /// <returns>
    /// Result containing:
    /// <list type="bullet">
    ///   <item>The assembled context string</item>
    ///   <item>Estimated token count</item>
    ///   <item>Number of chunks included vs truncated</item>
    ///   <item>Build timing information</item>
    /// </list>
    /// </returns>
    /// <remarks>
    /// <para>
    /// Chunks are processed in order until the token budget is exhausted.
    /// Higher relevance chunks should be passed first to ensure they are included.
    /// </para>
    /// <para>
    /// When GroupByFile is enabled in options, chunks from the same file are
    /// consolidated under a single file header.
    /// </para>
    /// </remarks>
    Task<ContextBuildResult> AssembleAsync(
        IReadOnlyList<KnowledgeChunk> chunks,
        ContextBuildOptions options,
        CancellationToken ct = default);

    /// <summary>
    /// Format a single chunk according to the specified format.
    /// </summary>
    /// <param name="chunk">The chunk to format.</param>
    /// <param name="format">Output format (Markdown, XML, Plain, JSON).</param>
    /// <param name="includeFileHeader">Whether to include file path header.</param>
    /// <param name="includeLineNumbers">Whether to include line number information.</param>
    /// <returns>Formatted chunk as a FormattedChunk with token estimate.</returns>
    /// <remarks>
    /// This method is useful for previewing individual chunks or building
    /// custom context assembly pipelines.
    /// </remarks>
    FormattedChunk FormatChunk(
        KnowledgeChunk chunk,
        ContextFormat format,
        bool includeFileHeader = true,
        bool includeLineNumbers = true);

    /// <summary>
    /// Estimate token count for a string using the specified method.
    /// </summary>
    /// <param name="text">Text to estimate tokens for.</param>
    /// <param name="method">Estimation method to use.</param>
    /// <returns>Estimated token count.</returns>
    /// <remarks>
    /// <para>
    /// Available methods:
    /// <list type="bullet">
    ///   <item>CharacterBased: ~4 characters per token (fastest)</item>
    ///   <item>WordBased: ~1.3 tokens per word (more accurate for prose)</item>
    ///   <item>Tokenizer: Actual tokenization (most accurate, slowest)</item>
    /// </list>
    /// </para>
    /// <para>
    /// For code, CharacterBased tends to be reasonably accurate as code
    /// has consistent token density.
    /// </para>
    /// </remarks>
    int EstimateTokens(string text, TokenEstimationMethod method);
}
```

---

### 4. IContextExpander.cs

**Location**: `src/SeniorIntern.Core/Interfaces/IContextExpander.cs`

```csharp
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using SeniorIntern.Core.Models;

namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Interface for expanding context around matched code chunks.
/// </summary>
/// <remarks>
/// <para>
/// Context expansion adds surrounding lines to matched chunks, providing
/// more context for understanding the code. This is useful because:
/// <list type="bullet">
///   <item>Chunks may cut off in the middle of a logical block</item>
///   <item>Surrounding code provides necessary context for understanding</item>
///   <item>Import statements and class declarations may be above the match</item>
/// </list>
/// </para>
/// <para>
/// The expander reads from the original source files, so it requires
/// file system access to the workspace.
/// </para>
/// </remarks>
public interface IContextExpander
{
    /// <summary>
    /// Expand context around a single chunk.
    /// </summary>
    /// <param name="workspacePath">Absolute path to the workspace root.</param>
    /// <param name="chunk">The chunk to expand context around.</param>
    /// <param name="contextLines">Number of lines to include before and after the chunk.</param>
    /// <param name="ct">Cancellation token for async operation.</param>
    /// <returns>
    /// Expanded content including surrounding lines, or null if the file
    /// cannot be read or is no longer available.
    /// </returns>
    /// <remarks>
    /// <para>
    /// The expanded content will include:
    /// <list type="bullet">
    ///   <item>Up to contextLines lines before the chunk</item>
    ///   <item>The original chunk content</item>
    ///   <item>Up to contextLines lines after the chunk</item>
    /// </list>
    /// </para>
    /// <para>
    /// If the file has been modified since indexing (detected by hash comparison),
    /// the expanded content may not match the indexed content perfectly.
    /// </para>
    /// </remarks>
    Task<string?> ExpandAsync(
        string workspacePath,
        TextChunk chunk,
        int contextLines,
        CancellationToken ct = default);

    /// <summary>
    /// Expand context for multiple chunks in batch.
    /// </summary>
    /// <param name="workspacePath">Absolute path to the workspace root.</param>
    /// <param name="chunks">Chunks to expand context for.</param>
    /// <param name="contextLines">Number of lines to include before and after each chunk.</param>
    /// <param name="ct">Cancellation token for async operation.</param>
    /// <returns>
    /// Dictionary mapping chunk IDs to expanded content.
    /// Entries are omitted for chunks that couldn't be expanded.
    /// </returns>
    /// <remarks>
    /// <para>
    /// Batch expansion is more efficient than calling ExpandAsync repeatedly
    /// because it can cache file reads for chunks from the same file.
    /// </para>
    /// <para>
    /// Chunks from the same file are processed together to minimize file I/O.
    /// </para>
    /// </remarks>
    Task<IReadOnlyDictionary<string, string>> ExpandBatchAsync(
        string workspacePath,
        IReadOnlyList<TextChunk> chunks,
        int contextLines,
        CancellationToken ct = default);
}
```

---

## Logging Specifications

The following logging events will be emitted by implementations:

| Component | Level | Event | Data |
|-----------|-------|-------|------|
| `KnowledgeService` | Debug | Query start | Question (truncated), WorkspacePath |
| `KnowledgeService` | Debug | Cache hit | Question (truncated) |
| `KnowledgeService` | Information | Query complete | Time, ResultCount, TotalChunks |
| `KnowledgeService` | Warning | No index found | WorkspacePath |
| `KnowledgeService` | Error | Embedding failed | Exception |
| `RerankingStrategy` | Debug | Rerank applied | Strategy, InputCount, OutputCount |
| `ContextAssembler` | Debug | Context built | ChunksIncluded, EstimatedTokens, WasTruncated |
| `ContextExpander` | Debug | Context expanded | FilePath, OriginalLines, ExpandedLines |
| `ContextExpander` | Warning | File not found | FilePath |

---

## Unit Testing Requirements

| Interface | Test Count | Focus Areas |
|-----------|------------|-------------|
| `IKnowledgeService` | 25-30 | Query behavior, caching, context building, error handling |
| `IRerankingStrategy` | 15-18 | Score calculation, ordering, edge cases |
| `IContextAssembler` | 18-22 | Format variations, token budgeting, grouping |
| `IContextExpander` | 12-15 | File reading, line expansion, batch processing |

### IKnowledgeService Test Scenarios

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                    IKnowledgeService Test Coverage                            │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  QueryAsync Tests (10-12 tests):                                             │
│  ├── Query_WithValidQuestion_ReturnsRelevantChunks                          │
│  ├── Query_WithEmptyQuestion_ThrowsArgumentException                        │
│  ├── Query_WithNullWorkspace_ThrowsArgumentException                        │
│  ├── Query_WithUnindexedWorkspace_ReturnsEmptyResult                        │
│  ├── Query_WithMaxResults_LimitsResultCount                                 │
│  ├── Query_WithMinRelevance_FiltersLowScoreChunks                          │
│  ├── Query_WithReranking_AppliesRerankingStrategy                          │
│  ├── Query_WithFilePatterns_FiltersToMatchingFiles                         │
│  ├── Query_WithLanguageFilter_FiltersToMatchingLanguages                   │
│  ├── Query_CacheHit_ReturnsCachedResult                                     │
│  ├── Query_Cancelled_ThrowsOperationCancelledException                      │
│  └── Query_EmbeddingFails_ThrowsKnowledgeQueryException                    │
│                                                                              │
│  BuildContextAsync Tests (6-8 tests):                                        │
│  ├── BuildContext_WithQuestion_ReturnsFormattedString                       │
│  ├── BuildContext_WithTokenBudget_TruncatesAppropriately                   │
│  ├── BuildContext_WithNoResults_ReturnsEmptyString                         │
│  ├── BuildContext_WithMarkdownFormat_IncludesCodeBlocks                    │
│  ├── BuildContext_WithXmlFormat_IncludesXmlTags                            │
│  ├── BuildContext_FromChunks_FormatsProvidedChunks                         │
│  └── BuildContext_WithGroupByFile_GroupsChunksByFile                       │
│                                                                              │
│  FindRelevantFilesAsync Tests (4-5 tests):                                   │
│  ├── FindFiles_WithValidQuery_ReturnsAggregatedFiles                        │
│  ├── FindFiles_WithMaxFiles_LimitsResultCount                               │
│  ├── FindFiles_OrdersByRelevanceThenMatchCount                             │
│  └── FindFiles_IncludesMatchLines                                           │
│                                                                              │
│  Index Status Tests (3-4 tests):                                             │
│  ├── IsIndexed_WithIndexedWorkspace_ReturnsTrue                             │
│  ├── IsIndexed_WithUnindexedWorkspace_ReturnsFalse                          │
│  ├── GetIndexHealth_WithIndex_ReturnsHealthInfo                             │
│  └── GetIndexHealth_WithStaleFiles_IndicatesNeedReindex                    │
│                                                                              │
│  Query Suggestions Tests (2-3 tests):                                        │
│  ├── GetSuggestions_WithPartialQuery_ReturnsMatchingSymbols                │
│  └── GetSuggestions_WithUnindexedWorkspace_ReturnsEmpty                    │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

### IRerankingStrategy Test Scenarios

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                    IRerankingStrategy Test Coverage                           │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Common Tests (5-6 tests):                                                   │
│  ├── Rerank_WithNullResults_ThrowsArgumentNullException                     │
│  ├── Rerank_WithEmptyResults_ReturnsEmptyList                               │
│  ├── Rerank_PreservesOriginalScore                                          │
│  ├── Rerank_ReturnsSameItemCount                                            │
│  ├── Rerank_SortsByScoreDescending                                          │
│  └── Rerank_Cancelled_ThrowsOperationCancelledException                     │
│                                                                              │
│  KeywordBoost Tests (5-6 tests):                                             │
│  ├── KeywordBoost_WithMatchingKeywords_BoostsScore                          │
│  ├── KeywordBoost_WithNoKeywords_PreservesOriginalScore                     │
│  ├── KeywordBoost_CaseInsensitiveMatching                                   │
│  ├── KeywordBoost_MultipleKeywords_AccumulatesBoost                        │
│  └── KeywordBoost_RequiresQueryText                                         │
│                                                                              │
│  RRF Tests (4-6 tests):                                                      │
│  ├── RRF_CombinesMultipleRankings                                           │
│  ├── RRF_WithSingleRanking_UsesRankPosition                                │
│  ├── RRF_UpdatesScoreToRRFValue                                             │
│  └── RRF_HandlesLargeResultSets                                             │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

**Total: ~70-85 tests across all interfaces**

---

## Acceptance Criteria

### Functional Requirements

- [ ] `IKnowledgeService` defines all knowledge retrieval operations
  - [ ] `QueryAsync` supports filtering, reranking, and caching
  - [ ] `BuildContextAsync` supports token budgeting and multiple formats
  - [ ] `FindRelevantFilesAsync` aggregates results by file
  - [ ] `IsIndexedAsync` and `GetIndexHealthAsync` provide status checks
  - [ ] `GetQuerySuggestionsAsync` returns symbol-based suggestions
- [ ] `IRerankingStrategy` defines pluggable reranking interface
  - [ ] Supports multiple strategy types (KeywordBoost, RRF, CrossEncoder)
  - [ ] Clearly documents requirements for query text
- [ ] `IContextAssembler` defines context formatting interface
  - [ ] Supports Markdown, XML, Plain, and JSON formats
  - [ ] Includes token estimation capability
- [ ] `IContextExpander` defines context expansion interface
  - [ ] Supports both single and batch expansion
  - [ ] Handles missing or modified files gracefully
- [ ] All interfaces have comprehensive XML documentation

### Quality Requirements

- [ ] All public members have XML documentation comments
- [ ] Interface contracts are clearly defined in `<remarks>` sections
- [ ] Usage examples provided in `<example>` tags where applicable
- [ ] No forward dependencies on implementation details
- [ ] Exception documentation complete for all throwing methods
- [ ] Thread-safety guarantees documented

### Documentation Requirements

- [ ] Each interface file includes namespace documentation
- [ ] Related types are cross-referenced with `<see cref=""/>` tags
- [ ] Return types and parameter purposes clearly explained
- [ ] Edge cases and error conditions documented

---

## Future Considerations

Items explicitly deferred to later sub-versions:

- **v0.7.4b**: Model implementations (`KnowledgeQueryOptions`, `KnowledgeQueryResult`, `KnowledgeChunk`, etc.)
- **v0.7.4c**: Context building models (`ContextBuildOptions`, `ContextBuildResult`, `FormattedChunk`)
- **v0.7.4d**: `KnowledgeService` implementation
- **v0.7.4e**: Reranking strategy implementations (`KeywordBoostStrategy`, `ReciprocalRankFusionStrategy`)
- **v0.7.4f**: `ContextAssembler` implementation
- **v0.7.4g**: `FileContextExpander` implementation
- **v0.7.4h**: `RagAwareChatService` integration

---

## Appendix A: Interface Method Summary

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                         Interface Method Reference                            │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  IKnowledgeService                                                           │
│  │                                                                          │
│  ├── QueryAsync(question, options, ct)                                      │
│  │   → KnowledgeQueryResult                                                 │
│  │                                                                          │
│  ├── BuildContextAsync(question, options, ct)                               │
│  │   → string                                                               │
│  │                                                                          │
│  ├── BuildContextFromChunksAsync(chunks, options, ct)                       │
│  │   → string                                                               │
│  │                                                                          │
│  ├── FindRelevantFilesAsync(query, workspacePath, maxFiles, ct)            │
│  │   → IReadOnlyList<RelevantFile>                                          │
│  │                                                                          │
│  ├── IsIndexedAsync(workspacePath, ct)                                      │
│  │   → bool                                                                 │
│  │                                                                          │
│  ├── GetIndexHealthAsync(workspacePath, ct)                                 │
│  │   → KnowledgeIndexHealth                                                 │
│  │                                                                          │
│  └── GetQuerySuggestionsAsync(partialQuery, workspacePath, maxSuggestions)  │
│      → IReadOnlyList<string>                                                │
│                                                                              │
│  IRerankingStrategy                                                          │
│  │                                                                          │
│  ├── Name                     → string                                       │
│  ├── RequiresQueryText        → bool                                         │
│  └── RerankAsync(results, query, ct)                                        │
│      → IReadOnlyList<ChunkSearchResult>                                      │
│                                                                              │
│  IContextAssembler                                                           │
│  │                                                                          │
│  ├── AssembleAsync(chunks, options, ct)                                     │
│  │   → ContextBuildResult                                                   │
│  │                                                                          │
│  ├── FormatChunk(chunk, format, includeFileHeader, includeLineNumbers)     │
│  │   → FormattedChunk                                                       │
│  │                                                                          │
│  └── EstimateTokens(text, method)                                           │
│      → int                                                                   │
│                                                                              │
│  IContextExpander                                                            │
│  │                                                                          │
│  ├── ExpandAsync(workspacePath, chunk, contextLines, ct)                    │
│  │   → string?                                                              │
│  │                                                                          │
│  └── ExpandBatchAsync(workspacePath, chunks, contextLines, ct)              │
│      → IReadOnlyDictionary<string, string>                                   │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Appendix B: Type Dependencies

```
v0.7.4a Interfaces
│
├── IKnowledgeService
│   ├── Uses: KnowledgeQueryOptions (v0.7.4b)
│   ├── Uses: KnowledgeQueryResult (v0.7.4b)
│   ├── Uses: KnowledgeChunk (v0.7.4b)
│   ├── Uses: ContextBuildOptions (v0.7.4c)
│   ├── Uses: KnowledgeIndexHealth (v0.7.4b)
│   ├── Uses: RelevantFile (v0.7.4b)
│   ├── Depends: IEmbeddingService (v0.7.1a)
│   └── Depends: IVectorStore (v0.7.2a)
│
├── IRerankingStrategy
│   └── Uses: ChunkSearchResult (v0.7.2c)
│
├── IContextAssembler
│   ├── Uses: KnowledgeChunk (v0.7.4b)
│   ├── Uses: ContextBuildOptions (v0.7.4c)
│   ├── Uses: ContextBuildResult (v0.7.4c)
│   ├── Uses: ContextFormat (v0.7.4c)
│   ├── Uses: FormattedChunk (v0.7.4c)
│   └── Uses: TokenEstimationMethod (v0.7.4c)
│
└── IContextExpander
    └── Uses: TextChunk (v0.7.1d)
```
