# Design Specification: AIntern v0.7.4d "Knowledge Service Implementation"

## Overview

**Version**: v0.7.4d  
**Parent**: v0.7.4 Retrieval & Context  
**Focus**: Implement the core `KnowledgeService` class that orchestrates retrieval, reranking, and context assembly

### Purpose

This sub-version implements the primary RAG orchestration service:
1. `KnowledgeService` - Core implementation of `IKnowledgeService`
2. `QueryCache` - In-memory LRU cache for query results
3. `KnowledgeQueryException` - Custom exception for query failures
4. `IRerankingStrategyFactory` - Factory interface for creating reranking strategies
5. DI Registration - Service registration in `DependencyInjection.cs`

### Dependencies

**From v0.7.1 (Embedding Foundation)**:
- `IEmbeddingService.EmbedAsync()` for generating query embeddings

**From v0.7.2 (Vector Storage)**:
- `IVectorStore` for vector search operations
- `VectorSearchOptions`, `ChunkSearchResult` models

**From v0.7.4a (Knowledge Service Interface)**:
- `IKnowledgeService` interface to implement
- `IRerankingStrategy` for reranking operations
- `IContextAssembler`, `IContextExpander` interfaces

**From v0.7.4b/c (Query & Context Models)**:
- `KnowledgeQueryOptions`, `KnowledgeQueryResult`, `KnowledgeChunk`
- `KnowledgeIndexHealth`, `RelevantFile`
- `ContextBuildOptions`, `RerankingStrategy` enum

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                     v0.7.4d Knowledge Service Implementation                  │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  src/SeniorIntern.Services/Knowledge/                                        │
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │                                                                          ││
│  │  KnowledgeService : IKnowledgeService                                    ││
│  │  ├── Dependencies (injected)                                             ││
│  │  │   ├── IVectorStore _vectorStore                                       ││
│  │  │   ├── IEmbeddingService _embeddingService                             ││
│  │  │   ├── IRerankingStrategyFactory _rerankingFactory                     ││
│  │  │   ├── IContextAssembler _contextAssembler                             ││
│  │  │   ├── IContextExpander _contextExpander                               ││
│  │  │   └── ILogger<KnowledgeService> _logger                               ││
│  │  │                                                                        ││
│  │  ├── Internal State                                                      ││
│  │  │   └── QueryCache _queryCache (maxSize: 100, expiration: 5min)         ││
│  │  │                                                                        ││
│  │  ├── Query Operations                                                    ││
│  │  │   ├── QueryAsync()                                                    ││
│  │  │   └── FindRelevantFilesAsync()                                        ││
│  │  │                                                                        ││
│  │  ├── Context Building                                                    ││
│  │  │   ├── BuildContextAsync()                                             ││
│  │  │   └── BuildContextFromChunksAsync()                                   ││
│  │  │                                                                        ││
│  │  ├── Index Status                                                        ││
│  │  │   ├── IsIndexedAsync()                                                ││
│  │  │   └── GetIndexHealthAsync()                                           ││
│  │  │                                                                        ││
│  │  ├── Query Assistance                                                    ││
│  │  │   └── GetQuerySuggestionsAsync()                                      ││
│  │  │                                                                        ││
│  │  └── Private Helpers                                                     ││
│  │      ├── ConvertToKnowledgeChunkAsync()                                  ││
│  │      └── ComputeCacheKey()                                               ││
│  │                                                                          ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │  QueryCache (internal)                                                   ││
│  │  ├── _cache: ConcurrentDictionary<string, CacheEntry>                    ││
│  │  ├── _maxSize: int, _expiration: TimeSpan                                ││
│  │  ├── TryGet<T>() → Thread-safe retrieval with expiration check           ││
│  │  ├── Set<T>() → Thread-safe insertion with LRU eviction                  ││
│  │  ├── Clear() → Remove all entries                                        ││
│  │  └── EvictOldest() → LRU eviction based on access counter                ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │  KnowledgeQueryException : Exception                                     ││
│  │  ├── KnowledgeQueryException(string message)                             ││
│  │  └── KnowledgeQueryException(string message, Exception inner)            ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
│  src/SeniorIntern.Services/Knowledge/Interfaces/                             │
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │  IRerankingStrategyFactory                                               ││
│  │  ├── Create(RerankingStrategy) → IRerankingStrategy?                     ││
│  │  └── IsSupported(RerankingStrategy) → bool                               ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Query Pipeline Flow

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                          QueryAsync Pipeline                                  │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Input: (question: string, options: KnowledgeQueryOptions)                   │
│     │                                                                        │
│     ▼                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  1. Validate Input                                                       │ │
│  │     - Question not null/empty → ArgumentException                        │ │
│  │     - WorkspacePath required → ArgumentException                         │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│     │                                                                        │
│     ▼                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  2. Check Cache                                                          │ │
│  │     - ComputeCacheKey(question, options)                                 │ │
│  │     - If hit: return cached result with CacheHit = true                  │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│     │                                                                        │
│     ▼                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  3. Get Index                                                            │ │
│  │     - _vectorStore.GetIndexForWorkspaceAsync(workspacePath)              │ │
│  │     - If null: Log warning, return Empty                                 │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│     │                                                                        │
│     ▼                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  4. Generate Query Embedding                                             │ │
│  │     - _embeddingService.EmbedAsync(question)                             │ │
│  │     - On failure: throw KnowledgeQueryException                          │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│     │                                                                        │
│     ▼                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  5. Vector Search                                                        │ │
│  │     - TopK = MaxResults * 2 (over-fetch for reranking)                   │ │
│  │     - MinScore = MinRelevance * 0.8 (lower threshold pre-rerank)         │ │
│  │     - _vectorStore.SearchAsync(indexId, embedding, options)              │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│     │                                                                        │
│     ▼                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  6. Rerank (if requested)                                                │ │
│  │     - _rerankingFactory.Create(options.Reranking)                        │ │
│  │     - reranker.RerankAsync(results, question)                            │ │
│  │     - Set wasReranked = true                                             │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│     │                                                                        │
│     ▼                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  7. Filter & Take Top Results                                            │ │
│  │     - Filter by MinRelevance threshold                                   │ │
│  │     - Order by score descending                                          │ │
│  │     - Take(MaxResults)                                                   │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│     │                                                                        │
│     ▼                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  8. Convert & Expand Context                                             │ │
│  │     - ConvertToKnowledgeChunkAsync() for each result                     │ │
│  │     - If ExpandContext: _contextExpander.ExpandAsync()                   │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│     │                                                                        │
│     ▼                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  9. Build Result & Cache                                                 │ │
│  │     - Extract unique file paths                                          │ │
│  │     - Create KnowledgeQueryResult                                        │ │
│  │     - _queryCache.Set(cacheKey, result)                                  │ │
│  │     - Log completion with timing                                         │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│     │                                                                        │
│     ▼                                                                        │
│  Output: KnowledgeQueryResult                                                │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Services/Knowledge/KnowledgeService.cs` | Core RAG orchestration implementation |
| `src/SeniorIntern.Services/Knowledge/KnowledgeService.Helpers.cs` | QueryCache, KnowledgeQueryException |
| `src/SeniorIntern.Services/Knowledge/Interfaces/IRerankingStrategyFactory.cs` | Factory interface for reranking strategies |

### File to Modify

| File | Changes |
|------|---------|
| `src/SeniorIntern.Services/DependencyInjection.cs` | Add service registrations |

---

## Detailed Specifications

### 1. KnowledgeService.cs

**Location**: `src/SeniorIntern.Services/Knowledge/KnowledgeService.cs`

```csharp
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Services.Knowledge.Interfaces;

namespace SeniorIntern.Services.Knowledge;

/// <summary>
/// High-level knowledge retrieval service for RAG.
/// Orchestrates embedding generation, vector search, reranking, and context assembly.
/// </summary>
/// <remarks>
/// <para>
/// This service is the main entry point for all knowledge retrieval operations.
/// It coordinates multiple underlying services:
/// <list type="bullet">
///   <item>IEmbeddingService: Generates query embeddings</item>
///   <item>IVectorStore: Performs similarity search</item>
///   <item>IRerankingStrategy: Improves result relevance</item>
///   <item>IContextExpander: Adds surrounding code context</item>
///   <item>IContextAssembler: Formats results for LLM consumption</item>
/// </list>
/// </para>
/// <para>
/// Thread safety: All methods are thread-safe. Query results are cached
/// for 5 minutes to improve performance for repeated queries.
/// </para>
/// </remarks>
public sealed class KnowledgeService : IKnowledgeService
{
    private readonly IVectorStore _vectorStore;
    private readonly IEmbeddingService _embeddingService;
    private readonly IRerankingStrategyFactory _rerankingFactory;
    private readonly IContextAssembler _contextAssembler;
    private readonly IContextExpander _contextExpander;
    private readonly ILogger<KnowledgeService> _logger;
    private readonly QueryCache _queryCache;

    /// <summary>
    /// Initializes a new instance of the KnowledgeService.
    /// </summary>
    public KnowledgeService(
        IVectorStore vectorStore,
        IEmbeddingService embeddingService,
        IRerankingStrategyFactory rerankingFactory,
        IContextAssembler contextAssembler,
        IContextExpander contextExpander,
        ILogger<KnowledgeService> logger)
    {
        _vectorStore = vectorStore ?? throw new ArgumentNullException(nameof(vectorStore));
        _embeddingService = embeddingService ?? throw new ArgumentNullException(nameof(embeddingService));
        _rerankingFactory = rerankingFactory ?? throw new ArgumentNullException(nameof(rerankingFactory));
        _contextAssembler = contextAssembler ?? throw new ArgumentNullException(nameof(contextAssembler));
        _contextExpander = contextExpander ?? throw new ArgumentNullException(nameof(contextExpander));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _queryCache = new QueryCache(maxSize: 100, expiration: TimeSpan.FromMinutes(5));
    }

    /// <inheritdoc />
    public async Task<KnowledgeQueryResult> QueryAsync(
        string question,
        KnowledgeQueryOptions options,
        CancellationToken ct = default)
    {
        // Validate input
        if (string.IsNullOrWhiteSpace(question))
            throw new ArgumentException("Question cannot be empty", nameof(question));
        if (string.IsNullOrWhiteSpace(options.WorkspacePath))
            throw new ArgumentException("WorkspacePath is required", nameof(options));

        var stopwatch = Stopwatch.StartNew();
        _logger.LogDebug("Querying knowledge base: {Question}", TruncateForLog(question));

        // Check cache
        var cacheKey = ComputeCacheKey(question, options);
        if (_queryCache.TryGet(cacheKey, out KnowledgeQueryResult? cached))
        {
            _logger.LogDebug("Query cache hit");
            return cached! with { CacheHit = true };
        }

        // Get index
        var index = await _vectorStore.GetIndexForWorkspaceAsync(options.WorkspacePath, ct);
        if (index == null)
        {
            _logger.LogWarning("No index found for workspace: {Path}", options.WorkspacePath);
            return KnowledgeQueryResult.Empty;
        }

        // Generate embedding
        float[] queryEmbedding;
        try
        {
            queryEmbedding = await _embeddingService.EmbedAsync(question, ct);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to generate query embedding");
            throw new KnowledgeQueryException("Failed to generate query embedding", ex);
        }

        // Vector search with over-fetch for reranking
        var searchOptions = new VectorSearchOptions
        {
            TopK = options.MaxResults * 2,
            MinScore = options.MinRelevance * 0.8f,
            FilePatterns = options.FilePatterns,
            Languages = options.Languages,
            IncludeContent = true,
            Deduplicate = options.DeduplicateChunks
        };

        var searchResults = await _vectorStore.SearchAsync(
            index.Id, queryEmbedding, searchOptions, ct);

        if (searchResults.Count == 0)
        {
            _logger.LogDebug("No results found for query");
            return new KnowledgeQueryResult
            {
                QueryTime = stopwatch.Elapsed,
                TotalChunksSearched = index.ChunkCount,
                QueryEmbedding = queryEmbedding
            };
        }

        // Apply reranking
        var rankedResults = searchResults;
        var wasReranked = false;
        if (options.Reranking != RerankingStrategy.None)
        {
            var reranker = _rerankingFactory.Create(options.Reranking);
            if (reranker != null)
            {
                rankedResults = await reranker.RerankAsync(searchResults, question, ct);
                wasReranked = true;
                _logger.LogDebug("Applied {Strategy} reranking", options.Reranking);
            }
        }

        // Filter and take top
        var topResults = rankedResults
            .Where(r => r.Score >= options.MinRelevance)
            .OrderByDescending(r => r.Score)
            .Take(options.MaxResults)
            .ToList();

        // Convert and expand
        var chunks = new List<KnowledgeChunk>();
        foreach (var result in topResults)
        {
            var chunk = await ConvertToKnowledgeChunkAsync(result, options, ct);
            chunks.Add(chunk);
        }

        var relevantFiles = chunks.Select(c => c.FilePath).Distinct().ToList();
        stopwatch.Stop();

        var queryResult = new KnowledgeQueryResult
        {
            Chunks = chunks,
            RelevantFiles = relevantFiles,
            QueryTime = stopwatch.Elapsed,
            TotalChunksSearched = index.ChunkCount,
            ChunksAboveThreshold = topResults.Count,
            QueryEmbedding = queryEmbedding,
            WasReranked = wasReranked,
            RerankingApplied = options.Reranking,
            CacheHit = false
        };

        _queryCache.Set(cacheKey, queryResult);

        _logger.LogInformation(
            "Query completed in {Time}ms: {ResultCount} results from {TotalChunks} chunks",
            stopwatch.ElapsedMilliseconds, chunks.Count, index.ChunkCount);

        return queryResult;
    }

    /// <inheritdoc />
    public async Task<string> BuildContextAsync(
        string question, ContextBuildOptions options, CancellationToken ct = default)
    {
        var queryResult = await QueryAsync(question, new KnowledgeQueryOptions
        {
            WorkspacePath = options.WorkspacePath,
            MaxResults = options.MaxChunks,
            MinRelevance = options.MinRelevance,
            ExpandContext = options.ExpandContext,
            ContextLines = options.ContextLines,
            FilePatterns = options.FilePatterns,
            Languages = options.Languages,
            Reranking = options.Reranking
        }, ct);

        return !queryResult.HasResults
            ? string.Empty
            : await BuildContextFromChunksAsync(queryResult.Chunks, options, ct);
    }

    /// <inheritdoc />
    public async Task<string> BuildContextFromChunksAsync(
        IReadOnlyList<KnowledgeChunk> chunks, ContextBuildOptions options, CancellationToken ct = default)
    {
        if (chunks.Count == 0) return string.Empty;
        var result = await _contextAssembler.AssembleAsync(chunks, options, ct);
        return result.Context;
    }

    /// <inheritdoc />
    public async Task<IReadOnlyList<RelevantFile>> FindRelevantFilesAsync(
        string query, string workspacePath, int maxFiles = 10, CancellationToken ct = default)
    {
        var result = await QueryAsync(query, new KnowledgeQueryOptions
        {
            WorkspacePath = workspacePath,
            MaxResults = maxFiles * 3,
            MinRelevance = 0.4f,
            IncludeSnippets = false,
            ExpandContext = false
        }, ct);

        return result.Chunks
            .GroupBy(c => c.FilePath)
            .Select(g => new RelevantFile
            {
                FilePath = g.Key,
                Relevance = g.Max(c => c.Relevance),
                MatchCount = g.Count(),
                Summary = g.First().Content.Length > 100 
                    ? g.First().Content[..100] + "..." 
                    : g.First().Content,
                Language = g.First().Language,
                MatchLines = g.Select(c => c.StartLine).Distinct().OrderBy(l => l).ToList()
            })
            .OrderByDescending(f => f.Relevance)
            .ThenByDescending(f => f.MatchCount)
            .Take(maxFiles)
            .ToList();
    }

    /// <inheritdoc />
    public async Task<bool> IsIndexedAsync(string workspacePath, CancellationToken ct = default)
    {
        var index = await _vectorStore.GetIndexForWorkspaceAsync(workspacePath, ct);
        return index != null;
    }

    /// <inheritdoc />
    public async Task<KnowledgeIndexHealth> GetIndexHealthAsync(
        string workspacePath, CancellationToken ct = default)
    {
        var index = await _vectorStore.GetIndexForWorkspaceAsync(workspacePath, ct);
        if (index == null) return KnowledgeIndexHealth.NotIndexed;

        var stats = await _vectorStore.GetStatisticsAsync(index.Id, ct);
        var staleCount = await _vectorStore.GetStaleFileCountAsync(index.Id, ct);

        return new KnowledgeIndexHealth
        {
            IsIndexed = true,
            IndexId = index.Id,
            IndexName = index.Name,
            TotalFiles = stats.FileCount,
            TotalChunks = stats.ChunkCount,
            LastUpdated = index.UpdatedAt,
            CreatedAt = index.CreatedAt,
            StaleFiles = staleCount,
            NeedsReindex = staleCount > stats.FileCount * 0.3,
            EmbeddingModel = index.Settings.EmbeddingModelPath,
            EmbeddingDimension = index.EmbeddingDimension,
            IndexSizeBytes = stats.TotalSizeBytes
        };
    }

    /// <inheritdoc />
    public async Task<IReadOnlyList<string>> GetQuerySuggestionsAsync(
        string partialQuery, string workspacePath, int maxSuggestions = 5, CancellationToken ct = default)
    {
        var index = await _vectorStore.GetIndexForWorkspaceAsync(workspacePath, ct);
        if (index == null) return Array.Empty<string>();

        var symbols = await _vectorStore.SearchSymbolsAsync(index.Id, partialQuery, maxSuggestions, ct);
        return symbols.Where(s => !string.IsNullOrEmpty(s)).Distinct().Take(maxSuggestions).ToList();
    }

    #region Private Helpers

    private async Task<KnowledgeChunk> ConvertToKnowledgeChunkAsync(
        ChunkSearchResult result, KnowledgeQueryOptions options, CancellationToken ct)
    {
        string? expandedContext = null;
        if (options.ExpandContext)
        {
            expandedContext = await _contextExpander.ExpandAsync(
                options.WorkspacePath, result.Chunk, options.ContextLines, ct);
        }

        return new KnowledgeChunk
        {
            Content = result.Chunk.Content,
            FilePath = result.Chunk.FilePath,
            StartLine = result.Chunk.StartLine,
            EndLine = result.Chunk.EndLine,
            Relevance = result.Score,
            Language = result.Chunk.Language,
            SymbolName = result.Chunk.SymbolName,
            SymbolType = result.Chunk.SymbolType,
            ExpandedContext = expandedContext,
            OriginalScore = result.OriginalScore,
            ChunkId = result.ChunkId,
            FileHash = result.Chunk.FileHash
        };
    }

    private static string ComputeCacheKey(string question, KnowledgeQueryOptions options)
    {
        return string.Join("|",
            question,
            options.WorkspacePath,
            options.MaxResults,
            options.MinRelevance.ToString("F2"),
            options.Reranking,
            string.Join(",", options.FilePatterns ?? Array.Empty<string>()),
            string.Join(",", options.Languages ?? Array.Empty<string>()));
    }

    private static string TruncateForLog(string text, int maxLength = 50)
        => text.Length <= maxLength ? text : text[..maxLength] + "...";

    #endregion
}
```

---

### 2. KnowledgeService.Helpers.cs

**Location**: `src/SeniorIntern.Services/Knowledge/KnowledgeService.Helpers.cs`

```csharp
using System;
using System.Collections.Concurrent;
using System.Threading;

namespace SeniorIntern.Services.Knowledge;

/// <summary>
/// Simple in-memory LRU cache for query results.
/// </summary>
/// <remarks>
/// Thread-safe implementation using ConcurrentDictionary.
/// Evicts oldest entries when capacity is reached.
/// </remarks>
internal sealed class QueryCache
{
    private readonly ConcurrentDictionary<string, CacheEntry> _cache = new();
    private readonly int _maxSize;
    private readonly TimeSpan _expiration;
    private int _accessCounter;

    public QueryCache(int maxSize, TimeSpan expiration)
    {
        _maxSize = maxSize;
        _expiration = expiration;
    }

    public int Count => _cache.Count;

    public bool TryGet<T>(string key, out T? value) where T : class
    {
        value = default;
        if (!_cache.TryGetValue(key, out var entry)) return false;
        if (DateTime.UtcNow > entry.ExpiresAt)
        {
            _cache.TryRemove(key, out _);
            return false;
        }
        entry.LastAccess = Interlocked.Increment(ref _accessCounter);
        value = entry.Value as T;
        return value != null;
    }

    public void Set<T>(string key, T value) where T : class
    {
        if (_cache.Count >= _maxSize) EvictOldest();
        var entry = new CacheEntry
        {
            Value = value,
            ExpiresAt = DateTime.UtcNow.Add(_expiration),
            LastAccess = Interlocked.Increment(ref _accessCounter)
        };
        _cache.AddOrUpdate(key, entry, (_, _) => entry);
    }

    public void Clear() => _cache.Clear();

    private void EvictOldest()
    {
        string? oldestKey = null;
        var oldestAccess = int.MaxValue;
        foreach (var kvp in _cache)
        {
            if (kvp.Value.LastAccess < oldestAccess)
            {
                oldestKey = kvp.Key;
                oldestAccess = kvp.Value.LastAccess;
            }
        }
        if (oldestKey != null) _cache.TryRemove(oldestKey, out _);
    }

    private sealed class CacheEntry
    {
        public object Value { get; init; } = null!;
        public DateTime ExpiresAt { get; init; }
        public int LastAccess { get; set; }
    }
}

/// <summary>
/// Exception thrown when a knowledge query fails.
/// </summary>
public sealed class KnowledgeQueryException : Exception
{
    public KnowledgeQueryException(string message) : base(message) { }
    public KnowledgeQueryException(string message, Exception inner) : base(message, inner) { }
}
```

---

### 3. IRerankingStrategyFactory.cs

**Location**: `src/SeniorIntern.Services/Knowledge/Interfaces/IRerankingStrategyFactory.cs`

```csharp
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;

namespace SeniorIntern.Services.Knowledge.Interfaces;

/// <summary>
/// Factory for creating reranking strategy instances.
/// </summary>
public interface IRerankingStrategyFactory
{
    /// <summary>
    /// Create a reranking strategy instance.
    /// </summary>
    /// <param name="strategy">The strategy type to create.</param>
    /// <returns>The strategy instance, or null if not supported.</returns>
    IRerankingStrategy? Create(RerankingStrategy strategy);

    /// <summary>
    /// Check if a strategy is supported.
    /// </summary>
    bool IsSupported(RerankingStrategy strategy);
}
```

---

### 4. DependencyInjection.cs (Modifications)

**Location**: `src/SeniorIntern.Services/DependencyInjection.cs`

```csharp
// Add these registrations in ConfigureServices method:
services.AddSingleton<IKnowledgeService, KnowledgeService>();
services.AddSingleton<IRerankingStrategyFactory, RerankingStrategyFactory>();
services.AddSingleton<IContextAssembler, ContextAssembler>();
services.AddSingleton<IContextExpander, FileContextExpander>();
```

---

## Unit Testing Requirements

| Component | Test Count | Focus Areas |
|-----------|------------|-------------|
| `KnowledgeService.QueryAsync` | 15-18 | Validation, caching, search pipeline, reranking |
| `KnowledgeService.BuildContextAsync` | 6-8 | Query → context flow, empty handling |
| `KnowledgeService.FindRelevantFilesAsync` | 5-6 | Aggregation, ordering |
| `KnowledgeService.IndexStatus` | 4-5 | IsIndexed, GetIndexHealth |
| `QueryCache` | 10-12 | LRU eviction, expiration, thread safety |
| `KnowledgeQueryException` | 2-3 | Constructor variants |

**Total: ~42-52 tests**

---

## Acceptance Criteria

### Functional Requirements
- [ ] `QueryAsync` validates inputs and throws appropriate exceptions
- [ ] `QueryAsync` checks cache before querying
- [ ] `QueryAsync` generates query embedding via `IEmbeddingService`
- [ ] `QueryAsync` applies reranking when requested
- [ ] `QueryAsync` expands context when `ExpandContext = true`
- [ ] `BuildContextAsync` delegates to `QueryAsync` and `IContextAssembler`
- [ ] `FindRelevantFilesAsync` aggregates chunks by file correctly
- [ ] `GetIndexHealthAsync` calculates staleness and `NeedsReindex` flag
- [ ] `QueryCache` implements LRU eviction and expiration
- [ ] All services registered in DI container

### Quality Requirements
- [ ] All methods have comprehensive XML documentation
- [ ] Logging at appropriate levels (Debug, Information, Warning, Error)
- [ ] Null checks on all constructor parameters
- [ ] Thread-safe cache implementation

---

## Future Considerations

Items deferred to later sub-versions:
- **v0.7.4e**: `RerankingStrategyFactory` and concrete reranking implementations
- **v0.7.4f**: `ContextAssembler` implementation
- **v0.7.4g**: `FileContextExpander` implementation
