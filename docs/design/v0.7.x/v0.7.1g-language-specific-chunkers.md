# Design Specification: AIntern v0.7.1g "Language-Specific Chunkers"

## Overview

**Version**: v0.7.1g
**Parent**: v0.7.1 Embedding Foundation
**Focus**: Implement specialized chunking strategies for specific languages with better accuracy

### Purpose

Implement language-specific chunking strategies:
1. Create `CSharpChunkingStrategy` with enhanced C# symbol extraction
2. Create `TypeScriptChunkingStrategy` for TypeScript/JavaScript including React
3. Create `PythonChunkingStrategy` with indentation-aware parsing
4. Create `MarkdownChunkingStrategy` for heading-based document chunking
5. Create `PlainTextChunkingStrategy` as universal fallback
6. Extract documentation comments (XML docs, JSDoc, docstrings)

### Dependencies

**From v0.7.1f (Code-Aware Chunking Strategy)**:
- `CodeAwareChunkingStrategy` base class
- Brace matching and indentation detection algorithms
- `GetSymbolPatterns()` virtual method

**From v0.7.1e (Chunking Service Interface)**:
- `IChunkingStrategy` interface
- `ICodeChunkingStrategy` interface
- `IChunkingService` for token estimation

**From v0.7.1d (Text Chunk Models)**:
- `TextChunk` model
- `ChunkType` enum
- `SymbolType` enum
- `ChunkingOptions` class

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                v0.7.1g Language-Specific Chunkers Architecture                │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Strategy Inheritance Hierarchy:                                             │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  IChunkingStrategy (Priority 0)                                         │ │
│  │         │                                                                │ │
│  │         ├── PlainTextChunkingStrategy (Priority 0) ← Universal fallback │ │
│  │         ├── MarkdownChunkingStrategy (Priority 150)                     │ │
│  │         │                                                                │ │
│  │         └── ICodeChunkingStrategy                                       │ │
│  │                     │                                                    │ │
│  │                     └── CodeAwareChunkingStrategy (Priority 100)        │ │
│  │                                 │                                        │ │
│  │                                 ├── CSharpChunkingStrategy (Priority 200)│ │
│  │                                 ├── TypeScriptChunkingStrategy (Pri 200)│ │
│  │                                 └── PythonChunkingStrategy (Priority 200)│ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  Priority Resolution (highest wins):                                         │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  File: MyClass.cs                                                        │ │
│  │  Candidates:                                                             │ │
│  │    - CSharpChunkingStrategy (200) ← SELECTED                            │ │
│  │    - CodeAwareChunkingStrategy (100)                                    │ │
│  │    - PlainTextChunkingStrategy (0)                                      │ │
│  │                                                                          │ │
│  │  File: README.md                                                         │ │
│  │  Candidates:                                                             │ │
│  │    - MarkdownChunkingStrategy (150) ← SELECTED                          │ │
│  │    - PlainTextChunkingStrategy (0)                                      │ │
│  │                                                                          │ │
│  │  File: unknown.xyz                                                       │ │
│  │  Candidates:                                                             │ │
│  │    - PlainTextChunkingStrategy (0) ← SELECTED (universal fallback)      │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Strategy Summary

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                          Strategy Summary Table                               │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Strategy               │ Priority │ Extensions      │ Documentation        │
│  ───────────────────────│──────────│─────────────────│───────────────────── │
│  CSharpChunkingStrategy │ 200      │ .cs             │ XML /// comments     │
│  TypeScriptChunkingStrategy│ 200   │ .ts,.tsx,.js,.jsx,.mjs │ JSDoc /**    │
│  PythonChunkingStrategy │ 200      │ .py, .pyi       │ Docstrings """       │
│  MarkdownChunkingStrategy│ 150     │ .md,.markdown,.mdx │ Heading as title │
│  PlainTextChunkingStrategy│ 0      │ .txt,.text,.log │ None                 │
│  (universal)            │ 0        │ ANY             │ None                 │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Specifications

### 1. CSharpChunkingStrategy.cs

**Location**: `src/SeniorIntern.Services/Chunking/CSharpChunkingStrategy.cs`

```csharp
namespace SeniorIntern.Services.Chunking;

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;

/// <summary>
/// Specialized chunking strategy for C# code.
/// </summary>
/// <remarks>
/// <para>
/// Extends CodeAwareChunkingStrategy with enhanced C#-specific pattern matching:
/// <list type="bullet">
///   <item>Recognizes namespaces, classes, records, structs, interfaces, enums</item>
///   <item>Extracts methods, properties, constructors, events, delegates</item>
///   <item>Parses XML documentation comments (/// summary)</item>
///   <item>Builds fully qualified names with namespace/class hierarchy</item>
/// </list>
/// </para>
/// </remarks>
public sealed class CSharpChunkingStrategy : CodeAwareChunkingStrategy
{
    /// <summary>
    /// Supported file extensions for C#.
    /// </summary>
    private static readonly HashSet<string> _extensions = new(StringComparer.OrdinalIgnoreCase)
    {
        ".cs"
    };

    #region Properties

    /// <inheritdoc />
    public override string Name => "CSharp";

    /// <inheritdoc />
    public override IReadOnlySet<string> SupportedExtensions => _extensions;

    /// <inheritdoc />
    public override int Priority => 200; // Higher than generic CodeAware (100)

    #endregion

    #region Constructor

    /// <summary>
    /// Initializes a new instance of the CSharpChunkingStrategy.
    /// </summary>
    public CSharpChunkingStrategy(
        ILogger<CSharpChunkingStrategy> logger,
        IChunkingService chunkingService)
        : base(logger, chunkingService)
    {
    }

    #endregion

    #region Overrides

    /// <inheritdoc />
    public override bool CanHandle(string filePath)
    {
        var extension = Path.GetExtension(filePath);
        return extension.Equals(".cs", StringComparison.OrdinalIgnoreCase);
    }

    /// <inheritdoc />
    protected override IEnumerable<(string Pattern, SymbolType Type)> GetSymbolPatterns(string language)
    {
        return new[]
        {
            // Namespaces (file-scoped and block)
            (@"namespace\s+(?<name>[\w.]+)\s*[{;]", SymbolType.Namespace),

            // Classes (including records, generics, partial)
            (@"(?:public|private|protected|internal)?\s*" +
             @"(?:static\s+)?(?:abstract\s+)?(?:sealed\s+)?(?:partial\s+)?" +
             @"(?:class|record)\s+(?<name>\w+)(?:<[^>]+>)?", SymbolType.Class),

            // Structs (including readonly, ref)
            (@"(?:public|private|protected|internal)?\s*" +
             @"(?:readonly\s+)?(?:ref\s+)?struct\s+(?<name>\w+)", SymbolType.Struct),

            // Interfaces (including partial, generics)
            (@"(?:public|private|protected|internal)?\s*" +
             @"(?:partial\s+)?interface\s+(?<name>\w+)(?:<[^>]+>)?", SymbolType.Interface),

            // Enums
            (@"(?:public|private|protected|internal)?\s*enum\s+(?<name>\w+)", SymbolType.Enum),

            // Methods (including async, with generics, where clauses)
            (@"(?:public|private|protected|internal)?\s*" +
             @"(?:static\s+)?(?:virtual\s+)?(?:override\s+)?(?:abstract\s+)?(?:async\s+)?" +
             @"(?:[\w<>\[\],\s]+)\s+(?<name>\w+)\s*(?:<[^>]+>)?\s*\([^)]*\)" +
             @"\s*(?:where\s+[^{]+)?(?=\s*[{;=>])", SymbolType.Method),

            // Properties (including required)
            (@"(?:public|private|protected|internal)?\s*" +
             @"(?:static\s+)?(?:virtual\s+)?(?:override\s+)?(?:required\s+)?" +
             @"(?:[\w<>\[\],?\s]+)\s+(?<name>\w+)\s*(?=\s*[{=>])", SymbolType.Property),

            // Constructors (including base/this calls)
            (@"(?:public|private|protected|internal)?\s*" +
             @"(?<name>\w+)\s*\([^)]*\)\s*" +
             @"(?::\s*(?:base|this)\s*\([^)]*\))?\s*(?=[{])", SymbolType.Constructor),

            // Events
            (@"(?:public|private|protected|internal)?\s*" +
             @"event\s+[\w<>]+\s+(?<name>\w+)", SymbolType.Event),

            // Delegates
            (@"(?:public|private|protected|internal)?\s*" +
             @"delegate\s+[\w<>]+\s+(?<name>\w+)\s*\(", SymbolType.Delegate),
        };
    }

    /// <inheritdoc />
    protected override IReadOnlyList<CodeSymbol> ExtractSymbolsForLanguage(
        string content,
        string language)
    {
        var symbols = new List<CodeSymbol>();
        var currentNamespace = "";
        var classStack = new Stack<string>();

        var patterns = GetSymbolPatterns(language);

        foreach (var (pattern, symbolType) in patterns)
        {
            try
            {
                var matches = Regex.Matches(content, pattern, RegexOptions.Multiline);

                foreach (Match match in matches)
                {
                    var nameGroup = match.Groups["name"];
                    if (!nameGroup.Success)
                        continue;

                    var name = nameGroup.Value;
                    var startOffset = match.Index;
                    var endOffset = FindSymbolEnd(content, startOffset, "csharp");
                    var startLine = GetLineNumber(content, startOffset);
                    var endLine = GetLineNumber(content, endOffset);

                    // Track namespace context
                    if (symbolType == SymbolType.Namespace)
                    {
                        currentNamespace = name;
                    }

                    // Track class context for nested types
                    if (symbolType is SymbolType.Class or SymbolType.Struct or SymbolType.Interface)
                    {
                        classStack.Push(name);
                    }

                    var parent = classStack.Count > 0 ? classStack.Peek() : null;

                    // Extract XML documentation if present
                    var documentation = ExtractXmlDocumentation(content, startOffset);

                    symbols.Add(new CodeSymbol
                    {
                        Name = name,
                        Type = symbolType,
                        QualifiedName = BuildQualifiedName(currentNamespace, classStack, name),
                        Parent = symbolType is SymbolType.Method or SymbolType.Property or SymbolType.Constructor
                            ? parent
                            : null,
                        Namespace = currentNamespace,
                        StartLine = startLine,
                        EndLine = endLine,
                        StartOffset = startOffset,
                        Length = endOffset - startOffset,
                        Documentation = documentation
                    });
                }
            }
            catch (RegexMatchTimeoutException ex)
            {
                _logger.LogWarning(ex, "Regex timeout for C# pattern");
            }
        }

        return symbols;
    }

    #endregion

    #region Documentation Extraction

    /// <summary>
    /// Extract XML documentation comments (///) before a symbol.
    /// </summary>
    private static string? ExtractXmlDocumentation(string content, int symbolOffset)
    {
        // Get content before the symbol
        var beforeSymbol = content[..symbolOffset];
        var lines = beforeSymbol.Split('\n');

        var docLines = new List<string>();

        // Walk backwards through lines
        for (int i = lines.Length - 1; i >= 0; i--)
        {
            var line = lines[i].Trim();

            if (line.StartsWith("///"))
            {
                // Remove /// prefix and add to doc
                docLines.Insert(0, line[3..].Trim());
            }
            else if (string.IsNullOrWhiteSpace(line))
            {
                // Skip empty lines
                continue;
            }
            else
            {
                // Non-doc line, stop
                break;
            }
        }

        if (docLines.Count == 0)
            return null;

        // Parse XML to extract summary
        var fullDoc = string.Join("\n", docLines);
        var summaryMatch = Regex.Match(
            fullDoc,
            @"<summary>\s*(?<content>.*?)\s*</summary>",
            RegexOptions.Singleline);

        return summaryMatch.Success
            ? summaryMatch.Groups["content"].Value.Trim()
            : string.Join(" ", docLines);
    }

    /// <summary>
    /// Build fully qualified name from namespace and class hierarchy.
    /// </summary>
    private static string BuildQualifiedName(
        string ns,
        Stack<string> classStack,
        string name)
    {
        var parts = new List<string>();

        if (!string.IsNullOrEmpty(ns))
            parts.Add(ns);

        parts.AddRange(classStack.Reverse());
        parts.Add(name);

        return string.Join(".", parts);
    }

    #endregion
}
```

### 2. TypeScriptChunkingStrategy.cs

**Location**: `src/SeniorIntern.Services/Chunking/TypeScriptChunkingStrategy.cs`

```csharp
namespace SeniorIntern.Services.Chunking;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;

/// <summary>
/// Specialized chunking strategy for TypeScript/JavaScript code.
/// </summary>
/// <remarks>
/// <para>
/// Handles TypeScript, JavaScript, JSX, and TSX files with patterns for:
/// <list type="bullet">
///   <item>Classes (abstract, default, exported)</item>
///   <item>Interfaces and type aliases</item>
///   <item>Functions (regular, async, generator)</item>
///   <item>Arrow functions assigned to const/let</item>
///   <item>React function components</item>
///   <item>Class methods and properties</item>
///   <item>JSDoc documentation extraction</item>
/// </list>
/// </para>
/// </remarks>
public sealed class TypeScriptChunkingStrategy : CodeAwareChunkingStrategy
{
    /// <summary>
    /// Supported file extensions for TypeScript/JavaScript.
    /// </summary>
    private static readonly HashSet<string> _extensions = new(StringComparer.OrdinalIgnoreCase)
    {
        ".ts", ".tsx", ".js", ".jsx", ".mjs"
    };

    #region Properties

    /// <inheritdoc />
    public override string Name => "TypeScript";

    /// <inheritdoc />
    public override IReadOnlySet<string> SupportedExtensions => _extensions;

    /// <inheritdoc />
    public override int Priority => 200;

    #endregion

    #region Constructor

    /// <summary>
    /// Initializes a new instance of the TypeScriptChunkingStrategy.
    /// </summary>
    public TypeScriptChunkingStrategy(
        ILogger<TypeScriptChunkingStrategy> logger,
        IChunkingService chunkingService)
        : base(logger, chunkingService)
    {
    }

    #endregion

    #region Overrides

    /// <inheritdoc />
    protected override IEnumerable<(string Pattern, SymbolType Type)> GetSymbolPatterns(string language)
    {
        return new[]
        {
            // Classes (including abstract, default, exported)
            (@"(?:export\s+)?(?:default\s+)?(?:abstract\s+)?class\s+(?<name>\w+)" +
             @"(?:<[^>]+>)?(?:\s+extends\s+[\w.<>]+)?(?:\s+implements\s+[\w.<>,\s]+)?",
             SymbolType.Class),

            // Interfaces
            (@"(?:export\s+)?interface\s+(?<name>\w+)(?:<[^>]+>)?(?:\s+extends\s+[\w.<>,\s]+)?",
             SymbolType.Interface),

            // Type aliases
            (@"(?:export\s+)?type\s+(?<name>\w+)(?:<[^>]+>)?\s*=",
             SymbolType.TypeAlias),

            // Enums (including const enum)
            (@"(?:export\s+)?(?:const\s+)?enum\s+(?<name>\w+)",
             SymbolType.Enum),

            // Functions (regular, async, generator)
            (@"(?:export\s+)?(?:default\s+)?(?:async\s+)?function\s*\*?\s*(?<name>\w+)" +
             @"\s*(?:<[^>]+>)?\s*\(",
             SymbolType.Function),

            // Arrow functions assigned to const/let
            (@"(?:export\s+)?(?:const|let|var)\s+(?<name>\w+)\s*(?::\s*[^=]+)?\s*=" +
             @"\s*(?:async\s+)?\([^)]*\)\s*(?::\s*[^=]+)?\s*=>",
             SymbolType.Function),

            // Class methods (including accessors)
            (@"(?:public|private|protected)?\s*(?:static\s+)?(?:readonly\s+)?(?:async\s+)?" +
             @"(?<name>\w+)\s*(?:<[^>]+>)?\s*\([^)]*\)\s*(?::\s*[\w<>\[\]|&\s]+)?\s*\{",
             SymbolType.Method),

            // Class properties/fields
            (@"(?:public|private|protected)?\s*(?:static\s+)?(?:readonly\s+)?" +
             @"(?<name>\w+)\s*(?:\?)?:\s*[\w<>\[\]|&\s]+\s*[;=]",
             SymbolType.Property),

            // React function components (PascalCase functions returning JSX)
            (@"(?:export\s+)?(?:default\s+)?(?:const|function)\s+(?<name>[A-Z]\w+)" +
             @"\s*(?::\s*[\w<>]+)?\s*=?\s*(?:\([^)]*\)|props)\s*(?::\s*[\w<>]+)?\s*=>?\s*\{?\s*(?:return)?\s*\(?\s*<",
             SymbolType.Function),
        };
    }

    /// <inheritdoc />
    protected override IReadOnlyList<CodeSymbol> ExtractSymbolsForLanguage(
        string content,
        string language)
    {
        var symbols = new List<CodeSymbol>();
        var patterns = GetSymbolPatterns(language);

        foreach (var (pattern, symbolType) in patterns)
        {
            try
            {
                var matches = Regex.Matches(content, pattern, RegexOptions.Multiline);

                foreach (Match match in matches)
                {
                    var nameGroup = match.Groups["name"];
                    if (!nameGroup.Success)
                        continue;

                    var name = nameGroup.Value;
                    var startOffset = match.Index;
                    var endOffset = FindSymbolEnd(content, startOffset, language);
                    var startLine = GetLineNumber(content, startOffset);
                    var endLine = GetLineNumber(content, endOffset);

                    // Extract JSDoc if present
                    var documentation = ExtractJsDoc(content, startOffset);

                    symbols.Add(new CodeSymbol
                    {
                        Name = name,
                        Type = symbolType,
                        StartLine = startLine,
                        EndLine = endLine,
                        StartOffset = startOffset,
                        Length = endOffset - startOffset,
                        Documentation = documentation
                    });
                }
            }
            catch (RegexMatchTimeoutException ex)
            {
                _logger.LogWarning(ex, "Regex timeout for TypeScript pattern");
            }
        }

        return symbols;
    }

    #endregion

    #region JSDoc Extraction

    /// <summary>
    /// Extract JSDoc documentation (/** */) before a symbol.
    /// </summary>
    private static string? ExtractJsDoc(string content, int symbolOffset)
    {
        // Look for /** */ comments before the symbol
        var beforeSymbol = content[..symbolOffset];
        var docMatch = Regex.Match(beforeSymbol, @"/\*\*\s*([\s\S]*?)\s*\*/\s*$");

        if (!docMatch.Success)
            return null;

        var docContent = docMatch.Groups[1].Value;

        // Clean up the doc: remove * prefixes and @-tags
        var lines = docContent.Split('\n')
            .Select(l => Regex.Replace(l.Trim(), @"^\*\s*", "").Trim())
            .Where(l => !string.IsNullOrEmpty(l) && !l.StartsWith("@"));

        return string.Join(" ", lines);
    }

    #endregion
}
```

### 3. PythonChunkingStrategy.cs

**Location**: `src/SeniorIntern.Services/Chunking/PythonChunkingStrategy.cs`

```csharp
namespace SeniorIntern.Services.Chunking;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;

/// <summary>
/// Specialized chunking strategy for Python code.
/// </summary>
/// <remarks>
/// <para>
/// Uses line-by-line parsing to respect Python's indentation-based structure:
/// <list type="bullet">
///   <item>Classes with optional base classes</item>
///   <item>Functions (def) and async functions</item>
///   <item>Methods (indented functions with self parameter)</item>
///   <item>Class methods and static methods via decorators</item>
///   <item>Docstring extraction (triple-quoted strings)</item>
/// </list>
/// </para>
/// </remarks>
public sealed class PythonChunkingStrategy : CodeAwareChunkingStrategy
{
    /// <summary>
    /// Supported file extensions for Python.
    /// </summary>
    private static readonly HashSet<string> _extensions = new(StringComparer.OrdinalIgnoreCase)
    {
        ".py", ".pyi"
    };

    #region Properties

    /// <inheritdoc />
    public override string Name => "Python";

    /// <inheritdoc />
    public override IReadOnlySet<string> SupportedExtensions => _extensions;

    /// <inheritdoc />
    public override int Priority => 200;

    #endregion

    #region Constructor

    /// <summary>
    /// Initializes a new instance of the PythonChunkingStrategy.
    /// </summary>
    public PythonChunkingStrategy(
        ILogger<PythonChunkingStrategy> logger,
        IChunkingService chunkingService)
        : base(logger, chunkingService)
    {
    }

    #endregion

    #region Overrides

    /// <inheritdoc />
    protected override IEnumerable<(string Pattern, SymbolType Type)> GetSymbolPatterns(string language)
    {
        return new[]
        {
            // Classes (at start of line)
            (@"^class\s+(?<name>\w+)\s*(?:\([^)]*\))?\s*:", SymbolType.Class),

            // Functions (at start of line, including async)
            (@"^(?:async\s+)?def\s+(?<name>\w+)\s*\([^)]*\)\s*(?:->\s*[\w\[\],\s]+)?\s*:", SymbolType.Function),

            // Methods (indented, with self parameter)
            (@"^\s+(?:async\s+)?def\s+(?<name>\w+)\s*\(self[^)]*\)\s*(?:->\s*[\w\[\],\s]+)?\s*:", SymbolType.Method),

            // Class/static methods (with decorators)
            (@"^\s+@(?:classmethod|staticmethod)\s*\n\s*(?:async\s+)?def\s+(?<name>\w+)", SymbolType.Method),
        };
    }

    /// <inheritdoc />
    protected override IReadOnlyList<CodeSymbol> ExtractSymbolsForLanguage(
        string content,
        string language)
    {
        var symbols = new List<CodeSymbol>();
        string? currentClass = null;

        var lines = content.Split('\n');
        var offset = 0;

        for (int i = 0; i < lines.Length; i++)
        {
            var line = lines[i];
            var lineStart = offset;
            offset += line.Length + 1;

            // Check for class definition
            var classMatch = Regex.Match(line, @"^class\s+(\w+)\s*(?:\([^)]*\))?\s*:");
            if (classMatch.Success)
            {
                currentClass = classMatch.Groups[1].Value;
                var endOffset = FindPythonBlockEnd(content, lineStart);

                symbols.Add(new CodeSymbol
                {
                    Name = currentClass,
                    Type = SymbolType.Class,
                    StartLine = i + 1,
                    EndLine = GetLineNumber(content, endOffset),
                    StartOffset = lineStart,
                    Length = endOffset - lineStart,
                    Documentation = ExtractDocstring(content, lineStart)
                });

                continue;
            }

            // Check for function/method definition
            var funcMatch = Regex.Match(line, @"^(\s*)(?:async\s+)?def\s+(\w+)\s*\(([^)]*)\)");
            if (funcMatch.Success)
            {
                var indent = funcMatch.Groups[1].Value;
                var name = funcMatch.Groups[2].Value;
                var params_ = funcMatch.Groups[3].Value;

                var endOffset = FindPythonBlockEnd(content, lineStart);
                var isMethod = indent.Length > 0 && params_.Contains("self");
                var symbolType = isMethod ? SymbolType.Method : SymbolType.Function;

                symbols.Add(new CodeSymbol
                {
                    Name = name,
                    Type = symbolType,
                    Parent = isMethod ? currentClass : null,
                    StartLine = i + 1,
                    EndLine = GetLineNumber(content, endOffset),
                    StartOffset = lineStart,
                    Length = endOffset - lineStart,
                    Documentation = ExtractDocstring(content, lineStart)
                });
            }

            // Reset class context when leaving indentation
            if (!string.IsNullOrWhiteSpace(line) &&
                !line.StartsWith(" ") &&
                !line.StartsWith("\t"))
            {
                if (!classMatch.Success && !funcMatch.Success)
                    currentClass = null;
            }
        }

        return symbols;
    }

    #endregion

    #region Docstring Extraction

    /// <summary>
    /// Extract Python docstring (triple-quoted string) after a definition.
    /// </summary>
    private static string? ExtractDocstring(string content, int symbolOffset)
    {
        // Find the colon that ends the definition line
        var colonIndex = content.IndexOf(':', symbolOffset);
        if (colonIndex < 0)
            return null;

        // Look for docstring after the colon
        var afterColon = content[(colonIndex + 1)..];
        var docMatch = Regex.Match(afterColon, @"^\s*(?:\"\"\"([\s\S]*?)\"\"\"|'''([\s\S]*?)''')");

        if (!docMatch.Success)
            return null;

        var doc = docMatch.Groups[1].Success
            ? docMatch.Groups[1].Value
            : docMatch.Groups[2].Value;

        // Clean up the docstring
        var lines = doc.Split('\n')
            .Select(l => l.Trim())
            .Where(l => !string.IsNullOrEmpty(l));

        return string.Join(" ", lines);
    }

    #endregion
}
```

### 4. MarkdownChunkingStrategy.cs

**Location**: `src/SeniorIntern.Services/Chunking/MarkdownChunkingStrategy.cs`

```csharp
namespace SeniorIntern.Services.Chunking;

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;

/// <summary>
/// Chunking strategy for Markdown documents.
/// </summary>
/// <remarks>
/// <para>
/// Chunks Markdown by headings and sections:
/// <list type="bullet">
///   <item>Splits document by heading markers (# to ######)</item>
///   <item>Uses heading text as chunk title/symbol name</item>
///   <item>Large sections are split by paragraphs</item>
///   <item>Sets ChunkType.Markdown for all chunks</item>
/// </list>
/// </para>
/// </remarks>
public sealed class MarkdownChunkingStrategy : IChunkingStrategy
{
    private readonly ILogger<MarkdownChunkingStrategy> _logger;
    private readonly IChunkingService _chunkingService;

    /// <summary>
    /// Supported file extensions for Markdown.
    /// </summary>
    private static readonly HashSet<string> _extensions = new(StringComparer.OrdinalIgnoreCase)
    {
        ".md", ".markdown", ".mdx"
    };

    #region Properties

    /// <inheritdoc />
    public string Name => "Markdown";

    /// <inheritdoc />
    public IReadOnlySet<string> SupportedExtensions => _extensions;

    /// <inheritdoc />
    public int Priority => 150;

    #endregion

    #region Constructor

    /// <summary>
    /// Initializes a new instance of the MarkdownChunkingStrategy.
    /// </summary>
    public MarkdownChunkingStrategy(
        ILogger<MarkdownChunkingStrategy> logger,
        IChunkingService chunkingService)
    {
        _logger = logger;
        _chunkingService = chunkingService;
    }

    #endregion

    #region IChunkingStrategy Implementation

    /// <inheritdoc />
    public bool CanHandle(string filePath)
    {
        var extension = Path.GetExtension(filePath);
        return SupportedExtensions.Contains(extension);
    }

    /// <inheritdoc />
    public IReadOnlyList<TextChunk> Chunk(
        string content,
        string filePath,
        ChunkingOptions options)
    {
        var chunks = new List<TextChunk>();
        var sections = SplitByHeadings(content);
        var sequenceNumber = 0;

        foreach (var section in sections)
        {
            var tokenCount = _chunkingService.EstimateTokenCount(section.Content);

            if (tokenCount < options.MinChunkSize)
                continue;

            if (tokenCount <= options.MaxChunkSize)
            {
                // Section fits in one chunk
                chunks.Add(new TextChunk
                {
                    Content = section.Content,
                    FilePath = filePath,
                    StartLine = section.StartLine,
                    EndLine = section.EndLine,
                    StartOffset = section.StartOffset,
                    EndOffset = section.EndOffset,
                    Type = ChunkType.Markdown,
                    Language = "markdown",
                    SymbolName = section.Heading,
                    SymbolType = SymbolType.Other,
                    TokenCount = tokenCount,
                    SequenceNumber = sequenceNumber++
                });
            }
            else
            {
                // Section too large, split by paragraphs
                var subChunks = SplitByParagraphs(
                    section, filePath, options, ref sequenceNumber);
                chunks.AddRange(subChunks);
            }
        }

        return chunks;
    }

    #endregion

    #region Section Splitting

    /// <summary>
    /// Split Markdown content by headings.
    /// </summary>
    private static List<MarkdownSection> SplitByHeadings(string content)
    {
        var sections = new List<MarkdownSection>();
        var lines = content.Split('\n');
        var currentSection = new StringBuilder();
        var currentHeading = "";
        var startLine = 1;
        var startOffset = 0;
        var currentOffset = 0;

        for (int i = 0; i < lines.Length; i++)
        {
            var line = lines[i];
            var headingMatch = Regex.Match(line, @"^(#{1,6})\s+(.+)$");

            if (headingMatch.Success)
            {
                // Save previous section
                if (currentSection.Length > 0)
                {
                    sections.Add(new MarkdownSection
                    {
                        Heading = currentHeading,
                        Content = currentSection.ToString().Trim(),
                        StartLine = startLine,
                        EndLine = i,
                        StartOffset = startOffset,
                        EndOffset = currentOffset
                    });
                }

                // Start new section
                currentHeading = headingMatch.Groups[2].Value;
                currentSection.Clear();
                startLine = i + 1;
                startOffset = currentOffset;
            }

            currentSection.AppendLine(line);
            currentOffset += line.Length + 1;
        }

        // Don't forget the last section
        if (currentSection.Length > 0)
        {
            sections.Add(new MarkdownSection
            {
                Heading = currentHeading,
                Content = currentSection.ToString().Trim(),
                StartLine = startLine,
                EndLine = lines.Length,
                StartOffset = startOffset,
                EndOffset = content.Length
            });
        }

        return sections;
    }

    /// <summary>
    /// Split a large section by paragraphs.
    /// </summary>
    private IReadOnlyList<TextChunk> SplitByParagraphs(
        MarkdownSection section,
        string filePath,
        ChunkingOptions options,
        ref int sequenceNumber)
    {
        var chunks = new List<TextChunk>();
        var paragraphs = Regex.Split(section.Content, @"\n\n+");
        var currentChunk = new StringBuilder();
        var currentTokens = 0;
        var startLine = section.StartLine;
        var startOffset = section.StartOffset;
        var currentOffset = section.StartOffset;

        foreach (var para in paragraphs)
        {
            var paraTokens = _chunkingService.EstimateTokenCount(para);

            if (currentTokens + paraTokens > options.TargetChunkSize && currentChunk.Length > 0)
            {
                // Emit current chunk
                chunks.Add(new TextChunk
                {
                    Content = currentChunk.ToString().Trim(),
                    FilePath = filePath,
                    StartLine = startLine,
                    EndLine = startLine + currentChunk.ToString().Count(c => c == '\n'),
                    StartOffset = startOffset,
                    EndOffset = currentOffset,
                    Type = ChunkType.Markdown,
                    Language = "markdown",
                    SymbolName = section.Heading,
                    TokenCount = currentTokens,
                    SequenceNumber = sequenceNumber++
                });

                currentChunk.Clear();
                startLine = startLine + currentChunk.ToString().Count(c => c == '\n') + 1;
                startOffset = currentOffset;
                currentTokens = 0;
            }

            currentChunk.AppendLine(para);
            currentChunk.AppendLine();
            currentOffset += para.Length + 2;
            currentTokens += paraTokens;
        }

        // Last chunk
        if (currentChunk.Length > 0 && currentTokens >= options.MinChunkSize)
        {
            chunks.Add(new TextChunk
            {
                Content = currentChunk.ToString().Trim(),
                FilePath = filePath,
                StartLine = startLine,
                EndLine = section.EndLine,
                StartOffset = startOffset,
                EndOffset = section.EndOffset,
                Type = ChunkType.Markdown,
                Language = "markdown",
                SymbolName = section.Heading,
                TokenCount = currentTokens,
                SequenceNumber = sequenceNumber++
            });
        }

        return chunks;
    }

    #endregion

    #region Private Types

    /// <summary>
    /// Represents a Markdown section bounded by headings.
    /// </summary>
    private sealed class MarkdownSection
    {
        public string Heading { get; init; } = "";
        public string Content { get; init; } = "";
        public int StartLine { get; init; }
        public int EndLine { get; init; }
        public int StartOffset { get; init; }
        public int EndOffset { get; init; }
    }

    #endregion
}
```

### 5. PlainTextChunkingStrategy.cs

**Location**: `src/SeniorIntern.Services/Chunking/PlainTextChunkingStrategy.cs`

```csharp
namespace SeniorIntern.Services.Chunking;

using System;
using System.Collections.Generic;
using System.Text;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;

/// <summary>
/// Default chunking strategy for plain text and unknown file types.
/// </summary>
/// <remarks>
/// <para>
/// Universal fallback strategy with Priority 0. Handles any file type by:
/// <list type="bullet">
///   <item>Line-based chunking with TargetChunkSize</item>
///   <item>Configurable overlap between chunks</item>
///   <item>Sets ChunkType.PlainText for all chunks</item>
///   <item>CanHandle() always returns true (universal fallback)</item>
/// </list>
/// </para>
/// </remarks>
public sealed class PlainTextChunkingStrategy : IChunkingStrategy
{
    private readonly ILogger<PlainTextChunkingStrategy> _logger;
    private readonly IChunkingService _chunkingService;

    /// <summary>
    /// Explicit file extensions for plain text.
    /// </summary>
    private static readonly HashSet<string> _extensions = new(StringComparer.OrdinalIgnoreCase)
    {
        ".txt", ".text", ".log"
    };

    #region Properties

    /// <inheritdoc />
    public string Name => "PlainText";

    /// <inheritdoc />
    public IReadOnlySet<string> SupportedExtensions => _extensions;

    /// <inheritdoc />
    public int Priority => 0; // Lowest priority - universal fallback

    #endregion

    #region Constructor

    /// <summary>
    /// Initializes a new instance of the PlainTextChunkingStrategy.
    /// </summary>
    public PlainTextChunkingStrategy(
        ILogger<PlainTextChunkingStrategy> logger,
        IChunkingService chunkingService)
    {
        _logger = logger;
        _chunkingService = chunkingService;
    }

    #endregion

    #region IChunkingStrategy Implementation

    /// <inheritdoc />
    public bool CanHandle(string filePath)
    {
        // Universal fallback - can handle anything
        return true;
    }

    /// <inheritdoc />
    public IReadOnlyList<TextChunk> Chunk(
        string content,
        string filePath,
        ChunkingOptions options)
    {
        var chunks = new List<TextChunk>();
        var lines = content.Split('\n');
        var currentChunk = new StringBuilder();
        var startLine = 1;
        var startOffset = 0;
        var currentOffset = 0;
        var currentTokenCount = 0;
        var sequenceNumber = 0;

        for (int i = 0; i < lines.Length; i++)
        {
            var line = lines[i];
            var lineTokens = _chunkingService.EstimateTokenCount(line);

            if (currentTokenCount + lineTokens > options.TargetChunkSize && currentChunk.Length > 0)
            {
                // Emit current chunk
                chunks.Add(new TextChunk
                {
                    Content = currentChunk.ToString().TrimEnd(),
                    FilePath = filePath,
                    StartLine = startLine,
                    EndLine = i,
                    StartOffset = startOffset,
                    EndOffset = currentOffset,
                    Type = ChunkType.PlainText,
                    TokenCount = currentTokenCount,
                    SequenceNumber = sequenceNumber++,
                    HasOverlap = sequenceNumber > 0
                });

                // Start new chunk with overlap
                var overlapLines = CalculateOverlapLines(lines, i, options.ChunkOverlap);
                currentChunk.Clear();

                foreach (var ol in overlapLines)
                    currentChunk.AppendLine(ol);

                startLine = Math.Max(1, i - overlapLines.Count + 1);
                startOffset = currentOffset - string.Join('\n', overlapLines).Length;
                currentTokenCount = _chunkingService.EstimateTokenCount(currentChunk.ToString());
            }

            currentChunk.AppendLine(line);
            currentOffset += line.Length + 1;
            currentTokenCount += lineTokens;
        }

        // Last chunk
        if (currentChunk.Length > 0 && currentTokenCount >= options.MinChunkSize)
        {
            chunks.Add(new TextChunk
            {
                Content = currentChunk.ToString().TrimEnd(),
                FilePath = filePath,
                StartLine = startLine,
                EndLine = lines.Length,
                StartOffset = startOffset,
                EndOffset = content.Length,
                Type = ChunkType.PlainText,
                TokenCount = currentTokenCount,
                SequenceNumber = sequenceNumber
            });
        }

        return chunks;
    }

    #endregion

    #region Helpers

    /// <summary>
    /// Calculate lines to include as overlap for a new chunk.
    /// </summary>
    private static List<string> CalculateOverlapLines(
        string[] lines,
        int currentIndex,
        int overlapTokens)
    {
        var overlapLines = new List<string>();
        var tokens = 0;

        for (int i = currentIndex - 1; i >= 0 && tokens < overlapTokens; i--)
        {
            overlapLines.Insert(0, lines[i]);
            tokens += lines[i].Length / 4; // Rough estimate: ~4 chars/token
        }

        return overlapLines;
    }

    #endregion
}
```

---

## Documentation Extraction Summary

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                      Documentation Extraction Methods                         │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  C# XML Documentation:                                                       │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  Pattern: Lines starting with "///" before symbol                        │ │
│  │  Parsing: Extract <summary> content from XML                             │ │
│  │  Example:                                                                 │ │
│  │    /// <summary>                                                          │ │
│  │    /// Gets the user by ID.                                              │ │
│  │    /// </summary>                                                         │ │
│  │  Output: "Gets the user by ID."                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  JavaScript/TypeScript JSDoc:                                                │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  Pattern: Block comment /** ... */ before symbol                         │ │
│  │  Parsing: Remove * prefixes, filter @-tags                               │ │
│  │  Example:                                                                 │ │
│  │    /**                                                                    │ │
│  │     * Fetches data from the API.                                         │ │
│  │     * @param {string} url - The endpoint                                 │ │
│  │     */                                                                    │ │
│  │  Output: "Fetches data from the API."                                    │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  Python Docstrings:                                                          │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  Pattern: Triple-quoted string after colon                               │ │
│  │  Parsing: Extract content, join lines                                    │ │
│  │  Example:                                                                 │ │
│  │    def process(data):                                                    │ │
│  │        """Process the input data.                                        │ │
│  │                                                                          │ │
│  │        Args:                                                              │ │
│  │            data: The data to process                                     │ │
│  │        """                                                                │ │
│  │  Output: "Process the input data."                                       │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Unit Test Plan

| Test | Description |
|------|-------------|
| `CSharp_ExtractsClasses` | Class pattern matching |
| `CSharp_ExtractsRecords` | Record type pattern |
| `CSharp_ExtractsInterfaces` | Interface pattern |
| `CSharp_ExtractsMethods` | Method pattern including async |
| `CSharp_ExtractsProperties` | Property pattern |
| `CSharp_ExtractsXmlDoc` | XML documentation extraction |
| `CSharp_BuildsQualifiedNames` | Namespace.Class.Method formatting |
| `TypeScript_ExtractsClasses` | TS class pattern |
| `TypeScript_ExtractsArrowFunctions` | Arrow function pattern |
| `TypeScript_ExtractsReactComponents` | PascalCase component detection |
| `TypeScript_ExtractsJsDoc` | JSDoc extraction |
| `Python_ExtractsClasses` | Python class pattern |
| `Python_ExtractsFunctions` | Top-level def pattern |
| `Python_ExtractsMethods` | Method (self) detection |
| `Python_ExtractsDocstrings` | Triple-quote docstring |
| `Python_TracksClassContext` | Parent class tracking |
| `Markdown_SplitsByHeadings` | Heading detection |
| `Markdown_HandlesParagraphs` | Large section splitting |
| `Markdown_PreservesHeadingAsTitle` | SymbolName assignment |
| `PlainText_ChunksAnyFile` | Universal fallback |
| `PlainText_RespectsOverlap` | Overlap calculation |

---

## File Summary

| File | Location | Purpose | Lines |
|------|----------|---------|-------|
| `CSharpChunkingStrategy.cs` | `Services/Chunking/` | C# specialized strategy | ~200 |
| `TypeScriptChunkingStrategy.cs` | `Services/Chunking/` | TS/JS specialized strategy | ~150 |
| `PythonChunkingStrategy.cs` | `Services/Chunking/` | Python specialized strategy | ~170 |
| `MarkdownChunkingStrategy.cs` | `Services/Chunking/` | Markdown heading-based | ~200 |
| `PlainTextChunkingStrategy.cs` | `Services/Chunking/` | Universal fallback | ~120 |

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | CSharpChunkingStrategy extracts C# symbols accurately |
| AC-2 | TypeScriptChunkingStrategy handles TS/JS patterns |
| AC-3 | PythonChunkingStrategy handles indentation-based blocks |
| AC-4 | XML/JSDoc/docstring documentation extraction works |
| AC-5 | Each strategy has higher priority than generic CodeAware |
| AC-6 | Qualified names built correctly with namespaces/classes |
| AC-7 | Markdown splits by headings correctly |
| AC-8 | PlainText serves as universal fallback |

---

## Changelog Entry

```markdown
## v0.7.1g - Language-Specific Chunkers

### Added
- `CSharpChunkingStrategy` (Priority 200)
  - Patterns: Namespace, Class, Record, Struct, Interface, Enum
  - Patterns: Method, Property, Constructor, Event, Delegate
  - XML documentation extraction (/// summary)
  - Qualified name building (Namespace.Class.Member)
  - Class hierarchy tracking for nested types
- `TypeScriptChunkingStrategy` (Priority 200)
  - Extensions: .ts, .tsx, .js, .jsx, .mjs
  - Patterns: Class, Interface, Type alias, Enum
  - Patterns: Function (regular, async, generator)
  - Patterns: Arrow functions, React components
  - JSDoc extraction (/** */)
- `PythonChunkingStrategy` (Priority 200)
  - Extensions: .py, .pyi
  - Line-by-line parsing for indentation awareness
  - Patterns: Class, Function (def), Method (self)
  - Class context tracking for method parent
  - Docstring extraction (""" and ''')
- `MarkdownChunkingStrategy` (Priority 150)
  - Extensions: .md, .markdown, .mdx
  - Heading-based section splitting
  - Paragraph splitting for large sections
  - Heading text used as chunk title
- `PlainTextChunkingStrategy` (Priority 0)
  - Extensions: .txt, .text, .log
  - Universal fallback (CanHandle returns true)
  - Line-based chunking with overlap
  - ChunkType.PlainText for all chunks

### Documentation Extraction
| Language | Format | Extraction Method |
|----------|--------|-------------------|
| C# | XML (///) | ExtractXmlDocumentation |
| TypeScript | JSDoc (/**) | ExtractJsDoc |
| Python | Docstring (""") | ExtractDocstring |

### Priority Order
1. Language-specific (200): CSharp, TypeScript, Python
2. Document-specific (150): Markdown
3. Generic code (100): CodeAware
4. Universal fallback (0): PlainText
```

---

## Timeline Estimate

| Version | Estimated Effort |
|---------|------------------|
| v0.7.1g | 1.0 day |
