# Design Specification: AIntern v0.7.2h "File Tracking & Change Detection"

## Overview

**Version**: v0.7.2h
**Parent**: v0.7.2 Vector Storage
**Focus**: Implement utilities for tracking file changes and computing content hashes for incremental indexing

### Purpose

Implement file tracking and change detection utilities:
1. Implement `FileHasher` for SHA-256 and quick hash computation
2. Implement `FileScanner` for directory scanning with include/exclude patterns
3. Implement `FileContentReader` for encoding detection and content reading
4. Support `.gitignore` pattern parsing
5. Provide change detection for incremental indexing

### Dependencies

**From v0.7.2b (Vector Index Models)**:
- `VectorIndexSettings` for scan configuration
- `FileChangeSet` for change detection results

**External Dependencies**:
- `Microsoft.Extensions.FileSystemGlobbing` - Glob pattern matching
- `UtfUnknown` (CharsetDetector) - Encoding detection
- `System.Security.Cryptography` - SHA-256 hashing

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                   v0.7.2h File Tracking & Change Detection                    │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Component Overview:                                                          │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  FileHasher.cs (static utility class)                                    │ │
│  │  ├── ComputeHashAsync(filePath)     ← Full SHA-256 hash of file         │ │
│  │  ├── ComputeHashAsync(stream)       ← SHA-256 hash of stream            │ │
│  │  ├── ComputeHash(string)            ← SHA-256 hash of string            │ │
│  │  ├── ComputeQuickHash(filePath)     ← Fast hash (size + mtime)          │ │
│  │  └── HasFileChanged(path, hash)     ← Quick change detection            │ │
│  │                                                                          │ │
│  │  FileScanner.cs (injectable service)                                     │ │
│  │  ├── ScanAsync()                    ← Scan directory for indexable files│ │
│  │  ├── ScanForChangesAsync()          ← Detect file changes               │ │
│  │  ├── LoadGitignoreAsync()           ← Parse .gitignore patterns         │ │
│  │  ├── ConvertGitignoreToGlob()       ← Convert patterns                  │ │
│  │  ├── DetectLanguage()               ← Language from extension           │ │
│  │  └── CountLinesAsync()              ← Count file lines                  │ │
│  │                                                                          │ │
│  │  FileContentReader.cs (static utility class)                             │ │
│  │  ├── ReadAsync()                    ← Read with encoding detection      │ │
│  │  ├── DetectEncodingAsync()          ← Detect file encoding              │ │
│  │  ├── ExtractLines()                 ← Extract line range                │ │
│  │  ├── GetLineNumber()                ← Offset → line number              │ │
│  │  └── GetLineOffset()                ← Line number → offset              │ │
│  │                                                                          │ │
│  │  Models:                                                                  │ │
│  │  ├── ScannedFile                    ← Scanned file info                 │ │
│  │  ├── FileScanProgress               ← Scan progress info                │ │
│  │  └── FileContent                    ← Read file content                 │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Scanning Flow

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                          FileScanner.ScanAsync Flow                           │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Input: rootPath, VectorIndexSettings, progress                              │
│       │                                                                      │
│       ▼                                                                      │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  1. Configure Matcher                                                    │ │
│  │     • Add IncludePatterns (*.cs, *.ts, *.py, etc.)                       │ │
│  │     • Add ExcludePatterns (bin/, obj/, node_modules/, etc.)              │ │
│  │     • If RespectGitignore → LoadGitignoreAsync() → add patterns         │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│       │                                                                      │
│       ▼                                                                      │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  2. Execute Pattern Matching                                             │ │
│  │     • DirectoryInfoWrapper(rootPath)                                     │ │
│  │     • matcher.Execute(directory)                                         │ │
│  │     • Returns matching file paths                                        │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│       │                                                                      │
│       ▼                                                                      │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  3. For Each Matched File:                                               │ │
│  │                                                                          │ │
│  │     ├── Skip if doesn't exist or is directory                           │ │
│  │     ├── Skip if hidden AND !IndexHiddenFiles                            │ │
│  │     ├── Skip if size < MinFileSizeBytes                                 │ │
│  │     ├── Skip if size > MaxFileSizeKb * 1024                             │ │
│  │     ├── Skip if symlink AND !FollowSymlinks                             │ │
│  │     │                                                                     │ │
│  │     ├── ComputeHashAsync(filePath) → ContentHash                        │ │
│  │     ├── DetectLanguage(relativePath) → Language                         │ │
│  │     ├── CountLinesAsync(filePath) → LineCount                           │ │
│  │     │                                                                     │ │
│  │     └── Create ScannedFile:                                              │ │
│  │         • RelativePath                                                    │ │
│  │         • AbsolutePath                                                    │ │
│  │         • Size                                                            │ │
│  │         • LastModified                                                    │ │
│  │         • ContentHash                                                     │ │
│  │         • Language                                                        │ │
│  │         • LineCount                                                       │ │
│  │                                                                          │ │
│  │     Report progress every 100 files                                      │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│       │                                                                      │
│       ▼                                                                      │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  4. Return Results                                                       │ │
│  │     • IReadOnlyList<ScannedFile>                                         │ │
│  │     • Report final progress (IsComplete = true)                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  Error Handling:                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  • IOException, UnauthorizedAccessException → Log warning, continue     │ │
│  │  • CancellationRequested → ThrowIfCancellationRequested()               │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Change Detection Flow

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                     ScanForChangesAsync Flow                                  │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Input: rootPath, settings, existingFileHashes (dict: path → hash)           │
│       │                                                                      │
│       ▼                                                                      │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  1. Scan Current Files                                                   │ │
│  │     currentFiles = await ScanAsync(rootPath, settings)                   │ │
│  │     currentByPath = { relativePath → contentHash }                       │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│       │                                                                      │
│       ▼                                                                      │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  2. Categorize Files                                                     │ │
│  │                                                                          │ │
│  │  Added:                                                                   │ │
│  │  └── Files in currentFiles NOT in existingFileHashes                    │ │
│  │                                                                          │ │
│  │  Modified:                                                                │ │
│  │  └── Files in BOTH but contentHash is different                         │ │
│  │                                                                          │ │
│  │  Deleted:                                                                 │ │
│  │  └── Files in existingFileHashes NOT in currentByPath                   │ │
│  │                                                                          │ │
│  │  Unchanged:                                                               │ │
│  │  └── Files in BOTH and contentHash is same                              │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│       │                                                                      │
│       ▼                                                                      │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  3. Return FileChangeSet                                                 │ │
│  │     • AddedFiles: List<string>                                           │ │
│  │     • ModifiedFiles: List<string>                                        │ │
│  │     • DeletedFiles: List<string>                                         │ │
│  │     • UnchangedFiles: List<string>                                       │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  Example Output:                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  FileChangeSet:                                                          │ │
│  │  ├── Added: ["src/NewFeature.cs", "tests/NewTests.cs"]                  │ │
│  │  ├── Modified: ["src/Program.cs", "src/Utils.cs"]                       │ │
│  │  ├── Deleted: ["src/OldFile.cs"]                                        │ │
│  │  └── Unchanged: ["src/Constants.cs", "src/Models.cs", ...]              │ │
│  │                                                                          │ │
│  │  HasChanges: true                                                        │ │
│  │  TotalChanges: 5                                                         │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Encoding Detection

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                       Encoding Detection Flow                                 │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  DetectEncodingAsync(filePath):                                              │
│       │                                                                      │
│       ▼                                                                      │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  1. Read Sample (first 64KB)                                             │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│       │                                                                      │
│       ▼                                                                      │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  2. Check for BOM (Byte Order Mark)                                      │ │
│  │                                                                          │ │
│  │  ┌─────────────────────────────┬──────────────────────────────────────┐ │ │
│  │  │ BOM Bytes                   │ Encoding                              │ │ │
│  │  │ ─────────────────────────── │ ──────────────────────────────────── │ │ │
│  │  │ EF BB BF                    │ UTF-8                                 │ │ │
│  │  │ FF FE                       │ UTF-16 LE (Unicode)                   │ │ │
│  │  │ FE FF                       │ UTF-16 BE (BigEndianUnicode)          │ │ │
│  │  └─────────────────────────────┴──────────────────────────────────────┘ │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│       │                                                                      │
│       ▼ (No BOM found)                                                       │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  3. Charset Detection via UtfUnknown                                     │ │
│  │                                                                          │ │
│  │     result = CharsetDetector.DetectFromBytes(buffer)                     │ │
│  │                                                                          │ │
│  │     If result.Confidence > 0.7:                                          │ │
│  │       └── Use detected encoding                                          │ │
│  │     Else:                                                                 │ │
│  │       └── Default to UTF-8                                               │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│       │                                                                      │
│       ▼                                                                      │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  4. Return Encoding                                                      │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  Common Encodings Detected:                                                   │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  • UTF-8 (most common for source code)                                   │ │
│  │  • UTF-16 LE/BE (Windows files)                                          │ │
│  │  • Windows-1252/ISO-8859-1 (legacy Latin)                                │ │
│  │  • Shift_JIS (Japanese)                                                  │ │
│  │  • GB2312/GBK (Chinese)                                                  │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Language Detection

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                        Language Detection by Extension                        │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  DetectLanguage(relativePath) → string?                                      │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  Extension(s)          │ Language                                        │ │
│  │  ══════════════════════╪════════════════════════════════════════════════ │ │
│  │  .cs                   │ csharp                                          │ │
│  │  .fs                   │ fsharp                                          │ │
│  │  .vb                   │ vb                                              │ │
│  │  .ts, .tsx             │ typescript                                      │ │
│  │  .js, .jsx             │ javascript                                      │ │
│  │  .py, .pyi             │ python                                          │ │
│  │  .java                 │ java                                            │ │
│  │  .kt                   │ kotlin                                          │ │
│  │  .go                   │ go                                              │ │
│  │  .rs                   │ rust                                            │ │
│  │  .cpp, .cc, .cxx       │ cpp                                             │ │
│  │  .c                    │ c                                               │ │
│  │  .h, .hpp              │ cpp                                             │ │
│  │  .swift                │ swift                                           │ │
│  │  .rb                   │ ruby                                            │ │
│  │  .php                  │ php                                             │ │
│  │  .lua                  │ lua                                             │ │
│  │  .scala                │ scala                                           │ │
│  │  .groovy               │ groovy                                          │ │
│  │  .md                   │ markdown                                        │ │
│  │  .json                 │ json                                            │ │
│  │  .yaml, .yml           │ yaml                                            │ │
│  │  .xml                  │ xml                                             │ │
│  │  .html, .htm           │ html                                            │ │
│  │  .css                  │ css                                             │ │
│  │  .scss, .sass          │ scss                                            │ │
│  │  (other)               │ null                                            │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Specifications

### 1. FileHasher.cs

**Location**: `src/SeniorIntern.Services/VectorStore/FileHasher.cs`

```csharp
namespace SeniorIntern.Services.VectorStore;

using System;
using System.IO;
using System.Security.Cryptography;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

/// <summary>
/// Utility for computing file content hashes for change detection.
/// </summary>
public static class FileHasher
{
    /// <summary>
    /// Buffer size for async file reading.
    /// </summary>
    private const int BufferSize = 81920; // 80KB

    #region Full Content Hash

    /// <summary>
    /// Computes SHA-256 hash of file contents.
    /// </summary>
    /// <param name="filePath">Path to the file.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>Lowercase hex SHA-256 hash.</returns>
    /// <exception cref="FileNotFoundException">File does not exist.</exception>
    public static async Task<string> ComputeHashAsync(
        string filePath,
        CancellationToken ct = default)
    {
        await using var stream = new FileStream(
            filePath,
            FileMode.Open,
            FileAccess.Read,
            FileShare.Read,
            bufferSize: BufferSize,
            useAsync: true);

        return await ComputeHashAsync(stream, ct);
    }

    /// <summary>
    /// Computes SHA-256 hash of stream contents.
    /// </summary>
    /// <param name="stream">Stream to hash.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>Lowercase hex SHA-256 hash.</returns>
    public static async Task<string> ComputeHashAsync(
        Stream stream,
        CancellationToken ct = default)
    {
        using var sha256 = SHA256.Create();
        var hashBytes = await sha256.ComputeHashAsync(stream, ct);
        return Convert.ToHexString(hashBytes).ToLowerInvariant();
    }

    /// <summary>
    /// Computes SHA-256 hash of string content.
    /// </summary>
    /// <param name="content">String to hash.</param>
    /// <returns>Lowercase hex SHA-256 hash.</returns>
    public static string ComputeHash(string content)
    {
        var bytes = Encoding.UTF8.GetBytes(content);
        var hashBytes = SHA256.HashData(bytes);
        return Convert.ToHexString(hashBytes).ToLowerInvariant();
    }

    #endregion

    #region Quick Hash

    /// <summary>
    /// Computes a quick hash combining file size and modification time.
    /// </summary>
    /// <remarks>
    /// This is much faster than reading file contents but may produce
    /// false negatives (same quick hash but different content) in rare cases
    /// like atomic file replacement with same timestamp.
    /// </remarks>
    /// <param name="filePath">Path to the file.</param>
    /// <returns>Lowercase hex hash, or empty string if file doesn't exist.</returns>
    public static string ComputeQuickHash(string filePath)
    {
        var info = new FileInfo(filePath);
        if (!info.Exists)
            return string.Empty;

        var combined = $"{info.Length}|{info.LastWriteTimeUtc.Ticks}";
        return ComputeHash(combined);
    }

    /// <summary>
    /// Checks if a file has changed by comparing quick hashes.
    /// </summary>
    /// <param name="filePath">Path to the file.</param>
    /// <param name="previousQuickHash">Previously computed quick hash.</param>
    /// <returns>True if the file has changed.</returns>
    public static bool HasFileChanged(
        string filePath,
        string previousQuickHash)
    {
        var currentHash = ComputeQuickHash(filePath);
        return currentHash != previousQuickHash;
    }

    /// <summary>
    /// Computes both quick hash and full content hash.
    /// </summary>
    /// <param name="filePath">Path to the file.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>Tuple of (quickHash, contentHash).</returns>
    public static async Task<(string QuickHash, string ContentHash)> ComputeBothHashesAsync(
        string filePath,
        CancellationToken ct = default)
    {
        var quickHash = ComputeQuickHash(filePath);
        var contentHash = await ComputeHashAsync(filePath, ct);
        return (quickHash, contentHash);
    }

    #endregion
}
```

### 2. FileScanner.cs

**Location**: `src/SeniorIntern.Services/VectorStore/FileScanner.cs`

```csharp
namespace SeniorIntern.Services.VectorStore;

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.FileSystemGlobbing;
using Microsoft.Extensions.FileSystemGlobbing.Abstractions;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Models;

/// <summary>
/// Scans directories for files to index based on patterns.
/// </summary>
public sealed class FileScanner
{
    private readonly ILogger<FileScanner> _logger;

    public FileScanner(ILogger<FileScanner> logger)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    #region Scanning

    /// <summary>
    /// Scans a directory for files matching the index settings.
    /// </summary>
    /// <param name="rootPath">Root directory path.</param>
    /// <param name="settings">Indexing settings.</param>
    /// <param name="progress">Progress reporter.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>List of scanned files.</returns>
    public async Task<IReadOnlyList<ScannedFile>> ScanAsync(
        string rootPath,
        VectorIndexSettings settings,
        IProgress<FileScanProgress>? progress = null,
        CancellationToken ct = default)
    {
        _logger.LogInformation("Scanning {Path} for indexable files", rootPath);

        var files = new List<ScannedFile>();
        var matcher = new Matcher();

        // Add include patterns
        foreach (var pattern in settings.IncludePatterns)
        {
            matcher.AddInclude(pattern);
        }

        // Add exclude patterns
        foreach (var pattern in settings.ExcludePatterns)
        {
            matcher.AddExclude(pattern);
        }

        // Load and add .gitignore patterns if enabled
        if (settings.RespectGitignore)
        {
            var gitignorePatterns = await LoadGitignoreAsync(rootPath, ct);
            foreach (var pattern in gitignorePatterns)
            {
                matcher.AddExclude(pattern);
            }
        }

        // Execute pattern matching
        var directory = new DirectoryInfoWrapper(new DirectoryInfo(rootPath));
        var matches = matcher.Execute(directory);

        var maxSizeBytes = settings.MaxFileSizeKb * 1024L;
        var processedCount = 0;

        foreach (var match in matches.Files)
        {
            ct.ThrowIfCancellationRequested();

            var fullPath = Path.Combine(rootPath, match.Path);
            var relativePath = match.Path.Replace('\\', '/');

            try
            {
                var fileInfo = new FileInfo(fullPath);

                // Validate file
                if (!ShouldIncludeFile(fileInfo, settings, maxSizeBytes, out var skipReason))
                {
                    _logger.LogDebug("Skipping {Path}: {Reason}", relativePath, skipReason);
                    continue;
                }

                // Compute hash and gather metadata
                var hash = await FileHasher.ComputeHashAsync(fullPath, ct);
                var language = DetectLanguage(relativePath);
                var lineCount = await CountLinesAsync(fullPath, ct);

                files.Add(new ScannedFile
                {
                    RelativePath = relativePath,
                    AbsolutePath = fullPath,
                    Size = fileInfo.Length,
                    LastModified = fileInfo.LastWriteTimeUtc,
                    ContentHash = hash,
                    Language = language,
                    LineCount = lineCount
                });

                processedCount++;

                // Report progress periodically
                if (processedCount % 100 == 0)
                {
                    progress?.Report(new FileScanProgress
                    {
                        ScannedCount = processedCount,
                        CurrentPath = relativePath
                    });
                }
            }
            catch (Exception ex) when (ex is IOException or UnauthorizedAccessException)
            {
                _logger.LogWarning("Cannot access file {Path}: {Message}", relativePath, ex.Message);
            }
        }

        _logger.LogInformation("Scan complete: found {Count} indexable files", files.Count);

        progress?.Report(new FileScanProgress
        {
            ScannedCount = files.Count,
            IsComplete = true
        });

        return files;
    }

    /// <summary>
    /// Scans for files that have changed since last index.
    /// </summary>
    public async Task<FileChangeSet> ScanForChangesAsync(
        string rootPath,
        VectorIndexSettings settings,
        IReadOnlyDictionary<string, string> existingFileHashes,
        CancellationToken ct = default)
    {
        _logger.LogInformation("Scanning for file changes in {Path}", rootPath);

        var currentFiles = await ScanAsync(rootPath, settings, null, ct);
        var currentByPath = currentFiles.ToDictionary(f => f.RelativePath, f => f.ContentHash);

        var added = currentFiles
            .Where(f => !existingFileHashes.ContainsKey(f.RelativePath))
            .Select(f => f.RelativePath)
            .ToList();

        var modified = currentFiles
            .Where(f => existingFileHashes.TryGetValue(f.RelativePath, out var hash) &&
                       hash != f.ContentHash)
            .Select(f => f.RelativePath)
            .ToList();

        var deleted = existingFileHashes.Keys
            .Where(p => !currentByPath.ContainsKey(p))
            .ToList();

        var unchanged = currentFiles
            .Where(f => existingFileHashes.TryGetValue(f.RelativePath, out var hash) &&
                       hash == f.ContentHash)
            .Select(f => f.RelativePath)
            .ToList();

        var changeSet = new FileChangeSet
        {
            AddedFiles = added,
            ModifiedFiles = modified,
            DeletedFiles = deleted,
            UnchangedFiles = unchanged
        };

        _logger.LogInformation(
            "Change detection complete: {Added} added, {Modified} modified, {Deleted} deleted, {Unchanged} unchanged",
            added.Count, modified.Count, deleted.Count, unchanged.Count);

        return changeSet;
    }

    #endregion

    #region File Validation

    private static bool ShouldIncludeFile(
        FileInfo fileInfo,
        VectorIndexSettings settings,
        long maxSizeBytes,
        out string? skipReason)
    {
        skipReason = null;

        // Must exist and not be a directory
        if (!fileInfo.Exists || (fileInfo.Attributes & FileAttributes.Directory) != 0)
        {
            skipReason = "does not exist or is directory";
            return false;
        }

        // Check hidden files
        if (!settings.IndexHiddenFiles && IsHidden(fileInfo))
        {
            skipReason = "hidden file";
            return false;
        }

        // Check size limits
        if (fileInfo.Length < settings.MinFileSizeBytes)
        {
            skipReason = $"too small ({fileInfo.Length} bytes)";
            return false;
        }

        if (fileInfo.Length > maxSizeBytes)
        {
            skipReason = $"too large ({fileInfo.Length} bytes)";
            return false;
        }

        // Check symlinks
        if (!settings.FollowSymlinks && IsSymlink(fileInfo))
        {
            skipReason = "symlink";
            return false;
        }

        return true;
    }

    private static bool IsHidden(FileInfo file)
    {
        return file.Name.StartsWith('.') ||
               (file.Attributes & FileAttributes.Hidden) != 0;
    }

    private static bool IsSymlink(FileInfo file)
    {
        return (file.Attributes & FileAttributes.ReparsePoint) != 0;
    }

    #endregion

    #region .gitignore

    private async Task<IReadOnlyList<string>> LoadGitignoreAsync(
        string rootPath,
        CancellationToken ct)
    {
        var gitignorePath = Path.Combine(rootPath, ".gitignore");
        if (!File.Exists(gitignorePath))
        {
            _logger.LogDebug("No .gitignore found at {Path}", gitignorePath);
            return Array.Empty<string>();
        }

        var patterns = new List<string>();
        var lines = await File.ReadAllLinesAsync(gitignorePath, ct);

        foreach (var line in lines)
        {
            var trimmed = line.Trim();

            // Skip empty lines and comments
            if (string.IsNullOrEmpty(trimmed) || trimmed.StartsWith('#'))
                continue;

            var pattern = ConvertGitignoreToGlob(trimmed);
            if (!string.IsNullOrEmpty(pattern))
            {
                patterns.Add(pattern);
            }
        }

        _logger.LogDebug("Loaded {Count} patterns from .gitignore", patterns.Count);
        return patterns;
    }

    private static string ConvertGitignoreToGlob(string gitignorePattern)
    {
        var pattern = gitignorePattern.TrimStart('/');

        // Handle directory patterns (ending with /)
        if (pattern.EndsWith('/'))
        {
            pattern = pattern.TrimEnd('/') + "/**";
        }

        // Add recursive wildcard prefix if not anchored
        if (!gitignorePattern.StartsWith('/') && !pattern.StartsWith("**/"))
        {
            pattern = "**/" + pattern;
        }

        return pattern;
    }

    #endregion

    #region Language Detection

    /// <summary>
    /// Detects programming language from file extension.
    /// </summary>
    public static string? DetectLanguage(string relativePath)
    {
        var ext = Path.GetExtension(relativePath).ToLowerInvariant();
        return ext switch
        {
            ".cs" => "csharp",
            ".fs" => "fsharp",
            ".vb" => "vb",
            ".ts" or ".tsx" => "typescript",
            ".js" or ".jsx" => "javascript",
            ".py" or ".pyi" => "python",
            ".java" => "java",
            ".kt" => "kotlin",
            ".go" => "go",
            ".rs" => "rust",
            ".cpp" or ".cc" or ".cxx" => "cpp",
            ".c" => "c",
            ".h" or ".hpp" => "cpp",
            ".swift" => "swift",
            ".rb" => "ruby",
            ".php" => "php",
            ".lua" => "lua",
            ".scala" => "scala",
            ".groovy" => "groovy",
            ".md" => "markdown",
            ".json" => "json",
            ".yaml" or ".yml" => "yaml",
            ".xml" => "xml",
            ".html" or ".htm" => "html",
            ".css" => "css",
            ".scss" or ".sass" => "scss",
            ".sql" => "sql",
            ".sh" or ".bash" => "shell",
            ".ps1" => "powershell",
            _ => null
        };
    }

    #endregion

    #region Utilities

    private static async Task<int> CountLinesAsync(string filePath, CancellationToken ct)
    {
        var lineCount = 0;
        await using var stream = File.OpenRead(filePath);
        using var reader = new StreamReader(stream);

        while (await reader.ReadLineAsync(ct) != null)
        {
            lineCount++;
        }

        return lineCount;
    }

    #endregion
}
```

### 3. ScannedFile.cs

**Location**: `src/SeniorIntern.Core/Models/ScannedFile.cs`

```csharp
namespace SeniorIntern.Core.Models;

using System;

/// <summary>
/// Information about a scanned file.
/// </summary>
public sealed class ScannedFile
{
    /// <summary>
    /// Relative path from workspace root.
    /// </summary>
    public required string RelativePath { get; init; }

    /// <summary>
    /// Full absolute path.
    /// </summary>
    public required string AbsolutePath { get; init; }

    /// <summary>
    /// File size in bytes.
    /// </summary>
    public long Size { get; init; }

    /// <summary>
    /// Last modification time (UTC).
    /// </summary>
    public DateTime LastModified { get; init; }

    /// <summary>
    /// SHA-256 hash of file content.
    /// </summary>
    public required string ContentHash { get; init; }

    /// <summary>
    /// Detected programming language, if known.
    /// </summary>
    public string? Language { get; init; }

    /// <summary>
    /// Number of lines in the file.
    /// </summary>
    public int LineCount { get; init; }

    /// <summary>
    /// Formatted file size for display.
    /// </summary>
    public string FormattedSize => FormatBytes(Size);

    private static string FormatBytes(long bytes)
    {
        return bytes switch
        {
            < 1024 => $"{bytes} B",
            < 1024 * 1024 => $"{bytes / 1024.0:F1} KB",
            < 1024 * 1024 * 1024 => $"{bytes / (1024.0 * 1024):F1} MB",
            _ => $"{bytes / (1024.0 * 1024 * 1024):F2} GB"
        };
    }
}
```

### 4. FileScanProgress.cs

**Location**: `src/SeniorIntern.Core/Models/FileScanProgress.cs`

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Progress information for file scanning operations.
/// </summary>
public sealed class FileScanProgress
{
    /// <summary>
    /// Number of files scanned so far.
    /// </summary>
    public int ScannedCount { get; init; }

    /// <summary>
    /// Current file being processed.
    /// </summary>
    public string? CurrentPath { get; init; }

    /// <summary>
    /// Whether the scan is complete.
    /// </summary>
    public bool IsComplete { get; init; }

    /// <summary>
    /// Status message for display.
    /// </summary>
    public string Message => IsComplete
        ? $"Scan complete: {ScannedCount} files"
        : $"Scanning: {ScannedCount} files...";
}
```

### 5. FileContentReader.cs

**Location**: `src/SeniorIntern.Services/VectorStore/FileContentReader.cs`

```csharp
namespace SeniorIntern.Services.VectorStore;

using System;
using System.IO;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using UtfUnknown;

/// <summary>
/// Reads file content with automatic encoding detection.
/// </summary>
public static class FileContentReader
{
    private const int DetectionSampleSize = 65536; // 64KB for encoding detection

    #region Reading

    /// <summary>
    /// Reads file content with automatic encoding detection.
    /// </summary>
    /// <param name="filePath">Path to the file.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>File content with metadata.</returns>
    public static async Task<FileContent> ReadAsync(
        string filePath,
        CancellationToken ct = default)
    {
        var encoding = await DetectEncodingAsync(filePath, ct);
        var content = await File.ReadAllTextAsync(filePath, encoding, ct);

        // Normalize line endings to LF
        content = content.Replace("\r\n", "\n").Replace("\r", "\n");

        return new FileContent
        {
            Content = content,
            Encoding = encoding.WebName,
            LineCount = CountLines(content),
            CharacterCount = content.Length
        };
    }

    #endregion

    #region Encoding Detection

    /// <summary>
    /// Detects the encoding of a file.
    /// </summary>
    /// <param name="filePath">Path to the file.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>Detected encoding (defaults to UTF-8).</returns>
    public static async Task<Encoding> DetectEncodingAsync(
        string filePath,
        CancellationToken ct = default)
    {
        await using var stream = File.OpenRead(filePath);

        // Read a sample for detection
        var bufferSize = (int)Math.Min(DetectionSampleSize, stream.Length);
        var buffer = new byte[bufferSize];
        var bytesRead = await stream.ReadAsync(buffer.AsMemory(0, bufferSize), ct);

        if (bytesRead == 0)
            return Encoding.UTF8;

        // Check for BOM first
        if (bytesRead >= 3 && buffer[0] == 0xEF && buffer[1] == 0xBB && buffer[2] == 0xBF)
            return Encoding.UTF8;
        if (bytesRead >= 2 && buffer[0] == 0xFF && buffer[1] == 0xFE)
            return Encoding.Unicode;
        if (bytesRead >= 2 && buffer[0] == 0xFE && buffer[1] == 0xFF)
            return Encoding.BigEndianUnicode;

        // Use character detection library
        var result = CharsetDetector.DetectFromBytes(buffer.AsSpan(0, bytesRead));

        if (result.Detected != null && result.Detected.Confidence > 0.7f)
        {
            try
            {
                return Encoding.GetEncoding(result.Detected.EncodingName);
            }
            catch
            {
                // Fall back to UTF-8 on invalid encoding name
            }
        }

        return Encoding.UTF8;
    }

    #endregion

    #region Line Utilities

    /// <summary>
    /// Extracts lines from content within a range.
    /// </summary>
    /// <param name="content">Full file content.</param>
    /// <param name="startLine">Start line number (1-based).</param>
    /// <param name="endLine">End line number (1-based, inclusive).</param>
    /// <returns>Extracted content.</returns>
    public static string ExtractLines(
        string content,
        int startLine,
        int endLine)
    {
        var lines = content.Split('\n');
        var sb = new StringBuilder();

        // Convert to 0-based index
        var start = Math.Max(0, startLine - 1);
        var end = Math.Min(lines.Length, endLine);

        for (int i = start; i < end; i++)
        {
            if (sb.Length > 0)
                sb.Append('\n');
            sb.Append(lines[i]);
        }

        return sb.ToString();
    }

    /// <summary>
    /// Gets the line number for a character offset.
    /// </summary>
    /// <param name="content">File content.</param>
    /// <param name="offset">Character offset (0-based).</param>
    /// <returns>Line number (1-based).</returns>
    public static int GetLineNumber(string content, int offset)
    {
        var line = 1;
        for (int i = 0; i < Math.Min(offset, content.Length); i++)
        {
            if (content[i] == '\n')
                line++;
        }
        return line;
    }

    /// <summary>
    /// Gets the character offset for a line number.
    /// </summary>
    /// <param name="content">File content.</param>
    /// <param name="lineNumber">Line number (1-based).</param>
    /// <returns>Character offset (0-based).</returns>
    public static int GetLineOffset(string content, int lineNumber)
    {
        var currentLine = 1;
        for (int i = 0; i < content.Length; i++)
        {
            if (currentLine == lineNumber)
                return i;
            if (content[i] == '\n')
                currentLine++;
        }
        return content.Length;
    }

    #endregion

    #region Utilities

    private static int CountLines(string content)
    {
        if (string.IsNullOrEmpty(content))
            return 0;

        var count = 1;
        foreach (var c in content)
        {
            if (c == '\n')
                count++;
        }
        return count;
    }

    #endregion
}
```

### 6. FileContent.cs

**Location**: `src/SeniorIntern.Core/Models/FileContent.cs`

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Result of reading file content.
/// </summary>
public sealed class FileContent
{
    /// <summary>
    /// File content with normalized line endings.
    /// </summary>
    public required string Content { get; init; }

    /// <summary>
    /// Detected encoding name.
    /// </summary>
    public required string Encoding { get; init; }

    /// <summary>
    /// Number of lines in the file.
    /// </summary>
    public int LineCount { get; init; }

    /// <summary>
    /// Number of characters in the content.
    /// </summary>
    public int CharacterCount { get; init; }
}
```

---

## Unit Test Plan

| Test | Description |
|------|-------------|
| `FileHasher_ComputeHashAsync_ProducesConsistentHash` | Same file, same hash |
| `FileHasher_ComputeHash_String_MatchesFile` | String hash matches file |
| `FileHasher_ComputeQuickHash_ChangesWithModification` | Quick hash changes |
| `FileHasher_HasFileChanged_DetectsChange` | Change detection |
| `FileScanner_ScanAsync_FindsMatchingFiles` | Basic scanning |
| `FileScanner_ScanAsync_RespectsExcludePatterns` | Exclude patterns |
| `FileScanner_ScanAsync_RespectsGitignore` | .gitignore support |
| `FileScanner_ScanAsync_SkipsHiddenFiles` | Hidden file handling |
| `FileScanner_ScanAsync_SkipsOversizedFiles` | Size limit |
| `FileScanner_ScanForChangesAsync_DetectsAdded` | Added files |
| `FileScanner_ScanForChangesAsync_DetectsModified` | Modified files |
| `FileScanner_ScanForChangesAsync_DetectsDeleted` | Deleted files |
| `FileScanner_DetectLanguage_IdentifiesLanguages` | Language detection |
| `FileContentReader_ReadAsync_DetectsUTF8` | UTF-8 detection |
| `FileContentReader_ReadAsync_DetectsUTF16` | UTF-16 detection |
| `FileContentReader_ExtractLines_ExtractsCorrectRange` | Line extraction |
| `FileContentReader_GetLineNumber_CalculatesCorrectly` | Offset → line |
| `FileContentReader_GetLineOffset_CalculatesCorrectly` | Line → offset |

---

## File Summary

| File | Location | Purpose | Lines |
|------|----------|---------|-------|
| `FileHasher.cs` | `Services/VectorStore/` | Content hashing | ~90 |
| `FileScanner.cs` | `Services/VectorStore/` | Directory scanning | ~280 |
| `FileContentReader.cs` | `Services/VectorStore/` | Encoding detection | ~130 |
| `ScannedFile.cs` | `Core/Models/` | Scanned file info | ~50 |
| `FileScanProgress.cs` | `Core/Models/` | Scan progress | ~30 |
| `FileContent.cs` | `Core/Models/` | File content result | ~30 |

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | `FileHasher.ComputeHashAsync` produces consistent SHA-256 |
| AC-2 | `FileHasher.ComputeQuickHash` uses size + mtime |
| AC-3 | `FileScanner.ScanAsync` finds files matching patterns |
| AC-4 | `FileScanner` respects all VectorIndexSettings options |
| AC-5 | `.gitignore` patterns are converted correctly |
| AC-6 | `ScanForChangesAsync` correctly categorizes changes |
| AC-7 | `DetectLanguage` identifies common languages |
| AC-8 | `FileContentReader` detects UTF-8, UTF-16 encodings |
| AC-9 | Line endings are normalized to LF |
| AC-10 | Progress is reported periodically |

---

## Changelog Entry

```markdown
## v0.7.2h - File Tracking & Change Detection

### Added
- `FileHasher.cs` static utility class
  - `ComputeHashAsync(filePath)` - SHA-256 of file
  - `ComputeHashAsync(stream)` - SHA-256 of stream
  - `ComputeHash(string)` - SHA-256 of string
  - `ComputeQuickHash(filePath)` - Fast size+mtime hash
  - `HasFileChanged()` - Quick change detection
  - `ComputeBothHashesAsync()` - Both hashes at once

- `FileScanner.cs` injectable service
  - `ScanAsync()` - Directory scanning with patterns
  - `ScanForChangesAsync()` - Incremental change detection
  - `LoadGitignoreAsync()` - .gitignore parsing
  - `ConvertGitignoreToGlob()` - Pattern conversion
  - `DetectLanguage()` - Extension-based detection

- `FileContentReader.cs` static utility class
  - `ReadAsync()` - Read with encoding detection
  - `DetectEncodingAsync()` - BOM + charset detection
  - `ExtractLines()` - Extract line range
  - `GetLineNumber()` - Offset to line
  - `GetLineOffset()` - Line to offset

- Models:
  - `ScannedFile` - Scanned file information
  - `FileScanProgress` - Scan progress reporting
  - `FileContent` - Read file result

### Features
- SHA-256 content hashing with 80KB buffer
- Quick hash for fast change detection
- Microsoft.Extensions.FileSystemGlobbing integration
- .gitignore pattern conversion to glob
- Automatic encoding detection (BOM + CharsetDetector)
- Line ending normalization (CRLF/CR → LF)
- Language detection for 25+ languages
```

---

## Timeline Estimate

| Version | Estimated Effort |
|---------|------------------|
| v0.7.2h | 0.75 day |
