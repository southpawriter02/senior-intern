# Design Specification: AIntern v0.7.4b "Query & Result Models"

## Overview

**Version**: v0.7.4b  
**Parent**: v0.7.4 Retrieval & Context  
**Focus**: Define the data models for knowledge queries and results, including relevance scoring and metadata

### Purpose

This sub-version defines the core data models for the knowledge retrieval layer:
1. `KnowledgeQueryOptions` - Options for querying the knowledge base
2. `KnowledgeQueryResult` - Container for query results with metadata
3. `KnowledgeChunk` - Single chunk of knowledge with relevance scoring
4. `TextHighlight` - Highlighted region for keyword matches
5. `RelevantFile` - File-level relevance aggregation
6. `KnowledgeIndexHealth` - Index health and statistics
7. `RerankingStrategy` - Enum for reranking algorithm selection

### Dependencies

**From v0.7.1 (Embedding Foundation)**:
- `SymbolType` enum (v0.7.1d) - Used for symbol type filtering

**From v0.7.4a (Knowledge Service Interface)**:
- `IKnowledgeService` consumes all models defined here

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                     v0.7.4b Query & Result Models                             │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  src/SeniorIntern.Core/Models/                                               │
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │                                                                          ││
│  │  KnowledgeQueryOptions                                                   ││
│  │  ├── WorkspacePath: string              (required)                       ││
│  │  ├── MaxResults: int                    (default: 10)                    ││
│  │  ├── MinRelevance: float                (default: 0.5)                   ││
│  │  ├── ExpandContext: bool                (default: true)                  ││
│  │  ├── ContextLines: int                  (default: 10)                    ││
│  │  ├── FilePatterns: IReadOnlyList<string>?                                ││
│  │  ├── Languages: IReadOnlyList<string>?                                   ││
│  │  ├── IncludeSnippets: bool              (default: true)                  ││
│  │  ├── Reranking: RerankingStrategy       (default: None)                  ││
│  │  ├── DeduplicateChunks: bool            (default: true)                  ││
│  │  ├── DirectoryFilters: IReadOnlyList<string>?                            ││
│  │  ├── BoostExactMatches: bool            (default: false)                 ││
│  │  └── SymbolTypes: IReadOnlyList<SymbolType>?                             ││
│  │                                                                          ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │  KnowledgeQueryResult                                                    ││
│  │  ├── Chunks: IReadOnlyList<KnowledgeChunk>                               ││
│  │  ├── RelevantFiles: IReadOnlyList<string>                                ││
│  │  ├── QueryTime: TimeSpan                                                 ││
│  │  ├── TotalChunksSearched: int                                            ││
│  │  ├── ChunksAboveThreshold: int                                           ││
│  │  ├── QueryEmbedding: float[]?                                            ││
│  │  ├── WasReranked: bool                                                   ││
│  │  ├── RerankingApplied: RerankingStrategy                                 ││
│  │  ├── CacheHit: bool                                                      ││
│  │  ├── HasResults: bool (computed)                                         ││
│  │  └── Empty: KnowledgeQueryResult (static)                                ││
│  │                                                                          ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │  KnowledgeChunk                                                          ││
│  │  ├── Content: string                                                     ││
│  │  ├── FilePath: string                                                    ││
│  │  ├── StartLine / EndLine: int                                            ││
│  │  ├── Relevance / OriginalScore: float                                    ││
│  │  ├── Language: string?                                                   ││
│  │  ├── SymbolName: string?, SymbolType: SymbolType?                        ││
│  │  ├── ExpandedContext: string?                                            ││
│  │  ├── Highlights: IReadOnlyList<TextHighlight>?                           ││
│  │  ├── ChunkId: string, FileHash: string?                                  ││
│  │  └──────────────────────────────────────────────────────────────────────││
│  │                                                                          ││
│  │  TextHighlight                                                           ││
│  │  ├── Start: int, Length: int                                             ││
│  │  └── MatchedKeyword: string?                                             ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │  RelevantFile                                                            ││
│  │  ├── FilePath: string, Relevance: float, MatchCount: int                 ││
│  │  ├── Summary: string?, Language: string?                                 ││
│  │  └── MatchLines: IReadOnlyList<int>?                                     ││
│  │                                                                          ││
│  │  KnowledgeIndexHealth                                                    ││
│  │  ├── IsIndexed: bool, IndexId: string?, IndexName: string?               ││
│  │  ├── TotalFiles: int, TotalChunks: int, StaleFiles: int                  ││
│  │  ├── LastUpdated: DateTime?, CreatedAt: DateTime?                        ││
│  │  ├── NeedsReindex: bool, EmbeddingModel: string?                         ││
│  │  ├── EmbeddingDimension: int, IndexSizeBytes: long                       ││
│  │  ├── AverageChunksPerFile, StalePercentage, FormattedSize (computed)     ││
│  │  ├── StatusMessage: string (computed)                                    ││
│  │  └── NotIndexed: KnowledgeIndexHealth (static)                           ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │  RerankingStrategy (enum)                                                ││
│  │  ├── None = 0         (embedding similarity only)                        ││
│  │  ├── KeywordBoost = 1 (boost keyword matches)                            ││
│  │  ├── RRF = 2          (Reciprocal Rank Fusion)                           ││
│  │  └── CrossEncoder = 3 (cross-encoder model - future)                     ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Models/KnowledgeQueryOptions.cs` | Query options with filtering and reranking configuration |
| `src/SeniorIntern.Core/Models/KnowledgeQueryResult.cs` | Query result container with chunks and metadata |
| `src/SeniorIntern.Core/Models/KnowledgeIndexHealth.cs` | Index health statistics and status |

---

## Detailed Specifications

### 1. KnowledgeQueryOptions.cs

**Location**: `src/SeniorIntern.Core/Models/KnowledgeQueryOptions.cs`

```csharp
using System;
using System.Collections.Generic;

namespace SeniorIntern.Core.Models;

/// <summary>
/// Options for querying the knowledge base.
/// </summary>
/// <remarks>
/// <para>
/// Provides comprehensive control over search behavior including:
/// <list type="bullet">
///   <item>Result limits and relevance thresholds</item>
///   <item>File and language filtering</item>
///   <item>Context expansion settings</item>
///   <item>Reranking strategy selection</item>
/// </list>
/// </para>
/// </remarks>
/// <example>
/// Basic usage:
/// <code>
/// var options = new KnowledgeQueryOptions
/// {
///     WorkspacePath = "/path/to/project",
///     MaxResults = 15,
///     MinRelevance = 0.6f,
///     Languages = new[] { "csharp" },
///     Reranking = RerankingStrategy.KeywordBoost
/// };
/// </code>
/// </example>
public sealed class KnowledgeQueryOptions
{
    /// <summary>
    /// Workspace path to search in. Required.
    /// </summary>
    public string WorkspacePath { get; init; } = string.Empty;

    /// <summary>
    /// Maximum number of results to return.
    /// Default: 10
    /// </summary>
    public int MaxResults { get; init; } = 10;

    /// <summary>
    /// Minimum relevance score threshold (0.0 to 1.0).
    /// Results below this score will be filtered out.
    /// Default: 0.5
    /// </summary>
    public float MinRelevance { get; init; } = 0.5f;

    /// <summary>
    /// Whether to expand context around matched chunks.
    /// When true, surrounding lines will be included.
    /// Default: true
    /// </summary>
    public bool ExpandContext { get; init; } = true;

    /// <summary>
    /// Number of lines to include around matches when ExpandContext is true.
    /// Default: 10
    /// </summary>
    public int ContextLines { get; init; } = 10;

    /// <summary>
    /// File glob patterns to include in search.
    /// If null or empty, all indexed files are searched.
    /// Example: ["*.cs", "*.ts"]
    /// </summary>
    public IReadOnlyList<string>? FilePatterns { get; init; }

    /// <summary>
    /// Programming languages to filter results.
    /// If null or empty, all languages are included.
    /// Example: ["csharp", "typescript"]
    /// </summary>
    public IReadOnlyList<string>? Languages { get; init; }

    /// <summary>
    /// Whether to include code snippets in results.
    /// Default: true
    /// </summary>
    public bool IncludeSnippets { get; init; } = true;

    /// <summary>
    /// Reranking strategy to apply after initial retrieval.
    /// Default: None (use embedding similarity only)
    /// </summary>
    public RerankingStrategy Reranking { get; init; } = RerankingStrategy.None;

    /// <summary>
    /// Whether to deduplicate overlapping chunks from the same file.
    /// Default: true
    /// </summary>
    public bool DeduplicateChunks { get; init; } = true;

    /// <summary>
    /// Optional filter for specific directories within the workspace.
    /// Example: ["src/", "lib/"]
    /// </summary>
    public IReadOnlyList<string>? DirectoryFilters { get; init; }

    /// <summary>
    /// Whether to boost results containing exact keyword matches.
    /// This is separate from the Reranking strategy.
    /// Default: false
    /// </summary>
    public bool BoostExactMatches { get; init; } = false;

    /// <summary>
    /// Symbol types to filter results.
    /// If null or empty, all symbol types are included.
    /// </summary>
    public IReadOnlyList<SymbolType>? SymbolTypes { get; init; }
}

/// <summary>
/// Reranking strategy for search results.
/// </summary>
public enum RerankingStrategy
{
    /// <summary>
    /// Use embedding similarity only (no reranking).
    /// Fastest option but may miss keyword relevance.
    /// </summary>
    None = 0,

    /// <summary>
    /// Apply keyword matching bonus to results.
    /// Boosts results that contain query keywords.
    /// </summary>
    KeywordBoost = 1,

    /// <summary>
    /// Use Reciprocal Rank Fusion (RRF) to combine semantic and keyword rankings.
    /// Balances embedding similarity with keyword relevance.
    /// </summary>
    RRF = 2,

    /// <summary>
    /// Use a cross-encoder model for reranking.
    /// Most accurate but slowest. Reserved for future implementation.
    /// </summary>
    CrossEncoder = 3
}
```

---

### 2. KnowledgeQueryResult.cs

**Location**: `src/SeniorIntern.Core/Models/KnowledgeQueryResult.cs`

```csharp
using System;
using System.Collections.Generic;

namespace SeniorIntern.Core.Models;

/// <summary>
/// Result of a knowledge base query.
/// </summary>
/// <remarks>
/// <para>
/// Contains the retrieved chunks ordered by relevance, along with metadata
/// about the query execution including timing, cache status, and reranking info.
/// </para>
/// </remarks>
public sealed class KnowledgeQueryResult
{
    /// <summary>
    /// Retrieved code/text chunks with relevance scores.
    /// Ordered by relevance (highest first).
    /// </summary>
    public IReadOnlyList<KnowledgeChunk> Chunks { get; init; } = Array.Empty<KnowledgeChunk>();

    /// <summary>
    /// Unique file paths containing relevant information.
    /// </summary>
    public IReadOnlyList<string> RelevantFiles { get; init; } = Array.Empty<string>();

    /// <summary>
    /// Total time spent processing the query.
    /// </summary>
    public TimeSpan QueryTime { get; init; }

    /// <summary>
    /// Total number of chunks searched in the index.
    /// </summary>
    public int TotalChunksSearched { get; init; }

    /// <summary>
    /// Number of chunks that passed the minimum relevance threshold.
    /// </summary>
    public int ChunksAboveThreshold { get; init; }

    /// <summary>
    /// The embedding vector generated for the query.
    /// Useful for debugging or caching.
    /// </summary>
    public float[]? QueryEmbedding { get; init; }

    /// <summary>
    /// Whether the results were reranked.
    /// </summary>
    public bool WasReranked { get; init; }

    /// <summary>
    /// Reranking strategy that was applied.
    /// </summary>
    public RerankingStrategy RerankingApplied { get; init; }

    /// <summary>
    /// Whether the query hit the cache.
    /// </summary>
    public bool CacheHit { get; init; }

    /// <summary>
    /// Empty result singleton.
    /// </summary>
    public static KnowledgeQueryResult Empty { get; } = new()
    {
        Chunks = Array.Empty<KnowledgeChunk>(),
        RelevantFiles = Array.Empty<string>()
    };

    /// <summary>
    /// Whether the query returned any results.
    /// </summary>
    public bool HasResults => Chunks.Count > 0;
}

/// <summary>
/// A chunk of knowledge (code/text) with relevance metadata.
/// </summary>
/// <remarks>
/// <para>
/// Represents a retrieved segment of code with full context for display:
/// <list type="bullet">
///   <item>Source location (file, lines)</item>
///   <item>Relevance scoring (original and reranked)</item>
///   <item>Symbol information (name, type)</item>
///   <item>Optional expanded context and keyword highlights</item>
/// </list>
/// </para>
/// </remarks>
public sealed class KnowledgeChunk
{
    /// <summary>
    /// The code/text content of this chunk.
    /// </summary>
    public string Content { get; init; } = string.Empty;

    /// <summary>
    /// File path relative to the workspace root.
    /// </summary>
    public string FilePath { get; init; } = string.Empty;

    /// <summary>
    /// Starting line number (1-based).
    /// </summary>
    public int StartLine { get; init; }

    /// <summary>
    /// Ending line number (1-based).
    /// </summary>
    public int EndLine { get; init; }

    /// <summary>
    /// Relevance score (0.0 to 1.0, higher is more relevant).
    /// This is the final score after any reranking.
    /// </summary>
    public float Relevance { get; init; }

    /// <summary>
    /// Programming language of the content.
    /// </summary>
    public string? Language { get; init; }

    /// <summary>
    /// Symbol name if this chunk represents a code symbol.
    /// Example: "UserService", "CalculateTotal"
    /// </summary>
    public string? SymbolName { get; init; }

    /// <summary>
    /// Symbol type if applicable.
    /// </summary>
    public SymbolType? SymbolType { get; init; }

    /// <summary>
    /// Expanded context including surrounding lines.
    /// Only populated if ExpandContext was requested.
    /// </summary>
    public string? ExpandedContext { get; init; }

    /// <summary>
    /// Highlighted ranges in the content where keywords match.
    /// </summary>
    public IReadOnlyList<TextHighlight>? Highlights { get; init; }

    /// <summary>
    /// Original similarity score before reranking.
    /// </summary>
    public float OriginalScore { get; init; }

    /// <summary>
    /// Internal chunk ID for reference.
    /// </summary>
    public string ChunkId { get; init; } = string.Empty;

    /// <summary>
    /// Hash of the source file when this chunk was indexed.
    /// </summary>
    public string? FileHash { get; init; }
}

/// <summary>
/// Represents a highlighted region in text.
/// </summary>
/// <remarks>
/// Used for UI rendering of keyword matches within chunk content.
/// </remarks>
public sealed class TextHighlight
{
    /// <summary>
    /// Start index in the content string.
    /// </summary>
    public int Start { get; init; }

    /// <summary>
    /// Length of the highlighted region.
    /// </summary>
    public int Length { get; init; }

    /// <summary>
    /// The keyword or phrase that was matched.
    /// </summary>
    public string? MatchedKeyword { get; init; }

    /// <summary>
    /// End index (exclusive) in the content string.
    /// </summary>
    public int End => Start + Length;
}

/// <summary>
/// A file that contains relevant information.
/// </summary>
/// <remarks>
/// Aggregates chunk-level results by file for file-level navigation.
/// </remarks>
public sealed class RelevantFile
{
    /// <summary>
    /// File path relative to workspace root.
    /// </summary>
    public string FilePath { get; init; } = string.Empty;

    /// <summary>
    /// Aggregate relevance score for this file (max of chunk scores).
    /// </summary>
    public float Relevance { get; init; }

    /// <summary>
    /// Number of matching chunks in this file.
    /// </summary>
    public int MatchCount { get; init; }

    /// <summary>
    /// Brief summary or first match preview.
    /// </summary>
    public string? Summary { get; init; }

    /// <summary>
    /// Programming language of the file.
    /// </summary>
    public string? Language { get; init; }

    /// <summary>
    /// Line numbers of matches in the file.
    /// </summary>
    public IReadOnlyList<int>? MatchLines { get; init; }
}
```

---

### 3. KnowledgeIndexHealth.cs

**Location**: `src/SeniorIntern.Core/Models/KnowledgeIndexHealth.cs`

```csharp
using System;

namespace SeniorIntern.Core.Models;

/// <summary>
/// Health and statistics for a knowledge index.
/// </summary>
/// <remarks>
/// <para>
/// Provides dashboard-ready statistics including:
/// <list type="bullet">
///   <item>Index existence and identification</item>
///   <item>File and chunk counts</item>
///   <item>Staleness metrics and reindex recommendations</item>
///   <item>Embedding model information</item>
///   <item>Size and performance metrics</item>
/// </list>
/// </para>
/// </remarks>
public sealed class KnowledgeIndexHealth
{
    /// <summary>
    /// Whether the workspace has been indexed.
    /// </summary>
    public bool IsIndexed { get; init; }

    /// <summary>
    /// Unique identifier of the index.
    /// </summary>
    public string? IndexId { get; init; }

    /// <summary>
    /// Name of the index.
    /// </summary>
    public string? IndexName { get; init; }

    /// <summary>
    /// Total number of files in the index.
    /// </summary>
    public int TotalFiles { get; init; }

    /// <summary>
    /// Total number of chunks in the index.
    /// </summary>
    public int TotalChunks { get; init; }

    /// <summary>
    /// When the index was last updated.
    /// </summary>
    public DateTime? LastUpdated { get; init; }

    /// <summary>
    /// When the index was created.
    /// </summary>
    public DateTime? CreatedAt { get; init; }

    /// <summary>
    /// Number of files that have changed since last index.
    /// </summary>
    public int StaleFiles { get; init; }

    /// <summary>
    /// Whether the index needs to be rebuilt (>30% stale files).
    /// </summary>
    public bool NeedsReindex { get; init; }

    /// <summary>
    /// Path to the embedding model used for this index.
    /// </summary>
    public string? EmbeddingModel { get; init; }

    /// <summary>
    /// Dimension of the embedding vectors.
    /// </summary>
    public int EmbeddingDimension { get; init; }

    /// <summary>
    /// Total size of the index in bytes.
    /// </summary>
    public long IndexSizeBytes { get; init; }

    /// <summary>
    /// Average chunks per file.
    /// </summary>
    public double AverageChunksPerFile => TotalFiles > 0 ? (double)TotalChunks / TotalFiles : 0;

    /// <summary>
    /// Percentage of stale files.
    /// </summary>
    public double StalePercentage => TotalFiles > 0 ? (double)StaleFiles / TotalFiles * 100 : 0;

    /// <summary>
    /// Human-readable index size.
    /// </summary>
    public string FormattedSize => FormatBytes(IndexSizeBytes);

    /// <summary>
    /// Status message for display.
    /// </summary>
    public string StatusMessage => GetStatusMessage();

    private string GetStatusMessage()
    {
        if (!IsIndexed)
            return "Not indexed";
        if (NeedsReindex)
            return $"Needs reindex ({StaleFiles} stale files)";
        if (StaleFiles > 0)
            return $"Up to date ({StaleFiles} files changed)";
        return "Up to date";
    }

    private static string FormatBytes(long bytes)
    {
        return bytes switch
        {
            < 1024 => $"{bytes} B",
            < 1024 * 1024 => $"{bytes / 1024.0:F1} KB",
            < 1024 * 1024 * 1024 => $"{bytes / (1024.0 * 1024):F1} MB",
            _ => $"{bytes / (1024.0 * 1024 * 1024):F2} GB"
        };
    }

    /// <summary>
    /// Empty health status for unindexed workspace.
    /// </summary>
    public static KnowledgeIndexHealth NotIndexed { get; } = new()
    {
        IsIndexed = false
    };
}
```

---

## Unit Testing Requirements

| Model | Test Count | Focus Areas |
|-------|------------|-------------|
| `KnowledgeQueryOptions` | 10-12 | Default values, validation scenarios, filter combinations |
| `KnowledgeQueryResult` | 8-10 | Empty singleton, HasResults, collection handling |
| `KnowledgeChunk` | 8-10 | Property initialization, SymbolType handling |
| `TextHighlight` | 4-5 | End calculation, range validation |
| `RelevantFile` | 5-6 | Property initialization, collection handling |
| `KnowledgeIndexHealth` | 10-12 | Computed properties, FormatBytes, StatusMessage |
| `RerankingStrategy` | 3-4 | Enum values, default behavior |

**Total: ~48-59 tests**

### Test Scenarios

```
KnowledgeQueryOptions Tests:
├── Options_DefaultValues_AreCorrect
├── Options_WithFilePatterns_FiltersCorrectly
├── Options_WithLanguages_FiltersCorrectly
├── Options_WithSymbolTypes_FiltersCorrectly
└── Options_WithDirectoryFilters_FiltersCorrectly

KnowledgeQueryResult Tests:
├── Result_Empty_HasNoChunks
├── Result_WithChunks_HasResultsIsTrue
├── Result_EmptySingleton_IsSameInstance
└── Result_QueryTime_TracksCorrectly

KnowledgeIndexHealth Tests:
├── Health_NotIndexed_ReturnsCorrectStatus
├── Health_WithStaleFiles_CalculatesPercentage
├── Health_NeedsReindex_WhenOver30Percent
├── Health_FormatBytes_FormatsCorrectly (B, KB, MB, GB)
└── Health_AverageChunksPerFile_CalculatesCorrectly
```

---

## Acceptance Criteria

### Functional Requirements
- [ ] `KnowledgeQueryOptions` provides all filtering and configuration properties
- [ ] `KnowledgeQueryResult` contains chunks ordered by relevance
- [ ] `KnowledgeChunk` includes all metadata for UI display
- [ ] `TextHighlight` supports keyword match rendering
- [ ] `RelevantFile` aggregates chunk-level results by file
- [ ] `KnowledgeIndexHealth` provides computed statistics
- [ ] `RerankingStrategy` enum includes all defined strategies

### Quality Requirements
- [ ] All models are sealed classes (immutability)
- [ ] All properties use `init` accessors (immutability)
- [ ] All public members have XML documentation
- [ ] Static singleton instances use lazy initialization pattern
- [ ] Computed properties handle edge cases (division by zero)

---

## Future Considerations

Items explicitly deferred to later sub-versions:
- **v0.7.4c**: Context building models (`ContextBuildOptions`, `ContextBuildResult`)
- **v0.7.4d**: `KnowledgeService` implementation using these models
- **v0.7.4i**: `KeywordExtractor` for generating `TextHighlight` instances

---

## Appendix: Type Dependencies

```
v0.7.4b Models
│
├── KnowledgeQueryOptions
│   ├── Uses: RerankingStrategy (defined here)
│   └── Uses: SymbolType (from v0.7.1d)
│
├── KnowledgeQueryResult
│   ├── Uses: KnowledgeChunk (defined here)
│   └── Uses: RerankingStrategy (defined here)
│
├── KnowledgeChunk
│   ├── Uses: SymbolType (from v0.7.1d)
│   └── Uses: TextHighlight (defined here)
│
├── RelevantFile
│   └── No external dependencies
│
└── KnowledgeIndexHealth
    └── No external dependencies
```
