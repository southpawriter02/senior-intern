# Design Specification: AIntern v0.7.5j "Unit & Integration Testing"

## Overview

**Version**: v0.7.5j  
**Parent**: v0.7.5 UI & Integration  
**Focus**: Comprehensive unit and integration tests for all v0.7.5 UI components

### Purpose

This sub-version provides complete test coverage for v0.7.5:
1. Unit tests for all ViewModels (a-i)
2. Integration tests for dialog workflows
3. UI automation tests for control interactions
4. End-to-end RAG workflow tests

### Dependencies

**From v0.7.5a-i**: All models, ViewModels, controls, and services  
**From Testing Infrastructure**: xUnit, Moq, FluentAssertions, Avalonia.Headless

---

## Test Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                    v0.7.5j Test Architecture                                 │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Test Categories                                                             │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  1. Unit Tests (ViewModels)                                              │ │
│  │     ├── IndexManagerViewModelTests                                      │ │
│  │     ├── PatternEditorViewModelTests                                     │ │
│  │     ├── IndexingProgressViewModelTests                                  │ │
│  │     ├── RagStatusViewModelTests                                         │ │
│  │     ├── RagSettingsPanelViewModelTests                                  │ │
│  │     ├── RagToggleViewModelTests                                         │ │
│  │     ├── ContextSourcesViewModelTests                                    │ │
│  │     └── WorkspaceSelectorViewModelTests                                 │ │
│  │                                                                          │ │
│  │  2. Unit Tests (Services)                                                │ │
│  │     ├── RagSettingsTests                                                │ │
│  │     ├── WorkspaceIndexInfoTests                                         │ │
│  │     ├── FileWatcherServiceTests                                         │ │
│  │     └── AutoIndexingCoordinatorTests                                    │ │
│  │                                                                          │ │
│  │  3. Integration Tests                                                    │ │
│  │     ├── IndexManagerDialogIntegrationTests                              │ │
│  │     ├── SettingsPersistenceIntegrationTests                             │ │
│  │     ├── AutoIndexingIntegrationTests                                    │ │
│  │     └── ChatRagIntegrationTests                                         │ │
│  │                                                                          │ │
│  │  4. End-to-End Tests                                                     │ │
│  │     └── RagWorkflowE2ETests                                             │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  Test Infrastructure                                                         │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  ├── TestBase.cs (common setup, mocks)                                  │ │
│  │  ├── ViewModelTestBase.cs (dispatcher, property change)                 │ │
│  │  ├── MockFactories/ (reusable mock builders)                            │ │
│  │  └── TestData/ (sample settings, index info)                            │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Test File Specifications

### 1. RagSettingsTests.cs

**Location**: `tests/AIntern.Core.Tests/RAG/Settings/RagSettingsTests.cs`

```csharp
namespace AIntern.Core.Tests.RAG.Settings;

using Xunit;
using FluentAssertions;
using AIntern.Core.RAG.Settings;

public class RagSettingsTests
{
    #region Default Values

    [Fact]
    public void Default_HasCorrectChunkSize()
    {
        var settings = RagSettings.Default;
        settings.ChunkSize.Should().Be(512);
    }

    [Fact]
    public void Default_HasCorrectChunkOverlap()
    {
        var settings = RagSettings.Default;
        settings.ChunkOverlap.Should().Be(64);
    }

    [Fact]
    public void Default_HasIncludePatterns()
    {
        var settings = RagSettings.Default;
        settings.IncludePatterns.Should().Contain("**/*.cs");
        settings.IncludePatterns.Should().Contain("**/*.ts");
    }

    [Fact]
    public void Default_HasExcludePatterns()
    {
        var settings = RagSettings.Default;
        settings.ExcludePatterns.Should().Contain("**/node_modules/**");
        settings.ExcludePatterns.Should().Contain("**/bin/**");
    }

    #endregion

    #region Validation

    [Theory]
    [InlineData(99, "Chunk size must be between 100 and 2000")]
    [InlineData(2001, "Chunk size must be between 100 and 2000")]
    public void Validate_InvalidChunkSize_ReturnsError(int size, string expected)
    {
        var settings = new RagSettings { ChunkSize = size };
        var errors = settings.Validate();
        errors.Should().Contain(expected);
    }

    [Fact]
    public void Validate_ChunkOverlapGreaterThanSize_ReturnsError()
    {
        var settings = new RagSettings { ChunkSize = 100, ChunkOverlap = 100 };
        var errors = settings.Validate();
        errors.Should().Contain("Chunk overlap must be between 0 and chunk size");
    }

    [Theory]
    [InlineData(0, "Max file size must be between 1 KB and 10 MB")]
    [InlineData(10241, "Max file size must be between 1 KB and 10 MB")]
    public void Validate_InvalidMaxFileSize_ReturnsError(int size, string expected)
    {
        var settings = new RagSettings { MaxFileSizeKb = size };
        var errors = settings.Validate();
        errors.Should().Contain(expected);
    }

    [Theory]
    [InlineData(-0.1)]
    [InlineData(1.1)]
    public void Validate_InvalidRelevanceScore_ReturnsError(double score)
    {
        var settings = new RagSettings { MinRelevanceScore = score };
        var errors = settings.Validate();
        errors.Should().Contain("Min relevance score must be between 0 and 1");
    }

    [Fact]
    public void Validate_ValidSettings_ReturnsNoErrors()
    {
        var settings = RagSettings.Default;
        var errors = settings.Validate();
        errors.Should().BeEmpty();
    }

    #endregion
}
```

### 2. IndexManagerViewModelTests.cs

**Location**: `tests/AIntern.Desktop.Tests/ViewModels/IndexManagerViewModelTests.cs`

```csharp
namespace AIntern.Desktop.Tests.ViewModels;

using Xunit;
using Moq;
using FluentAssertions;
using AIntern.Desktop.ViewModels;
using AIntern.Core.RAG.Settings;
using AIntern.Core.RAG.Storage;
using AIntern.Core.RAG.Embedding;
using Microsoft.Extensions.Logging.Abstractions;

public class IndexManagerViewModelTests : IAsyncLifetime
{
    private readonly Mock<IRagSettingsService> _settingsService;
    private readonly Mock<IVectorStore> _vectorStore;
    private readonly Mock<IEmbeddingService> _embeddingService;
    private IndexManagerViewModel _sut;

    public IndexManagerViewModelTests()
    {
        _settingsService = new Mock<IRagSettingsService>();
        _vectorStore = new Mock<IVectorStore>();
        _embeddingService = new Mock<IEmbeddingService>();
        
        _sut = new IndexManagerViewModel(
            _settingsService.Object,
            _vectorStore.Object,
            _embeddingService.Object,
            NullLogger<IndexManagerViewModel>.Instance);
    }

    public async Task InitializeAsync()
    {
        _settingsService.Setup(x => x.GetSettingsAsync())
            .ReturnsAsync(RagSettings.Default);
    }

    public Task DisposeAsync() => Task.CompletedTask;

    #region Initialization

    [Fact]
    public async Task InitializeAsync_LoadsSettingsFromService()
    {
        var settings = new RagSettings
        {
            ChunkSize = 256,
            ChunkOverlap = 32,
            AutoIndexEnabled = false
        };
        _settingsService.Setup(x => x.GetSettingsAsync())
            .ReturnsAsync(settings);

        await _sut.InitializeAsync();

        _sut.ChunkSize.Should().Be(256);
        _sut.ChunkOverlap.Should().Be(32);
        _sut.AutoIndexEnabled.Should().BeFalse();
    }

    [Fact]
    public async Task InitializeAsync_RefreshesIndexStatus()
    {
        var info = new WorkspaceIndexInfo
        {
            WorkspacePath = "/test",
            FileCount = 100,
            ChunkCount = 500
        };
        _vectorStore.Setup(x => x.GetIndexInfoAsync(It.IsAny<string>()))
            .ReturnsAsync(info);
        _settingsService.Setup(x => x.GetSettingsAsync())
            .ReturnsAsync(new RagSettings { LastWorkspacePath = "/test" });

        await _sut.InitializeAsync();

        _sut.IsIndexed.Should().BeTrue();
        _sut.FileCount.Should().Be(100);
        _sut.ChunkCount.Should().Be(500);
    }

    #endregion

    #region Validation

    [Fact]
    public void HasValidationErrors_TrueWhenOverlapExceedsSize()
    {
        _sut.ChunkSize = 100;
        _sut.ChunkOverlap = 150;

        _sut.HasValidationErrors.Should().BeTrue();
        _sut.ValidationErrorMessage.Should().Contain("overlap");
    }

    [Fact]
    public void HasValidationErrors_FalseWhenValid()
    {
        _sut.ChunkSize = 512;
        _sut.ChunkOverlap = 64;

        _sut.HasValidationErrors.Should().BeFalse();
    }

    #endregion

    #region Commands

    [Fact]
    public async Task SaveCommand_PersistsSettings()
    {
        _sut.ChunkSize = 256;
        _sut.ChunkOverlap = 32;
        RagSettings? saved = null;
        _settingsService.Setup(x => x.SaveSettingsAsync(It.IsAny<RagSettings>()))
            .Callback<RagSettings>(s => saved = s)
            .Returns(Task.CompletedTask);

        await _sut.SaveCommand.ExecuteAsync(null);

        saved.Should().NotBeNull();
        saved!.ChunkSize.Should().Be(256);
        saved.ChunkOverlap.Should().Be(32);
    }

    [Fact]
    public async Task SaveCommand_RaisesCloseRequested()
    {
        var raised = false;
        _sut.CloseRequested += (_, result) => raised = result;

        await _sut.SaveCommand.ExecuteAsync(null);

        raised.Should().BeTrue();
    }

    [Fact]
    public void CancelCommand_RaisesCloseRequested()
    {
        var raised = false;
        _sut.CloseRequested += (_, result) => raised = !result;

        _sut.CancelCommand.Execute(null);

        raised.Should().BeTrue();
    }

    #endregion

    #region Status Updates

    [Fact]
    public async Task StatusColor_GreenWhenIndexed()
    {
        var info = new WorkspaceIndexInfo { WorkspacePath = "/test" };
        _vectorStore.Setup(x => x.GetIndexInfoAsync(It.IsAny<string>()))
            .ReturnsAsync(info);
        _settingsService.Setup(x => x.GetSettingsAsync())
            .ReturnsAsync(new RagSettings { LastWorkspacePath = "/test" });

        await _sut.InitializeAsync();

        _sut.StatusColor.ToString().Should().Contain("32CD32"); // LimeGreen
    }

    [Fact]
    public async Task StatusColor_GrayWhenNotIndexed()
    {
        _vectorStore.Setup(x => x.GetIndexInfoAsync(It.IsAny<string>()))
            .ReturnsAsync((WorkspaceIndexInfo?)null);

        await _sut.InitializeAsync();

        _sut.StatusColor.ToString().Should().Contain("808080"); // Gray
    }

    #endregion
}
```

### 3. AutoIndexingCoordinatorTests.cs

**Location**: `tests/AIntern.Services.Tests/RAG/AutoIndexingCoordinatorTests.cs`

```csharp
namespace AIntern.Services.Tests.RAG;

using Xunit;
using Moq;
using FluentAssertions;
using AIntern.Services.RAG.Indexing;
using AIntern.Core.RAG.Indexing;
using AIntern.Core.RAG.Settings;
using Microsoft.Extensions.Logging.Abstractions;

public class AutoIndexingCoordinatorTests : IAsyncLifetime, IDisposable
{
    private readonly Mock<IFileWatcherService> _watcher;
    private readonly Mock<IIndexingPipeline> _pipeline;
    private readonly Mock<IRagSettingsService> _settingsService;
    private AutoIndexingCoordinator _sut;

    public AutoIndexingCoordinatorTests()
    {
        _watcher = new Mock<IFileWatcherService>();
        _pipeline = new Mock<IIndexingPipeline>();
        _settingsService = new Mock<IRagSettingsService>();

        _settingsService.Setup(x => x.GetSettingsAsync())
            .ReturnsAsync(new RagSettings { AutoIndexEnabled = true, AutoIndexDelaySeconds = 1 });

        _sut = new AutoIndexingCoordinator(
            _watcher.Object,
            _pipeline.Object,
            _settingsService.Object,
            NullLogger<AutoIndexingCoordinator>.Instance);
    }

    public Task InitializeAsync() => Task.CompletedTask;
    public Task DisposeAsync() => Task.CompletedTask;
    public void Dispose() => _sut.Dispose();

    [Fact]
    public async Task InitializeAsync_StartsWatcherWhenEnabled()
    {
        var settings = new RagSettings 
        { 
            AutoIndexEnabled = true, 
            LastWorkspacePath = "/test" 
        };
        _settingsService.Setup(x => x.GetSettingsAsync()).ReturnsAsync(settings);

        await _sut.InitializeAsync();

        _watcher.Verify(x => x.StartWatching(
            "/test",
            It.IsAny<IReadOnlyList<string>>(),
            It.IsAny<IReadOnlyList<string>>()),
            Times.Once);
    }

    [Fact]
    public async Task InitializeAsync_DoesNotStartWhenDisabled()
    {
        var settings = new RagSettings { AutoIndexEnabled = false };
        _settingsService.Setup(x => x.GetSettingsAsync()).ReturnsAsync(settings);

        await _sut.InitializeAsync();

        _watcher.Verify(x => x.StartWatching(
            It.IsAny<string>(),
            It.IsAny<IReadOnlyList<string>>(),
            It.IsAny<IReadOnlyList<string>>()),
            Times.Never);
    }

    [Fact]
    public async Task OnFileChanged_QueuesForProcessing()
    {
        await _sut.InitializeAsync();
        var eventTriggered = false;
        _sut.IndexingTriggered += (_, _) => eventTriggered = true;

        _watcher.Raise(x => x.FileChanged += null, 
            new FileChangeEventArgs { FilePath = "/test/file.cs", ChangeType = FileChangeType.Changed });

        // Wait for debounce
        await Task.Delay(1500);

        eventTriggered.Should().BeTrue();
    }

    [Fact]
    public async Task Debounce_AggregatesMultipleChanges()
    {
        await _sut.InitializeAsync();
        var changedFiles = new List<string>();
        _pipeline.Setup(x => x.UpdateFilesAsync(It.IsAny<IReadOnlyList<string>>(), It.IsAny<IReadOnlyList<string>>()))
            .Callback<IReadOnlyList<string>, IReadOnlyList<string>>((c, d) => changedFiles.AddRange(c))
            .Returns(Task.CompletedTask);

        _watcher.Raise(x => x.FileChanged += null,
            new FileChangeEventArgs { FilePath = "/test/a.cs", ChangeType = FileChangeType.Changed });
        _watcher.Raise(x => x.FileChanged += null,
            new FileChangeEventArgs { FilePath = "/test/b.cs", ChangeType = FileChangeType.Changed });
        _watcher.Raise(x => x.FileChanged += null,
            new FileChangeEventArgs { FilePath = "/test/c.cs", ChangeType = FileChangeType.Changed });

        await Task.Delay(1500);

        changedFiles.Should().HaveCount(3);
        _pipeline.Verify(x => x.UpdateFilesAsync(
            It.IsAny<IReadOnlyList<string>>(),
            It.IsAny<IReadOnlyList<string>>()),
            Times.Once);
    }

    [Fact]
    public void StopWatching_DisposesWatcher()
    {
        _sut.StartWatching("/test");

        _sut.StopWatching();

        _watcher.Verify(x => x.StopWatching(), Times.Once);
    }
}
```

### 4. ChatRagIntegrationTests.cs

**Location**: `tests/AIntern.Desktop.Tests/Integration/ChatRagIntegrationTests.cs`

```csharp
namespace AIntern.Desktop.Tests.Integration;

using Xunit;
using Moq;
using FluentAssertions;
using AIntern.Desktop.ViewModels;
using AIntern.Core.RAG.Settings;
using AIntern.Core.RAG.Retrieval;
using Microsoft.Extensions.Logging.Abstractions;

public class ChatRagIntegrationTests
{
    private readonly Mock<IRagSettingsService> _settingsService;
    private readonly Mock<IRagQueryService> _queryService;

    public ChatRagIntegrationTests()
    {
        _settingsService = new Mock<IRagSettingsService>();
        _queryService = new Mock<IRagQueryService>();
    }

    [Fact]
    public async Task SendMessage_WithRagEnabled_IncludesContext()
    {
        // Arrange
        var settings = new RagSettings
        {
            EnableRagInChat = true,
            MaxRagContextTokens = 4000,
            MaxRagChunks = 5,
            MinRelevanceScore = 0.7
        };
        _settingsService.Setup(x => x.GetSettingsAsync()).ReturnsAsync(settings);

        var context = new RagContext
        {
            Chunks = new List<RetrievedChunk>
            {
                new() { RelativeFilePath = "test.cs", Content = "code", RelevanceScore = 0.9 }
            }
        };
        _queryService.Setup(x => x.GetContextAsync(
            It.IsAny<string>(),
            It.IsAny<int>(),
            It.IsAny<int>(),
            It.IsAny<double>()))
            .ReturnsAsync(context);

        // Act - simulate chat flow
        var prompt = "How does this work?";
        var ragContext = await _queryService.Object.GetContextAsync(
            prompt, 
            settings.MaxRagContextTokens, 
            settings.MaxRagChunks, 
            settings.MinRelevanceScore);

        // Assert
        ragContext.Chunks.Should().HaveCount(1);
        ragContext.Chunks[0].RelativeFilePath.Should().Be("test.cs");
    }

    [Fact]
    public async Task SendMessage_WithRagDisabled_SkipsContext()
    {
        var settings = new RagSettings { EnableRagInChat = false };
        _settingsService.Setup(x => x.GetSettingsAsync()).ReturnsAsync(settings);

        settings.EnableRagInChat.Should().BeFalse();
        _queryService.Verify(x => x.GetContextAsync(
            It.IsAny<string>(),
            It.IsAny<int>(),
            It.IsAny<int>(),
            It.IsAny<double>()),
            Times.Never);
    }
}
```

---

## Test Coverage Matrix

| Component | Unit Tests | Integration Tests | Coverage Target |
|-----------|------------|-------------------|-----------------|
| RagSettings | 12 | - | 95% |
| WorkspaceIndexInfo | 8 | - | 90% |
| IndexManagerViewModel | 15 | 3 | 90% |
| PatternEditorViewModel | 6 | - | 90% |
| IndexingProgressViewModel | 10 | 2 | 90% |
| RagStatusViewModel | 10 | - | 90% |
| RagSettingsPanelViewModel | 10 | 2 | 90% |
| RagToggleViewModel | 6 | - | 90% |
| ContextSourcesViewModel | 6 | - | 90% |
| WorkspaceSelectorViewModel | 10 | 2 | 90% |
| FileWatcherService | 10 | 2 | 85% |
| AutoIndexingCoordinator | 12 | 3 | 90% |
| **Total** | **~115** | **~14** | **>90%** |

---

## Test Infrastructure

### ViewModelTestBase.cs

```csharp
namespace AIntern.Desktop.Tests;

using Avalonia.Threading;

public abstract class ViewModelTestBase : IAsyncLifetime
{
    protected List<string> PropertyChanges { get; } = new();

    protected void TrackPropertyChanges(INotifyPropertyChanged viewModel)
    {
        viewModel.PropertyChanged += (_, e) =>
        {
            if (e.PropertyName != null)
                PropertyChanges.Add(e.PropertyName);
        };
    }

    public virtual Task InitializeAsync() => Task.CompletedTask;
    public virtual Task DisposeAsync() => Task.CompletedTask;
}
```

### MockFactories/RagMockFactory.cs

```csharp
namespace AIntern.Desktop.Tests.MockFactories;

using Moq;
using AIntern.Core.RAG.Settings;
using AIntern.Core.RAG.Storage;

public static class RagMockFactory
{
    public static Mock<IRagSettingsService> CreateSettingsService(RagSettings? settings = null)
    {
        var mock = new Mock<IRagSettingsService>();
        mock.Setup(x => x.GetSettingsAsync())
            .ReturnsAsync(settings ?? RagSettings.Default);
        return mock;
    }

    public static Mock<IVectorStore> CreateVectorStore(WorkspaceIndexInfo? info = null)
    {
        var mock = new Mock<IVectorStore>();
        mock.Setup(x => x.GetIndexInfoAsync(It.IsAny<string>()))
            .ReturnsAsync(info);
        return mock;
    }

    public static WorkspaceIndexInfo CreateIndexInfo(
        string path = "/test",
        int files = 100,
        int chunks = 500)
    {
        return new WorkspaceIndexInfo
        {
            WorkspacePath = path,
            DisplayName = Path.GetFileName(path),
            FileCount = files,
            ChunkCount = chunks,
            LastUpdated = DateTime.UtcNow
        };
    }
}
```

---

## Acceptance Criteria

- [ ] All unit tests pass (115+ tests)
- [ ] All integration tests pass (14+ tests)
- [ ] Code coverage ≥90% for ViewModels
- [ ] Code coverage ≥85% for Services
- [ ] No flaky tests (deterministic results)
- [ ] Tests run in <30 seconds total
- [ ] Mock factories reusable across test files
- [ ] Property change tracking validated
- [ ] Async operations properly awaited
- [ ] Disposal/cleanup verified

---

## Changelog Entry

```markdown
## v0.7.5j - Unit & Integration Testing

### Added

- `RagSettingsTests` (12 tests): Default values, validation rules
- `WorkspaceIndexInfoTests` (8 tests): Formatting, computed properties
- `IndexManagerViewModelTests` (15 tests): Init, validation, commands, status
- `PatternEditorViewModelTests` (6 tests): Add/clear, apply/cancel
- `IndexingProgressViewModelTests` (10 tests): Progress, cancellation
- `RagStatusViewModelTests` (10 tests): Status states, events
- `RagSettingsPanelViewModelTests` (10 tests): Load/save, preview
- `RagToggleViewModelTests` (6 tests): Toggle, availability
- `ContextSourcesViewModelTests` (6 tests): Load, colors
- `WorkspaceSelectorViewModelTests` (10 tests): Selection, refresh
- `FileWatcherServiceTests` (10 tests): Events, patterns
- `AutoIndexingCoordinatorTests` (12 tests): Debounce, settings
- `ChatRagIntegrationTests` (5 tests): RAG flow
- `SettingsPersistenceIntegrationTests` (4 tests): Save/load cycle
- `ViewModelTestBase` for common test utilities
- `RagMockFactory` for reusable mock creation
- Total: 115+ unit tests, 14+ integration tests
- Target coverage: >90% for all v0.7.5 components
```
