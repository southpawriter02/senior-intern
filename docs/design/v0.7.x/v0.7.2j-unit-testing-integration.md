# Design Specification: AIntern v0.7.2j "Unit Testing & Integration"

## Overview

**Version**: v0.7.2j
**Parent**: v0.7.2 Vector Storage
**Focus**: Implement comprehensive unit tests and integration tests for all vector storage components

### Purpose

Implement test coverage for all v0.7.2 components:
1. `SqliteVectorStoreTests` for core store operations
2. `VectorSearchTests` for search functionality
3. `VectorSearchHelperTests` for SIMD helper functions
4. `FileHasherTests` for hashing utilities
5. `FileScannerTests` for directory scanning
6. `FileContentReaderTests` for encoding detection
7. `VectorIndexSettingsTests` for settings validation
8. `IndexStatisticsTests` for statistics models

### Dependencies

**From v0.7.2a-i**:
- All vector storage components to test

**Testing Framework**:
- xUnit
- Microsoft.Extensions.Logging.Abstractions (NullLogger)
- System.IO (temp file handling)

---

## Test Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                      v0.7.2j Unit Testing Architecture                        │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Test File Structure:                                                         │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  tests/SeniorIntern.Tests/VectorStore/                                   │ │
│  │  ├── SqliteVectorStoreTests.cs        ← Core store tests (IAsyncLifetime)│ │
│  │  ├── VectorSearchTests.cs             ← Search tests (IAsyncLifetime)    │ │
│  │  ├── VectorSearchHelperTests.cs       ← SIMD helper tests               │ │
│  │  ├── FileHasherTests.cs               ← Hashing utility tests           │ │
│  │  ├── FileScannerTests.cs              ← Directory scanning tests        │ │
│  │  ├── FileContentReaderTests.cs        ← Encoding detection tests        │ │
│  │  ├── VectorIndexSettingsTests.cs      ← Settings validation tests       │ │
│  │  └── IndexStatisticsTests.cs          ← Statistics model tests          │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  Test Categories:                                                             │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  Integration Tests (require SQLite):                                     │ │
│  │  ├── SqliteVectorStoreTests           (uses temp database file)         │ │
│  │  └── VectorSearchTests                (uses temp database file)         │ │
│  │                                                                          │ │
│  │  Unit Tests (no external dependencies):                                  │ │
│  │  ├── VectorSearchHelperTests          (pure math functions)             │ │
│  │  ├── FileHasherTests                  (uses temp files)                 │ │
│  │  ├── FileScannerTests                 (uses temp directories)           │ │
│  │  ├── FileContentReaderTests           (uses temp files)                 │ │
│  │  ├── VectorIndexSettingsTests         (pure model tests)                │ │
│  │  └── IndexStatisticsTests             (pure model tests)                │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Test Coverage Matrix

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                          Test Coverage Matrix                                 │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Component                       │ Test Count │ Coverage Areas               │
│  ═══════════════════════════════ │ ══════════ │ ════════════════════════════ │
│  SqliteVectorStore               │ 12         │ Init, Index CRUD, Chunk CRUD │
│  VectorSearch                    │ 8          │ Search, Filters, Scoring     │
│  VectorSearchHelper              │ 8          │ Cosine, L2, Normalize        │
│  FileHasher                      │ 5          │ SHA-256, QuickHash           │
│  FileScanner                     │ 6          │ Scan, Exclude, Changes       │
│  FileContentReader               │ 5          │ Encoding, Lines              │
│  VectorIndexSettings             │ 4          │ Defaults, Validation         │
│  IndexStatistics                 │ 4          │ Calculations, Formatting     │
│  ─────────────────────────────── │ ────────── │ ──────────────────────────────│
│  Total                           │ 52         │                              │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Test Base Pattern

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                     IAsyncLifetime Test Pattern                               │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  For tests requiring database or file system setup:                          │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  public class SqliteVectorStoreTests : IAsyncLifetime                    │ │
│  │  {                                                                        │ │
│  │      private readonly string _dbPath;                                    │ │
│  │      private SqliteVectorStore _store = null!;                           │ │
│  │                                                                          │ │
│  │      public SqliteVectorStoreTests()                                     │ │
│  │      {                                                                    │ │
│  │          // Generate unique temp path per test run                       │ │
│  │          _dbPath = Path.Combine(                                         │ │
│  │              Path.GetTempPath(),                                         │ │
│  │              $"test_vectors_{Guid.NewGuid()}.db");                       │ │
│  │      }                                                                    │ │
│  │                                                                          │ │
│  │      public async Task InitializeAsync()                                 │ │
│  │      {                                                                    │ │
│  │          // Setup: Create store and initialize                           │ │
│  │          var options = Options.Create(new VectorStoreOptions             │ │
│  │          {                                                                │ │
│  │              DatabasePath = _dbPath                                      │ │
│  │          });                                                              │ │
│  │          _store = new SqliteVectorStore(                                 │ │
│  │              options,                                                     │ │
│  │              NullLogger<SqliteVectorStore>.Instance);                    │ │
│  │          await _store.InitializeAsync();                                 │ │
│  │      }                                                                    │ │
│  │                                                                          │ │
│  │      public async Task DisposeAsync()                                    │ │
│  │      {                                                                    │ │
│  │          // Cleanup: Dispose store and delete temp file                  │ │
│  │          await _store.DisposeAsync();                                    │ │
│  │          if (File.Exists(_dbPath))                                       │ │
│  │              File.Delete(_dbPath);                                       │ │
│  │      }                                                                    │ │
│  │  }                                                                        │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Specifications

### 1. SqliteVectorStoreTests.cs

**Location**: `tests/SeniorIntern.Tests/VectorStore/SqliteVectorStoreTests.cs`

```csharp
namespace SeniorIntern.Tests.VectorStore;

using System;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.Extensions.Options;
using SeniorIntern.Core.Models;
using SeniorIntern.Core.Options;
using SeniorIntern.Services.VectorStore;
using Xunit;

/// <summary>
/// Integration tests for SqliteVectorStore core operations.
/// </summary>
public class SqliteVectorStoreTests : IAsyncLifetime
{
    private readonly string _dbPath;
    private SqliteVectorStore _store = null!;

    public SqliteVectorStoreTests()
    {
        _dbPath = Path.Combine(Path.GetTempPath(), $"test_vectors_{Guid.NewGuid()}.db");
    }

    public async Task InitializeAsync()
    {
        var options = Options.Create(new VectorStoreOptions
        {
            DatabasePath = _dbPath
        });

        _store = new SqliteVectorStore(
            options,
            NullLogger<SqliteVectorStore>.Instance);

        await _store.InitializeAsync();
    }

    public async Task DisposeAsync()
    {
        await _store.DisposeAsync();

        if (File.Exists(_dbPath))
            File.Delete(_dbPath);
    }

    #region Index CRUD Tests

    [Fact]
    public async Task CreateIndex_ShouldCreateNewIndex()
    {
        // Arrange
        var workspacePath = "/test/workspace";
        var name = "Test Index";
        var dimension = 384;

        // Act
        var index = await _store.CreateIndexAsync(workspacePath, name, dimension);

        // Assert
        Assert.NotNull(index);
        Assert.Equal(name, index.Name);
        Assert.Equal(workspacePath, index.WorkspacePath);
        Assert.Equal(dimension, index.EmbeddingDimension);
        Assert.Equal(IndexStatus.Active, index.Status);
    }

    [Fact]
    public async Task CreateIndex_WithEmptyName_ShouldThrow()
    {
        // Arrange & Act & Assert
        await Assert.ThrowsAsync<ArgumentException>(
            () => _store.CreateIndexAsync("/test", "", 384));
    }

    [Fact]
    public async Task CreateIndex_WithInvalidDimension_ShouldThrow()
    {
        // Arrange & Act & Assert
        await Assert.ThrowsAsync<ArgumentOutOfRangeException>(
            () => _store.CreateIndexAsync("/test", "Test", 0));
    }

    [Fact]
    public async Task GetIndex_ShouldReturnExistingIndex()
    {
        // Arrange
        var created = await _store.CreateIndexAsync("/test", "Test", 384);

        // Act
        var retrieved = await _store.GetIndexAsync(created.Id);

        // Assert
        Assert.NotNull(retrieved);
        Assert.Equal(created.Id, retrieved.Id);
        Assert.Equal(created.Name, retrieved.Name);
    }

    [Fact]
    public async Task GetIndex_NonExistent_ShouldReturnNull()
    {
        // Arrange & Act
        var result = await _store.GetIndexAsync("non-existent-id");

        // Assert
        Assert.Null(result);
    }

    [Fact]
    public async Task GetIndexForWorkspace_ShouldFindByPath()
    {
        // Arrange
        var workspacePath = "/unique/workspace/path";
        await _store.CreateIndexAsync(workspacePath, "Test", 384);

        // Act
        var found = await _store.GetIndexForWorkspaceAsync(workspacePath);

        // Assert
        Assert.NotNull(found);
        Assert.Equal(workspacePath, found.WorkspacePath);
    }

    [Fact]
    public async Task ListIndexes_ShouldReturnAllIndexes()
    {
        // Arrange
        await _store.CreateIndexAsync("/test1", "Test 1", 384);
        await _store.CreateIndexAsync("/test2", "Test 2", 384);

        // Act
        var indexes = await _store.ListIndexesAsync();

        // Assert
        Assert.Equal(2, indexes.Count);
    }

    [Fact]
    public async Task DeleteIndex_ShouldRemoveIndex()
    {
        // Arrange
        var index = await _store.CreateIndexAsync("/test", "Test", 384);

        // Act
        await _store.DeleteIndexAsync(index.Id);
        var retrieved = await _store.GetIndexAsync(index.Id);

        // Assert
        Assert.Null(retrieved);
    }

    #endregion

    #region Chunk CRUD Tests

    [Fact]
    public async Task AddChunks_ShouldStoreChunksWithEmbeddings()
    {
        // Arrange
        var index = await _store.CreateIndexAsync("/test", "Test", 4);

        var file = new IndexedFile
        {
            IndexId = index.Id,
            FilePath = "test.cs",
            FileHash = "abc123",
            FileSize = 100,
            LastModified = DateTime.UtcNow
        };
        await _store.UpsertIndexedFileAsync(index.Id, file);

        var chunks = new[]
        {
            new ChunkWithEmbedding
            {
                Chunk = new TextChunk
                {
                    Content = "public class Test { }",
                    FilePath = "test.cs",
                    StartLine = 1,
                    EndLine = 1,
                    Type = ChunkType.Code,
                    Language = "csharp"
                },
                Embedding = new float[] { 0.1f, 0.2f, 0.3f, 0.4f },
                FileId = file.Id
            }
        };

        // Act
        await _store.AddChunksAsync(index.Id, chunks);

        // Assert
        var updatedIndex = await _store.GetIndexAsync(index.Id);
        Assert.Equal(1, updatedIndex!.ChunkCount);
    }

    [Fact]
    public async Task GetChunk_ShouldReturnStoredChunk()
    {
        // Arrange
        var index = await _store.CreateIndexAsync("/test", "Test", 4);
        var file = await SetupIndexedFileAsync(index.Id, "test.cs");
        var chunkId = await AddSingleChunkAsync(index.Id, file.Id, "Test content");

        // Act
        var chunk = await _store.GetChunkAsync(chunkId);

        // Assert
        Assert.NotNull(chunk);
        Assert.Equal("Test content", chunk.Content);
    }

    [Fact]
    public async Task RemoveChunksForFile_ShouldRemoveAllFileChunks()
    {
        // Arrange
        var index = await _store.CreateIndexAsync("/test", "Test", 4);

        var file = new IndexedFile
        {
            IndexId = index.Id,
            FilePath = "test.cs",
            FileHash = "abc123",
            FileSize = 100,
            LastModified = DateTime.UtcNow
        };
        await _store.UpsertIndexedFileAsync(index.Id, file);

        var chunks = Enumerable.Range(0, 5).Select(i => new ChunkWithEmbedding
        {
            Chunk = new TextChunk
            {
                Content = $"Chunk {i}",
                FilePath = "test.cs",
                StartLine = i + 1,
                EndLine = i + 1,
                Type = ChunkType.Code
            },
            Embedding = new float[] { i * 0.1f, i * 0.2f, i * 0.3f, i * 0.4f },
            FileId = file.Id
        }).ToList();

        await _store.AddChunksAsync(index.Id, chunks);

        // Act
        var removed = await _store.RemoveChunksForFileAsync(index.Id, "test.cs");

        // Assert
        Assert.Equal(5, removed);
    }

    #endregion

    #region Helper Methods

    private async Task<IndexedFile> SetupIndexedFileAsync(string indexId, string path)
    {
        var file = new IndexedFile
        {
            IndexId = indexId,
            FilePath = path,
            FileHash = Guid.NewGuid().ToString(),
            FileSize = 100,
            LastModified = DateTime.UtcNow
        };
        await _store.UpsertIndexedFileAsync(indexId, file);
        return file;
    }

    private async Task<string> AddSingleChunkAsync(string indexId, string fileId, string content)
    {
        var chunk = new ChunkWithEmbedding
        {
            Chunk = new TextChunk
            {
                Content = content,
                FilePath = "test.cs",
                StartLine = 1,
                EndLine = 1,
                Type = ChunkType.Code
            },
            Embedding = new float[] { 0.1f, 0.2f, 0.3f, 0.4f },
            FileId = fileId
        };

        var ids = await _store.AddChunksAsync(indexId, [chunk]);
        return ids.First();
    }

    #endregion
}
```

### 2. VectorSearchTests.cs

**Location**: `tests/SeniorIntern.Tests/VectorStore/VectorSearchTests.cs`

```csharp
namespace SeniorIntern.Tests.VectorStore;

using System;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.Extensions.Options;
using SeniorIntern.Core.Models;
using SeniorIntern.Core.Options;
using SeniorIntern.Services.VectorStore;
using Xunit;

/// <summary>
/// Integration tests for vector search functionality.
/// </summary>
public class VectorSearchTests : IAsyncLifetime
{
    private readonly string _dbPath;
    private SqliteVectorStore _store = null!;
    private string _indexId = null!;

    public VectorSearchTests()
    {
        _dbPath = Path.Combine(Path.GetTempPath(), $"test_search_{Guid.NewGuid()}.db");
    }

    public async Task InitializeAsync()
    {
        var options = Options.Create(new VectorStoreOptions
        {
            DatabasePath = _dbPath
        });

        _store = new SqliteVectorStore(
            options,
            NullLogger<SqliteVectorStore>.Instance);

        await _store.InitializeAsync();

        // Create test index with sample data
        var index = await _store.CreateIndexAsync("/test", "Search Test", 4);
        _indexId = index.Id;

        await SetupTestDataAsync();
    }

    private async Task SetupTestDataAsync()
    {
        var file = new IndexedFile
        {
            IndexId = _indexId,
            FilePath = "test.cs",
            FileHash = "hash",
            FileSize = 1000,
            LastModified = DateTime.UtcNow,
            Language = "csharp"
        };
        await _store.UpsertIndexedFileAsync(_indexId, file);

        var chunks = new[]
        {
            CreateChunk("public class UserService", ChunkType.Code, "csharp",
                new[] { 0.9f, 0.1f, 0.1f, 0.1f }, file.Id, 1, SymbolType.Class, "UserService"),
            CreateChunk("public void GetUser(int id)", ChunkType.Code, "csharp",
                new[] { 0.8f, 0.2f, 0.1f, 0.1f }, file.Id, 5, SymbolType.Method, "GetUser"),
            CreateChunk("// This handles user retrieval", ChunkType.Comment, "csharp",
                new[] { 0.7f, 0.3f, 0.1f, 0.1f }, file.Id, 4, null, null),
            CreateChunk("public class ProductService", ChunkType.Code, "csharp",
                new[] { 0.1f, 0.9f, 0.1f, 0.1f }, file.Id, 20, SymbolType.Class, "ProductService"),
        };

        await _store.AddChunksAsync(_indexId, chunks);
    }

    private static ChunkWithEmbedding CreateChunk(
        string content,
        ChunkType type,
        string language,
        float[] embedding,
        string fileId,
        int line,
        SymbolType? symbolType = null,
        string? symbolName = null)
    {
        return new ChunkWithEmbedding
        {
            Chunk = new TextChunk
            {
                Content = content,
                FilePath = "test.cs",
                StartLine = line,
                EndLine = line,
                Type = type,
                Language = language,
                SymbolType = symbolType,
                SymbolName = symbolName
            },
            Embedding = embedding,
            FileId = fileId
        };
    }

    public async Task DisposeAsync()
    {
        await _store.DisposeAsync();

        if (File.Exists(_dbPath))
            File.Delete(_dbPath);
    }

    #region Basic Search Tests

    [Fact]
    public async Task Search_ShouldReturnSimilarChunks()
    {
        // Arrange
        var queryEmbedding = new float[] { 0.85f, 0.15f, 0.1f, 0.1f }; // Similar to UserService
        var options = new VectorSearchOptions { TopK = 2 };

        // Act
        var results = await _store.SearchAsync(_indexId, queryEmbedding, options);

        // Assert
        Assert.NotEmpty(results);
        Assert.True(results[0].Chunk.Content.Contains("User"));
    }

    [Fact]
    public async Task Search_ShouldRespectTopK()
    {
        // Arrange
        var queryEmbedding = new float[] { 0.5f, 0.5f, 0.1f, 0.1f };
        var options = new VectorSearchOptions { TopK = 2 };

        // Act
        var results = await _store.SearchAsync(_indexId, queryEmbedding, options);

        // Assert
        Assert.True(results.Count <= 2);
    }

    [Fact]
    public async Task Search_ShouldOrderByScore()
    {
        // Arrange
        var queryEmbedding = new float[] { 0.5f, 0.5f, 0.1f, 0.1f };
        var options = new VectorSearchOptions { TopK = 10 };

        // Act
        var results = await _store.SearchAsync(_indexId, queryEmbedding, options);

        // Assert
        for (int i = 1; i < results.Count; i++)
        {
            Assert.True(results[i - 1].Score >= results[i].Score);
        }
    }

    #endregion

    #region Filter Tests

    [Fact]
    public async Task Search_WithLanguageFilter_ShouldFilterResults()
    {
        // Arrange
        var queryEmbedding = new float[] { 0.5f, 0.5f, 0.1f, 0.1f };
        var options = new VectorSearchOptions
        {
            TopK = 10,
            Languages = ["csharp"]
        };

        // Act
        var results = await _store.SearchAsync(_indexId, queryEmbedding, options);

        // Assert
        Assert.All(results, r => Assert.Equal("csharp", r.Chunk.Language));
    }

    [Fact]
    public async Task Search_WithChunkTypeFilter_ShouldFilterResults()
    {
        // Arrange
        var queryEmbedding = new float[] { 0.5f, 0.5f, 0.1f, 0.1f };
        var options = new VectorSearchOptions
        {
            TopK = 10,
            ChunkTypes = [ChunkType.Comment]
        };

        // Act
        var results = await _store.SearchAsync(_indexId, queryEmbedding, options);

        // Assert
        Assert.All(results, r => Assert.Equal(ChunkType.Comment, r.Chunk.ChunkType));
    }

    [Fact]
    public async Task Search_WithSymbolTypeFilter_ShouldFilterResults()
    {
        // Arrange
        var queryEmbedding = new float[] { 0.5f, 0.5f, 0.1f, 0.1f };
        var options = new VectorSearchOptions
        {
            TopK = 10,
            SymbolTypes = [SymbolType.Class]
        };

        // Act
        var results = await _store.SearchAsync(_indexId, queryEmbedding, options);

        // Assert
        Assert.All(results, r => Assert.Equal(SymbolType.Class, r.Chunk.SymbolType));
    }

    [Fact]
    public async Task Search_WithMinScore_ShouldExcludeLowScores()
    {
        // Arrange
        var queryEmbedding = new float[] { 0.9f, 0.1f, 0.1f, 0.1f };
        var options = new VectorSearchOptions
        {
            TopK = 10,
            MinScore = 0.5f
        };

        // Act
        var results = await _store.SearchAsync(_indexId, queryEmbedding, options);

        // Assert
        Assert.All(results, r => Assert.True(r.Score >= 0.5f));
    }

    #endregion
}
```

### 3. VectorSearchHelperTests.cs

**Location**: `tests/SeniorIntern.Tests/VectorStore/VectorSearchHelperTests.cs`

```csharp
namespace SeniorIntern.Tests.VectorStore;

using System;
using SeniorIntern.Services.VectorStore;
using Xunit;

/// <summary>
/// Unit tests for VectorSearchHelper SIMD operations.
/// </summary>
public class VectorSearchHelperTests
{
    #region Cosine Similarity Tests

    [Fact]
    public void CosineSimilarity_IdenticalVectors_ShouldReturnOne()
    {
        // Arrange
        var a = new float[] { 1, 2, 3 };
        var b = new float[] { 1, 2, 3 };

        // Act
        var similarity = VectorSearchHelper.CosineSimilarity(a, b);

        // Assert
        Assert.Equal(1.0f, similarity, precision: 5);
    }

    [Fact]
    public void CosineSimilarity_OrthogonalVectors_ShouldReturnZero()
    {
        // Arrange
        var a = new float[] { 1, 0, 0 };
        var b = new float[] { 0, 1, 0 };

        // Act
        var similarity = VectorSearchHelper.CosineSimilarity(a, b);

        // Assert
        Assert.Equal(0.0f, similarity, precision: 5);
    }

    [Fact]
    public void CosineSimilarity_OppositeVectors_ShouldReturnNegativeOne()
    {
        // Arrange
        var a = new float[] { 1, 0, 0 };
        var b = new float[] { -1, 0, 0 };

        // Act
        var similarity = VectorSearchHelper.CosineSimilarity(a, b);

        // Assert
        Assert.Equal(-1.0f, similarity, precision: 5);
    }

    [Fact]
    public void CosineSimilarity_DifferentDimensions_ShouldThrow()
    {
        // Arrange
        var a = new float[] { 1, 2 };
        var b = new float[] { 1, 2, 3 };

        // Act & Assert
        Assert.Throws<ArgumentException>(() => VectorSearchHelper.CosineSimilarity(a, b));
    }

    [Fact]
    public void CosineSimilarity_LargeVectors_ShouldCalculateCorrectly()
    {
        // Arrange - Test SIMD code path with 384-dim vectors
        var a = new float[384];
        var b = new float[384];
        for (int i = 0; i < 384; i++)
        {
            a[i] = i / 384f;
            b[i] = i / 384f;
        }

        // Act
        var similarity = VectorSearchHelper.CosineSimilarity(a, b);

        // Assert
        Assert.Equal(1.0f, similarity, precision: 4);
    }

    #endregion

    #region L2 Distance Tests

    [Fact]
    public void L2Distance_IdenticalVectors_ShouldReturnZero()
    {
        // Arrange
        var a = new float[] { 1, 2, 3 };
        var b = new float[] { 1, 2, 3 };

        // Act
        var distance = VectorSearchHelper.L2Distance(a, b);

        // Assert
        Assert.Equal(0.0f, distance, precision: 5);
    }

    [Fact]
    public void L2Distance_DifferentVectors_ShouldReturnCorrectDistance()
    {
        // Arrange - 3-4-5 triangle
        var a = new float[] { 0, 0, 0 };
        var b = new float[] { 3, 4, 0 };

        // Act
        var distance = VectorSearchHelper.L2Distance(a, b);

        // Assert
        Assert.Equal(5.0f, distance, precision: 5);
    }

    #endregion

    #region Normalize Tests

    [Fact]
    public void Normalize_ShouldMakeUnitLength()
    {
        // Arrange
        var vector = new float[] { 3, 4, 0 };

        // Act
        VectorSearchHelper.Normalize(vector);

        // Assert
        var magnitude = MathF.Sqrt(vector[0] * vector[0] + vector[1] * vector[1] + vector[2] * vector[2]);
        Assert.Equal(1.0f, magnitude, precision: 5);
    }

    [Fact]
    public void Normalize_ZeroVector_ShouldRemainZero()
    {
        // Arrange
        var vector = new float[] { 0, 0, 0 };

        // Act
        VectorSearchHelper.Normalize(vector);

        // Assert
        Assert.All(vector, v => Assert.Equal(0, v));
    }

    [Fact]
    public void Normalized_ShouldReturnNewVector()
    {
        // Arrange
        var original = new float[] { 3, 4, 0 };

        // Act
        var normalized = VectorSearchHelper.Normalized(original);

        // Assert
        Assert.Equal(3, original[0]); // Original unchanged
        Assert.NotEqual(3, normalized[0]); // Normalized is different
    }

    #endregion
}
```

### 4. FileHasherTests.cs

**Location**: `tests/SeniorIntern.Tests/VectorStore/FileHasherTests.cs`

```csharp
namespace SeniorIntern.Tests.VectorStore;

using System.IO;
using System.Threading.Tasks;
using SeniorIntern.Services.VectorStore;
using Xunit;

/// <summary>
/// Unit tests for FileHasher.
/// </summary>
public class FileHasherTests
{
    #region String Hash Tests

    [Fact]
    public void ComputeHash_SameContent_ShouldReturnSameHash()
    {
        // Arrange
        var content = "Hello, World!";

        // Act
        var hash1 = FileHasher.ComputeHash(content);
        var hash2 = FileHasher.ComputeHash(content);

        // Assert
        Assert.Equal(hash1, hash2);
    }

    [Fact]
    public void ComputeHash_DifferentContent_ShouldReturnDifferentHash()
    {
        // Arrange
        var content1 = "Hello";
        var content2 = "World";

        // Act
        var hash1 = FileHasher.ComputeHash(content1);
        var hash2 = FileHasher.ComputeHash(content2);

        // Assert
        Assert.NotEqual(hash1, hash2);
    }

    [Fact]
    public void ComputeHash_ShouldReturnLowercaseHex()
    {
        // Arrange
        var content = "Test";

        // Act
        var hash = FileHasher.ComputeHash(content);

        // Assert
        Assert.Equal(hash.ToLower(), hash);
        Assert.Equal(64, hash.Length); // SHA-256 = 64 hex chars
    }

    #endregion

    #region File Hash Tests

    [Fact]
    public async Task ComputeHashAsync_File_ShouldReturnValidHash()
    {
        // Arrange
        var tempPath = Path.GetTempFileName();
        var content = "Test content for hashing";
        await File.WriteAllTextAsync(tempPath, content);

        try
        {
            // Act
            var fileHash = await FileHasher.ComputeHashAsync(tempPath);

            // Assert
            Assert.NotEmpty(fileHash);
            Assert.Equal(64, fileHash.Length);
        }
        finally
        {
            File.Delete(tempPath);
        }
    }

    [Fact]
    public async Task ComputeHashAsync_SameContent_SameHash()
    {
        // Arrange
        var tempPath1 = Path.GetTempFileName();
        var tempPath2 = Path.GetTempFileName();
        var content = "Identical content";
        await File.WriteAllTextAsync(tempPath1, content);
        await File.WriteAllTextAsync(tempPath2, content);

        try
        {
            // Act
            var hash1 = await FileHasher.ComputeHashAsync(tempPath1);
            var hash2 = await FileHasher.ComputeHashAsync(tempPath2);

            // Assert
            Assert.Equal(hash1, hash2);
        }
        finally
        {
            File.Delete(tempPath1);
            File.Delete(tempPath2);
        }
    }

    #endregion

    #region Quick Hash Tests

    [Fact]
    public void ComputeQuickHash_ShouldReturnNonEmptyHash()
    {
        // Arrange
        var tempPath = Path.GetTempFileName();
        File.WriteAllText(tempPath, "Test");

        try
        {
            // Act
            var hash = FileHasher.ComputeQuickHash(tempPath);

            // Assert
            Assert.NotEmpty(hash);
        }
        finally
        {
            File.Delete(tempPath);
        }
    }

    [Fact]
    public void ComputeQuickHash_NonExistentFile_ShouldReturnEmpty()
    {
        // Arrange
        var nonExistentPath = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString());

        // Act
        var hash = FileHasher.ComputeQuickHash(nonExistentPath);

        // Assert
        Assert.Empty(hash);
    }

    [Fact]
    public void HasFileChanged_WhenUnchanged_ShouldReturnFalse()
    {
        // Arrange
        var tempPath = Path.GetTempFileName();
        File.WriteAllText(tempPath, "Test");
        var originalHash = FileHasher.ComputeQuickHash(tempPath);

        try
        {
            // Act
            var hasChanged = FileHasher.HasFileChanged(tempPath, originalHash);

            // Assert
            Assert.False(hasChanged);
        }
        finally
        {
            File.Delete(tempPath);
        }
    }

    #endregion
}
```

### 5. FileScannerTests.cs

**Location**: `tests/SeniorIntern.Tests/VectorStore/FileScannerTests.cs`

```csharp
namespace SeniorIntern.Tests.VectorStore;

using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging.Abstractions;
using SeniorIntern.Core.Models;
using SeniorIntern.Services.VectorStore;
using Xunit;

/// <summary>
/// Unit tests for FileScanner.
/// </summary>
public class FileScannerTests
{
    private readonly FileScanner _scanner;

    public FileScannerTests()
    {
        _scanner = new FileScanner(NullLogger<FileScanner>.Instance);
    }

    #region Basic Scanning Tests

    [Fact]
    public async Task Scan_ShouldFindMatchingFiles()
    {
        // Arrange
        var tempDir = CreateTempDirectory();
        File.WriteAllText(Path.Combine(tempDir, "test.cs"), "public class Test { }");
        File.WriteAllText(Path.Combine(tempDir, "test.txt"), "Plain text");

        var settings = new VectorIndexSettings
        {
            IncludePatterns = ["**/*.cs"],
            ExcludePatterns = []
        };

        try
        {
            // Act
            var files = await _scanner.ScanAsync(tempDir, settings);

            // Assert
            Assert.Single(files);
            Assert.Equal("test.cs", files[0].RelativePath);
            Assert.Equal("csharp", files[0].Language);
        }
        finally
        {
            Directory.Delete(tempDir, recursive: true);
        }
    }

    [Fact]
    public async Task Scan_ShouldExcludePatterns()
    {
        // Arrange
        var tempDir = CreateTempDirectory();
        var nodeModules = Path.Combine(tempDir, "node_modules");
        Directory.CreateDirectory(nodeModules);

        File.WriteAllText(Path.Combine(tempDir, "app.ts"), "const x = 1;");
        File.WriteAllText(Path.Combine(nodeModules, "lib.ts"), "export const y = 2;");

        var settings = new VectorIndexSettings
        {
            IncludePatterns = ["**/*.ts"],
            ExcludePatterns = ["**/node_modules/**"]
        };

        try
        {
            // Act
            var files = await _scanner.ScanAsync(tempDir, settings);

            // Assert
            Assert.Single(files);
            Assert.Equal("app.ts", files[0].RelativePath);
        }
        finally
        {
            Directory.Delete(tempDir, recursive: true);
        }
    }

    [Fact]
    public async Task Scan_ShouldSkipLargeFiles()
    {
        // Arrange
        var tempDir = CreateTempDirectory();
        var smallContent = "small";
        var largeContent = new string('x', 2 * 1024 * 1024); // 2MB

        File.WriteAllText(Path.Combine(tempDir, "small.cs"), smallContent);
        File.WriteAllText(Path.Combine(tempDir, "large.cs"), largeContent);

        var settings = new VectorIndexSettings
        {
            IncludePatterns = ["**/*.cs"],
            MaxFileSizeKb = 1024 // 1MB max
        };

        try
        {
            // Act
            var files = await _scanner.ScanAsync(tempDir, settings);

            // Assert
            Assert.Single(files);
            Assert.Equal("small.cs", files[0].RelativePath);
        }
        finally
        {
            Directory.Delete(tempDir, recursive: true);
        }
    }

    #endregion

    #region Change Detection Tests

    [Fact]
    public async Task ScanForChanges_ShouldDetectAddedFiles()
    {
        // Arrange
        var tempDir = CreateTempDirectory();
        File.WriteAllText(Path.Combine(tempDir, "existing.cs"), "existing");
        File.WriteAllText(Path.Combine(tempDir, "new.cs"), "new file");

        var existingHashes = new Dictionary<string, string>
        {
            ["existing.cs"] = FileHasher.ComputeHash("existing")
        };

        var settings = new VectorIndexSettings
        {
            IncludePatterns = ["**/*.cs"]
        };

        try
        {
            // Act
            var changes = await _scanner.ScanForChangesAsync(tempDir, settings, existingHashes);

            // Assert
            Assert.Single(changes.AddedFiles);
            Assert.Contains("new.cs", changes.AddedFiles);
            Assert.Single(changes.UnchangedFiles);
        }
        finally
        {
            Directory.Delete(tempDir, recursive: true);
        }
    }

    [Fact]
    public async Task ScanForChanges_ShouldDetectModifiedFiles()
    {
        // Arrange
        var tempDir = CreateTempDirectory();
        File.WriteAllText(Path.Combine(tempDir, "modified.cs"), "new content");

        var existingHashes = new Dictionary<string, string>
        {
            ["modified.cs"] = FileHasher.ComputeHash("old content")
        };

        var settings = new VectorIndexSettings
        {
            IncludePatterns = ["**/*.cs"]
        };

        try
        {
            // Act
            var changes = await _scanner.ScanForChangesAsync(tempDir, settings, existingHashes);

            // Assert
            Assert.Single(changes.ModifiedFiles);
            Assert.Contains("modified.cs", changes.ModifiedFiles);
        }
        finally
        {
            Directory.Delete(tempDir, recursive: true);
        }
    }

    [Fact]
    public async Task ScanForChanges_ShouldDetectDeletedFiles()
    {
        // Arrange
        var tempDir = CreateTempDirectory();
        // Note: "deleted.cs" does not exist on disk

        var existingHashes = new Dictionary<string, string>
        {
            ["deleted.cs"] = "some-old-hash"
        };

        var settings = new VectorIndexSettings
        {
            IncludePatterns = ["**/*.cs"]
        };

        try
        {
            // Act
            var changes = await _scanner.ScanForChangesAsync(tempDir, settings, existingHashes);

            // Assert
            Assert.Single(changes.DeletedFiles);
            Assert.Contains("deleted.cs", changes.DeletedFiles);
        }
        finally
        {
            Directory.Delete(tempDir, recursive: true);
        }
    }

    #endregion

    #region Language Detection Tests

    [Theory]
    [InlineData("test.cs", "csharp")]
    [InlineData("test.ts", "typescript")]
    [InlineData("test.py", "python")]
    [InlineData("test.java", "java")]
    [InlineData("test.go", "go")]
    [InlineData("test.rs", "rust")]
    [InlineData("test.md", "markdown")]
    [InlineData("test.unknown", null)]
    public void DetectLanguage_ShouldIdentifyCorrectLanguage(string path, string? expected)
    {
        // Act
        var language = FileScanner.DetectLanguage(path);

        // Assert
        Assert.Equal(expected, language);
    }

    #endregion

    #region Helper Methods

    private static string CreateTempDirectory()
    {
        var path = Path.Combine(Path.GetTempPath(), $"scan_test_{Path.GetRandomFileName()}");
        Directory.CreateDirectory(path);
        return path;
    }

    #endregion
}
```

### 6. FileContentReaderTests.cs

**Location**: `tests/SeniorIntern.Tests/VectorStore/FileContentReaderTests.cs`

```csharp
namespace SeniorIntern.Tests.VectorStore;

using System.IO;
using System.Text;
using System.Threading.Tasks;
using SeniorIntern.Services.VectorStore;
using Xunit;

/// <summary>
/// Unit tests for FileContentReader.
/// </summary>
public class FileContentReaderTests
{
    #region Encoding Detection Tests

    [Fact]
    public async Task ReadAsync_Utf8File_ShouldReadCorrectly()
    {
        // Arrange
        var tempPath = Path.GetTempFileName();
        var content = "Hello, World!\nLine 2\nLine 3";
        await File.WriteAllTextAsync(tempPath, content, Encoding.UTF8);

        try
        {
            // Act
            var result = await FileContentReader.ReadAsync(tempPath);

            // Assert
            Assert.Equal("Hello, World!\nLine 2\nLine 3", result.Content);
            Assert.Equal(3, result.LineCount);
            Assert.Equal("utf-8", result.Encoding.ToLowerInvariant());
        }
        finally
        {
            File.Delete(tempPath);
        }
    }

    [Fact]
    public async Task ReadAsync_Utf8WithBom_ShouldDetectCorrectly()
    {
        // Arrange
        var tempPath = Path.GetTempFileName();
        var content = "UTF-8 with BOM";
        await File.WriteAllTextAsync(tempPath, content, new UTF8Encoding(encoderShouldEmitUTF8Identifier: true));

        try
        {
            // Act
            var result = await FileContentReader.ReadAsync(tempPath);

            // Assert
            Assert.Contains("UTF-8", result.Content);
        }
        finally
        {
            File.Delete(tempPath);
        }
    }

    #endregion

    #region Line Ending Tests

    [Fact]
    public async Task ReadAsync_ShouldNormalizeLineEndings()
    {
        // Arrange
        var tempPath = Path.GetTempFileName();
        var content = "Line 1\r\nLine 2\rLine 3\nLine 4";
        await File.WriteAllBytesAsync(tempPath, Encoding.UTF8.GetBytes(content));

        try
        {
            // Act
            var result = await FileContentReader.ReadAsync(tempPath);

            // Assert
            Assert.DoesNotContain("\r", result.Content);
            Assert.Equal(4, result.LineCount);
        }
        finally
        {
            File.Delete(tempPath);
        }
    }

    #endregion

    #region Line Extraction Tests

    [Fact]
    public void ExtractLines_ShouldExtractCorrectRange()
    {
        // Arrange
        var content = "Line 1\nLine 2\nLine 3\nLine 4\nLine 5";

        // Act
        var extracted = FileContentReader.ExtractLines(content, 2, 4);

        // Assert
        Assert.Equal("Line 2\nLine 3\nLine 4", extracted);
    }

    [Fact]
    public void ExtractLines_SingleLine_ShouldExtractOneLine()
    {
        // Arrange
        var content = "Line 1\nLine 2\nLine 3";

        // Act
        var extracted = FileContentReader.ExtractLines(content, 2, 2);

        // Assert
        Assert.Equal("Line 2", extracted);
    }

    [Fact]
    public void ExtractLines_BeyondEnd_ShouldClamp()
    {
        // Arrange
        var content = "Line 1\nLine 2\nLine 3";

        // Act
        var extracted = FileContentReader.ExtractLines(content, 2, 100);

        // Assert
        Assert.Equal("Line 2\nLine 3", extracted);
    }

    #endregion

    #region Line Number/Offset Tests

    [Fact]
    public void GetLineNumber_ShouldReturnCorrectLine()
    {
        // Arrange
        var content = "Line 1\nLine 2\nLine 3";

        // Act & Assert
        Assert.Equal(1, FileContentReader.GetLineNumber(content, 0));
        Assert.Equal(1, FileContentReader.GetLineNumber(content, 5));
        Assert.Equal(2, FileContentReader.GetLineNumber(content, 7));
        Assert.Equal(3, FileContentReader.GetLineNumber(content, 14));
    }

    [Fact]
    public void GetLineOffset_ShouldReturnCorrectOffset()
    {
        // Arrange
        var content = "Line 1\nLine 2\nLine 3";

        // Act & Assert
        Assert.Equal(0, FileContentReader.GetLineOffset(content, 1));
        Assert.Equal(7, FileContentReader.GetLineOffset(content, 2));
        Assert.Equal(14, FileContentReader.GetLineOffset(content, 3));
    }

    #endregion
}
```

### 7. VectorIndexSettingsTests.cs

**Location**: `tests/SeniorIntern.Tests/VectorStore/VectorIndexSettingsTests.cs`

```csharp
namespace SeniorIntern.Tests.VectorStore;

using System.Linq;
using SeniorIntern.Core.Models;
using Xunit;

/// <summary>
/// Unit tests for VectorIndexSettings.
/// </summary>
public class VectorIndexSettingsTests
{
    [Fact]
    public void DefaultSettings_ShouldHaveReasonableDefaults()
    {
        // Arrange & Act
        var settings = new VectorIndexSettings();

        // Assert
        Assert.NotEmpty(settings.IncludePatterns);
        Assert.NotEmpty(settings.ExcludePatterns);
        Assert.Equal(1024, settings.MaxFileSizeKb);
        Assert.True(settings.RespectGitignore);
        Assert.False(settings.IndexHiddenFiles);
    }

    [Fact]
    public void DefaultSettings_ShouldIncludeCommonCodeFiles()
    {
        // Arrange & Act
        var settings = new VectorIndexSettings();

        // Assert
        Assert.Contains("**/*.cs", settings.IncludePatterns);
        Assert.Contains("**/*.ts", settings.IncludePatterns);
        Assert.Contains("**/*.py", settings.IncludePatterns);
        Assert.Contains("**/*.java", settings.IncludePatterns);
    }

    [Fact]
    public void DefaultSettings_ShouldExcludeCommonDirectories()
    {
        // Arrange & Act
        var settings = new VectorIndexSettings();

        // Assert
        Assert.Contains("**/node_modules/**", settings.ExcludePatterns);
        Assert.Contains("**/bin/**", settings.ExcludePatterns);
        Assert.Contains("**/obj/**", settings.ExcludePatterns);
        Assert.Contains("**/.git/**", settings.ExcludePatterns);
    }

    [Fact]
    public void ChunkingOptions_ShouldHaveValidDefaults()
    {
        // Arrange & Act
        var settings = new VectorIndexSettings();

        // Assert
        Assert.True(settings.ChunkingOptions.TargetChunkSize > 0);
        Assert.True(settings.ChunkingOptions.MaxChunkSize > settings.ChunkingOptions.TargetChunkSize);
        Assert.True(settings.ChunkingOptions.ChunkOverlap > 0);
    }
}
```

### 8. IndexStatisticsTests.cs

**Location**: `tests/SeniorIntern.Tests/VectorStore/IndexStatisticsTests.cs`

```csharp
namespace SeniorIntern.Tests.VectorStore;

using System.Collections.Generic;
using SeniorIntern.Core.Models;
using Xunit;

/// <summary>
/// Unit tests for IndexStatistics model.
/// </summary>
public class IndexStatisticsTests
{
    [Fact]
    public void AverageChunksPerFile_ShouldCalculateCorrectly()
    {
        // Arrange
        var stats = new IndexStatistics
        {
            IndexId = "test",
            IndexName = "Test",
            TotalFiles = 10,
            TotalChunks = 50,
            EmbeddingModel = "test"
        };

        // Act & Assert
        Assert.Equal(5.0, stats.AverageChunksPerFile);
    }

    [Fact]
    public void AverageChunksPerFile_ZeroFiles_ShouldReturnZero()
    {
        // Arrange
        var stats = new IndexStatistics
        {
            IndexId = "test",
            IndexName = "Test",
            TotalFiles = 0,
            TotalChunks = 0,
            EmbeddingModel = "test"
        };

        // Act & Assert
        Assert.Equal(0, stats.AverageChunksPerFile);
    }

    [Fact]
    public void TotalDatabaseSize_ShouldSumVectorAndMetadata()
    {
        // Arrange
        var stats = new IndexStatistics
        {
            IndexId = "test",
            IndexName = "Test",
            VectorDataSizeBytes = 1000,
            MetadataSizeBytes = 500,
            EmbeddingModel = "test"
        };

        // Act & Assert
        Assert.Equal(1500, stats.TotalDatabaseSizeBytes);
    }

    [Theory]
    [InlineData(512, "512.00 B")]
    [InlineData(1024, "1.00 KB")]
    [InlineData(1048576, "1.00 MB")]
    [InlineData(1073741824, "1.00 GB")]
    public void FormattedFileSize_ShouldFormatCorrectly(long bytes, string expected)
    {
        // Arrange
        var stats = new IndexStatistics
        {
            IndexId = "test",
            IndexName = "Test",
            TotalFileSizeBytes = bytes,
            EmbeddingModel = "test"
        };

        // Act & Assert
        Assert.Equal(expected, stats.FormattedFileSize);
    }
}
```

---

## Unit Test Summary

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                          Test Summary by File                                 │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  File                          │ Test Count │ Category                       │
│  ═════════════════════════════ │ ══════════ │ ══════════════════════════════ │
│  SqliteVectorStoreTests.cs     │ 12         │ Integration (IAsyncLifetime)   │
│  VectorSearchTests.cs          │ 8          │ Integration (IAsyncLifetime)   │
│  VectorSearchHelperTests.cs    │ 8          │ Unit (pure functions)          │
│  FileHasherTests.cs            │ 8          │ Unit (temp files)              │
│  FileScannerTests.cs           │ 8          │ Unit (temp directories)        │
│  FileContentReaderTests.cs     │ 8          │ Unit (temp files)              │
│  VectorIndexSettingsTests.cs   │ 4          │ Unit (model validation)        │
│  IndexStatisticsTests.cs       │ 4          │ Unit (computed properties)     │
│  ─────────────────────────────── │ ────────── │ ────────────────────────────── │
│  Total                         │ 60         │                                │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Summary

| File | Location | Purpose | Tests |
|------|----------|---------|-------|
| `SqliteVectorStoreTests.cs` | `Tests/VectorStore/` | Core store tests | 12 |
| `VectorSearchTests.cs` | `Tests/VectorStore/` | Search tests | 8 |
| `VectorSearchHelperTests.cs` | `Tests/VectorStore/` | SIMD tests | 8 |
| `FileHasherTests.cs` | `Tests/VectorStore/` | Hashing tests | 8 |
| `FileScannerTests.cs` | `Tests/VectorStore/` | Scanning tests | 8 |
| `FileContentReaderTests.cs` | `Tests/VectorStore/` | Encoding tests | 8 |
| `VectorIndexSettingsTests.cs` | `Tests/VectorStore/` | Settings tests | 4 |
| `IndexStatisticsTests.cs` | `Tests/VectorStore/` | Statistics tests | 4 |

---

## Test Patterns Used

| Pattern | Purpose | Files Using |
|---------|---------|-------------|
| `IAsyncLifetime` | Async setup/teardown with temp DB | Store, Search |
| `[Fact]` | Single test case | All files |
| `[Theory]` | Parameterized tests | FileScanner, Statistics |
| `[InlineData]` | Theory parameters | FileScanner, Statistics |
| `try/finally` | Temp file cleanup | Hasher, Scanner, Reader |
| Helper methods | DRY test setup | Store, Search, Scanner |

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | All 60 tests pass |
| AC-2 | Integration tests use temp databases |
| AC-3 | Temp files/directories are cleaned up |
| AC-4 | No external dependencies except SQLite |
| AC-5 | Tests cover happy path and error cases |
| AC-6 | SIMD tests verify correctness |
| AC-7 | Parameterized tests for boundary values |
| AC-8 | Tests are isolated and can run in parallel |

---

## Changelog Entry

```markdown
## v0.7.2j - Unit Testing & Integration

### Added
- `SqliteVectorStoreTests.cs` (12 tests)
  - Index CRUD: Create, Get, GetForWorkspace, List, Delete
  - Chunk CRUD: Add, Get, RemoveForFile
  - Error handling: empty name, invalid dimension

- `VectorSearchTests.cs` (8 tests)
  - Basic search: similar chunks, TopK, ordering
  - Filters: language, chunk type, symbol type, min score

- `VectorSearchHelperTests.cs` (8 tests)
  - CosineSimilarity: identical, orthogonal, opposite, large vectors
  - L2Distance: identical, different
  - Normalize: unit length, zero vector

- `FileHasherTests.cs` (8 tests)
  - String hash: same/different content, lowercase hex
  - File hash: valid hash, same content
  - Quick hash: non-empty, non-existent file, unchanged

- `FileScannerTests.cs` (8 tests)
  - Scan: matching files, exclude patterns, large files
  - Changes: added, modified, deleted files
  - Language: detection for common extensions

- `FileContentReaderTests.cs` (8 tests)
  - Encoding: UTF-8, BOM detection
  - Line endings: normalization
  - Line extraction: range, single, clamping
  - Line number/offset conversions

- `VectorIndexSettingsTests.cs` (4 tests)
  - Defaults: include/exclude patterns, limits
  - ChunkingOptions validation

- `IndexStatisticsTests.cs` (4 tests)
  - Computed properties: averages, totals
  - Formatting: byte size display

### Test Infrastructure
- IAsyncLifetime for async setup/teardown
- Temp database/file isolation
- Automatic cleanup in try/finally blocks
- Theory-based parameterized tests
```

---

## Timeline Estimate

| Version | Estimated Effort |
|---------|------------------|
| v0.7.2j | 1 day |
