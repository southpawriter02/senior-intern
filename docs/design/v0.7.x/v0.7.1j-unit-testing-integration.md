# Design Specification: AIntern v0.7.1j "Unit Testing & Integration"

## Overview

**Version**: v0.7.1j
**Parent**: v0.7.1 Embedding Foundation
**Focus**: Create comprehensive tests for all embedding and chunking functionality

### Purpose

Create comprehensive unit and integration tests for v0.7.1:
1. Unit tests for `EmbeddingMath` SIMD operations
2. Unit tests for `ChunkingService` orchestration
3. Unit tests for `CodeAwareChunkingStrategy` and language-specific strategies
4. Unit tests for `MarkdownChunkingStrategy` heading splitting
5. Unit tests for `TokenEstimator` estimation utilities
6. Integration tests for `LlamaEmbeddingService` with real models
7. Integration tests for similarity calculations

### Dependencies

**Tests cover all v0.7.1 sub-versions:**
- v0.7.1a: Embedding Service Interface
- v0.7.1b: LlamaSharp Embedding Implementation
- v0.7.1c: ONNX Embedding Pipeline
- v0.7.1d: Text Chunk Models
- v0.7.1e: Chunking Service Interface
- v0.7.1f: Code-Aware Chunking Strategy
- v0.7.1g: Language-Specific Chunkers
- v0.7.1h: Markdown & Config File Chunking
- v0.7.1i: Tokenization Utilities

---

## Test Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                       v0.7.1j Test Architecture                               │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Test Projects:                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  tests/                                                                  │ │
│  │  ├── SeniorIntern.Tests.Unit/                                           │ │
│  │  │   ├── Embedding/                                                     │ │
│  │  │   │   ├── EmbeddingMathTests.cs          (v0.7.1c)                  │ │
│  │  │   │   ├── TokenEstimatorTests.cs         (v0.7.1i)                  │ │
│  │  │   │   └── SimpleTokenizerTests.cs        (v0.7.1i)                  │ │
│  │  │   │                                                                  │ │
│  │  │   └── Chunking/                                                      │ │
│  │  │       ├── ChunkingServiceTests.cs        (v0.7.1e)                  │ │
│  │  │       ├── CodeAwareChunkingTests.cs      (v0.7.1f)                  │ │
│  │  │       ├── CSharpChunkingTests.cs         (v0.7.1g)                  │ │
│  │  │       ├── TypeScriptChunkingTests.cs     (v0.7.1g)                  │ │
│  │  │       ├── PythonChunkingTests.cs         (v0.7.1g)                  │ │
│  │  │       ├── MarkdownChunkingTests.cs       (v0.7.1g)                  │ │
│  │  │       └── ConfigFileChunkingTests.cs     (v0.7.1h)                  │ │
│  │  │                                                                      │ │
│  │  └── SeniorIntern.Tests.Integration/                                    │ │
│  │      └── Embedding/                                                     │ │
│  │          ├── LlamaEmbeddingIntegrationTests.cs    (v0.7.1b)            │ │
│  │          └── OnnxEmbeddingIntegrationTests.cs     (v0.7.1c)            │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  Test Categories:                                                            │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  Unit Tests (~60 tests):                                                 │ │
│  │  ├── Fast, isolated, no external dependencies                           │ │
│  │  ├── Use NullLogger and mock services                                   │ │
│  │  └── Run on every build                                                 │ │
│  │                                                                          │ │
│  │  Integration Tests (~10 tests):                                          │ │
│  │  ├── Require actual embedding model                                     │ │
│  │  ├── Skipped if EMBEDDING_MODEL_PATH not set                            │ │
│  │  └── Run in CI with model artifacts                                     │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Test Coverage Matrix

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                         Test Coverage Matrix                                  │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Component                    │ Unit │ Integration │ Coverage Target        │
│  ────────────────────────────│──────│─────────────│─────────────────────── │
│  EmbeddingMath               │ 8    │ -           │ 100%                    │
│  TokenEstimator              │ 6    │ -           │ 100%                    │
│  SimpleTokenizer             │ 5    │ -           │ 90%                     │
│  ChunkingService             │ 10   │ -           │ 95%                     │
│  CodeAwareChunkingStrategy   │ 8    │ -           │ 85%                     │
│  CSharpChunkingStrategy      │ 6    │ -           │ 90%                     │
│  TypeScriptChunkingStrategy  │ 5    │ -           │ 85%                     │
│  PythonChunkingStrategy      │ 5    │ -           │ 85%                     │
│  MarkdownChunkingStrategy    │ 4    │ -           │ 90%                     │
│  ConfigFileChunkingStrategy  │ 3    │ -           │ 90%                     │
│  LlamaEmbeddingService       │ -    │ 4           │ Integration only        │
│  OnnxEmbeddingService        │ -    │ 3           │ Integration only        │
│  ────────────────────────────│──────│─────────────│─────────────────────── │
│  TOTAL                       │ ~60  │ ~7          │                         │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Specifications

### 1. EmbeddingMathTests.cs

**Location**: `tests/SeniorIntern.Tests.Unit/Embedding/EmbeddingMathTests.cs`

```csharp
namespace SeniorIntern.Tests.Unit.Embedding;

using SeniorIntern.Services.Embedding;
using Xunit;

/// <summary>
/// Unit tests for EmbeddingMath SIMD-optimized operations.
/// </summary>
public class EmbeddingMathTests
{
    #region CosineSimilarity Tests

    [Fact]
    public void CosineSimilarity_IdenticalVectors_ReturnsOne()
    {
        // Arrange
        var v1 = new float[] { 1, 2, 3, 4, 5 };
        var v2 = new float[] { 1, 2, 3, 4, 5 };

        // Act
        var similarity = EmbeddingMath.CosineSimilarity(v1, v2);

        // Assert
        Assert.Equal(1.0f, similarity, precision: 5);
    }

    [Fact]
    public void CosineSimilarity_OrthogonalVectors_ReturnsZero()
    {
        // Arrange - orthogonal unit vectors
        var v1 = new float[] { 1, 0, 0 };
        var v2 = new float[] { 0, 1, 0 };

        // Act
        var similarity = EmbeddingMath.CosineSimilarity(v1, v2);

        // Assert
        Assert.Equal(0.0f, similarity, precision: 5);
    }

    [Fact]
    public void CosineSimilarity_OppositeVectors_ReturnsNegativeOne()
    {
        // Arrange
        var v1 = new float[] { 1, 2, 3 };
        var v2 = new float[] { -1, -2, -3 };

        // Act
        var similarity = EmbeddingMath.CosineSimilarity(v1, v2);

        // Assert
        Assert.Equal(-1.0f, similarity, precision: 5);
    }

    [Fact]
    public void CosineSimilarity_ZeroVector_ReturnsZero()
    {
        // Arrange
        var v1 = new float[] { 1, 2, 3 };
        var v2 = new float[] { 0, 0, 0 };

        // Act
        var similarity = EmbeddingMath.CosineSimilarity(v1, v2);

        // Assert
        Assert.Equal(0.0f, similarity);
    }

    [Fact]
    public void CosineSimilarity_DifferentLengths_ThrowsException()
    {
        // Arrange
        var v1 = new float[] { 1, 2, 3 };
        var v2 = new float[] { 1, 2 };

        // Act & Assert
        Assert.Throws<ArgumentException>(() =>
            EmbeddingMath.CosineSimilarity(v1, v2));
    }

    #endregion

    #region Normalize Tests

    [Fact]
    public void Normalize_CreatesUnitVector()
    {
        // Arrange - 3-4-5 triangle
        var v = new float[] { 3, 4 };

        // Act
        EmbeddingMath.Normalize(v);

        // Assert
        var magnitude = MathF.Sqrt(v[0] * v[0] + v[1] * v[1]);
        Assert.Equal(1.0f, magnitude, precision: 5);
    }

    [Fact]
    public void Normalize_ZeroVector_RemainsZero()
    {
        // Arrange
        var v = new float[] { 0, 0, 0 };

        // Act
        EmbeddingMath.Normalize(v);

        // Assert
        Assert.All(v, x => Assert.Equal(0f, x));
    }

    #endregion

    #region DotProduct Tests

    [Fact]
    public void DotProduct_ReturnsCorrectValue()
    {
        // Arrange
        var v1 = new float[] { 1, 2, 3 };
        var v2 = new float[] { 4, 5, 6 };

        // Act
        var dot = EmbeddingMath.DotProduct(v1, v2);

        // Assert - 1*4 + 2*5 + 3*6 = 32
        Assert.Equal(32.0f, dot);
    }

    [Fact]
    public void DotProduct_OrthogonalVectors_ReturnsZero()
    {
        // Arrange
        var v1 = new float[] { 1, 0 };
        var v2 = new float[] { 0, 1 };

        // Act
        var dot = EmbeddingMath.DotProduct(v1, v2);

        // Assert
        Assert.Equal(0.0f, dot);
    }

    #endregion
}
```

### 2. ChunkingServiceTests.cs

**Location**: `tests/SeniorIntern.Tests.Unit/Chunking/ChunkingServiceTests.cs`

```csharp
namespace SeniorIntern.Tests.Unit.Chunking;

using Microsoft.Extensions.Logging.Abstractions;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Services.Chunking;
using Xunit;

/// <summary>
/// Unit tests for ChunkingService orchestration.
/// </summary>
public class ChunkingServiceTests
{
    private readonly ChunkingService _service;

    public ChunkingServiceTests()
    {
        var strategies = new IChunkingStrategy[]
        {
            new PlainTextChunkingStrategy(
                NullLogger<PlainTextChunkingStrategy>.Instance,
                null!) // Will use internal estimation
        };

        _service = new ChunkingService(
            NullLogger<ChunkingService>.Instance,
            strategies,
            null); // No tokenizer, use fallback estimation
    }

    #region Language Detection Tests

    [Theory]
    [InlineData(".cs", "csharp")]
    [InlineData(".ts", "typescript")]
    [InlineData(".tsx", "typescript")]
    [InlineData(".js", "javascript")]
    [InlineData(".jsx", "javascript")]
    [InlineData(".py", "python")]
    [InlineData(".go", "go")]
    [InlineData(".rs", "rust")]
    [InlineData(".java", "java")]
    [InlineData(".kt", "kotlin")]
    [InlineData(".md", "markdown")]
    [InlineData(".json", "json")]
    [InlineData(".yaml", "yaml")]
    [InlineData(".xml", "xml")]
    public void DetectLanguage_ReturnsCorrectLanguage(string extension, string expected)
    {
        // Act
        var language = _service.DetectLanguage($"test{extension}");

        // Assert
        Assert.Equal(expected, language);
    }

    [Fact]
    public void DetectLanguage_UnknownExtension_ReturnsNull()
    {
        // Act
        var language = _service.DetectLanguage("test.xyz");

        // Assert
        Assert.Null(language);
    }

    #endregion

    #region Token Estimation Tests

    [Fact]
    public void EstimateTokenCount_ReturnsReasonableEstimate()
    {
        // Arrange - 31 characters
        var text = "Hello, this is a test sentence.";

        // Act
        var estimate = _service.EstimateTokenCount(text);

        // Assert - Should be roughly text.Length / 4
        Assert.InRange(estimate, 5, 15);
    }

    [Fact]
    public void EstimateTokenCount_EmptyString_ReturnsZero()
    {
        // Act
        var estimate = _service.EstimateTokenCount("");

        // Assert
        Assert.Equal(0, estimate);
    }

    #endregion

    #region Preprocessing Tests

    [Fact]
    public void Preprocess_NormalizesWhitespace()
    {
        // Arrange
        var options = new ChunkPreprocessing
        {
            NormalizeWhitespace = true
        };
        var content = "line1\r\nline2\tindented";

        // Act
        var result = _service.Preprocess(content, options);

        // Assert
        Assert.Contains("\n", result);
        Assert.DoesNotContain("\r", result);
        Assert.Contains("    ", result); // Tab converted to 4 spaces
    }

    [Fact]
    public void Preprocess_CollapsesMultipleNewlines()
    {
        // Arrange
        var options = new ChunkPreprocessing
        {
            CollapseMultipleNewlines = true,
            MaxConsecutiveEmptyLines = 2
        };
        var content = "line1\n\n\n\n\nline2";

        // Act
        var result = _service.Preprocess(content, options);

        // Assert
        Assert.DoesNotContain("\n\n\n\n", result);
    }

    [Fact]
    public void Preprocess_TrimsLines()
    {
        // Arrange
        var options = new ChunkPreprocessing
        {
            TrimLines = true
        };
        var content = "  line1  \n  line2  ";

        // Act
        var result = _service.Preprocess(content, options);

        // Assert
        Assert.Equal("line1\nline2", result);
    }

    [Fact]
    public void Preprocess_RemovesEmptyLines()
    {
        // Arrange
        var options = new ChunkPreprocessing
        {
            RemoveEmptyLines = true
        };
        var content = "line1\n\n\nline2";

        // Act
        var result = _service.Preprocess(content, options);

        // Assert
        Assert.Equal("line1\nline2", result);
    }

    #endregion

    #region Strategy Selection Tests

    [Fact]
    public void GetStrategy_ReturnsHighestPriority()
    {
        // Arrange - service has PlainTextChunkingStrategy (priority 0)
        
        // Act
        var strategy = _service.GetStrategy("test.txt");

        // Assert
        Assert.IsType<PlainTextChunkingStrategy>(strategy);
    }

    [Fact]
    public void IsSupported_WithMatchingStrategy_ReturnsTrue()
    {
        // Act
        var supported = _service.IsSupported("test.txt");

        // Assert
        Assert.True(supported);
    }

    #endregion
}
```

### 3. CodeAwareChunkingTests.cs

**Location**: `tests/SeniorIntern.Tests.Unit/Chunking/CodeAwareChunkingTests.cs`

```csharp
namespace SeniorIntern.Tests.Unit.Chunking;

using Microsoft.Extensions.Logging.Abstractions;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Services.Chunking;
using Xunit;

/// <summary>
/// Unit tests for CodeAwareChunkingStrategy.
/// </summary>
public class CodeAwareChunkingTests
{
    #region C# Code Tests

    [Fact]
    public void Chunk_CSharpClass_ExtractsClassChunk()
    {
        // Arrange
        var strategy = CreateStrategy();
        var code = @"
namespace Test
{
    public class MyClass
    {
        public void MyMethod()
        {
        }
    }
}";

        // Act
        var chunks = strategy.Chunk(code, "test.cs", new ChunkingOptions());

        // Assert
        Assert.NotEmpty(chunks);
        Assert.Contains(chunks, c => c.SymbolName == "MyClass");
    }

    [Fact]
    public void Chunk_CSharpInterface_ExtractsInterfaceChunk()
    {
        // Arrange
        var strategy = CreateStrategy();
        var code = @"
namespace Test
{
    public interface IMyInterface
    {
        void DoSomething();
    }
}";

        // Act
        var chunks = strategy.Chunk(code, "test.cs", new ChunkingOptions());

        // Assert
        Assert.Contains(chunks, c => c.SymbolType == SymbolType.Interface);
    }

    #endregion

    #region TypeScript Code Tests

    [Fact]
    public void Chunk_TypeScriptFunction_ExtractsFunctionChunk()
    {
        // Arrange
        var strategy = CreateStrategy();
        var code = @"
export function calculateSum(a: number, b: number): number {
    return a + b;
}";

        // Act
        var chunks = strategy.Chunk(code, "test.ts", new ChunkingOptions());

        // Assert
        Assert.NotEmpty(chunks);
        Assert.Contains(chunks, c => c.SymbolType == SymbolType.Function);
    }

    [Fact]
    public void Chunk_TypeScriptArrowFunction_ExtractsFunctionChunk()
    {
        // Arrange
        var strategy = CreateStrategy();
        var code = @"
export const multiply = (a: number, b: number): number => {
    return a * b;
};";

        // Act
        var chunks = strategy.Chunk(code, "test.ts", new ChunkingOptions());

        // Assert
        Assert.NotEmpty(chunks);
    }

    #endregion

    #region Python Code Tests

    [Fact]
    public void Chunk_PythonFunction_UsesPythonStrategy()
    {
        // Arrange
        var strategy = new PythonChunkingStrategy(
            NullLogger<PythonChunkingStrategy>.Instance,
            CreateMockChunkingService());

        var code = @"
def my_function(x, y):
    '''Calculate the sum'''
    return x + y

class MyClass:
    def __init__(self):
        pass
";

        // Act
        var chunks = strategy.Chunk(code, "test.py", new ChunkingOptions());

        // Assert
        Assert.NotEmpty(chunks);
        Assert.Contains(chunks, c => c.SymbolName == "my_function");
        Assert.Contains(chunks, c => c.SymbolName == "MyClass");
    }

    [Fact]
    public void Chunk_PythonMethod_ParentClassSet()
    {
        // Arrange
        var strategy = new PythonChunkingStrategy(
            NullLogger<PythonChunkingStrategy>.Instance,
            CreateMockChunkingService());

        var code = @"
class Calculator:
    def add(self, a, b):
        return a + b
";

        // Act
        var chunks = strategy.Chunk(code, "test.py", new ChunkingOptions());

        // Assert
        var methodChunk = chunks.FirstOrDefault(c => c.SymbolName == "add");
        Assert.NotNull(methodChunk);
        Assert.Equal("Calculator", methodChunk.ParentSymbol);
    }

    #endregion

    #region Large File Tests

    [Fact]
    public void Chunk_LargeFile_SplitsIntoMultipleChunks()
    {
        // Arrange
        var strategy = CreateStrategy();
        var code = string.Join("\n", Enumerable.Range(1, 1000)
            .Select(i => $"// Line {i}"));

        var options = new ChunkingOptions
        {
            TargetChunkSize = 100,
            MaxChunkSize = 200
        };

        // Act
        var chunks = strategy.Chunk(code, "test.cs", options);

        // Assert
        Assert.True(chunks.Count > 1);
    }

    [Fact]
    public void Chunk_WithOverlap_ChunksOverlap()
    {
        // Arrange
        var strategy = CreateStrategy();
        var code = string.Join("\n", Enumerable.Range(1, 100)
            .Select(i => $"// Line {i}"));

        var options = new ChunkingOptions
        {
            TargetChunkSize = 20,
            ChunkOverlap = 5
        };

        // Act
        var chunks = strategy.Chunk(code, "test.cs", options);

        // Assert - Later chunks should have overlap flag
        Assert.Contains(chunks, c => c.HasOverlap);
    }

    #endregion

    #region Symbol Extraction Tests

    [Fact]
    public void ExtractSymbols_CSharpCode_FindsAllSymbols()
    {
        // Arrange
        var strategy = CreateCSharpStrategy();
        var code = @"
namespace Test
{
    public class MyClass
    {
        public int Property { get; set; }
        
        public void Method() { }
    }
}";

        // Act
        var symbols = strategy.ExtractSymbols(code, "test.cs");

        // Assert
        Assert.Contains(symbols, s => s.Type == SymbolType.Namespace);
        Assert.Contains(symbols, s => s.Type == SymbolType.Class);
        Assert.Contains(symbols, s => s.Type == SymbolType.Method);
    }

    #endregion

    #region Helper Methods

    private static CodeAwareChunkingStrategy CreateStrategy()
    {
        return new CodeAwareChunkingStrategy(
            NullLogger<CodeAwareChunkingStrategy>.Instance,
            CreateMockChunkingService());
    }

    private static CSharpChunkingStrategy CreateCSharpStrategy()
    {
        return new CSharpChunkingStrategy(
            NullLogger<CSharpChunkingStrategy>.Instance,
            CreateMockChunkingService());
    }

    private static IChunkingService CreateMockChunkingService()
    {
        var strategies = new IChunkingStrategy[]
        {
            new PlainTextChunkingStrategy(
                NullLogger<PlainTextChunkingStrategy>.Instance, null!)
        };

        return new ChunkingService(
            NullLogger<ChunkingService>.Instance,
            strategies,
            null);
    }

    #endregion
}
```

### 4. MarkdownChunkingTests.cs

**Location**: `tests/SeniorIntern.Tests.Unit/Chunking/MarkdownChunkingTests.cs`

```csharp
namespace SeniorIntern.Tests.Unit.Chunking;

using Microsoft.Extensions.Logging.Abstractions;
using SeniorIntern.Core.Models;
using SeniorIntern.Services.Chunking;
using Xunit;

/// <summary>
/// Unit tests for MarkdownChunkingStrategy.
/// </summary>
public class MarkdownChunkingTests
{
    [Fact]
    public void Chunk_MarkdownWithHeadings_SplitsByHeadings()
    {
        // Arrange
        var service = CreateMockChunkingService();
        var strategy = new MarkdownChunkingStrategy(
            NullLogger<MarkdownChunkingStrategy>.Instance,
            service);

        var content = @"
# Introduction

This is the intro.

## Section One

Content for section one.

## Section Two

Content for section two.
";

        // Act
        var chunks = strategy.Chunk(content, "test.md", new ChunkingOptions());

        // Assert
        Assert.True(chunks.Count >= 2);
        Assert.Contains(chunks, c => c.SymbolName == "Introduction");
        Assert.Contains(chunks, c => c.SymbolName == "Section One");
    }

    [Fact]
    public void Chunk_SmallMarkdown_SingleChunk()
    {
        // Arrange
        var service = CreateMockChunkingService();
        var strategy = new MarkdownChunkingStrategy(
            NullLogger<MarkdownChunkingStrategy>.Instance,
            service);

        var content = @"
# Title

A short paragraph.
";

        // Act
        var chunks = strategy.Chunk(content, "test.md", new ChunkingOptions
        {
            MinChunkSize = 1
        });

        // Assert
        Assert.Single(chunks);
        Assert.Equal(ChunkType.Markdown, chunks[0].Type);
    }

    [Fact]
    public void Chunk_MarkdownWithNestedHeadings_PreservesHierarchy()
    {
        // Arrange
        var service = CreateMockChunkingService();
        var strategy = new MarkdownChunkingStrategy(
            NullLogger<MarkdownChunkingStrategy>.Instance,
            service);

        var content = @"
# Main Title

## Subsection A

### Subsubsection A1

Content

## Subsection B

More content
";

        // Act
        var chunks = strategy.Chunk(content, "test.md", new ChunkingOptions());

        // Assert
        Assert.True(chunks.Count >= 2);
    }

    [Fact]
    public void Chunk_MarkdownNoHeadings_SingleChunk()
    {
        // Arrange
        var service = CreateMockChunkingService();
        var strategy = new MarkdownChunkingStrategy(
            NullLogger<MarkdownChunkingStrategy>.Instance,
            service);

        var content = "Just some plain text without any headings.";

        // Act
        var chunks = strategy.Chunk(content, "test.md", new ChunkingOptions
        {
            MinChunkSize = 1
        });

        // Assert
        Assert.Single(chunks);
    }

    private static IChunkingService CreateMockChunkingService()
    {
        return new ChunkingService(
            NullLogger<ChunkingService>.Instance,
            Array.Empty<IChunkingStrategy>(),
            null);
    }
}
```

### 5. TokenEstimatorTests.cs

**Location**: `tests/SeniorIntern.Tests.Unit/Embedding/TokenEstimatorTests.cs`

```csharp
namespace SeniorIntern.Tests.Unit.Embedding;

using SeniorIntern.Services.Embedding;
using Xunit;

/// <summary>
/// Unit tests for TokenEstimator static utilities.
/// </summary>
public class TokenEstimatorTests
{
    #region EstimateForCode Tests

    [Fact]
    public void EstimateForCode_ReturnsReasonableEstimate()
    {
        // Arrange - 24 characters
        var code = "public void Method() { }";

        // Act
        var estimate = TokenEstimator.EstimateForCode(code);

        // Assert - 24/4 = 6
        Assert.Equal(6, estimate);
    }

    [Fact]
    public void EstimateForCode_EmptyString_ReturnsZero()
    {
        // Act
        var estimate = TokenEstimator.EstimateForCode("");

        // Assert
        Assert.Equal(0, estimate);
    }

    [Fact]
    public void EstimateForCode_NullString_ReturnsZero()
    {
        // Act
        var estimate = TokenEstimator.EstimateForCode(null!);

        // Assert
        Assert.Equal(0, estimate);
    }

    #endregion

    #region EstimateForText Tests

    [Fact]
    public void EstimateForText_ReturnsReasonableEstimate()
    {
        // Arrange - 22 characters
        var text = "Hello, this is a test.";

        // Act
        var estimate = TokenEstimator.EstimateForText(text);

        // Assert - ceil(22/4.5) = 5
        Assert.Equal(5, estimate);
    }

    #endregion

    #region EstimateAdaptive Tests

    [Fact]
    public void EstimateAdaptive_HighSymbolContent_UsesLowerRatio()
    {
        // Arrange - high symbol density
        var code = "a + b * c / d - e % f";

        // Act
        var estimate = TokenEstimator.EstimateAdaptive(code);

        // Assert - Should use lower chars-per-token for symbol-heavy content
        Assert.True(estimate > code.Length / 5);
    }

    [Fact]
    public void EstimateAdaptive_HighDigitContent_UsesLowestRatio()
    {
        // Arrange - high digit density
        var data = "12345678901234567890";

        // Act
        var estimate = TokenEstimator.EstimateAdaptive(data);

        // Assert - Should use ~3 chars/token for numeric content
        Assert.True(estimate >= data.Length / 4);
    }

    #endregion

    #region Conversion Tests

    [Fact]
    public void CharactersToTokens_ConvertCorrectly()
    {
        // Arrange
        var chars = 100;

        // Act
        var tokens = TokenEstimator.CharactersToTokens(chars, TokenEstimationMode.Code);

        // Assert - 100/4 = 25
        Assert.Equal(25, tokens);
    }

    [Fact]
    public void TokensToCharacters_ConvertCorrectly()
    {
        // Arrange
        var tokens = 25;

        // Act
        var chars = TokenEstimator.TokensToCharacters(tokens, TokenEstimationMode.Code);

        // Assert - 25*4 = 100
        Assert.Equal(100, chars);
    }

    [Theory]
    [InlineData(TokenEstimationMode.Code, 25)]   // 100/4
    [InlineData(TokenEstimationMode.Text, 23)]   // ceil(100/4.5)
    [InlineData(TokenEstimationMode.Data, 34)]   // ceil(100/3)
    public void CharactersToTokens_DifferentModes_DifferentResults(
        TokenEstimationMode mode, int expected)
    {
        // Act
        var tokens = TokenEstimator.CharactersToTokens(100, mode);

        // Assert
        Assert.Equal(expected, tokens);
    }

    #endregion
}
```

### 6. LlamaEmbeddingIntegrationTests.cs

**Location**: `tests/SeniorIntern.Tests.Integration/Embedding/LlamaEmbeddingIntegrationTests.cs`

```csharp
namespace SeniorIntern.Tests.Integration.Embedding;

using Microsoft.Extensions.DependencyInjection;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Services.Embedding;
using Xunit;

/// <summary>
/// Integration tests for LlamaEmbeddingService.
/// Requires an actual embedding model to run.
/// </summary>
/// <remarks>
/// These tests require the EMBEDDING_MODEL_PATH environment variable
/// to be set to a valid GGUF embedding model path.
/// </remarks>
[Trait("Category", "Integration")]
public class LlamaEmbeddingIntegrationTests : IAsyncLifetime
{
    private IEmbeddingService? _service;
    private readonly string? _modelPath;

    public LlamaEmbeddingIntegrationTests()
    {
        _modelPath = Environment.GetEnvironmentVariable("EMBEDDING_MODEL_PATH");
    }

    public async Task InitializeAsync()
    {
        if (_modelPath is null)
            return;

        var services = new ServiceCollection();
        services.AddLogging();
        services.AddEmbeddingServices();

        var provider = services.BuildServiceProvider();
        _service = provider.GetRequiredService<LlamaEmbeddingService>();

        await _service.LoadModelAsync(new EmbeddingModelOptions
        {
            ModelPath = _modelPath,
            ModelName = "Test Model"
        });
    }

    public async Task DisposeAsync()
    {
        if (_service is IAsyncDisposable ad)
            await ad.DisposeAsync();
    }

    [SkippableFact]
    public async Task EmbedAsync_GeneratesEmbedding()
    {
        Skip.If(_service is null, "No embedding model available");

        // Act
        var embedding = await _service!.EmbedAsync("Hello, world!");

        // Assert
        Assert.NotNull(embedding);
        Assert.Equal(_service.EmbeddingDimension, embedding.Length);
    }

    [SkippableFact]
    public async Task EmbedBatchAsync_GeneratesMultipleEmbeddings()
    {
        Skip.If(_service is null, "No embedding model available");

        // Arrange
        var texts = new[] { "Hello", "World", "Test" };

        // Act
        var embeddings = await _service!.EmbedBatchAsync(texts);

        // Assert
        Assert.Equal(3, embeddings.Count);
        Assert.All(embeddings, e => Assert.Equal(_service.EmbeddingDimension, e.Length));
    }

    [SkippableFact]
    public async Task SimilarTexts_HaveHighSimilarity()
    {
        Skip.If(_service is null, "No embedding model available");

        // Arrange & Act
        var e1 = await _service!.EmbedAsync("How to implement a REST API in C#");
        var e2 = await _service.EmbedAsync("Creating RESTful services with C#");
        var e3 = await _service.EmbedAsync("The history of the Roman Empire");

        var similarity12 = _service.CosineSimilarity(e1, e2);
        var similarity13 = _service.CosineSimilarity(e1, e3);

        // Assert - Similar texts should have higher similarity
        Assert.True(similarity12 > similarity13,
            $"Expected similar texts to have higher similarity, but got {similarity12} vs {similarity13}");
    }

    [SkippableFact]
    public async Task EmbeddingsAreNormalized()
    {
        Skip.If(_service is null, "No embedding model available");

        // Act
        var embedding = await _service!.EmbedAsync("Test text");

        // Assert - Check magnitude is approximately 1
        var magnitude = MathF.Sqrt(embedding.Sum(x => x * x));
        Assert.InRange(magnitude, 0.99f, 1.01f);
    }
}
```

### 7. ConfigFileChunkingTests.cs

**Location**: `tests/SeniorIntern.Tests.Unit/Chunking/ConfigFileChunkingTests.cs`

```csharp
namespace SeniorIntern.Tests.Unit.Chunking;

using Microsoft.Extensions.Logging.Abstractions;
using SeniorIntern.Core.Models;
using SeniorIntern.Services.Chunking;
using Xunit;

/// <summary>
/// Unit tests for ConfigFileChunkingStrategy.
/// </summary>
public class ConfigFileChunkingTests
{
    [Theory]
    [InlineData(".json")]
    [InlineData(".yaml")]
    [InlineData(".yml")]
    [InlineData(".xml")]
    [InlineData(".toml")]
    [InlineData(".ini")]
    [InlineData(".env")]
    public void CanHandle_ConfigExtension_ReturnsTrue(string extension)
    {
        // Arrange
        var strategy = CreateStrategy();

        // Act
        var canHandle = strategy.CanHandle($"test{extension}");

        // Assert
        Assert.True(canHandle);
    }

    [Fact]
    public void CanHandle_NonConfigExtension_ReturnsFalse()
    {
        // Arrange
        var strategy = CreateStrategy();

        // Act
        var canHandle = strategy.CanHandle("test.cs");

        // Assert
        Assert.False(canHandle);
    }

    [Fact]
    public void Chunk_SmallConfig_SingleChunk()
    {
        // Arrange
        var strategy = CreateStrategy();
        var content = @"{
  ""name"": ""test"",
  ""version"": ""1.0.0""
}";

        // Act
        var chunks = strategy.Chunk(content, "package.json", new ChunkingOptions());

        // Assert
        Assert.Single(chunks);
        Assert.Equal(ChunkType.Config, chunks[0].Type);
        Assert.Equal("json", chunks[0].Language);
    }

    [Fact]
    public void Chunk_LargeConfig_MultipleChunks()
    {
        // Arrange
        var strategy = CreateStrategy();
        var content = string.Join("\n", Enumerable.Range(1, 500)
            .Select(i => $"\"key{i}\": \"value{i}\""));

        var options = new ChunkingOptions
        {
            MaxChunkSize = 100,
            TargetChunkSize = 50
        };

        // Act
        var chunks = strategy.Chunk(content, "large.json", options);

        // Assert
        Assert.True(chunks.Count > 1);
    }

    private static ConfigFileChunkingStrategy CreateStrategy()
    {
        var service = new ChunkingService(
            NullLogger<ChunkingService>.Instance,
            Array.Empty<IChunkingStrategy>(),
            null);

        return new ConfigFileChunkingStrategy(
            NullLogger<ConfigFileChunkingStrategy>.Instance,
            service);
    }
}
```

### 8. SimpleTokenizerTests.cs

**Location**: `tests/SeniorIntern.Tests.Unit/Embedding/SimpleTokenizerTests.cs`

```csharp
namespace SeniorIntern.Tests.Unit.Embedding;

using Microsoft.Extensions.Logging.Abstractions;
using SeniorIntern.Services.Embedding;
using Xunit;

/// <summary>
/// Unit tests for SimpleTokenizer.
/// </summary>
public class SimpleTokenizerTests
{
    private readonly SimpleTokenizer _tokenizer;

    public SimpleTokenizerTests()
    {
        _tokenizer = new SimpleTokenizer(NullLogger<SimpleTokenizer>.Instance);
    }

    [Fact]
    public void IsLoaded_AlwaysTrue()
    {
        // Assert
        Assert.True(_tokenizer.IsLoaded);
    }

    [Fact]
    public void CountTokens_EmptyString_ReturnsZero()
    {
        // Act
        var count = _tokenizer.CountTokens("");

        // Assert
        Assert.Equal(0, count);
    }

    [Fact]
    public void CountTokens_Code_ReturnsReasonableCount()
    {
        // Arrange
        var code = "public void Method() { return; }";

        // Act
        var count = _tokenizer.CountTokens(code);

        // Assert - Should find multiple tokens
        Assert.InRange(count, 5, 15);
    }

    [Fact]
    public void Encode_ReturnsTokenizedText()
    {
        // Arrange
        var text = "Hello world";

        // Act
        var result = _tokenizer.Encode(text, 100);

        // Assert
        Assert.NotNull(result);
        Assert.NotEmpty(result.InputIds);
        Assert.Equal(result.InputIds.Length, result.AttentionMask.Length);
    }

    [Fact]
    public void Encode_RespectsMaxLength()
    {
        // Arrange
        var longText = string.Join(" ", Enumerable.Repeat("word", 100));

        // Act
        var result = _tokenizer.Encode(longText, 10);

        // Assert
        Assert.True(result.InputIds.Length <= 10);
    }

    [Fact]
    public void Decode_ThrowsNotSupported()
    {
        // Arrange
        var tokenIds = new long[] { 1, 2, 3 };

        // Act & Assert
        Assert.Throws<NotSupportedException>(() =>
            _tokenizer.Decode(tokenIds));
    }
}
```

---

## Test Data Fixtures

```csharp
/// <summary>
/// Shared test fixtures for chunking tests.
/// </summary>
public static class ChunkingTestData
{
    public static string CSharpClassCode => @"
namespace TestNamespace
{
    /// <summary>
    /// A sample class for testing.
    /// </summary>
    public class SampleClass
    {
        public int Id { get; set; }
        
        public void DoSomething()
        {
            Console.WriteLine(""Hello"");
        }
    }
}";

    public static string TypeScriptFunctionCode => @"
/**
 * Calculate the sum of two numbers.
 */
export function calculateSum(a: number, b: number): number {
    return a + b;
}

export const multiply = (a: number, b: number): number => a * b;
";

    public static string PythonClassCode => @"
class Calculator:
    '''A simple calculator class.'''
    
    def __init__(self):
        self.value = 0
    
    def add(self, x: int, y: int) -> int:
        '''Add two numbers.'''
        return x + y
";

    public static string MarkdownDocument => @"
# Main Title

Introduction paragraph.

## Section One

Content for section one.

### Subsection 1.1

More detailed content.

## Section Two

Content for section two.
";
}
```

---

## Unit Test Plan

| Test File | Test Count | Coverage |
|-----------|------------|----------|
| `EmbeddingMathTests.cs` | 8 | CosineSimilarity, Normalize, DotProduct |
| `ChunkingServiceTests.cs` | 10 | Language detection, Token estimation, Preprocessing |
| `CodeAwareChunkingTests.cs` | 8 | Symbol extraction, Large files, Overlap |
| `CSharpChunkingTests.cs` | 6 | C# patterns |
| `TypeScriptChunkingTests.cs` | 5 | TS/JS patterns |
| `PythonChunkingTests.cs` | 5 | Python indentation |
| `MarkdownChunkingTests.cs` | 4 | Heading detection |
| `ConfigFileChunkingTests.cs` | 3 | Config file handling |
| `TokenEstimatorTests.cs` | 6 | Estimation modes |
| `SimpleTokenizerTests.cs` | 6 | Rule-based tokenization |
| `LlamaEmbeddingIntegrationTests.cs` | 4 | Real model testing |
| **TOTAL** | **~65** | |

---

## File Summary

| File | Location | Purpose | Lines |
|------|----------|---------|-------|
| `EmbeddingMathTests.cs` | `Tests.Unit/Embedding/` | SIMD math tests | ~100 |
| `ChunkingServiceTests.cs` | `Tests.Unit/Chunking/` | Orchestration tests | ~150 |
| `CodeAwareChunkingTests.cs` | `Tests.Unit/Chunking/` | Code chunking tests | ~180 |
| `MarkdownChunkingTests.cs` | `Tests.Unit/Chunking/` | Markdown tests | ~80 |
| `TokenEstimatorTests.cs` | `Tests.Unit/Embedding/` | Estimation tests | ~90 |
| `SimpleTokenizerTests.cs` | `Tests.Unit/Embedding/` | Tokenizer tests | ~70 |
| `ConfigFileChunkingTests.cs` | `Tests.Unit/Chunking/` | Config tests | ~60 |
| `LlamaEmbeddingIntegrationTests.cs` | `Tests.Integration/Embedding/` | Integration tests | ~100 |

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | EmbeddingMath unit tests pass |
| AC-2 | ChunkingService unit tests pass |
| AC-3 | CodeAwareChunking tests pass for multiple languages |
| AC-4 | MarkdownChunking tests pass |
| AC-5 | TokenEstimator tests pass |
| AC-6 | ConfigFileChunking tests pass |
| AC-7 | Integration tests run with actual model (when available) |
| AC-8 | Similar texts show higher similarity than dissimilar texts |
| AC-9 | All unit tests have >85% code coverage |
| AC-10 | Tests use NullLogger for isolation |

---

## Test Execution Commands

```bash
# Run all unit tests
dotnet test tests/SeniorIntern.Tests.Unit/

# Run all integration tests (requires EMBEDDING_MODEL_PATH)
dotnet test tests/SeniorIntern.Tests.Integration/ --filter "Category=Integration"

# Run specific test class
dotnet test --filter "FullyQualifiedName~EmbeddingMathTests"

# Run with coverage
dotnet test --collect:"XPlat Code Coverage"

# Run specific sub-version tests
dotnet test --filter "FullyQualifiedName~ChunkingServiceTests"
```

---

## Changelog Entry

```markdown
## v0.7.1j - Unit Testing & Integration

### Added
- Unit Tests (~60 tests)
  - `EmbeddingMathTests.cs` - SIMD operations (8 tests)
  - `ChunkingServiceTests.cs` - Orchestration (10 tests)
  - `CodeAwareChunkingTests.cs` - Symbol extraction (8 tests)
  - `CSharpChunkingTests.cs` - C# patterns (6 tests)
  - `TypeScriptChunkingTests.cs` - TS/JS patterns (5 tests)
  - `PythonChunkingTests.cs` - Python indentation (5 tests)
  - `MarkdownChunkingTests.cs` - Heading detection (4 tests)
  - `ConfigFileChunkingTests.cs` - Config files (3 tests)
  - `TokenEstimatorTests.cs` - Estimation modes (6 tests)
  - `SimpleTokenizerTests.cs` - Rule-based tokenization (6 tests)
- Integration Tests (~7 tests)
  - `LlamaEmbeddingIntegrationTests.cs` - Real model testing
  - Requires EMBEDDING_MODEL_PATH environment variable
  - Tests: embedding generation, batch embedding, similarity
- Test Fixtures
  - `ChunkingTestData` static class with sample code

### Test Patterns
- Use NullLogger for isolation
- Skip integration tests when model unavailable
- Theory/InlineData for parametric tests
- IAsyncLifetime for async setup/teardown

### Coverage Targets
| Component | Target |
|-----------|--------|
| EmbeddingMath | 100% |
| TokenEstimator | 100% |
| ChunkingService | 95% |
| Strategies | 85%+ |
```

---

## Timeline Estimate

| Version | Estimated Effort |
|---------|------------------|
| v0.7.1j | 1.0 day |
