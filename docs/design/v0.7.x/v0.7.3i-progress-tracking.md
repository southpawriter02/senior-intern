# Design Specification: AIntern v0.7.3i "Progress Tracking & Events"

## Overview

**Version**: v0.7.3i
**Parent**: v0.7.3 Indexing Pipeline
**Focus**: Detailed progress tracking, event aggregation, and performance metrics collection

### Purpose

This sub-version implements the progress and metrics system:
1. `ProgressTracker` - Tracks and calculates indexing progress with time estimates
2. `IndexingEventAggregator` - Collects and manages indexing events for display/logging
3. `IndexingMetrics` - Collects detailed performance metrics per file and language
4. Supporting models for events, file metrics, and summaries

### Dependencies

**From v0.7.3b (Indexing Models & Options)**:
- `IndexingProgress` model
- `IndexingResult` model
- `IndexingPhase` enum

**From v0.7.3c (Indexing Service Implementation)**:
- `IndexingService` uses these components for reporting

**From v0.7.3g (Background Job Queue)**:
- Event args classes for progress reporting

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                     v0.7.3i Progress Tracking & Events                        │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  src/SeniorIntern.Services/Indexing/                                         │
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │                                                                          ││
│  │  ProgressTracker                                                         ││
│  │  ┌────────────────────────────────────────────────────────────────────┐  ││
│  │  │  State                                                             │  ││
│  │  │  ├── _stopwatch: Stopwatch                                        │  ││
│  │  │  ├── _totalFiles, _totalBytes: int, long                          │  ││
│  │  │  ├── _processedFiles, _skippedFiles, _failedFiles: int            │  ││
│  │  │  ├── _totalChunks, _processedChunks: int                          │  ││
│  │  │  ├── _processedBytes: long                                         │  ││
│  │  │  ├── _currentFile: string?                                         │  ││
│  │  │  └── _phase: IndexingPhase                                         │  ││
│  │  └────────────────────────────────────────────────────────────────────┘  ││
│  │  ┌────────────────────────────────────────────────────────────────────┐  ││
│  │  │  Methods                                                           │  ││
│  │  │  ├── Start() / Stop()                                              │  ││
│  │  │  ├── SetPhase(phase)                                               │  ││
│  │  │  ├── SetCurrentFile(file)                                          │  ││
│  │  │  ├── FileProcessed(chunkCount, bytes)                             │  ││
│  │  │  ├── FileSkipped()                                                 │  ││
│  │  │  ├── FileFailed()                                                  │  ││
│  │  │  ├── GetProgress(message) → IndexingProgress                      │  ││
│  │  │  └── GetResult(indexId, success, error) → IndexingResult          │  ││
│  │  └────────────────────────────────────────────────────────────────────┘  ││
│  │                                                                          ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │  IndexingEventAggregator                                                 ││
│  │  ┌────────────────────────────────────────────────────────────────────┐  ││
│  │  │  State                                                             │  ││
│  │  │  ├── _events: ConcurrentQueue<IndexingEvent>                      │  ││
│  │  │  └── _maxEvents: int (default 1000)                               │  ││
│  │  └────────────────────────────────────────────────────────────────────┘  ││
│  │  ┌────────────────────────────────────────────────────────────────────┐  ││
│  │  │  Methods                                                           │  ││
│  │  │  ├── AddEvent(type, message, data)                                │  ││
│  │  │  ├── FileStarted(filePath)                                        │  ││
│  │  │  ├── FileCompleted(filePath, chunkCount)                          │  ││
│  │  │  ├── FileFailed(filePath, error)                                  │  ││
│  │  │  ├── PhaseChanged(phase)                                           │  ││
│  │  │  ├── ProgressUpdate(progress)                                      │  ││
│  │  │  ├── GetRecentEvents(count) → List<IndexingEvent>                 │  ││
│  │  │  ├── GetEventsSince(since) → List<IndexingEvent>                  │  ││
│  │  │  └── Clear()                                                       │  ││
│  │  └────────────────────────────────────────────────────────────────────┘  ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │  IndexingMetrics                                                         ││
│  │  ┌────────────────────────────────────────────────────────────────────┐  ││
│  │  │  State                                                             │  ││
│  │  │  ├── _byLanguage: ConcurrentDictionary<string, LanguageMetrics>   │  ││
│  │  │  ├── _fileMetrics: ConcurrentBag<FileMetrics>                     │  ││
│  │  │  └── _totalFilesProcessed, _totalChunksCreated, etc.: long        │  ││
│  │  └────────────────────────────────────────────────────────────────────┘  ││
│  │  ┌────────────────────────────────────────────────────────────────────┐  ││
│  │  │  Methods                                                           │  ││
│  │  │  ├── RecordFile(metrics)                                          │  ││
│  │  │  ├── GetSummary() → IndexingMetricsSummary                        │  ││
│  │  │  └── Reset()                                                       │  ││
│  │  └────────────────────────────────────────────────────────────────────┘  ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
│  Supporting Models                                                           │
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │  IndexingEvent           → Type, Message, Data, Timestamp               ││
│  │  IndexingEventType       → FileStarted, FileCompleted, FileFailed, ...  ││
│  │  FileMetrics             → FilePath, Language, Size, ChunkCount, Times  ││
│  │  LanguageMetrics         → Aggregated counts by language                ││
│  │  IndexingMetricsSummary  → Totals, averages, rates, by-language         ││
│  │  LanguageMetricsSummary  → FileCount, TotalChunks, Averages             ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Progress Tracking Flow

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                      Progress Tracking Integration                            │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  IndexingService.IndexWorkspaceAsync()                                       │
│  │                                                                           │
│  ▼                                                                           │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  1. INITIALIZE TRACKER                                                  │ │
│  │  ┌───────────────────────────────────────────────────────────────────┐  │ │
│  │  │  var tracker = new ProgressTracker(files.Count, totalBytes);     │  │ │
│  │  │  tracker.Start();                                                 │  │ │
│  │  │  tracker.SetPhase(IndexingPhase.Scanning);                       │  │ │
│  │  └───────────────────────────────────────────────────────────────────┘  │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                           │                                                  │
│                           ▼                                                  │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  2. PROCESS FILES (loop)                                                │ │
│  │  ┌───────────────────────────────────────────────────────────────────┐  │ │
│  │  │  foreach (var file in files)                                      │  │ │
│  │  │  {                                                                 │  │ │
│  │  │    tracker.SetCurrentFile(file.RelativePath);                    │  │ │
│  │  │    eventAggregator.FileStarted(file.RelativePath);               │  │ │
│  │  │                                                                    │  │ │
│  │  │    try {                                                          │  │ │
│  │  │      var result = await ProcessFileAsync(...);                    │  │ │
│  │  │                                                                    │  │ │
│  │  │      tracker.FileProcessed(result.ChunkCount, result.Bytes);     │  │ │
│  │  │      eventAggregator.FileCompleted(file, result.ChunkCount);     │  │ │
│  │  │      metrics.RecordFile(new FileMetrics { ... });                │  │ │
│  │  │    }                                                               │  │ │
│  │  │    catch (Exception ex) {                                         │  │ │
│  │  │      tracker.FileFailed();                                        │  │ │
│  │  │      eventAggregator.FileFailed(file, ex.Message);               │  │ │
│  │  │    }                                                               │  │ │
│  │  │                                                                    │  │ │
│  │  │    // Report progress periodically                                │  │ │
│  │  │    progress?.Report(tracker.GetProgress());                       │  │ │
│  │  │  }                                                                 │  │ │
│  │  └───────────────────────────────────────────────────────────────────┘  │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                           │                                                  │
│                           ▼                                                  │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  3. FINALIZE                                                            │ │
│  │  ┌───────────────────────────────────────────────────────────────────┐  │ │
│  │  │  tracker.SetPhase(IndexingPhase.Complete);                       │  │ │
│  │  │  eventAggregator.PhaseChanged(IndexingPhase.Complete);           │  │ │
│  │  │                                                                    │  │ │
│  │  │  var result = tracker.GetResult(indexId, success);               │  │ │
│  │  │  var metricsSummary = metrics.GetSummary();                      │  │ │
│  │  │                                                                    │  │ │
│  │  │  return result;                                                   │  │ │
│  │  └───────────────────────────────────────────────────────────────────┘  │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Services/Indexing/ProgressTracker.cs` | Progress calculation and time estimates |
| `src/SeniorIntern.Services/Indexing/IndexingEventAggregator.cs` | Event collection and retrieval |
| `src/SeniorIntern.Services/Indexing/IndexingMetrics.cs` | Performance metrics collection |
| `src/SeniorIntern.Services/Indexing/ProgressModels.cs` | Event and metrics models |

---

## Detailed Specifications

### 1. ProgressTracker.cs

**Location**: `src/SeniorIntern.Services/Indexing/ProgressTracker.cs`

```csharp
using System;
using System.Diagnostics;
using SeniorIntern.Core.Models;

namespace SeniorIntern.Services.Indexing;

/// <summary>
/// Tracks and calculates indexing progress.
/// </summary>
/// <remarks>
/// <para>
/// The ProgressTracker maintains state for a single indexing operation,
/// including file counts, chunk counts, timing, and current phase.
/// It calculates derived values like completion percentage, processing rates,
/// and estimated time remaining.
/// </para>
/// <para>
/// Usage pattern:
/// <code>
/// var tracker = new ProgressTracker(totalFiles, totalBytes);
/// tracker.Start();
/// tracker.SetPhase(IndexingPhase.Processing);
/// 
/// foreach (var file in files)
/// {
///     tracker.SetCurrentFile(file.Path);
///     // ... process file ...
///     tracker.FileProcessed(chunkCount, fileBytes);
///     progress?.Report(tracker.GetProgress());
/// }
/// 
/// return tracker.GetResult(indexId, success);
/// </code>
/// </para>
/// </remarks>
public sealed class ProgressTracker
{
    private readonly Stopwatch _stopwatch = new();
    private readonly int _totalFiles;
    private readonly long _totalBytes;

    private int _processedFiles;
    private int _skippedFiles;
    private int _failedFiles;
    private int _totalChunks;
    private int _processedChunks;
    private long _processedBytes;
    private string? _currentFile;
    private IndexingPhase _phase = IndexingPhase.Initializing;

    /// <summary>
    /// Initializes a new instance of the <see cref="ProgressTracker"/> class.
    /// </summary>
    /// <param name="totalFiles">Total number of files to process.</param>
    /// <param name="totalBytes">Total bytes to process (optional, for byte-based progress).</param>
    public ProgressTracker(int totalFiles, long totalBytes = 0)
    {
        _totalFiles = totalFiles;
        _totalBytes = totalBytes;
    }

    /// <summary>
    /// Gets elapsed time since tracking started.
    /// </summary>
    public TimeSpan Elapsed => _stopwatch.Elapsed;

    /// <summary>
    /// Gets whether the tracker is currently running.
    /// </summary>
    public bool IsRunning => _stopwatch.IsRunning;

    /// <summary>
    /// Gets the current phase.
    /// </summary>
    public IndexingPhase Phase => _phase;

    /// <summary>
    /// Gets the current file being processed.
    /// </summary>
    public string? CurrentFile => _currentFile;

    /// <summary>
    /// Gets processed file count.
    /// </summary>
    public int ProcessedFiles => _processedFiles;

    /// <summary>
    /// Gets total chunk count.
    /// </summary>
    public int TotalChunks => _totalChunks;

    /// <summary>
    /// Start the timer.
    /// </summary>
    public void Start()
    {
        _stopwatch.Start();
    }

    /// <summary>
    /// Stop the timer.
    /// </summary>
    public void Stop()
    {
        _stopwatch.Stop();
    }

    /// <summary>
    /// Set the current indexing phase.
    /// </summary>
    public void SetPhase(IndexingPhase phase)
    {
        _phase = phase;
    }

    /// <summary>
    /// Set the current file being processed.
    /// </summary>
    public void SetCurrentFile(string? file)
    {
        _currentFile = file;
    }

    /// <summary>
    /// Record a successfully processed file.
    /// </summary>
    /// <param name="chunkCount">Number of chunks created from this file.</param>
    /// <param name="bytes">Size of the file in bytes.</param>
    public void FileProcessed(int chunkCount, long bytes)
    {
        _processedFiles++;
        _totalChunks += chunkCount;
        _processedChunks += chunkCount;
        _processedBytes += bytes;
    }

    /// <summary>
    /// Record a skipped file (filtered out, already indexed, etc.).
    /// </summary>
    public void FileSkipped()
    {
        _skippedFiles++;
    }

    /// <summary>
    /// Record a failed file.
    /// </summary>
    public void FileFailed()
    {
        _failedFiles++;
    }

    /// <summary>
    /// Get current progress snapshot.
    /// </summary>
    /// <param name="message">Optional status message.</param>
    /// <returns>Progress snapshot with all computed values.</returns>
    public IndexingProgress GetProgress(string? message = null)
    {
        var elapsed = _stopwatch.Elapsed;
        var processedCount = _processedFiles + _skippedFiles + _failedFiles;

        // Calculate percent complete
        var percentComplete = _totalFiles > 0
            ? (double)processedCount / _totalFiles * 100
            : 0;

        // Calculate estimated time remaining
        TimeSpan? estimatedRemaining = null;
        if (processedCount > 0 && elapsed.TotalSeconds > 0)
        {
            var rate = processedCount / elapsed.TotalSeconds;
            var remaining = _totalFiles - processedCount;
            if (rate > 0)
            {
                estimatedRemaining = TimeSpan.FromSeconds(remaining / rate);
            }
        }

        // Calculate processing rates
        var filesPerSecond = elapsed.TotalSeconds > 0
            ? _processedFiles / elapsed.TotalSeconds
            : 0;

        var chunksPerSecond = elapsed.TotalSeconds > 0
            ? _processedChunks / elapsed.TotalSeconds
            : 0;

        return new IndexingProgress
        {
            Phase = _phase,
            TotalFiles = _totalFiles,
            ProcessedFiles = _processedFiles,
            SkippedFiles = _skippedFiles,
            FailedFiles = _failedFiles,
            TotalChunks = _totalChunks,
            ProcessedChunks = _processedChunks,
            CurrentFile = _currentFile,
            Message = message,
            PercentComplete = percentComplete,
            Elapsed = elapsed,
            EstimatedRemaining = estimatedRemaining,
            FilesPerSecond = filesPerSecond,
            ChunksPerSecond = chunksPerSecond,
            BytesProcessed = _processedBytes,
            TotalBytes = _totalBytes,
            CanPause = _phase is IndexingPhase.Scanning or IndexingPhase.Processing,
            CanCancel = _phase is not IndexingPhase.Complete and not IndexingPhase.Cancelled
        };
    }

    /// <summary>
    /// Get final result when indexing completes.
    /// </summary>
    /// <param name="indexId">ID of the index.</param>
    /// <param name="success">Whether indexing was successful.</param>
    /// <param name="errorMessage">Error message if failed.</param>
    /// <returns>Final indexing result.</returns>
    public IndexingResult GetResult(string indexId, bool success, string? errorMessage = null)
    {
        _stopwatch.Stop();
        var duration = _stopwatch.Elapsed;

        return new IndexingResult
        {
            Success = success,
            IndexId = indexId,
            FilesIndexed = _processedFiles,
            FilesSkipped = _skippedFiles,
            FilesErrored = _failedFiles,
            ChunksCreated = _totalChunks,
            ChunksRemoved = 0, // Set by caller if applicable
            BytesProcessed = _processedBytes,
            Duration = duration,
            StartedAt = DateTime.UtcNow - duration,
            CompletedAt = DateTime.UtcNow,
            ErrorMessage = errorMessage,
            WasCancelled = _phase == IndexingPhase.Cancelled
        };
    }

    /// <summary>
    /// Reset all counters and restart tracking.
    /// </summary>
    public void Reset()
    {
        _stopwatch.Reset();
        _processedFiles = 0;
        _skippedFiles = 0;
        _failedFiles = 0;
        _totalChunks = 0;
        _processedChunks = 0;
        _processedBytes = 0;
        _currentFile = null;
        _phase = IndexingPhase.Initializing;
    }
}
```

### 2. IndexingEventAggregator.cs

**Location**: `src/SeniorIntern.Services/Indexing/IndexingEventAggregator.cs`

```csharp
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using SeniorIntern.Core.Models;

namespace SeniorIntern.Services.Indexing;

/// <summary>
/// Aggregates and manages indexing events.
/// </summary>
/// <remarks>
/// <para>
/// The event aggregator maintains a bounded queue of recent indexing events.
/// When the queue exceeds <see cref="_maxEvents"/>, oldest events are removed.
/// </para>
/// <para>
/// Events can be retrieved:
/// <list type="bullet">
///   <item>Most recent N events via <see cref="GetRecentEvents"/></item>
///   <item>Events since a timestamp via <see cref="GetEventsSince"/></item>
/// </list>
/// </para>
/// <para>
/// This is useful for:
/// <list type="bullet">
///   <item>UI display of recent activity</item>
///   <item>Logging and debugging</item>
///   <item>Progress monitoring dashboards</item>
/// </list>
/// </para>
/// </remarks>
public sealed class IndexingEventAggregator
{
    private readonly ConcurrentQueue<IndexingEvent> _events = new();
    private readonly int _maxEvents;

    /// <summary>
    /// Gets the number of events currently buffered.
    /// </summary>
    public int EventCount => _events.Count;

    /// <summary>
    /// Initializes a new instance of the <see cref="IndexingEventAggregator"/> class.
    /// </summary>
    /// <param name="maxEvents">Maximum events to retain.</param>
    public IndexingEventAggregator(int maxEvents = 1000)
    {
        _maxEvents = maxEvents;
    }

    /// <summary>
    /// Add a generic event.
    /// </summary>
    /// <param name="type">Type of event.</param>
    /// <param name="message">Human-readable message.</param>
    /// <param name="data">Optional associated data.</param>
    public void AddEvent(IndexingEventType type, string message, object? data = null)
    {
        var evt = new IndexingEvent
        {
            Type = type,
            Message = message,
            Data = data,
            Timestamp = DateTime.UtcNow
        };

        _events.Enqueue(evt);

        // Trim old events if over capacity
        while (_events.Count > _maxEvents)
        {
            _events.TryDequeue(out _);
        }
    }

    /// <summary>
    /// Record that file processing has started.
    /// </summary>
    public void FileStarted(string filePath)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(filePath);
        AddEvent(IndexingEventType.FileStarted, $"Processing: {filePath}", filePath);
    }

    /// <summary>
    /// Record that file processing completed successfully.
    /// </summary>
    public void FileCompleted(string filePath, int chunkCount)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(filePath);
        AddEvent(
            IndexingEventType.FileCompleted,
            $"Completed: {filePath} ({chunkCount} chunks)",
            new { FilePath = filePath, ChunkCount = chunkCount });
    }

    /// <summary>
    /// Record that file processing was skipped.
    /// </summary>
    public void FileSkipped(string filePath, string reason)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(filePath);
        AddEvent(
            IndexingEventType.FileSkipped,
            $"Skipped: {filePath} - {reason}",
            new { FilePath = filePath, Reason = reason });
    }

    /// <summary>
    /// Record that file processing failed.
    /// </summary>
    public void FileFailed(string filePath, string error)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(filePath);
        AddEvent(
            IndexingEventType.FileFailed,
            $"Failed: {filePath} - {error}",
            new { FilePath = filePath, Error = error });
    }

    /// <summary>
    /// Record a phase change.
    /// </summary>
    public void PhaseChanged(IndexingPhase phase)
    {
        AddEvent(IndexingEventType.PhaseChanged, $"Phase: {phase}", phase);
    }

    /// <summary>
    /// Record a progress update.
    /// </summary>
    public void ProgressUpdate(IndexingProgress progress)
    {
        ArgumentNullException.ThrowIfNull(progress);
        AddEvent(
            IndexingEventType.ProgressUpdate,
            $"Progress: {progress.PercentComplete:F1}%",
            progress);
    }

    /// <summary>
    /// Add an info event.
    /// </summary>
    public void Info(string message, object? data = null)
    {
        AddEvent(IndexingEventType.Info, message, data);
    }

    /// <summary>
    /// Add a warning event.
    /// </summary>
    public void Warning(string message, object? data = null)
    {
        AddEvent(IndexingEventType.Warning, message, data);
    }

    /// <summary>
    /// Add an error event.
    /// </summary>
    public void Error(string message, Exception? ex = null)
    {
        AddEvent(IndexingEventType.Error, message, ex?.ToString());
    }

    /// <summary>
    /// Get most recent events.
    /// </summary>
    /// <param name="count">Maximum events to return.</param>
    /// <returns>Events in chronological order (oldest first).</returns>
    public IReadOnlyList<IndexingEvent> GetRecentEvents(int count = 50)
    {
        return _events.Reverse().Take(count).Reverse().ToList();
    }

    /// <summary>
    /// Get events since a given timestamp.
    /// </summary>
    /// <param name="since">Minimum timestamp (exclusive).</param>
    /// <returns>Events after the timestamp.</returns>
    public IReadOnlyList<IndexingEvent> GetEventsSince(DateTime since)
    {
        return _events.Where(e => e.Timestamp > since).ToList();
    }

    /// <summary>
    /// Get events of a specific type.
    /// </summary>
    /// <param name="type">Event type to filter by.</param>
    /// <returns>Events of the specified type.</returns>
    public IReadOnlyList<IndexingEvent> GetEventsByType(IndexingEventType type)
    {
        return _events.Where(e => e.Type == type).ToList();
    }

    /// <summary>
    /// Get all error events.
    /// </summary>
    public IReadOnlyList<IndexingEvent> GetErrors()
    {
        return GetEventsByType(IndexingEventType.Error)
            .Concat(GetEventsByType(IndexingEventType.FileFailed))
            .OrderBy(e => e.Timestamp)
            .ToList();
    }

    /// <summary>
    /// Clear all events.
    /// </summary>
    public void Clear()
    {
        while (_events.TryDequeue(out _)) { }
    }
}
```

### 3. IndexingMetrics.cs

**Location**: `src/SeniorIntern.Services/Indexing/IndexingMetrics.cs`

```csharp
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Threading;

namespace SeniorIntern.Services.Indexing;

/// <summary>
/// Collects metrics about indexing performance.
/// </summary>
/// <remarks>
/// <para>
/// Metrics are collected per-file and aggregated by language.
/// Thread-safe for concurrent recording from multiple sources.
/// </para>
/// <para>
/// Provides insights into:
/// <list type="bullet">
///   <item>Processing throughput (files/chunks/bytes per second)</item>
///   <item>Average file characteristics</item>
///   <item>Time spent on embedding generation</item>
///   <item>Language-specific statistics</item>
/// </list>
/// </para>
/// </remarks>
public sealed class IndexingMetrics
{
    private readonly ConcurrentDictionary<string, LanguageMetrics> _byLanguage = new();
    private readonly ConcurrentBag<FileMetrics> _fileMetrics = new();

    private long _totalFilesProcessed;
    private long _totalChunksCreated;
    private long _totalBytesProcessed;
    private long _totalEmbeddingTimeMs;
    private long _totalProcessingTimeMs;

    /// <summary>
    /// Gets the total number of files processed.
    /// </summary>
    public long TotalFilesProcessed => _totalFilesProcessed;

    /// <summary>
    /// Gets the total number of chunks created.
    /// </summary>
    public long TotalChunksCreated => _totalChunksCreated;

    /// <summary>
    /// Record metrics for a processed file.
    /// </summary>
    /// <param name="metrics">File metrics to record.</param>
    public void RecordFile(FileMetrics metrics)
    {
        ArgumentNullException.ThrowIfNull(metrics);

        _fileMetrics.Add(metrics);

        Interlocked.Increment(ref _totalFilesProcessed);
        Interlocked.Add(ref _totalChunksCreated, metrics.ChunkCount);
        Interlocked.Add(ref _totalBytesProcessed, metrics.FileSize);
        Interlocked.Add(ref _totalEmbeddingTimeMs, metrics.EmbeddingTimeMs);
        Interlocked.Add(ref _totalProcessingTimeMs, metrics.TotalTimeMs);

        // Aggregate by language
        if (!string.IsNullOrEmpty(metrics.Language))
        {
            var langMetrics = _byLanguage.GetOrAdd(metrics.Language, _ => new LanguageMetrics());
            langMetrics.Add(metrics);
        }
    }

    /// <summary>
    /// Get aggregated metrics summary.
    /// </summary>
    public IndexingMetricsSummary GetSummary()
    {
        return new IndexingMetricsSummary
        {
            TotalFilesProcessed = _totalFilesProcessed,
            TotalChunksCreated = _totalChunksCreated,
            TotalBytesProcessed = _totalBytesProcessed,
            TotalEmbeddingTimeMs = _totalEmbeddingTimeMs,
            TotalProcessingTimeMs = _totalProcessingTimeMs,

            // Averages
            AverageChunksPerFile = _totalFilesProcessed > 0
                ? (double)_totalChunksCreated / _totalFilesProcessed
                : 0,
            AverageFileSizeBytes = _totalFilesProcessed > 0
                ? (double)_totalBytesProcessed / _totalFilesProcessed
                : 0,
            AverageEmbeddingTimeMs = _totalFilesProcessed > 0
                ? (double)_totalEmbeddingTimeMs / _totalFilesProcessed
                : 0,
            AverageProcessingTimeMs = _totalFilesProcessed > 0
                ? (double)_totalProcessingTimeMs / _totalFilesProcessed
                : 0,

            // Throughput rates
            FilesPerSecond = _totalProcessingTimeMs > 0
                ? _totalFilesProcessed / (_totalProcessingTimeMs / 1000.0)
                : 0,
            ChunksPerSecond = _totalProcessingTimeMs > 0
                ? _totalChunksCreated / (_totalProcessingTimeMs / 1000.0)
                : 0,
            BytesPerSecond = _totalProcessingTimeMs > 0
                ? _totalBytesProcessed / (_totalProcessingTimeMs / 1000.0)
                : 0,

            // By language
            ByLanguage = _byLanguage.ToDictionary(
                kv => kv.Key,
                kv => kv.Value.GetSummary())
        };
    }

    /// <summary>
    /// Get the top N languages by file count.
    /// </summary>
    public IReadOnlyList<(string Language, long FileCount)> GetTopLanguages(int count = 10)
    {
        return _byLanguage
            .Select(kv => (kv.Key, kv.Value.FileCount))
            .OrderByDescending(x => x.Item2)
            .Take(count)
            .ToList();
    }

    /// <summary>
    /// Get the largest files processed.
    /// </summary>
    public IReadOnlyList<FileMetrics> GetLargestFiles(int count = 10)
    {
        return _fileMetrics
            .OrderByDescending(f => f.FileSize)
            .Take(count)
            .ToList();
    }

    /// <summary>
    /// Get the slowest files to process.
    /// </summary>
    public IReadOnlyList<FileMetrics> GetSlowestFiles(int count = 10)
    {
        return _fileMetrics
            .OrderByDescending(f => f.TotalTimeMs)
            .Take(count)
            .ToList();
    }

    /// <summary>
    /// Reset all metrics.
    /// </summary>
    public void Reset()
    {
        _byLanguage.Clear();
        while (_fileMetrics.TryTake(out _)) { }
        _totalFilesProcessed = 0;
        _totalChunksCreated = 0;
        _totalBytesProcessed = 0;
        _totalEmbeddingTimeMs = 0;
        _totalProcessingTimeMs = 0;
    }
}

/// <summary>
/// Aggregated metrics by language.
/// </summary>
public sealed class LanguageMetrics
{
    private long _fileCount;
    private long _totalChunks;
    private long _totalBytes;
    private long _totalTimeMs;

    /// <summary>
    /// Gets the file count for this language.
    /// </summary>
    public long FileCount => _fileCount;

    /// <summary>
    /// Add metrics for a file.
    /// </summary>
    public void Add(FileMetrics metrics)
    {
        Interlocked.Increment(ref _fileCount);
        Interlocked.Add(ref _totalChunks, metrics.ChunkCount);
        Interlocked.Add(ref _totalBytes, metrics.FileSize);
        Interlocked.Add(ref _totalTimeMs, metrics.TotalTimeMs);
    }

    /// <summary>
    /// Get summary for this language.
    /// </summary>
    public LanguageMetricsSummary GetSummary()
    {
        return new LanguageMetricsSummary
        {
            FileCount = _fileCount,
            TotalChunks = _totalChunks,
            TotalBytes = _totalBytes,
            AverageChunksPerFile = _fileCount > 0 ? (double)_totalChunks / _fileCount : 0,
            AverageFileSize = _fileCount > 0 ? (double)_totalBytes / _fileCount : 0
        };
    }
}
```

### 4. ProgressModels.cs

**Location**: `src/SeniorIntern.Services/Indexing/ProgressModels.cs`

```csharp
using System;
using System.Collections.Generic;

namespace SeniorIntern.Services.Indexing;

/// <summary>
/// An indexing event for logging and display.
/// </summary>
public sealed class IndexingEvent
{
    /// <summary>Type of event.</summary>
    public required IndexingEventType Type { get; init; }

    /// <summary>Human-readable message.</summary>
    public required string Message { get; init; }

    /// <summary>Optional associated data (file path, progress, error, etc.).</summary>
    public object? Data { get; init; }

    /// <summary>When the event occurred.</summary>
    public DateTime Timestamp { get; init; } = DateTime.UtcNow;
}

/// <summary>
/// Types of indexing events.
/// </summary>
public enum IndexingEventType
{
    /// <summary>File processing started.</summary>
    FileStarted,

    /// <summary>File processing completed successfully.</summary>
    FileCompleted,

    /// <summary>File processing failed with error.</summary>
    FileFailed,

    /// <summary>File was skipped (filtered, already indexed, etc.).</summary>
    FileSkipped,

    /// <summary>Indexing phase changed.</summary>
    PhaseChanged,

    /// <summary>Progress update.</summary>
    ProgressUpdate,

    /// <summary>Warning (non-fatal issue).</summary>
    Warning,

    /// <summary>Error (may or may not be fatal).</summary>
    Error,

    /// <summary>Informational message.</summary>
    Info
}

/// <summary>
/// Metrics for a single processed file.
/// </summary>
public sealed class FileMetrics
{
    /// <summary>Relative path of the file.</summary>
    public required string FilePath { get; init; }

    /// <summary>Detected programming language.</summary>
    public string? Language { get; init; }

    /// <summary>File size in bytes.</summary>
    public long FileSize { get; init; }

    /// <summary>Number of lines in the file.</summary>
    public int LineCount { get; init; }

    /// <summary>Number of chunks created.</summary>
    public int ChunkCount { get; init; }

    /// <summary>Time spent generating embeddings (ms).</summary>
    public int EmbeddingTimeMs { get; init; }

    /// <summary>Total processing time (ms).</summary>
    public int TotalTimeMs { get; init; }

    /// <summary>Time spent reading the file (ms).</summary>
    public int ReadTimeMs { get; init; }

    /// <summary>Time spent chunking (ms).</summary>
    public int ChunkingTimeMs { get; init; }
}

/// <summary>
/// Summary of indexing metrics.
/// </summary>
public sealed class IndexingMetricsSummary
{
    // Totals
    /// <summary>Total files processed.</summary>
    public long TotalFilesProcessed { get; init; }

    /// <summary>Total chunks created.</summary>
    public long TotalChunksCreated { get; init; }

    /// <summary>Total bytes processed.</summary>
    public long TotalBytesProcessed { get; init; }

    /// <summary>Total time spent on embeddings (ms).</summary>
    public long TotalEmbeddingTimeMs { get; init; }

    /// <summary>Total processing time (ms).</summary>
    public long TotalProcessingTimeMs { get; init; }

    // Averages
    /// <summary>Average chunks per file.</summary>
    public double AverageChunksPerFile { get; init; }

    /// <summary>Average file size in bytes.</summary>
    public double AverageFileSizeBytes { get; init; }

    /// <summary>Average embedding time per file (ms).</summary>
    public double AverageEmbeddingTimeMs { get; init; }

    /// <summary>Average total processing time per file (ms).</summary>
    public double AverageProcessingTimeMs { get; init; }

    // Throughput rates
    /// <summary>Files processed per second.</summary>
    public double FilesPerSecond { get; init; }

    /// <summary>Chunks created per second.</summary>
    public double ChunksPerSecond { get; init; }

    /// <summary>Bytes processed per second.</summary>
    public double BytesPerSecond { get; init; }

    // By language
    /// <summary>Metrics broken down by language.</summary>
    public IReadOnlyDictionary<string, LanguageMetricsSummary> ByLanguage { get; init; } =
        new Dictionary<string, LanguageMetricsSummary>();
}

/// <summary>
/// Summary for a single language.
/// </summary>
public sealed class LanguageMetricsSummary
{
    /// <summary>Number of files of this language.</summary>
    public long FileCount { get; init; }

    /// <summary>Total chunks from this language.</summary>
    public long TotalChunks { get; init; }

    /// <summary>Total bytes from this language.</summary>
    public long TotalBytes { get; init; }

    /// <summary>Average chunks per file for this language.</summary>
    public double AverageChunksPerFile { get; init; }

    /// <summary>Average file size for this language.</summary>
    public double AverageFileSize { get; init; }
}
```

---

## Integration Example

```csharp
// In IndexingService.IndexWorkspaceAsync()

public async Task<IndexingResult> IndexWorkspaceAsync(
    string workspacePath,
    IndexingOptions options,
    IProgress<IndexingProgress>? progress = null,
    CancellationToken ct = default)
{
    var files = await _fileScanner.ScanAsync(workspacePath, ...);
    var totalBytes = files.Sum(f => f.FileSize);

    // Initialize tracking
    var tracker = new ProgressTracker(files.Count, totalBytes);
    var events = new IndexingEventAggregator();
    var metrics = new IndexingMetrics();

    tracker.Start();
    tracker.SetPhase(IndexingPhase.Processing);
    events.PhaseChanged(IndexingPhase.Processing);

    foreach (var file in files)
    {
        ct.ThrowIfCancellationRequested();

        tracker.SetCurrentFile(file.RelativePath);
        events.FileStarted(file.RelativePath);

        var sw = Stopwatch.StartNew();
        try
        {
            var result = await ProcessFileAsync(file, ...);

            tracker.FileProcessed(result.ChunkCount, file.FileSize);
            events.FileCompleted(file.RelativePath, result.ChunkCount);

            metrics.RecordFile(new FileMetrics
            {
                FilePath = file.RelativePath,
                Language = result.Language,
                FileSize = file.FileSize,
                ChunkCount = result.ChunkCount,
                EmbeddingTimeMs = result.EmbeddingTimeMs,
                TotalTimeMs = (int)sw.ElapsedMilliseconds
            });
        }
        catch (Exception ex)
        {
            tracker.FileFailed();
            events.FileFailed(file.RelativePath, ex.Message);
        }

        // Report progress periodically
        if (tracker.ProcessedFiles % 10 == 0)
        {
            progress?.Report(tracker.GetProgress());
            events.ProgressUpdate(tracker.GetProgress());
        }
    }

    tracker.SetPhase(IndexingPhase.Complete);
    events.PhaseChanged(IndexingPhase.Complete);

    var summary = metrics.GetSummary();
    _logger.LogInformation(
        "Indexing complete: {FilesPerSec:F1} files/sec, {ChunksPerSec:F1} chunks/sec",
        summary.FilesPerSecond, summary.ChunksPerSecond);

    return tracker.GetResult(indexId, success: true);
}
```

---

## Unit Testing Requirements

| Class | Test Count | Focus Areas |
|-------|------------|-------------|
| `ProgressTracker` | 15-20 | Progress calculation, time estimates, rates |
| `IndexingEventAggregator` | 15-18 | Event buffering, trimming, retrieval |
| `IndexingMetrics` | 12-15 | Recording, aggregation, language breakdown |
| Models | 8-10 | Properties, computed values |

**Total: ~50-63 tests**

### Test Scenarios

**ProgressTracker**:
- Start/Stop timer works correctly
- FileProcessed increments counters
- FileSkipped and FileFailed track separately
- GetProgress calculates percentage correctly
- Estimated remaining time is reasonable
- Processing rates are calculated
- GetResult returns correct final values

**IndexingEventAggregator**:
- AddEvent adds to queue
- Max events limit is enforced
- GetRecentEvents returns in chronological order
- GetEventsSince filters by timestamp
- GetEventsByType filters correctly
- Convenience methods create correct events
- Clear empties the queue

**IndexingMetrics**:
- RecordFile updates totals
- Language metrics are aggregated separately
- GetSummary calculates averages correctly
- GetTopLanguages returns sorted list
- Thread-safe concurrent recording
- Reset clears all data

---

## Acceptance Criteria

### Functional Requirements
- [ ] `ProgressTracker` accurately tracks file counts and timing
- [ ] Progress percentage calculated correctly
- [ ] Estimated time remaining is reasonable
- [ ] Processing rates (files/sec, chunks/sec) are accurate
- [ ] Events are buffered and retrievable
- [ ] Old events are trimmed when limit exceeded
- [ ] Metrics are aggregated by language
- [ ] `GetResult` produces correct `IndexingResult`

### Quality Requirements
- [ ] Thread-safe for concurrent access
- [ ] Minimal overhead during indexing
- [ ] Clear separation of tracking, events, and metrics
- [ ] All public members have XML documentation

---

## Future Considerations

Items explicitly deferred to later sub-versions:
- **v0.7.3j**: Comprehensive unit tests for all components
- **v0.7.4**: UI integration for progress display
