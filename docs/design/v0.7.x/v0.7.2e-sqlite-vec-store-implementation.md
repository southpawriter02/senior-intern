# Design Specification: AIntern v0.7.2e "SQLite-vec Store Implementation"

## Overview

**Version**: v0.7.2e
**Parent**: v0.7.2 Vector Storage
**Focus**: Implement the main `SqliteVectorStore` class that provides the `IVectorStore` interface using SQLite-vec

### Purpose

Implement the core vector store service:
1. Create `VectorStoreOptions` configuration class
2. Implement `SqliteVectorStore` main class with initialization and disposal
3. Implement index management methods (Create, Get, List, Update, Delete)
4. Handle SQLite connection management, extension loading, and configuration
5. Provide thread-safe operations with proper locking

### Dependencies

**From v0.7.2a (Vector Store Interface)**:
- `IVectorStore` interface to implement
- `VectorStoreStateChangedEventArgs` for events

**From v0.7.2b (Vector Index Models)**:
- `VectorIndex` model for CRUD operations
- `VectorIndexSettings` for configuration

**From v0.7.2d (Database Schema)**:
- `VectorStoreSchema` for table definitions
- `VectorStoreMigrations` for schema management

**External Dependencies**:
- `Microsoft.Data.Sqlite` - SQLite database access
- `sqlite-vec` extension - Vector similarity operations
- `Microsoft.Extensions.Options` - Configuration binding
- `Microsoft.Extensions.Logging` - Logging infrastructure

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                      v0.7.2e SQLite-vec Store Implementation                  │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Class Structure:                                                            │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  SqliteVectorStore : IVectorStore, IAsyncDisposable (partial class)     │ │
│  │  ├── SqliteVectorStore.cs                    ← Main class, init/dispose │ │
│  │  ├── SqliteVectorStore.IndexManagement.cs    ← Index CRUD               │ │
│  │  ├── SqliteVectorStore.ChunkOperations.cs    ← Chunk CRUD (v0.7.2f)     │ │
│  │  ├── SqliteVectorStore.Search.cs             ← Vector search (v0.7.2g)  │ │
│  │  └── SqliteVectorStore.FileTracking.cs       ← File tracking (v0.7.2h)  │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  Component Interaction:                                                      │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  Consumer                                                                 │ │
│  │       │                                                                   │ │
│  │       ▼                                                                   │ │
│  │  SqliteVectorStore                                                        │ │
│  │       │                                                                   │ │
│  │       ├──▶ VectorStoreOptions (configuration)                            │ │
│  │       │                                                                   │ │
│  │       ├──▶ SqliteConnection (database access)                            │ │
│  │       │         │                                                         │ │
│  │       │         └──▶ sqlite-vec extension (vector operations)            │ │
│  │       │                                                                   │ │
│  │       ├──▶ VectorStoreMigrations (schema management)                     │ │
│  │       │                                                                   │ │
│  │       ├──▶ _initLock (SemaphoreSlim for init)                           │ │
│  │       │                                                                   │ │
│  │       └──▶ _writeLock (SemaphoreSlim for writes)                        │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Initialization Flow

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                        Initialization Sequence                                │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  InitializeAsync()                                                           │
│       │                                                                      │
│       ▼                                                                      │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  1. Check if already initialized → return early                          │ │
│  │                                                                          │ │
│  │  2. Acquire _initLock                                                    │ │
│  │       │                                                                   │ │
│  │       ▼                                                                   │ │
│  │  3. Determine database path                                               │ │
│  │     ├── Use configured path if set                                       │ │
│  │     └── Otherwise: {AppData}/SeniorIntern/vectors.db                     │ │
│  │       │                                                                   │ │
│  │       ▼                                                                   │ │
│  │  4. Create directory if needed                                            │ │
│  │       │                                                                   │ │
│  │       ▼                                                                   │ │
│  │  5. Create connection string                                              │ │
│  │     • DataSource = {path}                                                 │ │
│  │     • Mode = ReadWriteCreate                                              │ │
│  │     • Cache = Shared                                                      │ │
│  │     • DefaultTimeout = {configured}                                       │ │
│  │       │                                                                   │ │
│  │       ▼                                                                   │ │
│  │  6. Open SqliteConnection                                                 │ │
│  │       │                                                                   │ │
│  │       ▼                                                                   │ │
│  │  7. Configure SQLite (PRAGMAs)                                           │ │
│  │     • journal_mode = WAL                                                  │ │
│  │     • cache_size = -{kb}                                                  │ │
│  │     • synchronous = NORMAL                                                │ │
│  │     • temp_store = MEMORY                                                 │ │
│  │     • mmap_size = 268435456                                               │ │
│  │     • foreign_keys = ON                                                   │ │
│  │       │                                                                   │ │
│  │       ▼                                                                   │ │
│  │  8. Load sqlite-vec extension                                             │ │
│  │     ├── Find extension path                                              │ │
│  │     │   ├── Configured path                                               │ │
│  │     │   ├── App base directory                                            │ │
│  │     │   ├── runtimes/{rid}/native                                        │ │
│  │     │   └── System paths (/usr/local/lib, etc.)                          │ │
│  │     │                                                                     │ │
│  │     └── load_extension(path, 'sqlite3_vec_init')                         │ │
│  │       │                                                                   │ │
│  │       ▼                                                                   │ │
│  │  9. Create/migrate schema                                                 │ │
│  │     ├── Check current version                                            │ │
│  │     ├── Version 0 → CreateSchemaAsync()                                  │ │
│  │     └── Version < Current → MigrateAsync()                               │ │
│  │       │                                                                   │ │
│  │       ▼                                                                   │ │
│  │  10. Set _isInitialized = true                                           │ │
│  │       │                                                                   │ │
│  │       ▼                                                                   │ │
│  │  11. Raise StateChanged event (IsInitialized=true)                       │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  Error Handling:                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  On any exception:                                                        │ │
│  │  • Log error                                                              │ │
│  │  • Raise StateChanged event (IsInitialized=false, Error=message)         │ │
│  │  • Re-throw exception                                                     │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Extension Loading

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                     sqlite-vec Extension Loading                              │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Platform-specific Extension Names:                                          │
│  ┌─────────────────┬───────────────┐                                         │
│  │ Platform        │ Extension     │                                         │
│  │ ────────────────│───────────────│                                         │
│  │ Windows         │ vec0.dll      │                                         │
│  │ macOS           │ vec0.dylib    │                                         │
│  │ Linux           │ vec0.so       │                                         │
│  └─────────────────┴───────────────┘                                         │
│                                                                              │
│  Search Order:                                                                │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  1. Configured ExtensionPath (if set)                                    │ │
│  │       │                                                                   │ │
│  │       ▼ (if not found)                                                    │ │
│  │  2. App base directory                                                    │ │
│  │     {AppDomain.CurrentDomain.BaseDirectory}/vec0.{ext}                    │ │
│  │       │                                                                   │ │
│  │       ▼ (if not found)                                                    │ │
│  │  3. Runtime native directory                                              │ │
│  │     {BaseDir}/runtimes/{rid}/native/vec0.{ext}                           │ │
│  │     RID examples: win-x64, osx-arm64, linux-x64                          │ │
│  │       │                                                                   │ │
│  │       ▼ (if not found)                                                    │ │
│  │  4. Current directory                                                     │ │
│  │     {Environment.CurrentDirectory}/vec0.{ext}                             │ │
│  │       │                                                                   │ │
│  │       ▼ (if not found)                                                    │ │
│  │  5. System paths (Linux/macOS only)                                       │ │
│  │     /usr/local/lib/vec0.{ext}                                            │ │
│  │     /usr/lib/vec0.{ext}                                                  │ │
│  │       │                                                                   │ │
│  │       ▼ (if not found)                                                    │ │
│  │  6. Throw InvalidOperationException                                       │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  Loading SQL:                                                                 │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  SELECT load_extension(@path, 'sqlite3_vec_init')                        │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Specifications

### 1. VectorStoreOptions.cs

**Location**: `src/SeniorIntern.Core/Options/VectorStoreOptions.cs`

```csharp
namespace SeniorIntern.Core.Options;

/// <summary>
/// Configuration options for the vector store.
/// </summary>
/// <remarks>
/// <para>
/// Bind to the "VectorStore" section in configuration:
/// </para>
/// <code>
/// {
///   "VectorStore": {
///     "DatabasePath": "/path/to/vectors.db",
///     "ExtensionPath": "/path/to/vec0.dylib",
///     "ConnectionPoolSize": 4
///   }
/// }
/// </code>
/// </remarks>
public sealed class VectorStoreOptions
{
    /// <summary>
    /// Configuration section name.
    /// </summary>
    public const string SectionName = "VectorStore";

    #region Database

    /// <summary>
    /// Path to the SQLite database file.
    /// </summary>
    /// <remarks>
    /// If not specified, uses default location: {AppData}/SeniorIntern/vectors.db
    /// </remarks>
    public string? DatabasePath { get; set; }

    /// <summary>
    /// Path to the sqlite-vec extension library.
    /// </summary>
    /// <remarks>
    /// If not specified, attempts to load from default locations:
    /// 1. App base directory
    /// 2. runtimes/{rid}/native directory
    /// 3. System library paths
    /// </remarks>
    public string? ExtensionPath { get; set; }

    #endregion

    #region Connection

    /// <summary>
    /// Connection pool size for concurrent operations.
    /// </summary>
    /// <remarks>
    /// Currently unused, reserved for future connection pooling.
    /// </remarks>
    public int ConnectionPoolSize { get; set; } = 4;

    /// <summary>
    /// Default timeout for database operations in seconds.
    /// </summary>
    public int DefaultTimeoutSeconds { get; set; } = 30;

    #endregion

    #region Performance

    /// <summary>
    /// Whether to enable WAL mode for better concurrent performance.
    /// </summary>
    /// <remarks>
    /// WAL (Write-Ahead Logging) allows concurrent reads during writes.
    /// Recommended: true (default).
    /// </remarks>
    public bool EnableWalMode { get; set; } = true;

    /// <summary>
    /// SQLite cache size in kilobytes.
    /// </summary>
    /// <remarks>
    /// Larger cache improves performance for repeated queries.
    /// Default: 10240 KB (10 MB).
    /// </remarks>
    public int CacheSizeKb { get; set; } = 10240;

    /// <summary>
    /// Whether to run VACUUM on startup.
    /// </summary>
    /// <remarks>
    /// VACUUM rebuilds the database file, reducing size but is slow.
    /// Enable periodically, not on every startup.
    /// Default: false.
    /// </remarks>
    public bool VacuumOnStartup { get; set; } = false;

    /// <summary>
    /// Batch size for bulk insert operations.
    /// </summary>
    /// <remarks>
    /// Larger batches are faster but use more memory.
    /// Default: 100.
    /// </remarks>
    public int BulkInsertBatchSize { get; set; } = 100;

    #endregion

    #region Validation

    /// <summary>
    /// Validates the options.
    /// </summary>
    public void Validate()
    {
        if (DefaultTimeoutSeconds <= 0)
            throw new ArgumentException("DefaultTimeoutSeconds must be positive");

        if (CacheSizeKb < 0)
            throw new ArgumentException("CacheSizeKb must be non-negative");

        if (BulkInsertBatchSize <= 0)
            throw new ArgumentException("BulkInsertBatchSize must be positive");
    }

    #endregion
}
```

### 2. SqliteVectorStore.cs (Main File)

**Location**: `src/SeniorIntern.Services/VectorStore/SqliteVectorStore.cs`

```csharp
namespace SeniorIntern.Services.VectorStore;

using System;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Data.Sqlite;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Core.Options;

/// <summary>
/// Vector store implementation using SQLite with sqlite-vec extension.
/// </summary>
/// <remarks>
/// <para>
/// This is the main implementation of <see cref="IVectorStore"/> using SQLite
/// with the sqlite-vec extension for vector similarity operations.
/// </para>
/// <para>
/// The class is split across multiple partial files for organization:
/// <list type="bullet">
///   <item><c>SqliteVectorStore.cs</c> - Initialization, connection management</item>
///   <item><c>SqliteVectorStore.IndexManagement.cs</c> - Index CRUD</item>
///   <item><c>SqliteVectorStore.ChunkOperations.cs</c> - Chunk CRUD</item>
///   <item><c>SqliteVectorStore.Search.cs</c> - Vector search</item>
///   <item><c>SqliteVectorStore.FileTracking.cs</c> - File tracking</item>
/// </list>
/// </para>
/// <para>
/// Thread safety:
/// <list type="bullet">
///   <item>Read operations are concurrent</item>
///   <item>Write operations are serialized via _writeLock</item>
///   <item>Initialization is protected by _initLock</item>
/// </list>
/// </para>
/// </remarks>
public sealed partial class SqliteVectorStore : IVectorStore, IAsyncDisposable
{
    #region Fields

    private readonly VectorStoreOptions _options;
    private readonly ILogger<SqliteVectorStore> _logger;
    private readonly ILoggerFactory _loggerFactory;
    private readonly SemaphoreSlim _initLock = new(1, 1);
    private readonly SemaphoreSlim _writeLock = new(1, 1);

    private SqliteConnection? _connection;
    private bool _isInitialized;
    private bool _isDisposed;
    private string? _databasePath;

    #endregion

    #region Properties

    /// <inheritdoc />
    public bool IsInitialized => _isInitialized;

    /// <summary>
    /// Path to the database file (after initialization).
    /// </summary>
    public string? DatabasePath => _databasePath;

    #endregion

    #region Events

    /// <inheritdoc />
    public event EventHandler<VectorStoreStateChangedEventArgs>? StateChanged;

    #endregion

    #region Constructor

    /// <summary>
    /// Initializes a new instance of the SqliteVectorStore.
    /// </summary>
    /// <param name="options">Configuration options.</param>
    /// <param name="logger">Logger instance.</param>
    /// <param name="loggerFactory">Logger factory for child loggers.</param>
    public SqliteVectorStore(
        IOptions<VectorStoreOptions> options,
        ILogger<SqliteVectorStore> logger,
        ILoggerFactory loggerFactory)
    {
        _options = options?.Value ?? throw new ArgumentNullException(nameof(options));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _loggerFactory = loggerFactory ?? throw new ArgumentNullException(nameof(loggerFactory));
    }

    #endregion

    #region Initialization

    /// <inheritdoc />
    public async Task InitializeAsync(CancellationToken ct = default)
    {
        if (_isInitialized)
        {
            _logger.LogDebug("Vector store already initialized");
            return;
        }

        await _initLock.WaitAsync(ct);
        try
        {
            // Double-check after acquiring lock
            if (_isInitialized) return;

            _logger.LogInformation("Initializing vector store...");

            // Determine database path
            _databasePath = _options.DatabasePath ?? GetDefaultDatabasePath();
            var directory = Path.GetDirectoryName(_databasePath);
            if (!string.IsNullOrEmpty(directory))
            {
                Directory.CreateDirectory(directory);
            }

            // Create and open connection
            var connectionString = BuildConnectionString(_databasePath);
            _connection = new SqliteConnection(connectionString);
            await _connection.OpenAsync(ct);

            _logger.LogDebug("Database connection opened at {Path}", _databasePath);

            // Configure SQLite settings
            await ConfigureSqliteAsync(ct);

            // Load sqlite-vec extension
            await LoadVecExtensionAsync(ct);

            // Create or migrate schema
            var migrations = new VectorStoreMigrations(
                _connection,
                _loggerFactory.CreateLogger<VectorStoreMigrations>());

            var currentVersion = await migrations.GetCurrentVersionAsync(ct);
            if (currentVersion == 0)
            {
                await migrations.CreateSchemaAsync(ct);
            }
            else
            {
                await migrations.MigrateAsync(ct);
            }

            _isInitialized = true;
            _logger.LogInformation(
                "Vector store initialized successfully at {Path}",
                _databasePath);

            StateChanged?.Invoke(this, VectorStoreStateChangedEventArgs.Initialized(_databasePath));
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to initialize vector store");
            StateChanged?.Invoke(
                this,
                VectorStoreStateChangedEventArgs.ErrorOccurred(ex.Message, _databasePath));
            throw;
        }
        finally
        {
            _initLock.Release();
        }
    }

    private string BuildConnectionString(string dbPath)
    {
        return new SqliteConnectionStringBuilder
        {
            DataSource = dbPath,
            Mode = SqliteOpenMode.ReadWriteCreate,
            Cache = SqliteCacheMode.Shared,
            DefaultTimeout = _options.DefaultTimeoutSeconds
        }.ToString();
    }

    private async Task ConfigureSqliteAsync(CancellationToken ct)
    {
        var pragmas = new[]
        {
            _options.EnableWalMode ? "PRAGMA journal_mode = WAL" : null,
            $"PRAGMA cache_size = -{_options.CacheSizeKb}", // Negative = KB
            "PRAGMA synchronous = NORMAL",
            "PRAGMA temp_store = MEMORY",
            "PRAGMA mmap_size = 268435456", // 256MB memory-mapped I/O
            "PRAGMA foreign_keys = ON",
            "PRAGMA busy_timeout = 5000" // 5 second wait on lock
        };

        foreach (var pragma in pragmas.Where(p => p != null))
        {
            await using var cmd = _connection!.CreateCommand();
            cmd.CommandText = pragma;
            await cmd.ExecuteNonQueryAsync(ct);
            _logger.LogDebug("Applied: {Pragma}", pragma);
        }

        if (_options.VacuumOnStartup)
        {
            _logger.LogInformation("Running VACUUM on startup...");
            await using var cmd = _connection!.CreateCommand();
            cmd.CommandText = "VACUUM";
            await cmd.ExecuteNonQueryAsync(ct);
            _logger.LogInformation("VACUUM complete");
        }
    }

    private async Task LoadVecExtensionAsync(CancellationToken ct)
    {
        var extensionPath = _options.ExtensionPath ?? FindVecExtension();

        if (string.IsNullOrEmpty(extensionPath))
        {
            throw new InvalidOperationException(
                "sqlite-vec extension not found. Please install it or specify ExtensionPath in configuration. " +
                "See: https://github.com/asg017/sqlite-vec");
        }

        _logger.LogDebug("Loading sqlite-vec from {Path}", extensionPath);

        // Enable extension loading
        await using (var cmd = _connection!.CreateCommand())
        {
            cmd.CommandText = "SELECT sqlite3_enable_load_extension(1)";
            try { await cmd.ExecuteNonQueryAsync(ct); } catch { /* May not be available */ }
        }

        // Load the extension
        await using var loadCmd = _connection!.CreateCommand();
        loadCmd.CommandText = "SELECT load_extension(@path, 'sqlite3_vec_init')";
        loadCmd.Parameters.AddWithValue("@path", extensionPath);

        try
        {
            await loadCmd.ExecuteNonQueryAsync(ct);
            _logger.LogInformation("sqlite-vec extension loaded successfully from {Path}", extensionPath);
        }
        catch (SqliteException ex)
        {
            throw new InvalidOperationException(
                $"Failed to load sqlite-vec extension from '{extensionPath}'. Error: {ex.Message}. " +
                "Ensure the extension is compatible with your SQLite version and platform.", ex);
        }
    }

    private static string? FindVecExtension()
    {
        // Platform-specific extension names
        var extensionName = RuntimeInformation.IsOSPlatform(OSPlatform.Windows)
            ? "vec0.dll"
            : RuntimeInformation.IsOSPlatform(OSPlatform.OSX)
                ? "vec0.dylib"
                : "vec0.so";

        // Search paths in order of preference
        var searchPaths = new[]
        {
            AppDomain.CurrentDomain.BaseDirectory,
            Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "runtimes", GetRuntimeIdentifier(), "native"),
            Environment.CurrentDirectory,
            "/usr/local/lib",
            "/usr/lib"
        };

        foreach (var basePath in searchPaths.Where(p => !string.IsNullOrEmpty(p)))
        {
            var fullPath = Path.Combine(basePath, extensionName);
            if (File.Exists(fullPath))
                return fullPath;
        }

        return null;
    }

    private static string GetRuntimeIdentifier()
    {
        var os = RuntimeInformation.IsOSPlatform(OSPlatform.Windows) ? "win"
            : RuntimeInformation.IsOSPlatform(OSPlatform.OSX) ? "osx"
            : "linux";

        var arch = RuntimeInformation.OSArchitecture switch
        {
            Architecture.X64 => "x64",
            Architecture.Arm64 => "arm64",
            Architecture.X86 => "x86",
            _ => "x64"
        };

        return $"{os}-{arch}";
    }

    private static string GetDefaultDatabasePath()
    {
        var appData = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
        return Path.Combine(appData, "SeniorIntern", "vectors.db");
    }

    #endregion

    #region Guard Methods

    /// <summary>
    /// Ensures the store is initialized, throwing if not.
    /// </summary>
    private void EnsureInitialized()
    {
        ObjectDisposedException.ThrowIf(_isDisposed, this);

        if (!_isInitialized)
        {
            throw new InvalidOperationException(
                "Vector store not initialized. Call InitializeAsync first.");
        }
    }

    /// <summary>
    /// Gets the connection, ensuring it's initialized.
    /// </summary>
    private SqliteConnection GetConnection()
    {
        EnsureInitialized();
        return _connection!;
    }

    #endregion

    #region Disposal

    /// <inheritdoc />
    public async ValueTask DisposeAsync()
    {
        if (_isDisposed) return;
        _isDisposed = true;

        _logger.LogInformation("Disposing vector store...");

        if (_connection != null)
        {
            await _connection.CloseAsync();
            await _connection.DisposeAsync();
            _connection = null;
        }

        _initLock.Dispose();
        _writeLock.Dispose();

        StateChanged?.Invoke(this, VectorStoreStateChangedEventArgs.Disposed());

        _logger.LogInformation("Vector store disposed");
    }

    #endregion

    #region Utilities

    /// <summary>
    /// Sanitizes an identifier for use in SQL table names.
    /// </summary>
    /// <param name="input">The raw identifier (e.g., GUID).</param>
    /// <returns>A SQL-safe identifier.</returns>
    private static string SanitizeTableName(string input)
    {
        // Replace hyphens with underscores and keep only alphanumeric + underscores
        return new string(input.Replace("-", "_")
            .Where(c => char.IsLetterOrDigit(c) || c == '_')
            .ToArray())
            .ToLowerInvariant();
    }

    #endregion
}
```

### 3. SqliteVectorStore.IndexManagement.cs

**Location**: `src/SeniorIntern.Services/VectorStore/SqliteVectorStore.IndexManagement.cs`

```csharp
namespace SeniorIntern.Services.VectorStore;

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Data.Sqlite;
using SeniorIntern.Core.Models;

/// <summary>
/// Partial class containing index management operations.
/// </summary>
public sealed partial class SqliteVectorStore
{
    #region Create

    /// <inheritdoc />
    public async Task<VectorIndex> CreateIndexAsync(
        string workspacePath,
        string name,
        int embeddingDimension,
        VectorIndexSettings? settings = null,
        CancellationToken ct = default)
    {
        EnsureInitialized();

        if (string.IsNullOrWhiteSpace(workspacePath))
            throw new ArgumentException("Workspace path is required", nameof(workspacePath));

        if (string.IsNullOrWhiteSpace(name))
            throw new ArgumentException("Name is required", nameof(name));

        if (embeddingDimension <= 0)
            throw new ArgumentException("Embedding dimension must be positive", nameof(embeddingDimension));

        var indexId = Guid.NewGuid().ToString();
        var sanitizedId = SanitizeTableName(indexId);
        settings ??= new VectorIndexSettings();

        _logger.LogInformation(
            "Creating index '{Name}' for workspace {Path} with dimension {Dimension}",
            name, workspacePath, embeddingDimension);

        await _writeLock.WaitAsync(ct);
        try
        {
            await using var transaction = await _connection!.BeginTransactionAsync(ct);
            try
            {
                // Check for existing index
                await using (var checkCmd = _connection.CreateCommand())
                {
                    checkCmd.Transaction = (SqliteTransaction)transaction;
                    checkCmd.CommandText = "SELECT COUNT(*) FROM vector_indexes WHERE workspace_path = @path AND status != 'Deleted'";
                    checkCmd.Parameters.AddWithValue("@path", workspacePath);
                    var count = Convert.ToInt32(await checkCmd.ExecuteScalarAsync(ct));
                    if (count > 0)
                    {
                        throw new InvalidOperationException(
                            $"An index already exists for workspace: {workspacePath}");
                    }
                }

                // Create the vector virtual table for this index
                var createVectorTable = VectorStoreSchema.CreateVectorTableTemplate
                    .Replace("{index_id}", sanitizedId)
                    .Replace("{dimension}", embeddingDimension.ToString());

                await using (var cmd = _connection.CreateCommand())
                {
                    cmd.Transaction = (SqliteTransaction)transaction;
                    cmd.CommandText = createVectorTable;
                    await cmd.ExecuteNonQueryAsync(ct);
                }

                _logger.LogDebug("Created vector table: vectors_{SanitizedId}", sanitizedId);

                // Insert index metadata
                await using (var cmd = _connection.CreateCommand())
                {
                    cmd.Transaction = (SqliteTransaction)transaction;
                    cmd.CommandText = """
                        INSERT INTO vector_indexes (
                            id, name, workspace_path, embedding_model,
                            embedding_dimension, settings_json, status
                        ) VALUES (
                            @id, @name, @workspace, @model, @dimension, @settings, @status
                        )
                        """;

                    cmd.Parameters.AddWithValue("@id", indexId);
                    cmd.Parameters.AddWithValue("@name", name);
                    cmd.Parameters.AddWithValue("@workspace", workspacePath);
                    cmd.Parameters.AddWithValue("@model", "default");
                    cmd.Parameters.AddWithValue("@dimension", embeddingDimension);
                    cmd.Parameters.AddWithValue("@settings", JsonSerializer.Serialize(settings));
                    cmd.Parameters.AddWithValue("@status", IndexStatus.Active.ToString());

                    await cmd.ExecuteNonQueryAsync(ct);
                }

                await transaction.CommitAsync(ct);

                _logger.LogInformation("Created index {IndexId} for {Workspace}", indexId, workspacePath);

                return new VectorIndex
                {
                    Id = indexId,
                    Name = name,
                    WorkspacePath = workspacePath,
                    EmbeddingModel = "default",
                    EmbeddingDimension = embeddingDimension,
                    Settings = settings,
                    Status = IndexStatus.Active
                };
            }
            catch
            {
                await transaction.RollbackAsync(ct);
                throw;
            }
        }
        finally
        {
            _writeLock.Release();
        }
    }

    #endregion

    #region Read

    /// <inheritdoc />
    public async Task<VectorIndex?> GetIndexAsync(string indexId, CancellationToken ct = default)
    {
        EnsureInitialized();

        await using var cmd = _connection!.CreateCommand();
        cmd.CommandText = GetIndexSelectQuery() + " WHERE id = @id";
        cmd.Parameters.AddWithValue("@id", indexId);

        await using var reader = await cmd.ExecuteReaderAsync(ct);
        if (!await reader.ReadAsync(ct))
            return null;

        return ReadIndexFromReader(reader);
    }

    /// <inheritdoc />
    public async Task<VectorIndex?> GetIndexForWorkspaceAsync(
        string workspacePath,
        CancellationToken ct = default)
    {
        EnsureInitialized();

        await using var cmd = _connection!.CreateCommand();
        cmd.CommandText = GetIndexSelectQuery() + " WHERE workspace_path = @path AND status != 'Deleted'";
        cmd.Parameters.AddWithValue("@path", workspacePath);

        await using var reader = await cmd.ExecuteReaderAsync(ct);
        if (!await reader.ReadAsync(ct))
            return null;

        return ReadIndexFromReader(reader);
    }

    /// <inheritdoc />
    public async Task<IReadOnlyList<VectorIndex>> ListIndexesAsync(CancellationToken ct = default)
    {
        EnsureInitialized();

        var indexes = new List<VectorIndex>();

        await using var cmd = _connection!.CreateCommand();
        cmd.CommandText = GetIndexSelectQuery() + " WHERE status != 'Deleted' ORDER BY updated_at DESC";

        await using var reader = await cmd.ExecuteReaderAsync(ct);
        while (await reader.ReadAsync(ct))
        {
            indexes.Add(ReadIndexFromReader(reader));
        }

        return indexes;
    }

    #endregion

    #region Update

    /// <inheritdoc />
    public async Task UpdateIndexAsync(VectorIndex index, CancellationToken ct = default)
    {
        EnsureInitialized();

        if (index == null)
            throw new ArgumentNullException(nameof(index));

        await _writeLock.WaitAsync(ct);
        try
        {
            await using var cmd = _connection!.CreateCommand();
            cmd.CommandText = """
                UPDATE vector_indexes SET
                    name = @name,
                    updated_at = datetime('now'),
                    chunk_count = @chunkCount,
                    file_count = @fileCount,
                    total_file_size_bytes = @totalSize,
                    status = @status,
                    settings_json = @settings,
                    description = @description,
                    last_error = @lastError,
                    last_full_index_at = @lastFull,
                    last_incremental_update_at = @lastIncremental
                WHERE id = @id
                """;

            cmd.Parameters.AddWithValue("@id", index.Id);
            cmd.Parameters.AddWithValue("@name", index.Name);
            cmd.Parameters.AddWithValue("@chunkCount", index.ChunkCount);
            cmd.Parameters.AddWithValue("@fileCount", index.FileCount);
            cmd.Parameters.AddWithValue("@totalSize", index.TotalFileSizeBytes);
            cmd.Parameters.AddWithValue("@status", index.Status.ToString());
            cmd.Parameters.AddWithValue("@settings", JsonSerializer.Serialize(index.Settings));
            cmd.Parameters.AddWithValue("@description", (object?)index.Description ?? DBNull.Value);
            cmd.Parameters.AddWithValue("@lastError", (object?)index.LastError ?? DBNull.Value);
            cmd.Parameters.AddWithValue("@lastFull",
                index.LastFullIndexAt?.ToString("O") ?? (object)DBNull.Value);
            cmd.Parameters.AddWithValue("@lastIncremental",
                index.LastIncrementalUpdateAt?.ToString("O") ?? (object)DBNull.Value);

            var rowsAffected = await cmd.ExecuteNonQueryAsync(ct);

            if (rowsAffected == 0)
            {
                throw new InvalidOperationException($"Index not found: {index.Id}");
            }

            _logger.LogDebug("Updated index {IndexId}", index.Id);
        }
        finally
        {
            _writeLock.Release();
        }
    }

    #endregion

    #region Delete

    /// <inheritdoc />
    public async Task DeleteIndexAsync(string indexId, CancellationToken ct = default)
    {
        EnsureInitialized();

        _logger.LogInformation("Deleting index {IndexId}", indexId);

        await _writeLock.WaitAsync(ct);
        try
        {
            await using var transaction = await _connection!.BeginTransactionAsync(ct);
            try
            {
                // Drop the vector table
                var sanitizedId = SanitizeTableName(indexId);
                await using (var cmd = _connection.CreateCommand())
                {
                    cmd.Transaction = (SqliteTransaction)transaction;
                    cmd.CommandText = $"DROP TABLE IF EXISTS vectors_{sanitizedId}";
                    await cmd.ExecuteNonQueryAsync(ct);
                }

                _logger.LogDebug("Dropped vector table: vectors_{SanitizedId}", sanitizedId);

                // Delete metadata (cascade will handle chunks and files)
                await using (var cmd = _connection.CreateCommand())
                {
                    cmd.Transaction = (SqliteTransaction)transaction;
                    cmd.CommandText = "DELETE FROM vector_indexes WHERE id = @id";
                    cmd.Parameters.AddWithValue("@id", indexId);
                    await cmd.ExecuteNonQueryAsync(ct);
                }

                await transaction.CommitAsync(ct);
                _logger.LogInformation("Deleted index {IndexId}", indexId);
            }
            catch
            {
                await transaction.RollbackAsync(ct);
                throw;
            }
        }
        finally
        {
            _writeLock.Release();
        }
    }

    #endregion

    #region Helper Methods

    private static string GetIndexSelectQuery()
    {
        return """
            SELECT id, name, workspace_path, created_at, updated_at,
                   embedding_model, embedding_dimension, chunk_count, file_count,
                   total_file_size_bytes, status, settings_json, schema_version,
                   description, last_error, last_full_index_at, last_incremental_update_at
            FROM vector_indexes
            """;
    }

    private static VectorIndex ReadIndexFromReader(SqliteDataReader reader)
    {
        var settingsJson = reader.IsDBNull(reader.GetOrdinal("settings_json"))
            ? null
            : reader.GetString(reader.GetOrdinal("settings_json"));

        var settings = string.IsNullOrEmpty(settingsJson)
            ? new VectorIndexSettings()
            : JsonSerializer.Deserialize<VectorIndexSettings>(settingsJson) ?? new VectorIndexSettings();

        return new VectorIndex
        {
            Id = reader.GetString(reader.GetOrdinal("id")),
            Name = reader.GetString(reader.GetOrdinal("name")),
            WorkspacePath = reader.GetString(reader.GetOrdinal("workspace_path")),
            CreatedAt = DateTime.Parse(reader.GetString(reader.GetOrdinal("created_at"))),
            UpdatedAt = DateTime.Parse(reader.GetString(reader.GetOrdinal("updated_at"))),
            EmbeddingModel = reader.GetString(reader.GetOrdinal("embedding_model")),
            EmbeddingDimension = reader.GetInt32(reader.GetOrdinal("embedding_dimension")),
            ChunkCount = reader.GetInt32(reader.GetOrdinal("chunk_count")),
            FileCount = reader.GetInt32(reader.GetOrdinal("file_count")),
            TotalFileSizeBytes = reader.GetInt64(reader.GetOrdinal("total_file_size_bytes")),
            Status = Enum.Parse<IndexStatus>(reader.GetString(reader.GetOrdinal("status"))),
            Settings = settings,
            SchemaVersion = reader.GetInt32(reader.GetOrdinal("schema_version")),
            Description = reader.IsDBNull(reader.GetOrdinal("description"))
                ? null
                : reader.GetString(reader.GetOrdinal("description")),
            LastError = reader.IsDBNull(reader.GetOrdinal("last_error"))
                ? null
                : reader.GetString(reader.GetOrdinal("last_error")),
            LastFullIndexAt = reader.IsDBNull(reader.GetOrdinal("last_full_index_at"))
                ? null
                : DateTime.Parse(reader.GetString(reader.GetOrdinal("last_full_index_at"))),
            LastIncrementalUpdateAt = reader.IsDBNull(reader.GetOrdinal("last_incremental_update_at"))
                ? null
                : DateTime.Parse(reader.GetString(reader.GetOrdinal("last_incremental_update_at")))
        };
    }

    #endregion
}
```

---

## Thread Safety

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                           Thread Safety Design                                │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Lock Strategy:                                                               │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  SemaphoreSlim _initLock (1, 1)                                         │ │
│  │  ├── Purpose: Protect initialization                                    │ │
│  │  ├── Acquired: During InitializeAsync()                                 │ │
│  │  └── Pattern: Double-check locking                                      │ │
│  │                                                                          │ │
│  │  SemaphoreSlim _writeLock (1, 1)                                        │ │
│  │  ├── Purpose: Serialize write operations                                │ │
│  │  ├── Acquired: By all mutating operations                               │ │
│  │  │   ├── CreateIndexAsync                                               │ │
│  │  │   ├── UpdateIndexAsync                                               │ │
│  │  │   ├── DeleteIndexAsync                                               │ │
│  │  │   ├── AddChunksAsync                                                 │ │
│  │  │   ├── RemoveChunksForFileAsync                                       │ │
│  │  │   └── ClearIndexAsync                                                │ │
│  │  └── Pattern: try/finally with Release()                                │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  Concurrency Matrix:                                                          │
│  ┌────────────────────────────────┬───────────────────────────────────────┐ │
│  │ Operation Type                 │ Concurrency                            │ │
│  │ ───────────────────────────────│────────────────────────────────────── │ │
│  │ Read (GetIndex, List, Search)  │ Fully concurrent (no lock)            │ │
│  │ Write (Create, Update, Delete) │ Serialized via _writeLock             │ │
│  │ Initialization                 │ Serialized via _initLock              │ │
│  │ Read during Write              │ Allowed (WAL mode)                    │ │
│  └────────────────────────────────┴───────────────────────────────────────┘ │
│                                                                              │
│  Transaction Pattern:                                                         │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  await _writeLock.WaitAsync(ct);                                         │ │
│  │  try                                                                      │ │
│  │  {                                                                        │ │
│  │      await using var tx = await _connection.BeginTransactionAsync(ct);   │ │
│  │      try                                                                  │ │
│  │      {                                                                    │ │
│  │          // ... operations ...                                            │ │
│  │          await tx.CommitAsync(ct);                                        │ │
│  │      }                                                                    │ │
│  │      catch                                                                │ │
│  │      {                                                                    │ │
│  │          await tx.RollbackAsync(ct);                                      │ │
│  │          throw;                                                           │ │
│  │      }                                                                    │ │
│  │  }                                                                        │ │
│  │  finally                                                                  │ │
│  │  {                                                                        │ │
│  │      _writeLock.Release();                                                │ │
│  │  }                                                                        │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Unit Test Plan

| Test | Description |
|------|-------------|
| `VectorStoreOptions_Defaults_AreCorrect` | Default values |
| `VectorStoreOptions_Validate_ThrowsOnInvalid` | Validation |
| `SqliteVectorStore_InitializeAsync_CreatesDatabase` | Creates file |
| `SqliteVectorStore_InitializeAsync_IdempotentOnMultipleCalls` | Safe re-init |
| `SqliteVectorStore_InitializeAsync_ThrowsOnMissingExtension` | Extension error |
| `SqliteVectorStore_CreateIndexAsync_CreatesIndex` | Index creation |
| `SqliteVectorStore_CreateIndexAsync_ThrowsOnDuplicate` | Duplicate check |
| `SqliteVectorStore_GetIndexAsync_ReturnsIndex` | Index retrieval |
| `SqliteVectorStore_GetIndexAsync_ReturnsNullIfNotFound` | Not found case |
| `SqliteVectorStore_GetIndexForWorkspaceAsync_WorksCorrectly` | Workspace lookup |
| `SqliteVectorStore_ListIndexesAsync_ReturnsAllActive` | List all |
| `SqliteVectorStore_UpdateIndexAsync_UpdatesFields` | Update works |
| `SqliteVectorStore_DeleteIndexAsync_RemovesIndex` | Deletion |
| `SqliteVectorStore_DisposeAsync_ClosesConnection` | Cleanup |
| `SqliteVectorStore_SanitizeTableName_RemovesHyphens` | Table name sanitization |

---

## File Summary

| File | Location | Purpose | Lines |
|------|----------|---------|-------|
| `VectorStoreOptions.cs` | `Core/Options/` | Configuration options | ~100 |
| `SqliteVectorStore.cs` | `Services/VectorStore/` | Main class, init/dispose | ~350 |
| `SqliteVectorStore.IndexManagement.cs` | `Services/VectorStore/` | Index CRUD | ~300 |

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | `VectorStoreOptions` binds from configuration correctly |
| AC-2 | Initialization creates database file if missing |
| AC-3 | sqlite-vec extension loads successfully |
| AC-4 | Schema is created/migrated on initialization |
| AC-5 | StateChanged events fire correctly |
| AC-6 | CreateIndexAsync creates vector table and metadata |
| AC-7 | GetIndexAsync retrieves index correctly |
| AC-8 | ListIndexesAsync excludes deleted indexes |
| AC-9 | DeleteIndexAsync drops vector table and cascades |
| AC-10 | Write operations are serialized via lock |
| AC-11 | Disposal closes connection and releases resources |

---

## Changelog Entry

```markdown
## v0.7.2e - SQLite-vec Store Implementation

### Added
- `VectorStoreOptions` configuration class (`Core/Options/`)
  - DatabasePath - Custom database location
  - ExtensionPath - sqlite-vec extension location
  - ConnectionPoolSize, DefaultTimeoutSeconds
  - EnableWalMode, CacheSizeKb, VacuumOnStartup
  - BulkInsertBatchSize
  - Validate() method
- `SqliteVectorStore` partial class (`Services/VectorStore/`)
  - Main file: initialization, connection management, disposal
  - InitializeAsync() with extension loading and schema setup
  - ConfigureSqliteAsync() with optimal PRAGMAs
  - LoadVecExtensionAsync() with cross-platform search
  - GetDefaultDatabasePath() for standard location
  - StateChanged event for lifecycle notifications
  - Proper IAsyncDisposable implementation
- `SqliteVectorStore.IndexManagement.cs`
  - CreateIndexAsync() with duplicate check
  - GetIndexAsync() by ID
  - GetIndexForWorkspaceAsync() by path
  - ListIndexesAsync() excluding deleted
  - UpdateIndexAsync() for metadata changes
  - DeleteIndexAsync() with cascade

### Thread Safety
- SemaphoreSlim for initialization (_initLock)
- SemaphoreSlim for writes (_writeLock)
- Concurrent reads allowed (WAL mode)

### Cross-Platform Support
- Windows: vec0.dll
- macOS: vec0.dylib
- Linux: vec0.so
- Platform-specific runtime identifier detection
```

---

## Timeline Estimate

| Version | Estimated Effort |
|---------|------------------|
| v0.7.2e | 1 day |
