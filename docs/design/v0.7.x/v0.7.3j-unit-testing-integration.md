# Design Specification: AIntern v0.7.3j "Unit Testing & Integration"

## Overview

**Version**: v0.7.3j
**Parent**: v0.7.3 Indexing Pipeline
**Focus**: Implement comprehensive unit tests and integration tests for all indexing pipeline components

### Purpose

Implement test coverage for all v0.7.3 components:
1. `IndexingServiceTests` for core service operations
2. `FileProcessorTests` for file processing pipeline
3. `GitignoreParserTests` for gitignore pattern matching
4. `IncrementalIndexerTests` for incremental indexing
5. `IndexingJobQueueTests` for job queue management
6. `FileWatcherServiceTests` for file watching
7. `ProgressTrackerTests` for progress tracking
8. `ChangeDetectorTests` for change detection
9. `IndexingOptionsTests` for options validation
10. `IndexingIntegrationTests` for end-to-end scenarios

### Dependencies

**From v0.7.3a-i**:
- All indexing pipeline components to test

**Testing Framework**:
- xUnit
- Moq (for mocking dependencies)
- Microsoft.Extensions.Logging.Abstractions (NullLogger)
- System.IO (temp file handling)

---

## Test Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                      v0.7.3j Unit Testing Architecture                        │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Test File Structure:                                                         │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  tests/SeniorIntern.Tests/Indexing/                                      │ │
│  │  ├── IndexingServiceTests.cs        ← Core service tests                │ │
│  │  ├── FileProcessorTests.cs          ← File processing tests             │ │
│  │  ├── GitignoreParserTests.cs        ← Gitignore parsing tests           │ │
│  │  ├── GitignoreMatcherTests.cs       ← Pattern matching tests            │ │
│  │  ├── IncrementalIndexerTests.cs     ← Incremental indexing tests        │ │
│  │  ├── ChangeDetectorTests.cs         ← Change detection tests            │ │
│  │  ├── FileScannerTests.cs            ← File scanning tests               │ │
│  │  ├── IndexingJobQueueTests.cs       ← Job queue tests                   │ │
│  │  ├── IndexingJobProcessorTests.cs   ← Job processor tests               │ │
│  │  ├── FileWatcherServiceTests.cs     ← File watcher tests                │ │
│  │  ├── ProgressTrackerTests.cs        ← Progress tracking tests           │ │
│  │  ├── IndexingEventAggregatorTests.cs← Event aggregation tests           │ │
│  │  ├── IndexingMetricsTests.cs        ← Metrics collection tests          │ │
│  │  ├── IndexingOptionsTests.cs        ← Options validation tests          │ │
│  │  └── IndexingIntegrationTests.cs    ← End-to-end integration tests      │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  Test Categories:                                                             │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  Integration Tests (require external resources):                         │ │
│  │  ├── IndexingServiceTests         (uses mocks, temp files)              │ │
│  │  ├── IncrementalIndexerTests      (uses mocks, temp files)              │ │
│  │  ├── FileWatcherServiceTests      (uses temp directories)               │ │
│  │  └── IndexingIntegrationTests     (full pipeline with temp DB)          │ │
│  │                                                                          │ │
│  │  Unit Tests (no external dependencies):                                  │ │
│  │  ├── FileProcessorTests           (mocked dependencies)                 │ │
│  │  ├── GitignoreParserTests         (pure parsing logic)                  │ │
│  │  ├── GitignoreMatcherTests        (pure matching logic)                 │ │
│  │  ├── ChangeDetectorTests          (pure comparison logic)               │ │
│  │  ├── FileScannerTests             (uses temp directories)               │ │
│  │  ├── IndexingJobQueueTests        (pure queue logic)                    │ │
│  │  ├── ProgressTrackerTests         (pure calculation logic)              │ │
│  │  ├── IndexingEventAggregatorTests (pure event buffering)                │ │
│  │  ├── IndexingMetricsTests         (pure aggregation logic)              │ │
│  │  └── IndexingOptionsTests         (pure model validation)               │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Test Coverage Matrix

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                          Test Coverage Matrix                                 │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Component                       │ Test Count │ Coverage Areas               │
│  ═══════════════════════════════ │ ══════════ │ ════════════════════════════ │
│  IndexingService                 │ 15         │ Full index, incremental, sync│
│  FileProcessor                   │ 12         │ Read, hash, chunk, embed     │
│  GitignoreParser                 │ 10         │ Parse, load, patterns        │
│  GitignoreMatcher                │ 12         │ Match, filter, negation      │
│  IncrementalIndexer              │ 10         │ Changes, process, stats      │
│  ChangeDetector                  │ 10         │ Add/mod/del, hash, rename    │
│  FileScanner                     │ 8          │ Scan, patterns, size limits  │
│  IndexingJobQueue                │ 10         │ Enqueue, dequeue, priority   │
│  IndexingJobProcessor            │ 8          │ Process, retry, types        │
│  FileWatcherService              │ 10         │ Watch, debounce, patterns    │
│  ProgressTracker                 │ 8          │ Progress, rates, estimates   │
│  IndexingEventAggregator         │ 8          │ Events, trim, retrieve       │
│  IndexingMetrics                 │ 8          │ Record, aggregate, summary   │
│  IndexingOptions                 │ 6          │ Defaults, validation         │
│  IndexingIntegration             │ 10         │ Full pipeline E2E            │
│  ─────────────────────────────── │ ────────── │ ──────────────────────────── │
│  Total                           │ ~145       │                              │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Test Base Patterns

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                     Testing Patterns for v0.7.3j                              │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Pattern 1: IAsyncLifetime for integration tests                             │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  public class IndexingIntegrationTests : IAsyncLifetime                  │ │
│  │  {                                                                        │ │
│  │      private string _tempDir = null!;                                    │ │
│  │      private string _dbPath = null!;                                     │ │
│  │                                                                          │ │
│  │      public async Task InitializeAsync()                                 │ │
│  │      {                                                                    │ │
│  │          _tempDir = Path.Combine(Path.GetTempPath(), Guid.NewGuid()...); │ │
│  │          Directory.CreateDirectory(_tempDir);                            │ │
│  │          _dbPath = Path.Combine(_tempDir, "test.db");                    │ │
│  │          // Setup services...                                             │ │
│  │      }                                                                    │ │
│  │                                                                          │ │
│  │      public Task DisposeAsync()                                          │ │
│  │      {                                                                    │ │
│  │          if (Directory.Exists(_tempDir))                                 │ │
│  │              Directory.Delete(_tempDir, true);                           │ │
│  │          return Task.CompletedTask;                                      │ │
│  │      }                                                                    │ │
│  │  }                                                                        │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  Pattern 2: Mocked dependencies for unit tests                               │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  public class FileProcessorTests                                         │ │
│  │  {                                                                        │ │
│  │      private readonly Mock<IChunkingService> _chunkingMock = new();      │ │
│  │      private readonly Mock<IEmbeddingService> _embeddingMock = new();    │ │
│  │      private readonly Mock<IVectorStore> _vectorStoreMock = new();       │ │
│  │      private readonly FileProcessor _processor;                          │ │
│  │                                                                          │ │
│  │      public FileProcessorTests()                                         │ │
│  │      {                                                                    │ │
│  │          _processor = new FileProcessor(                                 │ │
│  │              _chunkingMock.Object,                                       │ │
│  │              _embeddingMock.Object,                                      │ │
│  │              _vectorStoreMock.Object,                                    │ │
│  │              NullLogger<FileProcessor>.Instance);                        │ │
│  │      }                                                                    │ │
│  │  }                                                                        │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  Pattern 3: Temp file helper for file tests                                  │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  private class TempFileHelper : IDisposable                              │ │
│  │  {                                                                        │ │
│  │      public string RootPath { get; }                                     │ │
│  │                                                                          │ │
│  │      public TempFileHelper()                                             │ │
│  │      {                                                                    │ │
│  │          RootPath = Path.Combine(Path.GetTempPath(), Guid.NewGuid()...); │ │
│  │          Directory.CreateDirectory(RootPath);                            │ │
│  │      }                                                                    │ │
│  │                                                                          │ │
│  │      public string CreateFile(string relativePath, string content)       │ │
│  │      {                                                                    │ │
│  │          var fullPath = Path.Combine(RootPath, relativePath);            │ │
│  │          Directory.CreateDirectory(Path.GetDirectoryName(fullPath)!);    │ │
│  │          File.WriteAllText(fullPath, content);                           │ │
│  │          return fullPath;                                                 │ │
│  │      }                                                                    │ │
│  │                                                                          │ │
│  │      public void Dispose() => Directory.Delete(RootPath, true);          │ │
│  │  }                                                                        │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Files to Create

| File | Purpose |
|------|---------|
| `tests/SeniorIntern.Tests/Indexing/IndexingServiceTests.cs` | Core service tests |
| `tests/SeniorIntern.Tests/Indexing/FileProcessorTests.cs` | File processor tests |
| `tests/SeniorIntern.Tests/Indexing/GitignoreParserTests.cs` | Gitignore parsing tests |
| `tests/SeniorIntern.Tests/Indexing/GitignoreMatcherTests.cs` | Pattern matching tests |
| `tests/SeniorIntern.Tests/Indexing/IncrementalIndexerTests.cs` | Incremental tests |
| `tests/SeniorIntern.Tests/Indexing/ChangeDetectorTests.cs` | Change detection tests |
| `tests/SeniorIntern.Tests/Indexing/FileScannerTests.cs` | File scanning tests |
| `tests/SeniorIntern.Tests/Indexing/IndexingJobQueueTests.cs` | Job queue tests |
| `tests/SeniorIntern.Tests/Indexing/IndexingJobProcessorTests.cs` | Job processor tests |
| `tests/SeniorIntern.Tests/Indexing/FileWatcherServiceTests.cs` | File watcher tests |
| `tests/SeniorIntern.Tests/Indexing/ProgressTrackerTests.cs` | Progress tests |
| `tests/SeniorIntern.Tests/Indexing/IndexingEventAggregatorTests.cs` | Event tests |
| `tests/SeniorIntern.Tests/Indexing/IndexingMetricsTests.cs` | Metrics tests |
| `tests/SeniorIntern.Tests/Indexing/IndexingOptionsTests.cs` | Options tests |
| `tests/SeniorIntern.Tests/Indexing/IndexingIntegrationTests.cs` | E2E tests |

---

## Detailed Test Specifications

### 1. GitignoreParserTests.cs

**Location**: `tests/SeniorIntern.Tests/Indexing/GitignoreParserTests.cs`

```csharp
namespace SeniorIntern.Tests.Indexing;

using System.IO;
using SeniorIntern.Services.Indexing;
using Xunit;

/// <summary>
/// Unit tests for GitignoreParser.
/// </summary>
public class GitignoreParserTests : IDisposable
{
    private readonly string _tempDir;
    private readonly GitignoreParser _parser = new();

    public GitignoreParserTests()
    {
        _tempDir = Path.Combine(Path.GetTempPath(), $"gitignore_test_{Guid.NewGuid()}");
        Directory.CreateDirectory(_tempDir);
    }

    public void Dispose()
    {
        if (Directory.Exists(_tempDir))
            Directory.Delete(_tempDir, true);
    }

    #region LoadFromContent Tests

    [Fact]
    public void LoadFromContent_EmptyContent_ReturnsEmptyMatcher()
    {
        // Arrange & Act
        var matcher = _parser.LoadFromContent("", _tempDir);

        // Assert
        Assert.Equal(0, matcher.PatternCount);
    }

    [Fact]
    public void LoadFromContent_CommentsOnly_ReturnsEmptyMatcher()
    {
        // Arrange
        var content = """
            # This is a comment
            # Another comment
            """;

        // Act
        var matcher = _parser.LoadFromContent(content, _tempDir);

        // Assert
        Assert.Equal(0, matcher.PatternCount);
    }

    [Fact]
    public void LoadFromContent_BlankLines_AreIgnored()
    {
        // Arrange
        var content = """
            *.log

            *.tmp
            """;

        // Act
        var matcher = _parser.LoadFromContent(content, _tempDir);

        // Assert
        Assert.Equal(2, matcher.PatternCount);
    }

    [Fact]
    public void LoadFromContent_StandardPatterns_AreParsed()
    {
        // Arrange
        var content = """
            *.log
            /build/
            !important.log
            temp/
            """;

        // Act
        var matcher = _parser.LoadFromContent(content, _tempDir);

        // Assert
        Assert.Equal(4, matcher.PatternCount);
    }

    #endregion

    #region LoadFromFile Tests

    [Fact]
    public void LoadFromFile_ExistingFile_LoadsPatterns()
    {
        // Arrange
        var gitignorePath = Path.Combine(_tempDir, ".gitignore");
        File.WriteAllText(gitignorePath, "*.log\nnode_modules/");

        // Act
        var matcher = _parser.LoadFromFile(gitignorePath);

        // Assert
        Assert.Equal(2, matcher.PatternCount);
    }

    [Fact]
    public void LoadFromFile_NonExistentFile_ReturnsEmptyMatcher()
    {
        // Arrange
        var nonExistentPath = Path.Combine(_tempDir, "nonexistent", ".gitignore");

        // Act
        var matcher = _parser.LoadFromFile(nonExistentPath);

        // Assert
        Assert.Equal(0, matcher.PatternCount);
    }

    #endregion

    #region LoadFromDirectory Tests

    [Fact]
    public void LoadFromDirectory_RootGitignore_IsLoaded()
    {
        // Arrange
        File.WriteAllText(Path.Combine(_tempDir, ".gitignore"), "*.log");

        // Act
        var matcher = _parser.LoadFromDirectory(_tempDir);

        // Assert
        Assert.True(matcher.PatternCount > 0);
    }

    [Fact]
    public void LoadFromDirectory_NestedGitignores_AreMerged()
    {
        // Arrange
        File.WriteAllText(Path.Combine(_tempDir, ".gitignore"), "*.log");
        
        var subDir = Path.Combine(_tempDir, "subdir");
        Directory.CreateDirectory(subDir);
        File.WriteAllText(Path.Combine(subDir, ".gitignore"), "*.tmp");

        // Act
        var matcher = _parser.LoadFromDirectory(_tempDir);

        // Assert
        Assert.True(matcher.PatternCount >= 2);
    }

    [Fact]
    public void LoadFromDirectory_NoGitignore_ReturnsEmptyMatcher()
    {
        // Arrange - _tempDir has no .gitignore

        // Act
        var matcher = _parser.LoadFromDirectory(_tempDir);

        // Assert
        Assert.Equal(0, matcher.PatternCount);
    }

    #endregion
}
```

### 2. GitignoreMatcherTests.cs

**Location**: `tests/SeniorIntern.Tests/Indexing/GitignoreMatcherTests.cs`

```csharp
namespace SeniorIntern.Tests.Indexing;

using System.Text.RegularExpressions;
using SeniorIntern.Services.Indexing;
using Xunit;

/// <summary>
/// Unit tests for GitignoreMatcher pattern matching.
/// </summary>
public class GitignoreMatcherTests
{
    private static GitignoreMatcher CreateMatcher(params string[] patterns)
    {
        var parser = new GitignoreParser();
        var content = string.Join("\n", patterns);
        return (GitignoreMatcher)parser.LoadFromContent(content, "/root");
    }

    #region Simple Pattern Tests

    [Fact]
    public void IsIgnored_ExactMatch_ReturnsTrue()
    {
        // Arrange
        var matcher = CreateMatcher("debug.log");

        // Act & Assert
        Assert.True(matcher.IsIgnored("debug.log"));
        Assert.False(matcher.IsIgnored("other.log"));
    }

    [Fact]
    public void IsIgnored_WildcardPattern_MatchesFiles()
    {
        // Arrange
        var matcher = CreateMatcher("*.log");

        // Act & Assert
        Assert.True(matcher.IsIgnored("debug.log"));
        Assert.True(matcher.IsIgnored("error.log"));
        Assert.False(matcher.IsIgnored("file.txt"));
    }

    [Fact]
    public void IsIgnored_QuestionMarkWildcard_MatchesSingleChar()
    {
        // Arrange
        var matcher = CreateMatcher("file?.txt");

        // Act & Assert
        Assert.True(matcher.IsIgnored("file1.txt"));
        Assert.True(matcher.IsIgnored("fileA.txt"));
        Assert.False(matcher.IsIgnored("file10.txt"));
    }

    #endregion

    #region Directory Pattern Tests

    [Fact]
    public void IsIgnored_DirectoryPattern_MatchesDirectoriesOnly()
    {
        // Arrange
        var matcher = CreateMatcher("build/");

        // Act & Assert
        Assert.True(matcher.IsIgnored("build", isDirectory: true));
        Assert.True(matcher.IsIgnored("build/", isDirectory: true));
        // File named "build" should not match directory-only pattern
        Assert.False(matcher.IsIgnored("build", isDirectory: false));
    }

    [Fact]
    public void IsIgnored_DoubleGlobstar_MatchesAcrossDirectories()
    {
        // Arrange
        var matcher = CreateMatcher("**/logs");

        // Act & Assert
        Assert.True(matcher.IsIgnored("logs"));
        Assert.True(matcher.IsIgnored("src/logs"));
        Assert.True(matcher.IsIgnored("src/app/logs"));
    }

    [Fact]
    public void IsIgnored_GlobstarSuffix_MatchesAllInDirectory()
    {
        // Arrange
        var matcher = CreateMatcher("build/**"));

        // Act & Assert
        Assert.True(matcher.IsIgnored("build/output.dll"));
        Assert.True(matcher.IsIgnored("build/Debug/output.dll"));
    }

    #endregion

    #region Anchored Pattern Tests

    [Fact]
    public void IsIgnored_AnchoredPattern_MatchesFromRoot()
    {
        // Arrange
        var matcher = CreateMatcher("/build");

        // Act & Assert
        Assert.True(matcher.IsIgnored("build"));
        Assert.False(matcher.IsIgnored("src/build"));
    }

    [Fact]
    public void IsIgnored_UnanchoredPattern_MatchesAnywhere()
    {
        // Arrange
        var matcher = CreateMatcher("build");

        // Act & Assert
        Assert.True(matcher.IsIgnored("build"));
        Assert.True(matcher.IsIgnored("src/build"));
    }

    #endregion

    #region Negation Pattern Tests

    [Fact]
    public void IsIgnored_NegationPattern_UndoesIgnore()
    {
        // Arrange
        var matcher = CreateMatcher("*.log", "!important.log");

        // Act & Assert
        Assert.True(matcher.IsIgnored("debug.log"));
        Assert.False(matcher.IsIgnored("important.log"));
    }

    [Fact]
    public void IsIgnored_NegationWithGlobstar_WorksCorrectly()
    {
        // Arrange
        var matcher = CreateMatcher("logs/", "!logs/important/");

        // Act & Assert
        Assert.True(matcher.IsIgnored("logs/debug.log"));
        Assert.False(matcher.IsIgnored("logs/important/keep.log"));
    }

    [Fact]
    public void IsIgnored_LastMatchWins_NegationThenIgnore()
    {
        // Arrange
        var matcher = CreateMatcher("*.log", "!important.log", "really.log");

        // Act & Assert
        Assert.True(matcher.IsIgnored("really.log"));
    }

    #endregion

    #region Filter Tests

    [Fact]
    public void Filter_RemovesIgnoredPaths()
    {
        // Arrange
        var matcher = CreateMatcher("*.log");
        var paths = new[] { "file.txt", "debug.log", "app.cs", "error.log" };

        // Act
        var filtered = matcher.Filter(paths).ToList();

        // Assert
        Assert.Equal(2, filtered.Count);
        Assert.Contains("file.txt", filtered);
        Assert.Contains("app.cs", filtered);
    }

    [Fact]
    public void Filter_EmptyInput_ReturnsEmpty()
    {
        // Arrange
        var matcher = CreateMatcher("*.log");

        // Act
        var filtered = matcher.Filter(Array.Empty<string>()).ToList();

        // Assert
        Assert.Empty(filtered);
    }

    #endregion
}
```

### 3. IndexingJobQueueTests.cs

**Location**: `tests/SeniorIntern.Tests/Indexing/IndexingJobQueueTests.cs`

```csharp
namespace SeniorIntern.Tests.Indexing;

using System;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using SeniorIntern.Core.Models;
using SeniorIntern.Services.Indexing;
using Xunit;

/// <summary>
/// Unit tests for IndexingJobQueue.
/// </summary>
public class IndexingJobQueueTests
{
    private static IndexingJob CreateJob(int priority = 0) => new()
    {
        Type = IndexingJobType.FullIndex,
        WorkspacePath = $"/test/{Guid.NewGuid()}",
        Options = new IndexingOptions(),
        Priority = priority
    };

    #region Enqueue Tests

    [Fact]
    public void Enqueue_AddsJobToQueue()
    {
        // Arrange
        var queue = new IndexingJobQueue();
        var job = CreateJob();

        // Act
        queue.Enqueue(job);

        // Assert
        Assert.Equal(1, queue.QueueLength);
    }

    [Fact]
    public void Enqueue_SetsStatusToQueued()
    {
        // Arrange
        var queue = new IndexingJobQueue();
        var job = CreateJob();

        // Act
        queue.Enqueue(job);

        // Assert
        Assert.Equal(IndexingJobStatus.Queued, job.Status);
    }

    [Fact]
    public void Enqueue_RaisesJobEnqueuedEvent()
    {
        // Arrange
        var queue = new IndexingJobQueue();
        var job = CreateJob();
        var eventRaised = false;
        queue.JobEnqueued += (s, e) => eventRaised = true;

        // Act
        queue.Enqueue(job);

        // Assert
        Assert.True(eventRaised);
    }

    [Fact]
    public void Enqueue_DuplicateJobId_DoesNotAdd()
    {
        // Arrange
        var queue = new IndexingJobQueue();
        var job = CreateJob();
        queue.Enqueue(job);

        // Act
        queue.Enqueue(job); // Same job again

        // Assert
        Assert.Equal(1, queue.QueueLength);
    }

    #endregion

    #region Dequeue Tests

    [Fact]
    public void TryDequeue_WhenEmpty_ReturnsFalse()
    {
        // Arrange
        var queue = new IndexingJobQueue();

        // Act
        var result = queue.TryDequeue(out var job);

        // Assert
        Assert.False(result);
        Assert.Null(job);
    }

    [Fact]
    public void TryDequeue_WhenNotEmpty_ReturnsJob()
    {
        // Arrange
        var queue = new IndexingJobQueue();
        var job = CreateJob();
        queue.Enqueue(job);

        // Act
        var result = queue.TryDequeue(out var dequeuedJob);

        // Assert
        Assert.True(result);
        Assert.NotNull(dequeuedJob);
        Assert.Equal(job.Id, dequeuedJob.Id);
    }

    [Fact]
    public void TryDequeue_SetsStatusToRunning()
    {
        // Arrange
        var queue = new IndexingJobQueue();
        var job = CreateJob();
        queue.Enqueue(job);

        // Act
        queue.TryDequeue(out var dequeuedJob);

        // Assert
        Assert.Equal(IndexingJobStatus.Running, dequeuedJob!.Status);
    }

    [Fact]
    public void TryDequeue_SetsStartedAt()
    {
        // Arrange
        var queue = new IndexingJobQueue();
        var job = CreateJob();
        queue.Enqueue(job);

        // Act
        queue.TryDequeue(out var dequeuedJob);

        // Assert
        Assert.NotNull(dequeuedJob!.StartedAt);
    }

    [Fact]
    public async Task DequeueAsync_WaitsForJob()
    {
        // Arrange
        var queue = new IndexingJobQueue();
        var job = CreateJob();
        IndexingJob? dequeuedJob = null;

        // Start waiting for job
        var dequeueTask = Task.Run(async () =>
        {
            dequeuedJob = await queue.DequeueAsync();
        });

        // Wait a bit then enqueue
        await Task.Delay(100);
        queue.Enqueue(job);
        await dequeueTask;

        // Assert
        Assert.NotNull(dequeuedJob);
        Assert.Equal(job.Id, dequeuedJob.Id);
    }

    #endregion

    #region GetQueuedJobs Tests

    [Fact]
    public void GetQueuedJobs_ReturnsSortedByPriorityThenCreatedAt()
    {
        // Arrange
        var queue = new IndexingJobQueue();
        var lowPriority = CreateJob(priority: 0);
        var highPriority = CreateJob(priority: 10);
        queue.Enqueue(lowPriority);
        queue.Enqueue(highPriority);

        // Act
        var jobs = queue.GetQueuedJobs();

        // Assert
        Assert.Equal(highPriority.Id, jobs[0].Id);
        Assert.Equal(lowPriority.Id, jobs[1].Id);
    }

    #endregion

    #region Remove and Clear Tests

    [Fact]
    public void Remove_ExistingJob_ReturnsTrue()
    {
        // Arrange
        var queue = new IndexingJobQueue();
        var job = CreateJob();
        queue.Enqueue(job);

        // Act
        var result = queue.Remove(job.Id);

        // Assert
        Assert.True(result);
        Assert.Equal(0, queue.QueueLength);
    }

    [Fact]
    public void Remove_SetsStatusToCancelled()
    {
        // Arrange
        var queue = new IndexingJobQueue();
        var job = CreateJob();
        queue.Enqueue(job);

        // Act
        queue.Remove(job.Id);

        // Assert
        Assert.Equal(IndexingJobStatus.Cancelled, job.Status);
    }

    [Fact]
    public void Clear_RemovesAllJobs()
    {
        // Arrange
        var queue = new IndexingJobQueue();
        queue.Enqueue(CreateJob());
        queue.Enqueue(CreateJob());
        queue.Enqueue(CreateJob());

        // Act
        queue.Clear();

        // Assert
        Assert.Equal(0, queue.QueueLength);
    }

    #endregion
}
```

### 4. ProgressTrackerTests.cs

**Location**: `tests/SeniorIntern.Tests/Indexing/ProgressTrackerTests.cs`

```csharp
namespace SeniorIntern.Tests.Indexing;

using System;
using System.Threading.Tasks;
using SeniorIntern.Core.Models;
using SeniorIntern.Services.Indexing;
using Xunit;

/// <summary>
/// Unit tests for ProgressTracker.
/// </summary>
public class ProgressTrackerTests
{
    #region Basic Tracking Tests

    [Fact]
    public void FileProcessed_IncrementsCounters()
    {
        // Arrange
        var tracker = new ProgressTracker(10, 1000);
        tracker.Start();

        // Act
        tracker.FileProcessed(chunkCount: 5, bytes: 200);

        // Assert
        var progress = tracker.GetProgress();
        Assert.Equal(1, progress.ProcessedFiles);
        Assert.Equal(5, progress.TotalChunks);
        Assert.Equal(200, progress.BytesProcessed);
    }

    [Fact]
    public void FileSkipped_IncrementsSkippedCounter()
    {
        // Arrange
        var tracker = new ProgressTracker(10);
        tracker.Start();

        // Act
        tracker.FileSkipped();

        // Assert
        var progress = tracker.GetProgress();
        Assert.Equal(1, progress.SkippedFiles);
    }

    [Fact]
    public void FileFailed_IncrementsFailedCounter()
    {
        // Arrange
        var tracker = new ProgressTracker(10);
        tracker.Start();

        // Act
        tracker.FileFailed();

        // Assert
        var progress = tracker.GetProgress();
        Assert.Equal(1, progress.FailedFiles);
    }

    #endregion

    #region Progress Calculation Tests

    [Fact]
    public void GetProgress_CalculatesPercentageCorrectly()
    {
        // Arrange
        var tracker = new ProgressTracker(10);
        tracker.Start();
        tracker.FileProcessed(1, 100);
        tracker.FileProcessed(1, 100);
        tracker.FileSkipped();

        // Act
        var progress = tracker.GetProgress();

        // Assert - 3 of 10 = 30%
        Assert.Equal(30.0, progress.PercentComplete, precision: 1);
    }

    [Fact]
    public void GetProgress_ZeroTotalFiles_ReturnsZeroPercent()
    {
        // Arrange
        var tracker = new ProgressTracker(0);

        // Act
        var progress = tracker.GetProgress();

        // Assert
        Assert.Equal(0, progress.PercentComplete);
    }

    [Fact]
    public async Task GetProgress_CalculatesFilesPerSecond()
    {
        // Arrange
        var tracker = new ProgressTracker(100);
        tracker.Start();

        // Process files over time
        tracker.FileProcessed(1, 100);
        await Task.Delay(100);
        tracker.FileProcessed(1, 100);

        // Act
        var progress = tracker.GetProgress();

        // Assert - Should have some files per second
        Assert.True(progress.FilesPerSecond > 0);
    }

    [Fact]
    public async Task GetProgress_EstimatesRemainingTime()
    {
        // Arrange
        var tracker = new ProgressTracker(100);
        tracker.Start();

        // Process some files
        for (int i = 0; i < 10; i++)
        {
            tracker.FileProcessed(1, 100);
        }
        await Task.Delay(50);

        // Act
        var progress = tracker.GetProgress();

        // Assert - 10 done, 90 remaining
        Assert.NotNull(progress.EstimatedRemaining);
        Assert.True(progress.EstimatedRemaining.Value.TotalSeconds > 0);
    }

    #endregion

    #region Phase and State Tests

    [Fact]
    public void SetPhase_UpdatesPhase()
    {
        // Arrange
        var tracker = new ProgressTracker(10);

        // Act
        tracker.SetPhase(IndexingPhase.Processing);

        // Assert
        Assert.Equal(IndexingPhase.Processing, tracker.Phase);
    }

    [Fact]
    public void SetCurrentFile_UpdatesCurrentFile()
    {
        // Arrange
        var tracker = new ProgressTracker(10);

        // Act
        tracker.SetCurrentFile("test.cs");

        // Assert
        Assert.Equal("test.cs", tracker.CurrentFile);
        Assert.Equal("test.cs", tracker.GetProgress().CurrentFile);
    }

    #endregion

    #region Result Tests

    [Fact]
    public void GetResult_ReturnsCorrectValues()
    {
        // Arrange
        var tracker = new ProgressTracker(10);
        tracker.Start();
        tracker.FileProcessed(3, 300);
        tracker.FileProcessed(2, 200);
        tracker.FileSkipped();
        tracker.FileFailed();

        // Act
        var result = tracker.GetResult("index-1", success: true);

        // Assert
        Assert.True(result.Success);
        Assert.Equal("index-1", result.IndexId);
        Assert.Equal(2, result.FilesIndexed);
        Assert.Equal(1, result.FilesSkipped);
        Assert.Equal(1, result.FilesErrored);
        Assert.Equal(5, result.ChunksCreated);
        Assert.Equal(500, result.BytesProcessed);
    }

    [Fact]
    public void GetResult_StopsTimer()
    {
        // Arrange
        var tracker = new ProgressTracker(10);
        tracker.Start();
        Assert.True(tracker.IsRunning);

        // Act
        tracker.GetResult("index-1", success: true);

        // Assert
        Assert.False(tracker.IsRunning);
    }

    #endregion
}
```

### 5. IndexingIntegrationTests.cs

**Location**: `tests/SeniorIntern.Tests/Indexing/IndexingIntegrationTests.cs`

```csharp
namespace SeniorIntern.Tests.Indexing;

using System;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.Extensions.Options;
using Moq;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Core.Options;
using SeniorIntern.Services.Indexing;
using SeniorIntern.Services.VectorStore;
using Xunit;

/// <summary>
/// End-to-end integration tests for the indexing pipeline.
/// </summary>
public class IndexingIntegrationTests : IAsyncLifetime
{
    private string _tempDir = null!;
    private string _dbPath = null!;
    private SqliteVectorStore _vectorStore = null!;
    private IndexingService _indexingService = null!;

    public async Task InitializeAsync()
    {
        _tempDir = Path.Combine(Path.GetTempPath(), $"indexing_test_{Guid.NewGuid()}");
        Directory.CreateDirectory(_tempDir);
        _dbPath = Path.Combine(_tempDir, "test.db");

        // Create test files
        CreateTestWorkspace();

        // Setup services
        var vectorOptions = Options.Create(new VectorStoreOptions { DatabasePath = _dbPath });
        _vectorStore = new SqliteVectorStore(
            vectorOptions,
            NullLogger<SqliteVectorStore>.Instance);
        await _vectorStore.InitializeAsync();

        // Create mocks for embedding and chunking (full integration would use real services)
        var embeddingMock = new Mock<IEmbeddingService>();
        embeddingMock.Setup(e => e.GenerateEmbeddingsAsync(It.IsAny<IReadOnlyList<string>>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync((IReadOnlyList<string> texts, CancellationToken ct) =>
                texts.Select(_ => Enumerable.Range(0, 384).Select(i => (float)i / 384).ToArray()).ToList());

        var chunkingMock = new Mock<IChunkingService>();
        chunkingMock.Setup(c => c.ChunkAsync(It.IsAny<string>(), It.IsAny<ChunkingOptions>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync((string content, ChunkingOptions opts, CancellationToken ct) =>
                new[] { new TextChunk { Content = content, StartLine = 1, EndLine = 1 } });

        // Setup indexing service with dependencies
        var gitignoreParser = new GitignoreParser();
        var fileScanner = new FileScanner(gitignoreParser, NullLogger<FileScanner>.Instance);
        var jobQueue = new IndexingJobQueue();
        
        _indexingService = new IndexingService(
            embeddingMock.Object,
            chunkingMock.Object,
            _vectorStore,
            gitignoreParser,
            fileScanner,
            jobQueue,
            NullLogger<IndexingService>.Instance);
    }

    private void CreateTestWorkspace()
    {
        var srcDir = Path.Combine(_tempDir, "workspace", "src");
        Directory.CreateDirectory(srcDir);

        File.WriteAllText(Path.Combine(srcDir, "Program.cs"),
            "public class Program { static void Main() { } }");
        File.WriteAllText(Path.Combine(srcDir, "Service.cs"),
            "public class Service { public void DoWork() { } }");
        File.WriteAllText(Path.Combine(_tempDir, "workspace", "README.md"),
            "# Test Project\nThis is a test.");

        // Create .gitignore
        File.WriteAllText(Path.Combine(_tempDir, "workspace", ".gitignore"),
            "*.log\nbin/\nobj/");
    }

    public async Task DisposeAsync()
    {
        await _vectorStore.DisposeAsync();

        if (Directory.Exists(_tempDir))
            Directory.Delete(_tempDir, true);
    }

    #region Full Pipeline Tests

    [Fact]
    public async Task IndexWorkspaceAsync_IndexesAllMatchingFiles()
    {
        // Arrange
        var workspacePath = Path.Combine(_tempDir, "workspace");
        var options = new IndexingOptions
        {
            IncludePatterns = ["**/*.cs", "**/*.md"],
            RespectGitignore = true
        };

        // Act
        var result = await _indexingService.IndexWorkspaceAsync(workspacePath, options);

        // Assert
        Assert.True(result.Success);
        Assert.Equal(3, result.FilesIndexed); // 2 .cs + 1 .md
        Assert.True(result.ChunksCreated > 0);
    }

    [Fact]
    public async Task IndexWorkspaceAsync_RespectsGitignore()
    {
        // Arrange
        var workspacePath = Path.Combine(_tempDir, "workspace");
        File.WriteAllText(Path.Combine(workspacePath, "debug.log"), "log content");
        var options = new IndexingOptions { RespectGitignore = true };

        // Act
        var result = await _indexingService.IndexWorkspaceAsync(workspacePath, options);

        // Assert - .log files should be ignored
        Assert.DoesNotContain("debug.log", result.FilesIndexed.ToString());
    }

    [Fact]
    public async Task IndexWorkspaceAsync_ReportsProgress()
    {
        // Arrange
        var workspacePath = Path.Combine(_tempDir, "workspace");
        var options = new IndexingOptions();
        var progressReports = new List<IndexingProgress>();
        var progress = new Progress<IndexingProgress>(p => progressReports.Add(p));

        // Act
        await _indexingService.IndexWorkspaceAsync(workspacePath, options, progress);

        // Assert
        Assert.NotEmpty(progressReports);
        Assert.Contains(progressReports, p => p.Phase == IndexingPhase.Processing);
    }

    #endregion

    #region Incremental Update Tests

    [Fact]
    public async Task UpdateIndexAsync_DetectsNewFiles()
    {
        // Arrange
        var workspacePath = Path.Combine(_tempDir, "workspace");
        var options = new IndexingOptions();
        var initialResult = await _indexingService.IndexWorkspaceAsync(workspacePath, options);
        var indexId = initialResult.IndexId;

        // Add a new file
        File.WriteAllText(Path.Combine(workspacePath, "src", "NewFile.cs"),
            "public class NewFile { }");

        // Act
        var updateResult = await _indexingService.UpdateIndexAsync(indexId);

        // Assert
        Assert.True(updateResult.Success);
        Assert.True(updateResult.FilesIndexed > 0);
    }

    [Fact]
    public async Task UpdateIndexAsync_DetectsModifiedFiles()
    {
        // Arrange
        var workspacePath = Path.Combine(_tempDir, "workspace");
        var filePath = Path.Combine(workspacePath, "src", "Program.cs");
        var options = new IndexingOptions();
        var initialResult = await _indexingService.IndexWorkspaceAsync(workspacePath, options);
        var indexId = initialResult.IndexId;

        // Modify file
        await Task.Delay(100); // Ensure timestamp changes
        File.WriteAllText(filePath, "public class Program { // Modified }");

        // Act
        var updateResult = await _indexingService.UpdateIndexAsync(indexId);

        // Assert
        Assert.True(updateResult.Success);
    }

    [Fact]
    public async Task UpdateIndexAsync_DetectsDeletedFiles()
    {
        // Arrange
        var workspacePath = Path.Combine(_tempDir, "workspace");
        var options = new IndexingOptions();
        var initialResult = await _indexingService.IndexWorkspaceAsync(workspacePath, options);
        var indexId = initialResult.IndexId;

        // Delete file
        File.Delete(Path.Combine(workspacePath, "src", "Service.cs"));

        // Act
        var updateResult = await _indexingService.UpdateIndexAsync(indexId);

        // Assert
        Assert.True(updateResult.Success);
        Assert.True(updateResult.ChunksRemoved > 0);
    }

    #endregion

    #region Cancellation Tests

    [Fact]
    public async Task IndexWorkspaceAsync_RespectsCancellation()
    {
        // Arrange
        var workspacePath = Path.Combine(_tempDir, "workspace");
        var options = new IndexingOptions();
        var cts = new CancellationTokenSource();
        cts.Cancel(); // Cancel immediately

        // Act & Assert
        var result = await _indexingService.IndexWorkspaceAsync(
            workspacePath, options, null, cts.Token);

        Assert.True(result.WasCancelled);
    }

    #endregion

    #region Error Handling Tests

    [Fact]
    public async Task IndexWorkspaceAsync_NonExistentPath_ReturnsFailure()
    {
        // Arrange
        var nonExistentPath = Path.Combine(_tempDir, "nonexistent");
        var options = new IndexingOptions();

        // Act
        var result = await _indexingService.IndexWorkspaceAsync(nonExistentPath, options);

        // Assert
        Assert.False(result.Success);
        Assert.NotNull(result.ErrorMessage);
    }

    [Fact]
    public async Task IndexWorkspaceAsync_ContinuesOnError_WhenEnabled()
    {
        // Arrange
        var workspacePath = Path.Combine(_tempDir, "workspace");
        var options = new IndexingOptions { ContinueOnError = true };

        // Create a file that will fail (binary content)
        File.WriteAllBytes(
            Path.Combine(workspacePath, "corrupt.cs"),
            new byte[] { 0xFF, 0xFE, 0x00, 0x01 });

        // Act
        var result = await _indexingService.IndexWorkspaceAsync(workspacePath, options);

        // Assert - Should complete with some errors but not fail entirely
        Assert.True(result.Success);
        Assert.True(result.FilesErrored > 0 || result.FilesIndexed > 0);
    }

    #endregion
}
```

---

## Additional Test Files (Abbreviated Specifications)

### 6. ChangeDetectorTests.cs
- `DetectChangesAsync_IdentifiesAddedFiles`
- `DetectChangesAsync_IdentifiesModifiedFiles_ByHash`
- `DetectChangesAsync_IdentifiesModifiedFiles_ByTimestamp`
- `DetectChangesAsync_IdentifiesDeletedFiles`
- `DetectChangesAsync_IdentifiesUnchangedFiles`
- `DetectChangesAsync_DetectsRenames_WhenEnabled`
- `DetectChangesAsync_RespectsMinFileAge`
- `HasAnyChangesAsync_ReturnsTrueForDeleted`
- `HasAnyChangesAsync_ReturnsTrueForModified`
- `HasAnyChangesAsync_ReturnsFalseForUnchanged`

### 7. FileScannerTests.cs
- `ScanAsync_ReturnsAllMatchingFiles`
- `ScanAsync_RespectsIncludePatterns`
- `ScanAsync_RespectsExcludePatterns`
- `ScanAsync_RespectsGitignore`
- `ScanAsync_RespectsFileSizeLimits`
- `ScanAsync_RespectsMaxDepth`
- `ScanWithHashesAsync_ComputesHashes`
- `ScanAsync_NonExistentPath_Throws`

### 8. FileProcessorTests.cs
- `ProcessFileAsync_ReturnsChunksWithEmbeddings`
- `ProcessFileAsync_HandlesBinaryFiles`
- `ProcessFileAsync_HandlesEncodingDetection`
- `ProcessFileAsync_ComputesContentHash`
- `ProcessFilesAsync_ProcessesInParallel`
- `ProcessFilesAsync_ReportsProgress`
- `ProcessFilesAsync_ContinuesOnError`
- `ProcessFilesAsync_CollectsAllErrors`

### 9. IndexingEventAggregatorTests.cs
- `AddEvent_AddsToQueue`
- `AddEvent_TrimsOldEvents_WhenOverCapacity`
- `FileStarted_CreatesCorrectEvent`
- `FileCompleted_IncludesChunkCount`
- `GetRecentEvents_ReturnsChronological`
- `GetEventsSince_FiltersCorrectly`
- `GetErrors_ReturnsAllErrorTypes`
- `Clear_EmptiesQueue`

### 10. IndexingMetricsTests.cs
- `RecordFile_UpdatesTotals`
- `RecordFile_AggregatesByLanguage`
- `GetSummary_CalculatesAverages`
- `GetSummary_CalculatesThroughput`
- `GetTopLanguages_ReturnsSorted`
- `GetLargestFiles_ReturnsSorted`
- `Reset_ClearsAllData`
- `RecordFile_IsThreadSafe`

---

## Acceptance Criteria

### Test Coverage Requirements
- [ ] All v0.7.3a-i components have corresponding test files
- [ ] Minimum 80% code coverage for core components
- [ ] All public methods have at least one test
- [ ] Edge cases and error conditions are tested
- [ ] Integration tests cover full pipeline

### Quality Requirements
- [ ] All tests pass consistently (no flaky tests)
- [ ] Tests are isolated (no shared state between tests)
- [ ] Tests use appropriate mocking for dependencies
- [ ] Tests clean up temp files/directories
- [ ] Tests have descriptive names following pattern: `Method_Scenario_ExpectedBehavior`

### Documentation Requirements
- [ ] Each test class has summary documentation
- [ ] Test regions organize tests by functionality
- [ ] Complex test setups are explained with comments

---

## Summary

v0.7.3j completes the Indexing Pipeline by implementing:

| Test File | Test Count | Focus |
|-----------|------------|-------|
| IndexingServiceTests | 15 | Full index, incremental, sync |
| FileProcessorTests | 12 | Read, hash, chunk, embed |
| GitignoreParserTests | 10 | Parse, load, patterns |
| GitignoreMatcherTests | 12 | Match, filter, negation |
| IncrementalIndexerTests | 10 | Changes, process, stats |
| ChangeDetectorTests | 10 | Add/mod/del, hash, rename |
| FileScannerTests | 8 | Scan, patterns, limits |
| IndexingJobQueueTests | 10 | Enqueue, dequeue, priority |
| IndexingJobProcessorTests | 8 | Process, retry, types |
| FileWatcherServiceTests | 10 | Watch, debounce, patterns |
| ProgressTrackerTests | 8 | Progress, rates, estimates |
| IndexingEventAggregatorTests | 8 | Events, trim, retrieve |
| IndexingMetricsTests | 8 | Record, aggregate, summary |
| IndexingOptionsTests | 6 | Defaults, validation |
| IndexingIntegrationTests | 10 | Full pipeline E2E |
| **Total** | **~145** | |

This completes the v0.7.3 Indexing Pipeline milestone with comprehensive test coverage.
