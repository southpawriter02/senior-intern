# Design Specification: AIntern v0.7.2i "Statistics & Health Monitoring"

## Overview

**Version**: v0.7.2i
**Parent**: v0.7.2 Vector Storage
**Focus**: Implement statistics gathering and health monitoring for vector indexes

### Purpose

Implement comprehensive statistics and health monitoring:
1. Implement `GetStatisticsAsync` for per-index statistics
2. Implement `GetOverallStatisticsAsync` for aggregate store statistics
3. Implement `OptimizeAsync` for database maintenance
4. Implement `CheckHealthAsync` for integrity verification
5. Provide background health monitoring service
6. Define statistics models for rich data reporting

### Dependencies

**From v0.7.2b (Vector Index Models)**:
- `VectorIndex` model
- `IndexStatus` enum
- `ChunkType` enum
- `SymbolType` enum
- `FileIndexStatus` enum

**From v0.7.2e (Store Implementation)**:
- `SqliteVectorStore` partial class to extend
- `_writeLock` for thread safety
- `_connection` for database access

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                   v0.7.2i Statistics & Health Monitoring                      │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Component Overview:                                                          │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  SqliteVectorStore.Statistics.cs (partial class extension)               │ │
│  │  ├── GetStatisticsAsync()         ← Per-index statistics                │ │
│  │  ├── GetOverallStatisticsAsync()  ← Aggregate store statistics          │ │
│  │  ├── OptimizeAsync()              ← ANALYZE + VACUUM                    │ │
│  │  └── CheckHealthAsync()           ← Integrity verification              │ │
│  │                                                                          │ │
│  │  VectorStoreHealthService.cs (BackgroundService)                         │ │
│  │  ├── ExecuteAsync()               ← Periodic health check loop          │ │
│  │  └── CheckInterval = 1 hour       ← Configurable interval               │ │
│  │                                                                          │ │
│  │  Models:                                                                  │ │
│  │  ├── IndexStatistics              ← Per-index statistics                │ │
│  │  ├── VectorStoreStatistics        ← Aggregate store statistics          │ │
│  │  └── DatabaseHealthCheck          ← Health check result                 │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Statistics Gathering Flow

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                       GetStatisticsAsync Flow                                 │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Input: indexId                                                              │
│       │                                                                      │
│       ▼                                                                      │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  1. Get Index Metadata                                                   │ │
│  │     index = await GetIndexAsync(indexId)                                 │ │
│  │     → Provides: FileCount, ChunkCount, TotalFileSizeBytes                │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│       │                                                                      │
│       ▼                                                                      │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  2. Query File Statistics by Language                                    │ │
│  │     SELECT language, COUNT(*) FROM indexed_files                         │ │
│  │     WHERE index_id = @indexId AND language IS NOT NULL                   │ │
│  │     GROUP BY language                                                    │ │
│  │     → Produces: { "csharp": 45, "typescript": 23, "python": 12 }        │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│       │                                                                      │
│       ▼                                                                      │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  3. Query Chunk Statistics by Type                                       │ │
│  │     SELECT chunk_type, COUNT(*) FROM chunk_metadata                      │ │
│  │     WHERE index_id = @indexId                                            │ │
│  │     GROUP BY chunk_type                                                  │ │
│  │     → Produces: { Code: 234, Comment: 56, Import: 45 }                  │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│       │                                                                      │
│       ▼                                                                      │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  4. Query Chunk Statistics by Symbol Type                                │ │
│  │     SELECT symbol_type, COUNT(*) FROM chunk_metadata                     │ │
│  │     WHERE index_id = @indexId AND symbol_type IS NOT NULL                │ │
│  │     GROUP BY symbol_type                                                 │ │
│  │     → Produces: { Class: 12, Method: 156, Property: 89 }                │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│       │                                                                      │
│       ▼                                                                      │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  5. Query Average Tokens per Chunk                                       │ │
│  │     SELECT AVG(token_count) FROM chunk_metadata                          │ │
│  │     WHERE index_id = @indexId                                            │ │
│  │     → Produces: 128.5                                                    │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│       │                                                                      │
│       ▼                                                                      │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  6. Query File Status Counts                                             │ │
│  │     SELECT status, COUNT(*) FROM indexed_files                           │ │
│  │     WHERE index_id = @indexId                                            │ │
│  │     GROUP BY status                                                      │ │
│  │     → Produces: FilesWithErrors, SkippedFiles                           │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│       │                                                                      │
│       ▼                                                                      │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  7. Calculate Storage Sizes                                              │ │
│  │     dbSize = File.GetLength(DatabasePath)                                │ │
│  │     vectorDataSize = ChunkCount × EmbeddingDimension × sizeof(float)    │ │
│  │     metadataSize = dbSize - vectorDataSize                               │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│       │                                                                      │
│       ▼                                                                      │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  8. Return IndexStatistics                                               │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Health Check Flow

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                         CheckHealthAsync Flow                                 │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  1. SQLite Integrity Check                                               │ │
│  │     PRAGMA integrity_check                                               │ │
│  │                                                                          │ │
│  │     Expected: "ok"                                                       │ │
│  │     On failure: Add issue, set isHealthy = false                        │ │
│  │                                                                          │ │
│  │     Checks:                                                               │ │
│  │     • Page consistency                                                    │ │
│  │     • B-tree structure integrity                                         │ │
│  │     • Index consistency                                                   │ │
│  │     • Free list integrity                                                 │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│       │                                                                      │
│       ▼                                                                      │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  2. Foreign Key Check                                                    │ │
│  │     PRAGMA foreign_key_check                                             │ │
│  │                                                                          │ │
│  │     Expected: No results                                                  │ │
│  │     On failure: Add violation details, set isHealthy = false            │ │
│  │                                                                          │ │
│  │     Returns: table, rowid, parent, fkid                                  │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│       │                                                                      │
│       ▼                                                                      │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  3. Orphaned Chunk Detection                                             │ │
│  │     SELECT COUNT(*) FROM chunk_metadata cm                               │ │
│  │     LEFT JOIN indexed_files if ON cm.file_id = if.id                    │ │
│  │     WHERE if.id IS NULL                                                  │ │
│  │                                                                          │ │
│  │     Expected: 0                                                          │ │
│  │     On failure: Add warning (not critical)                               │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│       │                                                                      │
│       ▼                                                                      │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  4. Return DatabaseHealthCheck                                           │ │
│  │     • IsHealthy: true if no critical issues                             │ │
│  │     • Issues: List of detected problems                                  │ │
│  │     • CheckedAt: Timestamp                                               │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Database Optimization

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                          OptimizeAsync Flow                                   │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  1. Acquire Write Lock                                                   │ │
│  │     await _writeLock.WaitAsync(ct)                                       │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│       │                                                                      │
│       ▼                                                                      │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  2. ANALYZE                                                              │ │
│  │     Collects statistics about table contents                             │ │
│  │     Used by query planner for optimal execution plans                    │ │
│  │                                                                          │ │
│  │     Updates: sqlite_stat1, sqlite_stat4 tables                           │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│       │                                                                      │
│       ▼                                                                      │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  3. VACUUM                                                               │ │
│  │     Rebuilds database file to reclaim space                              │ │
│  │     Defragments tables and indexes                                       │ │
│  │                                                                          │ │
│  │     Effects:                                                              │ │
│  │     • Reclaims deleted row space                                         │ │
│  │     • Reduces file size                                                  │ │
│  │     • Optimizes storage layout                                           │ │
│  │                                                                          │ │
│  │     Caution:                                                              │ │
│  │     • Requires lock for entire duration                                  │ │
│  │     • Temporarily uses 2× disk space                                    │ │
│  │     • Can be slow for large databases                                    │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│       │                                                                      │
│       ▼                                                                      │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  4. Release Write Lock                                                   │ │
│  │     _writeLock.Release()                                                 │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  When to Run:                                                                 │
│  • After large delete operations                                             │
│  • After bulk imports                                                        │
│  • Periodically (weekly/monthly)                                            │
│  • Before backup                                                             │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Background Health Service

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                    VectorStoreHealthService Architecture                      │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  Lifecycle:                                                               │ │
│  │  ┌────────────┐    ┌────────────┐    ┌────────────┐    ┌────────────┐   │ │
│  │  │ App Start  │ →  │ Wait 1hr   │ →  │ Check      │ →  │ Log Result │   │ │
│  │  └────────────┘    └────────────┘    └────────────┘    └──────┬─────┘   │ │
│  │                         ▲                                      │         │ │
│  │                         └──────────────────────────────────────┘         │ │
│  │                                                                          │ │
│  │                    ┌────────────┐                                        │ │
│  │                    │ App Stop   │ → Exit loop                           │ │
│  │                    └────────────┘                                        │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  Configuration:                                                               │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  Property              │ Default      │ Purpose                         │ │
│  │  ═════════════════════ │ ════════════ │ ═══════════════════════════════ │ │
│  │  CheckInterval         │ 1 hour       │ Time between health checks      │ │
│  │  EnableHealthService   │ true         │ Enable/disable background svc   │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  Logging:                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  Health Status  │ Log Level   │ Message                                 │ │
│  │  ═══════════════│ ═══════════ │ ═══════════════════════════════════════ │ │
│  │  Healthy        │ Debug       │ "Vector store health check passed"      │ │
│  │  Issues Found   │ Warning     │ "Health check found issues: {Issues}"   │ │
│  │  Check Failed   │ Error       │ "Error during vector store health check"│ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Specifications

### 1. SqliteVectorStore.Statistics.cs

**Location**: `src/SeniorIntern.Services/VectorStore/SqliteVectorStore.Statistics.cs`

```csharp
namespace SeniorIntern.Services.VectorStore;

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Data.Sqlite;
using SeniorIntern.Core.Models;

/// <summary>
/// Partial class containing statistics and health monitoring operations.
/// </summary>
public sealed partial class SqliteVectorStore
{
    #region Statistics

    /// <summary>
    /// Gets detailed statistics for a specific index.
    /// </summary>
    /// <param name="indexId">Index ID.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>Index statistics.</returns>
    /// <exception cref="ArgumentException">Index not found.</exception>
    public async Task<IndexStatistics> GetStatisticsAsync(
        string indexId,
        CancellationToken ct = default)
    {
        EnsureInitialized();

        var index = await GetIndexAsync(indexId, ct)
            ?? throw new ArgumentException($"Index not found: {indexId}", nameof(indexId));

        _logger.LogDebug("Gathering statistics for index {IndexId}", indexId);

        // Get file statistics by language
        var filesByLanguage = await GetFilesByLanguageAsync(indexId, ct);

        // Get chunk statistics by type
        var chunksByType = await GetChunksByTypeAsync(indexId, ct);

        // Get chunk statistics by symbol type
        var chunksBySymbolType = await GetChunksBySymbolTypeAsync(indexId, ct);

        // Get average tokens per chunk
        var avgTokens = await GetAverageTokensAsync(indexId, ct);

        // Get files with errors/skipped
        var (filesWithErrors, skippedFiles) = await GetFileStatusCountsAsync(indexId, ct);

        // Calculate storage sizes
        var dbPath = _options.DatabasePath ?? GetDefaultDatabasePath();
        var dbSize = File.Exists(dbPath) ? new FileInfo(dbPath).Length : 0;
        var vectorDataSize = (long)index.ChunkCount * index.EmbeddingDimension * sizeof(float);

        return new IndexStatistics
        {
            IndexId = index.Id,
            IndexName = index.Name,
            TotalFiles = index.FileCount,
            TotalChunks = index.ChunkCount,
            TotalFileSizeBytes = index.TotalFileSizeBytes,
            VectorDataSizeBytes = vectorDataSize,
            MetadataSizeBytes = Math.Max(0, dbSize - vectorDataSize),
            AverageTokensPerChunk = avgTokens,
            FilesByLanguage = filesByLanguage,
            ChunksByType = chunksByType,
            ChunksBySymbolType = chunksBySymbolType,
            FilesWithErrors = filesWithErrors,
            SkippedFiles = skippedFiles,
            LastModified = index.UpdatedAt,
            EmbeddingModel = index.EmbeddingModel,
            EmbeddingDimension = index.EmbeddingDimension
        };
    }

    /// <summary>
    /// Gets aggregate statistics for the entire vector store.
    /// </summary>
    public async Task<VectorStoreStatistics> GetOverallStatisticsAsync(CancellationToken ct = default)
    {
        EnsureInitialized();

        _logger.LogDebug("Gathering overall vector store statistics");

        var indexes = await ListIndexesAsync(ct);
        var indexStats = new List<IndexStatistics>();

        foreach (var index in indexes)
        {
            ct.ThrowIfCancellationRequested();
            indexStats.Add(await GetStatisticsAsync(index.Id, ct));
        }

        var dbPath = _options.DatabasePath ?? GetDefaultDatabasePath();
        var dbSize = File.Exists(dbPath) ? new FileInfo(dbPath).Length : 0;

        return new VectorStoreStatistics
        {
            TotalIndexes = indexes.Count,
            ActiveIndexes = indexes.Count(i => i.Status == IndexStatus.Active),
            TotalFiles = indexStats.Sum(s => s.TotalFiles),
            TotalChunks = indexStats.Sum(s => s.TotalChunks),
            TotalDatabaseSizeBytes = dbSize,
            IndexStats = indexStats
        };
    }

    #endregion

    #region Statistics Queries

    private async Task<Dictionary<string, int>> GetFilesByLanguageAsync(
        string indexId,
        CancellationToken ct)
    {
        var result = new Dictionary<string, int>();

        await using var cmd = _connection!.CreateCommand();
        cmd.CommandText = """
            SELECT language, COUNT(*) as count
            FROM indexed_files
            WHERE index_id = @indexId AND language IS NOT NULL
            GROUP BY language
            """;
        cmd.Parameters.AddWithValue("@indexId", indexId);

        await using var reader = await cmd.ExecuteReaderAsync(ct);
        while (await reader.ReadAsync(ct))
        {
            result[reader.GetString(0)] = reader.GetInt32(1);
        }

        return result;
    }

    private async Task<Dictionary<ChunkType, int>> GetChunksByTypeAsync(
        string indexId,
        CancellationToken ct)
    {
        var result = new Dictionary<ChunkType, int>();

        await using var cmd = _connection!.CreateCommand();
        cmd.CommandText = """
            SELECT chunk_type, COUNT(*) as count
            FROM chunk_metadata
            WHERE index_id = @indexId
            GROUP BY chunk_type
            """;
        cmd.Parameters.AddWithValue("@indexId", indexId);

        await using var reader = await cmd.ExecuteReaderAsync(ct);
        while (await reader.ReadAsync(ct))
        {
            var type = Enum.Parse<ChunkType>(reader.GetString(0));
            result[type] = reader.GetInt32(1);
        }

        return result;
    }

    private async Task<Dictionary<SymbolType, int>> GetChunksBySymbolTypeAsync(
        string indexId,
        CancellationToken ct)
    {
        var result = new Dictionary<SymbolType, int>();

        await using var cmd = _connection!.CreateCommand();
        cmd.CommandText = """
            SELECT symbol_type, COUNT(*) as count
            FROM chunk_metadata
            WHERE index_id = @indexId AND symbol_type IS NOT NULL
            GROUP BY symbol_type
            """;
        cmd.Parameters.AddWithValue("@indexId", indexId);

        await using var reader = await cmd.ExecuteReaderAsync(ct);
        while (await reader.ReadAsync(ct))
        {
            var type = Enum.Parse<SymbolType>(reader.GetString(0));
            result[type] = reader.GetInt32(1);
        }

        return result;
    }

    private async Task<double> GetAverageTokensAsync(string indexId, CancellationToken ct)
    {
        await using var cmd = _connection!.CreateCommand();
        cmd.CommandText = """
            SELECT AVG(token_count)
            FROM chunk_metadata
            WHERE index_id = @indexId
            """;
        cmd.Parameters.AddWithValue("@indexId", indexId);

        var result = await cmd.ExecuteScalarAsync(ct);
        return result is double avg ? avg : 0;
    }

    private async Task<(int Errors, int Skipped)> GetFileStatusCountsAsync(
        string indexId,
        CancellationToken ct)
    {
        int errors = 0, skipped = 0;

        await using var cmd = _connection!.CreateCommand();
        cmd.CommandText = """
            SELECT status, COUNT(*) as count
            FROM indexed_files
            WHERE index_id = @indexId
            GROUP BY status
            """;
        cmd.Parameters.AddWithValue("@indexId", indexId);

        await using var reader = await cmd.ExecuteReaderAsync(ct);
        while (await reader.ReadAsync(ct))
        {
            var status = Enum.Parse<FileIndexStatus>(reader.GetString(0));
            var count = reader.GetInt32(1);

            if (status == FileIndexStatus.Error)
                errors = count;
            else if (status == FileIndexStatus.Skipped)
                skipped = count;
        }

        return (errors, skipped);
    }

    #endregion

    #region Optimization

    /// <summary>
    /// Performs database maintenance (ANALYZE + VACUUM).
    /// </summary>
    /// <remarks>
    /// This operation may take significant time for large databases
    /// and temporarily requires 2× disk space.
    /// </remarks>
    public async Task OptimizeAsync(CancellationToken ct = default)
    {
        EnsureInitialized();

        _logger.LogInformation("Running database optimization...");

        await _writeLock.WaitAsync(ct);
        try
        {
            var sw = System.Diagnostics.Stopwatch.StartNew();

            // Analyze tables for query optimization
            await using (var cmd = _connection!.CreateCommand())
            {
                cmd.CommandText = "ANALYZE";
                await cmd.ExecuteNonQueryAsync(ct);
            }

            _logger.LogDebug("ANALYZE completed in {Elapsed}ms", sw.ElapsedMilliseconds);

            // Vacuum to reclaim space
            var beforeSize = GetDatabaseSize();
            await using (var cmd = _connection.CreateCommand())
            {
                cmd.CommandText = "VACUUM";
                await cmd.ExecuteNonQueryAsync(ct);
            }
            var afterSize = GetDatabaseSize();

            sw.Stop();

            _logger.LogInformation(
                "Database optimization complete in {Elapsed}ms. Size: {Before} → {After} ({Saved} saved)",
                sw.ElapsedMilliseconds,
                FormatBytes(beforeSize),
                FormatBytes(afterSize),
                FormatBytes(beforeSize - afterSize));
        }
        finally
        {
            _writeLock.Release();
        }
    }

    private long GetDatabaseSize()
    {
        var dbPath = _options.DatabasePath ?? GetDefaultDatabasePath();
        return File.Exists(dbPath) ? new FileInfo(dbPath).Length : 0;
    }

    private static string FormatBytes(long bytes)
    {
        return bytes switch
        {
            < 1024 => $"{bytes} B",
            < 1024 * 1024 => $"{bytes / 1024.0:F1} KB",
            < 1024 * 1024 * 1024 => $"{bytes / (1024.0 * 1024):F1} MB",
            _ => $"{bytes / (1024.0 * 1024 * 1024):F2} GB"
        };
    }

    #endregion

    #region Health Check

    /// <summary>
    /// Checks database integrity and health.
    /// </summary>
    /// <returns>Health check result.</returns>
    public async Task<DatabaseHealthCheck> CheckHealthAsync(CancellationToken ct = default)
    {
        EnsureInitialized();

        _logger.LogDebug("Running database health check");

        var issues = new List<string>();
        var isHealthy = true;

        // Check SQLite integrity
        await using (var cmd = _connection!.CreateCommand())
        {
            cmd.CommandText = "PRAGMA integrity_check";
            await using var reader = await cmd.ExecuteReaderAsync(ct);

            while (await reader.ReadAsync(ct))
            {
                var result = reader.GetString(0);
                if (result != "ok")
                {
                    issues.Add($"Integrity check: {result}");
                    isHealthy = false;
                    _logger.LogError("Database integrity check failed: {Result}", result);
                }
            }
        }

        // Check foreign key violations
        await using (var cmd = _connection.CreateCommand())
        {
            cmd.CommandText = "PRAGMA foreign_key_check";
            await using var reader = await cmd.ExecuteReaderAsync(ct);

            while (await reader.ReadAsync(ct))
            {
                var table = reader.GetString(0);
                issues.Add($"Foreign key violation in {table}");
                isHealthy = false;
                _logger.LogError("Foreign key violation in table {Table}", table);
            }
        }

        // Check for orphaned chunks (chunks without files)
        await using (var cmd = _connection.CreateCommand())
        {
            cmd.CommandText = """
                SELECT COUNT(*) FROM chunk_metadata cm
                LEFT JOIN indexed_files if ON cm.file_id = if.id
                WHERE if.id IS NULL
                """;

            var orphanedChunks = Convert.ToInt32(await cmd.ExecuteScalarAsync(ct));
            if (orphanedChunks > 0)
            {
                issues.Add($"Found {orphanedChunks} orphaned chunks");
                _logger.LogWarning("Found {Count} orphaned chunks", orphanedChunks);
            }
        }

        var result = new DatabaseHealthCheck
        {
            IsHealthy = isHealthy,
            Issues = issues,
            CheckedAt = DateTime.UtcNow
        };

        if (isHealthy)
            _logger.LogDebug("Database health check passed");
        else
            _logger.LogWarning("Database health check found {Count} issues", issues.Count);

        return result;
    }

    #endregion
}
```

### 2. VectorStoreHealthService.cs

**Location**: `src/SeniorIntern.Services/VectorStore/VectorStoreHealthService.cs`

```csharp
namespace SeniorIntern.Services.VectorStore;

using System;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;

/// <summary>
/// Background service for periodic health monitoring of vector store.
/// </summary>
public sealed class VectorStoreHealthService : BackgroundService
{
    private readonly IVectorStore _vectorStore;
    private readonly ILogger<VectorStoreHealthService> _logger;
    private readonly TimeSpan _checkInterval;

    /// <summary>
    /// Initializes a new instance of the health service.
    /// </summary>
    /// <param name="vectorStore">Vector store to monitor.</param>
    /// <param name="logger">Logger instance.</param>
    /// <param name="checkInterval">Optional check interval (default: 1 hour).</param>
    public VectorStoreHealthService(
        IVectorStore vectorStore,
        ILogger<VectorStoreHealthService> logger,
        TimeSpan? checkInterval = null)
    {
        _vectorStore = vectorStore ?? throw new ArgumentNullException(nameof(vectorStore));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _checkInterval = checkInterval ?? TimeSpan.FromHours(1);
    }

    /// <inheritdoc />
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        _logger.LogInformation(
            "Vector store health monitoring started (interval: {Interval})",
            _checkInterval);

        // Initial delay to let the application start up
        await Task.Delay(TimeSpan.FromSeconds(30), stoppingToken).ConfigureAwait(false);

        while (!stoppingToken.IsCancellationRequested)
        {
            try
            {
                await PerformHealthCheckAsync(stoppingToken);
                await Task.Delay(_checkInterval, stoppingToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                // Expected during shutdown
                break;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error during vector store health check");

                // Wait before retrying after an error
                await Task.Delay(TimeSpan.FromMinutes(5), stoppingToken).ConfigureAwait(false);
            }
        }

        _logger.LogInformation("Vector store health monitoring stopped");
    }

    private async Task PerformHealthCheckAsync(CancellationToken ct)
    {
        if (_vectorStore is not SqliteVectorStore sqliteStore)
        {
            _logger.LogDebug("Health check skipped: vector store is not SqliteVectorStore");
            return;
        }

        var health = await sqliteStore.CheckHealthAsync(ct);

        if (health.IsHealthy)
        {
            _logger.LogDebug("Vector store health check passed at {Time}", health.CheckedAt);
        }
        else
        {
            _logger.LogWarning(
                "Vector store health check found {Count} issues: {Issues}",
                health.Issues.Count,
                string.Join(", ", health.Issues));

            // Could emit events or metrics here for alerting
        }
    }
}
```

### 3. IndexStatistics.cs

**Location**: `src/SeniorIntern.Core/Models/IndexStatistics.cs`

```csharp
namespace SeniorIntern.Core.Models;

using System;
using System.Collections.Generic;

/// <summary>
/// Statistics for a single vector index.
/// </summary>
public sealed class IndexStatistics
{
    /// <summary>
    /// ID of the index.
    /// </summary>
    public required string IndexId { get; init; }

    /// <summary>
    /// Name of the index.
    /// </summary>
    public required string IndexName { get; init; }

    /// <summary>
    /// Total number of indexed files.
    /// </summary>
    public int TotalFiles { get; init; }

    /// <summary>
    /// Total number of stored chunks.
    /// </summary>
    public int TotalChunks { get; init; }

    /// <summary>
    /// Total size of indexed files in bytes.
    /// </summary>
    public long TotalFileSizeBytes { get; init; }

    /// <summary>
    /// Size of the vector data in bytes.
    /// </summary>
    public long VectorDataSizeBytes { get; init; }

    /// <summary>
    /// Size of metadata in bytes.
    /// </summary>
    public long MetadataSizeBytes { get; init; }

    /// <summary>
    /// Total database size in bytes.
    /// </summary>
    public long TotalDatabaseSizeBytes => VectorDataSizeBytes + MetadataSizeBytes;

    /// <summary>
    /// Average chunks per file.
    /// </summary>
    public double AverageChunksPerFile => TotalFiles > 0
        ? (double)TotalChunks / TotalFiles
        : 0;

    /// <summary>
    /// Average tokens per chunk.
    /// </summary>
    public double AverageTokensPerChunk { get; init; }

    /// <summary>
    /// File count by programming language.
    /// </summary>
    public IReadOnlyDictionary<string, int> FilesByLanguage { get; init; } =
        new Dictionary<string, int>();

    /// <summary>
    /// Chunk count by type.
    /// </summary>
    public IReadOnlyDictionary<ChunkType, int> ChunksByType { get; init; } =
        new Dictionary<ChunkType, int>();

    /// <summary>
    /// Chunk count by symbol type.
    /// </summary>
    public IReadOnlyDictionary<SymbolType, int> ChunksBySymbolType { get; init; } =
        new Dictionary<SymbolType, int>();

    /// <summary>
    /// Number of files with errors.
    /// </summary>
    public int FilesWithErrors { get; init; }

    /// <summary>
    /// Number of skipped files.
    /// </summary>
    public int SkippedFiles { get; init; }

    /// <summary>
    /// When statistics were calculated.
    /// </summary>
    public DateTime CalculatedAt { get; init; } = DateTime.UtcNow;

    /// <summary>
    /// When the index was last modified.
    /// </summary>
    public DateTime LastModified { get; init; }

    /// <summary>
    /// Embedding model used.
    /// </summary>
    public required string EmbeddingModel { get; init; }

    /// <summary>
    /// Embedding dimension.
    /// </summary>
    public int EmbeddingDimension { get; init; }

    /// <summary>
    /// Formats total file size for display.
    /// </summary>
    public string FormattedFileSize => FormatBytes(TotalFileSizeBytes);

    /// <summary>
    /// Formats database size for display.
    /// </summary>
    public string FormattedDatabaseSize => FormatBytes(TotalDatabaseSizeBytes);

    private static string FormatBytes(long bytes)
    {
        string[] suffixes = ["B", "KB", "MB", "GB"];
        int i = 0;
        double size = bytes;
        while (size >= 1024 && i < suffixes.Length - 1)
        {
            size /= 1024;
            i++;
        }
        return $"{size:F2} {suffixes[i]}";
    }
}
```

### 4. VectorStoreStatistics.cs

**Location**: `src/SeniorIntern.Core/Models/VectorStoreStatistics.cs`

```csharp
namespace SeniorIntern.Core.Models;

using System;
using System.Collections.Generic;

/// <summary>
/// Aggregate statistics for the entire vector store.
/// </summary>
public sealed class VectorStoreStatistics
{
    /// <summary>
    /// Total number of indexes.
    /// </summary>
    public int TotalIndexes { get; init; }

    /// <summary>
    /// Number of active indexes.
    /// </summary>
    public int ActiveIndexes { get; init; }

    /// <summary>
    /// Total files across all indexes.
    /// </summary>
    public int TotalFiles { get; init; }

    /// <summary>
    /// Total chunks across all indexes.
    /// </summary>
    public int TotalChunks { get; init; }

    /// <summary>
    /// Total database size in bytes.
    /// </summary>
    public long TotalDatabaseSizeBytes { get; init; }

    /// <summary>
    /// Statistics per index.
    /// </summary>
    public IReadOnlyList<IndexStatistics> IndexStats { get; init; } = [];

    /// <summary>
    /// When statistics were calculated.
    /// </summary>
    public DateTime CalculatedAt { get; init; } = DateTime.UtcNow;

    /// <summary>
    /// Formats database size for display.
    /// </summary>
    public string FormattedDatabaseSize => FormatBytes(TotalDatabaseSizeBytes);

    private static string FormatBytes(long bytes)
    {
        string[] suffixes = ["B", "KB", "MB", "GB"];
        int i = 0;
        double size = bytes;
        while (size >= 1024 && i < suffixes.Length - 1)
        {
            size /= 1024;
            i++;
        }
        return $"{size:F2} {suffixes[i]}";
    }
}
```

### 5. DatabaseHealthCheck.cs

**Location**: `src/SeniorIntern.Core/Models/DatabaseHealthCheck.cs`

```csharp
namespace SeniorIntern.Core.Models;

using System;
using System.Collections.Generic;

/// <summary>
/// Result of database health check.
/// </summary>
public sealed class DatabaseHealthCheck
{
    /// <summary>
    /// Whether the database is healthy.
    /// </summary>
    public bool IsHealthy { get; init; }

    /// <summary>
    /// List of detected issues.
    /// </summary>
    public IReadOnlyList<string> Issues { get; init; } = [];

    /// <summary>
    /// When the check was performed.
    /// </summary>
    public DateTime CheckedAt { get; init; }

    /// <summary>
    /// Whether there are any issues.
    /// </summary>
    public bool HasIssues => Issues.Count > 0;

    /// <summary>
    /// Summary message for display.
    /// </summary>
    public string Summary => IsHealthy
        ? "Database is healthy"
        : $"Database has {Issues.Count} issue(s)";
}
```

---

## Unit Test Plan

| Test | Description |
|------|-------------|
| `GetStatisticsAsync_ReturnsCorrectCounts` | File/chunk counts |
| `GetStatisticsAsync_GroupsByLanguage` | Language distribution |
| `GetStatisticsAsync_GroupsByChunkType` | Chunk type distribution |
| `GetStatisticsAsync_GroupsBySymbolType` | Symbol distribution |
| `GetStatisticsAsync_CalculatesAverageTokens` | Token average |
| `GetStatisticsAsync_CalculatesStorageSizes` | Size calculations |
| `GetStatisticsAsync_IndexNotFound_Throws` | Error handling |
| `GetOverallStatisticsAsync_AggregatesAllIndexes` | Aggregation |
| `GetOverallStatisticsAsync_CalculatesTotals` | Total counts |
| `OptimizeAsync_RunsAnalyze` | ANALYZE execution |
| `OptimizeAsync_RunsVacuum` | VACUUM execution |
| `CheckHealthAsync_Healthy_ReturnsOk` | Healthy database |
| `CheckHealthAsync_IntegrityFailure_ReportsIssue` | Integrity issue |
| `CheckHealthAsync_ForeignKeyViolation_ReportsIssue` | FK violation |
| `CheckHealthAsync_OrphanedChunks_ReportsWarning` | Orphan detection |
| `VectorStoreHealthService_RunsPeriodically` | Background loop |

---

## File Summary

| File | Location | Purpose | Lines |
|------|----------|---------|-------|
| `SqliteVectorStore.Statistics.cs` | `Services/VectorStore/` | Statistics & health ops | ~250 |
| `VectorStoreHealthService.cs` | `Services/VectorStore/` | Background health svc | ~80 |
| `IndexStatistics.cs` | `Core/Models/` | Per-index statistics | ~100 |
| `VectorStoreStatistics.cs` | `Core/Models/` | Aggregate statistics | ~50 |
| `DatabaseHealthCheck.cs` | `Core/Models/` | Health check result | ~40 |

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | `GetStatisticsAsync` returns accurate file/chunk counts |
| AC-2 | Language distribution is correctly calculated |
| AC-3 | Chunk/symbol type distributions are accurate |
| AC-4 | Average tokens is calculated correctly |
| AC-5 | Storage size estimates are reasonable |
| AC-6 | `GetOverallStatisticsAsync` aggregates across indexes |
| AC-7 | `OptimizeAsync` executes ANALYZE and VACUUM |
| AC-8 | `CheckHealthAsync` detects integrity issues |
| AC-9 | `CheckHealthAsync` detects FK violations |
| AC-10 | Background health service runs periodically |

---

## Changelog Entry

```markdown
## v0.7.2i - Statistics & Health Monitoring

### Added
- `SqliteVectorStore.Statistics.cs` partial class
  - `GetStatisticsAsync()` - Per-index statistics
    - Files/chunks by language
    - Chunks by type and symbol type
    - Average tokens per chunk
    - File status counts (errors, skipped)
    - Storage size estimates
  - `GetOverallStatisticsAsync()` - Aggregate store statistics
  - `OptimizeAsync()` - Database maintenance (ANALYZE + VACUUM)
  - `CheckHealthAsync()` - Integrity verification
    - SQLite integrity_check
    - Foreign key validation
    - Orphaned chunk detection

- `VectorStoreHealthService.cs` background service
  - Periodic health checks (default: 1 hour)
  - Automatic logging of issues
  - Graceful shutdown handling

- Models:
  - `IndexStatistics` - Per-index statistics
  - `VectorStoreStatistics` - Aggregate statistics
  - `DatabaseHealthCheck` - Health check result

### Features
- Automatic storage size estimation (vector + metadata)
- Language and type distribution analysis
- Computed properties for formatting
- Rich logging throughout
```

---

## Timeline Estimate

| Version | Estimated Effort |
|---------|------------------|
| v0.7.2i | 0.75 day |
