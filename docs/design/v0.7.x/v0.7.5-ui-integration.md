# Design Specification: AIntern v0.7.5 "UI & Integration"

## Overview

This document provides a comprehensive design specification for v0.7.5 of The Senior Intern project. This version creates the user interface for index management, implements auto-indexing with file watching, adds RAG settings to the application configuration, and polishes the overall user experience for the RAG feature set.

### Objectives
- Create the Index Manager dialog for controlling indexing operations
- Implement the Indexing Progress dialog with real-time updates
- Build RAG status indicator for the main window
- Add RAG settings panel to application settings
- Implement auto-indexing with file system watching
- Create workspace selector for multi-project support
- Polish UX with notifications, tooltips, and keyboard shortcuts
- Integrate RAG toggle into the chat interface

### Prerequisites
- v0.7.1 (Embedding Foundation) completed - provides embedding service
- v0.7.2 (Vector Storage) completed - provides vector store operations
- v0.7.3 (Indexing Pipeline) completed - provides indexing service
- v0.7.4 (Retrieval & Context) completed - provides knowledge service
- Avalonia UI framework understanding
- MVVM pattern with CommunityToolkit.Mvvm

### Architecture Context

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         Desktop Application                              │
├─────────────────────────────────────────────────────────────────────────┤
│  ┌──────────────────┐  ┌──────────────────┐  ┌──────────────────────┐  │
│  │   MainWindow     │  │  Settings Panel  │  │   Chat Interface     │  │
│  │                  │  │                  │  │                      │  │
│  │ ┌──────────────┐ │  │ ┌──────────────┐ │  │ ┌──────────────────┐ │  │
│  │ │RAG Status    │ │  │ │RAG Settings  │ │  │ │RAG Toggle Button │ │  │
│  │ │Indicator     │ │  │ │Tab           │ │  │ │                  │ │  │
│  │ └──────────────┘ │  │ └──────────────┘ │  │ └──────────────────┘ │  │
│  └──────────────────┘  └──────────────────┘  └──────────────────────┘  │
│           │                     │                      │               │
│           └─────────────────────┼──────────────────────┘               │
│                                 ▼                                       │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │                    Index Manager Dialog                            │ │
│  │  ┌─────────────┐  ┌─────────────┐  ┌──────────────────────────┐  │ │
│  │  │Index Status │  │Model Config │  │    File Filters          │  │ │
│  │  │Panel        │  │Panel        │  │    Panel                 │  │ │
│  │  └─────────────┘  └─────────────┘  └──────────────────────────┘  │ │
│  │  ┌───────────────────────────────────────────────────────────┐   │ │
│  │  │              Action Buttons (Reindex, Update, Clear)      │   │ │
│  │  └───────────────────────────────────────────────────────────┘   │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                 │                                       │
│                                 ▼                                       │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │                  Indexing Progress Dialog                          │ │
│  │  ┌─────────────┐  ┌─────────────┐  ┌──────────────────────────┐  │ │
│  │  │Progress Bar │  │Statistics   │  │    Activity Log          │  │ │
│  │  └─────────────┘  └─────────────┘  └──────────────────────────┘  │ │
│  └───────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                        Services Layer                                    │
│  ┌──────────────────┐  ┌──────────────────┐  ┌──────────────────────┐  │
│  │ IKnowledgeService│  │ IIndexingService │  │ IFileWatcherService  │  │
│  └──────────────────┘  └──────────────────┘  └──────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## Sub-version Breakdown

| Version | Focus | Files to Create | Files to Modify |
|---------|-------|-----------------|-----------------|
| v0.7.5a | RAG Settings Model & Storage | 3 | 1 |
| v0.7.5b | Index Manager Dialog UI | 3 | 0 |
| v0.7.5c | Index Manager ViewModel | 2 | 0 |
| v0.7.5d | Indexing Progress Dialog | 3 | 0 |
| v0.7.5e | RAG Status Indicator Control | 3 | 1 |
| v0.7.5f | RAG Settings Panel | 3 | 1 |
| v0.7.5g | Auto-Indexing File Watcher | 3 | 0 |
| v0.7.5h | Chat Interface RAG Integration | 2 | 2 |
| v0.7.5i | Workspace Selector | 3 | 1 |
| v0.7.5j | Unit Testing & Integration | 8 | 0 |

**Totals: 33 files to create, 6 files to modify**

---

## v0.7.5a: RAG Settings Model & Storage

### Objective
Define the RAG settings model and integrate it with the application's settings storage system.

### File: `src/SeniorIntern.Core/Models/RagSettings.cs`

```csharp
using System;
using System.Collections.Generic;
using System.Text.Json.Serialization;

namespace SeniorIntern.Core.Models;

/// <summary>
/// Configuration settings for RAG (Retrieval-Augmented Generation) functionality.
/// Persisted as part of application settings.
/// </summary>
public sealed class RagSettings
{
    /// <summary>
    /// Whether RAG functionality is enabled globally.
    /// Default: true
    /// </summary>
    public bool Enabled { get; set; } = true;

    /// <summary>
    /// Path to the embedding model file (GGUF or ONNX).
    /// </summary>
    public string? EmbeddingModelPath { get; set; }

    /// <summary>
    /// Type of embedding model (auto-detected from extension if not specified).
    /// </summary>
    [JsonConverter(typeof(JsonStringEnumConverter))]
    public EmbeddingModelType? EmbeddingModelType { get; set; }

    /// <summary>
    /// Whether to automatically index files when they change.
    /// Default: true
    /// </summary>
    public bool AutoIndexEnabled { get; set; } = true;

    /// <summary>
    /// Delay in seconds before auto-indexing changed files (debounce).
    /// Default: 2
    /// </summary>
    public int AutoIndexDelaySeconds { get; set; } = 2;

    /// <summary>
    /// Whether to respect .gitignore when indexing.
    /// Default: true
    /// </summary>
    public bool RespectGitignore { get; set; } = true;

    /// <summary>
    /// Whether to index hidden files and directories.
    /// Default: false
    /// </summary>
    public bool IndexHiddenFiles { get; set; } = false;

    /// <summary>
    /// Target chunk size in tokens.
    /// Default: 512
    /// </summary>
    public int ChunkSize { get; set; } = 512;

    /// <summary>
    /// Overlap between consecutive chunks in tokens.
    /// Default: 64
    /// </summary>
    public int ChunkOverlap { get; set; } = 64;

    /// <summary>
    /// Maximum file size to index in kilobytes.
    /// Files larger than this are skipped.
    /// Default: 1024 (1MB)
    /// </summary>
    public int MaxFileSizeKb { get; set; } = 1024;

    /// <summary>
    /// File patterns to include in indexing (glob patterns).
    /// Default: Common code file extensions
    /// </summary>
    public List<string> IncludePatterns { get; set; } = new()
    {
        "**/*.cs",
        "**/*.ts",
        "**/*.tsx",
        "**/*.js",
        "**/*.jsx",
        "**/*.py",
        "**/*.java",
        "**/*.go",
        "**/*.rs",
        "**/*.cpp",
        "**/*.c",
        "**/*.h",
        "**/*.hpp",
        "**/*.md",
        "**/*.json",
        "**/*.yaml",
        "**/*.yml",
        "**/*.xml",
        "**/*.html",
        "**/*.css",
        "**/*.scss"
    };

    /// <summary>
    /// File patterns to exclude from indexing (glob patterns).
    /// Default: Common build/dependency directories
    /// </summary>
    public List<string> ExcludePatterns { get; set; } = new()
    {
        "**/node_modules/**",
        "**/bin/**",
        "**/obj/**",
        "**/.git/**",
        "**/dist/**",
        "**/build/**",
        "**/target/**",
        "**/__pycache__/**",
        "**/.venv/**",
        "**/vendor/**",
        "**/*.min.js",
        "**/*.min.css",
        "**/package-lock.json",
        "**/yarn.lock"
    };

    /// <summary>
    /// Enable RAG context in chat by default.
    /// Default: true
    /// </summary>
    public bool EnableRagInChat { get; set; } = true;

    /// <summary>
    /// Maximum tokens for RAG context in chat prompts.
    /// Default: 4000
    /// </summary>
    public int MaxRagContextTokens { get; set; } = 4000;

    /// <summary>
    /// Maximum chunks to retrieve for context.
    /// Default: 10
    /// </summary>
    public int MaxRagChunks { get; set; } = 10;

    /// <summary>
    /// Minimum relevance score for including chunks (0.0 to 1.0).
    /// Default: 0.5
    /// </summary>
    public float MinRelevanceScore { get; set; } = 0.5f;

    /// <summary>
    /// Reranking strategy to use for search results.
    /// Default: KeywordBoost
    /// </summary>
    [JsonConverter(typeof(JsonStringEnumConverter))]
    public RerankingStrategy RerankingStrategy { get; set; } = RerankingStrategy.KeywordBoost;

    /// <summary>
    /// Show RAG status indicator in the main window.
    /// Default: true
    /// </summary>
    public bool ShowStatusIndicator { get; set; } = true;

    /// <summary>
    /// Show notifications for indexing events.
    /// Default: true
    /// </summary>
    public bool ShowIndexingNotifications { get; set; } = true;

    /// <summary>
    /// Last workspace path that was indexed.
    /// Used to restore state on startup.
    /// </summary>
    public string? LastWorkspacePath { get; set; }

    /// <summary>
    /// Create default settings.
    /// </summary>
    public static RagSettings Default => new();

    /// <summary>
    /// Validate settings and return any errors.
    /// </summary>
    public IReadOnlyList<string> Validate()
    {
        var errors = new List<string>();

        if (ChunkSize < 100 || ChunkSize > 2000)
            errors.Add("Chunk size must be between 100 and 2000 tokens");

        if (ChunkOverlap < 0 || ChunkOverlap >= ChunkSize)
            errors.Add("Chunk overlap must be between 0 and chunk size");

        if (MaxFileSizeKb < 1 || MaxFileSizeKb > 10240)
            errors.Add("Max file size must be between 1 KB and 10 MB");

        if (MaxRagContextTokens < 500 || MaxRagContextTokens > 16000)
            errors.Add("Max RAG context tokens must be between 500 and 16000");

        if (MinRelevanceScore < 0 || MinRelevanceScore > 1)
            errors.Add("Min relevance score must be between 0 and 1");

        if (AutoIndexDelaySeconds < 1 || AutoIndexDelaySeconds > 60)
            errors.Add("Auto index delay must be between 1 and 60 seconds");

        return errors;
    }
}

/// <summary>
/// Type of embedding model.
/// </summary>
public enum EmbeddingModelType
{
    /// <summary>
    /// GGUF format (llama.cpp compatible).
    /// </summary>
    Gguf,

    /// <summary>
    /// ONNX format.
    /// </summary>
    Onnx
}
```

### File: `src/SeniorIntern.Core/Models/WorkspaceIndexInfo.cs`

```csharp
using System;
using System.Collections.Generic;

namespace SeniorIntern.Core.Models;

/// <summary>
/// Information about an indexed workspace.
/// </summary>
public sealed class WorkspaceIndexInfo
{
    /// <summary>
    /// Unique identifier for the index.
    /// </summary>
    public string IndexId { get; init; } = string.Empty;

    /// <summary>
    /// Path to the workspace directory.
    /// </summary>
    public string WorkspacePath { get; init; } = string.Empty;

    /// <summary>
    /// Display name for the workspace.
    /// </summary>
    public string DisplayName { get; init; } = string.Empty;

    /// <summary>
    /// When the workspace was first indexed.
    /// </summary>
    public DateTime CreatedAt { get; init; }

    /// <summary>
    /// When the index was last updated.
    /// </summary>
    public DateTime LastUpdated { get; init; }

    /// <summary>
    /// Total number of indexed files.
    /// </summary>
    public int FileCount { get; init; }

    /// <summary>
    /// Total number of chunks in the index.
    /// </summary>
    public int ChunkCount { get; init; }

    /// <summary>
    /// Size of the index in bytes.
    /// </summary>
    public long IndexSizeBytes { get; init; }

    /// <summary>
    /// Embedding model used for this index.
    /// </summary>
    public string? EmbeddingModel { get; init; }

    /// <summary>
    /// Embedding dimension.
    /// </summary>
    public int EmbeddingDimension { get; init; }

    /// <summary>
    /// Whether this is the currently active workspace.
    /// </summary>
    public bool IsActive { get; set; }

    /// <summary>
    /// Number of files that have changed since last update.
    /// </summary>
    public int StaleFileCount { get; init; }

    /// <summary>
    /// Human-readable index size.
    /// </summary>
    public string FormattedSize => FormatBytes(IndexSizeBytes);

    /// <summary>
    /// Human-readable last update time.
    /// </summary>
    public string FormattedLastUpdate => FormatTimeAgo(LastUpdated);

    private static string FormatBytes(long bytes)
    {
        return bytes switch
        {
            < 1024 => $"{bytes} B",
            < 1024 * 1024 => $"{bytes / 1024.0:F1} KB",
            < 1024 * 1024 * 1024 => $"{bytes / (1024.0 * 1024):F1} MB",
            _ => $"{bytes / (1024.0 * 1024 * 1024):F2} GB"
        };
    }

    private static string FormatTimeAgo(DateTime dateTime)
    {
        var elapsed = DateTime.UtcNow - dateTime;

        return elapsed switch
        {
            { TotalMinutes: < 1 } => "Just now",
            { TotalMinutes: < 60 } => $"{(int)elapsed.TotalMinutes}m ago",
            { TotalHours: < 24 } => $"{(int)elapsed.TotalHours}h ago",
            { TotalDays: < 7 } => $"{(int)elapsed.TotalDays}d ago",
            _ => dateTime.ToLocalTime().ToString("MMM d, yyyy")
        };
    }
}
```

### File: `src/SeniorIntern.Services/Settings/IRagSettingsService.cs`

```csharp
using System.Threading;
using System.Threading.Tasks;
using SeniorIntern.Core.Models;

namespace SeniorIntern.Services.Settings;

/// <summary>
/// Service for managing RAG settings.
/// </summary>
public interface IRagSettingsService
{
    /// <summary>
    /// Get current RAG settings.
    /// </summary>
    Task<RagSettings> GetSettingsAsync(CancellationToken ct = default);

    /// <summary>
    /// Save RAG settings.
    /// </summary>
    Task SaveSettingsAsync(RagSettings settings, CancellationToken ct = default);

    /// <summary>
    /// Reset settings to defaults.
    /// </summary>
    Task ResetToDefaultsAsync(CancellationToken ct = default);

    /// <summary>
    /// Event raised when settings change.
    /// </summary>
    event System.EventHandler<RagSettings>? SettingsChanged;
}
```

### File to Modify: `src/SeniorIntern.Core/Models/AppSettings.cs`

Add RAG settings property:

```csharp
// Add to existing AppSettings class:

/// <summary>
/// RAG (Retrieval-Augmented Generation) settings.
/// </summary>
public RagSettings Rag { get; set; } = new();
```

### Dependencies
- `RerankingStrategy` enum from v0.7.4

### Implementation Notes
1. Settings are serialized as JSON within the main app settings
2. Validation prevents invalid configurations
3. Default patterns cover common programming languages
4. `IRagSettingsService` provides reactive updates via events

---

## v0.7.5b: Index Manager Dialog UI

### Objective
Create the main dialog for managing knowledge indexes with status display, configuration, and action buttons.

### File: `src/SeniorIntern.Desktop/Views/Dialogs/IndexManagerDialog.axaml`

```xml
<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:vm="using:SeniorIntern.Desktop.ViewModels"
        xmlns:controls="using:SeniorIntern.Desktop.Controls"
        mc:Ignorable="d"
        x:Class="SeniorIntern.Desktop.Views.Dialogs.IndexManagerDialog"
        x:DataType="vm:IndexManagerViewModel"
        Title="Knowledge Index Manager"
        Width="650"
        Height="700"
        MinWidth="550"
        MinHeight="600"
        WindowStartupLocation="CenterOwner"
        CanResize="True">

    <Window.Styles>
        <Style Selector="TextBlock.SectionHeader">
            <Setter Property="FontWeight" Value="SemiBold"/>
            <Setter Property="FontSize" Value="14"/>
            <Setter Property="Margin" Value="0,0,0,8"/>
        </Style>
        <Style Selector="Border.SectionBorder">
            <Setter Property="BorderBrush" Value="{DynamicResource SystemControlForegroundBaseMediumLowBrush}"/>
            <Setter Property="BorderThickness" Value="1"/>
            <Setter Property="CornerRadius" Value="4"/>
            <Setter Property="Padding" Value="12"/>
            <Setter Property="Margin" Value="0,0,0,16"/>
        </Style>
    </Window.Styles>

    <Grid RowDefinitions="Auto,*,Auto">
        <!-- Header -->
        <Border Grid.Row="0"
                Background="{DynamicResource SystemControlBackgroundChromeMediumBrush}"
                Padding="16">
            <StackPanel>
                <TextBlock Text="Knowledge Index Manager"
                           FontSize="20"
                           FontWeight="Bold"/>
                <TextBlock Text="Manage your codebase index for AI-assisted coding"
                           Opacity="0.7"
                           Margin="0,4,0,0"/>
            </StackPanel>
        </Border>

        <!-- Main Content -->
        <ScrollViewer Grid.Row="1" Padding="16">
            <StackPanel>

                <!-- Workspace Selection -->
                <TextBlock Text="Workspace" Classes="SectionHeader"/>
                <Border Classes="SectionBorder">
                    <Grid ColumnDefinitions="*,Auto">
                        <TextBox Grid.Column="0"
                                 Text="{Binding WorkspacePath}"
                                 Watermark="Select a workspace folder..."
                                 IsReadOnly="True"/>
                        <Button Grid.Column="1"
                                Content="Browse..."
                                Margin="8,0,0,0"
                                Command="{Binding BrowseWorkspaceCommand}"/>
                    </Grid>
                </Border>

                <!-- Index Status -->
                <TextBlock Text="Index Status" Classes="SectionHeader"/>
                <Border Classes="SectionBorder">
                    <Grid RowDefinitions="Auto,Auto,Auto" ColumnDefinitions="Auto,*">
                        <!-- Status Indicator -->
                        <StackPanel Grid.Row="0" Grid.ColumnSpan="2"
                                    Orientation="Horizontal"
                                    Margin="0,0,0,12">
                            <Ellipse Width="12" Height="12"
                                     Fill="{Binding StatusColor}"
                                     Margin="0,0,8,0"/>
                            <TextBlock Text="{Binding StatusText}"
                                       FontWeight="SemiBold"/>
                        </StackPanel>

                        <!-- Statistics -->
                        <Grid Grid.Row="1" Grid.ColumnSpan="2"
                              ColumnDefinitions="*,*,*"
                              IsVisible="{Binding IsIndexed}">
                            <StackPanel Grid.Column="0">
                                <TextBlock Text="{Binding FileCount, StringFormat={}{0:N0}}"
                                           FontSize="24"
                                           FontWeight="Bold"/>
                                <TextBlock Text="Files" Opacity="0.7"/>
                            </StackPanel>
                            <StackPanel Grid.Column="1">
                                <TextBlock Text="{Binding ChunkCount, StringFormat={}{0:N0}}"
                                           FontSize="24"
                                           FontWeight="Bold"/>
                                <TextBlock Text="Chunks" Opacity="0.7"/>
                            </StackPanel>
                            <StackPanel Grid.Column="2">
                                <TextBlock Text="{Binding IndexSize}"
                                           FontSize="24"
                                           FontWeight="Bold"/>
                                <TextBlock Text="Size" Opacity="0.7"/>
                            </StackPanel>
                        </Grid>

                        <!-- Last Updated -->
                        <TextBlock Grid.Row="2" Grid.ColumnSpan="2"
                                   Text="{Binding LastUpdatedText}"
                                   Opacity="0.7"
                                   Margin="0,12,0,0"
                                   IsVisible="{Binding IsIndexed}"/>
                    </Grid>
                </Border>

                <!-- Embedding Model -->
                <TextBlock Text="Embedding Model" Classes="SectionHeader"/>
                <Border Classes="SectionBorder">
                    <StackPanel>
                        <Grid ColumnDefinitions="*,Auto">
                            <TextBox Grid.Column="0"
                                     Text="{Binding EmbeddingModelPath}"
                                     Watermark="Select an embedding model..."
                                     IsReadOnly="True"/>
                            <Button Grid.Column="1"
                                    Content="Browse..."
                                    Margin="8,0,0,0"
                                    Command="{Binding BrowseEmbeddingModelCommand}"/>
                        </Grid>

                        <!-- Model Info -->
                        <StackPanel Orientation="Horizontal"
                                    Margin="0,8,0,0"
                                    IsVisible="{Binding IsModelLoaded}">
                            <TextBlock Text="Dimension: "/>
                            <TextBlock Text="{Binding EmbeddingDimension}" FontWeight="SemiBold"/>
                            <TextBlock Text="  |  Max Tokens: " Margin="8,0,0,0"/>
                            <TextBlock Text="{Binding MaxTokens}" FontWeight="SemiBold"/>
                        </StackPanel>

                        <!-- Model Loading Status -->
                        <StackPanel Orientation="Horizontal"
                                    Margin="0,8,0,0"
                                    IsVisible="{Binding IsLoadingModel}">
                            <controls:LoadingSpinner Width="16" Height="16"/>
                            <TextBlock Text="Loading model..." Margin="8,0,0,0"/>
                        </StackPanel>
                    </StackPanel>
                </Border>

                <!-- Index Options -->
                <TextBlock Text="Index Options" Classes="SectionHeader"/>
                <Border Classes="SectionBorder">
                    <StackPanel>
                        <CheckBox Content="Auto-index on file changes"
                                  IsChecked="{Binding AutoIndexEnabled}"
                                  Margin="0,0,0,8"/>
                        <CheckBox Content="Respect .gitignore"
                                  IsChecked="{Binding RespectGitignore}"
                                  Margin="0,0,0,8"/>
                        <CheckBox Content="Index hidden files"
                                  IsChecked="{Binding IndexHiddenFiles}"
                                  Margin="0,0,0,12"/>

                        <Grid ColumnDefinitions="Auto,100,Auto,100,Auto,100" RowDefinitions="Auto,Auto">
                            <TextBlock Grid.Row="0" Grid.Column="0"
                                       Text="Chunk Size:"
                                       VerticalAlignment="Center"/>
                            <NumericUpDown Grid.Row="0" Grid.Column="1"
                                           Value="{Binding ChunkSize}"
                                           Minimum="100"
                                           Maximum="2000"
                                           Increment="64"
                                           Margin="8,0,16,0"/>

                            <TextBlock Grid.Row="0" Grid.Column="2"
                                       Text="Overlap:"
                                       VerticalAlignment="Center"/>
                            <NumericUpDown Grid.Row="0" Grid.Column="3"
                                           Value="{Binding ChunkOverlap}"
                                           Minimum="0"
                                           Maximum="256"
                                           Increment="16"
                                           Margin="8,0,16,0"/>

                            <TextBlock Grid.Row="0" Grid.Column="4"
                                       Text="Max File (KB):"
                                       VerticalAlignment="Center"/>
                            <NumericUpDown Grid.Row="0" Grid.Column="5"
                                           Value="{Binding MaxFileSizeKb}"
                                           Minimum="1"
                                           Maximum="10240"
                                           Increment="256"
                                           Margin="8,0,0,0"/>
                        </Grid>
                    </StackPanel>
                </Border>

                <!-- File Filters -->
                <TextBlock Text="File Filters" Classes="SectionHeader"/>
                <Border Classes="SectionBorder">
                    <StackPanel>
                        <TextBlock Text="Include Patterns:" Margin="0,0,0,4"/>
                        <TextBox Text="{Binding IncludePatterns}"
                                 Watermark="*.cs, *.ts, *.py, ..."
                                 AcceptsReturn="False"
                                 Margin="0,0,0,12"/>

                        <TextBlock Text="Exclude Patterns:" Margin="0,0,0,4"/>
                        <TextBox Text="{Binding ExcludePatterns}"
                                 Watermark="**/node_modules/**, **/bin/**, ..."
                                 AcceptsReturn="False"/>

                        <Button Content="Edit Patterns..."
                                HorizontalAlignment="Left"
                                Margin="0,8,0,0"
                                Command="{Binding EditPatternsCommand}"/>
                    </StackPanel>
                </Border>

                <!-- Actions -->
                <TextBlock Text="Actions" Classes="SectionHeader"/>
                <Border Classes="SectionBorder">
                    <StackPanel Orientation="Horizontal" Spacing="8">
                        <Button Content="Reindex All"
                                Command="{Binding ReindexAllCommand}"
                                IsEnabled="{Binding CanStartIndexing}"
                                Classes="accent"/>
                        <Button Content="Update Changed"
                                Command="{Binding UpdateChangedCommand}"
                                IsEnabled="{Binding CanStartIndexing}"/>
                        <Button Content="Clear Index"
                                Command="{Binding ClearIndexCommand}"
                                IsEnabled="{Binding IsIndexed}"/>
                    </StackPanel>
                </Border>

            </StackPanel>
        </ScrollViewer>

        <!-- Footer -->
        <Border Grid.Row="2"
                Background="{DynamicResource SystemControlBackgroundChromeMediumBrush}"
                Padding="16">
            <Grid ColumnDefinitions="*,Auto,Auto">
                <StackPanel Grid.Column="0"
                            Orientation="Horizontal"
                            IsVisible="{Binding HasValidationErrors}">
                    <PathIcon Data="{StaticResource warning_regular}"
                              Foreground="Orange"
                              Width="16" Height="16"/>
                    <TextBlock Text="{Binding ValidationErrorMessage}"
                               Foreground="Orange"
                               Margin="8,0,0,0"/>
                </StackPanel>

                <Button Grid.Column="1"
                        Content="Cancel"
                        Command="{Binding CancelCommand}"
                        Margin="0,0,8,0"/>
                <Button Grid.Column="2"
                        Content="Save"
                        Command="{Binding SaveCommand}"
                        Classes="accent"/>
            </Grid>
        </Border>
    </Grid>
</Window>
```

### File: `src/SeniorIntern.Desktop/Views/Dialogs/IndexManagerDialog.axaml.cs`

```csharp
using Avalonia.Controls;
using SeniorIntern.Desktop.ViewModels;

namespace SeniorIntern.Desktop.Views.Dialogs;

public partial class IndexManagerDialog : Window
{
    public IndexManagerDialog()
    {
        InitializeComponent();
    }

    public IndexManagerDialog(IndexManagerViewModel viewModel) : this()
    {
        DataContext = viewModel;
        viewModel.CloseRequested += (_, result) => Close(result);
    }
}
```

### File: `src/SeniorIntern.Desktop/Views/Dialogs/PatternEditorDialog.axaml`

```xml
<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        mc:Ignorable="d"
        x:Class="SeniorIntern.Desktop.Views.Dialogs.PatternEditorDialog"
        Title="Edit File Patterns"
        Width="500"
        Height="500"
        WindowStartupLocation="CenterOwner">

    <Grid RowDefinitions="*,Auto" Margin="16">
        <TabControl Grid.Row="0">
            <!-- Include Patterns -->
            <TabItem Header="Include">
                <Grid RowDefinitions="Auto,*,Auto">
                    <TextBlock Grid.Row="0"
                               Text="Files matching these patterns will be indexed (one per line):"
                               Margin="0,0,0,8"
                               TextWrapping="Wrap"/>
                    <TextBox Grid.Row="1"
                             x:Name="IncludePatternsTextBox"
                             AcceptsReturn="True"
                             TextWrapping="Wrap"
                             FontFamily="Consolas,Monaco,monospace"/>
                    <StackPanel Grid.Row="2" Orientation="Horizontal" Margin="0,8,0,0">
                        <Button Content="Add Common" Command="{Binding AddCommonIncludesCommand}"/>
                        <Button Content="Clear" Command="{Binding ClearIncludesCommand}" Margin="8,0,0,0"/>
                    </StackPanel>
                </Grid>
            </TabItem>

            <!-- Exclude Patterns -->
            <TabItem Header="Exclude">
                <Grid RowDefinitions="Auto,*,Auto">
                    <TextBlock Grid.Row="0"
                               Text="Files matching these patterns will be skipped (one per line):"
                               Margin="0,0,0,8"
                               TextWrapping="Wrap"/>
                    <TextBox Grid.Row="1"
                             x:Name="ExcludePatternsTextBox"
                             AcceptsReturn="True"
                             TextWrapping="Wrap"
                             FontFamily="Consolas,Monaco,monospace"/>
                    <StackPanel Grid.Row="2" Orientation="Horizontal" Margin="0,8,0,0">
                        <Button Content="Add Common" Command="{Binding AddCommonExcludesCommand}"/>
                        <Button Content="Clear" Command="{Binding ClearExcludesCommand}" Margin="8,0,0,0"/>
                    </StackPanel>
                </Grid>
            </TabItem>
        </TabControl>

        <!-- Footer -->
        <StackPanel Grid.Row="1"
                    Orientation="Horizontal"
                    HorizontalAlignment="Right"
                    Margin="0,16,0,0">
            <Button Content="Cancel" Command="{Binding CancelCommand}"/>
            <Button Content="Apply" Command="{Binding ApplyCommand}" Classes="accent" Margin="8,0,0,0"/>
        </StackPanel>
    </Grid>
</Window>
```

### Dependencies
- Avalonia UI
- CommunityToolkit.Mvvm

### Implementation Notes
1. Dialog uses responsive layout with ScrollViewer for smaller screens
2. Status indicator uses color-coded ellipse for quick status identification
3. Statistics are prominently displayed when index exists
4. All actions have appropriate enabled/disabled states

---

## v0.7.5c: Index Manager ViewModel

### Objective
Implement the ViewModel for the Index Manager dialog with full indexing control logic.

### File: `src/SeniorIntern.Desktop/ViewModels/IndexManagerViewModel.cs`

```csharp
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Avalonia.Media;
using Avalonia.Platform.Storage;
using Avalonia.Threading;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Services.Settings;

namespace SeniorIntern.Desktop.ViewModels;

public partial class IndexManagerViewModel : ViewModelBase
{
    private readonly IKnowledgeService _knowledgeService;
    private readonly IIndexingService _indexingService;
    private readonly IEmbeddingService _embeddingService;
    private readonly IVectorStore _vectorStore;
    private readonly IRagSettingsService _settingsService;
    private readonly ILogger<IndexManagerViewModel> _logger;
    private readonly IStorageProvider _storageProvider;

    private CancellationTokenSource? _indexingCts;

    public event EventHandler<bool>? CloseRequested;

    #region Observable Properties

    [ObservableProperty]
    private string _workspacePath = string.Empty;

    [ObservableProperty]
    private bool _isIndexed;

    [ObservableProperty]
    private DateTime? _lastUpdated;

    [ObservableProperty]
    private int _fileCount;

    [ObservableProperty]
    private int _chunkCount;

    [ObservableProperty]
    private string _indexSize = "0 B";

    [ObservableProperty]
    private string? _embeddingModelPath;

    [ObservableProperty]
    private int _embeddingDimension;

    [ObservableProperty]
    private int _maxTokens;

    [ObservableProperty]
    private bool _isModelLoaded;

    [ObservableProperty]
    private bool _isLoadingModel;

    [ObservableProperty]
    private bool _autoIndexEnabled = true;

    [ObservableProperty]
    private bool _respectGitignore = true;

    [ObservableProperty]
    private bool _indexHiddenFiles;

    [ObservableProperty]
    private int _chunkSize = 512;

    [ObservableProperty]
    private int _chunkOverlap = 64;

    [ObservableProperty]
    private int _maxFileSizeKb = 1024;

    [ObservableProperty]
    private string _includePatterns = "*.cs, *.ts, *.js, *.py, *.md";

    [ObservableProperty]
    private string _excludePatterns = "**/node_modules/**, **/bin/**, **/obj/**";

    [ObservableProperty]
    private bool _isIndexing;

    [ObservableProperty]
    private IndexingProgress? _currentProgress;

    [ObservableProperty]
    private string? _validationErrorMessage;

    #endregion

    #region Computed Properties

    public string StatusText => IsIndexed ? "Indexed" : "Not Indexed";

    public IBrush StatusColor => IsIndexed
        ? Brushes.LimeGreen
        : Brushes.Gray;

    public string LastUpdatedText => LastUpdated.HasValue
        ? $"Last updated: {FormatTimeAgo(LastUpdated.Value)}"
        : string.Empty;

    public bool CanStartIndexing => !IsIndexing &&
                                     !string.IsNullOrEmpty(WorkspacePath) &&
                                     IsModelLoaded;

    public bool HasValidationErrors => !string.IsNullOrEmpty(ValidationErrorMessage);

    #endregion

    public IndexManagerViewModel(
        IKnowledgeService knowledgeService,
        IIndexingService indexingService,
        IEmbeddingService embeddingService,
        IVectorStore vectorStore,
        IRagSettingsService settingsService,
        IStorageProvider storageProvider,
        ILogger<IndexManagerViewModel> logger)
    {
        _knowledgeService = knowledgeService;
        _indexingService = indexingService;
        _embeddingService = embeddingService;
        _vectorStore = vectorStore;
        _settingsService = settingsService;
        _storageProvider = storageProvider;
        _logger = logger;
    }

    public async Task InitializeAsync(string? workspacePath = null)
    {
        // Load settings
        var settings = await _settingsService.GetSettingsAsync();
        ApplySettings(settings);

        // Set workspace path
        WorkspacePath = workspacePath ?? settings.LastWorkspacePath ?? string.Empty;

        // Load model if path is set
        if (!string.IsNullOrEmpty(EmbeddingModelPath))
        {
            await LoadEmbeddingModelAsync();
        }

        // Load index status
        if (!string.IsNullOrEmpty(WorkspacePath))
        {
            await LoadIndexStatusAsync();
        }
    }

    private void ApplySettings(RagSettings settings)
    {
        EmbeddingModelPath = settings.EmbeddingModelPath;
        AutoIndexEnabled = settings.AutoIndexEnabled;
        RespectGitignore = settings.RespectGitignore;
        IndexHiddenFiles = settings.IndexHiddenFiles;
        ChunkSize = settings.ChunkSize;
        ChunkOverlap = settings.ChunkOverlap;
        MaxFileSizeKb = settings.MaxFileSizeKb;
        IncludePatterns = string.Join(", ", settings.IncludePatterns);
        ExcludePatterns = string.Join(", ", settings.ExcludePatterns);
    }

    [RelayCommand]
    private async Task BrowseWorkspaceAsync()
    {
        var folders = await _storageProvider.OpenFolderPickerAsync(new FolderPickerOpenOptions
        {
            Title = "Select Workspace Folder",
            AllowMultiple = false
        });

        if (folders.Count > 0)
        {
            WorkspacePath = folders[0].Path.LocalPath;
            await LoadIndexStatusAsync();
        }
    }

    [RelayCommand]
    private async Task BrowseEmbeddingModelAsync()
    {
        var files = await _storageProvider.OpenFilePickerAsync(new FilePickerOpenOptions
        {
            Title = "Select Embedding Model",
            AllowMultiple = false,
            FileTypeFilter = new[]
            {
                new FilePickerFileType("Embedding Models")
                {
                    Patterns = new[] { "*.gguf", "*.onnx" }
                }
            }
        });

        if (files.Count > 0)
        {
            EmbeddingModelPath = files[0].Path.LocalPath;
            await LoadEmbeddingModelAsync();
        }
    }

    private async Task LoadEmbeddingModelAsync()
    {
        if (string.IsNullOrEmpty(EmbeddingModelPath))
            return;

        IsLoadingModel = true;
        IsModelLoaded = false;

        try
        {
            var modelType = EmbeddingModelPath.EndsWith(".onnx", StringComparison.OrdinalIgnoreCase)
                ? Core.Models.EmbeddingModelType.Onnx
                : Core.Models.EmbeddingModelType.Gguf;

            await _embeddingService.LoadModelAsync(new EmbeddingModelOptions
            {
                ModelPath = EmbeddingModelPath,
                ModelType = modelType
            });

            EmbeddingDimension = _embeddingService.EmbeddingDimension;
            MaxTokens = _embeddingService.MaxTokens;
            IsModelLoaded = true;

            _logger.LogInformation("Loaded embedding model: {Path}", EmbeddingModelPath);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to load embedding model");
            ValidationErrorMessage = $"Failed to load model: {ex.Message}";
            IsModelLoaded = false;
        }
        finally
        {
            IsLoadingModel = false;
        }
    }

    [RelayCommand]
    private async Task LoadIndexStatusAsync()
    {
        if (string.IsNullOrEmpty(WorkspacePath))
            return;

        try
        {
            var health = await _knowledgeService.GetIndexHealthAsync(WorkspacePath);

            IsIndexed = health.IsIndexed;
            LastUpdated = health.LastUpdated;
            FileCount = health.TotalFiles;
            ChunkCount = health.TotalChunks;
            IndexSize = health.FormattedSize;

            if (!string.IsNullOrEmpty(health.EmbeddingModel) && string.IsNullOrEmpty(EmbeddingModelPath))
            {
                EmbeddingModelPath = health.EmbeddingModel;
            }

            OnPropertyChanged(nameof(StatusText));
            OnPropertyChanged(nameof(StatusColor));
            OnPropertyChanged(nameof(LastUpdatedText));
            OnPropertyChanged(nameof(CanStartIndexing));
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to load index status");
        }
    }

    [RelayCommand]
    private async Task ReindexAllAsync()
    {
        if (!CanStartIndexing)
            return;

        await StartIndexingAsync(forceReindex: true);
    }

    [RelayCommand]
    private async Task UpdateChangedAsync()
    {
        if (!CanStartIndexing)
            return;

        if (!IsIndexed)
        {
            await StartIndexingAsync(forceReindex: true);
            return;
        }

        await StartIndexingAsync(forceReindex: false);
    }

    private async Task StartIndexingAsync(bool forceReindex)
    {
        IsIndexing = true;
        _indexingCts = new CancellationTokenSource();

        var progress = new Progress<IndexingProgress>(p =>
        {
            Dispatcher.UIThread.Post(() =>
            {
                CurrentProgress = p;
            });
        });

        try
        {
            var options = BuildIndexingOptions(forceReindex);
            var result = await _indexingService.IndexWorkspaceAsync(
                WorkspacePath,
                options,
                progress,
                _indexingCts.Token);

            if (result.Success)
            {
                await LoadIndexStatusAsync();
                _logger.LogInformation(
                    "Indexing complete: {Files} files, {Chunks} chunks",
                    result.FilesIndexed,
                    result.ChunksCreated);
            }
            else
            {
                ValidationErrorMessage = result.ErrorMessage ?? "Indexing failed";
            }
        }
        catch (OperationCanceledException)
        {
            _logger.LogInformation("Indexing cancelled");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Indexing failed");
            ValidationErrorMessage = $"Indexing failed: {ex.Message}";
        }
        finally
        {
            IsIndexing = false;
            CurrentProgress = null;
            _indexingCts?.Dispose();
            _indexingCts = null;
        }
    }

    [RelayCommand]
    private async Task ClearIndexAsync()
    {
        if (!IsIndexed)
            return;

        try
        {
            var index = await _vectorStore.GetIndexForWorkspaceAsync(WorkspacePath);
            if (index != null)
            {
                await _vectorStore.DeleteIndexAsync(index.Id);
                await LoadIndexStatusAsync();
                _logger.LogInformation("Cleared index for: {Path}", WorkspacePath);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to clear index");
            ValidationErrorMessage = $"Failed to clear index: {ex.Message}";
        }
    }

    [RelayCommand]
    private void CancelIndexing()
    {
        _indexingCts?.Cancel();
    }

    [RelayCommand]
    private void EditPatterns()
    {
        // Open pattern editor dialog
        // This would be implemented to show PatternEditorDialog
    }

    [RelayCommand]
    private async Task SaveAsync()
    {
        // Validate settings
        var settings = BuildSettings();
        var errors = settings.Validate();

        if (errors.Count > 0)
        {
            ValidationErrorMessage = string.Join("; ", errors);
            return;
        }

        try
        {
            await _settingsService.SaveSettingsAsync(settings);
            CloseRequested?.Invoke(this, true);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to save settings");
            ValidationErrorMessage = $"Failed to save: {ex.Message}";
        }
    }

    [RelayCommand]
    private void Cancel()
    {
        CancelIndexing();
        CloseRequested?.Invoke(this, false);
    }

    private IndexingOptions BuildIndexingOptions(bool forceReindex)
    {
        return new IndexingOptions
        {
            IndexName = Path.GetFileName(WorkspacePath),
            EmbeddingModelPath = EmbeddingModelPath!,
            ChunkingOptions = new ChunkingOptions
            {
                TargetChunkSize = ChunkSize,
                ChunkOverlap = ChunkOverlap
            },
            IncludePatterns = ParsePatterns(IncludePatterns),
            ExcludePatterns = ParsePatterns(ExcludePatterns),
            MaxFileSizeKb = MaxFileSizeKb,
            RespectGitignore = RespectGitignore,
            IndexHiddenFiles = IndexHiddenFiles,
            ForceReindex = forceReindex
        };
    }

    private RagSettings BuildSettings()
    {
        return new RagSettings
        {
            EmbeddingModelPath = EmbeddingModelPath,
            AutoIndexEnabled = AutoIndexEnabled,
            RespectGitignore = RespectGitignore,
            IndexHiddenFiles = IndexHiddenFiles,
            ChunkSize = ChunkSize,
            ChunkOverlap = ChunkOverlap,
            MaxFileSizeKb = MaxFileSizeKb,
            IncludePatterns = ParsePatterns(IncludePatterns),
            ExcludePatterns = ParsePatterns(ExcludePatterns),
            LastWorkspacePath = WorkspacePath
        };
    }

    private static List<string> ParsePatterns(string patterns)
    {
        return patterns
            .Split(new[] { ',', '\n', '\r' }, StringSplitOptions.RemoveEmptyEntries)
            .Select(p => p.Trim())
            .Where(p => !string.IsNullOrEmpty(p))
            .ToList();
    }

    private static string FormatTimeAgo(DateTime dateTime)
    {
        var elapsed = DateTime.UtcNow - dateTime;

        return elapsed switch
        {
            { TotalMinutes: < 1 } => "just now",
            { TotalMinutes: < 60 } => $"{(int)elapsed.TotalMinutes} minutes ago",
            { TotalHours: < 24 } => $"{(int)elapsed.TotalHours} hours ago",
            { TotalDays: < 7 } => $"{(int)elapsed.TotalDays} days ago",
            _ => dateTime.ToLocalTime().ToString("MMM d, yyyy")
        };
    }
}
```

### File: `src/SeniorIntern.Desktop/ViewModels/IndexManagerViewModel.Commands.cs`

```csharp
using System.Threading.Tasks;
using CommunityToolkit.Mvvm.Input;

namespace SeniorIntern.Desktop.ViewModels;

public partial class IndexManagerViewModel
{
    // Additional command implementations can be added here
    // to keep the main file cleaner

    [RelayCommand]
    private async Task RefreshStatusAsync()
    {
        await LoadIndexStatusAsync();
    }

    [RelayCommand]
    private void ResetToDefaults()
    {
        var defaults = RagSettings.Default;
        ChunkSize = defaults.ChunkSize;
        ChunkOverlap = defaults.ChunkOverlap;
        MaxFileSizeKb = defaults.MaxFileSizeKb;
        RespectGitignore = defaults.RespectGitignore;
        IndexHiddenFiles = defaults.IndexHiddenFiles;
        AutoIndexEnabled = defaults.AutoIndexEnabled;
        IncludePatterns = string.Join(", ", defaults.IncludePatterns);
        ExcludePatterns = string.Join(", ", defaults.ExcludePatterns);
    }
}
```

### Dependencies
- CommunityToolkit.Mvvm
- Avalonia.Platform.Storage
- All v0.7.1-v0.7.4 services

### Implementation Notes
1. ViewModel uses partial class pattern for organization
2. All async operations support cancellation
3. Progress updates are dispatched to UI thread
4. Settings validation before save

---

## v0.7.5d: Indexing Progress Dialog

### Objective
Create a dialog that displays real-time indexing progress with detailed statistics and activity log.

### File: `src/SeniorIntern.Desktop/Views/Dialogs/IndexingProgressDialog.axaml`

```xml
<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:vm="using:SeniorIntern.Desktop.ViewModels"
        mc:Ignorable="d"
        x:Class="SeniorIntern.Desktop.Views.Dialogs.IndexingProgressDialog"
        x:DataType="vm:IndexingProgressViewModel"
        Title="Indexing Project"
        Width="550"
        Height="450"
        MinWidth="450"
        MinHeight="350"
        WindowStartupLocation="CenterOwner"
        CanResize="True">

    <Grid RowDefinitions="Auto,Auto,Auto,*,Auto" Margin="20">

        <!-- Phase Label -->
        <TextBlock Grid.Row="0"
                   Text="{Binding PhaseText}"
                   FontSize="16"
                   FontWeight="SemiBold"
                   Margin="0,0,0,16"/>

        <!-- Progress Bar -->
        <Grid Grid.Row="1" RowDefinitions="Auto,Auto" Margin="0,0,0,20">
            <ProgressBar Grid.Row="0"
                         Minimum="0"
                         Maximum="100"
                         Value="{Binding ProgressPercentage}"
                         Height="20"/>
            <TextBlock Grid.Row="1"
                       Text="{Binding ProgressPercentage, StringFormat={}{0:F0}%}"
                       HorizontalAlignment="Center"
                       Margin="0,4,0,0"/>
        </Grid>

        <!-- Statistics -->
        <Grid Grid.Row="2" ColumnDefinitions="*,*" Margin="0,0,0,20">
            <StackPanel Grid.Column="0">
                <TextBlock Text="Files"/>
                <TextBlock FontSize="20" FontWeight="Bold">
                    <TextBlock.Text>
                        <MultiBinding StringFormat="{}{0:N0} / {1:N0}">
                            <Binding Path="FilesProcessed"/>
                            <Binding Path="TotalFiles"/>
                        </MultiBinding>
                    </TextBlock.Text>
                </TextBlock>
            </StackPanel>
            <StackPanel Grid.Column="1">
                <TextBlock Text="Chunks"/>
                <TextBlock FontSize="20" FontWeight="Bold">
                    <TextBlock.Text>
                        <MultiBinding StringFormat="{}{0:N0} / ~{1:N0}">
                            <Binding Path="ChunksCreated"/>
                            <Binding Path="EstimatedChunks"/>
                        </MultiBinding>
                    </TextBlock.Text>
                </TextBlock>
            </StackPanel>
        </Grid>

        <!-- Current File & Time -->
        <StackPanel Grid.Row="3" Margin="0,0,0,16">
            <TextBlock Text="Current file:" Opacity="0.7"/>
            <TextBlock Text="{Binding CurrentFile}"
                       TextTrimming="CharacterEllipsis"
                       FontFamily="Consolas,Monaco,monospace"
                       Margin="0,4,0,12"/>

            <Grid ColumnDefinitions="*,*">
                <StackPanel Grid.Column="0">
                    <TextBlock Text="Elapsed" Opacity="0.7"/>
                    <TextBlock Text="{Binding ElapsedTime}" FontWeight="SemiBold"/>
                </StackPanel>
                <StackPanel Grid.Column="1">
                    <TextBlock Text="Remaining" Opacity="0.7"/>
                    <TextBlock Text="{Binding RemainingTime}" FontWeight="SemiBold"/>
                </StackPanel>
            </Grid>

            <!-- Activity Log -->
            <TextBlock Text="Activity Log" Margin="0,16,0,8"/>
            <Border BorderBrush="{DynamicResource SystemControlForegroundBaseMediumLowBrush}"
                    BorderThickness="1"
                    CornerRadius="4"
                    Height="120">
                <ScrollViewer x:Name="LogScrollViewer">
                    <ItemsControl ItemsSource="{Binding LogEntries}">
                        <ItemsControl.ItemTemplate>
                            <DataTemplate>
                                <StackPanel Orientation="Horizontal" Margin="8,2">
                                    <TextBlock Text="{Binding Icon}"
                                               Width="20"
                                               FontFamily="Segoe UI Emoji"/>
                                    <TextBlock Text="{Binding Message}"
                                               FontFamily="Consolas,Monaco,monospace"
                                               FontSize="12"/>
                                </StackPanel>
                            </DataTemplate>
                        </ItemsControl.ItemTemplate>
                    </ItemsControl>
                </ScrollViewer>
            </Border>
        </StackPanel>

        <!-- Footer Buttons -->
        <StackPanel Grid.Row="4"
                    Orientation="Horizontal"
                    HorizontalAlignment="Right"
                    Spacing="8">
            <Button Content="Run in Background"
                    Command="{Binding RunInBackgroundCommand}"
                    IsVisible="{Binding !IsBackground}"/>
            <Button Content="Cancel"
                    Command="{Binding CancelCommand}"/>
        </StackPanel>
    </Grid>
</Window>
```

### File: `src/SeniorIntern.Desktop/Views/Dialogs/IndexingProgressDialog.axaml.cs`

```csharp
using Avalonia.Controls;
using SeniorIntern.Desktop.ViewModels;

namespace SeniorIntern.Desktop.Views.Dialogs;

public partial class IndexingProgressDialog : Window
{
    public IndexingProgressDialog()
    {
        InitializeComponent();
    }

    public IndexingProgressDialog(IndexingProgressViewModel viewModel) : this()
    {
        DataContext = viewModel;
        viewModel.CloseRequested += (_, _) => Close();
        viewModel.LogEntryAdded += (_, _) =>
        {
            // Auto-scroll log to bottom
            LogScrollViewer?.ScrollToEnd();
        };
    }
}
```

### File: `src/SeniorIntern.Desktop/ViewModels/IndexingProgressViewModel.cs`

```csharp
using System;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;
using Avalonia.Threading;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using SeniorIntern.Core.Models;

namespace SeniorIntern.Desktop.ViewModels;

public partial class IndexingProgressViewModel : ViewModelBase
{
    private readonly Stopwatch _stopwatch = new();
    private CancellationTokenSource? _cts;

    public event EventHandler? CloseRequested;
    public event EventHandler? LogEntryAdded;

    #region Observable Properties

    [ObservableProperty]
    private string _phaseText = "Preparing...";

    [ObservableProperty]
    private double _progressPercentage;

    [ObservableProperty]
    private int _filesProcessed;

    [ObservableProperty]
    private int _totalFiles;

    [ObservableProperty]
    private int _chunksCreated;

    [ObservableProperty]
    private int _estimatedChunks;

    [ObservableProperty]
    private string _currentFile = string.Empty;

    [ObservableProperty]
    private string _elapsedTime = "0:00";

    [ObservableProperty]
    private string _remainingTime = "Calculating...";

    [ObservableProperty]
    private bool _isBackground;

    [ObservableProperty]
    private bool _isCancelled;

    #endregion

    public ObservableCollection<LogEntry> LogEntries { get; } = new();

    public IndexingProgressViewModel()
    {
        _stopwatch.Start();

        // Update elapsed time every second
        var timer = new DispatcherTimer
        {
            Interval = TimeSpan.FromSeconds(1)
        };
        timer.Tick += (_, _) => UpdateElapsedTime();
        timer.Start();
    }

    public void SetCancellationToken(CancellationTokenSource cts)
    {
        _cts = cts;
    }

    public void UpdateProgress(IndexingProgress progress)
    {
        Dispatcher.UIThread.Post(() =>
        {
            PhaseText = progress.Phase switch
            {
                IndexingPhase.Scanning => "Scanning files...",
                IndexingPhase.Filtering => "Filtering files...",
                IndexingPhase.Chunking => "Creating chunks...",
                IndexingPhase.Embedding => "Generating embeddings...",
                IndexingPhase.Storing => "Storing vectors...",
                IndexingPhase.Completing => "Completing...",
                _ => "Processing..."
            };

            FilesProcessed = progress.FilesProcessed;
            TotalFiles = progress.TotalFiles;
            ChunksCreated = progress.ChunksCreated;
            EstimatedChunks = progress.EstimatedTotalChunks;
            CurrentFile = progress.CurrentFile ?? string.Empty;

            if (TotalFiles > 0)
            {
                ProgressPercentage = (double)FilesProcessed / TotalFiles * 100;
                UpdateRemainingTime();
            }

            // Add log entry for significant events
            if (!string.IsNullOrEmpty(progress.CurrentFile) && progress.FilesProcessed % 50 == 0)
            {
                AddLogEntry("processing", $"Processed {progress.FilesProcessed} files...");
            }
        });
    }

    public void AddLogEntry(string type, string message)
    {
        Dispatcher.UIThread.Post(() =>
        {
            var icon = type switch
            {
                "success" => "\u2714",  // ✔
                "error" => "\u2716",    // ✖
                "warning" => "\u26A0",  // ⚠
                "processing" => "\u26A1", // ⚡
                _ => "\u2022"           // •
            };

            LogEntries.Add(new LogEntry { Icon = icon, Message = message });
            LogEntryAdded?.Invoke(this, EventArgs.Empty);

            // Keep log size manageable
            while (LogEntries.Count > 100)
            {
                LogEntries.RemoveAt(0);
            }
        });
    }

    public void Complete(bool success, string? message = null)
    {
        _stopwatch.Stop();

        Dispatcher.UIThread.Post(() =>
        {
            ProgressPercentage = 100;
            PhaseText = success ? "Complete!" : "Failed";
            RemainingTime = "Done";

            AddLogEntry(
                success ? "success" : "error",
                message ?? (success ? "Indexing completed successfully" : "Indexing failed"));
        });
    }

    [RelayCommand]
    private void RunInBackground()
    {
        IsBackground = true;
        CloseRequested?.Invoke(this, EventArgs.Empty);
    }

    [RelayCommand]
    private void Cancel()
    {
        IsCancelled = true;
        _cts?.Cancel();
        AddLogEntry("warning", "Cancelling...");
    }

    private void UpdateElapsedTime()
    {
        ElapsedTime = FormatTimeSpan(_stopwatch.Elapsed);
    }

    private void UpdateRemainingTime()
    {
        if (FilesProcessed <= 0 || TotalFiles <= 0)
        {
            RemainingTime = "Calculating...";
            return;
        }

        var elapsed = _stopwatch.Elapsed;
        var remaining = FilesProcessed > 0
            ? TimeSpan.FromTicks(elapsed.Ticks * (TotalFiles - FilesProcessed) / FilesProcessed)
            : TimeSpan.Zero;

        RemainingTime = remaining > TimeSpan.Zero
            ? $"~{FormatTimeSpan(remaining)}"
            : "Almost done...";
    }

    private static string FormatTimeSpan(TimeSpan ts)
    {
        if (ts.TotalHours >= 1)
            return $"{(int)ts.TotalHours}:{ts.Minutes:D2}:{ts.Seconds:D2}";
        return $"{ts.Minutes}:{ts.Seconds:D2}";
    }
}

public sealed class LogEntry
{
    public string Icon { get; init; } = string.Empty;
    public string Message { get; init; } = string.Empty;
}
```

### Dependencies
- CommunityToolkit.Mvvm
- Avalonia.Threading

### Implementation Notes
1. Progress updates are dispatched to UI thread for safety
2. Log auto-scrolls to show latest entries
3. Remaining time calculation improves over time
4. "Run in Background" allows dialog to close while indexing continues

---

## v0.7.5e: RAG Status Indicator Control

### Objective
Create a reusable control that displays RAG status in the main window status bar.

### File: `src/SeniorIntern.Desktop/Controls/RagStatusIndicator.axaml`

```xml
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             mc:Ignorable="d"
             x:Class="SeniorIntern.Desktop.Controls.RagStatusIndicator"
             x:Name="Root">

    <UserControl.Styles>
        <Style Selector="Button.StatusButton">
            <Setter Property="Background" Value="Transparent"/>
            <Setter Property="BorderThickness" Value="0"/>
            <Setter Property="Padding" Value="8,4"/>
            <Setter Property="Cursor" Value="Hand"/>
        </Style>
        <Style Selector="Button.StatusButton:pointerover">
            <Setter Property="Background" Value="{DynamicResource SystemControlBackgroundListLowBrush}"/>
        </Style>
    </UserControl.Styles>

    <Button Classes="StatusButton"
            Command="{Binding OpenIndexManagerCommand, ElementName=Root}"
            ToolTip.Tip="{Binding TooltipText, ElementName=Root}">
        <StackPanel Orientation="Horizontal" Spacing="6">
            <!-- Status Icon -->
            <Grid>
                <Ellipse Width="10" Height="10"
                         Fill="{Binding StatusColor, ElementName=Root}"/>
                <!-- Pulsing animation for indexing state -->
                <Ellipse Width="10" Height="10"
                         Fill="{Binding StatusColor, ElementName=Root}"
                         Opacity="0.5"
                         IsVisible="{Binding IsIndexing, ElementName=Root}">
                    <Ellipse.Styles>
                        <Style Selector="Ellipse">
                            <Style.Animations>
                                <Animation Duration="0:0:1" IterationCount="Infinite">
                                    <KeyFrame Cue="0%">
                                        <Setter Property="ScaleTransform.ScaleX" Value="1"/>
                                        <Setter Property="ScaleTransform.ScaleY" Value="1"/>
                                        <Setter Property="Opacity" Value="0.5"/>
                                    </KeyFrame>
                                    <KeyFrame Cue="100%">
                                        <Setter Property="ScaleTransform.ScaleX" Value="2"/>
                                        <Setter Property="ScaleTransform.ScaleY" Value="2"/>
                                        <Setter Property="Opacity" Value="0"/>
                                    </KeyFrame>
                                </Animation>
                            </Style.Animations>
                        </Style>
                    </Ellipse.Styles>
                    <Ellipse.RenderTransform>
                        <ScaleTransform/>
                    </Ellipse.RenderTransform>
                </Ellipse>
            </Grid>

            <!-- Status Text -->
            <TextBlock Text="{Binding StatusText, ElementName=Root}"
                       FontSize="12"
                       VerticalAlignment="Center"/>

            <!-- Progress indicator when indexing -->
            <TextBlock Text="{Binding ProgressText, ElementName=Root}"
                       FontSize="12"
                       Opacity="0.7"
                       VerticalAlignment="Center"
                       IsVisible="{Binding IsIndexing, ElementName=Root}"/>
        </StackPanel>
    </Button>
</UserControl>
```

### File: `src/SeniorIntern.Desktop/Controls/RagStatusIndicator.axaml.cs`

```csharp
using System;
using System.Windows.Input;
using Avalonia;
using Avalonia.Controls;
using Avalonia.Media;

namespace SeniorIntern.Desktop.Controls;

public partial class RagStatusIndicator : UserControl
{
    public static readonly StyledProperty<RagStatus> StatusProperty =
        AvaloniaProperty.Register<RagStatusIndicator, RagStatus>(nameof(Status));

    public static readonly StyledProperty<bool> IsIndexingProperty =
        AvaloniaProperty.Register<RagStatusIndicator, bool>(nameof(IsIndexing));

    public static readonly StyledProperty<double> IndexingProgressProperty =
        AvaloniaProperty.Register<RagStatusIndicator, double>(nameof(IndexingProgress));

    public static readonly StyledProperty<ICommand?> OpenIndexManagerCommandProperty =
        AvaloniaProperty.Register<RagStatusIndicator, ICommand?>(nameof(OpenIndexManagerCommand));

    public RagStatus Status
    {
        get => GetValue(StatusProperty);
        set => SetValue(StatusProperty, value);
    }

    public bool IsIndexing
    {
        get => GetValue(IsIndexingProperty);
        set => SetValue(IsIndexingProperty, value);
    }

    public double IndexingProgress
    {
        get => GetValue(IndexingProgressProperty);
        set => SetValue(IndexingProgressProperty, value);
    }

    public ICommand? OpenIndexManagerCommand
    {
        get => GetValue(OpenIndexManagerCommandProperty);
        set => SetValue(OpenIndexManagerCommandProperty, value);
    }

    public IBrush StatusColor => Status switch
    {
        RagStatus.Indexed => Brushes.LimeGreen,
        RagStatus.Indexing => Brushes.Orange,
        RagStatus.NeedsUpdate => Brushes.Yellow,
        RagStatus.Error => Brushes.Red,
        RagStatus.NoModel => Brushes.Gray,
        _ => Brushes.Gray
    };

    public string StatusText => Status switch
    {
        RagStatus.Indexed => "RAG Ready",
        RagStatus.Indexing => "Indexing",
        RagStatus.NeedsUpdate => "Update Available",
        RagStatus.Error => "RAG Error",
        RagStatus.NoModel => "No Model",
        RagStatus.NotIndexed => "Not Indexed",
        _ => "RAG"
    };

    public string ProgressText => IsIndexing
        ? $"({IndexingProgress:F0}%)"
        : string.Empty;

    public string TooltipText => Status switch
    {
        RagStatus.Indexed => "Knowledge index is ready. Click to manage.",
        RagStatus.Indexing => $"Indexing in progress: {IndexingProgress:F0}%",
        RagStatus.NeedsUpdate => "Some files have changed. Click to update index.",
        RagStatus.Error => "There was an error with the index. Click to resolve.",
        RagStatus.NoModel => "No embedding model configured. Click to set up.",
        RagStatus.NotIndexed => "Workspace not indexed. Click to index.",
        _ => "Click to open index manager"
    };

    public RagStatusIndicator()
    {
        InitializeComponent();
    }

    protected override void OnPropertyChanged(AvaloniaPropertyChangedEventArgs change)
    {
        base.OnPropertyChanged(change);

        if (change.Property == StatusProperty ||
            change.Property == IsIndexingProperty ||
            change.Property == IndexingProgressProperty)
        {
            // Trigger property change notifications for computed properties
            RaisePropertyChanged(nameof(StatusColor));
            RaisePropertyChanged(nameof(StatusText));
            RaisePropertyChanged(nameof(ProgressText));
            RaisePropertyChanged(nameof(TooltipText));
        }
    }

    private void RaisePropertyChanged(string propertyName)
    {
        // This is a simplified approach - in production, use proper INotifyPropertyChanged
    }
}

public enum RagStatus
{
    NotIndexed,
    Indexed,
    Indexing,
    NeedsUpdate,
    Error,
    NoModel
}
```

### File: `src/SeniorIntern.Desktop/Services/RagStatusService.cs`

```csharp
using System;
using System.Threading;
using System.Threading.Tasks;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Desktop.Controls;
using SeniorIntern.Services.Settings;

namespace SeniorIntern.Desktop.Services;

/// <summary>
/// Service for tracking and providing RAG status to the UI.
/// </summary>
public sealed class RagStatusService : IDisposable
{
    private readonly IKnowledgeService _knowledgeService;
    private readonly IEmbeddingService _embeddingService;
    private readonly IRagSettingsService _settingsService;

    private string? _currentWorkspace;
    private RagStatus _currentStatus = RagStatus.NotIndexed;
    private double _indexingProgress;
    private bool _isIndexing;

    public event EventHandler<RagStatusChangedEventArgs>? StatusChanged;

    public RagStatus CurrentStatus => _currentStatus;
    public double IndexingProgress => _indexingProgress;
    public bool IsIndexing => _isIndexing;

    public RagStatusService(
        IKnowledgeService knowledgeService,
        IEmbeddingService embeddingService,
        IRagSettingsService settingsService)
    {
        _knowledgeService = knowledgeService;
        _embeddingService = embeddingService;
        _settingsService = settingsService;
    }

    public async Task UpdateStatusAsync(string? workspacePath, CancellationToken ct = default)
    {
        _currentWorkspace = workspacePath;

        if (string.IsNullOrEmpty(workspacePath))
        {
            SetStatus(RagStatus.NotIndexed);
            return;
        }

        var settings = await _settingsService.GetSettingsAsync(ct);

        if (string.IsNullOrEmpty(settings.EmbeddingModelPath))
        {
            SetStatus(RagStatus.NoModel);
            return;
        }

        if (!_embeddingService.IsModelLoaded)
        {
            SetStatus(RagStatus.NoModel);
            return;
        }

        try
        {
            var health = await _knowledgeService.GetIndexHealthAsync(workspacePath, ct);

            if (!health.IsIndexed)
            {
                SetStatus(RagStatus.NotIndexed);
            }
            else if (health.NeedsReindex)
            {
                SetStatus(RagStatus.NeedsUpdate);
            }
            else
            {
                SetStatus(RagStatus.Indexed);
            }
        }
        catch
        {
            SetStatus(RagStatus.Error);
        }
    }

    public void SetIndexing(bool isIndexing, double progress = 0)
    {
        _isIndexing = isIndexing;
        _indexingProgress = progress;

        if (isIndexing)
        {
            SetStatus(RagStatus.Indexing);
        }
        else
        {
            // Refresh status after indexing completes
            _ = UpdateStatusAsync(_currentWorkspace);
        }
    }

    public void UpdateIndexingProgress(double progress)
    {
        _indexingProgress = progress;
        StatusChanged?.Invoke(this, new RagStatusChangedEventArgs
        {
            Status = _currentStatus,
            IsIndexing = _isIndexing,
            Progress = progress
        });
    }

    private void SetStatus(RagStatus status)
    {
        if (_currentStatus == status && !_isIndexing)
            return;

        _currentStatus = status;
        StatusChanged?.Invoke(this, new RagStatusChangedEventArgs
        {
            Status = status,
            IsIndexing = _isIndexing,
            Progress = _indexingProgress
        });
    }

    public void Dispose()
    {
        // Cleanup if needed
    }
}

public sealed class RagStatusChangedEventArgs : EventArgs
{
    public RagStatus Status { get; init; }
    public bool IsIndexing { get; init; }
    public double Progress { get; init; }
}
```

### File to Modify: `src/SeniorIntern.Desktop/Views/MainWindow.axaml`

Add RAG status indicator to status bar:

```xml
<!-- Add to the status bar section of MainWindow -->
<controls:RagStatusIndicator
    Status="{Binding RagStatus}"
    IsIndexing="{Binding IsRagIndexing}"
    IndexingProgress="{Binding RagIndexingProgress}"
    OpenIndexManagerCommand="{Binding OpenIndexManagerCommand}"
    IsVisible="{Binding Settings.Rag.ShowStatusIndicator}"/>
```

### Dependencies
- Avalonia UI
- IKnowledgeService from v0.7.4

### Implementation Notes
1. Status indicator uses color-coded display with pulsing animation during indexing
2. Tooltip provides context-sensitive help
3. Click handler opens Index Manager dialog
4. Service-based status tracking enables updates from anywhere in the app

---

## v0.7.5f: RAG Settings Panel

### Objective
Add a RAG settings tab to the application settings dialog.

### File: `src/SeniorIntern.Desktop/Views/Settings/RagSettingsPanel.axaml`

```xml
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             xmlns:vm="using:SeniorIntern.Desktop.ViewModels"
             mc:Ignorable="d"
             x:Class="SeniorIntern.Desktop.Views.Settings.RagSettingsPanel"
             x:DataType="vm:RagSettingsViewModel">

    <ScrollViewer>
        <StackPanel Margin="20" Spacing="20">

            <!-- Enable RAG -->
            <StackPanel>
                <CheckBox Content="Enable RAG (Retrieval-Augmented Generation)"
                          IsChecked="{Binding Enabled}"
                          FontWeight="SemiBold"/>
                <TextBlock Text="When enabled, the AI can search your codebase to provide context-aware responses."
                           TextWrapping="Wrap"
                           Opacity="0.7"
                           Margin="28,4,0,0"/>
            </StackPanel>

            <Separator/>

            <!-- Embedding Model -->
            <StackPanel IsEnabled="{Binding Enabled}">
                <TextBlock Text="Embedding Model" FontWeight="SemiBold" Margin="0,0,0,8"/>
                <Grid ColumnDefinitions="*,Auto">
                    <TextBox Grid.Column="0"
                             Text="{Binding EmbeddingModelPath}"
                             Watermark="Path to embedding model (.gguf or .onnx)"
                             IsReadOnly="True"/>
                    <Button Grid.Column="1"
                            Content="Browse..."
                            Margin="8,0,0,0"
                            Command="{Binding BrowseModelCommand}"/>
                </Grid>
                <TextBlock Text="Supported formats: GGUF (llama.cpp), ONNX. Recommended: nomic-embed-text"
                           Opacity="0.7"
                           FontSize="12"
                           Margin="0,4,0,0"/>
            </StackPanel>

            <Separator IsVisible="{Binding Enabled}"/>

            <!-- Chat Integration -->
            <StackPanel IsEnabled="{Binding Enabled}">
                <TextBlock Text="Chat Integration" FontWeight="SemiBold" Margin="0,0,0,8"/>

                <CheckBox Content="Enable RAG in chat by default"
                          IsChecked="{Binding EnableRagInChat}"
                          Margin="0,0,0,8"/>

                <Grid ColumnDefinitions="Auto,150,Auto,150" RowDefinitions="Auto,Auto" Margin="0,8,0,0">
                    <TextBlock Grid.Row="0" Grid.Column="0"
                               Text="Max context tokens:"
                               VerticalAlignment="Center"/>
                    <NumericUpDown Grid.Row="0" Grid.Column="1"
                                   Value="{Binding MaxRagContextTokens}"
                                   Minimum="500"
                                   Maximum="16000"
                                   Increment="500"
                                   Margin="8,0,16,0"/>

                    <TextBlock Grid.Row="0" Grid.Column="2"
                               Text="Min relevance:"
                               VerticalAlignment="Center"/>
                    <NumericUpDown Grid.Row="0" Grid.Column="3"
                                   Value="{Binding MinRelevanceScore}"
                                   Minimum="0"
                                   Maximum="1"
                                   Increment="0.1"
                                   FormatString="F1"
                                   Margin="8,0,0,0"/>
                </Grid>

                <StackPanel Margin="0,12,0,0">
                    <TextBlock Text="Reranking strategy:" Margin="0,0,0,4"/>
                    <ComboBox SelectedItem="{Binding RerankingStrategy}"
                              ItemsSource="{Binding RerankingStrategies}"
                              Width="200"
                              HorizontalAlignment="Left"/>
                </StackPanel>
            </StackPanel>

            <Separator IsVisible="{Binding Enabled}"/>

            <!-- Auto-Indexing -->
            <StackPanel IsEnabled="{Binding Enabled}">
                <TextBlock Text="Auto-Indexing" FontWeight="SemiBold" Margin="0,0,0,8"/>

                <CheckBox Content="Automatically index files when they change"
                          IsChecked="{Binding AutoIndexEnabled}"
                          Margin="0,0,0,8"/>

                <StackPanel Orientation="Horizontal"
                            IsEnabled="{Binding AutoIndexEnabled}"
                            Margin="28,0,0,0">
                    <TextBlock Text="Delay before indexing:" VerticalAlignment="Center"/>
                    <NumericUpDown Value="{Binding AutoIndexDelaySeconds}"
                                   Minimum="1"
                                   Maximum="60"
                                   Margin="8,0,8,0"
                                   Width="80"/>
                    <TextBlock Text="seconds" VerticalAlignment="Center"/>
                </StackPanel>
            </StackPanel>

            <Separator IsVisible="{Binding Enabled}"/>

            <!-- Indexing Options -->
            <StackPanel IsEnabled="{Binding Enabled}">
                <TextBlock Text="Indexing Options" FontWeight="SemiBold" Margin="0,0,0,8"/>

                <CheckBox Content="Respect .gitignore"
                          IsChecked="{Binding RespectGitignore}"
                          Margin="0,0,0,4"/>
                <CheckBox Content="Index hidden files and directories"
                          IsChecked="{Binding IndexHiddenFiles}"
                          Margin="0,0,0,12"/>

                <Grid ColumnDefinitions="Auto,100,Auto,100,Auto,100" Margin="0,8,0,0">
                    <TextBlock Grid.Column="0" Text="Chunk size:" VerticalAlignment="Center"/>
                    <NumericUpDown Grid.Column="1"
                                   Value="{Binding ChunkSize}"
                                   Minimum="100"
                                   Maximum="2000"
                                   Increment="64"
                                   Margin="8,0,16,0"/>

                    <TextBlock Grid.Column="2" Text="Overlap:" VerticalAlignment="Center"/>
                    <NumericUpDown Grid.Column="3"
                                   Value="{Binding ChunkOverlap}"
                                   Minimum="0"
                                   Maximum="256"
                                   Increment="16"
                                   Margin="8,0,16,0"/>

                    <TextBlock Grid.Column="4" Text="Max file (KB):" VerticalAlignment="Center"/>
                    <NumericUpDown Grid.Column="5"
                                   Value="{Binding MaxFileSizeKb}"
                                   Minimum="1"
                                   Maximum="10240"
                                   Increment="256"
                                   Margin="8,0,0,0"/>
                </Grid>
            </StackPanel>

            <Separator IsVisible="{Binding Enabled}"/>

            <!-- UI Options -->
            <StackPanel IsEnabled="{Binding Enabled}">
                <TextBlock Text="Interface" FontWeight="SemiBold" Margin="0,0,0,8"/>

                <CheckBox Content="Show RAG status indicator"
                          IsChecked="{Binding ShowStatusIndicator}"
                          Margin="0,0,0,4"/>
                <CheckBox Content="Show indexing notifications"
                          IsChecked="{Binding ShowIndexingNotifications}"/>
            </StackPanel>

            <Separator IsVisible="{Binding Enabled}"/>

            <!-- Actions -->
            <StackPanel Orientation="Horizontal" Spacing="8">
                <Button Content="Open Index Manager"
                        Command="{Binding OpenIndexManagerCommand}"/>
                <Button Content="Reset to Defaults"
                        Command="{Binding ResetToDefaultsCommand}"/>
            </StackPanel>

        </StackPanel>
    </ScrollViewer>
</UserControl>
```

### File: `src/SeniorIntern.Desktop/Views/Settings/RagSettingsPanel.axaml.cs`

```csharp
using Avalonia.Controls;

namespace SeniorIntern.Desktop.Views.Settings;

public partial class RagSettingsPanel : UserControl
{
    public RagSettingsPanel()
    {
        InitializeComponent();
    }
}
```

### File: `src/SeniorIntern.Desktop/ViewModels/RagSettingsViewModel.cs`

```csharp
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Avalonia.Platform.Storage;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using SeniorIntern.Core.Models;
using SeniorIntern.Services.Settings;

namespace SeniorIntern.Desktop.ViewModels;

public partial class RagSettingsViewModel : ViewModelBase
{
    private readonly IRagSettingsService _settingsService;
    private readonly IStorageProvider _storageProvider;

    public event EventHandler? OpenIndexManagerRequested;

    #region Observable Properties

    [ObservableProperty]
    private bool _enabled = true;

    [ObservableProperty]
    private string? _embeddingModelPath;

    [ObservableProperty]
    private bool _enableRagInChat = true;

    [ObservableProperty]
    private int _maxRagContextTokens = 4000;

    [ObservableProperty]
    private float _minRelevanceScore = 0.5f;

    [ObservableProperty]
    private RerankingStrategy _rerankingStrategy = RerankingStrategy.KeywordBoost;

    [ObservableProperty]
    private bool _autoIndexEnabled = true;

    [ObservableProperty]
    private int _autoIndexDelaySeconds = 2;

    [ObservableProperty]
    private bool _respectGitignore = true;

    [ObservableProperty]
    private bool _indexHiddenFiles;

    [ObservableProperty]
    private int _chunkSize = 512;

    [ObservableProperty]
    private int _chunkOverlap = 64;

    [ObservableProperty]
    private int _maxFileSizeKb = 1024;

    [ObservableProperty]
    private bool _showStatusIndicator = true;

    [ObservableProperty]
    private bool _showIndexingNotifications = true;

    #endregion

    public IReadOnlyList<RerankingStrategy> RerankingStrategies { get; } = new[]
    {
        RerankingStrategy.None,
        RerankingStrategy.KeywordBoost,
        RerankingStrategy.RRF
    };

    public RagSettingsViewModel(
        IRagSettingsService settingsService,
        IStorageProvider storageProvider)
    {
        _settingsService = settingsService;
        _storageProvider = storageProvider;
    }

    public async Task LoadAsync()
    {
        var settings = await _settingsService.GetSettingsAsync();
        ApplySettings(settings);
    }

    public async Task SaveAsync()
    {
        var settings = BuildSettings();
        await _settingsService.SaveSettingsAsync(settings);
    }

    private void ApplySettings(RagSettings settings)
    {
        Enabled = settings.Enabled;
        EmbeddingModelPath = settings.EmbeddingModelPath;
        EnableRagInChat = settings.EnableRagInChat;
        MaxRagContextTokens = settings.MaxRagContextTokens;
        MinRelevanceScore = settings.MinRelevanceScore;
        RerankingStrategy = settings.RerankingStrategy;
        AutoIndexEnabled = settings.AutoIndexEnabled;
        AutoIndexDelaySeconds = settings.AutoIndexDelaySeconds;
        RespectGitignore = settings.RespectGitignore;
        IndexHiddenFiles = settings.IndexHiddenFiles;
        ChunkSize = settings.ChunkSize;
        ChunkOverlap = settings.ChunkOverlap;
        MaxFileSizeKb = settings.MaxFileSizeKb;
        ShowStatusIndicator = settings.ShowStatusIndicator;
        ShowIndexingNotifications = settings.ShowIndexingNotifications;
    }

    private RagSettings BuildSettings()
    {
        return new RagSettings
        {
            Enabled = Enabled,
            EmbeddingModelPath = EmbeddingModelPath,
            EnableRagInChat = EnableRagInChat,
            MaxRagContextTokens = MaxRagContextTokens,
            MinRelevanceScore = MinRelevanceScore,
            RerankingStrategy = RerankingStrategy,
            AutoIndexEnabled = AutoIndexEnabled,
            AutoIndexDelaySeconds = AutoIndexDelaySeconds,
            RespectGitignore = RespectGitignore,
            IndexHiddenFiles = IndexHiddenFiles,
            ChunkSize = ChunkSize,
            ChunkOverlap = ChunkOverlap,
            MaxFileSizeKb = MaxFileSizeKb,
            ShowStatusIndicator = ShowStatusIndicator,
            ShowIndexingNotifications = ShowIndexingNotifications
        };
    }

    [RelayCommand]
    private async Task BrowseModelAsync()
    {
        var files = await _storageProvider.OpenFilePickerAsync(new FilePickerOpenOptions
        {
            Title = "Select Embedding Model",
            AllowMultiple = false,
            FileTypeFilter = new[]
            {
                new FilePickerFileType("Embedding Models")
                {
                    Patterns = new[] { "*.gguf", "*.onnx" }
                }
            }
        });

        if (files.Count > 0)
        {
            EmbeddingModelPath = files[0].Path.LocalPath;
        }
    }

    [RelayCommand]
    private void OpenIndexManager()
    {
        OpenIndexManagerRequested?.Invoke(this, EventArgs.Empty);
    }

    [RelayCommand]
    private void ResetToDefaults()
    {
        var defaults = RagSettings.Default;
        ApplySettings(defaults);
    }
}
```

### File to Modify: `src/SeniorIntern.Desktop/Views/Settings/SettingsDialog.axaml`

Add RAG tab to existing settings dialog:

```xml
<!-- Add to TabControl in SettingsDialog -->
<TabItem Header="RAG">
    <settings:RagSettingsPanel DataContext="{Binding RagSettings}"/>
</TabItem>
```

### Dependencies
- CommunityToolkit.Mvvm
- IRagSettingsService from v0.7.5a

### Implementation Notes
1. Settings are organized into logical sections
2. All controls are disabled when RAG is disabled
3. Settings auto-save when dialog closes
4. Reset to defaults available for troubleshooting

---

## v0.7.5g: Auto-Indexing File Watcher

### Objective
Implement automatic re-indexing when files change in the workspace.

### File: `src/SeniorIntern.Services/Indexing/AutoIndexingService.cs`

```csharp
using System;
using System.Collections.Concurrent;
using System.IO;
using System.Threading;
using System.Threading.Channels;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Services.Settings;

namespace SeniorIntern.Services.Indexing;

/// <summary>
/// Service that watches for file changes and automatically updates the index.
/// </summary>
public sealed class AutoIndexingService : IAsyncDisposable
{
    private readonly IIndexingService _indexingService;
    private readonly IVectorStore _vectorStore;
    private readonly IRagSettingsService _settingsService;
    private readonly IGitignoreParser _gitignoreParser;
    private readonly ILogger<AutoIndexingService> _logger;

    private FileSystemWatcher? _watcher;
    private string? _watchedPath;
    private string? _indexId;
    private RagSettings? _settings;

    private readonly Channel<FileChangeEvent> _changeChannel;
    private readonly ConcurrentDictionary<string, DateTime> _pendingChanges = new();
    private readonly CancellationTokenSource _cts = new();
    private Task? _processingTask;

    public bool IsWatching => _watcher != null;

    public event EventHandler<AutoIndexEventArgs>? FileIndexed;
    public event EventHandler<AutoIndexEventArgs>? IndexingStarted;
    public event EventHandler<AutoIndexEventArgs>? IndexingCompleted;
    public event EventHandler<AutoIndexErrorEventArgs>? IndexingError;

    public AutoIndexingService(
        IIndexingService indexingService,
        IVectorStore vectorStore,
        IRagSettingsService settingsService,
        IGitignoreParser gitignoreParser,
        ILogger<AutoIndexingService> logger)
    {
        _indexingService = indexingService;
        _vectorStore = vectorStore;
        _settingsService = settingsService;
        _gitignoreParser = gitignoreParser;
        _logger = logger;
        _changeChannel = Channel.CreateUnbounded<FileChangeEvent>(new UnboundedChannelOptions
        {
            SingleReader = true,
            SingleWriter = false
        });
    }

    public async Task StartWatchingAsync(string workspacePath, CancellationToken ct = default)
    {
        if (_watcher != null)
        {
            await StopWatchingAsync();
        }

        _settings = await _settingsService.GetSettingsAsync(ct);

        if (!_settings.AutoIndexEnabled)
        {
            _logger.LogInformation("Auto-indexing is disabled");
            return;
        }

        var index = await _vectorStore.GetIndexForWorkspaceAsync(workspacePath, ct);
        if (index == null)
        {
            _logger.LogWarning("No index found for workspace: {Path}. Auto-indexing disabled.", workspacePath);
            return;
        }

        _watchedPath = workspacePath;
        _indexId = index.Id;

        // Load gitignore if enabled
        if (_settings.RespectGitignore)
        {
            var gitignorePath = Path.Combine(workspacePath, ".gitignore");
            if (File.Exists(gitignorePath))
            {
                await _gitignoreParser.LoadAsync(gitignorePath, ct);
            }
        }

        // Create file system watcher
        _watcher = new FileSystemWatcher(workspacePath)
        {
            IncludeSubdirectories = true,
            NotifyFilter = NotifyFilters.LastWrite |
                          NotifyFilters.FileName |
                          NotifyFilters.DirectoryName,
            InternalBufferSize = 64 * 1024 // 64KB buffer
        };

        _watcher.Changed += OnFileChanged;
        _watcher.Created += OnFileCreated;
        _watcher.Deleted += OnFileDeleted;
        _watcher.Renamed += OnFileRenamed;
        _watcher.Error += OnWatcherError;

        _watcher.EnableRaisingEvents = true;

        // Start processing task
        _processingTask = ProcessChangesAsync(_cts.Token);

        _logger.LogInformation("Started watching workspace for changes: {Path}", workspacePath);
    }

    public async Task StopWatchingAsync()
    {
        if (_watcher != null)
        {
            _watcher.EnableRaisingEvents = false;
            _watcher.Dispose();
            _watcher = null;
        }

        _watchedPath = null;
        _indexId = null;

        // Wait for processing to complete
        if (_processingTask != null)
        {
            _cts.Cancel();
            try
            {
                await _processingTask.WaitAsync(TimeSpan.FromSeconds(5));
            }
            catch (TimeoutException)
            {
                _logger.LogWarning("Processing task did not complete within timeout");
            }
        }

        _logger.LogInformation("Stopped watching workspace");
    }

    private void OnFileChanged(object sender, FileSystemEventArgs e)
    {
        QueueChange(e.FullPath, FileChangeType.Modified);
    }

    private void OnFileCreated(object sender, FileSystemEventArgs e)
    {
        QueueChange(e.FullPath, FileChangeType.Created);
    }

    private void OnFileDeleted(object sender, FileSystemEventArgs e)
    {
        QueueChange(e.FullPath, FileChangeType.Deleted);
    }

    private void OnFileRenamed(object sender, RenamedEventArgs e)
    {
        QueueChange(e.OldFullPath, FileChangeType.Deleted);
        QueueChange(e.FullPath, FileChangeType.Created);
    }

    private void OnWatcherError(object sender, ErrorEventArgs e)
    {
        _logger.LogError(e.GetException(), "File watcher error");
        IndexingError?.Invoke(this, new AutoIndexErrorEventArgs
        {
            Error = e.GetException()
        });
    }

    private void QueueChange(string path, FileChangeType changeType)
    {
        if (ShouldIgnore(path))
            return;

        _changeChannel.Writer.TryWrite(new FileChangeEvent
        {
            FilePath = path,
            ChangeType = changeType,
            Timestamp = DateTime.UtcNow
        });
    }

    private bool ShouldIgnore(string path)
    {
        if (string.IsNullOrEmpty(_watchedPath))
            return true;

        var relativePath = Path.GetRelativePath(_watchedPath, path);

        // Ignore common non-indexable paths
        if (IsCommonIgnoredPath(relativePath))
            return true;

        // Check gitignore
        if (_settings?.RespectGitignore == true && _gitignoreParser.IsIgnored(relativePath))
            return true;

        // Check file extension
        var extension = Path.GetExtension(path);
        if (!IsIndexableExtension(extension))
            return true;

        // Check hidden files
        if (!_settings?.IndexHiddenFiles == true)
        {
            var fileName = Path.GetFileName(path);
            if (fileName.StartsWith('.'))
                return true;
        }

        return false;
    }

    private static bool IsCommonIgnoredPath(string relativePath)
    {
        var pathLower = relativePath.ToLowerInvariant();

        return pathLower.StartsWith(".git") ||
               pathLower.Contains("node_modules") ||
               pathLower.Contains($"{Path.DirectorySeparatorChar}bin{Path.DirectorySeparatorChar}") ||
               pathLower.Contains($"{Path.DirectorySeparatorChar}obj{Path.DirectorySeparatorChar}") ||
               pathLower.Contains($"{Path.DirectorySeparatorChar}.vs{Path.DirectorySeparatorChar}") ||
               pathLower.EndsWith(".tmp") ||
               pathLower.EndsWith(".lock") ||
               pathLower.EndsWith(".log");
    }

    private static bool IsIndexableExtension(string extension)
    {
        var ext = extension.ToLowerInvariant();
        return ext switch
        {
            ".cs" or ".ts" or ".tsx" or ".js" or ".jsx" => true,
            ".py" or ".java" or ".go" or ".rs" => true,
            ".cpp" or ".c" or ".h" or ".hpp" => true,
            ".md" or ".json" or ".yaml" or ".yml" or ".xml" => true,
            ".html" or ".css" or ".scss" => true,
            _ => false
        };
    }

    private async Task ProcessChangesAsync(CancellationToken ct)
    {
        var debounceTime = TimeSpan.FromSeconds(_settings?.AutoIndexDelaySeconds ?? 2);

        while (!ct.IsCancellationRequested)
        {
            try
            {
                await foreach (var change in _changeChannel.Reader.ReadAllAsync(ct))
                {
                    // Track pending changes with debouncing
                    _pendingChanges[change.FilePath] = change.Timestamp;

                    // Schedule processing after debounce period
                    _ = Task.Run(async () =>
                    {
                        await Task.Delay(debounceTime, ct);
                        await ProcessPendingChangesAsync(ct);
                    }, ct);
                }
            }
            catch (OperationCanceledException)
            {
                break;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error processing file changes");
            }
        }
    }

    private async Task ProcessPendingChangesAsync(CancellationToken ct)
    {
        if (string.IsNullOrEmpty(_indexId))
            return;

        var cutoff = DateTime.UtcNow - TimeSpan.FromSeconds(_settings?.AutoIndexDelaySeconds ?? 2);
        var toProcess = new List<string>();

        foreach (var kvp in _pendingChanges)
        {
            if (kvp.Value <= cutoff)
            {
                if (_pendingChanges.TryRemove(kvp.Key, out _))
                {
                    toProcess.Add(kvp.Key);
                }
            }
        }

        if (toProcess.Count == 0)
            return;

        IndexingStarted?.Invoke(this, new AutoIndexEventArgs
        {
            FilePaths = toProcess.ToArray()
        });

        foreach (var path in toProcess)
        {
            try
            {
                if (!File.Exists(path))
                {
                    // File was deleted
                    await _vectorStore.RemoveChunksForFileAsync(_indexId, path, ct);
                    _logger.LogDebug("Removed chunks for deleted file: {Path}", path);
                }
                else
                {
                    // File was created or modified
                    await _indexingService.IndexFilesAsync(_indexId, new[] { path }, null, ct);
                    _logger.LogDebug("Re-indexed file: {Path}", path);
                }

                FileIndexed?.Invoke(this, new AutoIndexEventArgs
                {
                    FilePaths = new[] { path },
                    Success = true
                });
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Failed to process file change: {Path}", path);
                IndexingError?.Invoke(this, new AutoIndexErrorEventArgs
                {
                    FilePath = path,
                    Error = ex
                });
            }
        }

        IndexingCompleted?.Invoke(this, new AutoIndexEventArgs
        {
            FilePaths = toProcess.ToArray(),
            Success = true
        });
    }

    public async ValueTask DisposeAsync()
    {
        await StopWatchingAsync();
        _cts.Dispose();
    }

    private enum FileChangeType
    {
        Created,
        Modified,
        Deleted
    }

    private sealed record FileChangeEvent
    {
        public string FilePath { get; init; } = string.Empty;
        public FileChangeType ChangeType { get; init; }
        public DateTime Timestamp { get; init; }
    }
}

public sealed class AutoIndexEventArgs : EventArgs
{
    public string[] FilePaths { get; init; } = Array.Empty<string>();
    public bool Success { get; init; }
}

public sealed class AutoIndexErrorEventArgs : EventArgs
{
    public string? FilePath { get; init; }
    public Exception Error { get; init; } = null!;
}
```

### File: `src/SeniorIntern.Services/Indexing/AutoIndexingBackgroundService.cs`

```csharp
using System;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using SeniorIntern.Services.Settings;

namespace SeniorIntern.Services.Indexing;

/// <summary>
/// Background service that manages automatic indexing.
/// </summary>
public sealed class AutoIndexingBackgroundService : BackgroundService
{
    private readonly AutoIndexingService _autoIndexingService;
    private readonly IRagSettingsService _settingsService;
    private readonly ILogger<AutoIndexingBackgroundService> _logger;

    private string? _currentWorkspace;

    public AutoIndexingBackgroundService(
        AutoIndexingService autoIndexingService,
        IRagSettingsService settingsService,
        ILogger<AutoIndexingBackgroundService> logger)
    {
        _autoIndexingService = autoIndexingService;
        _settingsService = settingsService;
        _logger = logger;

        // Listen for settings changes
        _settingsService.SettingsChanged += OnSettingsChanged;
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        // Wait for application to fully start
        await Task.Delay(1000, stoppingToken);

        var settings = await _settingsService.GetSettingsAsync(stoppingToken);

        if (settings.AutoIndexEnabled && !string.IsNullOrEmpty(settings.LastWorkspacePath))
        {
            _currentWorkspace = settings.LastWorkspacePath;
            await _autoIndexingService.StartWatchingAsync(_currentWorkspace, stoppingToken);
        }

        // Keep the service running
        await Task.Delay(Timeout.Infinite, stoppingToken);
    }

    public async Task SetWorkspaceAsync(string? workspacePath, CancellationToken ct = default)
    {
        if (_currentWorkspace == workspacePath)
            return;

        _currentWorkspace = workspacePath;

        if (string.IsNullOrEmpty(workspacePath))
        {
            await _autoIndexingService.StopWatchingAsync();
        }
        else
        {
            var settings = await _settingsService.GetSettingsAsync(ct);
            if (settings.AutoIndexEnabled)
            {
                await _autoIndexingService.StartWatchingAsync(workspacePath, ct);
            }
        }
    }

    private async void OnSettingsChanged(object? sender, RagSettings settings)
    {
        if (settings.AutoIndexEnabled && !string.IsNullOrEmpty(_currentWorkspace))
        {
            if (!_autoIndexingService.IsWatching)
            {
                await _autoIndexingService.StartWatchingAsync(_currentWorkspace);
            }
        }
        else
        {
            await _autoIndexingService.StopWatchingAsync();
        }
    }

    public override async Task StopAsync(CancellationToken cancellationToken)
    {
        await _autoIndexingService.StopWatchingAsync();
        await base.StopAsync(cancellationToken);
    }
}
```

### File: `src/SeniorIntern.Services/DependencyInjection.AutoIndexing.cs`

```csharp
using Microsoft.Extensions.DependencyInjection;
using SeniorIntern.Services.Indexing;

namespace SeniorIntern.Services;

public static partial class DependencyInjection
{
    public static IServiceCollection AddAutoIndexing(this IServiceCollection services)
    {
        services.AddSingleton<AutoIndexingService>();
        services.AddHostedService<AutoIndexingBackgroundService>();

        return services;
    }
}
```

### Dependencies
- IIndexingService from v0.7.3
- IVectorStore from v0.7.2
- IRagSettingsService from v0.7.5a

### Implementation Notes
1. Uses Channel for thread-safe event queuing
2. Debouncing prevents excessive re-indexing during rapid saves
3. Background service manages lifecycle
4. Events allow UI to show notifications

---

## v0.7.5h: Chat Interface RAG Integration

### Objective
Integrate RAG toggle and status into the chat interface.

### File: `src/SeniorIntern.Desktop/Controls/RagToggleButton.axaml`

```xml
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             mc:Ignorable="d"
             x:Class="SeniorIntern.Desktop.Controls.RagToggleButton">

    <ToggleButton IsChecked="{Binding IsEnabled, Mode=TwoWay}"
                  ToolTip.Tip="{Binding TooltipText}"
                  IsEnabled="{Binding CanToggle}">
        <StackPanel Orientation="Horizontal" Spacing="4">
            <PathIcon Data="{StaticResource database_search_regular}"
                      Width="16" Height="16"/>
            <TextBlock Text="RAG"
                       VerticalAlignment="Center"
                       IsVisible="{Binding ShowLabel}"/>
        </StackPanel>
    </ToggleButton>
</UserControl>
```

### File: `src/SeniorIntern.Desktop/Controls/RagToggleButton.axaml.cs`

```csharp
using Avalonia;
using Avalonia.Controls;

namespace SeniorIntern.Desktop.Controls;

public partial class RagToggleButton : UserControl
{
    public static readonly StyledProperty<bool> IsEnabledProperty =
        AvaloniaProperty.Register<RagToggleButton, bool>(nameof(IsEnabled), defaultValue: true);

    public static readonly StyledProperty<bool> CanToggleProperty =
        AvaloniaProperty.Register<RagToggleButton, bool>(nameof(CanToggle), defaultValue: true);

    public static readonly StyledProperty<bool> ShowLabelProperty =
        AvaloniaProperty.Register<RagToggleButton, bool>(nameof(ShowLabel), defaultValue: true);

    public new bool IsEnabled
    {
        get => GetValue(IsEnabledProperty);
        set => SetValue(IsEnabledProperty, value);
    }

    public bool CanToggle
    {
        get => GetValue(CanToggleProperty);
        set => SetValue(CanToggleProperty, value);
    }

    public bool ShowLabel
    {
        get => GetValue(ShowLabelProperty);
        set => SetValue(ShowLabelProperty, value);
    }

    public string TooltipText => IsEnabled
        ? "RAG enabled - AI will search your codebase for context"
        : "RAG disabled - AI will not search your codebase";

    public RagToggleButton()
    {
        InitializeComponent();
        DataContext = this;
    }
}
```

### File to Modify: `src/SeniorIntern.Desktop/Views/ChatView.axaml`

Add RAG toggle to chat input area:

```xml
<!-- Add to the chat input toolbar section -->
<controls:RagToggleButton
    IsEnabled="{Binding IsRagEnabled}"
    CanToggle="{Binding CanToggleRag}"
    ShowLabel="True"
    Margin="0,0,8,0"/>
```

### File to Modify: `src/SeniorIntern.Desktop/ViewModels/ChatViewModel.cs`

Add RAG-related properties and logic:

```csharp
// Add these properties to ChatViewModel:

[ObservableProperty]
private bool _isRagEnabled = true;

[ObservableProperty]
private bool _canToggleRag = true;

partial void OnIsRagEnabledChanged(bool value)
{
    _logger.LogDebug("RAG {Status}", value ? "enabled" : "disabled");
}

// Modify the SendMessageAsync method to include RAG options:
private async Task SendMessageAsync()
{
    // ... existing code ...

    var ragOptions = new RagChatOptions
    {
        EnableRag = IsRagEnabled && CanToggleRag,
        WorkspacePath = _currentWorkspacePath,
        MaxRagTokens = _settings.Rag.MaxRagContextTokens,
        MaxRagChunks = _settings.Rag.MaxRagChunks,
        MinRelevance = _settings.Rag.MinRelevanceScore
    };

    await foreach (var token in _ragChatService.GenerateWithRagAsync(
        _conversationId,
        userMessage,
        ragOptions,
        _cts.Token))
    {
        // ... existing streaming logic ...
    }
}
```

### Dependencies
- RagChatService from v0.7.4
- RagSettings from v0.7.5a

### Implementation Notes
1. Toggle button provides quick enable/disable of RAG
2. Disabled state when workspace not indexed
3. Settings integration for persistence
4. Tooltip explains current state

---

## v0.7.5i: Workspace Selector

### Objective
Create a workspace selector for managing multiple indexed projects.

### File: `src/SeniorIntern.Desktop/Controls/WorkspaceSelector.axaml`

```xml
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             mc:Ignorable="d"
             x:Class="SeniorIntern.Desktop.Controls.WorkspaceSelector">

    <Grid ColumnDefinitions="*,Auto">
        <ComboBox Grid.Column="0"
                  ItemsSource="{Binding Workspaces}"
                  SelectedItem="{Binding SelectedWorkspace}"
                  PlaceholderText="Select workspace..."
                  MinWidth="200">
            <ComboBox.ItemTemplate>
                <DataTemplate>
                    <StackPanel>
                        <TextBlock Text="{Binding DisplayName}" FontWeight="SemiBold"/>
                        <TextBlock Text="{Binding WorkspacePath}"
                                   FontSize="11"
                                   Opacity="0.7"
                                   TextTrimming="CharacterEllipsis"/>
                    </StackPanel>
                </DataTemplate>
            </ComboBox.ItemTemplate>
        </ComboBox>

        <StackPanel Grid.Column="1" Orientation="Horizontal" Margin="8,0,0,0">
            <Button Command="{Binding AddWorkspaceCommand}"
                    ToolTip.Tip="Add workspace">
                <PathIcon Data="{StaticResource add_regular}" Width="16" Height="16"/>
            </Button>
            <Button Command="{Binding OpenFolderCommand}"
                    ToolTip.Tip="Open in file explorer"
                    Margin="4,0,0,0"
                    IsEnabled="{Binding HasSelectedWorkspace}">
                <PathIcon Data="{StaticResource folder_open_regular}" Width="16" Height="16"/>
            </Button>
        </StackPanel>
    </Grid>
</UserControl>
```

### File: `src/SeniorIntern.Desktop/Controls/WorkspaceSelector.axaml.cs`

```csharp
using Avalonia.Controls;

namespace SeniorIntern.Desktop.Controls;

public partial class WorkspaceSelector : UserControl
{
    public WorkspaceSelector()
    {
        InitializeComponent();
    }
}
```

### File: `src/SeniorIntern.Desktop/ViewModels/WorkspaceSelectorViewModel.cs`

```csharp
using System;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Linq;
using System.Threading.Tasks;
using Avalonia.Platform.Storage;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Services.Settings;

namespace SeniorIntern.Desktop.ViewModels;

public partial class WorkspaceSelectorViewModel : ViewModelBase
{
    private readonly IVectorStore _vectorStore;
    private readonly IRagSettingsService _settingsService;
    private readonly IStorageProvider _storageProvider;
    private readonly ILogger<WorkspaceSelectorViewModel> _logger;

    public event EventHandler<WorkspaceIndexInfo>? WorkspaceSelected;

    [ObservableProperty]
    private WorkspaceIndexInfo? _selectedWorkspace;

    public ObservableCollection<WorkspaceIndexInfo> Workspaces { get; } = new();

    public bool HasSelectedWorkspace => SelectedWorkspace != null;

    public WorkspaceSelectorViewModel(
        IVectorStore vectorStore,
        IRagSettingsService settingsService,
        IStorageProvider storageProvider,
        ILogger<WorkspaceSelectorViewModel> logger)
    {
        _vectorStore = vectorStore;
        _settingsService = settingsService;
        _storageProvider = storageProvider;
        _logger = logger;
    }

    public async Task LoadWorkspacesAsync()
    {
        Workspaces.Clear();

        var indexes = await _vectorStore.GetAllIndexesAsync();
        var settings = await _settingsService.GetSettingsAsync();

        foreach (var index in indexes.OrderByDescending(i => i.UpdatedAt))
        {
            var info = new WorkspaceIndexInfo
            {
                IndexId = index.Id,
                WorkspacePath = index.WorkspacePath,
                DisplayName = index.Name,
                CreatedAt = index.CreatedAt,
                LastUpdated = index.UpdatedAt,
                FileCount = index.FileCount,
                ChunkCount = index.ChunkCount,
                EmbeddingModel = index.Settings.EmbeddingModelPath,
                EmbeddingDimension = index.EmbeddingDimension,
                IsActive = index.WorkspacePath == settings.LastWorkspacePath
            };

            Workspaces.Add(info);

            if (info.IsActive)
            {
                SelectedWorkspace = info;
            }
        }
    }

    partial void OnSelectedWorkspaceChanged(WorkspaceIndexInfo? value)
    {
        OnPropertyChanged(nameof(HasSelectedWorkspace));

        if (value != null)
        {
            // Update last workspace in settings
            Task.Run(async () =>
            {
                var settings = await _settingsService.GetSettingsAsync();
                settings.LastWorkspacePath = value.WorkspacePath;
                await _settingsService.SaveSettingsAsync(settings);
            });

            WorkspaceSelected?.Invoke(this, value);
        }
    }

    [RelayCommand]
    private async Task AddWorkspaceAsync()
    {
        var folders = await _storageProvider.OpenFolderPickerAsync(new FolderPickerOpenOptions
        {
            Title = "Select Workspace to Index",
            AllowMultiple = false
        });

        if (folders.Count > 0)
        {
            var path = folders[0].Path.LocalPath;

            // Check if already exists
            if (Workspaces.Any(w => w.WorkspacePath.Equals(path, StringComparison.OrdinalIgnoreCase)))
            {
                _logger.LogInformation("Workspace already indexed: {Path}", path);
                SelectedWorkspace = Workspaces.First(w =>
                    w.WorkspacePath.Equals(path, StringComparison.OrdinalIgnoreCase));
                return;
            }

            // Trigger indexing for new workspace
            // This would typically open the Index Manager dialog
            _logger.LogInformation("New workspace selected: {Path}", path);
        }
    }

    [RelayCommand]
    private void OpenFolder()
    {
        if (SelectedWorkspace == null)
            return;

        try
        {
            Process.Start(new ProcessStartInfo
            {
                FileName = SelectedWorkspace.WorkspacePath,
                UseShellExecute = true
            });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to open folder");
        }
    }

    [RelayCommand]
    private async Task RefreshAsync()
    {
        await LoadWorkspacesAsync();
    }
}
```

### File to Modify: `src/SeniorIntern.Desktop/Views/MainWindow.axaml`

Add workspace selector to toolbar or header:

```xml
<!-- Add to the header/toolbar area -->
<controls:WorkspaceSelector
    DataContext="{Binding WorkspaceSelector}"
    Margin="8,0"/>
```

### Dependencies
- IVectorStore from v0.7.2
- IRagSettingsService from v0.7.5a

### Implementation Notes
1. Dropdown shows all indexed workspaces
2. Selected workspace is persisted in settings
3. Quick access to add new workspace
4. Open in file explorer for navigation

---

## v0.7.5j: Unit Testing & Integration

### Objective
Create comprehensive tests for all v0.7.5 UI components and services.

### File: `tests/SeniorIntern.Tests/Settings/RagSettingsTests.cs`

```csharp
using SeniorIntern.Core.Models;
using Xunit;

namespace SeniorIntern.Tests.Settings;

public class RagSettingsTests
{
    [Fact]
    public void Default_HasValidSettings()
    {
        var settings = RagSettings.Default;

        Assert.True(settings.Enabled);
        Assert.True(settings.AutoIndexEnabled);
        Assert.Equal(512, settings.ChunkSize);
        Assert.Equal(64, settings.ChunkOverlap);
    }

    [Fact]
    public void Validate_ValidSettings_ReturnsNoErrors()
    {
        var settings = new RagSettings
        {
            ChunkSize = 512,
            ChunkOverlap = 64,
            MaxFileSizeKb = 1024,
            MaxRagContextTokens = 4000,
            MinRelevanceScore = 0.5f,
            AutoIndexDelaySeconds = 2
        };

        var errors = settings.Validate();

        Assert.Empty(errors);
    }

    [Fact]
    public void Validate_InvalidChunkSize_ReturnsError()
    {
        var settings = new RagSettings { ChunkSize = 50 };

        var errors = settings.Validate();

        Assert.Contains(errors, e => e.Contains("Chunk size"));
    }

    [Fact]
    public void Validate_ChunkOverlapTooLarge_ReturnsError()
    {
        var settings = new RagSettings
        {
            ChunkSize = 100,
            ChunkOverlap = 150
        };

        var errors = settings.Validate();

        Assert.Contains(errors, e => e.Contains("Chunk overlap"));
    }

    [Fact]
    public void Validate_InvalidRelevanceScore_ReturnsError()
    {
        var settings = new RagSettings { MinRelevanceScore = 1.5f };

        var errors = settings.Validate();

        Assert.Contains(errors, e => e.Contains("relevance score"));
    }
}
```

### File: `tests/SeniorIntern.Tests/UI/IndexManagerViewModelTests.cs`

```csharp
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Moq;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Desktop.ViewModels;
using SeniorIntern.Services.Settings;
using Xunit;

namespace SeniorIntern.Tests.UI;

public class IndexManagerViewModelTests
{
    private readonly Mock<IKnowledgeService> _knowledgeServiceMock;
    private readonly Mock<IIndexingService> _indexingServiceMock;
    private readonly Mock<IEmbeddingService> _embeddingServiceMock;
    private readonly Mock<IVectorStore> _vectorStoreMock;
    private readonly Mock<IRagSettingsService> _settingsServiceMock;
    private readonly Mock<ILogger<IndexManagerViewModel>> _loggerMock;

    public IndexManagerViewModelTests()
    {
        _knowledgeServiceMock = new Mock<IKnowledgeService>();
        _indexingServiceMock = new Mock<IIndexingService>();
        _embeddingServiceMock = new Mock<IEmbeddingService>();
        _vectorStoreMock = new Mock<IVectorStore>();
        _settingsServiceMock = new Mock<IRagSettingsService>();
        _loggerMock = new Mock<ILogger<IndexManagerViewModel>>();

        _settingsServiceMock
            .Setup(s => s.GetSettingsAsync(default))
            .ReturnsAsync(RagSettings.Default);
    }

    [Fact]
    public void CanStartIndexing_NoWorkspacePath_ReturnsFalse()
    {
        var vm = CreateViewModel();
        vm.WorkspacePath = string.Empty;

        Assert.False(vm.CanStartIndexing);
    }

    [Fact]
    public void CanStartIndexing_NoModelLoaded_ReturnsFalse()
    {
        var vm = CreateViewModel();
        vm.WorkspacePath = "/test";
        // Model not loaded by default

        Assert.False(vm.CanStartIndexing);
    }

    [Fact]
    public async Task LoadIndexStatusAsync_NoIndex_SetsNotIndexed()
    {
        _knowledgeServiceMock
            .Setup(k => k.GetIndexHealthAsync("/test", default))
            .ReturnsAsync(KnowledgeIndexHealth.NotIndexed);

        var vm = CreateViewModel();
        vm.WorkspacePath = "/test";

        await vm.LoadIndexStatusCommand.ExecuteAsync(null);

        Assert.False(vm.IsIndexed);
    }

    [Fact]
    public async Task LoadIndexStatusAsync_HasIndex_SetsIndexed()
    {
        _knowledgeServiceMock
            .Setup(k => k.GetIndexHealthAsync("/test", default))
            .ReturnsAsync(new KnowledgeIndexHealth
            {
                IsIndexed = true,
                TotalFiles = 100,
                TotalChunks = 500,
                LastUpdated = System.DateTime.UtcNow
            });

        var vm = CreateViewModel();
        vm.WorkspacePath = "/test";

        await vm.LoadIndexStatusCommand.ExecuteAsync(null);

        Assert.True(vm.IsIndexed);
        Assert.Equal(100, vm.FileCount);
        Assert.Equal(500, vm.ChunkCount);
    }

    private IndexManagerViewModel CreateViewModel()
    {
        return new IndexManagerViewModel(
            _knowledgeServiceMock.Object,
            _indexingServiceMock.Object,
            _embeddingServiceMock.Object,
            _vectorStoreMock.Object,
            _settingsServiceMock.Object,
            null!, // StorageProvider - would need proper mock
            _loggerMock.Object);
    }
}
```

### File: `tests/SeniorIntern.Tests/Services/AutoIndexingServiceTests.cs`

```csharp
using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Moq;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Services.Indexing;
using SeniorIntern.Services.Settings;
using Xunit;

namespace SeniorIntern.Tests.Services;

public class AutoIndexingServiceTests : IDisposable
{
    private readonly string _testDir;
    private readonly Mock<IIndexingService> _indexingServiceMock;
    private readonly Mock<IVectorStore> _vectorStoreMock;
    private readonly Mock<IRagSettingsService> _settingsServiceMock;
    private readonly Mock<IGitignoreParser> _gitignoreParserMock;
    private readonly Mock<ILogger<AutoIndexingService>> _loggerMock;

    public AutoIndexingServiceTests()
    {
        _testDir = Path.Combine(Path.GetTempPath(), $"auto-index-test-{Guid.NewGuid()}");
        Directory.CreateDirectory(_testDir);

        _indexingServiceMock = new Mock<IIndexingService>();
        _vectorStoreMock = new Mock<IVectorStore>();
        _settingsServiceMock = new Mock<IRagSettingsService>();
        _gitignoreParserMock = new Mock<IGitignoreParser>();
        _loggerMock = new Mock<ILogger<AutoIndexingService>>();

        _settingsServiceMock
            .Setup(s => s.GetSettingsAsync(default))
            .ReturnsAsync(new RagSettings { AutoIndexEnabled = true, AutoIndexDelaySeconds = 1 });

        _vectorStoreMock
            .Setup(v => v.GetIndexForWorkspaceAsync(_testDir, default))
            .ReturnsAsync(new VectorIndex { Id = "test-index", WorkspacePath = _testDir });
    }

    [Fact]
    public async Task StartWatchingAsync_CreatesWatcher()
    {
        await using var service = CreateService();

        await service.StartWatchingAsync(_testDir);

        Assert.True(service.IsWatching);
    }

    [Fact]
    public async Task StopWatchingAsync_StopsWatcher()
    {
        await using var service = CreateService();
        await service.StartWatchingAsync(_testDir);

        await service.StopWatchingAsync();

        Assert.False(service.IsWatching);
    }

    [Fact]
    public async Task FileCreated_TriggersIndexing()
    {
        await using var service = CreateService();
        var eventRaised = new TaskCompletionSource<bool>();

        service.FileIndexed += (_, args) =>
        {
            if (args.FilePaths.Length > 0)
                eventRaised.TrySetResult(true);
        };

        await service.StartWatchingAsync(_testDir);

        // Create a file
        var testFile = Path.Combine(_testDir, "test.cs");
        await File.WriteAllTextAsync(testFile, "public class Test { }");

        // Wait for event with timeout
        var completed = await Task.WhenAny(eventRaised.Task, Task.Delay(5000));
        Assert.Equal(eventRaised.Task, completed);
    }

    public void Dispose()
    {
        if (Directory.Exists(_testDir))
        {
            Directory.Delete(_testDir, recursive: true);
        }
    }

    private AutoIndexingService CreateService()
    {
        return new AutoIndexingService(
            _indexingServiceMock.Object,
            _vectorStoreMock.Object,
            _settingsServiceMock.Object,
            _gitignoreParserMock.Object,
            _loggerMock.Object);
    }
}
```

### File: `tests/SeniorIntern.Tests/UI/RagStatusIndicatorTests.cs`

```csharp
using SeniorIntern.Desktop.Controls;
using Xunit;

namespace SeniorIntern.Tests.UI;

public class RagStatusIndicatorTests
{
    [Theory]
    [InlineData(RagStatus.Indexed, "RAG Ready")]
    [InlineData(RagStatus.Indexing, "Indexing")]
    [InlineData(RagStatus.NeedsUpdate, "Update Available")]
    [InlineData(RagStatus.Error, "RAG Error")]
    [InlineData(RagStatus.NoModel, "No Model")]
    [InlineData(RagStatus.NotIndexed, "Not Indexed")]
    public void StatusText_ReturnsCorrectText(RagStatus status, string expectedText)
    {
        var indicator = new RagStatusIndicator { Status = status };

        Assert.Equal(expectedText, indicator.StatusText);
    }

    [Fact]
    public void ProgressText_WhenIndexing_ShowsPercentage()
    {
        var indicator = new RagStatusIndicator
        {
            IsIndexing = true,
            IndexingProgress = 75.5
        };

        Assert.Contains("75", indicator.ProgressText);
    }

    [Fact]
    public void ProgressText_WhenNotIndexing_IsEmpty()
    {
        var indicator = new RagStatusIndicator { IsIndexing = false };

        Assert.Equal(string.Empty, indicator.ProgressText);
    }
}
```

### File: `tests/SeniorIntern.Tests/UI/WorkspaceSelectorViewModelTests.cs`

```csharp
using System;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Moq;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Desktop.ViewModels;
using SeniorIntern.Services.Settings;
using Xunit;

namespace SeniorIntern.Tests.UI;

public class WorkspaceSelectorViewModelTests
{
    private readonly Mock<IVectorStore> _vectorStoreMock;
    private readonly Mock<IRagSettingsService> _settingsServiceMock;
    private readonly Mock<ILogger<WorkspaceSelectorViewModel>> _loggerMock;

    public WorkspaceSelectorViewModelTests()
    {
        _vectorStoreMock = new Mock<IVectorStore>();
        _settingsServiceMock = new Mock<IRagSettingsService>();
        _loggerMock = new Mock<ILogger<WorkspaceSelectorViewModel>>();

        _settingsServiceMock
            .Setup(s => s.GetSettingsAsync(default))
            .ReturnsAsync(new RagSettings());
    }

    [Fact]
    public async Task LoadWorkspacesAsync_LoadsIndexes()
    {
        var indexes = new[]
        {
            new VectorIndex { Id = "1", Name = "Project A", WorkspacePath = "/a" },
            new VectorIndex { Id = "2", Name = "Project B", WorkspacePath = "/b" }
        };

        _vectorStoreMock
            .Setup(v => v.GetAllIndexesAsync(default))
            .ReturnsAsync(indexes);

        var vm = CreateViewModel();

        await vm.LoadWorkspacesAsync();

        Assert.Equal(2, vm.Workspaces.Count);
    }

    [Fact]
    public async Task LoadWorkspacesAsync_SelectsLastWorkspace()
    {
        var indexes = new[]
        {
            new VectorIndex { Id = "1", Name = "Project A", WorkspacePath = "/a" },
            new VectorIndex { Id = "2", Name = "Project B", WorkspacePath = "/b" }
        };

        _vectorStoreMock
            .Setup(v => v.GetAllIndexesAsync(default))
            .ReturnsAsync(indexes);

        _settingsServiceMock
            .Setup(s => s.GetSettingsAsync(default))
            .ReturnsAsync(new RagSettings { LastWorkspacePath = "/b" });

        var vm = CreateViewModel();

        await vm.LoadWorkspacesAsync();

        Assert.NotNull(vm.SelectedWorkspace);
        Assert.Equal("/b", vm.SelectedWorkspace.WorkspacePath);
    }

    [Fact]
    public void HasSelectedWorkspace_NoSelection_ReturnsFalse()
    {
        var vm = CreateViewModel();

        Assert.False(vm.HasSelectedWorkspace);
    }

    private WorkspaceSelectorViewModel CreateViewModel()
    {
        return new WorkspaceSelectorViewModel(
            _vectorStoreMock.Object,
            _settingsServiceMock.Object,
            null!, // StorageProvider
            _loggerMock.Object);
    }
}
```

### File: `tests/SeniorIntern.Tests/UI/RagSettingsViewModelTests.cs`

```csharp
using System.Threading.Tasks;
using Moq;
using SeniorIntern.Core.Models;
using SeniorIntern.Desktop.ViewModels;
using SeniorIntern.Services.Settings;
using Xunit;

namespace SeniorIntern.Tests.UI;

public class RagSettingsViewModelTests
{
    private readonly Mock<IRagSettingsService> _settingsServiceMock;

    public RagSettingsViewModelTests()
    {
        _settingsServiceMock = new Mock<IRagSettingsService>();
    }

    [Fact]
    public async Task LoadAsync_AppliesSettings()
    {
        var settings = new RagSettings
        {
            Enabled = true,
            ChunkSize = 256,
            MinRelevanceScore = 0.7f
        };

        _settingsServiceMock
            .Setup(s => s.GetSettingsAsync(default))
            .ReturnsAsync(settings);

        var vm = CreateViewModel();

        await vm.LoadAsync();

        Assert.True(vm.Enabled);
        Assert.Equal(256, vm.ChunkSize);
        Assert.Equal(0.7f, vm.MinRelevanceScore);
    }

    [Fact]
    public async Task SaveAsync_SavesSettings()
    {
        RagSettings? savedSettings = null;
        _settingsServiceMock
            .Setup(s => s.SaveSettingsAsync(It.IsAny<RagSettings>(), default))
            .Callback<RagSettings, System.Threading.CancellationToken>((s, _) => savedSettings = s)
            .Returns(Task.CompletedTask);

        var vm = CreateViewModel();
        vm.ChunkSize = 1024;
        vm.MinRelevanceScore = 0.8f;

        await vm.SaveAsync();

        Assert.NotNull(savedSettings);
        Assert.Equal(1024, savedSettings!.ChunkSize);
        Assert.Equal(0.8f, savedSettings.MinRelevanceScore);
    }

    [Fact]
    public void ResetToDefaults_AppliesDefaultSettings()
    {
        var vm = CreateViewModel();
        vm.ChunkSize = 1024;

        vm.ResetToDefaultsCommand.Execute(null);

        Assert.Equal(512, vm.ChunkSize);
    }

    private RagSettingsViewModel CreateViewModel()
    {
        return new RagSettingsViewModel(
            _settingsServiceMock.Object,
            null!); // StorageProvider
    }
}
```

### File: `tests/SeniorIntern.Tests/Integration/RagUiIntegrationTests.cs`

```csharp
using System;
using System.IO;
using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;
using Xunit;

namespace SeniorIntern.Tests.Integration;

/// <summary>
/// Integration tests for RAG UI components.
/// These tests verify the full integration between UI and services.
/// </summary>
public class RagUiIntegrationTests : IAsyncLifetime
{
    private string? _testWorkspace;
    private IServiceProvider? _serviceProvider;

    public async Task InitializeAsync()
    {
        _testWorkspace = Path.Combine(Path.GetTempPath(), $"rag-ui-test-{Guid.NewGuid()}");
        Directory.CreateDirectory(_testWorkspace);

        // Create test files
        await File.WriteAllTextAsync(
            Path.Combine(_testWorkspace, "Program.cs"),
            "class Program { static void Main() { } }");

        // Set up DI container (simplified)
        // In a real test, this would configure all services
    }

    public Task DisposeAsync()
    {
        if (_testWorkspace != null && Directory.Exists(_testWorkspace))
        {
            Directory.Delete(_testWorkspace, recursive: true);
        }
        return Task.CompletedTask;
    }

    [Fact(Skip = "Integration test - requires full service setup")]
    public async Task IndexManager_FullWorkflow_Succeeds()
    {
        // This test would verify:
        // 1. Opening Index Manager
        // 2. Selecting workspace
        // 3. Selecting embedding model
        // 4. Running indexing
        // 5. Verifying index status
    }

    [Fact(Skip = "Integration test - requires full service setup")]
    public async Task AutoIndexing_FileChange_TriggersReindex()
    {
        // This test would verify:
        // 1. Starting auto-indexing
        // 2. Modifying a file
        // 3. Waiting for re-index
        // 4. Verifying updated chunks
    }
}
```

### File: `tests/SeniorIntern.Tests/Services/RagStatusServiceTests.cs`

```csharp
using System.Threading.Tasks;
using Moq;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Desktop.Controls;
using SeniorIntern.Desktop.Services;
using SeniorIntern.Services.Settings;
using Xunit;

namespace SeniorIntern.Tests.Services;

public class RagStatusServiceTests
{
    private readonly Mock<IKnowledgeService> _knowledgeServiceMock;
    private readonly Mock<IEmbeddingService> _embeddingServiceMock;
    private readonly Mock<IRagSettingsService> _settingsServiceMock;

    public RagStatusServiceTests()
    {
        _knowledgeServiceMock = new Mock<IKnowledgeService>();
        _embeddingServiceMock = new Mock<IEmbeddingService>();
        _settingsServiceMock = new Mock<IRagSettingsService>();
    }

    [Fact]
    public async Task UpdateStatusAsync_NoWorkspace_SetsNotIndexed()
    {
        var service = CreateService();

        await service.UpdateStatusAsync(null);

        Assert.Equal(RagStatus.NotIndexed, service.CurrentStatus);
    }

    [Fact]
    public async Task UpdateStatusAsync_NoModel_SetsNoModel()
    {
        _settingsServiceMock
            .Setup(s => s.GetSettingsAsync(default))
            .ReturnsAsync(new RagSettings { EmbeddingModelPath = null });

        var service = CreateService();

        await service.UpdateStatusAsync("/test");

        Assert.Equal(RagStatus.NoModel, service.CurrentStatus);
    }

    [Fact]
    public async Task UpdateStatusAsync_IndexedWorkspace_SetsIndexed()
    {
        _settingsServiceMock
            .Setup(s => s.GetSettingsAsync(default))
            .ReturnsAsync(new RagSettings { EmbeddingModelPath = "/model.gguf" });

        _embeddingServiceMock
            .Setup(e => e.IsModelLoaded)
            .Returns(true);

        _knowledgeServiceMock
            .Setup(k => k.GetIndexHealthAsync("/test", default))
            .ReturnsAsync(new KnowledgeIndexHealth { IsIndexed = true });

        var service = CreateService();

        await service.UpdateStatusAsync("/test");

        Assert.Equal(RagStatus.Indexed, service.CurrentStatus);
    }

    [Fact]
    public void SetIndexing_UpdatesStatus()
    {
        var service = CreateService();
        RagStatus? reportedStatus = null;
        service.StatusChanged += (_, args) => reportedStatus = args.Status;

        service.SetIndexing(true, 50);

        Assert.Equal(RagStatus.Indexing, service.CurrentStatus);
        Assert.True(service.IsIndexing);
        Assert.Equal(50, service.IndexingProgress);
    }

    private RagStatusService CreateService()
    {
        return new RagStatusService(
            _knowledgeServiceMock.Object,
            _embeddingServiceMock.Object,
            _settingsServiceMock.Object);
    }
}
```

### Dependencies
- xUnit testing framework
- Moq for mocking
- All v0.7.5 components

### Implementation Notes
1. Unit tests isolate individual components
2. Integration tests verify full workflows
3. Skip attribute on integration tests allows selective running
4. Tests cover ViewModels, services, and settings

---

## Implementation Summary

### Files to Create (33 total)

| Sub-version | File Path | Purpose |
|-------------|-----------|---------|
| v0.7.5a | `src/SeniorIntern.Core/Models/RagSettings.cs` | RAG configuration model |
| v0.7.5a | `src/SeniorIntern.Core/Models/WorkspaceIndexInfo.cs` | Workspace index info |
| v0.7.5a | `src/SeniorIntern.Services/Settings/IRagSettingsService.cs` | Settings service interface |
| v0.7.5b | `src/SeniorIntern.Desktop/Views/Dialogs/IndexManagerDialog.axaml` | Index manager UI |
| v0.7.5b | `src/SeniorIntern.Desktop/Views/Dialogs/IndexManagerDialog.axaml.cs` | Code-behind |
| v0.7.5b | `src/SeniorIntern.Desktop/Views/Dialogs/PatternEditorDialog.axaml` | Pattern editor UI |
| v0.7.5c | `src/SeniorIntern.Desktop/ViewModels/IndexManagerViewModel.cs` | Index manager logic |
| v0.7.5c | `src/SeniorIntern.Desktop/ViewModels/IndexManagerViewModel.Commands.cs` | Additional commands |
| v0.7.5d | `src/SeniorIntern.Desktop/Views/Dialogs/IndexingProgressDialog.axaml` | Progress dialog UI |
| v0.7.5d | `src/SeniorIntern.Desktop/Views/Dialogs/IndexingProgressDialog.axaml.cs` | Code-behind |
| v0.7.5d | `src/SeniorIntern.Desktop/ViewModels/IndexingProgressViewModel.cs` | Progress logic |
| v0.7.5e | `src/SeniorIntern.Desktop/Controls/RagStatusIndicator.axaml` | Status indicator UI |
| v0.7.5e | `src/SeniorIntern.Desktop/Controls/RagStatusIndicator.axaml.cs` | Code-behind |
| v0.7.5e | `src/SeniorIntern.Desktop/Services/RagStatusService.cs` | Status tracking |
| v0.7.5f | `src/SeniorIntern.Desktop/Views/Settings/RagSettingsPanel.axaml` | Settings panel UI |
| v0.7.5f | `src/SeniorIntern.Desktop/Views/Settings/RagSettingsPanel.axaml.cs` | Code-behind |
| v0.7.5f | `src/SeniorIntern.Desktop/ViewModels/RagSettingsViewModel.cs` | Settings logic |
| v0.7.5g | `src/SeniorIntern.Services/Indexing/AutoIndexingService.cs` | Auto-indexing service |
| v0.7.5g | `src/SeniorIntern.Services/Indexing/AutoIndexingBackgroundService.cs` | Background service |
| v0.7.5g | `src/SeniorIntern.Services/DependencyInjection.AutoIndexing.cs` | DI registration |
| v0.7.5h | `src/SeniorIntern.Desktop/Controls/RagToggleButton.axaml` | RAG toggle UI |
| v0.7.5h | `src/SeniorIntern.Desktop/Controls/RagToggleButton.axaml.cs` | Code-behind |
| v0.7.5i | `src/SeniorIntern.Desktop/Controls/WorkspaceSelector.axaml` | Workspace selector UI |
| v0.7.5i | `src/SeniorIntern.Desktop/Controls/WorkspaceSelector.axaml.cs` | Code-behind |
| v0.7.5i | `src/SeniorIntern.Desktop/ViewModels/WorkspaceSelectorViewModel.cs` | Selector logic |
| v0.7.5j | `tests/SeniorIntern.Tests/Settings/RagSettingsTests.cs` | Settings tests |
| v0.7.5j | `tests/SeniorIntern.Tests/UI/IndexManagerViewModelTests.cs` | Index manager tests |
| v0.7.5j | `tests/SeniorIntern.Tests/Services/AutoIndexingServiceTests.cs` | Auto-indexing tests |
| v0.7.5j | `tests/SeniorIntern.Tests/UI/RagStatusIndicatorTests.cs` | Status indicator tests |
| v0.7.5j | `tests/SeniorIntern.Tests/UI/WorkspaceSelectorViewModelTests.cs` | Workspace selector tests |
| v0.7.5j | `tests/SeniorIntern.Tests/UI/RagSettingsViewModelTests.cs` | Settings VM tests |
| v0.7.5j | `tests/SeniorIntern.Tests/Integration/RagUiIntegrationTests.cs` | Integration tests |
| v0.7.5j | `tests/SeniorIntern.Tests/Services/RagStatusServiceTests.cs` | Status service tests |

### Files to Modify (6 total)

| File Path | Changes |
|-----------|---------|
| `src/SeniorIntern.Core/Models/AppSettings.cs` | Add RagSettings property |
| `src/SeniorIntern.Desktop/Views/MainWindow.axaml` | Add RAG status indicator |
| `src/SeniorIntern.Desktop/Views/Settings/SettingsDialog.axaml` | Add RAG settings tab |
| `src/SeniorIntern.Desktop/Views/ChatView.axaml` | Add RAG toggle button |
| `src/SeniorIntern.Desktop/ViewModels/ChatViewModel.cs` | Add RAG properties/logic |
| `src/SeniorIntern.Desktop/Views/MainWindow.axaml` | Add workspace selector |

### NuGet Packages

No new NuGet packages required for v0.7.5. UI uses existing Avalonia and CommunityToolkit.Mvvm packages.

---

## Success Criteria

- [ ] Index Manager dialog opens and displays correct status
- [ ] Embedding model can be selected and loaded
- [ ] Indexing operations (Reindex All, Update Changed, Clear) work correctly
- [ ] Progress dialog shows real-time indexing progress
- [ ] RAG status indicator reflects current state in main window
- [ ] RAG settings panel allows configuration of all options
- [ ] Auto-indexing detects and processes file changes
- [ ] RAG toggle in chat interface enables/disables context injection
- [ ] Workspace selector shows all indexed workspaces
- [ ] All unit tests pass
- [ ] UI is responsive and doesn't block on long operations
- [ ] Settings persist correctly between sessions
