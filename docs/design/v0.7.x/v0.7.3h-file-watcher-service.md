# Design Specification: AIntern v0.7.3h "File Watcher Service"

## Overview

**Version**: v0.7.3h
**Parent**: v0.7.3 Indexing Pipeline
**Focus**: File system watching to detect changes and trigger automatic re-indexing

### Purpose

This sub-version implements the file watching system:
1. `FileWatcherService` - Core file system watcher with debouncing
2. `FileWatcherCoordinator` - Hosted service to auto-start watchers for indexes
3. `FileWatcherBackgroundService` - Background service to process file changes
4. Supporting models for file changes, events, and configuration

### Dependencies

**From v0.7.3a (Indexing Service Interface)**:
- `IFileWatcherService` interface
- `IIndexingService` for processing changes

**From v0.7.3b (Indexing Models & Options)**:
- `IndexingOptions` configuration
- `IndexingJob` model

**From v0.7.3g (Background Job Queue)**:
- `IIndexingJobQueue` for queuing update jobs

**From v0.7.2 (Vector Storage)**:
- `IVectorStore` for listing indexes on startup

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                     v0.7.3h File Watcher Service                              │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  src/SeniorIntern.Services/Indexing/                                         │
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │                                                                          ││
│  │  FileWatcherService : IFileWatcherService, IAsyncDisposable              ││
│  │  ┌────────────────────────────────────────────────────────────────────┐  ││
│  │  │  Dependencies                                                      │  ││
│  │  │  ├── IIndexingJobQueue _jobQueue                                  │  ││
│  │  │  └── ILogger<FileWatcherService> _logger                          │  ││
│  │  └────────────────────────────────────────────────────────────────────┘  ││
│  │  ┌────────────────────────────────────────────────────────────────────┐  ││
│  │  │  State                                                             │  ││
│  │  │  ├── _watchers: ConcurrentDictionary<string, WatcherState>        │  ││
│  │  │  ├── _isEnabled: bool                                              │  ││
│  │  │  └── _isDisposed: bool                                             │  ││
│  │  └────────────────────────────────────────────────────────────────────┘  ││
│  │  ┌────────────────────────────────────────────────────────────────────┐  ││
│  │  │  IFileWatcherService Implementation                                │  ││
│  │  │  ├── IsEnabled: bool                                               │  ││
│  │  │  ├── WatchedWorkspaces: IReadOnlyList<string>                     │  ││
│  │  │  ├── StartWatching(indexId, workspacePath, options)               │  ││
│  │  │  ├── StopWatching(workspacePath)                                   │  ││
│  │  │  ├── StopAll()                                                     │  ││
│  │  │  ├── SetEnabled(enabled)                                           │  ││
│  │  │  └── GetPendingChanges(workspacePath) → List<string>              │  ││
│  │  └────────────────────────────────────────────────────────────────────┘  ││
│  │  ┌────────────────────────────────────────────────────────────────────┐  ││
│  │  │  Internal Event Handlers                                           │  ││
│  │  │  ├── OnFileChanged(state, fullPath, changeType)                   │  ││
│  │  │  ├── OnFileRenamed(state, oldPath, newPath)                       │  ││
│  │  │  ├── OnWatcherError(state, exception)                             │  ││
│  │  │  └── OnDebounceElapsed(state)                                      │  ││
│  │  └────────────────────────────────────────────────────────────────────┘  ││
│  │  ┌────────────────────────────────────────────────────────────────────┐  ││
│  │  │  Events                                                            │  ││
│  │  │  └── ChangesDetected: EventHandler<FileChangesDetectedEventArgs>  │  ││
│  │  └────────────────────────────────────────────────────────────────────┘  ││
│  │                                                                          ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │  FileWatcherCoordinator : IHostedService                                 ││
│  │  ┌────────────────────────────────────────────────────────────────────┐  ││
│  │  │  Purpose: Auto-start watchers for indexes on app startup          │  ││
│  │  │  ├── StartAsync: Load indexes, start watching those with AutoReindex│ ││
│  │  │  └── StopAsync: Stop all watchers                                  │  ││
│  │  └────────────────────────────────────────────────────────────────────┘  ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │  FileWatcherBackgroundService : BackgroundService                        ││
│  │  ┌────────────────────────────────────────────────────────────────────┐  ││
│  │  │  Purpose: Process file change events and trigger re-indexing      │  ││
│  │  │  ├── Subscribe to ChangesDetected event                           │  ││
│  │  │  ├── Remove deleted files from index                               │  ││
│  │  │  └── Index added/modified files                                    │  ││
│  │  └────────────────────────────────────────────────────────────────────┘  ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
│  Supporting Models                                                           │
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │  FileWatchOptions         → Debounce delay, patterns, auto-reindex      ││
│  │  FileChange               → FilePath, ChangeType, OldPath (for rename)  ││
│  │  FileChangeType           → Created, Modified, Deleted, Renamed          ││
│  │  FileChangesDetectedEventArgs → IndexId, WorkspacePath, Changes         ││
│  │  WatcherState (internal)  → IndexId, Watcher, Options, PendingChanges   ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Watcher Flow

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                           File Change Pipeline                                │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌──────────────────────────────────────────────────────┐                    │
│  │  1. FILE SYSTEM EVENT                                │                    │
│  │  ┌────────────────────────────────────────────────┐  │                    │
│  │  │  FileSystemWatcher detects change              │  │                    │
│  │  │  • Created, Changed, Deleted, or Renamed      │  │                    │
│  │  └────────────────────────────────────────────────┘  │                    │
│  └──────────────────────────────────────────────────────┘                    │
│                           │                                                  │
│                           ▼                                                  │
│  ┌──────────────────────────────────────────────────────┐                    │
│  │  2. FILTER & VALIDATE                                │                    │
│  │  ┌────────────────────────────────────────────────┐  │                    │
│  │  │  OnFileChanged() / OnFileRenamed()             │  │                    │
│  │  │  ├── Check if watcher is enabled               │  │                    │
│  │  │  ├── Convert to relative path                  │  │                    │
│  │  │  ├── Apply exclude patterns                    │  │                    │
│  │  │  └── Apply include patterns (if specified)    │  │                    │
│  │  └────────────────────────────────────────────────┘  │                    │
│  └──────────────────────────────────────────────────────┘                    │
│                           │                                                  │
│                           ▼                                                  │
│  ┌──────────────────────────────────────────────────────┐                    │
│  │  3. BUFFER CHANGES                                   │                    │
│  │  ┌────────────────────────────────────────────────┐  │                    │
│  │  │  Add to state.PendingChanges (ConcurrentBag)  │  │                    │
│  │  │  Reset debounce timer                          │  │                    │
│  │  │  If batch size exceeded → immediate flush     │  │                    │
│  │  └────────────────────────────────────────────────┘  │                    │
│  └──────────────────────────────────────────────────────┘                    │
│                           │                                                  │
│              ┌────────────┴────────────┐                                     │
│              │                         │                                     │
│              ▼                         ▼                                     │
│  ┌─────────────────────┐   ┌─────────────────────────┐                       │
│  │  Debounce Timer     │   │  Batch Size Exceeded    │                       │
│  │  (2000ms default)   │   │  (MaxBatchSize = 100)   │                       │
│  └──────────┬──────────┘   └────────────┬────────────┘                       │
│             │                           │                                    │
│             └─────────────┬─────────────┘                                    │
│                           │                                                  │
│                           ▼                                                  │
│  ┌──────────────────────────────────────────────────────┐                    │
│  │  4. DEBOUNCE ELAPSED                                 │                    │
│  │  ┌────────────────────────────────────────────────┐  │                    │
│  │  │  OnDebounceElapsed()                           │  │                    │
│  │  │  ├── Drain all pending changes                 │  │                    │
│  │  │  ├── Deduplicate changes                       │  │                    │
│  │  │  │   ├── Created + Deleted = No change        │  │                    │
│  │  │  │   ├── Multiple Modified = Keep latest      │  │                    │
│  │  │  │   └── Per-file deduplication               │  │                    │
│  │  │  └── Raise ChangesDetected event              │  │                    │
│  │  └────────────────────────────────────────────────┘  │                    │
│  └──────────────────────────────────────────────────────┘                    │
│                           │                                                  │
│                           ▼                                                  │
│  ┌──────────────────────────────────────────────────────┐                    │
│  │  5. QUEUE RE-INDEXING (if AutoReindex enabled)       │                    │
│  │  ┌────────────────────────────────────────────────┐  │                    │
│  │  │  Create IndexingJob (FileWatchUpdate type)     │  │                    │
│  │  │  Enqueue to IIndexingJobQueue                  │  │                    │
│  │  └────────────────────────────────────────────────┘  │                    │
│  └──────────────────────────────────────────────────────┘                    │
│                           │                                                  │
│                           ▼                                                  │
│  ┌──────────────────────────────────────────────────────┐                    │
│  │  6. PROCESS CHANGES (FileWatcherBackgroundService)   │                    │
│  │  ┌────────────────────────────────────────────────┐  │                    │
│  │  │  Subscribe to ChangesDetected event            │  │                    │
│  │  │  ├── Deleted files → RemoveFilesAsync()       │  │                    │
│  │  │  └── Added/Modified → IndexFilesAsync()       │  │                    │
│  │  └────────────────────────────────────────────────┘  │                    │
│  └──────────────────────────────────────────────────────┘                    │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Services/Indexing/FileWatcherService.cs` | Core file system watcher |
| `src/SeniorIntern.Services/Indexing/FileWatcherCoordinator.cs` | Auto-start watchers on startup |
| `src/SeniorIntern.Services/Indexing/FileWatcherBackgroundService.cs` | Process file change events |
| `src/SeniorIntern.Services/Indexing/FileWatcherModels.cs` | Options and change models |

---

## Detailed Specifications

### 1. FileWatcherService.cs

**Location**: `src/SeniorIntern.Services/Indexing/FileWatcherService.cs`

```csharp
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Timers;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using Timer = System.Timers.Timer;

namespace SeniorIntern.Services.Indexing;

/// <summary>
/// Watches file system changes and triggers re-indexing.
/// </summary>
/// <remarks>
/// <para>
/// Uses <see cref="FileSystemWatcher"/> to monitor directories for changes.
/// Changes are debounced to batch rapid successive modifications into
/// a single update operation.
/// </para>
/// <para>
/// Key features:
/// <list type="bullet">
///   <item>Debouncing to reduce noise from rapid file saves</item>
///   <item>Pattern-based filtering (include/exclude patterns)</item>
///   <item>Automatic re-indexing via job queue</item>
///   <item>Change deduplication (Created+Deleted = no change)</item>
/// </list>
/// </para>
/// </remarks>
public sealed class FileWatcherService : IFileWatcherService, IAsyncDisposable
{
    private readonly IIndexingJobQueue _jobQueue;
    private readonly ILogger<FileWatcherService> _logger;

    private readonly ConcurrentDictionary<string, WatcherState> _watchers = new();
    private bool _isEnabled = true;
    private bool _isDisposed;

    /// <inheritdoc />
    public bool IsEnabled => _isEnabled;

    /// <inheritdoc />
    public IReadOnlyList<string> WatchedWorkspaces => _watchers.Keys.ToList();

    /// <inheritdoc />
    public event EventHandler<FileChangesDetectedEventArgs>? ChangesDetected;

    /// <summary>
    /// Initializes a new instance of the <see cref="FileWatcherService"/> class.
    /// </summary>
    public FileWatcherService(
        IIndexingJobQueue jobQueue,
        ILogger<FileWatcherService> logger)
    {
        _jobQueue = jobQueue ?? throw new ArgumentNullException(nameof(jobQueue));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <inheritdoc />
    public void StartWatching(
        string indexId,
        string workspacePath,
        FileWatchOptions? options = null)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(indexId);
        ArgumentException.ThrowIfNullOrWhiteSpace(workspacePath);

        if (_isDisposed)
            throw new ObjectDisposedException(nameof(FileWatcherService));

        options ??= new FileWatchOptions();

        if (_watchers.ContainsKey(workspacePath))
        {
            _logger.LogWarning("Already watching {Path}", workspacePath);
            return;
        }

        if (!Directory.Exists(workspacePath))
        {
            throw new DirectoryNotFoundException($"Workspace not found: {workspacePath}");
        }

        _logger.LogInformation("Starting file watcher for {Path}", workspacePath);

        // Create FileSystemWatcher
        var watcher = new FileSystemWatcher(workspacePath)
        {
            IncludeSubdirectories = options.IncludeSubdirectories,
            NotifyFilter = NotifyFilters.FileName |
                          NotifyFilters.DirectoryName |
                          NotifyFilters.LastWrite |
                          NotifyFilters.Size,
            EnableRaisingEvents = _isEnabled
        };

        var state = new WatcherState
        {
            IndexId = indexId,
            WorkspacePath = workspacePath,
            Watcher = watcher,
            Options = options,
            PendingChanges = new ConcurrentBag<FileChange>(),
            DebounceTimer = new Timer(options.DebounceDelayMs)
        };

        state.DebounceTimer.AutoReset = false;
        state.DebounceTimer.Elapsed += (s, e) => OnDebounceElapsed(state);

        // Set up event handlers
        watcher.Created += (s, e) => OnFileChanged(state, e.FullPath, FileChangeType.Created);
        watcher.Changed += (s, e) => OnFileChanged(state, e.FullPath, FileChangeType.Modified);
        watcher.Deleted += (s, e) => OnFileChanged(state, e.FullPath, FileChangeType.Deleted);
        watcher.Renamed += (s, e) => OnFileRenamed(state, e.OldFullPath, e.FullPath);
        watcher.Error += (s, e) => OnWatcherError(state, e.GetException());

        _watchers.TryAdd(workspacePath, state);
    }

    /// <inheritdoc />
    public void StopWatching(string workspacePath)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(workspacePath);

        if (_watchers.TryRemove(workspacePath, out var state))
        {
            _logger.LogInformation("Stopping file watcher for {Path}", workspacePath);
            DisposeWatcher(state);
        }
    }

    /// <inheritdoc />
    public void StopAll()
    {
        foreach (var path in _watchers.Keys.ToList())
        {
            StopWatching(path);
        }
    }

    /// <inheritdoc />
    public void SetEnabled(bool enabled)
    {
        _isEnabled = enabled;

        foreach (var state in _watchers.Values)
        {
            state.Watcher.EnableRaisingEvents = enabled;
        }

        _logger.LogInformation("File watching {Status}", enabled ? "enabled" : "disabled");
    }

    /// <inheritdoc />
    public IReadOnlyList<string> GetPendingChanges(string workspacePath)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(workspacePath);

        if (_watchers.TryGetValue(workspacePath, out var state))
        {
            return state.PendingChanges
                .Select(c => c.FilePath)
                .Distinct()
                .ToList();
        }
        return [];
    }

    /// <summary>
    /// Handler for Created, Changed, and Deleted events.
    /// </summary>
    private void OnFileChanged(WatcherState state, string fullPath, FileChangeType changeType)
    {
        if (!_isEnabled) return;

        var relativePath = Path.GetRelativePath(state.WorkspacePath, fullPath)
            .Replace('\\', '/');

        // Check if should ignore
        if (ShouldIgnore(relativePath, state.Options))
            return;

        _logger.LogDebug("File {Type}: {Path}", changeType, relativePath);

        state.PendingChanges.Add(new FileChange
        {
            FilePath = relativePath,
            ChangeType = changeType,
            DetectedAt = DateTime.UtcNow
        });

        // Reset debounce timer
        state.DebounceTimer.Stop();
        state.DebounceTimer.Start();

        // Check if batch size exceeded - immediate flush
        if (state.PendingChanges.Count >= state.Options.MaxBatchSize)
        {
            state.DebounceTimer.Stop();
            OnDebounceElapsed(state);
        }
    }

    /// <summary>
    /// Handler for Renamed events.
    /// </summary>
    private void OnFileRenamed(WatcherState state, string oldPath, string newPath)
    {
        if (!_isEnabled) return;

        var oldRelative = Path.GetRelativePath(state.WorkspacePath, oldPath)
            .Replace('\\', '/');
        var newRelative = Path.GetRelativePath(state.WorkspacePath, newPath)
            .Replace('\\', '/');

        if (ShouldIgnore(newRelative, state.Options))
            return;

        _logger.LogDebug("File renamed: {Old} -> {New}", oldRelative, newRelative);

        state.PendingChanges.Add(new FileChange
        {
            FilePath = newRelative,
            ChangeType = FileChangeType.Renamed,
            OldPath = oldRelative,
            DetectedAt = DateTime.UtcNow
        });

        state.DebounceTimer.Stop();
        state.DebounceTimer.Start();
    }

    /// <summary>
    /// Handler for watcher errors.
    /// </summary>
    private void OnWatcherError(WatcherState state, Exception error)
    {
        _logger.LogError(error, "File watcher error for {Path}", state.WorkspacePath);

        // Try to restart watcher
        try
        {
            state.Watcher.EnableRaisingEvents = false;
            state.Watcher.EnableRaisingEvents = _isEnabled;
            _logger.LogInformation("Restarted file watcher for {Path}", state.WorkspacePath);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to restart watcher for {Path}", state.WorkspacePath);
        }
    }

    /// <summary>
    /// Called when debounce timer elapses - processes buffered changes.
    /// </summary>
    private void OnDebounceElapsed(WatcherState state)
    {
        if (state.PendingChanges.IsEmpty)
            return;

        // Collect all pending changes
        var changes = new List<FileChange>();
        while (state.PendingChanges.TryTake(out var change))
        {
            changes.Add(change);
        }

        // Deduplicate changes
        var deduped = DeduplicateChanges(changes);

        if (deduped.Count == 0)
            return;

        _logger.LogInformation(
            "Detected {Count} file changes in {Path}",
            deduped.Count, state.WorkspacePath);

        // Raise event
        ChangesDetected?.Invoke(this, new FileChangesDetectedEventArgs
        {
            IndexId = state.IndexId,
            WorkspacePath = state.WorkspacePath,
            Changes = deduped
        });

        // Queue re-indexing if enabled
        if (state.Options.AutoReindex)
        {
            var job = new IndexingJob
            {
                Type = IndexingJobType.IncrementalUpdate,
                IndexId = state.IndexId,
                WorkspacePath = state.WorkspacePath,
                Options = new IndexingOptions
                {
                    ForceReindex = false
                }
            };

            _jobQueue.Enqueue(job);
            _logger.LogDebug("Queued file watch update job {JobId}", job.Id);
        }
    }

    /// <summary>
    /// Deduplicate changes by path, merging sequential operations.
    /// </summary>
    private static IReadOnlyList<FileChange> DeduplicateChanges(List<FileChange> changes)
    {
        var byPath = new Dictionary<string, FileChange>();

        foreach (var change in changes.OrderBy(c => c.DetectedAt))
        {
            if (byPath.TryGetValue(change.FilePath, out var existing))
            {
                // Merge changes
                if (change.ChangeType == FileChangeType.Deleted)
                {
                    if (existing.ChangeType == FileChangeType.Created)
                    {
                        // Created then deleted = no change
                        byPath.Remove(change.FilePath);
                    }
                    else
                    {
                        // Modified then deleted = deleted
                        byPath[change.FilePath] = change;
                    }
                }
                else if (change.ChangeType == FileChangeType.Created)
                {
                    // Deleted then created = modified
                    byPath[change.FilePath] = change with { ChangeType = FileChangeType.Modified };
                }
                // Multiple modifications = keep latest
            }
            else
            {
                byPath[change.FilePath] = change;
            }
        }

        return byPath.Values.ToList();
    }

    /// <summary>
    /// Check if a path should be ignored based on options.
    /// </summary>
    private static bool ShouldIgnore(string relativePath, FileWatchOptions options)
    {
        // Check exclude patterns
        if (options.ExcludePatterns != null)
        {
            foreach (var pattern in options.ExcludePatterns)
            {
                if (MatchesPattern(relativePath, pattern))
                    return true;
            }
        }

        // Check include patterns if specified
        if (options.FilePatterns != null && options.FilePatterns.Count > 0)
        {
            foreach (var pattern in options.FilePatterns)
            {
                if (MatchesPattern(relativePath, pattern))
                    return false;
            }
            return true; // Not in include list
        }

        return false;
    }

    /// <summary>
    /// Simple glob pattern matching.
    /// </summary>
    private static bool MatchesPattern(string path, string pattern)
    {
        var regexPattern = "^" + Regex.Escape(pattern)
            .Replace(@"\*\*", ".*")
            .Replace(@"\*", @"[^/\\]*")
            .Replace(@"\?", ".") + "$";

        return Regex.IsMatch(path, regexPattern, RegexOptions.IgnoreCase);
    }

    /// <summary>
    /// Dispose a watcher and its resources.
    /// </summary>
    private static void DisposeWatcher(WatcherState state)
    {
        state.DebounceTimer.Stop();
        state.DebounceTimer.Dispose();
        state.Watcher.EnableRaisingEvents = false;
        state.Watcher.Dispose();
    }

    /// <inheritdoc />
    public async ValueTask DisposeAsync()
    {
        if (_isDisposed) return;
        _isDisposed = true;

        foreach (var state in _watchers.Values)
        {
            DisposeWatcher(state);
        }
        _watchers.Clear();

        await Task.CompletedTask;
    }

    /// <summary>
    /// Internal state for a single directory watcher.
    /// </summary>
    private sealed class WatcherState
    {
        public required string IndexId { get; init; }
        public required string WorkspacePath { get; init; }
        public required FileSystemWatcher Watcher { get; init; }
        public required FileWatchOptions Options { get; init; }
        public required ConcurrentBag<FileChange> PendingChanges { get; init; }
        public required Timer DebounceTimer { get; init; }
    }
}
```

### 2. FileWatcherCoordinator.cs

**Location**: `src/SeniorIntern.Services/Indexing/FileWatcherCoordinator.cs`

```csharp
using System;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Services.VectorStore;

namespace SeniorIntern.Services.Indexing;

/// <summary>
/// Coordinates file watching with indexing operations.
/// </summary>
/// <remarks>
/// <para>
/// This hosted service automatically starts file watchers for all indexes
/// that have auto-reindexing enabled when the application starts.
/// </para>
/// <para>
/// On shutdown, all watchers are gracefully stopped.
/// </para>
/// </remarks>
public sealed class FileWatcherCoordinator : IHostedService
{
    private readonly IFileWatcherService _fileWatcher;
    private readonly IVectorStore _vectorStore;
    private readonly ILogger<FileWatcherCoordinator> _logger;

    /// <summary>
    /// Initializes a new instance of the <see cref="FileWatcherCoordinator"/> class.
    /// </summary>
    public FileWatcherCoordinator(
        IFileWatcherService fileWatcher,
        IVectorStore vectorStore,
        ILogger<FileWatcherCoordinator> logger)
    {
        _fileWatcher = fileWatcher ?? throw new ArgumentNullException(nameof(fileWatcher));
        _vectorStore = vectorStore ?? throw new ArgumentNullException(nameof(vectorStore));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <inheritdoc />
    public async Task StartAsync(CancellationToken cancellationToken)
    {
        _logger.LogInformation("Starting file watcher coordinator");

        try
        {
            // Load existing indexes and start watching them
            var indexes = await _vectorStore.ListIndexesAsync(cancellationToken);
            var autoReindexIndexes = indexes.Where(i => i.Settings.AutoReindex).ToList();

            _logger.LogDebug(
                "Found {Count} indexes with auto-reindex enabled",
                autoReindexIndexes.Count);

            foreach (var index in autoReindexIndexes)
            {
                try
                {
                    _fileWatcher.StartWatching(
                        index.Id,
                        index.WorkspacePath,
                        new FileWatchOptions
                        {
                            DebounceDelayMs = index.Settings.AutoReindexDelayMs,
                            ExcludePatterns = index.Settings.ExcludePatterns,
                            FilePatterns = index.Settings.IncludePatterns,
                            IncludeSubdirectories = true,
                            AutoReindex = true
                        });

                    _logger.LogDebug("Started watching index {Id} at {Path}",
                        index.Id, index.WorkspacePath);
                }
                catch (Exception ex)
                {
                    _logger.LogWarning(ex,
                        "Failed to start file watcher for index {Id}",
                        index.Id);
                }
            }

            _logger.LogInformation(
                "File watcher coordinator started, watching {Count} workspaces",
                _fileWatcher.WatchedWorkspaces.Count);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error during file watcher coordinator startup");
        }
    }

    /// <inheritdoc />
    public Task StopAsync(CancellationToken cancellationToken)
    {
        _logger.LogInformation("Stopping file watcher coordinator");
        _fileWatcher.StopAll();
        return Task.CompletedTask;
    }
}
```

### 3. FileWatcherBackgroundService.cs

**Location**: `src/SeniorIntern.Services/Indexing/FileWatcherBackgroundService.cs`

```csharp
using System;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;

namespace SeniorIntern.Services.Indexing;

/// <summary>
/// Background service that handles file change events.
/// </summary>
/// <remarks>
/// <para>
/// This service subscribes to the <see cref="IFileWatcherService.ChangesDetected"/>
/// event and processes changes by:
/// <list type="bullet">
///   <item>Removing deleted files from the index</item>
///   <item>Re-indexing added and modified files</item>
/// </list>
/// </para>
/// <para>
/// This provides an alternative to queueing jobs - direct file processing
/// for smaller, more immediate updates.
/// </para>
/// </remarks>
public sealed class FileWatcherBackgroundService : BackgroundService
{
    private readonly IFileWatcherService _fileWatcher;
    private readonly IIndexingService _indexingService;
    private readonly ILogger<FileWatcherBackgroundService> _logger;

    /// <summary>
    /// Initializes a new instance of the <see cref="FileWatcherBackgroundService"/> class.
    /// </summary>
    public FileWatcherBackgroundService(
        IFileWatcherService fileWatcher,
        IIndexingService indexingService,
        ILogger<FileWatcherBackgroundService> logger)
    {
        _fileWatcher = fileWatcher ?? throw new ArgumentNullException(nameof(fileWatcher));
        _indexingService = indexingService ?? throw new ArgumentNullException(nameof(indexingService));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <inheritdoc />
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        _logger.LogInformation("File watcher background service started");

        // Subscribe to changes detected event
        _fileWatcher.ChangesDetected += async (sender, args) =>
        {
            if (stoppingToken.IsCancellationRequested) return;

            await ProcessChangesAsync(args, stoppingToken);
        };

        // Keep running until cancelled
        try
        {
            await Task.Delay(Timeout.Infinite, stoppingToken);
        }
        catch (OperationCanceledException)
        {
            // Normal shutdown
        }

        _logger.LogInformation("File watcher background service stopped");
    }

    /// <summary>
    /// Process file changes by updating the index.
    /// </summary>
    private async Task ProcessChangesAsync(
        FileChangesDetectedEventArgs args,
        CancellationToken ct)
    {
        _logger.LogDebug(
            "Processing {Count} file changes for index {IndexId}",
            args.Changes.Count, args.IndexId);

        try
        {
            // Separate changes by type
            var addedOrModified = args.Changes
                .Where(c => c.ChangeType != FileChangeType.Deleted)
                .Select(c => c.FilePath)
                .ToList();

            var deleted = args.Changes
                .Where(c => c.ChangeType == FileChangeType.Deleted)
                .Select(c => c.FilePath)
                .ToList();

            // Process renamed files - treat as modified (new path) + deleted (old path)
            var renamed = args.Changes
                .Where(c => c.ChangeType == FileChangeType.Renamed && c.OldPath != null)
                .ToList();

            foreach (var rename in renamed)
            {
                if (rename.OldPath != null)
                {
                    deleted.Add(rename.OldPath);
                }
            }

            // Remove deleted files
            if (deleted.Count > 0)
            {
                _logger.LogDebug("Removing {Count} deleted files", deleted.Count);
                await _indexingService.RemoveFilesAsync(args.IndexId, deleted, ct);
            }

            // Index added/modified files
            if (addedOrModified.Count > 0)
            {
                _logger.LogDebug("Indexing {Count} added/modified files", addedOrModified.Count);
                await _indexingService.IndexFilesAsync(
                    args.IndexId,
                    addedOrModified,
                    null,
                    ct);
            }

            _logger.LogInformation(
                "Processed file changes for index {IndexId}: {Added} indexed, {Deleted} removed",
                args.IndexId, addedOrModified.Count, deleted.Count);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex,
                "Error processing file changes for index {IndexId}",
                args.IndexId);
        }
    }
}
```

### 4. FileWatcherModels.cs

**Location**: `src/SeniorIntern.Services/Indexing/FileWatcherModels.cs`

```csharp
using System;
using System.Collections.Generic;

namespace SeniorIntern.Services.Indexing;

/// <summary>
/// Options for file watching.
/// </summary>
public sealed class FileWatchOptions
{
    /// <summary>
    /// Delay in milliseconds before processing changes.
    /// </summary>
    /// <remarks>
    /// This helps batch rapid successive file saves into a single update.
    /// Default is 2000ms (2 seconds).
    /// </remarks>
    public int DebounceDelayMs { get; init; } = 2000;

    /// <summary>
    /// File patterns to watch (glob patterns).
    /// </summary>
    /// <remarks>
    /// If specified, only files matching these patterns will be tracked.
    /// If null or empty, all files are tracked (subject to exclude patterns).
    /// </remarks>
    public IReadOnlyList<string>? FilePatterns { get; init; }

    /// <summary>
    /// Patterns to exclude from watching (glob patterns).
    /// </summary>
    public IReadOnlyList<string>? ExcludePatterns { get; init; }

    /// <summary>
    /// Whether to include subdirectories.
    /// </summary>
    public bool IncludeSubdirectories { get; init; } = true;

    /// <summary>
    /// Maximum batch size before forcing immediate processing.
    /// </summary>
    /// <remarks>
    /// If the number of pending changes exceeds this, processing
    /// happens immediately without waiting for debounce.
    /// </remarks>
    public int MaxBatchSize { get; init; } = 100;

    /// <summary>
    /// Whether to automatically queue re-indexing jobs.
    /// </summary>
    public bool AutoReindex { get; init; } = true;
}

/// <summary>
/// Represents a single file change.
/// </summary>
public sealed record FileChange
{
    /// <summary>
    /// Relative path of the changed file.
    /// </summary>
    public required string FilePath { get; init; }

    /// <summary>
    /// Type of change detected.
    /// </summary>
    public FileChangeType ChangeType { get; init; }

    /// <summary>
    /// Old path for renamed files, null otherwise.
    /// </summary>
    public string? OldPath { get; init; }

    /// <summary>
    /// When the change was detected.
    /// </summary>
    public DateTime DetectedAt { get; init; } = DateTime.UtcNow;
}

/// <summary>
/// Type of file change.
/// </summary>
public enum FileChangeType
{
    /// <summary>File was created.</summary>
    Created,

    /// <summary>File was modified.</summary>
    Modified,

    /// <summary>File was deleted.</summary>
    Deleted,

    /// <summary>File was renamed.</summary>
    Renamed
}

/// <summary>
/// Event args for file changes detected.
/// </summary>
public sealed class FileChangesDetectedEventArgs : EventArgs
{
    /// <summary>
    /// ID of the affected index.
    /// </summary>
    public required string IndexId { get; init; }

    /// <summary>
    /// Workspace path being watched.
    /// </summary>
    public required string WorkspacePath { get; init; }

    /// <summary>
    /// List of detected changes (deduplicated).
    /// </summary>
    public required IReadOnlyList<FileChange> Changes { get; init; }

    /// <summary>
    /// Number of created files.
    /// </summary>
    public int CreatedCount => Changes.Count(c => c.ChangeType == FileChangeType.Created);

    /// <summary>
    /// Number of modified files.
    /// </summary>
    public int ModifiedCount => Changes.Count(c => c.ChangeType == FileChangeType.Modified);

    /// <summary>
    /// Number of deleted files.
    /// </summary>
    public int DeletedCount => Changes.Count(c => c.ChangeType == FileChangeType.Deleted);

    /// <summary>
    /// Number of renamed files.
    /// </summary>
    public int RenamedCount => Changes.Count(c => c.ChangeType == FileChangeType.Renamed);
}
```

---

## Dependency Injection Registration

```csharp
// In ServiceCollectionExtensions.cs or Program.cs

// File watcher service
services.AddSingleton<IFileWatcherService, FileWatcherService>();
services.AddSingleton<FileWatcherService>(sp => 
    (FileWatcherService)sp.GetRequiredService<IFileWatcherService>());

// Hosted services for coordination
services.AddHostedService<FileWatcherCoordinator>();
services.AddHostedService<FileWatcherBackgroundService>();
```

---

## Unit Testing Requirements

| Class | Test Count | Focus Areas |
|-------|------------|-------------|
| `FileWatcherService` | 20-25 | Start/stop watching, debouncing, pattern matching |
| `FileWatcherCoordinator` | 8-12 | Startup/shutdown, index loading |
| `FileWatcherBackgroundService` | 10-15 | Event handling, file processing |
| Models | 8-10 | Properties, deduplication logic |

**Total: ~46-62 tests**

### Test Scenarios

**FileWatcherService**:
- StartWatching creates FileSystemWatcher
- StopWatching disposes watcher
- SetEnabled toggles EnableRaisingEvents
- File changes are buffered in PendingChanges
- Debounce timer delays processing
- MaxBatchSize triggers immediate processing
- Exclude patterns filter changes
- Include patterns restrict to matching files
- Deduplication: Created + Deleted = no change
- Deduplication: Multiple Modified = keep latest
- ChangesDetected event is raised
- AutoReindex queues IndexingJob
- Watcher error attempts restart

**FileWatcherCoordinator**:
- StartAsync loads indexes from vector store
- Only indexes with AutoReindex enabled are watched
- Invalid workspace paths are logged but don't crash
- StopAsync stops all watchers

**FileWatcherBackgroundService**:
- ChangesDetected event triggers processing
- Deleted files are removed via RemoveFilesAsync
- Added/Modified files are indexed via IndexFilesAsync
- Renamed files are treated as delete + add
- Errors are logged but don't crash

---

## Acceptance Criteria

### Functional Requirements
- [ ] `FileWatcherService` detects file changes (create, modify, delete, rename)
- [ ] Changes are debounced based on `DebounceDelayMs`
- [ ] Pattern filtering works for include and exclude patterns
- [ ] `ChangesDetected` event is raised with deduplicated changes
- [ ] Auto-reindex queues jobs when enabled
- [ ] `FileWatcherCoordinator` starts watchers on app startup
- [ ] `FileWatcherBackgroundService` processes changes and updates index
- [ ] Watcher errors are handled and watcher is restarted

### Quality Requirements
- [ ] Proper disposal of FileSystemWatcher and Timer
- [ ] Thread-safe change buffering with ConcurrentBag
- [ ] Graceful shutdown via StopAll
- [ ] All public members have XML documentation

---

## Future Considerations

Items explicitly deferred to later sub-versions:
- **v0.7.3i**: Progress tracking integration with UI
- **v0.7.4**: Integration tests for full pipeline
