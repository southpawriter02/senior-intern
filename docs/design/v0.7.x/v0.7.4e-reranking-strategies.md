# Design Specification: AIntern v0.7.4e "Reranking Strategies"

## Overview

**Version**: v0.7.4e  
**Parent**: v0.7.4 Retrieval & Context  
**Focus**: Implement multiple reranking strategies to improve search result relevance beyond pure embedding similarity

### Purpose

This sub-version implements concrete reranking strategies:
1. `RerankingStrategyFactory` - Factory implementation for `IRerankingStrategyFactory`
2. `KeywordBoostStrategy` - Boosts results containing query keywords
3. `ReciprocalRankFusionStrategy` - Combines semantic and keyword rankings using RRF
4. `CrossEncoderStrategy` - Placeholder for future cross-encoder model integration

### Dependencies

**From v0.7.2 (Vector Storage)**:
- `ChunkSearchResult` model for search results

**From v0.7.4a (Knowledge Service Interface)**:
- `IRerankingStrategy` interface to implement

**From v0.7.4b (Query & Result Models)**:
- `RerankingStrategy` enum for strategy selection

**From v0.7.4d (Knowledge Service Implementation)**:
- `IRerankingStrategyFactory` interface to implement

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                     v0.7.4e Reranking Strategies                              │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  src/SeniorIntern.Services/Knowledge/Reranking/                              │
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │                                                                          ││
│  │  RerankingStrategyFactory : IRerankingStrategyFactory                    ││
│  │  ├── Dependencies                                                        ││
│  │  │   ├── ILogger<RerankingStrategyFactory>                               ││
│  │  │   └── ILoggerFactory (for strategy logger creation)                   ││
│  │  ├── Create(RerankingStrategy) → IRerankingStrategy?                     ││
│  │  │   ├── None         → null                                             ││
│  │  │   ├── KeywordBoost → new KeywordBoostStrategy(...)                    ││
│  │  │   ├── RRF          → new ReciprocalRankFusionStrategy(...)            ││
│  │  │   └── CrossEncoder → null (not yet implemented)                       ││
│  │  └── IsSupported(RerankingStrategy) → bool                               ││
│  │                                                                          ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │  KeywordBoostStrategy : IRerankingStrategy                               ││
│  │  ├── Configuration Constants                                             ││
│  │  │   ├── BoostPerKeyword = 0.05f   (5% per keyword)                      ││
│  │  │   ├── ExactMatchBoost = 0.10f   (10% for exact phrase)                ││
│  │  │   └── MaxBoost = 0.30f          (30% cap)                             ││
│  │  ├── Properties                                                          ││
│  │  │   ├── Name = "KeywordBoost"                                           ││
│  │  │   └── RequiresQueryText = true                                        ││
│  │  ├── RerankAsync() → Boost scores based on keyword matches               ││
│  │  └── Private Helpers                                                     ││
│  │      ├── ApplyKeywordBoost()                                             ││
│  │      ├── ExtractKeywords() → Filters stop words, splits camelCase        ││
│  │      ├── ContainsKeyword() → Word boundary regex matching                ││
│  │      └── SplitCamelCase() → Split "UserService" → ["User", "Service"]    ││
│  │                                                                          ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │  ReciprocalRankFusionStrategy : IRerankingStrategy                       ││
│  │  ├── Configuration Constants                                             ││
│  │  │   ├── K = 60f               (RRF constant)                            ││
│  │  │   ├── SemanticWeight = 1.0f (weight for embedding rank)               ││
│  │  │   └── KeywordWeight = 0.8f  (weight for keyword rank)                 ││
│  │  ├── Properties                                                          ││
│  │  │   ├── Name = "RRF"                                                    ││
│  │  │   └── RequiresQueryText = true                                        ││
│  │  ├── RerankAsync() → Combine semantic & keyword rankings                 ││
│  │  └── Private Helpers                                                     ││
│  │      ├── CalculateRRFScore() → 1/(K+rank) formula                        ││
│  │      ├── CalculateKeywordScore() → Count occurrences + boundary bonus    ││
│  │      ├── CountOccurrences() → Substring counting                         ││
│  │      ├── CountWordBoundaryMatches() → Regex word boundary                ││
│  │      └── ExtractKeywords() → Filter stop words                           ││
│  │                                                                          ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │  CrossEncoderStrategy : IRerankingStrategy (Placeholder)                 ││
│  │  ├── Name = "CrossEncoder"                                               ││
│  │  ├── RequiresQueryText = true                                            ││
│  │  └── RerankAsync() → Logs warning, returns original results              ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Reranking Pipeline Flow

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                         Reranking Strategy Selection                          │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Input: RerankingStrategy enum value                                         │
│     │                                                                        │
│     ▼                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  RerankingStrategy.None                                                  │ │
│  │  └── Return null → Use original vector search scores                     │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│     │                                                                        │
│     ▼                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  RerankingStrategy.KeywordBoost                                          │ │
│  │  ├── Extract keywords from query (filter stop words)                     │ │
│  │  ├── For each result:                                                    │ │
│  │  │   ├── Check exact phrase match → +10% boost                           │ │
│  │  │   ├── Count keyword matches → +5% per match                           │ │
│  │  │   └── Cap total boost at 30%                                          │ │
│  │  └── Sort by boosted score (descending)                                  │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│     │                                                                        │
│     ▼                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  RerankingStrategy.RRF                                                   │ │
│  │  ├── Create semantic ranking (by embedding similarity)                   │ │
│  │  ├── Create keyword ranking (by keyword frequency)                       │ │
│  │  ├── For each result:                                                    │ │
│  │  │   ├── Semantic: 1.0 × 1/(60 + semanticRank)                          │ │
│  │  │   ├── Keyword:  0.8 × 1/(60 + keywordRank)                           │ │
│  │  │   └── RRF Score = semantic + keyword                                  │ │
│  │  ├── Normalize scores to 0-1 range                                       │ │
│  │  └── Sort by RRF score (descending)                                      │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│     │                                                                        │
│     ▼                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  RerankingStrategy.CrossEncoder                                          │ │
│  │  └── Not implemented → Return original results (with warning log)        │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Services/Knowledge/Reranking/RerankingStrategyFactory.cs` | Factory for creating strategy instances |
| `src/SeniorIntern.Services/Knowledge/Reranking/KeywordBoostStrategy.cs` | Keyword-based score boosting |
| `src/SeniorIntern.Services/Knowledge/Reranking/ReciprocalRankFusionStrategy.cs` | RRF combining multiple rankings |
| `src/SeniorIntern.Services/Knowledge/Reranking/CrossEncoderStrategy.cs` | Placeholder for future cross-encoder |

---

## Detailed Specifications

### 1. RerankingStrategyFactory.cs

**Location**: `src/SeniorIntern.Services/Knowledge/Reranking/RerankingStrategyFactory.cs`

```csharp
using System;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Services.Knowledge.Interfaces;

namespace SeniorIntern.Services.Knowledge.Reranking;

/// <summary>
/// Factory for creating reranking strategy instances.
/// </summary>
public sealed class RerankingStrategyFactory : IRerankingStrategyFactory
{
    private readonly ILogger<RerankingStrategyFactory> _logger;
    private readonly ILoggerFactory _loggerFactory;

    public RerankingStrategyFactory(
        ILogger<RerankingStrategyFactory> logger,
        ILoggerFactory loggerFactory)
    {
        _logger = logger;
        _loggerFactory = loggerFactory;
    }

    /// <inheritdoc />
    public IRerankingStrategy? Create(RerankingStrategy strategy)
    {
        return strategy switch
        {
            RerankingStrategy.None => null,
            RerankingStrategy.KeywordBoost => new KeywordBoostStrategy(
                _loggerFactory.CreateLogger<KeywordBoostStrategy>()),
            RerankingStrategy.RRF => new ReciprocalRankFusionStrategy(
                _loggerFactory.CreateLogger<ReciprocalRankFusionStrategy>()),
            RerankingStrategy.CrossEncoder => CreateCrossEncoderStrategy(),
            _ => throw new ArgumentOutOfRangeException(nameof(strategy))
        };
    }

    /// <inheritdoc />
    public bool IsSupported(RerankingStrategy strategy)
    {
        return strategy switch
        {
            RerankingStrategy.None => true,
            RerankingStrategy.KeywordBoost => true,
            RerankingStrategy.RRF => true,
            RerankingStrategy.CrossEncoder => false,
            _ => false
        };
    }

    private IRerankingStrategy? CreateCrossEncoderStrategy()
    {
        _logger.LogWarning("CrossEncoder reranking is not yet implemented");
        return null;
    }
}
```

---

### 2. KeywordBoostStrategy.cs

**Location**: `src/SeniorIntern.Services/Knowledge/Reranking/KeywordBoostStrategy.cs`

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;

namespace SeniorIntern.Services.Knowledge.Reranking;

/// <summary>
/// Reranking strategy that boosts results containing query keywords.
/// </summary>
/// <remarks>
/// <para>
/// This strategy improves relevance by applying score boosts for:
/// <list type="bullet">
///   <item>Exact phrase matches (+10%)</item>
///   <item>Individual keyword matches (+5% each)</item>
/// </list>
/// Total boost is capped at 30% to prevent over-amplification.
/// </para>
/// <para>
/// Keywords are extracted by filtering stop words and splitting camelCase identifiers.
/// </para>
/// </remarks>
public sealed class KeywordBoostStrategy : IRerankingStrategy
{
    private readonly ILogger<KeywordBoostStrategy> _logger;

    private const float BoostPerKeyword = 0.05f;
    private const float ExactMatchBoost = 0.10f;
    private const float MaxBoost = 0.30f;

    private static readonly HashSet<string> StopWords = new(StringComparer.OrdinalIgnoreCase)
    {
        "a", "an", "the", "is", "are", "was", "were", "be", "been",
        "being", "have", "has", "had", "do", "does", "did", "will",
        "would", "could", "should", "may", "might", "must", "shall",
        "can", "need", "dare", "ought", "used", "to", "of", "in",
        "for", "on", "with", "at", "by", "from", "as", "into",
        "through", "during", "before", "after", "above", "below",
        "between", "under", "again", "further", "then", "once",
        "where", "how", "what", "which", "who", "whom", "this",
        "that", "these", "those", "am", "or", "and", "but", "if",
        "because", "until", "while", "about", "against", "each",
        "few", "more", "most", "other", "some", "such", "no", "nor",
        "not", "only", "own", "same", "so", "than", "too", "very",
        "just", "also", "now", "here", "there", "when", "why", "all",
        "any", "both", "each", "every"
    };

    public string Name => "KeywordBoost";
    public bool RequiresQueryText => true;

    public KeywordBoostStrategy(ILogger<KeywordBoostStrategy> logger)
    {
        _logger = logger;
    }

    /// <inheritdoc />
    public Task<IReadOnlyList<ChunkSearchResult>> RerankAsync(
        IReadOnlyList<ChunkSearchResult> results,
        string query,
        CancellationToken ct = default)
    {
        if (results.Count == 0)
            return Task.FromResult(results);

        var keywords = ExtractKeywords(query);
        if (keywords.Count == 0)
        {
            _logger.LogDebug("No keywords extracted, skipping reranking");
            return Task.FromResult(results);
        }

        _logger.LogDebug("Reranking with {Count} keywords: {Keywords}",
            keywords.Count, string.Join(", ", keywords));

        var reranked = results
            .Select(r => ApplyKeywordBoost(r, keywords, query))
            .OrderByDescending(r => r.Score)
            .ToList();

        return Task.FromResult<IReadOnlyList<ChunkSearchResult>>(reranked);
    }

    private ChunkSearchResult ApplyKeywordBoost(
        ChunkSearchResult result, List<string> keywords, string originalQuery)
    {
        var content = result.Chunk.Content;
        var totalBoost = 0f;

        // Exact phrase match
        if (content.Contains(originalQuery, StringComparison.OrdinalIgnoreCase))
            totalBoost += ExactMatchBoost;

        // Keyword matches
        var matchCount = keywords.Count(k => ContainsKeyword(content, k));
        totalBoost += matchCount * BoostPerKeyword;
        totalBoost = Math.Min(totalBoost, MaxBoost);

        if (totalBoost > 0)
        {
            return result with
            {
                Score = Math.Min(1.0f, result.Score + totalBoost),
                OriginalScore = result.OriginalScore > 0 ? result.OriginalScore : result.Score
            };
        }
        return result;
    }

    private static bool ContainsKeyword(string content, string keyword)
    {
        var pattern = $@"\b{Regex.Escape(keyword)}\b";
        return Regex.IsMatch(content, pattern, RegexOptions.IgnoreCase);
    }

    private static List<string> ExtractKeywords(string query)
    {
        var words = Regex.Split(query, @"[\s\.,;:!?\-\(\)\[\]{}""']+")
            .Where(w => !string.IsNullOrEmpty(w)).ToList();

        var keywords = words
            .Where(w => w.Length > 2 && !StopWords.Contains(w))
            .Select(w => w.ToLowerInvariant())
            .Distinct().ToList();

        // Add camelCase parts
        foreach (var word in words.Where(w => w.Length > 3))
        {
            keywords.AddRange(SplitCamelCase(word)
                .Where(p => p.Length > 2 && !StopWords.Contains(p))
                .Select(p => p.ToLowerInvariant()));
        }

        return keywords.Distinct().ToList();
    }

    private static IEnumerable<string> SplitCamelCase(string input)
        => Regex.Split(input, @"(?<!^)(?=[A-Z])").Where(s => !string.IsNullOrEmpty(s));
}
```

---

### 3. ReciprocalRankFusionStrategy.cs

**Location**: `src/SeniorIntern.Services/Knowledge/Reranking/ReciprocalRankFusionStrategy.cs`

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;

namespace SeniorIntern.Services.Knowledge.Reranking;

/// <summary>
/// Reranking strategy using Reciprocal Rank Fusion (RRF).
/// Combines semantic similarity ranking with keyword-based ranking.
/// </summary>
/// <remarks>
/// <para>
/// RRF is a proven technique for combining multiple ranking signals:
/// <code>
/// RRF(d) = Σ 1/(k + rank_i(d)) for each ranking i
/// </code>
/// Where k=60 is a standard constant that prevents the impact of high rankings
/// from dominating over the sum of lower rankings.
/// </para>
/// </remarks>
public sealed class ReciprocalRankFusionStrategy : IRerankingStrategy
{
    private readonly ILogger<ReciprocalRankFusionStrategy> _logger;

    private const float K = 60f;
    private const float SemanticWeight = 1.0f;
    private const float KeywordWeight = 0.8f;

    private static readonly HashSet<string> StopWords = new(StringComparer.OrdinalIgnoreCase)
    {
        "a", "an", "the", "is", "are", "was", "were", "be", "been",
        "being", "have", "has", "had", "do", "does", "did", "will",
        "would", "could", "should", "may", "might", "must", "shall",
        "can", "need", "to", "of", "in", "for", "on", "with", "at",
        "by", "from", "as", "into", "through", "during", "before",
        "after", "where", "how", "what", "which", "who", "this",
        "that", "or", "and", "but", "if", "not", "all", "any"
    };

    public string Name => "RRF";
    public bool RequiresQueryText => true;

    public ReciprocalRankFusionStrategy(ILogger<ReciprocalRankFusionStrategy> logger)
    {
        _logger = logger;
    }

    /// <inheritdoc />
    public Task<IReadOnlyList<ChunkSearchResult>> RerankAsync(
        IReadOnlyList<ChunkSearchResult> results,
        string query,
        CancellationToken ct = default)
    {
        if (results.Count == 0)
            return Task.FromResult(results);

        var keywords = ExtractKeywords(query);
        if (keywords.Count == 0)
        {
            _logger.LogDebug("No keywords for RRF, using semantic ranking only");
            return Task.FromResult(results);
        }

        _logger.LogDebug("Applying RRF with {Count} keywords", keywords.Count);

        // Semantic ranking (input order)
        var semanticRanks = results
            .Select((r, i) => (r.ChunkId, Rank: i + 1))
            .ToDictionary(x => x.ChunkId, x => x.Rank);

        // Keyword ranking
        var keywordRanks = results
            .Select(r => (r, Score: CalculateKeywordScore(r.Chunk.Content, keywords)))
            .OrderByDescending(x => x.Score)
            .Select((x, i) => (x.r.ChunkId, Rank: i + 1))
            .ToDictionary(x => x.ChunkId, x => x.Rank);

        // Calculate RRF
        var reranked = results.Select(r =>
        {
            var rrfScore = CalculateRRFScore(
                semanticRanks[r.ChunkId],
                keywordRanks.GetValueOrDefault(r.ChunkId, results.Count));

            return r with
            {
                Score = rrfScore,
                OriginalScore = r.OriginalScore > 0 ? r.OriginalScore : r.Score
            };
        }).OrderByDescending(r => r.Score).ToList();

        // Normalize to 0-1
        if (reranked.Count > 0)
        {
            var max = reranked.Max(r => r.Score);
            var min = reranked.Min(r => r.Score);
            var range = max - min;
            if (range > 0)
                reranked = reranked.Select(r => r with { Score = (r.Score - min) / range }).ToList();
        }

        return Task.FromResult<IReadOnlyList<ChunkSearchResult>>(reranked);
    }

    private static float CalculateRRFScore(int semanticRank, int keywordRank)
    {
        return SemanticWeight * (1f / (K + semanticRank))
             + KeywordWeight * (1f / (K + keywordRank));
    }

    private static float CalculateKeywordScore(string content, List<string> keywords)
    {
        var contentLower = content.ToLowerInvariant();
        var score = 0f;

        foreach (var kw in keywords)
        {
            score += CountOccurrences(contentLower, kw.ToLowerInvariant());
            score += CountWordBoundaryMatches(content, kw) * 0.5f;
        }
        return score;
    }

    private static int CountOccurrences(string content, string keyword)
    {
        int count = 0, index = 0;
        while ((index = content.IndexOf(keyword, index, StringComparison.Ordinal)) != -1)
        {
            count++;
            index += keyword.Length;
        }
        return count;
    }

    private static int CountWordBoundaryMatches(string content, string keyword)
        => Regex.Matches(content, $@"\b{Regex.Escape(keyword)}\b", RegexOptions.IgnoreCase).Count;

    private static List<string> ExtractKeywords(string query)
        => Regex.Split(query, @"[\s\.,;:!?\-\(\)\[\]{}""']+")
            .Where(w => w.Length > 2 && !StopWords.Contains(w))
            .Select(w => w.ToLowerInvariant())
            .Distinct().ToList();
}
```

---

### 4. CrossEncoderStrategy.cs

**Location**: `src/SeniorIntern.Services/Knowledge/Reranking/CrossEncoderStrategy.cs`

```csharp
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;

namespace SeniorIntern.Services.Knowledge.Reranking;

/// <summary>
/// Reranking strategy using a cross-encoder model.
/// Reserved for future implementation - provides placeholder for architecture.
/// </summary>
/// <remarks>
/// <para>
/// Cross-encoder reranking provides the highest accuracy by scoring each
/// (query, document) pair directly. Implementation would involve:
/// <list type="number">
///   <item>Loading a cross-encoder model (e.g., ms-marco-MiniLM)</item>
///   <item>Scoring each (query, chunk) pair</item>
///   <item>Sorting by cross-encoder scores</item>
/// </list>
/// </para>
/// <para>
/// This is significantly slower than KeywordBoost or RRF but provides
/// the best relevance for complex queries.
/// </para>
/// </remarks>
public sealed class CrossEncoderStrategy : IRerankingStrategy
{
    private readonly ILogger<CrossEncoderStrategy> _logger;

    public string Name => "CrossEncoder";
    public bool RequiresQueryText => true;

    public CrossEncoderStrategy(ILogger<CrossEncoderStrategy> logger)
    {
        _logger = logger;
    }

    /// <inheritdoc />
    public Task<IReadOnlyList<ChunkSearchResult>> RerankAsync(
        IReadOnlyList<ChunkSearchResult> results,
        string query,
        CancellationToken ct = default)
    {
        _logger.LogWarning("CrossEncoder reranking is not yet implemented, returning original results");
        return Task.FromResult(results);
    }
}
```

---

## Unit Testing Requirements

| Component | Test Count | Focus Areas |
|-----------|------------|-------------|
| `RerankingStrategyFactory` | 6-8 | Create each strategy, IsSupported checks |
| `KeywordBoostStrategy` | 12-15 | Boost calculation, keyword extraction, edge cases |
| `ReciprocalRankFusionStrategy` | 10-12 | RRF formula, normalization, ranking |
| `CrossEncoderStrategy` | 2-3 | Returns original, logs warning |

**Total: ~30-38 tests**

### Test Scenarios

```
RerankingStrategyFactory Tests:
├── Create_None_ReturnsNull
├── Create_KeywordBoost_ReturnsKeywordBoostStrategy
├── Create_RRF_ReturnsReciprocalRankFusionStrategy
├── Create_CrossEncoder_ReturnsNull
├── IsSupported_KeywordBoost_ReturnsTrue
└── IsSupported_CrossEncoder_ReturnsFalse

KeywordBoostStrategy Tests:
├── Rerank_EmptyResults_ReturnsEmpty
├── Rerank_NoKeywords_ReturnsOriginal
├── Rerank_ExactMatch_Applies10PercentBoost
├── Rerank_SingleKeyword_Applies5PercentBoost
├── Rerank_MultipleKeywords_AccumulatesBoost
├── Rerank_MaxBoost_CappedAt30Percent
├── Rerank_PreservesOriginalScore
├── ExtractKeywords_FiltersStopWords
├── ExtractKeywords_SplitsCamelCase
└── ContainsKeyword_WordBoundaryMatching

ReciprocalRankFusionStrategy Tests:
├── Rerank_EmptyResults_ReturnsEmpty
├── Rerank_CombinesSemanticAndKeywordRanks
├── Rerank_NormalizesScoresToZeroOne
├── Rerank_HighKeywordFrequency_BoostsRank
├── CalculateRRFScore_CorrectFormula
└── Rerank_PreservesOriginalScore
```

---

## Acceptance Criteria

### Functional Requirements
- [ ] `RerankingStrategyFactory.Create` returns correct strategy for each enum value
- [ ] `RerankingStrategyFactory.IsSupported` returns false for CrossEncoder
- [ ] `KeywordBoostStrategy` extracts keywords filtering stop words
- [ ] `KeywordBoostStrategy` applies boost capped at 30%
- [ ] `KeywordBoostStrategy` splits camelCase identifiers
- [ ] `ReciprocalRankFusionStrategy` combines semantic and keyword rankings
- [ ] `ReciprocalRankFusionStrategy` normalizes output scores to 0-1
- [ ] All strategies preserve `OriginalScore` property
- [ ] `CrossEncoderStrategy` logs warning and returns original results

### Quality Requirements
- [ ] All strategies implement `IRerankingStrategy` correctly
- [ ] All public members have XML documentation
- [ ] Logging at Debug level for reranking operations
- [ ] Stop words list is comprehensive for code search

---

## Future Considerations

Items deferred to later versions:
- **Future**: Full `CrossEncoderStrategy` implementation with model loading
- **Future**: Configurable boost values via options
- **Future**: Language-specific stop word lists
