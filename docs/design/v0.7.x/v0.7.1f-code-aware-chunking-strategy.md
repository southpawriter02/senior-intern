# Design Specification: AIntern v0.7.1f "Code-Aware Chunking Strategy"

## Overview

**Version**: v0.7.1f
**Parent**: v0.7.1 Embedding Foundation
**Focus**: Implement chunking strategy that respects code structure

### Purpose

Implement a code-aware chunking strategy using regex-based symbol extraction:
1. Create `CodeAwareChunkingStrategy` as base implementation of `ICodeChunkingStrategy`
2. Extract code symbols (classes, methods, functions) via regex patterns
3. Implement semantic chunking that respects code boundaries
4. Provide line-based fallback with configurable overlap
5. Handle brace-matching for C-style languages
6. Handle indentation-based block detection for Python
7. Provide DI registration extension methods

### Dependencies

**From v0.7.1e (Chunking Service Interface)**:
- `IChunkingService` interface
- `IChunkingStrategy` interface
- `ICodeChunkingStrategy` interface
- `CodeSymbol` model
- `ParameterInfo` model

**From v0.7.1d (Text Chunk Models)**:
- `TextChunk` model
- `ChunkType` enum
- `SymbolType` enum
- `ChunkingOptions` class

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                v0.7.1f Code-Aware Chunking Architecture                       │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Strategy Inheritance Hierarchy:                                             │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  IChunkingStrategy (from v0.7.1e)                                       │ │
│  │         │                                                                │ │
│  │         └── ICodeChunkingStrategy (from v0.7.1e)                        │ │
│  │                     │                                                    │ │
│  │                     └── CodeAwareChunkingStrategy (v0.7.1f)             │ │
│  │                                 │                                        │ │
│  │                                 ├── CSharpChunkingStrategy (v0.7.1g)    │ │
│  │                                 ├── TypeScriptChunkingStrategy (v0.7.1g)│ │
│  │                                 └── PythonChunkingStrategy (v0.7.1g)    │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  CodeAwareChunkingStrategy Components:                                       │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  Properties:                                                             │ │
│  │  ├── Name: "CodeAware"                                                  │ │
│  │  ├── Priority: 100                                                      │ │
│  │  └── SupportedExtensions: 16 file extensions                            │ │
│  │                                                                          │ │
│  │  Core Methods:                                                           │ │
│  │  ├── CanHandle(filePath) → bool                                         │ │
│  │  ├── Chunk(content, path, options) → TextChunk[]                        │ │
│  │  └── ExtractSymbols(content, path) → CodeSymbol[]                       │ │
│  │                                                                          │ │
│  │  Chunking Pipeline:                                                      │ │
│  │  ├── TrySemanticChunk() → Symbol-based chunking (primary)               │ │
│  │  └── LineBasedChunk() → Line-based fallback with overlap                │ │
│  │                                                                          │ │
│  │  Symbol Extraction:                                                      │ │
│  │  ├── GetSymbolPatterns(language) → Regex patterns                       │ │
│  │  ├── ExtractSymbolsForLanguage(content, language) → CodeSymbol[]        │ │
│  │  └── FindSymbolEnd(content, offset, language) → end position            │ │
│  │                                                                          │ │
│  │  Block Detection:                                                        │ │
│  │  ├── FindMatchingBrace() → For C-style languages                        │ │
│  │  └── FindPythonBlockEnd() → For indentation-based languages             │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Chunking Algorithm Flow

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                         Chunking Algorithm Flow                               │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Input: content, filePath, ChunkingOptions                                   │
│                                                                              │
│  Step 1: Detect Language                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  extension = Path.GetExtension(filePath).ToLowerInvariant()              │ │
│  │  language = GetLanguageFromExtension(extension)                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                               ↓                                              │
│  Step 2: Try Semantic Chunking (if options.UseSemanticChunking)              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  2a. Extract Symbols                                                     │ │
│  │      symbols = ExtractSymbolsForLanguage(content, language)              │ │
│  │                                                                          │ │
│  │  2b. For each symbol (ordered by StartOffset):                           │ │
│  │      ├── Extract symbol content                                          │ │
│  │      ├── Estimate token count                                            │ │
│  │      │                                                                    │ │
│  │      ├── IF tokens < MinChunkSize: SKIP                                  │ │
│  │      │                                                                    │ │
│  │      ├── IF tokens <= MaxChunkSize:                                      │ │
│  │      │   └── Create single chunk with symbol metadata                    │ │
│  │      │                                                                    │ │
│  │      └── IF tokens > MaxChunkSize:                                       │ │
│  │          └── SplitLargeSymbol() → sub-chunks                             │ │
│  │                                                                          │ │
│  │  2c. Handle inter-symbol content (imports, top-level code)               │ │
│  │      └── ChunkInterSymbolContent() → gap chunks                          │ │
│  │                                                                          │ │
│  │  2d. Sort all chunks by StartOffset                                      │ │
│  │  2e. IF chunks.Count > 0: RETURN chunks                                  │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                               ↓                                              │
│  Step 3: Line-Based Fallback                                                 │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  3a. Split content into lines                                            │ │
│  │                                                                          │ │
│  │  3b. For each line:                                                      │ │
│  │      ├── Estimate line token count                                       │ │
│  │      ├── IF (currentTokens + lineTokens > TargetChunkSize):              │ │
│  │      │   ├── Emit current chunk                                          │ │
│  │      │   ├── Calculate overlap lines (ChunkOverlap tokens)               │ │
│  │      │   └── Start new chunk with overlap                                │ │
│  │      └── Append line to current chunk                                    │ │
│  │                                                                          │ │
│  │  3c. Emit final chunk (if >= MinChunkSize)                               │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                               ↓                                              │
│  Output: IReadOnlyList<TextChunk>                                            │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Symbol Extraction Patterns

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                      Language Symbol Regex Patterns                           │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  C# Patterns:                                                                │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  Symbol Type  │ Pattern (simplified)                                     │ │
│  │  ─────────────│──────────────────────────────────────────────────────── │ │
│  │  Class        │ [access]? [static]? [partial]? class (?<name>\w+)       │ │
│  │  Interface    │ [access]? [static]? interface (?<name>\w+)               │ │
│  │  Method       │ [access]? [async]? [type] (?<name>\w+) \(                │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  TypeScript/JavaScript Patterns:                                             │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  Symbol Type  │ Pattern (simplified)                                     │ │
│  │  ─────────────│──────────────────────────────────────────────────────── │ │
│  │  Class        │ [export]? [default]? class (?<name>\w+)                  │ │
│  │  Function     │ [export]? [async]? function (?<name>\w+) \(              │ │
│  │  Arrow Func   │ (const|let|var) (?<name>\w+) = [async]? (...) =>        │ │
│  │  Method       │ (?<name>\w+) : [async]? (...) =>                        │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  Python Patterns:                                                            │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  Symbol Type  │ Pattern (simplified)                                     │ │
│  │  ─────────────│──────────────────────────────────────────────────────── │ │
│  │  Class        │ class (?<name>\w+) [...] :                               │ │
│  │  Function     │ [async]? def (?<name>\w+) \(                             │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  Go Patterns:                                                                │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  Symbol Type  │ Pattern (simplified)                                     │ │
│  │  ─────────────│──────────────────────────────────────────────────────── │ │
│  │  Struct       │ type (?<name>\w+) struct \{                              │ │
│  │  Interface    │ type (?<name>\w+) interface \{                           │ │
│  │  Function     │ func [receiver]? (?<name>\w+) \(                         │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  Rust Patterns:                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  Symbol Type  │ Pattern (simplified)                                     │ │
│  │  ─────────────│──────────────────────────────────────────────────────── │ │
│  │  Struct       │ [pub]? struct (?<name>\w+)                               │ │
│  │  Trait        │ [pub]? trait (?<name>\w+)                                │ │
│  │  Function     │ [pub]? [async]? fn (?<name>\w+)                          │ │
│  │  Impl         │ impl [...] (?<name>\w+)                                  │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  Fallback (Unknown Languages):                                               │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  Class        │ (class|struct|interface) (?<name>\w+)                    │ │
│  │  Function     │ (function|func|def|fn) (?<name>\w+)                      │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Block Detection Algorithms

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                      Block Detection Algorithms                               │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Brace Matching (C-style languages):                                         │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  Languages: C#, TypeScript, JavaScript, Java, Go, Rust, C++, Swift       │ │
│  │                                                                          │ │
│  │  Algorithm:                                                              │ │
│  │  1. Find first '{' after startOffset                                    │ │
│  │  2. Track nested depth (increment on '{', decrement on '}')              │ │
│  │  3. Handle string literals (", ', `) - ignore braces inside              │ │
│  │  4. Handle escape sequences (\\) - skip next character                   │ │
│  │  5. Return position after matching '}' when depth == 0                   │ │
│  │                                                                          │ │
│  │  Edge Cases:                                                             │ │
│  │  ├── No opening brace found → return content.Length                      │ │
│  │  ├── Unmatched braces → return content.Length                            │ │
│  │  └── String containing braces → correctly ignored                        │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  Indentation-Based (Python):                                                 │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  Algorithm:                                                              │ │
│  │  1. Get base indentation of first line                                   │ │
│  │  2. Scan subsequent lines:                                               │ │
│  │     ├── Skip empty/whitespace-only lines                                 │ │
│  │     ├── Skip comment lines (starting with #)                             │ │
│  │     └── Block ends when indentation <= base AND not comment              │ │
│  │  3. Return position of first line at same/lower indentation              │ │
│  │                                                                          │ │
│  │  Indentation Calculation:                                                │ │
│  │  ├── Space: +1                                                           │ │
│  │  └── Tab: +4 (normalized)                                                │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  Fallback (Unknown):                                                         │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  Find next double newline ("\n\n") or end of file                        │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Specifications

### 1. CodeAwareChunkingStrategy.cs

**Location**: `src/SeniorIntern.Services/Chunking/CodeAwareChunkingStrategy.cs`

```csharp
namespace SeniorIntern.Services.Chunking;

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;

/// <summary>
/// Chunking strategy that respects code structure (classes, methods, functions).
/// Uses regex-based parsing for language-agnostic symbol detection.
/// </summary>
/// <remarks>
/// <para>
/// The CodeAwareChunkingStrategy extracts semantic units from source code
/// rather than splitting arbitrarily by character or line count. This produces
/// chunks that are more meaningful for embedding and retrieval.
/// </para>
/// <para>
/// The strategy supports two modes:
/// <list type="bullet">
///   <item>Semantic chunking: Chunks by code symbols (classes, methods, functions)</item>
///   <item>Line-based fallback: Used when symbol extraction yields no results</item>
/// </list>
/// </para>
/// <para>
/// Language-specific strategies (e.g., CSharpChunkingStrategy) can inherit
/// from this class and override symbol patterns for better accuracy.
/// </para>
/// </remarks>
public class CodeAwareChunkingStrategy : ICodeChunkingStrategy
{
    /// <summary>
    /// Logger instance.
    /// </summary>
    protected readonly ILogger _logger;

    /// <summary>
    /// Reference to chunking service for token estimation.
    /// </summary>
    protected readonly IChunkingService _chunkingService;

    /// <summary>
    /// Supported file extensions for this strategy.
    /// </summary>
    private static readonly HashSet<string> _supportedExtensions = new(StringComparer.OrdinalIgnoreCase)
    {
        // .NET
        ".cs", ".fs", ".vb",
        // JavaScript/TypeScript
        ".ts", ".tsx", ".js", ".jsx",
        // Python
        ".py",
        // JVM
        ".java", ".kt",
        // Go
        ".go",
        // Rust
        ".rs",
        // C/C++
        ".cpp", ".hpp", ".c", ".h",
        // Others
        ".swift", ".rb", ".php"
    };

    /// <summary>
    /// Languages that use brace-based block delimiters.
    /// </summary>
    private static readonly HashSet<string> _braceLanguages = new()
    {
        "csharp", "typescript", "javascript", "java", "go", "rust",
        "cpp", "c", "swift", "kotlin", "php"
    };

    #region IChunkingStrategy Properties

    /// <inheritdoc />
    public virtual string Name => "CodeAware";

    /// <inheritdoc />
    public virtual IReadOnlySet<string> SupportedExtensions => _supportedExtensions;

    /// <inheritdoc />
    public virtual int Priority => 100;

    #endregion

    #region Constructor

    /// <summary>
    /// Initializes a new instance of the CodeAwareChunkingStrategy.
    /// </summary>
    /// <param name="logger">Logger instance.</param>
    /// <param name="chunkingService">Chunking service for token estimation.</param>
    public CodeAwareChunkingStrategy(
        ILogger<CodeAwareChunkingStrategy> logger,
        IChunkingService chunkingService)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _chunkingService = chunkingService ?? throw new ArgumentNullException(nameof(chunkingService));
    }

    #endregion

    #region IChunkingStrategy Implementation

    /// <inheritdoc />
    public virtual bool CanHandle(string filePath)
    {
        var extension = Path.GetExtension(filePath);
        return SupportedExtensions.Contains(extension);
    }

    /// <inheritdoc />
    public virtual IReadOnlyList<TextChunk> Chunk(
        string content,
        string filePath,
        ChunkingOptions options)
    {
        var extension = Path.GetExtension(filePath).ToLowerInvariant();
        var language = GetLanguageFromExtension(extension);

        _logger.LogDebug(
            "Chunking {File} as {Language} ({Length} chars)",
            filePath, language, content.Length);

        // Try semantic chunking first (by code symbols)
        if (options.UseSemanticChunking)
        {
            var semanticChunks = TrySemanticChunk(content, filePath, language, options);
            if (semanticChunks.Count > 0)
            {
                _logger.LogDebug(
                    "Semantic chunking produced {Count} chunks",
                    semanticChunks.Count);
                return semanticChunks;
            }

            _logger.LogDebug("No symbols extracted, falling back to line-based chunking");
        }

        // Fall back to line-based chunking with overlap
        return LineBasedChunk(content, filePath, language, options);
    }

    /// <inheritdoc />
    public virtual IReadOnlyList<CodeSymbol> ExtractSymbols(string content, string filePath)
    {
        var extension = Path.GetExtension(filePath).ToLowerInvariant();
        var language = GetLanguageFromExtension(extension);

        return ExtractSymbolsForLanguage(content, language);
    }

    #endregion

    #region Semantic Chunking

    /// <summary>
    /// Try to chunk content by semantic code structure.
    /// </summary>
    protected virtual IReadOnlyList<TextChunk> TrySemanticChunk(
        string content,
        string filePath,
        string language,
        ChunkingOptions options)
    {
        var chunks = new List<TextChunk>();
        var symbols = ExtractSymbolsForLanguage(content, language);

        if (symbols.Count == 0)
            return chunks;

        _logger.LogDebug("Extracted {Count} symbols from {File}", symbols.Count, filePath);

        var sequenceNumber = 0;

        // Process each symbol in order
        foreach (var symbol in symbols.OrderBy(s => s.StartOffset))
        {
            var symbolContent = content.Substring(symbol.StartOffset, symbol.Length);
            var tokenCount = _chunkingService.EstimateTokenCount(symbolContent);

            // Skip symbols that are too small
            if (tokenCount < options.MinChunkSize)
                continue;

            if (tokenCount <= options.MaxChunkSize)
            {
                // Symbol fits in one chunk
                chunks.Add(CreateChunk(
                    symbolContent, filePath, symbol, language, tokenCount, sequenceNumber++));
            }
            else if (options.PreserveFunctionBodies && IsCallableSymbol(symbol.Type))
            {
                // Try to keep function bodies together with smart splitting
                chunks.AddRange(SplitLargeSymbol(
                    content, filePath, symbol, language, options, ref sequenceNumber));
            }
            else
            {
                // Split the symbol into smaller chunks
                chunks.AddRange(SplitLargeSymbol(
                    content, filePath, symbol, language, options, ref sequenceNumber));
            }
        }

        // Handle content between symbols (imports, top-level code, etc.)
        var interSymbolChunks = ChunkInterSymbolContent(
            content, filePath, symbols, language, options, ref sequenceNumber);
        chunks.AddRange(interSymbolChunks);

        // Return chunks in document order
        return chunks.OrderBy(c => c.StartOffset).ToList();
    }

    #endregion

    #region Line-Based Chunking

    /// <summary>
    /// Chunk content by lines with configurable overlap.
    /// </summary>
    protected virtual IReadOnlyList<TextChunk> LineBasedChunk(
        string content,
        string filePath,
        string language,
        ChunkingOptions options)
    {
        var chunks = new List<TextChunk>();
        var lines = content.Split('\n');
        var currentChunk = new StringBuilder();
        var startLine = 1;
        var startOffset = 0;
        var currentTokenCount = 0;
        var sequenceNumber = 0;
        var currentOffset = 0;

        for (int i = 0; i < lines.Length; i++)
        {
            var line = lines[i];
            var lineTokens = _chunkingService.EstimateTokenCount(line);

            // Check if we need to emit the current chunk
            if (currentTokenCount + lineTokens > options.TargetChunkSize && currentChunk.Length > 0)
            {
                // Emit current chunk
                chunks.Add(new TextChunk
                {
                    Content = currentChunk.ToString().TrimEnd(),
                    FilePath = filePath,
                    StartLine = startLine,
                    EndLine = i,
                    StartOffset = startOffset,
                    EndOffset = currentOffset,
                    Language = language,
                    Type = ChunkType.Code,
                    TokenCount = currentTokenCount,
                    SequenceNumber = sequenceNumber++,
                    HasOverlap = sequenceNumber > 0
                });

                // Start new chunk with overlap
                var overlapLines = CalculateOverlapLines(lines, i, options.ChunkOverlap);
                currentChunk.Clear();

                foreach (var ol in overlapLines)
                    currentChunk.AppendLine(ol);

                startLine = Math.Max(1, i - overlapLines.Count + 1);
                startOffset = currentOffset - string.Join('\n', overlapLines).Length;
                currentTokenCount = _chunkingService.EstimateTokenCount(currentChunk.ToString());
            }

            currentChunk.AppendLine(line);
            currentOffset += line.Length + 1; // +1 for newline
            currentTokenCount += lineTokens;
        }

        // Emit the final chunk if it meets minimum size
        if (currentChunk.Length > 0 && currentTokenCount >= options.MinChunkSize)
        {
            chunks.Add(new TextChunk
            {
                Content = currentChunk.ToString().TrimEnd(),
                FilePath = filePath,
                StartLine = startLine,
                EndLine = lines.Length,
                StartOffset = startOffset,
                EndOffset = content.Length,
                Language = language,
                Type = ChunkType.Code,
                TokenCount = currentTokenCount,
                SequenceNumber = sequenceNumber
            });
        }

        return chunks;
    }

    #endregion

    #region Symbol Extraction

    /// <summary>
    /// Extract symbols from content for a specific language.
    /// </summary>
    protected virtual IReadOnlyList<CodeSymbol> ExtractSymbolsForLanguage(
        string content,
        string language)
    {
        var symbols = new List<CodeSymbol>();
        var patterns = GetSymbolPatterns(language);

        foreach (var (pattern, symbolType) in patterns)
        {
            try
            {
                var matches = Regex.Matches(content, pattern, RegexOptions.Multiline);

                foreach (Match match in matches)
                {
                    var nameGroup = match.Groups["name"];
                    if (!nameGroup.Success)
                        continue;

                    var startOffset = match.Index;
                    var endOffset = FindSymbolEnd(content, startOffset, language);
                    var startLine = GetLineNumber(content, startOffset);
                    var endLine = GetLineNumber(content, endOffset);

                    symbols.Add(new CodeSymbol
                    {
                        Name = nameGroup.Value,
                        Type = symbolType,
                        StartLine = startLine,
                        EndLine = endLine,
                        StartOffset = startOffset,
                        Length = endOffset - startOffset
                    });
                }
            }
            catch (RegexMatchTimeoutException ex)
            {
                _logger.LogWarning(ex, "Regex timeout for pattern in {Language}", language);
            }
        }

        return symbols;
    }

    /// <summary>
    /// Get regex patterns for extracting symbols in a language.
    /// </summary>
    protected virtual IEnumerable<(string Pattern, SymbolType Type)> GetSymbolPatterns(string language)
    {
        return language switch
        {
            "csharp" => new[]
            {
                (@"(?:public|private|protected|internal)?\s*(?:static\s+)?(?:partial\s+)?class\s+(?<name>\w+)", SymbolType.Class),
                (@"(?:public|private|protected|internal)?\s*(?:static\s+)?interface\s+(?<name>\w+)", SymbolType.Interface),
                (@"(?:public|private|protected|internal)?\s*(?:static\s+)?(?:async\s+)?(?:\w+(?:<[^>]+>)?)\s+(?<name>\w+)\s*\(", SymbolType.Method),
            },
            "typescript" or "javascript" => new[]
            {
                (@"(?:export\s+)?(?:default\s+)?class\s+(?<name>\w+)", SymbolType.Class),
                (@"(?:export\s+)?(?:async\s+)?function\s+(?<name>\w+)\s*\(", SymbolType.Function),
                (@"(?:const|let|var)\s+(?<name>\w+)\s*=\s*(?:async\s+)?(?:\([^)]*\)|[^=])\s*=>", SymbolType.Function),
                (@"(?<name>\w+)\s*:\s*(?:async\s+)?(?:\([^)]*\)|[^=])\s*=>", SymbolType.Method),
            },
            "python" => new[]
            {
                (@"class\s+(?<name>\w+)\s*(?:\([^)]*\))?\s*:", SymbolType.Class),
                (@"(?:async\s+)?def\s+(?<name>\w+)\s*\(", SymbolType.Function),
            },
            "go" => new[]
            {
                (@"type\s+(?<name>\w+)\s+struct\s*\{", SymbolType.Struct),
                (@"type\s+(?<name>\w+)\s+interface\s*\{", SymbolType.Interface),
                (@"func\s+(?:\([^)]+\)\s+)?(?<name>\w+)\s*\(", SymbolType.Function),
            },
            "rust" => new[]
            {
                (@"(?:pub\s+)?struct\s+(?<name>\w+)", SymbolType.Struct),
                (@"(?:pub\s+)?trait\s+(?<name>\w+)", SymbolType.Interface),
                (@"(?:pub\s+)?(?:async\s+)?fn\s+(?<name>\w+)", SymbolType.Function),
                (@"impl(?:<[^>]+>)?\s+(?<name>\w+)", SymbolType.Class),
            },
            _ => new[]
            {
                (@"(?:class|struct|interface)\s+(?<name>\w+)", SymbolType.Class),
                (@"(?:function|func|def|fn)\s+(?<name>\w+)", SymbolType.Function),
            }
        };
    }

    #endregion

    #region Block Detection

    /// <summary>
    /// Find the end of a code symbol (block end).
    /// </summary>
    protected virtual int FindSymbolEnd(string content, int startOffset, string language)
    {
        // Brace-based languages
        if (_braceLanguages.Contains(language))
        {
            return FindMatchingBrace(content, startOffset);
        }

        // Indentation-based for Python
        if (language == "python")
        {
            return FindPythonBlockEnd(content, startOffset);
        }

        // Default: find next double newline or end of file
        var nextBlank = content.IndexOf("\n\n", startOffset);
        return nextBlank > 0 ? nextBlank : content.Length;
    }

    /// <summary>
    /// Find the matching closing brace for C-style languages.
    /// </summary>
    protected static int FindMatchingBrace(string content, int startOffset)
    {
        var braceStart = content.IndexOf('{', startOffset);
        if (braceStart < 0)
            return content.Length;

        var depth = 0;
        var inString = false;
        var stringChar = '\0';
        var escaped = false;

        for (int i = braceStart; i < content.Length; i++)
        {
            var c = content[i];

            // Handle escape sequences
            if (escaped)
            {
                escaped = false;
                continue;
            }

            if (c == '\\' && inString)
            {
                escaped = true;
                continue;
            }

            // Handle string literals
            if ((c == '"' || c == '\'' || c == '`') && !inString)
            {
                inString = true;
                stringChar = c;
            }
            else if (c == stringChar && inString)
            {
                inString = false;
            }
            else if (!inString)
            {
                // Count braces only outside strings
                if (c == '{')
                    depth++;
                else if (c == '}')
                {
                    depth--;
                    if (depth == 0)
                        return i + 1;
                }
            }
        }

        return content.Length;
    }

    /// <summary>
    /// Find the end of a Python block (indentation-based).
    /// </summary>
    protected static int FindPythonBlockEnd(string content, int startOffset)
    {
        var lines = content[startOffset..].Split('\n');
        if (lines.Length == 0)
            return content.Length;

        // Get initial indentation
        var firstLine = lines[0];
        var baseIndent = GetIndentation(firstLine);
        var offset = startOffset + firstLine.Length + 1;

        for (int i = 1; i < lines.Length; i++)
        {
            var line = lines[i];

            // Skip empty lines and comments
            if (string.IsNullOrWhiteSpace(line))
            {
                offset += line.Length + 1;
                continue;
            }

            var indent = GetIndentation(line);

            // Block ends when we return to same or lower indentation
            // (excluding comment lines)
            if (indent <= baseIndent && !line.TrimStart().StartsWith('#'))
            {
                return offset;
            }

            offset += line.Length + 1;
        }

        return content.Length;
    }

    /// <summary>
    /// Get the indentation level of a line (spaces, with tabs as 4 spaces).
    /// </summary>
    protected static int GetIndentation(string line)
    {
        var count = 0;
        foreach (var c in line)
        {
            if (c == ' ')
                count++;
            else if (c == '\t')
                count += 4;
            else
                break;
        }
        return count;
    }

    #endregion

    #region Helper Methods

    /// <summary>
    /// Get line number for a character offset.
    /// </summary>
    protected static int GetLineNumber(string content, int offset)
    {
        var line = 1;
        for (int i = 0; i < offset && i < content.Length; i++)
        {
            if (content[i] == '\n')
                line++;
        }
        return line;
    }

    /// <summary>
    /// Create a TextChunk from a CodeSymbol.
    /// </summary>
    protected TextChunk CreateChunk(
        string content,
        string filePath,
        CodeSymbol symbol,
        string language,
        int tokenCount,
        int sequenceNumber)
    {
        return new TextChunk
        {
            Content = content,
            FilePath = filePath,
            StartLine = symbol.StartLine,
            EndLine = symbol.EndLine,
            StartOffset = symbol.StartOffset,
            EndOffset = symbol.StartOffset + symbol.Length,
            Language = language,
            Type = GetChunkTypeFromSymbol(symbol.Type),
            SymbolName = symbol.Name,
            SymbolType = symbol.Type,
            QualifiedName = symbol.QualifiedName,
            ParentSymbol = symbol.Parent,
            Namespace = symbol.Namespace,
            Summary = symbol.Documentation,
            TokenCount = tokenCount,
            SequenceNumber = sequenceNumber
        };
    }

    /// <summary>
    /// Split a large symbol into multiple chunks.
    /// </summary>
    protected IReadOnlyList<TextChunk> SplitLargeSymbol(
        string content,
        string filePath,
        CodeSymbol symbol,
        string language,
        ChunkingOptions options,
        ref int sequenceNumber)
    {
        // Extract symbol content and use line-based chunking
        var symbolContent = content.Substring(symbol.StartOffset, symbol.Length);
        var subChunks = LineBasedChunk(symbolContent, filePath, language, options);

        // Adjust offsets and add symbol metadata
        var result = new List<TextChunk>();
        foreach (var chunk in subChunks)
        {
            result.Add(chunk with
            {
                StartOffset = symbol.StartOffset + chunk.StartOffset,
                EndOffset = symbol.StartOffset + chunk.EndOffset,
                StartLine = symbol.StartLine + chunk.StartLine - 1,
                EndLine = symbol.StartLine + chunk.EndLine - 1,
                SymbolName = symbol.Name,
                SymbolType = symbol.Type,
                ParentSymbol = symbol.Parent,
                SequenceNumber = sequenceNumber++
            });
        }

        return result;
    }

    /// <summary>
    /// Chunk content between extracted symbols.
    /// </summary>
    protected IReadOnlyList<TextChunk> ChunkInterSymbolContent(
        string content,
        string filePath,
        IReadOnlyList<CodeSymbol> symbols,
        string language,
        ChunkingOptions options,
        ref int sequenceNumber)
    {
        var chunks = new List<TextChunk>();
        var sortedSymbols = symbols.OrderBy(s => s.StartOffset).ToList();
        var lastEnd = 0;

        // Process gaps between symbols
        foreach (var symbol in sortedSymbols)
        {
            if (symbol.StartOffset > lastEnd)
            {
                var gapContent = content[lastEnd..symbol.StartOffset].Trim();

                if (!string.IsNullOrWhiteSpace(gapContent))
                {
                    var tokenCount = _chunkingService.EstimateTokenCount(gapContent);

                    if (tokenCount >= options.MinChunkSize)
                    {
                        var startLine = GetLineNumber(content, lastEnd);
                        var endLine = GetLineNumber(content, symbol.StartOffset);

                        chunks.Add(new TextChunk
                        {
                            Content = gapContent,
                            FilePath = filePath,
                            StartLine = startLine,
                            EndLine = endLine,
                            StartOffset = lastEnd,
                            EndOffset = symbol.StartOffset,
                            Language = language,
                            Type = DetectChunkType(gapContent),
                            TokenCount = tokenCount,
                            SequenceNumber = sequenceNumber++
                        });
                    }
                }
            }

            lastEnd = symbol.StartOffset + symbol.Length;
        }

        // Handle trailing content after last symbol
        if (lastEnd < content.Length)
        {
            var trailingContent = content[lastEnd..].Trim();

            if (!string.IsNullOrWhiteSpace(trailingContent))
            {
                var tokenCount = _chunkingService.EstimateTokenCount(trailingContent);

                if (tokenCount >= options.MinChunkSize)
                {
                    chunks.Add(new TextChunk
                    {
                        Content = trailingContent,
                        FilePath = filePath,
                        StartLine = GetLineNumber(content, lastEnd),
                        EndLine = GetLineNumber(content, content.Length),
                        StartOffset = lastEnd,
                        EndOffset = content.Length,
                        Language = language,
                        Type = DetectChunkType(trailingContent),
                        TokenCount = tokenCount,
                        SequenceNumber = sequenceNumber++
                    });
                }
            }
        }

        return chunks;
    }

    /// <summary>
    /// Convert SymbolType to ChunkType.
    /// </summary>
    protected static ChunkType GetChunkTypeFromSymbol(SymbolType symbolType)
    {
        return symbolType switch
        {
            SymbolType.Class or SymbolType.Struct or
            SymbolType.Interface or SymbolType.Enum => ChunkType.TypeDefinition,
            SymbolType.Import => ChunkType.Import,
            _ => ChunkType.Code
        };
    }

    /// <summary>
    /// Detect chunk type from content.
    /// </summary>
    protected static ChunkType DetectChunkType(string content)
    {
        var trimmed = content.TrimStart();

        // Check for comments
        if (trimmed.StartsWith("//") || trimmed.StartsWith("/*") ||
            trimmed.StartsWith("#") || trimmed.StartsWith("'''") ||
            trimmed.StartsWith("\"\"\""))
        {
            return ChunkType.Comment;
        }

        // Check for imports
        if (trimmed.StartsWith("using ") || trimmed.StartsWith("import ") ||
            trimmed.StartsWith("from ") || trimmed.StartsWith("require("))
        {
            return ChunkType.Import;
        }

        return ChunkType.Code;
    }

    /// <summary>
    /// Check if symbol type is a callable (method, function, etc.).
    /// </summary>
    protected static bool IsCallableSymbol(SymbolType type)
    {
        return type is SymbolType.Method
            or SymbolType.Function
            or SymbolType.Constructor
            or SymbolType.Lambda;
    }

    /// <summary>
    /// Calculate lines to include as overlap for a new chunk.
    /// </summary>
    protected static List<string> CalculateOverlapLines(
        string[] lines,
        int currentIndex,
        int overlapTokens)
    {
        var overlapLines = new List<string>();
        var tokens = 0;

        for (int i = currentIndex - 1; i >= 0 && tokens < overlapTokens; i--)
        {
            overlapLines.Insert(0, lines[i]);
            tokens += lines[i].Length / 4; // Rough estimate: ~4 chars/token
        }

        return overlapLines;
    }

    /// <summary>
    /// Get language identifier from file extension.
    /// </summary>
    protected static string GetLanguageFromExtension(string extension) => extension switch
    {
        ".cs" => "csharp",
        ".fs" => "fsharp",
        ".ts" or ".tsx" => "typescript",
        ".js" or ".jsx" => "javascript",
        ".py" => "python",
        ".java" => "java",
        ".go" => "go",
        ".rs" => "rust",
        ".cpp" or ".hpp" or ".c" or ".h" => "cpp",
        ".swift" => "swift",
        ".rb" => "ruby",
        ".kt" => "kotlin",
        ".php" => "php",
        _ => "unknown"
    };

    #endregion
}
```

### 2. ChunkingStrategyExtensions.cs

**Location**: `src/SeniorIntern.Services/Chunking/ChunkingStrategyExtensions.cs`

```csharp
namespace SeniorIntern.Services.Chunking;

using Microsoft.Extensions.DependencyInjection;
using SeniorIntern.Core.Interfaces;

/// <summary>
/// Extension methods for registering chunking services.
/// </summary>
public static class ChunkingStrategyExtensions
{
    /// <summary>
    /// Add all chunking services and strategies to the service collection.
    /// </summary>
    /// <param name="services">The service collection.</param>
    /// <returns>The service collection for chaining.</returns>
    /// <remarks>
    /// Registers the following:
    /// <list type="bullet">
    ///   <item>IChunkingService (singleton)</item>
    ///   <item>CodeAwareChunkingStrategy (priority 100)</item>
    ///   <item>MarkdownChunkingStrategy (priority 75)</item>
    ///   <item>PlainTextChunkingStrategy (priority 0 - fallback)</item>
    ///   <item>Language-specific strategies (priority 150+)</item>
    /// </list>
    /// </remarks>
    public static IServiceCollection AddChunkingServices(this IServiceCollection services)
    {
        // Register main chunking service
        services.AddSingleton<IChunkingService, ChunkingService>();

        // Register base strategies
        services.AddSingleton<IChunkingStrategy, CodeAwareChunkingStrategy>();
        services.AddSingleton<IChunkingStrategy, MarkdownChunkingStrategy>();
        services.AddSingleton<IChunkingStrategy, PlainTextChunkingStrategy>();

        // Register language-specific strategies (from v0.7.1g)
        services.AddSingleton<IChunkingStrategy, CSharpChunkingStrategy>();
        services.AddSingleton<IChunkingStrategy, TypeScriptChunkingStrategy>();
        services.AddSingleton<IChunkingStrategy, PythonChunkingStrategy>();

        return services;
    }

    /// <summary>
    /// Add core chunking services without language-specific strategies.
    /// </summary>
    public static IServiceCollection AddCoreChunkingServices(this IServiceCollection services)
    {
        services.AddSingleton<IChunkingService, ChunkingService>();
        services.AddSingleton<IChunkingStrategy, CodeAwareChunkingStrategy>();
        services.AddSingleton<IChunkingStrategy, PlainTextChunkingStrategy>();

        return services;
    }
}
```

---

## Supported Languages Summary

| Language | Extension(s) | Block Detection | Symbol Patterns |
|----------|--------------|-----------------|-----------------|
| C# | .cs | Brace matching | Class, Interface, Method |
| F# | .fs | Brace matching | Generic fallback |
| VB.NET | .vb | Brace matching | Generic fallback |
| TypeScript | .ts, .tsx | Brace matching | Class, Function, Arrow |
| JavaScript | .js, .jsx | Brace matching | Class, Function, Arrow |
| Python | .py | Indentation | Class, Function |
| Java | .java | Brace matching | Generic fallback |
| Kotlin | .kt | Brace matching | Generic fallback |
| Go | .go | Brace matching | Struct, Interface, Func |
| Rust | .rs | Brace matching | Struct, Trait, Fn, Impl |
| C/C++ | .c, .h, .cpp, .hpp | Brace matching | Generic fallback |
| Swift | .swift | Brace matching | Generic fallback |
| Ruby | .rb | Generic | Generic fallback |
| PHP | .php | Brace matching | Generic fallback |

---

## Unit Test Plan

| Test | Description |
|------|-------------|
| `CanHandle_SupportedExtension_ReturnsTrue` | Extension matching |
| `CanHandle_UnsupportedExtension_ReturnsFalse` | Unknown extension |
| `Chunk_SemanticMode_ExtractsSymbols` | Symbol extraction |
| `Chunk_FallbackMode_UsesLines` | Line-based fallback |
| `ExtractSymbols_CSharp_FindsClasses` | C# class pattern |
| `ExtractSymbols_CSharp_FindsMethods` | C# method pattern |
| `ExtractSymbols_TypeScript_FindsFunctions` | TS function pattern |
| `ExtractSymbols_TypeScript_FindsArrowFunctions` | Arrow function pattern |
| `ExtractSymbols_Python_FindsClasses` | Python class pattern |
| `ExtractSymbols_Python_FindsFunctions` | Python def pattern |
| `ExtractSymbols_Go_FindsStructs` | Go struct pattern |
| `ExtractSymbols_Rust_FindsFunctions` | Rust fn pattern |
| `FindMatchingBrace_SimpleBlock_FindsEnd` | Basic brace matching |
| `FindMatchingBrace_NestedBlocks_FindsCorrectEnd` | Nested brace matching |
| `FindMatchingBrace_StringLiterals_IgnoresBraces` | String handling |
| `FindPythonBlockEnd_BasicFunction_FindsEnd` | Python indentation |
| `FindPythonBlockEnd_NestedBlocks_FindsCorrectEnd` | Nested Python |
| `SplitLargeSymbol_ExceedsMax_SplitsCorrectly` | Large symbol handling |
| `ChunkInterSymbolContent_ImportsDetected` | Import detection |
| `LineBasedChunk_WithOverlap_IncludesOverlap` | Overlap calculation |

---

## File Summary

| File | Location | Purpose | Lines |
|------|----------|---------|-------|
| `CodeAwareChunkingStrategy.cs` | `Services/Chunking/` | Main strategy implementation | ~600 |
| `ChunkingStrategyExtensions.cs` | `Services/Chunking/` | DI registration | ~50 |

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | CodeAwareChunkingStrategy extracts symbols via regex |
| AC-2 | Semantic chunking by code structure works |
| AC-3 | Line-based fallback with overlap works |
| AC-4 | Brace matching for C-style languages |
| AC-5 | Indentation-based block detection for Python |
| AC-6 | Inter-symbol content handled |
| AC-7 | Large symbols split appropriately |
| AC-8 | Token estimation used for chunk sizing |

---

## Changelog Entry

```markdown
## v0.7.1f - Code-Aware Chunking Strategy

### Added
- `CodeAwareChunkingStrategy` class
  - Base implementation of ICodeChunkingStrategy
  - Priority 100 (between generic and language-specific)
  - Supports 16 file extensions across 14 languages
  - Two chunking modes: semantic and line-based
- Semantic Chunking
  - Extracts code symbols via regex patterns
  - Respects class/method/function boundaries
  - Preserves symbol metadata in chunks
  - Handles large symbols by splitting with context
- Line-Based Chunking (Fallback)
  - Chunks by line with configurable target size
  - Configurable overlap between chunks
  - Used when no symbols are extracted
- Symbol Extraction Patterns
  - C#: Class, Interface, Method
  - TypeScript/JavaScript: Class, Function, Arrow Functions
  - Python: Class, Function (def)
  - Go: Struct, Interface, Function
  - Rust: Struct, Trait, Function, Impl
  - Fallback: Generic class/function patterns
- Block Detection Algorithms
  - FindMatchingBrace(): For C-style languages
    - Handles nested braces
    - Ignores braces in string literals
    - Handles escape sequences
  - FindPythonBlockEnd(): For indentation-based languages
    - Tracks base indentation level
    - Skips empty lines and comments
    - Ends at same/lower indentation
- Inter-Symbol Content Handling
  - Detects imports, comments, top-level code
  - Creates separate chunks for gaps between symbols
- Helper Methods
  - GetLineNumber(): Character offset to line number
  - GetIndentation(): Calculate indentation level
  - CalculateOverlapLines(): For chunking overlap
  - DetectChunkType(): Classify content type
- `ChunkingStrategyExtensions` class
  - AddChunkingServices(): Full registration
  - AddCoreChunkingServices(): Minimal registration

### Language Support
| Language | Extensions | Block Detection |
|----------|------------|-----------------|
| C# | .cs | Brace |
| TypeScript | .ts, .tsx | Brace |
| JavaScript | .js, .jsx | Brace |
| Python | .py | Indentation |
| Go | .go | Brace |
| Rust | .rs | Brace |
| Java | .java | Brace |
| C/C++ | .c, .h, .cpp, .hpp | Brace |
```

---

## Design Decisions

### Why Regex-Based Symbol Extraction?

1. **No external dependencies**: Pure .NET solution
2. **Language-agnostic base**: Works for any C-style language
3. **Extensible**: Language-specific strategies can override patterns
4. **Performance**: Regex is fast for simple patterns
5. **Trade-off**: Less accurate than AST parsing, but simpler

### Why Two Chunking Modes?

1. **Semantic mode** produces higher-quality chunks for retrieval
2. **Line-based fallback** ensures all content is chunked
3. **Graceful degradation** when symbol extraction fails

### Why Overlap in Line-Based Chunking?

1. **Context preservation**: Overlapping lines provide context
2. **Better embeddings**: Overlapping chunks capture cross-boundary semantics
3. **Configurable**: `ChunkOverlap` option controls overlap size

---

## Timeline Estimate

| Version | Estimated Effort |
|---------|------------------|
| v0.7.1f | 1.0 day |
