# Design Specification: AIntern v0.7.2a "Vector Store Interface"

## Overview

**Version**: v0.7.2a
**Parent**: v0.7.2 Vector Storage
**Focus**: Define the core interface for vector storage operations

### Purpose

Define the primary interface and supporting models for vector storage operations:
1. Create `IVectorStore` interface for CRUD operations on embeddings
2. Define `ChunkWithEmbedding` model for storing chunks with their vectors
3. Define `StoredChunk` model for retrieved chunks with metadata
4. Define `ChunkStorageProgress` model for batch operation progress reporting
5. Define `VectorStoreStateChangedEventArgs` for state change events

### Dependencies

**From v0.7.1 (Embedding Foundation)**:
- `TextChunk` model (v0.7.1d)
- `ChunkType` enum (v0.7.1d)
- `SymbolType` enum (v0.7.1e)
- `ChunkingOptions` model (v0.7.1d)

**Forward references (defined in later v0.7.2 sub-versions)**:
- `VectorIndex` (v0.7.2b)
- `VectorIndexSettings` (v0.7.2b)
- `VectorSearchOptions` (v0.7.2c)
- `ChunkSearchResult` (v0.7.2c)
- `IndexedFile` (v0.7.2h)
- `FileChangeSet` (v0.7.2h)
- `IndexStatistics` (v0.7.2i)
- `VectorStoreStatistics` (v0.7.2i)

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                      v0.7.2a Vector Store Interface                          │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Interface Definition:                                                       │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  IVectorStore : IAsyncDisposable                                        │ │
│  │  ├── Properties                                                         │ │
│  │  │   └── IsInitialized                                                  │ │
│  │  │                                                                       │ │
│  │  ├── Lifecycle                                                          │ │
│  │  │   └── InitializeAsync()                                              │ │
│  │  │                                                                       │ │
│  │  ├── Index Management                                                   │ │
│  │  │   ├── CreateIndexAsync()                                             │ │
│  │  │   ├── GetIndexAsync()                                                │ │
│  │  │   ├── GetIndexForWorkspaceAsync()                                    │ │
│  │  │   ├── ListIndexesAsync()                                             │ │
│  │  │   ├── UpdateIndexAsync()                                             │ │
│  │  │   └── DeleteIndexAsync()                                             │ │
│  │  │                                                                       │ │
│  │  ├── Chunk Operations                                                   │ │
│  │  │   ├── AddChunksAsync()                                               │ │
│  │  │   ├── AddChunksBatchAsync()                                          │ │
│  │  │   ├── GetChunkAsync()                                                │ │
│  │  │   ├── RemoveChunksForFileAsync()                                     │ │
│  │  │   ├── RemoveChunksForFilesAsync()                                    │ │
│  │  │   └── ClearIndexAsync()                                              │ │
│  │  │                                                                       │ │
│  │  ├── Search Operations                                                  │ │
│  │  │   ├── SearchAsync()                                                  │ │
│  │  │   └── SearchMultipleAsync()                                          │ │
│  │  │                                                                       │ │
│  │  ├── File Tracking                                                      │ │
│  │  │   ├── GetIndexedFileAsync()                                          │ │
│  │  │   ├── GetIndexedFilesAsync()                                         │ │
│  │  │   ├── UpsertIndexedFileAsync()                                       │ │
│  │  │   ├── RemoveIndexedFileAsync()                                       │ │
│  │  │   └── DetectFileChangesAsync()                                       │ │
│  │  │                                                                       │ │
│  │  ├── Statistics                                                         │ │
│  │  │   ├── GetStatisticsAsync()                                           │ │
│  │  │   └── GetOverallStatisticsAsync()                                    │ │
│  │  │                                                                       │ │
│  │  └── Events                                                             │ │
│  │      └── StateChanged                                                   │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  Supporting Models:                                                          │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  ChunkWithEmbedding                                                     │ │
│  │  ├── Chunk: TextChunk          ← The chunk to store                     │ │
│  │  ├── Embedding: float[]        ← The embedding vector                   │ │
│  │  ├── FileId: string            ← Reference to indexed file              │ │
│  │  └── ValidateEmbeddingDimension() → Validation helper                   │ │
│  │                                                                          │ │
│  │  StoredChunk                                                            │ │
│  │  ├── Id, IndexId, FileId       ← Identifiers                            │ │
│  │  ├── Content, FilePath         ← Text content and location              │ │
│  │  ├── StartLine, EndLine        ← Line range                             │ │
│  │  ├── StartOffset, EndOffset    ← Character offsets                      │ │
│  │  ├── ChunkType, Language       ← Type metadata                          │ │
│  │  ├── SymbolName, SymbolType    ← Code symbol info                       │ │
│  │  ├── ParentSymbol              ← Parent symbol (class for method)       │ │
│  │  ├── TokenCount, IndexedAt     ← Statistics                             │ │
│  │  ├── Embedding?: float[]       ← Optional embedding                     │ │
│  │  └── ToTextChunk()             ← Conversion method                       │ │
│  │                                                                          │ │
│  │  ChunkStorageProgress                                                   │ │
│  │  ├── StoredCount, TotalCount   ← Progress counters                      │ │
│  │  ├── PercentComplete           ← Calculated percentage                  │ │
│  │  ├── Phase: ChunkStoragePhase  ← Current phase                          │ │
│  │  └── Message?: string          ← Status message                         │ │
│  │                                                                          │ │
│  │  ChunkStoragePhase (enum)                                               │ │
│  │  ├── Preparing                                                          │ │
│  │  ├── InsertingVectors                                                   │ │
│  │  ├── InsertingMetadata                                                  │ │
│  │  ├── Committing                                                         │ │
│  │  └── Complete                                                           │ │
│  │                                                                          │ │
│  │  VectorStoreStateChangedEventArgs                                       │ │
│  │  ├── IsInitialized: bool                                                │ │
│  │  ├── DatabasePath?: string                                              │ │
│  │  └── Error?: string                                                     │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Operation Categories

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                    IVectorStore Operation Categories                          │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Category          │ Methods                       │ Purpose                 │
│  ──────────────────│───────────────────────────────│──────────────────────── │
│  Lifecycle         │ InitializeAsync               │ Initialize store        │
│                    │ DisposeAsync (IAsyncDisposable)│ Clean up resources     │
│                    │                               │                         │
│  Index Management  │ CreateIndexAsync              │ Create new index        │
│                    │ GetIndexAsync                 │ Get index by ID         │
│                    │ GetIndexForWorkspaceAsync     │ Get index by workspace  │
│                    │ ListIndexesAsync              │ List all indexes        │
│                    │ UpdateIndexAsync              │ Update index metadata   │
│                    │ DeleteIndexAsync              │ Delete index + data     │
│                    │                               │                         │
│  Chunk Operations  │ AddChunksAsync                │ Add chunks to index     │
│                    │ AddChunksBatchAsync           │ Batch add with progress │
│                    │ GetChunkAsync                 │ Get chunk by ID         │
│                    │ RemoveChunksForFileAsync      │ Remove file's chunks    │
│                    │ RemoveChunksForFilesAsync     │ Remove multi-file       │
│                    │ ClearIndexAsync               │ Clear all chunks        │
│                    │                               │                         │
│  Search            │ SearchAsync                   │ Single index search     │
│                    │ SearchMultipleAsync           │ Multi-index search      │
│                    │                               │                         │
│  File Tracking     │ GetIndexedFileAsync           │ Get file status         │
│                    │ GetIndexedFilesAsync          │ List indexed files      │
│                    │ UpsertIndexedFileAsync        │ Update file record      │
│                    │ RemoveIndexedFileAsync        │ Remove file record      │
│                    │ DetectFileChangesAsync        │ Detect changes          │
│                    │                               │                         │
│  Statistics        │ GetStatisticsAsync            │ Index statistics        │
│                    │ GetOverallStatisticsAsync     │ Global statistics       │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Specifications

### 1. IVectorStore.cs

**Location**: `src/SeniorIntern.Core/Interfaces/IVectorStore.cs`

```csharp
namespace SeniorIntern.Core.Interfaces;

using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using SeniorIntern.Core.Models;

/// <summary>
/// Interface for vector storage and retrieval operations.
/// </summary>
/// <remarks>
/// <para>
/// Provides complete CRUD operations for vector indexes and similarity search capabilities.
/// The vector store manages:
/// <list type="bullet">
///   <item>Vector indexes (one per workspace)</item>
///   <item>Chunk storage with embeddings</item>
///   <item>Similarity search across stored embeddings</item>
///   <item>File tracking for incremental indexing</item>
/// </list>
/// </para>
/// <para>
/// Implementations must call <see cref="InitializeAsync"/> before any other operations.
/// The store should be disposed when no longer needed to release resources.
/// </para>
/// <para>
/// Thread safety: Implementations should be thread-safe for concurrent read operations.
/// Write operations may be serialized for consistency.
/// </para>
/// </remarks>
/// <example>
/// <code>
/// await vectorStore.InitializeAsync();
/// 
/// var index = await vectorStore.CreateIndexAsync(
///     "/path/to/workspace",
///     "My Project Index",
///     384); // embedding dimension
/// 
/// await vectorStore.AddChunksAsync(index.Id, chunksWithEmbeddings);
/// 
/// var results = await vectorStore.SearchAsync(
///     index.Id,
///     queryEmbedding,
///     new VectorSearchOptions { TopK = 10 });
/// </code>
/// </example>
public interface IVectorStore : IAsyncDisposable
{
    #region Properties

    /// <summary>
    /// Whether the vector store is initialized and ready for operations.
    /// </summary>
    /// <remarks>
    /// Returns false until <see cref="InitializeAsync"/> completes successfully.
    /// Returns false after disposal.
    /// </remarks>
    bool IsInitialized { get; }

    #endregion

    #region Lifecycle

    /// <summary>
    /// Initialize the vector store (create database, load extensions, etc.).
    /// </summary>
    /// <param name="ct">Cancellation token.</param>
    /// <remarks>
    /// Must be called before any other operations. Calling on an already-initialized
    /// store should be a no-op. Raises <see cref="StateChanged"/> on completion.
    /// </remarks>
    /// <exception cref="InvalidOperationException">If initialization fails.</exception>
    Task InitializeAsync(CancellationToken ct = default);

    #endregion

    #region Index Management

    /// <summary>
    /// Create a new vector index for a workspace.
    /// </summary>
    /// <param name="workspacePath">Absolute path to the workspace directory.</param>
    /// <param name="name">Human-readable name for the index.</param>
    /// <param name="embeddingDimension">Dimension of embedding vectors to store.</param>
    /// <param name="settings">Optional index settings.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>The created vector index.</returns>
    /// <remarks>
    /// Creates database tables/virtual tables for storing vectors.
    /// Only one index per workspace path is allowed.
    /// </remarks>
    /// <exception cref="ArgumentException">If workspace path is invalid.</exception>
    /// <exception cref="InvalidOperationException">If index already exists for workspace.</exception>
    Task<VectorIndex> CreateIndexAsync(
        string workspacePath,
        string name,
        int embeddingDimension,
        VectorIndexSettings? settings = null,
        CancellationToken ct = default);

    /// <summary>
    /// Get an existing index by its ID.
    /// </summary>
    /// <param name="indexId">The unique index identifier.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>The index if found, null otherwise.</returns>
    Task<VectorIndex?> GetIndexAsync(string indexId, CancellationToken ct = default);

    /// <summary>
    /// Get the index associated with a workspace path.
    /// </summary>
    /// <param name="workspacePath">Absolute path to the workspace directory.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>The index if found, null otherwise.</returns>
    /// <remarks>
    /// Workspace path comparison is case-insensitive on Windows, case-sensitive elsewhere.
    /// </remarks>
    Task<VectorIndex?> GetIndexForWorkspaceAsync(
        string workspacePath,
        CancellationToken ct = default);

    /// <summary>
    /// List all vector indexes.
    /// </summary>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>List of all indexes.</returns>
    Task<IReadOnlyList<VectorIndex>> ListIndexesAsync(CancellationToken ct = default);

    /// <summary>
    /// Update index metadata and settings.
    /// </summary>
    /// <param name="index">The index with updated values.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <remarks>
    /// Updates: Name, Description, Settings, Status.
    /// Does not modify: Id, WorkspacePath, EmbeddingDimension, CreatedAt.
    /// </remarks>
    /// <exception cref="ArgumentException">If index ID is invalid.</exception>
    Task UpdateIndexAsync(VectorIndex index, CancellationToken ct = default);

    /// <summary>
    /// Delete an index and all associated data.
    /// </summary>
    /// <param name="indexId">The index to delete.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <remarks>
    /// Deletes: index metadata, all chunks, all file tracking records, vector tables.
    /// This operation is irreversible.
    /// </remarks>
    Task DeleteIndexAsync(string indexId, CancellationToken ct = default);

    #endregion

    #region Chunk Operations

    /// <summary>
    /// Add chunks with their embeddings to an index.
    /// </summary>
    /// <param name="indexId">Target index ID.</param>
    /// <param name="chunks">Chunks with their embedding vectors.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <remarks>
    /// Each chunk's embedding dimension must match the index's embedding dimension.
    /// Chunks with invalid dimensions are skipped with a warning.
    /// </remarks>
    /// <exception cref="ArgumentException">If indexId is invalid.</exception>
    Task AddChunksAsync(
        string indexId,
        IEnumerable<ChunkWithEmbedding> chunks,
        CancellationToken ct = default);

    /// <summary>
    /// Add chunks in a batch with progress reporting.
    /// </summary>
    /// <param name="indexId">Target index ID.</param>
    /// <param name="chunks">Chunks with their embedding vectors.</param>
    /// <param name="progress">Optional progress reporter.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <remarks>
    /// For large chunk sets, progress is reported periodically.
    /// Uses database transactions for atomicity.
    /// </remarks>
    Task AddChunksBatchAsync(
        string indexId,
        IEnumerable<ChunkWithEmbedding> chunks,
        IProgress<ChunkStorageProgress>? progress = null,
        CancellationToken ct = default);

    /// <summary>
    /// Get a specific chunk by ID.
    /// </summary>
    /// <param name="chunkId">The chunk identifier.</param>
    /// <param name="includeEmbedding">Whether to include the embedding vector.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>The chunk if found, null otherwise.</returns>
    /// <remarks>
    /// Set includeEmbedding to false for faster retrieval when vector is not needed.
    /// </remarks>
    Task<StoredChunk?> GetChunkAsync(
        string chunkId,
        bool includeEmbedding = false,
        CancellationToken ct = default);

    /// <summary>
    /// Remove all chunks for a specific file (for re-indexing).
    /// </summary>
    /// <param name="indexId">The index containing the chunks.</param>
    /// <param name="filePath">Relative path to the file.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>Number of chunks removed.</returns>
    Task<int> RemoveChunksForFileAsync(
        string indexId,
        string filePath,
        CancellationToken ct = default);

    /// <summary>
    /// Remove all chunks for multiple files.
    /// </summary>
    /// <param name="indexId">The index containing the chunks.</param>
    /// <param name="filePaths">Relative paths to the files.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>Total number of chunks removed.</returns>
    /// <remarks>
    /// More efficient than calling RemoveChunksForFileAsync multiple times.
    /// Uses a single transaction for atomicity.
    /// </remarks>
    Task<int> RemoveChunksForFilesAsync(
        string indexId,
        IEnumerable<string> filePaths,
        CancellationToken ct = default);

    /// <summary>
    /// Clear all chunks from an index without deleting the index itself.
    /// </summary>
    /// <param name="indexId">The index to clear.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <remarks>
    /// Preserves index metadata and settings.
    /// Removes all chunks and file tracking records.
    /// </remarks>
    Task ClearIndexAsync(string indexId, CancellationToken ct = default);

    #endregion

    #region Search Operations

    /// <summary>
    /// Search for similar chunks using vector similarity.
    /// </summary>
    /// <param name="indexId">The index to search.</param>
    /// <param name="queryEmbedding">The query embedding vector.</param>
    /// <param name="options">Search options and filters.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>Ranked list of matching chunks.</returns>
    /// <remarks>
    /// Results are sorted by similarity score (descending).
    /// Filtering is applied before ranking.
    /// </remarks>
    Task<IReadOnlyList<ChunkSearchResult>> SearchAsync(
        string indexId,
        float[] queryEmbedding,
        VectorSearchOptions options,
        CancellationToken ct = default);

    /// <summary>
    /// Search across multiple indexes.
    /// </summary>
    /// <param name="indexIds">Indexes to search.</param>
    /// <param name="queryEmbedding">The query embedding vector.</param>
    /// <param name="options">Search options and filters.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>Ranked list of matching chunks from all indexes.</returns>
    /// <remarks>
    /// Results from all indexes are merged and re-ranked.
    /// TopK limit applies to the final merged results.
    /// </remarks>
    Task<IReadOnlyList<ChunkSearchResult>> SearchMultipleAsync(
        IEnumerable<string> indexIds,
        float[] queryEmbedding,
        VectorSearchOptions options,
        CancellationToken ct = default);

    #endregion

    #region File Tracking

    /// <summary>
    /// Get the indexing status of a specific file.
    /// </summary>
    /// <param name="indexId">The index to check.</param>
    /// <param name="filePath">Relative path to the file.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>File status if indexed, null otherwise.</returns>
    Task<IndexedFile?> GetIndexedFileAsync(
        string indexId,
        string filePath,
        CancellationToken ct = default);

    /// <summary>
    /// Get all indexed files for an index.
    /// </summary>
    /// <param name="indexId">The index to query.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>List of all indexed files.</returns>
    Task<IReadOnlyList<IndexedFile>> GetIndexedFilesAsync(
        string indexId,
        CancellationToken ct = default);

    /// <summary>
    /// Update or insert file indexing status.
    /// </summary>
    /// <param name="indexId">The index containing the file.</param>
    /// <param name="file">File indexing information.</param>
    /// <param name="ct">Cancellation token.</param>
    Task UpsertIndexedFileAsync(
        string indexId,
        IndexedFile file,
        CancellationToken ct = default);

    /// <summary>
    /// Remove a file tracking record.
    /// </summary>
    /// <param name="indexId">The index containing the file.</param>
    /// <param name="filePath">Relative path to the file.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <remarks>
    /// Does not remove chunks for the file. Use <see cref="RemoveChunksForFileAsync"/>
    /// in conjunction if chunks should also be removed.
    /// </remarks>
    Task RemoveIndexedFileAsync(
        string indexId,
        string filePath,
        CancellationToken ct = default);

    /// <summary>
    /// Find files that need re-indexing based on hash comparison.
    /// </summary>
    /// <param name="indexId">The index to check.</param>
    /// <param name="fileHashes">Current file paths and their content hashes.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>Files that are new, modified, or deleted.</returns>
    /// <remarks>
    /// Compares provided hashes against stored hashes to detect changes.
    /// Returns categorized lists of new, modified, and deleted files.
    /// </remarks>
    Task<FileChangeSet> DetectFileChangesAsync(
        string indexId,
        IReadOnlyDictionary<string, string> fileHashes,
        CancellationToken ct = default);

    #endregion

    #region Statistics

    /// <summary>
    /// Get statistics for a specific index.
    /// </summary>
    /// <param name="indexId">The index to analyze.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>Index statistics.</returns>
    Task<IndexStatistics> GetStatisticsAsync(
        string indexId,
        CancellationToken ct = default);

    /// <summary>
    /// Get overall vector store statistics.
    /// </summary>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>Aggregate statistics for all indexes.</returns>
    Task<VectorStoreStatistics> GetOverallStatisticsAsync(CancellationToken ct = default);

    #endregion

    #region Events

    /// <summary>
    /// Event raised when store state changes (initialization, errors, etc.).
    /// </summary>
    event EventHandler<VectorStoreStateChangedEventArgs>? StateChanged;

    #endregion
}
```

### 2. ChunkWithEmbedding.cs

**Location**: `src/SeniorIntern.Core/Models/ChunkWithEmbedding.cs`

```csharp
namespace SeniorIntern.Core.Models;

using System;

/// <summary>
/// A text chunk paired with its embedding vector for storage.
/// </summary>
/// <remarks>
/// <para>
/// This is the primary input type for adding chunks to a vector store.
/// It combines:
/// <list type="bullet">
///   <item>The text chunk with all its metadata</item>
///   <item>The embedding vector generated by an embedding model</item>
///   <item>A reference to the source file record</item>
/// </list>
/// </para>
/// <para>
/// The embedding dimension must match the index's expected dimension.
/// Use <see cref="ValidateEmbeddingDimension"/> to verify before storage.
/// </para>
/// </remarks>
/// <example>
/// <code>
/// var chunk = new ChunkWithEmbedding
/// {
///     Chunk = textChunk,
///     Embedding = embeddingService.Embed(textChunk.Content),
///     FileId = indexedFile.Id
/// };
/// 
/// if (chunk.ValidateEmbeddingDimension(384))
///     await vectorStore.AddChunksAsync(indexId, new[] { chunk });
/// </code>
/// </example>
public sealed class ChunkWithEmbedding
{
    /// <summary>
    /// The text chunk with metadata.
    /// </summary>
    /// <remarks>
    /// Contains content, file path, line ranges, symbol information, etc.
    /// </remarks>
    public required TextChunk Chunk { get; init; }

    /// <summary>
    /// The embedding vector for the chunk content.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Must be normalized for cosine similarity searches.
    /// Length must match the target index's embedding dimension.
    /// </para>
    /// <para>
    /// Common dimensions:
    /// <list type="bullet">
    ///   <item>384 - all-MiniLM-L6-v2, BGE-small</item>
    ///   <item>768 - BERT base, BGE-base</item>
    ///   <item>1024 - BGE-large, E5-large</item>
    ///   <item>1536 - OpenAI ada-002</item>
    /// </list>
    /// </para>
    /// </remarks>
    public required float[] Embedding { get; init; }

    /// <summary>
    /// ID of the indexed file this chunk belongs to.
    /// </summary>
    /// <remarks>
    /// References the file record in the indexed_files table.
    /// Used for efficient file-based chunk removal during re-indexing.
    /// </remarks>
    public required string FileId { get; init; }

    /// <summary>
    /// Validates that the embedding has the expected dimension.
    /// </summary>
    /// <param name="expectedDimension">Expected embedding dimension.</param>
    /// <returns>True if valid, false otherwise.</returns>
    public bool ValidateEmbeddingDimension(int expectedDimension)
    {
        return Embedding.Length == expectedDimension;
    }

    /// <summary>
    /// Get the embedding as a ReadOnlySpan for efficient processing.
    /// </summary>
    public ReadOnlySpan<float> EmbeddingSpan => Embedding.AsSpan();
}
```

### 3. StoredChunk.cs

**Location**: `src/SeniorIntern.Core/Models/StoredChunk.cs`

```csharp
namespace SeniorIntern.Core.Models;

using System;

/// <summary>
/// A chunk as stored in the vector database, with optional embedding.
/// </summary>
/// <remarks>
/// <para>
/// This is the primary output type when retrieving chunks from the vector store.
/// It contains all chunk metadata and optionally the embedding vector.
/// </para>
/// <para>
/// By default, embeddings are not included to reduce data transfer.
/// Request embeddings only when needed (e.g., for re-ranking or analysis).
/// </para>
/// </remarks>
public sealed class StoredChunk
{
    #region Identifiers

    /// <summary>
    /// Unique identifier for this chunk.
    /// </summary>
    public required string Id { get; init; }

    /// <summary>
    /// ID of the index containing this chunk.
    /// </summary>
    public required string IndexId { get; init; }

    /// <summary>
    /// ID of the indexed file this chunk belongs to.
    /// </summary>
    public required string FileId { get; init; }

    #endregion

    #region Content

    /// <summary>
    /// The actual text content.
    /// </summary>
    public required string Content { get; init; }

    /// <summary>
    /// Relative file path within the workspace.
    /// </summary>
    public required string FilePath { get; init; }

    #endregion

    #region Position

    /// <summary>
    /// Starting line number (1-based).
    /// </summary>
    public int StartLine { get; init; }

    /// <summary>
    /// Ending line number (1-based).
    /// </summary>
    public int EndLine { get; init; }

    /// <summary>
    /// Character offset from start of file.
    /// </summary>
    public int StartOffset { get; init; }

    /// <summary>
    /// End character offset.
    /// </summary>
    public int EndOffset { get; init; }

    #endregion

    #region Metadata

    /// <summary>
    /// Type of chunk content.
    /// </summary>
    public ChunkType ChunkType { get; init; }

    /// <summary>
    /// Programming language (if applicable).
    /// </summary>
    public string? Language { get; init; }

    /// <summary>
    /// Symbol name if chunk represents a specific symbol.
    /// </summary>
    public string? SymbolName { get; init; }

    /// <summary>
    /// Type of symbol (class, method, etc.).
    /// </summary>
    public SymbolType? SymbolType { get; init; }

    /// <summary>
    /// Parent symbol name (e.g., class containing a method).
    /// </summary>
    public string? ParentSymbol { get; init; }

    #endregion

    #region Statistics

    /// <summary>
    /// Approximate token count of the content.
    /// </summary>
    public int TokenCount { get; init; }

    /// <summary>
    /// When this chunk was indexed.
    /// </summary>
    public DateTime IndexedAt { get; init; }

    #endregion

    #region Embedding

    /// <summary>
    /// The embedding vector (only populated if requested).
    /// </summary>
    /// <remarks>
    /// Null by default to reduce memory usage.
    /// Set includeEmbedding=true in retrieval methods to populate.
    /// </remarks>
    public float[]? Embedding { get; init; }

    #endregion

    #region Conversion

    /// <summary>
    /// Convert to TextChunk model.
    /// </summary>
    /// <returns>A TextChunk with copied properties.</returns>
    public TextChunk ToTextChunk()
    {
        return new TextChunk
        {
            Id = Guid.Parse(Id),
            Content = Content,
            FilePath = FilePath,
            StartLine = StartLine,
            EndLine = EndLine,
            StartOffset = StartOffset,
            EndOffset = EndOffset,
            Type = ChunkType,
            Language = Language,
            SymbolName = SymbolName,
            SymbolType = SymbolType,
            ParentSymbol = ParentSymbol,
            TokenCount = TokenCount
        };
    }

    #endregion
}
```

### 4. ChunkStorageProgress.cs

**Location**: `src/SeniorIntern.Core/Models/ChunkStorageProgress.cs`

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Progress information for chunk storage operations.
/// </summary>
/// <remarks>
/// Reported periodically during batch chunk storage operations.
/// Use with <see cref="IProgress{T}"/> for UI updates.
/// </remarks>
public sealed class ChunkStorageProgress
{
    /// <summary>
    /// Number of chunks stored so far.
    /// </summary>
    public int StoredCount { get; init; }

    /// <summary>
    /// Total number of chunks to store.
    /// </summary>
    public int TotalCount { get; init; }

    /// <summary>
    /// Percentage complete (0-100).
    /// </summary>
    public double PercentComplete => TotalCount > 0
        ? (double)StoredCount / TotalCount * 100
        : 0;

    /// <summary>
    /// Current operation phase.
    /// </summary>
    public ChunkStoragePhase Phase { get; init; }

    /// <summary>
    /// Optional message describing current operation.
    /// </summary>
    public string? Message { get; init; }

    /// <summary>
    /// Create progress for a specific count.
    /// </summary>
    public static ChunkStorageProgress Create(
        int stored,
        int total,
        ChunkStoragePhase phase,
        string? message = null)
    {
        return new ChunkStorageProgress
        {
            StoredCount = stored,
            TotalCount = total,
            Phase = phase,
            Message = message
        };
    }
}

/// <summary>
/// Phases of chunk storage operations.
/// </summary>
public enum ChunkStoragePhase
{
    /// <summary>
    /// Preparing data for storage.
    /// </summary>
    /// <remarks>
    /// Includes: validating embeddings, batching data.
    /// </remarks>
    Preparing,

    /// <summary>
    /// Inserting vectors into database.
    /// </summary>
    /// <remarks>
    /// Writing embedding vectors to the vector virtual table.
    /// </remarks>
    InsertingVectors,

    /// <summary>
    /// Inserting chunk metadata.
    /// </summary>
    /// <remarks>
    /// Writing chunk content and metadata to the chunks table.
    /// </remarks>
    InsertingMetadata,

    /// <summary>
    /// Committing transaction.
    /// </summary>
    /// <remarks>
    /// Finalizing the database transaction.
    /// </remarks>
    Committing,

    /// <summary>
    /// Operation complete.
    /// </summary>
    Complete
}
```

### 5. VectorStoreStateChangedEventArgs.cs

**Location**: `src/SeniorIntern.Core/Models/VectorStoreStateChangedEventArgs.cs`

```csharp
namespace SeniorIntern.Core.Models;

using System;

/// <summary>
/// Event arguments for vector store state changes.
/// </summary>
/// <remarks>
/// Raised when:
/// <list type="bullet">
///   <item>The store is initialized successfully</item>
///   <item>The store encounters an error</item>
///   <item>The store is disposed</item>
/// </list>
/// </remarks>
public sealed class VectorStoreStateChangedEventArgs : EventArgs
{
    /// <summary>
    /// Whether the store is currently initialized and ready.
    /// </summary>
    public bool IsInitialized { get; init; }

    /// <summary>
    /// Path to the database file (if applicable).
    /// </summary>
    public string? DatabasePath { get; init; }

    /// <summary>
    /// Error message if something went wrong.
    /// </summary>
    public string? Error { get; init; }

    /// <summary>
    /// Type of state change that occurred.
    /// </summary>
    public VectorStoreStateChange ChangeType { get; init; }

    /// <summary>
    /// Create an "initialized" event.
    /// </summary>
    public static VectorStoreStateChangedEventArgs Initialized(string databasePath)
    {
        return new VectorStoreStateChangedEventArgs
        {
            IsInitialized = true,
            DatabasePath = databasePath,
            ChangeType = VectorStoreStateChange.Initialized
        };
    }

    /// <summary>
    /// Create an "error" event.
    /// </summary>
    public static VectorStoreStateChangedEventArgs ErrorOccurred(string error, string? databasePath = null)
    {
        return new VectorStoreStateChangedEventArgs
        {
            IsInitialized = false,
            DatabasePath = databasePath,
            Error = error,
            ChangeType = VectorStoreStateChange.Error
        };
    }

    /// <summary>
    /// Create a "disposed" event.
    /// </summary>
    public static VectorStoreStateChangedEventArgs Disposed()
    {
        return new VectorStoreStateChangedEventArgs
        {
            IsInitialized = false,
            ChangeType = VectorStoreStateChange.Disposed
        };
    }
}

/// <summary>
/// Types of vector store state changes.
/// </summary>
public enum VectorStoreStateChange
{
    /// <summary>
    /// Store was successfully initialized.
    /// </summary>
    Initialized,

    /// <summary>
    /// Store encountered an error.
    /// </summary>
    Error,

    /// <summary>
    /// Store was disposed.
    /// </summary>
    Disposed
}
```

---

## Placeholder Interfaces

For v0.7.2a to compile, we need forward declarations for types defined in later sub-versions. These can be initially defined as placeholder interfaces/classes:

```csharp
// Placeholders for v0.7.2b
public sealed class VectorIndex { /* defined in v0.7.2b */ }
public sealed class VectorIndexSettings { /* defined in v0.7.2b */ }

// Placeholders for v0.7.2c
public sealed class VectorSearchOptions { /* defined in v0.7.2c */ }
public sealed class ChunkSearchResult { /* defined in v0.7.2c */ }

// Placeholders for v0.7.2h
public sealed class IndexedFile { /* defined in v0.7.2h */ }
public sealed class FileChangeSet { /* defined in v0.7.2h */ }

// Placeholders for v0.7.2i
public sealed class IndexStatistics { /* defined in v0.7.2i */ }
public sealed class VectorStoreStatistics { /* defined in v0.7.2i */ }
```

---

## Unit Test Plan

| Test | Description |
|------|-------------|
| `ChunkWithEmbedding_ValidateEmbeddingDimension_MatchingDimension_ReturnsTrue` | Validation passes |
| `ChunkWithEmbedding_ValidateEmbeddingDimension_MismatchedDimension_ReturnsFalse` | Validation fails |
| `StoredChunk_ToTextChunk_CopiesAllProperties` | Conversion works |
| `StoredChunk_ToTextChunk_HandlesNullOptionalProperties` | Nullable handling |
| `ChunkStorageProgress_PercentComplete_CalculatesCorrectly` | 50/100 = 50% |
| `ChunkStorageProgress_PercentComplete_ZeroTotal_ReturnsZero` | Division by zero |
| `ChunkStorageProgress_Create_Factory_SetsAllProperties` | Factory method |
| `VectorStoreStateChangedEventArgs_Initialized_CreatesCorrectEvent` | Factory |
| `VectorStoreStateChangedEventArgs_ErrorOccurred_CreatesCorrectEvent` | Factory |
| `VectorStoreStateChangedEventArgs_Disposed_CreatesCorrectEvent` | Factory |

---

## File Summary

| File | Location | Purpose | Lines |
|------|----------|---------|-------|
| `IVectorStore.cs` | `Core/Interfaces/` | Vector store interface | ~350 |
| `ChunkWithEmbedding.cs` | `Core/Models/` | Storage input model | ~60 |
| `StoredChunk.cs` | `Core/Models/` | Retrieved chunk model | ~120 |
| `ChunkStorageProgress.cs` | `Core/Models/` | Progress reporting | ~80 |
| `VectorStoreStateChangedEventArgs.cs` | `Core/Models/` | State change events | ~80 |

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | `IVectorStore` interface compiles and can be implemented |
| AC-2 | All interface methods have XML documentation |
| AC-3 | `ChunkWithEmbedding.ValidateEmbeddingDimension()` works correctly |
| AC-4 | `StoredChunk.ToTextChunk()` converts all properties |
| AC-5 | `ChunkStorageProgress.PercentComplete` calculates correctly |
| AC-6 | `VectorStoreStateChangedEventArgs` factory methods create correct events |
| AC-7 | Event args include all necessary state information |

---

## Changelog Entry

```markdown
## v0.7.2a - Vector Store Interface

### Added
- `IVectorStore` interface (`Core/Interfaces/`)
  - Lifecycle: InitializeAsync, DisposeAsync
  - Index Management: Create/Get/List/Update/Delete
  - Chunk Operations: Add/Get/Remove chunks
  - Search: SearchAsync, SearchMultipleAsync
  - File Tracking: GetIndexedFile, DetectFileChanges
  - Statistics: GetStatistics, GetOverallStatistics
  - Events: StateChanged
- `ChunkWithEmbedding` model (`Core/Models/`)
  - TextChunk + float[] Embedding
  - FileId reference
  - ValidateEmbeddingDimension() helper
- `StoredChunk` model (`Core/Models/`)
  - Complete chunk data with optional embedding
  - ToTextChunk() conversion method
- `ChunkStorageProgress` model (`Core/Models/`)
  - StoredCount, TotalCount, PercentComplete
  - Phase enumeration
- `ChunkStoragePhase` enum
  - Preparing, InsertingVectors, InsertingMetadata, Committing, Complete
- `VectorStoreStateChangedEventArgs` (`Core/Models/`)
  - IsInitialized, DatabasePath, Error
  - Static factory methods
- `VectorStoreStateChange` enum
  - Initialized, Error, Disposed

### Interface Design Decisions
- IAsyncDisposable for proper resource cleanup
- Separate methods for single/batch operations
- Optional embedding in StoredChunk to reduce memory
- Progress reporting via IProgress<T>
- Event-based state notification
```

---

## Timeline Estimate

| Version | Estimated Effort |
|---------|------------------|
| v0.7.2a | 0.5 day |
