# Design Specification: AIntern v0.7.1e "Chunking Service Interface"

## Overview

**Version**: v0.7.1e
**Parent**: v0.7.1 Embedding Foundation
**Focus**: Define interfaces for chunking service and chunking strategies

### Purpose

Define the core interfaces and service implementation for text chunking:
1. Create `IChunkingService` interface for document chunking orchestration
2. Define `IChunkingStrategy` interface for extensible chunking algorithms
3. Define `ICodeChunkingStrategy` for language-aware symbol extraction
4. Create `CodeSymbol` and `ParameterInfo` models for code structure
5. Implement `ChunkingService` to orchestrate strategies
6. Support language detection, preprocessing, and token estimation

### Dependencies

**From v0.7.1d (Text Chunk Models)**:
- `TextChunk` model
- `ChunkType` enum
- `SymbolType` enum
- `ChunkingOptions` class
- `ChunkPreprocessing` class

**From v0.7.1i (Tokenization Utilities)**:
- `ITokenizerService` (optional dependency)

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                    v0.7.1e Chunking Service Architecture                      │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Interface Hierarchy:                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  IChunkingService (orchestrator)                                        │ │
│  │  ├── ChunkDocument(content, path, options): TextChunk[]                 │ │
│  │  ├── ChunkDocumentAsync(content, path, options, ct): Task<TextChunk[]>  │ │
│  │  ├── GetStrategy(filePath): IChunkingStrategy                           │ │
│  │  ├── DetectLanguage(filePath): string?                                  │ │
│  │  ├── IsSupported(filePath): bool                                        │ │
│  │  ├── Preprocess(content, options): string                               │ │
│  │  └── EstimateTokenCount(text): int                                      │ │
│  │                                                                          │ │
│  │  IChunkingStrategy (base strategy)                                      │ │
│  │  ├── Name: string                                                       │ │
│  │  ├── SupportedExtensions: IReadOnlySet<string>                          │ │
│  │  ├── Priority: int                                                      │ │
│  │  ├── CanHandle(filePath): bool                                          │ │
│  │  └── Chunk(content, path, options): TextChunk[]                         │ │
│  │             │                                                            │ │
│  │             └── ICodeChunkingStrategy (extends base)                    │ │
│  │                 └── ExtractSymbols(content, path): CodeSymbol[]         │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  ChunkingService Implementation:                                             │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                          │ │
│  │  ChunkingService : IChunkingService                                     │ │
│  │  ├── _logger: ILogger<ChunkingService>                                  │ │
│  │  ├── _strategies: IEnumerable<IChunkingStrategy>                        │ │
│  │  ├── _tokenizer: ITokenizerService? (optional)                          │ │
│  │  ├── _extensionToLanguage: Dictionary<string, string>                   │ │
│  │  │                                                                       │ │
│  │  Strategy Selection:                                                     │ │
│  │  ├── Strategies ordered by Priority (descending)                        │ │
│  │  ├── First matching strategy (CanHandle) is used                        │ │
│  │  └── Falls back to "PlainText" strategy if none match                   │ │
│  │                                                                          │ │
│  │  Preprocessing Pipeline:                                                 │ │
│  │  ├── NormalizeWhitespace (tabs → spaces, CRLF → LF)                     │ │
│  │  ├── RemoveLicenseHeaders (regex-based detection)                       │ │
│  │  ├── TrimLines (trailing whitespace)                                    │ │
│  │  ├── CollapseMultipleNewlines (configurable max)                        │ │
│  │  └── RemoveEmptyLines (optional)                                        │ │
│  │                                                                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Language Detection Mapping

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                      Extension to Language Mapping                            │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Category         │ Extensions               │ Language ID                  │
│  ─────────────────│──────────────────────────│──────────────────────────── │
│  .NET             │ .cs                      │ csharp                       │
│                   │ .fs                      │ fsharp                       │
│                   │ .vb                      │ vb                           │
│  ─────────────────│──────────────────────────│──────────────────────────── │
│  JavaScript/TS    │ .ts, .tsx                │ typescript                   │
│                   │ .js, .jsx, .mjs          │ javascript                   │
│  ─────────────────│──────────────────────────│──────────────────────────── │
│  Python           │ .py, .pyi                │ python                       │
│  ─────────────────│──────────────────────────│──────────────────────────── │
│  JVM              │ .java                    │ java                         │
│                   │ .kt                      │ kotlin                       │
│                   │ .scala                   │ scala                        │
│  ─────────────────│──────────────────────────│──────────────────────────── │
│  Systems          │ .go                      │ go                           │
│                   │ .rs                      │ rust                         │
│                   │ .c, .h                   │ c                            │
│                   │ .cpp, .hpp, .cc          │ cpp                          │
│  ─────────────────│──────────────────────────│──────────────────────────── │
│  Other Languages  │ .swift                   │ swift                        │
│                   │ .rb                      │ ruby                         │
│                   │ .php                     │ php                          │
│                   │ .lua                     │ lua                          │
│                   │ .r                       │ r                            │
│                   │ .jl                      │ julia                        │
│  ─────────────────│──────────────────────────│──────────────────────────── │
│  Markup/Config    │ .md, .markdown           │ markdown                     │
│                   │ .json                    │ json                         │
│                   │ .yaml, .yml              │ yaml                         │
│                   │ .xml                     │ xml                          │
│                   │ .html, .htm              │ html                         │
│                   │ .css, .scss, .sass       │ css/scss/sass                │
│  ─────────────────│──────────────────────────│──────────────────────────── │
│  Shell            │ .sh, .bash               │ bash                         │
│                   │ .zsh                     │ zsh                          │
│                   │ .ps1                     │ powershell                   │
│  ─────────────────│──────────────────────────│──────────────────────────── │
│  Other            │ .sql                     │ sql                          │
│                   │ .txt                     │ text                         │
│                   │ .rst                     │ rst                          │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Preprocessing Pipeline

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                        Preprocessing Pipeline Flow                            │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Input: Raw file content                                                     │
│                                                                              │
│  Step 1: Normalize Whitespace (if enabled)                                   │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  • Replace tabs with 4 spaces                                            │ │
│  │  • Convert \r\n to \n (Windows → Unix line endings)                      │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                               ↓                                              │
│  Step 2: Remove License Headers (if enabled)                                 │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  Pattern 1: /* ... license|copyright ... */                              │ │
│  │  Pattern 2: // license|copyright lines                                   │ │
│  │  Pattern 3: # license|copyright lines (Python/Shell)                     │ │
│  │  Only removes if at start of file (index 0)                              │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                               ↓                                              │
│  Step 3: Trim Lines (if enabled)                                             │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  • Remove trailing whitespace from each line                             │ │
│  │  • Preserves leading whitespace (indentation)                            │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                               ↓                                              │
│  Step 4: Collapse Multiple Newlines (if enabled)                             │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  • Replace N+ consecutive newlines with max N                            │ │
│  │  • MaxConsecutiveEmptyLines + 1 = max newlines                          │ │
│  │  • Default: max 3 newlines (2 empty lines)                               │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                               ↓                                              │
│  Step 5: Remove Empty Lines (if enabled)                                     │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  • Remove all lines that are empty or whitespace-only                    │ │
│  │  • Generally NOT recommended for code                                    │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                               ↓                                              │
│  Output: Preprocessed content ready for chunking                             │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## File Specifications

### 1. IChunkingService.cs

**Location**: `src/SeniorIntern.Core/Interfaces/IChunkingService.cs`

```csharp
namespace SeniorIntern.Core.Interfaces;

using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using SeniorIntern.Core.Models;

/// <summary>
/// Service for chunking text and code into embeddable segments.
/// </summary>
/// <remarks>
/// <para>
/// The chunking service orchestrates different chunking strategies to convert
/// documents into appropriately-sized text chunks for embedding and retrieval.
/// </para>
/// <para>
/// Key responsibilities:
/// <list type="bullet">
///   <item>Strategy selection based on file type</item>
///   <item>Language detection from file extensions</item>
///   <item>Content preprocessing (whitespace normalization, license removal)</item>
///   <item>Token count estimation for chunk sizing</item>
/// </list>
/// </para>
/// </remarks>
/// <example>
/// <code>
/// var chunks = chunkingService.ChunkDocument(
///     content: fileContent,
///     filePath: "src/MyClass.cs",
///     options: new ChunkingOptions { TargetChunkSize = 512 });
/// </code>
/// </example>
public interface IChunkingService
{
    /// <summary>
    /// Chunk a document into segments based on content type and options.
    /// </summary>
    /// <param name="content">The document content to chunk.</param>
    /// <param name="filePath">Path to the source file (used for language detection).</param>
    /// <param name="options">Chunking configuration.</param>
    /// <returns>List of text chunks with comprehensive metadata.</returns>
    /// <exception cref="ArgumentNullException">
    /// Thrown when <paramref name="content"/> or <paramref name="filePath"/> is null.
    /// </exception>
    /// <exception cref="InvalidOperationException">
    /// Thrown when no suitable chunking strategy is found.
    /// </exception>
    IReadOnlyList<TextChunk> ChunkDocument(
        string content,
        string filePath,
        ChunkingOptions options);

    /// <summary>
    /// Chunk a document asynchronously (for large files or background processing).
    /// </summary>
    /// <param name="content">The document content to chunk.</param>
    /// <param name="filePath">Path to the source file.</param>
    /// <param name="options">Chunking configuration.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>List of text chunks.</returns>
    Task<IReadOnlyList<TextChunk>> ChunkDocumentAsync(
        string content,
        string filePath,
        ChunkingOptions options,
        CancellationToken ct = default);

    /// <summary>
    /// Get the appropriate chunking strategy for a file type.
    /// </summary>
    /// <param name="filePath">File path or filename with extension.</param>
    /// <returns>The best matching chunking strategy.</returns>
    /// <remarks>
    /// Strategies are evaluated in priority order (highest first).
    /// Falls back to the "PlainText" strategy if no specific strategy matches.
    /// </remarks>
    IChunkingStrategy GetStrategy(string filePath);

    /// <summary>
    /// Get the detected language identifier for a file.
    /// </summary>
    /// <param name="filePath">File path or filename with extension.</param>
    /// <returns>
    /// Language identifier (e.g., "csharp", "python", "javascript"),
    /// or null if the extension is not recognized.
    /// </returns>
    string? DetectLanguage(string filePath);

    /// <summary>
    /// Check if a file type is supported for chunking.
    /// </summary>
    /// <param name="filePath">File path or filename with extension.</param>
    /// <returns>True if any registered strategy can handle this file type.</returns>
    bool IsSupported(string filePath);

    /// <summary>
    /// Preprocess text content according to preprocessing options.
    /// </summary>
    /// <param name="content">The raw content to preprocess.</param>
    /// <param name="options">Preprocessing configuration.</param>
    /// <returns>Preprocessed content ready for chunking.</returns>
    string Preprocess(string content, ChunkPreprocessing options);

    /// <summary>
    /// Estimate the token count for text.
    /// </summary>
    /// <param name="text">The text to estimate.</param>
    /// <returns>
    /// Approximate token count. Uses the tokenizer service if available,
    /// otherwise falls back to a character-based heuristic.
    /// </returns>
    int EstimateTokenCount(string text);
}
```

### 2. IChunkingStrategy.cs

**Location**: `src/SeniorIntern.Core/Interfaces/IChunkingStrategy.cs`

```csharp
namespace SeniorIntern.Core.Interfaces;

using System.Collections.Generic;
using SeniorIntern.Core.Models;

/// <summary>
/// Strategy for chunking specific types of content.
/// </summary>
/// <remarks>
/// <para>
/// Implement this interface to create a custom chunking strategy for a specific
/// file type or content category. Strategies are selected based on file extension
/// matching and priority ordering.
/// </para>
/// <para>
/// Example implementations:
/// <list type="bullet">
///   <item>CodeAwareChunkingStrategy - Respects code structure (classes, methods)</item>
///   <item>MarkdownChunkingStrategy - Chunked by headers and sections</item>
///   <item>PlainTextChunkingStrategy - Simple line/paragraph-based chunking</item>
/// </list>
/// </para>
/// </remarks>
public interface IChunkingStrategy
{
    /// <summary>
    /// Name of this strategy (for logging and debugging).
    /// </summary>
    /// <example>"CodeAware", "Markdown", "PlainText"</example>
    string Name { get; }

    /// <summary>
    /// File extensions this strategy can handle (lowercase, including dot).
    /// </summary>
    /// <example>{ ".cs", ".vb", ".fs" }</example>
    IReadOnlySet<string> SupportedExtensions { get; }

    /// <summary>
    /// Priority when multiple strategies could handle a file.
    /// Higher values = higher priority.
    /// </summary>
    /// <remarks>
    /// Recommended priority ranges:
    /// <list type="bullet">
    ///   <item>0-49: Fallback strategies (PlainText)</item>
    ///   <item>50-99: General strategies (Markdown, Config)</item>
    ///   <item>100-199: Language-specific strategies (CSharp, Python)</item>
    ///   <item>200+: Highly specialized strategies</item>
    /// </list>
    /// </remarks>
    int Priority { get; }

    /// <summary>
    /// Check if this strategy can handle the given file.
    /// </summary>
    /// <param name="filePath">File path or filename with extension.</param>
    /// <returns>True if this strategy can chunk the file.</returns>
    /// <remarks>
    /// Default implementation checks if the file extension is in
    /// <see cref="SupportedExtensions"/>. Override for more complex logic.
    /// </remarks>
    bool CanHandle(string filePath);

    /// <summary>
    /// Chunk content using this strategy.
    /// </summary>
    /// <param name="content">The preprocessed content to chunk.</param>
    /// <param name="filePath">Source file path (for metadata).</param>
    /// <param name="options">Chunking options.</param>
    /// <returns>List of text chunks in document order.</returns>
    IReadOnlyList<TextChunk> Chunk(
        string content,
        string filePath,
        ChunkingOptions options);
}

/// <summary>
/// Extended strategy interface that supports code structure analysis.
/// </summary>
/// <remarks>
/// Implement this interface for strategies that can extract semantic
/// information about code symbols (classes, methods, functions, etc.).
/// </remarks>
public interface ICodeChunkingStrategy : IChunkingStrategy
{
    /// <summary>
    /// Extract code symbols from content.
    /// </summary>
    /// <param name="content">The source code content.</param>
    /// <param name="filePath">Source file path.</param>
    /// <returns>
    /// List of code symbols with location and metadata.
    /// Symbols are typically extracted using regex or lightweight parsing.
    /// </returns>
    IReadOnlyList<CodeSymbol> ExtractSymbols(string content, string filePath);
}

/// <summary>
/// Represents a code symbol extracted from source.
/// </summary>
/// <remarks>
/// Captures structural information about code elements for semantic chunking.
/// </remarks>
public sealed class CodeSymbol
{
    /// <summary>
    /// Symbol name (identifier).
    /// </summary>
    /// <example>"MyClass", "ProcessData", "userId"</example>
    public string Name { get; init; } = string.Empty;

    /// <summary>
    /// Type of symbol.
    /// </summary>
    public SymbolType Type { get; init; }

    /// <summary>
    /// Fully qualified name including namespace/class hierarchy.
    /// </summary>
    /// <example>"MyApp.Services.DataService.ProcessData"</example>
    public string? QualifiedName { get; init; }

    /// <summary>
    /// Parent symbol name (containing class, namespace, etc.).
    /// </summary>
    /// <example>"DataService" for a method in the DataService class</example>
    public string? Parent { get; init; }

    /// <summary>
    /// Namespace containing this symbol.
    /// </summary>
    /// <example>"MyApp.Services"</example>
    public string? Namespace { get; init; }

    /// <summary>
    /// Start line number (1-based).
    /// </summary>
    public int StartLine { get; init; }

    /// <summary>
    /// End line number (1-based, inclusive).
    /// </summary>
    public int EndLine { get; init; }

    /// <summary>
    /// Character offset from start of file.
    /// </summary>
    public int StartOffset { get; init; }

    /// <summary>
    /// Character length of this symbol.
    /// </summary>
    public int Length { get; init; }

    /// <summary>
    /// Documentation comment or docstring if available.
    /// </summary>
    public string? Documentation { get; init; }

    /// <summary>
    /// Access modifier (public, private, protected, internal).
    /// </summary>
    public string? AccessModifier { get; init; }

    /// <summary>
    /// Return type for methods and functions.
    /// </summary>
    public string? ReturnType { get; init; }

    /// <summary>
    /// Parameters for methods and functions.
    /// </summary>
    public IReadOnlyList<ParameterInfo>? Parameters { get; init; }

    /// <summary>
    /// Number of lines in this symbol.
    /// </summary>
    public int LineCount => EndLine - StartLine + 1;

    /// <summary>
    /// Create a signature string for display.
    /// </summary>
    public string SignatureDisplay
    {
        get
        {
            if (Type is SymbolType.Method or SymbolType.Function or SymbolType.Constructor)
            {
                var parameters = Parameters is not null
                    ? string.Join(", ", Parameters.Select(p => $"{p.Type} {p.Name}"))
                    : "";
                var returnPart = ReturnType is not null ? $": {ReturnType}" : "";
                return $"{Name}({parameters}){returnPart}";
            }
            return Name;
        }
    }
}

/// <summary>
/// Parameter information for methods and functions.
/// </summary>
public sealed class ParameterInfo
{
    /// <summary>
    /// Parameter name.
    /// </summary>
    public string Name { get; init; } = string.Empty;

    /// <summary>
    /// Parameter type (language-specific).
    /// </summary>
    public string? Type { get; init; }

    /// <summary>
    /// Default value if specified.
    /// </summary>
    public string? DefaultValue { get; init; }

    /// <summary>
    /// Whether this is an optional parameter.
    /// </summary>
    public bool IsOptional => DefaultValue is not null;
}
```

### 3. ChunkingService.cs

**Location**: `src/SeniorIntern.Services/Chunking/ChunkingService.cs`

```csharp
namespace SeniorIntern.Services.Chunking;

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;

/// <summary>
/// Main chunking service that orchestrates different chunking strategies.
/// </summary>
/// <remarks>
/// <para>
/// The ChunkingService is the primary entry point for document chunking.
/// It manages strategy selection, preprocessing, and delegates to the
/// appropriate strategy for the actual chunking work.
/// </para>
/// <para>
/// Strategies are selected based on file extension and priority. The
/// highest-priority strategy that can handle a file type is used.
/// </para>
/// </remarks>
public sealed class ChunkingService : IChunkingService
{
    private readonly ILogger<ChunkingService> _logger;
    private readonly IReadOnlyList<IChunkingStrategy> _strategies;
    private readonly ITokenizerService? _tokenizer;

    /// <summary>
    /// Mapping of file extensions to language identifiers.
    /// </summary>
    private static readonly Dictionary<string, string> _extensionToLanguage =
        new(StringComparer.OrdinalIgnoreCase)
    {
        // .NET
        [".cs"] = "csharp",
        [".fs"] = "fsharp",
        [".vb"] = "vb",

        // JavaScript/TypeScript
        [".ts"] = "typescript",
        [".tsx"] = "typescript",
        [".js"] = "javascript",
        [".jsx"] = "javascript",
        [".mjs"] = "javascript",

        // Python
        [".py"] = "python",
        [".pyi"] = "python",

        // JVM
        [".java"] = "java",
        [".kt"] = "kotlin",
        [".scala"] = "scala",

        // Systems
        [".go"] = "go",
        [".rs"] = "rust",
        [".c"] = "c",
        [".h"] = "c",
        [".cpp"] = "cpp",
        [".hpp"] = "cpp",
        [".cc"] = "cpp",

        // Other languages
        [".swift"] = "swift",
        [".rb"] = "ruby",
        [".php"] = "php",
        [".lua"] = "lua",
        [".r"] = "r",
        [".jl"] = "julia",

        // Markup/Config
        [".md"] = "markdown",
        [".markdown"] = "markdown",
        [".json"] = "json",
        [".yaml"] = "yaml",
        [".yml"] = "yaml",
        [".xml"] = "xml",
        [".html"] = "html",
        [".htm"] = "html",
        [".css"] = "css",
        [".scss"] = "scss",
        [".sass"] = "sass",

        // Shell
        [".sh"] = "bash",
        [".bash"] = "bash",
        [".zsh"] = "zsh",
        [".ps1"] = "powershell",

        // Other
        [".sql"] = "sql",
        [".txt"] = "text",
        [".rst"] = "rst",
    };

    /// <summary>
    /// License header detection patterns.
    /// </summary>
    private static readonly string[] _licensePatterns =
    {
        @"^/\*[\s\S]*?(?:license|copyright|mit|apache|gpl|bsd)[\s\S]*?\*/\s*",
        @"^//[^\n]*(?:license|copyright)[^\n]*\n(?://[^\n]*\n)*",
        @"^#[^\n]*(?:license|copyright)[^\n]*\n(?:#[^\n]*\n)*",
    };

    #region Constructor

    /// <summary>
    /// Initializes a new instance of the ChunkingService.
    /// </summary>
    /// <param name="logger">Logger instance.</param>
    /// <param name="strategies">Available chunking strategies.</param>
    /// <param name="tokenizer">Optional tokenizer for accurate token counting.</param>
    public ChunkingService(
        ILogger<ChunkingService> logger,
        IEnumerable<IChunkingStrategy> strategies,
        ITokenizerService? tokenizer = null)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _tokenizer = tokenizer;

        // Sort strategies by priority (highest first)
        _strategies = strategies
            .OrderByDescending(s => s.Priority)
            .ToList();

        _logger.LogDebug(
            "ChunkingService initialized with {Count} strategies: {Names}",
            _strategies.Count,
            string.Join(", ", _strategies.Select(s => $"{s.Name}({s.Priority})")));
    }

    #endregion

    #region IChunkingService Implementation

    /// <inheritdoc />
    public IReadOnlyList<TextChunk> ChunkDocument(
        string content,
        string filePath,
        ChunkingOptions options)
    {
        ArgumentNullException.ThrowIfNull(content);
        ArgumentNullException.ThrowIfNull(filePath);
        ArgumentNullException.ThrowIfNull(options);

        if (string.IsNullOrEmpty(content))
        {
            _logger.LogDebug("Empty content for {File}, returning empty chunk list", filePath);
            return Array.Empty<TextChunk>();
        }

        // Step 1: Preprocess content
        var processed = Preprocess(content, options.Preprocessing);

        // Step 2: Get appropriate strategy
        var strategy = GetStrategy(filePath);

        _logger.LogDebug(
            "Chunking {File} ({Length} chars) with strategy {Strategy}",
            filePath, processed.Length, strategy.Name);

        // Step 3: Perform chunking
        var chunks = strategy.Chunk(processed, filePath, options);

        _logger.LogDebug(
            "Created {Count} chunks from {File} (avg tokens: {Avg:F0})",
            chunks.Count,
            filePath,
            chunks.Count > 0 ? chunks.Average(c => c.TokenCount) : 0);

        return chunks;
    }

    /// <inheritdoc />
    public Task<IReadOnlyList<TextChunk>> ChunkDocumentAsync(
        string content,
        string filePath,
        ChunkingOptions options,
        CancellationToken ct = default)
    {
        return Task.Run(
            () => ChunkDocument(content, filePath, options),
            ct);
    }

    /// <inheritdoc />
    public IChunkingStrategy GetStrategy(string filePath)
    {
        foreach (var strategy in _strategies)
        {
            if (strategy.CanHandle(filePath))
            {
                return strategy;
            }
        }

        // Fallback to PlainText strategy
        var fallback = _strategies.FirstOrDefault(s => s.Name == "PlainText");

        if (fallback is null)
        {
            throw new InvalidOperationException(
                $"No chunking strategy found for '{filePath}' and no PlainText fallback available");
        }

        _logger.LogDebug(
            "No specific strategy for {File}, using {Fallback}",
            filePath, fallback.Name);

        return fallback;
    }

    /// <inheritdoc />
    public string? DetectLanguage(string filePath)
    {
        var extension = Path.GetExtension(filePath);

        if (string.IsNullOrEmpty(extension))
            return null;

        return _extensionToLanguage.TryGetValue(extension, out var language)
            ? language
            : null;
    }

    /// <inheritdoc />
    public bool IsSupported(string filePath)
    {
        return _strategies.Any(s => s.CanHandle(filePath));
    }

    /// <inheritdoc />
    public string Preprocess(string content, ChunkPreprocessing options)
    {
        if (options is null)
            return content;

        var result = content;

        // Step 1: Normalize whitespace
        if (options.NormalizeWhitespace)
        {
            result = result.Replace("\t", "    ");       // Tabs to 4 spaces
            result = result.Replace("\r\n", "\n");       // CRLF to LF
            result = result.Replace("\r", "\n");         // CR to LF
        }

        // Step 2: Remove license headers
        if (options.RemoveLicenseHeaders)
        {
            result = RemoveLicenseHeader(result);
        }

        // Step 3: Trim lines (trailing whitespace)
        if (options.TrimLines)
        {
            var lines = result.Split('\n');
            result = string.Join('\n', lines.Select(l => l.TrimEnd()));
        }

        // Step 4: Collapse multiple newlines
        if (options.CollapseMultipleNewlines)
        {
            var maxNewlines = options.MaxConsecutiveEmptyLines + 1;
            var pattern = $"\n{{{maxNewlines + 1},}}";
            result = Regex.Replace(result, pattern, new string('\n', maxNewlines));
        }

        // Step 5: Remove empty lines
        if (options.RemoveEmptyLines)
        {
            var lines = result.Split('\n');
            result = string.Join('\n', lines.Where(l => !string.IsNullOrWhiteSpace(l)));
        }

        return result;
    }

    /// <inheritdoc />
    public int EstimateTokenCount(string text)
    {
        if (string.IsNullOrEmpty(text))
            return 0;

        // Use tokenizer if available
        if (_tokenizer?.IsLoaded == true)
        {
            return _tokenizer.CountTokens(text);
        }

        // Fallback: Character-based heuristic
        // ~4 characters per token for code/technical text
        // This is a well-known approximation used in many embedding systems
        return (int)Math.Ceiling(text.Length / 4.0);
    }

    #endregion

    #region Private Methods

    /// <summary>
    /// Remove license/copyright headers from the start of content.
    /// </summary>
    private static string RemoveLicenseHeader(string content)
    {
        foreach (var pattern in _licensePatterns)
        {
            var match = Regex.Match(
                content,
                pattern,
                RegexOptions.IgnoreCase | RegexOptions.Compiled);

            if (match.Success && match.Index == 0)
            {
                return content[match.Length..].TrimStart('\n');
            }
        }

        return content;
    }

    #endregion
}
```

---

## Strategy Registration

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                    Strategy Registration (DI Setup)                           │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  // In ServiceCollectionExtensions or Startup                                │
│                                                                              │
│  services.AddScoped<IChunkingService, ChunkingService>();                    │
│                                                                              │
│  // Register strategies (order doesn't matter, priority determines order)    │
│  services.AddScoped<IChunkingStrategy, CodeAwareChunkingStrategy>();         │
│  services.AddScoped<IChunkingStrategy, CSharpChunkingStrategy>();            │
│  services.AddScoped<IChunkingStrategy, PythonChunkingStrategy>();            │
│  services.AddScoped<IChunkingStrategy, JavaScriptChunkingStrategy>();        │
│  services.AddScoped<IChunkingStrategy, MarkdownChunkingStrategy>();          │
│  services.AddScoped<IChunkingStrategy, PlainTextChunkingStrategy>();         │
│                                                                              │
│  // Optional: Register tokenizer                                             │
│  services.AddScoped<ITokenizerService, TokenizerService>();                  │
│                                                                              │
│  Strategy Priority Order (after sorting):                                    │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  1. CSharpChunkingStrategy     (Priority: 150)                          │ │
│  │  2. PythonChunkingStrategy     (Priority: 150)                          │ │
│  │  3. JavaScriptChunkingStrategy (Priority: 150)                          │ │
│  │  4. CodeAwareChunkingStrategy  (Priority: 100)                          │ │
│  │  5. MarkdownChunkingStrategy   (Priority: 75)                           │ │
│  │  6. PlainTextChunkingStrategy  (Priority: 0)  ← Fallback               │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Unit Test Plan

| Test | Description |
|------|-------------|
| `ChunkDocument_EmptyContent_ReturnsEmpty` | Empty content returns empty list |
| `ChunkDocument_NullContent_ThrowsArgumentNull` | Null validation |
| `ChunkDocument_SelectsCorrectStrategy` | Strategy selection by extension |
| `ChunkDocument_FallsBackToPlainText` | Unknown extension uses fallback |
| `ChunkDocumentAsync_RunsOnThreadPool` | Async runs on background thread |
| `GetStrategy_HighestPriorityWins` | Priority ordering works |
| `GetStrategy_NoMatchUsesPlainText` | Fallback behavior |
| `DetectLanguage_KnownExtension` | Returns correct language ID |
| `DetectLanguage_UnknownExtension_ReturnsNull` | Unknown returns null |
| `IsSupported_KnownExtension_True` | Known extension supported |
| `IsSupported_UnknownExtension_False` | Unknown not supported |
| `Preprocess_NormalizesWhitespace` | Tabs and line endings |
| `Preprocess_RemovesLicenseHeader` | License header removal |
| `Preprocess_TrimsLines` | Trailing whitespace removed |
| `Preprocess_CollapsesNewlines` | Multiple empty lines collapsed |
| `Preprocess_RemovesEmptyLines` | Empty lines removed |
| `EstimateTokenCount_UsesTokenizer` | Tokenizer when available |
| `EstimateTokenCount_UsesHeuristic` | Character-based fallback |
| `CodeSymbol_SignatureDisplay` | Signature formatting |
| `CodeSymbol_LineCount` | Line count calculation |

---

## File Summary

| File | Location | Purpose | Lines |
|------|----------|---------|-------|
| `IChunkingService.cs` | `Core/Interfaces/` | Service interface | ~110 |
| `IChunkingStrategy.cs` | `Core/Interfaces/` | Strategy interfaces + models | ~200 |
| `ChunkingService.cs` | `Services/Chunking/` | Service implementation | ~280 |

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | IChunkingService interface defined with all methods |
| AC-2 | IChunkingStrategy interface supports extension |
| AC-3 | ICodeChunkingStrategy adds symbol extraction |
| AC-4 | CodeSymbol model captures code structure |
| AC-5 | ChunkingService orchestrates strategies |
| AC-6 | Language detection from file extensions works |
| AC-7 | Preprocessing operations implemented |
| AC-8 | Token count estimation available |

---

## Changelog Entry

```markdown
## v0.7.1e - Chunking Service Interface

### Added
- `IChunkingService` interface
  - ChunkDocument(content, path, options): IReadOnlyList<TextChunk>
  - ChunkDocumentAsync(content, path, options, ct): Task<...>
  - GetStrategy(filePath): IChunkingStrategy
  - DetectLanguage(filePath): string?
  - IsSupported(filePath): bool
  - Preprocess(content, options): string
  - EstimateTokenCount(text): int
- `IChunkingStrategy` interface
  - Name, SupportedExtensions, Priority properties
  - CanHandle(filePath) method
  - Chunk(content, path, options) method
- `ICodeChunkingStrategy` interface (extends IChunkingStrategy)
  - ExtractSymbols(content, path): IReadOnlyList<CodeSymbol>
- `CodeSymbol` class
  - Name, Type, QualifiedName, Parent, Namespace
  - StartLine, EndLine, StartOffset, Length
  - Documentation, AccessModifier, ReturnType, Parameters
  - LineCount, SignatureDisplay computed properties
- `ParameterInfo` class
  - Name, Type, DefaultValue, IsOptional
- `ChunkingService` implementation
  - Strategy selection by priority
  - Language detection (40+ extensions)
  - Preprocessing pipeline (5 steps)
  - Token count estimation (tokenizer or heuristic)
  - License header removal (regex patterns)

### Language Support
- 40+ file extensions mapped to language identifiers
- Categories: .NET, JavaScript/TypeScript, Python, JVM, Systems, Shell, Markup

### Preprocessing Pipeline
1. NormalizeWhitespace (tabs → spaces, CRLF → LF)
2. RemoveLicenseHeaders (regex detection)
3. TrimLines (trailing whitespace)
4. CollapseMultipleNewlines (configurable max)
5. RemoveEmptyLines (optional)
```

---

## Implementation Notes

### Strategy Priority Guidelines

| Priority Range | Use Case |
|----------------|----------|
| 0-49 | Fallback strategies (PlainText) |
| 50-99 | General strategies (Markdown, Config) |
| 100-149 | Code-aware generic strategy |
| 150-199 | Language-specific strategies |
| 200+ | Highly specialized strategies |

### Token Estimation Heuristic

When no tokenizer is available, use the character-based heuristic:
- **~4 characters per token** for code and technical text
- This is a well-established approximation used in OpenAI's tokenizer documentation

### License Header Detection

Three patterns are checked (at file start only):
1. Block comments: `/* ... license|copyright ... */`
2. Line comments: `// license|copyright ...` (consecutive)
3. Hash comments: `# license|copyright ...` (Python/Shell)

---

## Timeline Estimate

| Version | Estimated Effort |
|---------|------------------|
| v0.7.1e | 0.5 day |
