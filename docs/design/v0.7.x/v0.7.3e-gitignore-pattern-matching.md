# Design Specification: AIntern v0.7.3e "Gitignore Pattern Matching"

## Overview

**Version**: v0.7.3e
**Parent**: v0.7.3 Indexing Pipeline
**Focus**: Implement gitignore parsing and pattern matching to respect .gitignore rules during indexing

### Purpose

This sub-version implements the complete gitignore system:
1. `GitignoreParser` - Parse .gitignore files into pattern collections
2. `GitignoreMatcher` - Match file paths against parsed patterns
3. `GitignorePattern` - Individual pattern representation with compiled regex
4. `GitignorePatternMatcher` - Hierarchical matching with caching

### Dependencies

**From v0.7.3a (Indexing Service Interface)**:
- `IGitignoreParser` interface
- `IGitignoreMatcher` interface

**From v0.7.3c (Indexing Service Implementation)**:
- `IndexingService` uses `IGitignoreParser` for file filtering

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                     v0.7.3e Gitignore Pattern Matching                        │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  src/SeniorIntern.Services/Indexing/                                         │
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │                                                                          ││
│  │  GitignoreParser : IGitignoreParser                                      ││
│  │  ┌────────────────────────────────────────────────────────────────────┐  ││
│  │  │  Methods                                                           │  ││
│  │  │  ├── LoadFromFile(gitignorePath) → IGitignoreMatcher              │  ││
│  │  │  ├── LoadFromContent(content, basePath) → IGitignoreMatcher       │  ││
│  │  │  └── LoadFromDirectory(rootPath) → IGitignoreMatcher              │  ││
│  │  └────────────────────────────────────────────────────────────────────┘  ││
│  │  ┌────────────────────────────────────────────────────────────────────┐  ││
│  │  │  Private Methods                                                   │  ││
│  │  │  ├── ParsePatterns(content) → List<GitignorePattern>              │  ││
│  │  │  └── CompilePattern(pattern, isAnchored) → Regex                  │  ││
│  │  └────────────────────────────────────────────────────────────────────┘  ││
│  │                                                                          ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │  GitignoreMatcher : IGitignoreMatcher                                    ││
│  │  ┌────────────────────────────────────────────────────────────────────┐  ││
│  │  │  State                                                             │  ││
│  │  │  ├── _patterns: List<GitignorePattern>                            │  ││
│  │  │  └── _basePath: string                                             │  ││
│  │  └────────────────────────────────────────────────────────────────────┘  ││
│  │  ┌────────────────────────────────────────────────────────────────────┐  ││
│  │  │  IGitignoreMatcher Implementation                                  │  ││
│  │  │  ├── PatternCount: int                                             │  ││
│  │  │  ├── IsIgnored(relativePath, isDirectory) → bool                  │  ││
│  │  │  ├── Filter(relativePaths) → IEnumerable<string>                  │  ││
│  │  │  └── GetPatterns() → IReadOnlyList<string>                        │  ││
│  │  └────────────────────────────────────────────────────────────────────┘  ││
│  │  ┌────────────────────────────────────────────────────────────────────┐  ││
│  │  │  Pattern Matching Logic                                            │  ││
│  │  │  ├── Normalize path separators (\ → /)                            │  ││
│  │  │  ├── Skip directory-only patterns for files                       │  ││
│  │  │  ├── Apply patterns in order (last match wins)                    │  ││
│  │  │  └── Handle negation patterns (! prefix)                          │  ││
│  │  └────────────────────────────────────────────────────────────────────┘  ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │  GitignorePattern (Record)                                               ││
│  │  ┌────────────────────────────────────────────────────────────────────┐  ││
│  │  │  Properties                                                        │  ││
│  │  │  ├── Pattern: string          [The original pattern text]         │  ││
│  │  │  ├── IsNegation: bool         [True if pattern starts with !]     │  ││
│  │  │  ├── IsDirectoryOnly: bool    [True if pattern ends with /]       │  ││
│  │  │  ├── IsAnchored: bool         [True if pattern starts with /]     │  ││
│  │  │  └── Regex: Regex             [Compiled regex for matching]       │  ││
│  │  └────────────────────────────────────────────────────────────────────┘  ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │  GitignorePatternMatcher (Hierarchical with Caching)                     ││
│  │  ┌────────────────────────────────────────────────────────────────────┐  ││
│  │  │  State                                                             │  ││
│  │  │  ├── _matchers: Dictionary<string, GitignoreMatcher>              │  ││
│  │  │  ├── _parser: GitignoreParser                                      │  ││
│  │  │  └── _lock: object                                                 │  ││
│  │  └────────────────────────────────────────────────────────────────────┘  ││
│  │  ┌────────────────────────────────────────────────────────────────────┐  ││
│  │  │  Methods                                                           │  ││
│  │  │  ├── GetMatcher(directoryPath) → GitignoreMatcher                 │  ││
│  │  │  ├── IsIgnored(rootPath, relativePath) → bool                     │  ││
│  │  │  ├── FilterPaths(rootPath, relativePaths) → IEnumerable<string>   │  ││
│  │  │  ├── ClearCache()                                                  │  ││
│  │  │  └── InvalidateCache(directoryPath)                               │  ││
│  │  └────────────────────────────────────────────────────────────────────┘  ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Gitignore Pattern Syntax

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                        Gitignore Pattern Syntax                               │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Supported Features:                                                         │
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │  # Comments                                                              ││
│  │  Lines starting with # are ignored                                       ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │  Basic Patterns                                                          ││
│  │  ├── foo           Match "foo" anywhere in path                         ││
│  │  ├── foo.txt       Match "foo.txt" anywhere in path                     ││
│  │  └── *.log         Match any file ending with ".log"                    ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │  Anchored Patterns (leading /)                                           ││
│  │  ├── /foo          Match "foo" only at root level                       ││
│  │  ├── /build        Match "build" directory at root only                 ││
│  │  └── /src/*.cs     Match .cs files directly in /src                     ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │  Directory Patterns (trailing /)                                         ││
│  │  ├── bin/          Match "bin" directory only (not files named "bin")   ││
│  │  ├── obj/          Match "obj" directory only                           ││
│  │  └── .git/         Match ".git" directory only                          ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │  Wildcard Patterns                                                       ││
│  │  ├── *             Match any sequence except /                          ││
│  │  ├── ?             Match any single character except /                  ││
│  │  ├── [abc]         Match any character in brackets                      ││
│  │  ├── **            Match any path (including /)                         ││
│  │  ├── **/foo        Match "foo" at any depth                             ││
│  │  ├── foo/**        Match everything inside "foo" directory              ││
│  │  └── foo/**/bar    Match "bar" at any depth inside "foo"               ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │  Negation Patterns (leading !)                                           ││
│  │  ├── !important.log     Un-ignore previously ignored file              ││
│  │  ├── !src/              Un-ignore previously ignored directory         ││
│  │  └── Order matters: last matching pattern wins                          ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
│  Pattern Matching Rules:                                                     │
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │  1. Blank lines are ignored                                              ││
│  │  2. Lines starting with # are comments                                   ││
│  │  3. Trailing spaces are trimmed                                          ││
│  │  4. Prefix ! negates the pattern                                         ││
│  │  5. Prefix / anchors to the .gitignore location                         ││
│  │  6. Suffix / matches directories only                                    ││
│  │  7. ** matches across directory boundaries                               ││
│  │  8. Patterns are evaluated top-to-bottom, last match wins               ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Services/Indexing/GitignoreParser.cs` | Parse .gitignore files |
| `src/SeniorIntern.Services/Indexing/GitignoreMatcher.cs` | Match paths against patterns |
| `src/SeniorIntern.Services/Indexing/GitignorePattern.cs` | Pattern record type |
| `src/SeniorIntern.Services/Indexing/GitignorePatternMatcher.cs` | Hierarchical matching with caching |

---

## Detailed Specifications

### 1. GitignoreParser.cs

**Location**: `src/SeniorIntern.Services/Indexing/GitignoreParser.cs`

```csharp
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using SeniorIntern.Core.Interfaces;

namespace SeniorIntern.Services.Indexing;

/// <summary>
/// Parser for .gitignore files.
/// </summary>
/// <remarks>
/// <para>
/// Implements the official gitignore specification:
/// <list type="bullet">
///   <item>Blank lines are ignored</item>
///   <item>Lines starting with # are comments</item>
///   <item>Trailing spaces are trimmed</item>
///   <item>Prefix ! negates the pattern</item>
///   <item>Prefix / anchors to the .gitignore location</item>
///   <item>Suffix / matches directories only</item>
///   <item>Wildcards: *, ?, [abc], **</item>
/// </list>
/// </para>
/// </remarks>
public sealed class GitignoreParser : IGitignoreParser
{
    /// <inheritdoc />
    public IGitignoreMatcher LoadFromFile(string gitignorePath)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(gitignorePath);

        if (!File.Exists(gitignorePath))
        {
            // Return empty matcher for non-existent file
            var basePath = Path.GetDirectoryName(gitignorePath) ?? "";
            return new GitignoreMatcher([], basePath);
        }

        var content = File.ReadAllText(gitignorePath);
        var basePath = Path.GetDirectoryName(gitignorePath) ?? "";
        return LoadFromContent(content, basePath);
    }

    /// <inheritdoc />
    public IGitignoreMatcher LoadFromContent(string content, string basePath)
    {
        ArgumentNullException.ThrowIfNull(content);
        ArgumentException.ThrowIfNullOrWhiteSpace(basePath);

        var patterns = ParsePatterns(content);
        return new GitignoreMatcher(patterns, basePath);
    }

    /// <inheritdoc />
    public IGitignoreMatcher LoadFromDirectory(string rootPath)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(rootPath);

        if (!Directory.Exists(rootPath))
        {
            return new GitignoreMatcher([], rootPath);
        }

        var allPatterns = new List<GitignorePattern>();

        // Find all .gitignore files recursively
        try
        {
            var gitignoreFiles = Directory.EnumerateFiles(
                rootPath,
                ".gitignore",
                new EnumerationOptions
                {
                    RecurseSubdirectories = true,
                    IgnoreInaccessible = true,
                    AttributesToSkip = FileAttributes.System
                });

            foreach (var file in gitignoreFiles)
            {
                var relativeDirPath = Path.GetRelativePath(rootPath, Path.GetDirectoryName(file) ?? "");
                var content = File.ReadAllText(file);
                var patterns = ParsePatterns(content);

                // Adjust patterns to be relative to root
                foreach (var pattern in patterns)
                {
                    var adjustedPattern = relativeDirPath == "."
                        ? pattern
                        : pattern with
                        {
                            Pattern = CombinePaths(relativeDirPath, pattern.Pattern),
                            // Patterns from nested .gitignore are anchored to that directory
                            IsAnchored = true,
                            Regex = CompilePattern(
                                CombinePaths(relativeDirPath, pattern.Pattern),
                                true)
                        };
                    allPatterns.Add(adjustedPattern);
                }
            }
        }
        catch (UnauthorizedAccessException)
        {
            // Ignore directories we can't access
        }

        return new GitignoreMatcher(allPatterns, rootPath);
    }

    /// <summary>
    /// Parse gitignore content into pattern list.
    /// </summary>
    private static List<GitignorePattern> ParsePatterns(string content)
    {
        var patterns = new List<GitignorePattern>();
        var lines = content.Split('\n');

        foreach (var line in lines)
        {
            var trimmed = line.TrimEnd('\r').Trim();

            // Skip empty lines and comments
            if (string.IsNullOrEmpty(trimmed) || trimmed.StartsWith('#'))
                continue;

            // Check for negation
            var isNegation = trimmed.StartsWith('!');
            var pattern = isNegation ? trimmed[1..] : trimmed;

            // Check if directory-only pattern
            var isDirectoryOnly = pattern.EndsWith('/');
            pattern = pattern.TrimEnd('/');

            // Check if anchored (starts with /)
            var isAnchored = pattern.StartsWith('/');
            pattern = pattern.TrimStart('/');

            // Skip empty patterns after processing
            if (string.IsNullOrEmpty(pattern))
                continue;

            patterns.Add(new GitignorePattern
            {
                Pattern = pattern,
                IsNegation = isNegation,
                IsDirectoryOnly = isDirectoryOnly,
                IsAnchored = isAnchored,
                Regex = CompilePattern(pattern, isAnchored)
            });
        }

        return patterns;
    }

    /// <summary>
    /// Compile a gitignore pattern into a regex.
    /// </summary>
    private static Regex CompilePattern(string pattern, bool isAnchored)
    {
        var regexPattern = new StringBuilder();

        // Anchored patterns must match from start
        if (isAnchored)
        {
            regexPattern.Append('^');
        }
        else if (!pattern.Contains('/'))
        {
            // Non-anchored patterns without / can match at any level
            regexPattern.Append("(^|/)");
        }
        else
        {
            // Non-anchored patterns with / are implicitly anchored
            regexPattern.Append('^');
        }

        for (int i = 0; i < pattern.Length; i++)
        {
            var c = pattern[i];

            if (c == '*')
            {
                // Check for **
                if (i + 1 < pattern.Length && pattern[i + 1] == '*')
                {
                    // Check for **/
                    if (i + 2 < pattern.Length && pattern[i + 2] == '/')
                    {
                        // **/ matches zero or more directories
                        regexPattern.Append("(.*/)?");
                        i += 2;
                    }
                    // Check for /**
                    else if (i > 0 && pattern[i - 1] == '/')
                    {
                        // /** matches everything inside
                        regexPattern.Append(".*");
                        i++;
                    }
                    else
                    {
                        // ** alone matches anything
                        regexPattern.Append(".*");
                        i++;
                    }
                }
                else
                {
                    // Single * matches anything except /
                    regexPattern.Append("[^/]*");
                }
            }
            else if (c == '?')
            {
                // ? matches any single character except /
                regexPattern.Append("[^/]");
            }
            else if (c == '/')
            {
                regexPattern.Append('/');
            }
            else if (c == '[')
            {
                // Character class - find matching ]
                var end = pattern.IndexOf(']', i + 1);
                if (end > i)
                {
                    regexPattern.Append(pattern.AsSpan(i, end - i + 1));
                    i = end;
                }
                else
                {
                    regexPattern.Append(Regex.Escape(c.ToString()));
                }
            }
            else
            {
                regexPattern.Append(Regex.Escape(c.ToString()));
            }
        }

        // Match end of path or followed by /
        regexPattern.Append("(/|$)");

        return new Regex(
            regexPattern.ToString(),
            RegexOptions.Compiled | RegexOptions.IgnoreCase | RegexOptions.CultureInvariant);
    }

    /// <summary>
    /// Combine directory path with pattern.
    /// </summary>
    private static string CombinePaths(string directory, string pattern)
    {
        if (directory == "." || string.IsNullOrEmpty(directory))
            return pattern;

        return directory.Replace('\\', '/') + "/" + pattern;
    }
}
```

### 2. GitignoreMatcher.cs

**Location**: `src/SeniorIntern.Services/Indexing/GitignoreMatcher.cs`

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using SeniorIntern.Core.Interfaces;

namespace SeniorIntern.Services.Indexing;

/// <summary>
/// Matcher for gitignore patterns.
/// </summary>
/// <remarks>
/// <para>
/// Patterns are evaluated in order, with the last matching pattern determining
/// whether a path is ignored. Negation patterns (starting with !) can un-ignore
/// previously ignored paths.
/// </para>
/// <para>
/// Thread-safe for read operations. Pattern list is immutable after construction.
/// </para>
/// </remarks>
public sealed class GitignoreMatcher : IGitignoreMatcher
{
    private readonly IReadOnlyList<GitignorePattern> _patterns;
    private readonly string _basePath;

    /// <inheritdoc />
    public int PatternCount => _patterns.Count;

    /// <summary>
    /// Initializes a new instance of the <see cref="GitignoreMatcher"/> class.
    /// </summary>
    /// <param name="patterns">List of parsed patterns.</param>
    /// <param name="basePath">Base path for relative matching.</param>
    public GitignoreMatcher(IEnumerable<GitignorePattern> patterns, string basePath)
    {
        _patterns = patterns?.ToList() ?? throw new ArgumentNullException(nameof(patterns));
        _basePath = basePath ?? throw new ArgumentNullException(nameof(basePath));
    }

    /// <inheritdoc />
    public bool IsIgnored(string relativePath, bool isDirectory = false)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(relativePath);

        // Normalize path separators and remove leading slash
        relativePath = NormalizePath(relativePath);

        var isIgnored = false;

        // Patterns are evaluated in order, last match wins
        foreach (var pattern in _patterns)
        {
            // Skip directory-only patterns when checking files
            if (pattern.IsDirectoryOnly && !isDirectory)
                continue;

            var matches = pattern.Regex.IsMatch(relativePath);
            if (matches)
            {
                // Negation patterns un-ignore, regular patterns ignore
                isIgnored = !pattern.IsNegation;
            }
        }

        return isIgnored;
    }

    /// <inheritdoc />
    public IEnumerable<string> Filter(IEnumerable<string> relativePaths)
    {
        ArgumentNullException.ThrowIfNull(relativePaths);

        return relativePaths.Where(path => !IsIgnored(path));
    }

    /// <inheritdoc />
    public IReadOnlyList<string> GetPatterns()
    {
        return _patterns.Select(p => FormatPattern(p)).ToList();
    }

    /// <summary>
    /// Check if any pattern matches a path prefix.
    /// </summary>
    /// <remarks>
    /// Useful for early pruning during directory traversal.
    /// </remarks>
    /// <param name="directoryPath">Directory path to check.</param>
    /// <returns>True if the directory might contain ignored files.</returns>
    public bool MightContainIgnoredFiles(string directoryPath)
    {
        directoryPath = NormalizePath(directoryPath);

        // Check if directory itself is ignored
        if (IsIgnored(directoryPath, isDirectory: true))
            return true;

        // Check if any pattern could match files in this directory
        foreach (var pattern in _patterns)
        {
            if (pattern.IsNegation)
                continue;

            // If pattern contains the directory path, files inside might match
            var patternPath = pattern.Pattern;
            if (patternPath.StartsWith(directoryPath + "/") ||
                patternPath.StartsWith("**/") ||
                !patternPath.Contains('/'))
            {
                return true;
            }
        }

        return false;
    }

    /// <summary>
    /// Normalize path separators and trim leading/trailing slashes.
    /// </summary>
    private static string NormalizePath(string path)
    {
        return path.Replace('\\', '/').Trim('/');
    }

    /// <summary>
    /// Format pattern back to original syntax.
    /// </summary>
    private static string FormatPattern(GitignorePattern pattern)
    {
        var prefix = pattern.IsNegation ? "!" : "";
        var anchor = pattern.IsAnchored ? "/" : "";
        var suffix = pattern.IsDirectoryOnly ? "/" : "";
        return $"{prefix}{anchor}{pattern.Pattern}{suffix}";
    }
}
```

### 3. GitignorePattern.cs

**Location**: `src/SeniorIntern.Services/Indexing/GitignorePattern.cs`

```csharp
using System.Text.RegularExpressions;

namespace SeniorIntern.Services.Indexing;

/// <summary>
/// Represents a single parsed gitignore pattern.
/// </summary>
/// <remarks>
/// <para>
/// Each pattern is parsed from a line in a .gitignore file and compiled
/// into a regex for efficient matching.
/// </para>
/// <para>
/// Pattern semantics:
/// <list type="bullet">
///   <item><see cref="IsNegation"/>: Pattern started with !, un-ignores matching paths</item>
///   <item><see cref="IsDirectoryOnly"/>: Pattern ended with /, only matches directories</item>
///   <item><see cref="IsAnchored"/>: Pattern started with /, matches from root only</item>
/// </list>
/// </para>
/// </remarks>
public sealed record GitignorePattern
{
    /// <summary>
    /// The original pattern text (without !, /, prefixes/suffixes).
    /// </summary>
    /// <example>
    /// For pattern "!/*.log/", this would be "*.log"
    /// </example>
    public required string Pattern { get; init; }

    /// <summary>
    /// True if this is a negation pattern (started with !).
    /// </summary>
    /// <remarks>
    /// Negation patterns un-ignore paths that were previously ignored.
    /// Example: "!important.log" keeps important.log even if "*.log" was ignored.
    /// </remarks>
    public bool IsNegation { get; init; }

    /// <summary>
    /// True if this pattern only matches directories (ended with /).
    /// </summary>
    /// <remarks>
    /// Example: "build/" only matches directories named "build", not files.
    /// </remarks>
    public bool IsDirectoryOnly { get; init; }

    /// <summary>
    /// True if this pattern is anchored to the base path (started with /).
    /// </summary>
    /// <remarks>
    /// Example: "/build" only matches "build" at the root, not "src/build".
    /// Non-anchored patterns can match at any directory level.
    /// </remarks>
    public bool IsAnchored { get; init; }

    /// <summary>
    /// Compiled regex for matching paths against this pattern.
    /// </summary>
    /// <remarks>
    /// The regex is compiled with <see cref="RegexOptions.Compiled"/> for
    /// efficient repeated matching.
    /// </remarks>
    public required Regex Regex { get; init; }
}
```

### 4. GitignorePatternMatcher.cs

**Location**: `src/SeniorIntern.Services/Indexing/GitignorePatternMatcher.cs`

```csharp
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace SeniorIntern.Services.Indexing;

/// <summary>
/// Efficient gitignore pattern matching with hierarchical .gitignore support and caching.
/// </summary>
/// <remarks>
/// <para>
/// In Git, .gitignore files can exist at any directory level, and patterns in nested
/// .gitignore files apply to that directory and below. This class handles the complete
/// gitignore semantics by:
/// <list type="bullet">
///   <item>Finding all .gitignore files in the directory tree</item>
///   <item>Caching parsed matchers for efficiency</item>
///   <item>Evaluating patterns at each directory level</item>
/// </list>
/// </para>
/// <para>
/// Thread-safe with lock-protected cache.
/// </para>
/// </remarks>
public sealed class GitignorePatternMatcher
{
    private readonly Dictionary<string, GitignoreMatcher> _matchers = new();
    private readonly GitignoreParser _parser = new();
    private readonly object _lock = new();

    /// <summary>
    /// Get or create a matcher for a directory.
    /// </summary>
    /// <param name="directoryPath">Path to the directory.</param>
    /// <returns>Matcher for the .gitignore file in that directory.</returns>
    public GitignoreMatcher GetMatcher(string directoryPath)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(directoryPath);

        lock (_lock)
        {
            if (_matchers.TryGetValue(directoryPath, out var cached))
                return cached;

            var gitignorePath = Path.Combine(directoryPath, ".gitignore");
            var matcher = (GitignoreMatcher)_parser.LoadFromFile(gitignorePath);

            _matchers[directoryPath] = matcher;
            return matcher;
        }
    }

    /// <summary>
    /// Check if a file should be ignored, considering all parent .gitignore files.
    /// </summary>
    /// <param name="rootPath">Root path of the workspace.</param>
    /// <param name="relativePath">Relative path from root to the file.</param>
    /// <returns>True if the file should be ignored.</returns>
    /// <remarks>
    /// This method walks up from root to the file's directory, checking each
    /// .gitignore file along the way. Each level can override the previous.
    /// </remarks>
    public bool IsIgnored(string rootPath, string relativePath)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(rootPath);
        ArgumentException.ThrowIfNullOrWhiteSpace(relativePath);

        var pathParts = relativePath.Replace('\\', '/').Split('/', StringSplitOptions.RemoveEmptyEntries);
        var currentPath = rootPath;
        var isIgnored = false;

        // Check each directory level from root to file
        for (int i = 0; i < pathParts.Length; i++)
        {
            var matcher = GetMatcher(currentPath);
            var partialPath = string.Join('/', pathParts.Take(i + 1));
            var isDir = i < pathParts.Length - 1;

            // Check if this path component is ignored
            if (matcher.PatternCount > 0)
            {
                var match = matcher.IsIgnored(partialPath, isDir);
                if (match)
                {
                    isIgnored = true;
                }
                else
                {
                    // Check for negation patterns that might un-ignore
                    // By checking again with the current ignored state
                    var negated = !matcher.IsIgnored(partialPath, isDir);
                    if (negated && isIgnored)
                    {
                        // This level un-ignored it
                        // (handled automatically by IsIgnored's last-match-wins logic)
                    }
                }

                // Update ignored state based on this level's decision
                isIgnored = matcher.IsIgnored(partialPath, isDir);
            }

            // Move to next directory level
            if (i < pathParts.Length - 1)
            {
                currentPath = Path.Combine(currentPath, pathParts[i]);
            }
        }

        return isIgnored;
    }

    /// <summary>
    /// Filter paths, removing those that are gitignored.
    /// </summary>
    /// <param name="rootPath">Root path of the workspace.</param>
    /// <param name="relativePaths">Relative paths to filter.</param>
    /// <returns>Paths that are not ignored.</returns>
    public IEnumerable<string> FilterPaths(string rootPath, IEnumerable<string> relativePaths)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(rootPath);
        ArgumentNullException.ThrowIfNull(relativePaths);

        return relativePaths.Where(p => !IsIgnored(rootPath, p));
    }

    /// <summary>
    /// Clear the entire matcher cache.
    /// </summary>
    /// <remarks>
    /// Call this when .gitignore files may have changed.
    /// </remarks>
    public void ClearCache()
    {
        lock (_lock)
        {
            _matchers.Clear();
        }
    }

    /// <summary>
    /// Remove cached matcher for a specific directory.
    /// </summary>
    /// <param name="directoryPath">Directory whose cache to invalidate.</param>
    public void InvalidateCache(string directoryPath)
    {
        if (string.IsNullOrWhiteSpace(directoryPath))
            return;

        lock (_lock)
        {
            _matchers.Remove(directoryPath);
        }
    }

    /// <summary>
    /// Get the number of cached matchers.
    /// </summary>
    public int CacheCount
    {
        get
        {
            lock (_lock)
            {
                return _matchers.Count;
            }
        }
    }
}
```

---

## Pattern Regex Compilation Examples

```
┌──────────────────────────────────────────────────────────────────────────────┐
│              Pattern to Regex Conversion Examples                             │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Simple patterns:                                                            │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  Pattern: "*.log"                                                       │ │
│  │  Regex:   "(^|/)[^/]*\.log(/|$)"                                        │ │
│  │  Matches: "debug.log", "src/error.log", "a/b/c/app.log"                │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  Anchored patterns:                                                          │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  Pattern: "/build"                                                      │ │
│  │  Regex:   "^build(/|$)"                                                 │ │
│  │  Matches: "build", "build/output"                                       │ │
│  │  No match: "src/build"                                                  │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  Double-star patterns:                                                       │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  Pattern: "**/test"                                                     │ │
│  │  Regex:   "^(.*/)?test(/|$)"                                            │ │
│  │  Matches: "test", "src/test", "a/b/c/test"                             │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  Pattern: "logs/**"                                                     │ │
│  │  Regex:   "^logs/.*(/|$)"                                               │ │
│  │  Matches: "logs/debug.log", "logs/2024/01/app.log"                     │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  Character class patterns:                                                   │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  Pattern: "*.[oa]"                                                      │ │
│  │  Regex:   "(^|/)[^/]*\.[oa](/|$)"                                       │ │
│  │  Matches: "file.o", "lib.a", "src/main.o"                              │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Unit Testing Requirements

| Class | Test Count | Focus Areas |
|-------|------------|-------------|
| `GitignoreParser` | 15-20 | Pattern parsing, regex compilation, file loading |
| `GitignoreMatcher` | 20-25 | Pattern matching, negation, directories, wildcards |
| `GitignorePattern` | 5-8 | Record equality, property behavior |
| `GitignorePatternMatcher` | 15-18 | Hierarchical matching, caching, invalidation |

**Total: ~55-71 tests**

### Test Cases to Cover

**Pattern Parsing**:
- Empty lines are skipped
- Comments (# prefix) are skipped
- Leading ! marks negation
- Leading / marks anchored
- Trailing / marks directory-only
- Whitespace trimming

**Pattern Matching**:
- `*` matches non-slash characters
- `?` matches single non-slash character
- `**` matches across directories
- `[abc]` character classes
- Anchored vs non-anchored patterns
- Directory-only patterns
- Negation patterns override earlier patterns
- Last match wins rule

**Hierarchical Matching**:
- Root .gitignore applies to all
- Nested .gitignore overrides parent
- Cache hit/miss behavior
- Cache invalidation

---

## Acceptance Criteria

### Functional Requirements
- [ ] `GitignoreParser` correctly parses all pattern types
- [ ] `GitignoreMatcher.IsIgnored` implements last-match-wins semantics
- [ ] `GitignoreMatcher.Filter` correctly filters path collections
- [ ] Negation patterns can un-ignore previously ignored paths
- [ ] Directory-only patterns don't match files
- [ ] `*` matches within directories, `**` matches across directories
- [ ] Character classes `[abc]` work correctly
- [ ] `GitignorePatternMatcher` handles hierarchical .gitignore files
- [ ] Cache improves performance for repeated lookups

### Quality Requirements
- [ ] Regex compilation uses `RegexOptions.Compiled` for performance
- [ ] Thread-safe cache access in `GitignorePatternMatcher`
- [ ] Proper handling of non-existent .gitignore files
- [ ] All public members have XML documentation

---

## Future Considerations

Items explicitly deferred to later sub-versions:
- **v0.7.3f**: IncrementalIndexer implementation (uses gitignore for file filtering)
- **v0.7.3g**: IndexingJobQueue implementation
- **v0.7.3h**: FileWatcherService implementation
