# Design Specification: AIntern v0.7.4j "Unit Testing & Integration"

## Overview

**Version**: v0.7.4j  
**Parent**: v0.7.4 Retrieval & Context  
**Focus**: Create comprehensive unit tests and integration tests for all v0.7.4 components

### Purpose

This sub-version implements comprehensive testing for the v0.7.4 Retrieval & Context components:
1. Unit tests with mocked dependencies for isolated testing
2. Integration tests for end-to-end workflow validation
3. Test coverage for edge cases, error handling, and performance

### Dependencies

**Testing Framework**:
- xUnit for test framework
- Moq for mocking dependencies

**Components Under Test** (from v0.7.4a-i):
- `KnowledgeService`, `QueryCache`
- `KeywordBoostStrategy`, `ReciprocalRankFusionStrategy`
- `ContextAssembler`, `TokenEstimator`, `FileContextExpander`
- `KeywordExtractor`, `TextHighlighter`
- `RagChatService`

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                     v0.7.4j Unit Testing & Integration                        │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  tests/SeniorIntern.Tests/Knowledge/                                         │
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │  Unit Tests (Mocked Dependencies)                                        ││
│  │                                                                          ││
│  │  KnowledgeServiceTests.cs                                                ││
│  │  ├── QueryAsync_* tests (validation, empty, results)                     ││
│  │  ├── IsIndexedAsync_* tests                                              ││
│  │  ├── GetIndexHealthAsync_* tests                                         ││
│  │  └── BuildContextAsync_* tests                                           ││
│  │                                                                          ││
│  │  KeywordExtractorTests.cs                                                ││
│  │  ├── Extract_* tests (stop words, camelCase, snake_case)                 ││
│  │  └── ExtractQuotedPhrases_* tests                                        ││
│  │                                                                          ││
│  │  TextHighlighterTests.cs                                                 ││
│  │  ├── FindHighlights_* tests (matches, overlaps)                          ││
│  │  └── ApplyHighlights_* tests (markers, positions)                        ││
│  │                                                                          ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
│  tests/SeniorIntern.Tests/Knowledge/Reranking/                               │
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │  KeywordBoostStrategyTests.cs                                            ││
│  │  ├── RerankAsync_WithEmptyResults_ReturnsEmpty                           ││
│  │  ├── RerankAsync_BoostsKeywordMatches                                    ││
│  │  └── RerankAsync_ExactMatchGetsHigherBoost                               ││
│  │                                                                          ││
│  │  RRFStrategyTests.cs                                                     ││
│  │  ├── RerankAsync_CombinesSemanticAndKeywordRankings                      ││
│  │  └── RerankAsync_NormalizesScores                                        ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
│  tests/SeniorIntern.Tests/Knowledge/Context/                                 │
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │  ContextAssemblerTests.cs                                                ││
│  │  ├── AssembleAsync_* tests (empty, formats, token budget, grouping)      ││
│  │                                                                          ││
│  │  TokenEstimatorTests.cs                                                  ││
│  │  ├── EstimateTokens_* tests (empty, character, word, special chars)      ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
│  tests/SeniorIntern.Tests/Knowledge/Integration/                             │
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │  KnowledgeServiceIntegrationTests.cs                                     ││
│  │  ├── IAsyncLifetime (setup/teardown temp workspace)                      ││
│  │  ├── FullPipeline_IndexAndQuery_ReturnsResults                           ││
│  │  └── BuildContext_WithTokenBudget_FitsWithinLimit                        ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Test Files to Create

| File | Component | Test Count |
|------|-----------|------------|
| `tests/SeniorIntern.Tests/Knowledge/KnowledgeServiceTests.cs` | KnowledgeService | 10-12 |
| `tests/SeniorIntern.Tests/Knowledge/Reranking/KeywordBoostStrategyTests.cs` | KeywordBoostStrategy | 6-8 |
| `tests/SeniorIntern.Tests/Knowledge/Reranking/RRFStrategyTests.cs` | ReciprocalRankFusionStrategy | 4-6 |
| `tests/SeniorIntern.Tests/Knowledge/Context/ContextAssemblerTests.cs` | ContextAssembler | 8-10 |
| `tests/SeniorIntern.Tests/Knowledge/Context/TokenEstimatorTests.cs` | TokenEstimator | 5-6 |
| `tests/SeniorIntern.Tests/Knowledge/KeywordExtractorTests.cs` | KeywordExtractor | 8-10 |
| `tests/SeniorIntern.Tests/Knowledge/TextHighlighterTests.cs` | TextHighlighter | 6-8 |
| `tests/SeniorIntern.Tests/Knowledge/Integration/KnowledgeServiceIntegrationTests.cs` | Full pipeline | 3-5 |

**Total: ~50-65 tests**

---

## Detailed Specifications

### 1. KnowledgeServiceTests.cs

**Location**: `tests/SeniorIntern.Tests/Knowledge/KnowledgeServiceTests.cs`

```csharp
using System;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Moq;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Services.Knowledge;
using SeniorIntern.Services.Knowledge.Context;
using SeniorIntern.Services.Knowledge.Interfaces;
using Xunit;

namespace SeniorIntern.Tests.Knowledge;

public class KnowledgeServiceTests
{
    private readonly Mock<IVectorStore> _vectorStoreMock;
    private readonly Mock<IEmbeddingService> _embeddingServiceMock;
    private readonly Mock<IRerankingStrategyFactory> _rerankingFactoryMock;
    private readonly Mock<IContextAssembler> _contextAssemblerMock;
    private readonly Mock<IContextExpander> _contextExpanderMock;
    private readonly Mock<ILogger<KnowledgeService>> _loggerMock;
    private readonly KnowledgeService _service;

    public KnowledgeServiceTests()
    {
        _vectorStoreMock = new Mock<IVectorStore>();
        _embeddingServiceMock = new Mock<IEmbeddingService>();
        _rerankingFactoryMock = new Mock<IRerankingStrategyFactory>();
        _contextAssemblerMock = new Mock<IContextAssembler>();
        _contextExpanderMock = new Mock<IContextExpander>();
        _loggerMock = new Mock<ILogger<KnowledgeService>>();

        _service = new KnowledgeService(
            _vectorStoreMock.Object,
            _embeddingServiceMock.Object,
            _rerankingFactoryMock.Object,
            _contextAssemblerMock.Object,
            _contextExpanderMock.Object,
            _loggerMock.Object);
    }

    [Fact]
    public async Task QueryAsync_WithEmptyQuestion_ThrowsArgumentException()
    {
        var options = new KnowledgeQueryOptions { WorkspacePath = "/test" };
        await Assert.ThrowsAsync<ArgumentException>(() => _service.QueryAsync("", options));
    }

    [Fact]
    public async Task QueryAsync_WithNoWorkspacePath_ThrowsArgumentException()
    {
        var options = new KnowledgeQueryOptions { WorkspacePath = "" };
        await Assert.ThrowsAsync<ArgumentException>(() => _service.QueryAsync("test query", options));
    }

    [Fact]
    public async Task QueryAsync_WithNoIndex_ReturnsEmptyResult()
    {
        _vectorStoreMock
            .Setup(v => v.GetIndexForWorkspaceAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync((VectorIndex?)null);

        var options = new KnowledgeQueryOptions { WorkspacePath = "/test" };
        var result = await _service.QueryAsync("test query", options);

        Assert.False(result.HasResults);
        Assert.Empty(result.Chunks);
    }

    [Fact]
    public async Task QueryAsync_WithValidQuery_ReturnsResults()
    {
        // Arrange
        var index = new VectorIndex { Id = "test-index", WorkspacePath = "/test", ChunkCount = 100 };
        var embedding = new float[] { 0.1f, 0.2f, 0.3f };
        var searchResults = new[]
        {
            new ChunkSearchResult
            {
                ChunkId = "chunk1",
                Score = 0.9f,
                Chunk = new TextChunk { Content = "test content", FilePath = "test.cs" }
            }
        };

        _vectorStoreMock
            .Setup(v => v.GetIndexForWorkspaceAsync("/test", It.IsAny<CancellationToken>()))
            .ReturnsAsync(index);
        _embeddingServiceMock
            .Setup(e => e.EmbedAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(embedding);
        _vectorStoreMock
            .Setup(v => v.SearchAsync("test-index", It.IsAny<float[]>(), It.IsAny<VectorSearchOptions>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(searchResults);
        _contextExpanderMock
            .Setup(c => c.ExpandAsync(It.IsAny<string>(), It.IsAny<TextChunk>(), It.IsAny<int>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync("expanded content");

        var options = new KnowledgeQueryOptions { WorkspacePath = "/test", MaxResults = 10, MinRelevance = 0.5f };

        // Act
        var result = await _service.QueryAsync("test query", options);

        // Assert
        Assert.True(result.HasResults);
        Assert.Single(result.Chunks);
        Assert.Equal(0.9f, result.Chunks[0].Relevance);
    }

    [Fact]
    public async Task IsIndexedAsync_WithIndex_ReturnsTrue()
    {
        _vectorStoreMock
            .Setup(v => v.GetIndexForWorkspaceAsync("/test", It.IsAny<CancellationToken>()))
            .ReturnsAsync(new VectorIndex { Id = "test" });

        var result = await _service.IsIndexedAsync("/test");
        Assert.True(result);
    }

    [Fact]
    public async Task IsIndexedAsync_WithoutIndex_ReturnsFalse()
    {
        _vectorStoreMock
            .Setup(v => v.GetIndexForWorkspaceAsync("/test", It.IsAny<CancellationToken>()))
            .ReturnsAsync((VectorIndex?)null);

        var result = await _service.IsIndexedAsync("/test");
        Assert.False(result);
    }

    [Fact]
    public async Task QueryAsync_WithCachedResult_ReturnsCacheHit()
    {
        // Arrange - setup for valid query
        var index = new VectorIndex { Id = "idx", WorkspacePath = "/test" };
        _vectorStoreMock.Setup(v => v.GetIndexForWorkspaceAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(index);
        _embeddingServiceMock.Setup(e => e.EmbedAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(new float[] { 0.1f });
        _vectorStoreMock.Setup(v => v.SearchAsync(It.IsAny<string>(), It.IsAny<float[]>(), It.IsAny<VectorSearchOptions>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(Array.Empty<ChunkSearchResult>());

        var options = new KnowledgeQueryOptions { WorkspacePath = "/test" };

        // Act - query twice
        var result1 = await _service.QueryAsync("same query", options);
        var result2 = await _service.QueryAsync("same query", options);

        // Assert - second call should hit cache
        Assert.True(result2.CacheHit);
    }
}
```

---

### 2. KeywordBoostStrategyTests.cs

**Location**: `tests/SeniorIntern.Tests/Knowledge/Reranking/KeywordBoostStrategyTests.cs`

```csharp
using System.Collections.Generic;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Moq;
using SeniorIntern.Core.Models;
using SeniorIntern.Services.Knowledge.Reranking;
using Xunit;

namespace SeniorIntern.Tests.Knowledge.Reranking;

public class KeywordBoostStrategyTests
{
    private readonly KeywordBoostStrategy _strategy;

    public KeywordBoostStrategyTests()
    {
        var loggerMock = new Mock<ILogger<KeywordBoostStrategy>>();
        _strategy = new KeywordBoostStrategy(loggerMock.Object);
    }

    [Fact]
    public async Task RerankAsync_WithEmptyResults_ReturnsEmpty()
    {
        var results = new List<ChunkSearchResult>();
        var reranked = await _strategy.RerankAsync(results, "test query");
        Assert.Empty(reranked);
    }

    [Fact]
    public async Task RerankAsync_BoostsKeywordMatches()
    {
        var results = new List<ChunkSearchResult>
        {
            new() { ChunkId = "1", Score = 0.8f, Chunk = new TextChunk { Content = "This is some unrelated content" } },
            new() { ChunkId = "2", Score = 0.7f, Chunk = new TextChunk { Content = "This contains UserService code" } }
        };

        var reranked = await _strategy.RerankAsync(results, "UserService");

        Assert.Equal("2", reranked[0].ChunkId);
    }

    [Fact]
    public async Task RerankAsync_ExactMatchGetsHigherBoost()
    {
        var results = new List<ChunkSearchResult>
        {
            new() { ChunkId = "1", Score = 0.8f, Chunk = new TextChunk { Content = "User authentication service" } },
            new() { ChunkId = "2", Score = 0.75f, Chunk = new TextChunk { Content = "find user by email" } }
        };

        var reranked = await _strategy.RerankAsync(results, "find user by email");
        Assert.Equal("2", reranked[0].ChunkId);
    }

    [Fact]
    public async Task RerankAsync_PreservesOriginalScore()
    {
        var results = new List<ChunkSearchResult>
        {
            new() { ChunkId = "1", Score = 0.7f, Chunk = new TextChunk { Content = "UserService implementation" } }
        };

        var reranked = await _strategy.RerankAsync(results, "UserService");

        Assert.True(reranked[0].OriginalScore > 0 || reranked[0].Score != 0.7f);
    }

    [Fact]
    public async Task RerankAsync_MaxBoostIsCapped()
    {
        var results = new List<ChunkSearchResult>
        {
            new() { ChunkId = "1", Score = 0.9f, Chunk = new TextChunk { Content = "user user user user user user user user" } }
        };

        var reranked = await _strategy.RerankAsync(results, "user");

        // Max boost is 30%, so score should not exceed 1.0
        Assert.True(reranked[0].Score <= 1.0f);
    }
}
```

---

### 3. RRFStrategyTests.cs

**Location**: `tests/SeniorIntern.Tests/Knowledge/Reranking/RRFStrategyTests.cs`

```csharp
using System.Collections.Generic;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Moq;
using SeniorIntern.Core.Models;
using SeniorIntern.Services.Knowledge.Reranking;
using Xunit;

namespace SeniorIntern.Tests.Knowledge.Reranking;

public class RRFStrategyTests
{
    private readonly ReciprocalRankFusionStrategy _strategy;

    public RRFStrategyTests()
    {
        var loggerMock = new Mock<ILogger<ReciprocalRankFusionStrategy>>();
        _strategy = new ReciprocalRankFusionStrategy(loggerMock.Object);
    }

    [Fact]
    public async Task RerankAsync_CombinesSemanticAndKeywordRankings()
    {
        var results = new List<ChunkSearchResult>
        {
            new() { ChunkId = "1", Score = 0.9f, Chunk = new TextChunk { Content = "Generic database operations" } },
            new() { ChunkId = "2", Score = 0.7f, Chunk = new TextChunk { Content = "UserRepository UserRepository UserRepository" } },
            new() { ChunkId = "3", Score = 0.8f, Chunk = new TextChunk { Content = "UserRepository implementation" } }
        };

        var reranked = await _strategy.RerankAsync(results, "UserRepository");

        // High keyword frequency should boost result 2
        Assert.Equal("2", reranked[0].ChunkId);
    }

    [Fact]
    public async Task RerankAsync_NormalizesScores()
    {
        var results = new List<ChunkSearchResult>
        {
            new() { ChunkId = "1", Score = 0.9f, Chunk = new TextChunk { Content = "test content" } },
            new() { ChunkId = "2", Score = 0.5f, Chunk = new TextChunk { Content = "other test content" } }
        };

        var reranked = await _strategy.RerankAsync(results, "test");

        Assert.True(reranked[0].Score <= 1.0f);
        Assert.True(reranked[0].Score >= 0.0f);
        Assert.True(reranked[^1].Score >= 0.0f);
    }

    [Fact]
    public async Task RerankAsync_EmptyResults_ReturnsEmpty()
    {
        var results = new List<ChunkSearchResult>();
        var reranked = await _strategy.RerankAsync(results, "test");
        Assert.Empty(reranked);
    }

    [Fact]
    public async Task RerankAsync_NoKeywords_ReturnsOriginalOrder()
    {
        var results = new List<ChunkSearchResult>
        {
            new() { ChunkId = "1", Score = 0.9f, Chunk = new TextChunk { Content = "first" } },
            new() { ChunkId = "2", Score = 0.8f, Chunk = new TextChunk { Content = "second" } }
        };

        var reranked = await _strategy.RerankAsync(results, "the is a");

        // Stop words only - should return original
        Assert.Equal("1", reranked[0].ChunkId);
    }
}
```

---

### 4. ContextAssemblerTests.cs

**Location**: `tests/SeniorIntern.Tests/Knowledge/Context/ContextAssemblerTests.cs`

```csharp
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Moq;
using SeniorIntern.Core.Models;
using SeniorIntern.Services.Knowledge.Context;
using Xunit;

namespace SeniorIntern.Tests.Knowledge.Context;

public class ContextAssemblerTests
{
    private readonly ContextAssembler _assembler;

    public ContextAssemblerTests()
    {
        var tokenEstimator = new TokenEstimator();
        var loggerMock = new Mock<ILogger<ContextAssembler>>();
        _assembler = new ContextAssembler(tokenEstimator, loggerMock.Object);
    }

    [Fact]
    public async Task AssembleAsync_WithEmptyChunks_ReturnsEmpty()
    {
        var chunks = new List<KnowledgeChunk>();
        var options = new ContextBuildOptions();

        var result = await _assembler.AssembleAsync(chunks, options);

        Assert.True(result.IsEmpty);
    }

    [Fact]
    public async Task AssembleAsync_FormatsMarkdown()
    {
        var chunks = new List<KnowledgeChunk>
        {
            new() { Content = "public class Test { }", FilePath = "Test.cs", StartLine = 1, EndLine = 1, Language = "csharp", Relevance = 0.9f }
        };

        var options = new ContextBuildOptions { Format = ContextFormat.Markdown, IncludeFileHeaders = true, IncludeLineNumbers = true };

        var result = await _assembler.AssembleAsync(chunks, options);

        Assert.Contains("### Test.cs", result.Context);
        Assert.Contains("```csharp", result.Context);
        Assert.Contains("public class Test { }", result.Context);
    }

    [Fact]
    public async Task AssembleAsync_FormatsXml()
    {
        var chunks = new List<KnowledgeChunk>
        {
            new() { Content = "public class Test { }", FilePath = "Test.cs", StartLine = 1, EndLine = 1, Relevance = 0.9f }
        };

        var options = new ContextBuildOptions { Format = ContextFormat.Xml };

        var result = await _assembler.AssembleAsync(chunks, options);

        Assert.Contains("<code-context", result.Context);
        Assert.Contains("file=\"Test.cs\"", result.Context);
    }

    [Fact]
    public async Task AssembleAsync_RespectsTokenBudget()
    {
        var chunks = Enumerable.Range(0, 100)
            .Select(i => new KnowledgeChunk
            {
                Content = new string('x', 1000),
                FilePath = $"File{i}.cs",
                StartLine = 1, EndLine = 100,
                Relevance = 0.9f - (i * 0.001f)
            }).ToList();

        var options = new ContextBuildOptions { Format = ContextFormat.Plain, MaxTokens = 500, MaxChunks = 100 };

        var result = await _assembler.AssembleAsync(chunks, options);

        Assert.True(result.EstimatedTokens <= 500);
        Assert.True(result.WasTruncated);
    }

    [Fact]
    public async Task AssembleAsync_GroupsByFile()
    {
        var chunks = new List<KnowledgeChunk>
        {
            new() { Content = "chunk1", FilePath = "B.cs", StartLine = 10, Relevance = 0.9f },
            new() { Content = "chunk2", FilePath = "A.cs", StartLine = 1, Relevance = 0.8f },
            new() { Content = "chunk3", FilePath = "B.cs", StartLine = 1, Relevance = 0.7f }
        };

        var options = new ContextBuildOptions { Format = ContextFormat.Plain, GroupByFile = true };

        var result = await _assembler.AssembleAsync(chunks, options);

        var bIndex = result.Context.IndexOf("B.cs");
        var aIndex = result.Context.IndexOf("A.cs");
        Assert.True(bIndex < aIndex); // B.cs has higher max relevance
    }

    [Fact]
    public async Task AssembleAsync_IncludesHeaderAndFooter()
    {
        var chunks = new List<KnowledgeChunk>
        {
            new() { Content = "test", FilePath = "Test.cs", Relevance = 0.9f }
        };

        var options = new ContextBuildOptions
        {
            ContextHeader = "== START ==",
            ContextFooter = "== END =="
        };

        var result = await _assembler.AssembleAsync(chunks, options);

        Assert.StartsWith("== START ==", result.Context.Trim());
        Assert.EndsWith("== END ==", result.Context.Trim());
    }
}
```

---

### 5. TokenEstimatorTests.cs

**Location**: `tests/SeniorIntern.Tests/Knowledge/Context/TokenEstimatorTests.cs`

```csharp
using SeniorIntern.Core.Models;
using SeniorIntern.Services.Knowledge.Context;
using Xunit;

namespace SeniorIntern.Tests.Knowledge.Context;

public class TokenEstimatorTests
{
    private readonly TokenEstimator _estimator = new();

    [Fact]
    public void EstimateTokens_EmptyString_ReturnsZero()
    {
        var result = _estimator.EstimateTokens("");
        Assert.Equal(0, result);
    }

    [Fact]
    public void EstimateTokens_NullString_ReturnsZero()
    {
        var result = _estimator.EstimateTokens(null!);
        Assert.Equal(0, result);
    }

    [Fact]
    public void EstimateTokens_CharacterBased_ApproximatesCorrectly()
    {
        var text = new string('a', 100);
        var result = _estimator.EstimateTokens(text, TokenEstimationMethod.CharacterBased);
        Assert.InRange(result, 20, 35); // ~25 tokens (100/4)
    }

    [Fact]
    public void EstimateTokens_WordBased_ApproximatesCorrectly()
    {
        var text = "This is a test sentence with some words";
        var result = _estimator.EstimateTokens(text, TokenEstimationMethod.WordBased);
        Assert.InRange(result, 8, 15);
    }

    [Fact]
    public void EstimateTokens_CodeWithSpecialChars_AdjustsEstimate()
    {
        var code = "public void Method() { return x + y; }";
        var plainText = "public void method return plus";

        var codeTokens = _estimator.EstimateTokens(code, TokenEstimationMethod.CharacterBased);
        var plainTokens = _estimator.EstimateTokens(plainText, TokenEstimationMethod.CharacterBased);

        Assert.True(codeTokens > plainTokens);
    }
}
```

---

### 6. KeywordExtractorTests.cs

**Location**: `tests/SeniorIntern.Tests/Knowledge/KeywordExtractorTests.cs`

```csharp
using SeniorIntern.Services.Knowledge;
using Xunit;

namespace SeniorIntern.Tests.Knowledge;

public class KeywordExtractorTests
{
    private readonly KeywordExtractor _extractor = new();

    [Fact]
    public void Extract_EmptyQuery_ReturnsEmpty()
    {
        var result = _extractor.Extract("");
        Assert.Empty(result);
    }

    [Fact]
    public void Extract_FiltersStopWords()
    {
        var result = _extractor.Extract("the quick brown fox");

        Assert.DoesNotContain("the", result);
        Assert.Contains("quick", result);
        Assert.Contains("brown", result);
        Assert.Contains("fox", result);
    }

    [Fact]
    public void Extract_SplitsCamelCase()
    {
        var result = _extractor.Extract("UserService");

        Assert.Contains("user", result);
        Assert.Contains("service", result);
        Assert.Contains("userservice", result);
    }

    [Fact]
    public void Extract_SplitsSnakeCase()
    {
        var result = _extractor.Extract("get_user_by_id");

        Assert.Contains("get", result);
        Assert.Contains("user", result);
    }

    [Fact]
    public void Extract_PreservesProgrammingKeywords()
    {
        var result = _extractor.Extract("async await function");

        Assert.Contains("async", result);
        Assert.Contains("await", result);
    }

    [Fact]
    public void ExtractQuotedPhrases_FindsExactPhrases()
    {
        var result = _extractor.ExtractQuotedPhrases("find \"user service\" in code");

        Assert.Single(result);
        Assert.Equal("user service", result[0]);
    }

    [Fact]
    public void ExtractQuotedPhrases_FindsMultiplePhrases()
    {
        var result = _extractor.ExtractQuotedPhrases("\"first phrase\" and \"second phrase\"");
        Assert.Equal(2, result.Count);
    }

    [Fact]
    public void ExtractQuotedPhrases_NoQuotes_ReturnsEmpty()
    {
        var result = _extractor.ExtractQuotedPhrases("no quotes here");
        Assert.Empty(result);
    }
}
```

---

### 7. TextHighlighterTests.cs

**Location**: `tests/SeniorIntern.Tests/Knowledge/TextHighlighterTests.cs`

```csharp
using SeniorIntern.Services.Knowledge;
using Xunit;

namespace SeniorIntern.Tests.Knowledge;

public class TextHighlighterTests
{
    private readonly TextHighlighter _highlighter;

    public TextHighlighterTests()
    {
        _highlighter = new TextHighlighter(new KeywordExtractor());
    }

    [Fact]
    public void FindHighlights_FindsKeywordMatches()
    {
        var content = "This is a UserService implementation";
        var query = "UserService";

        var highlights = _highlighter.FindHighlights(content, query);

        Assert.NotEmpty(highlights);
        Assert.Contains(highlights, h => h.MatchedKeyword == "userservice");
    }

    [Fact]
    public void FindHighlights_CaseInsensitive()
    {
        var content = "USERSERVICE implementation";
        var query = "userservice";

        var highlights = _highlighter.FindHighlights(content, query);
        Assert.NotEmpty(highlights);
    }

    [Fact]
    public void ApplyHighlights_InsertsMarkers()
    {
        var content = "Call UserService here";
        var query = "UserService";

        var highlights = _highlighter.FindHighlights(content, query);
        var result = _highlighter.ApplyHighlights(content, highlights);

        Assert.Contains("**UserService**", result);
    }

    [Fact]
    public void ApplyHighlights_CustomMarkers()
    {
        var content = "Call UserService here";
        var query = "UserService";

        var highlights = _highlighter.FindHighlights(content, query);
        var result = _highlighter.ApplyHighlights(content, highlights, "<mark>", "</mark>");

        Assert.Contains("<mark>UserService</mark>", result);
    }

    [Fact]
    public void FindHighlights_RemovesOverlaps()
    {
        var content = "UserServiceImpl";
        var query = "UserService Service";

        var highlights = _highlighter.FindHighlights(content, query);

        for (var i = 0; i < highlights.Count - 1; i++)
        {
            var current = highlights[i];
            var next = highlights[i + 1];
            Assert.True(current.Start + current.Length <= next.Start);
        }
    }

    [Fact]
    public void FindHighlights_EmptyContent_ReturnsEmpty()
    {
        var highlights = _highlighter.FindHighlights("", "test");
        Assert.Empty(highlights);
    }
}
```

---

### 8. KnowledgeServiceIntegrationTests.cs

**Location**: `tests/SeniorIntern.Tests/Knowledge/Integration/KnowledgeServiceIntegrationTests.cs`

```csharp
using System;
using System.IO;
using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using Xunit;

namespace SeniorIntern.Tests.Knowledge.Integration;

/// <summary>
/// Integration tests for the full knowledge retrieval pipeline.
/// Uses IAsyncLifetime for test fixture setup/teardown.
/// </summary>
public class KnowledgeServiceIntegrationTests : IAsyncLifetime
{
    private IServiceProvider? _serviceProvider;
    private string? _testWorkspace;

    public async Task InitializeAsync()
    {
        // Create test workspace with sample files
        _testWorkspace = Path.Combine(Path.GetTempPath(), $"test-workspace-{Guid.NewGuid()}");
        Directory.CreateDirectory(_testWorkspace);

        await File.WriteAllTextAsync(
            Path.Combine(_testWorkspace, "UserService.cs"),
            """
            namespace TestApp;

            public class UserService
            {
                private readonly IUserRepository _repository;

                public UserService(IUserRepository repository)
                {
                    _repository = repository;
                }

                public async Task<User> GetUserByIdAsync(int id)
                {
                    return await _repository.FindByIdAsync(id);
                }

                public async Task<User> CreateUserAsync(string name, string email)
                {
                    var user = new User { Name = name, Email = email };
                    return await _repository.SaveAsync(user);
                }
            }
            """);

        await File.WriteAllTextAsync(
            Path.Combine(_testWorkspace, "User.cs"),
            """
            namespace TestApp;

            public class User
            {
                public int Id { get; set; }
                public string Name { get; set; }
                public string Email { get; set; }
            }
            """);

        // Note: Real integration tests would set up full DI container here
    }

    public Task DisposeAsync()
    {
        if (_testWorkspace != null && Directory.Exists(_testWorkspace))
        {
            Directory.Delete(_testWorkspace, recursive: true);
        }
        return Task.CompletedTask;
    }

    [Fact(Skip = "Integration test - requires full service setup")]
    public async Task FullPipeline_IndexAndQuery_ReturnsResults()
    {
        var knowledgeService = _serviceProvider!.GetRequiredService<IKnowledgeService>();

        var result = await knowledgeService.QueryAsync(
            "How do I get a user by ID?",
            new KnowledgeQueryOptions
            {
                WorkspacePath = _testWorkspace!,
                MaxResults = 5,
                MinRelevance = 0.5f
            });

        Assert.True(result.HasResults);
        Assert.Contains(result.Chunks, c => c.FilePath.Contains("UserService"));
    }

    [Fact(Skip = "Integration test - requires full service setup")]
    public async Task BuildContext_WithTokenBudget_FitsWithinLimit()
    {
        var knowledgeService = _serviceProvider!.GetRequiredService<IKnowledgeService>();

        var context = await knowledgeService.BuildContextAsync(
            "Tell me about User management",
            new ContextBuildOptions
            {
                WorkspacePath = _testWorkspace!,
                MaxTokens = 500,
                Format = ContextFormat.Markdown
            });

        Assert.NotEmpty(context);
        Assert.True(context.Length < 2500); // ~500 tokens * 5 chars/token
    }

    [Fact(Skip = "Integration test - requires full service setup")]
    public async Task FindRelevantFiles_ReturnsMatchingFiles()
    {
        var knowledgeService = _serviceProvider!.GetRequiredService<IKnowledgeService>();

        var files = await knowledgeService.FindRelevantFilesAsync(
            "User entity",
            new KnowledgeQueryOptions { WorkspacePath = _testWorkspace!, MaxResults = 10 });

        Assert.NotEmpty(files);
        Assert.Contains(files, f => f.FilePath.Contains("User.cs"));
    }
}
```

---

## Test Summary by Component

```
┌─────────────────────────────────────────────────────────────────┐
│                     v0.7.4j Test Coverage                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  KnowledgeService (v0.7.4d)           ~10 tests                 │
│  ├── QueryAsync validation                                      │
│  ├── QueryAsync empty results                                   │
│  ├── QueryAsync with results                                    │
│  ├── QueryAsync cache hit                                       │
│  ├── IsIndexedAsync                                             │
│  └── GetIndexHealthAsync                                        │
│                                                                 │
│  Reranking Strategies (v0.7.4e)       ~10 tests                 │
│  ├── KeywordBoostStrategy (6)                                   │
│  │   ├── Empty results → empty                                  │
│  │   ├── Keyword boost                                          │
│  │   ├── Exact match boost                                      │
│  │   └── Max boost cap                                          │
│  └── RRFStrategy (4)                                            │
│      ├── Combines rankings                                      │
│      ├── Normalizes scores                                      │
│      └── Empty/no keywords                                      │
│                                                                 │
│  Context Assembly (v0.7.4f)           ~12 tests                 │
│  ├── ContextAssembler (7)                                       │
│  │   ├── Empty chunks                                           │
│  │   ├── Format: Markdown, XML, JSON, Plain                     │
│  │   ├── Token budget                                           │
│  │   ├── Group by file                                          │
│  │   └── Header/footer                                          │
│  └── TokenEstimator (5)                                         │
│      ├── Empty/null                                             │
│      ├── Character-based                                        │
│      ├── Word-based                                             │
│      └── Special chars adjustment                               │
│                                                                 │
│  Keyword & Highlighting (v0.7.4i)     ~14 tests                 │
│  ├── KeywordExtractor (8)                                       │
│  │   ├── Empty query                                            │
│  │   ├── Stop words                                             │
│  │   ├── CamelCase split                                        │
│  │   ├── snake_case split                                       │
│  │   ├── Programming keywords                                   │
│  │   └── Quoted phrases                                         │
│  └── TextHighlighter (6)                                        │
│      ├── Find matches                                           │
│      ├── Case insensitive                                       │
│      ├── Apply markers                                          │
│      ├── Custom markers                                         │
│      └── Remove overlaps                                        │
│                                                                 │
│  Integration Tests                     ~3-5 tests (skipped)     │
│  ├── Full pipeline with temp workspace                          │
│  ├── Context budget enforcement                                 │
│  └── File discovery                                             │
│                                                                 │
│  TOTAL: ~50-55 unit tests + ~3-5 integration tests              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## Acceptance Criteria

### Test Requirements
- [ ] All unit tests use mocked dependencies (isolated)
- [ ] Integration tests use `IAsyncLifetime` for setup/teardown
- [ ] Integration tests create temporary workspaces
- [ ] Skip attribute on integration tests for selective running
- [ ] Edge cases covered (empty inputs, null, boundaries)

### Coverage Requirements
- [ ] `KnowledgeService` - validation, query flow, caching
- [ ] `KeywordBoostStrategy` - boost calculation, max cap
- [ ] `ReciprocalRankFusionStrategy` - ranking combination, normalization
- [ ] `ContextAssembler` - all formats, token budget, grouping
- [ ] `TokenEstimator` - all methods, special character handling
- [ ] `KeywordExtractor` - stop words, identifier splitting
- [ ] `TextHighlighter` - matching, overlap removal, marker insertion

### Quality Requirements
- [ ] Tests follow Arrange-Act-Assert pattern
- [ ] Meaningful test names describing behavior
- [ ] No test interdependencies (isolation)
- [ ] Cleanup after integration tests

---

## Future Considerations

Items deferred to later versions:
- **Future**: Property-based testing for edge cases
- **Future**: Performance benchmarks
- **Future**: Code coverage enforcement
