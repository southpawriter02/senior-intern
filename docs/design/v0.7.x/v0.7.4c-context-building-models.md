# Design Specification: AIntern v0.7.4c "Context Building Models"

## Overview

**Version**: v0.7.4c  
**Parent**: v0.7.4 Retrieval & Context  
**Focus**: Define the data models for context assembly, including format options and token budgeting

### Purpose

This sub-version defines the models for building formatted context strings for LLM prompts:
1. `ContextBuildOptions` - Configuration for context assembly (format, token budget, headers)
2. `ContextBuildResult` - Result container with assembled context and metadata
3. `FormattedChunk` - Single formatted chunk ready for assembly
4. `ContextFormat` - Enum for output format selection (Markdown, XML, Plain, JSON)
5. `TokenEstimationMethod` - Enum for token counting strategy

### Dependencies

**From v0.7.4b (Query & Result Models)**:
- `KnowledgeChunk` - Source chunk data referenced in `FormattedChunk`
- `RerankingStrategy` - Used in `ContextBuildOptions` for retrieval

**From v0.7.4a (Knowledge Service Interface)**:
- `IContextAssembler` consumes `ContextBuildOptions` and produces `ContextBuildResult`

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                     v0.7.4c Context Building Models                           │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  src/SeniorIntern.Core/Models/                                               │
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │                                                                          ││
│  │  ContextBuildOptions                                                     ││
│  │  ├── Core Settings                                                       ││
│  │  │   ├── WorkspacePath: string              (required)                   ││
│  │  │   ├── MaxTokens: int                     (default: 4000)              ││
│  │  │   ├── MaxChunks: int                     (default: 10)                ││
│  │  │   └── MinRelevance: float                (default: 0.5)               ││
│  │  │                                                                        ││
│  │  ├── Formatting                                                          ││
│  │  │   ├── Format: ContextFormat              (default: Markdown)          ││
│  │  │   ├── IncludeFileHeaders: bool           (default: true)              ││
│  │  │   ├── IncludeLineNumbers: bool           (default: true)              ││
│  │  │   ├── IncludeScores: bool                (default: false)             ││
│  │  │   ├── GroupByFile: bool                  (default: true)              ││
│  │  │   └── ChunkSeparator: string             (default: "\n\n")            ││
│  │  │                                                                        ││
│  │  ├── Context Expansion                                                   ││
│  │  │   ├── ExpandContext: bool                (default: true)              ││
│  │  │   └── ContextLines: int                  (default: 5)                 ││
│  │  │                                                                        ││
│  │  ├── Filtering                                                           ││
│  │  │   ├── FilePatterns: IReadOnlyList<string>?                            ││
│  │  │   └── Languages: IReadOnlyList<string>?                               ││
│  │  │                                                                        ││
│  │  ├── Custom Content                                                      ││
│  │  │   ├── ContextHeader: string?                                          ││
│  │  │   └── ContextFooter: string?                                          ││
│  │  │                                                                        ││
│  │  └── Retrieval                                                           ││
│  │      ├── Reranking: RerankingStrategy       (default: KeywordBoost)      ││
│  │      └── TokenEstimation: TokenEstimationMethod (default: CharacterBased)││
│  │                                                                          ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │  ContextBuildResult                                                      ││
│  │  ├── Context: string                        (assembled output)           ││
│  │  ├── EstimatedTokens: int                   (token count)                ││
│  │  ├── ChunksIncluded: int                    (chunks in output)           ││
│  │  ├── ChunksTruncated: int                   (chunks omitted)             ││
│  │  ├── FilesIncluded: IReadOnlyList<string>   (unique files)               ││
│  │  ├── WasTruncated: bool                     (hit token limit)            ││
│  │  ├── Format: ContextFormat                  (format used)                ││
│  │  ├── BuildTime: TimeSpan                    (processing time)            ││
│  │  ├── AverageRelevance: float                (mean relevance)             ││
│  │  ├── IsEmpty: bool (computed)               (no content)                 ││
│  │  └── Empty: ContextBuildResult (static)     (singleton)                  ││
│  │                                                                          ││
│  │  FormattedChunk                                                          ││
│  │  ├── FormattedContent: string               (with headers/blocks)        ││
│  │  ├── EstimatedTokens: int                   (token count)                ││
│  │  ├── FilePath: string                       (source file)                ││
│  │  ├── Relevance: float                       (source relevance)           ││
│  │  └── SourceChunk: KnowledgeChunk?           (original chunk)             ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
│  ┌──────────────────────────────────────────────────────────────────────────┐│
│  │  ContextFormat (enum)                                                    ││
│  │  ├── Markdown = 0     (code blocks with language tags)                   ││
│  │  ├── Plain = 1        (minimal formatting)                               ││
│  │  ├── Xml = 2          (structured XML tags)                              ││
│  │  └── Json = 3         (structured JSON output)                           ││
│  │                                                                          ││
│  │  TokenEstimationMethod (enum)                                            ││
│  │  ├── CharacterBased = 0  (~4 chars per token, fastest)                   ││
│  │  ├── WordBased = 1       (~1.3 tokens per word)                          ││
│  │  └── Tokenizer = 2       (actual tokenization, slowest)                  ││
│  └──────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Context Assembly Flow

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                        Context Assembly Pipeline                              │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Input: IReadOnlyList<KnowledgeChunk> chunks                                 │
│         ContextBuildOptions options                                          │
│     │                                                                        │
│     ▼                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  1. Filter Chunks                                                        │ │
│  │     - Apply MinRelevance threshold                                       │ │
│  │     - Apply FilePatterns filter                                          │ │
│  │     - Apply Languages filter                                             │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│     │                                                                        │
│     ▼                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  2. Format Chunks                                                        │ │
│  │     - Apply ContextFormat (Markdown/XML/Plain/JSON)                      │ │
│  │     - Add file headers if IncludeFileHeaders                             │ │
│  │     - Add line numbers if IncludeLineNumbers                             │ │
│  │     - Add relevance scores if IncludeScores                              │ │
│  │     → Produces: IReadOnlyList<FormattedChunk>                            │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│     │                                                                        │
│     ▼                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  3. Group (Optional)                                                     │ │
│  │     - If GroupByFile: consolidate chunks from same file                  │ │
│  │     - Single file header for grouped chunks                              │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│     │                                                                        │
│     ▼                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  4. Token Budgeting                                                      │ │
│  │     - Estimate tokens using TokenEstimationMethod                        │ │
│  │     - Include chunks until MaxTokens reached                             │ │
│  │     - Limit to MaxChunks if specified                                    │ │
│  │     - Track ChunksTruncated count                                        │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│     │                                                                        │
│     ▼                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  5. Assemble                                                             │ │
│  │     - Prepend ContextHeader (if set)                                     │ │
│  │     - Join chunks with ChunkSeparator                                    │ │
│  │     - Append ContextFooter (if set)                                      │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│     │                                                                        │
│     ▼                                                                        │
│  Output: ContextBuildResult                                                  │
│          - Context (assembled string)                                        │
│          - EstimatedTokens, ChunksIncluded, ChunksTruncated                 │
│          - WasTruncated, BuildTime, AverageRelevance                        │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Models/ContextBuildOptions.cs` | Context assembly configuration with format and budgeting options |
| `src/SeniorIntern.Core/Models/ContextBuildResult.cs` | Result container with assembled context and metadata |

---

## Detailed Specifications

### 1. ContextBuildOptions.cs

**Location**: `src/SeniorIntern.Core/Models/ContextBuildOptions.cs`

```csharp
using System;
using System.Collections.Generic;

namespace SeniorIntern.Core.Models;

/// <summary>
/// Options for building context strings for LLM prompts.
/// </summary>
/// <remarks>
/// <para>
/// Provides comprehensive control over context assembly including:
/// <list type="bullet">
///   <item>Token budget management (MaxTokens, MaxChunks)</item>
///   <item>Output format selection (Markdown, XML, Plain, JSON)</item>
///   <item>Display options (headers, line numbers, scores)</item>
///   <item>Context expansion and filtering</item>
/// </list>
/// </para>
/// <para>
/// Token budgeting ensures the assembled context fits within LLM context windows.
/// The default MaxTokens of 4000 leaves room for the user prompt and response.
/// </para>
/// </remarks>
/// <example>
/// Typical RAG context building:
/// <code>
/// var options = new ContextBuildOptions
/// {
///     WorkspacePath = "/path/to/project",
///     MaxTokens = 6000,
///     Format = ContextFormat.Markdown,
///     GroupByFile = true,
///     ContextHeader = "Relevant code from the codebase:",
///     Reranking = RerankingStrategy.KeywordBoost
/// };
/// </code>
/// </example>
public sealed class ContextBuildOptions
{
    #region Core Settings

    /// <summary>
    /// Workspace path to retrieve context from. Required.
    /// </summary>
    public string WorkspacePath { get; init; } = string.Empty;

    /// <summary>
    /// Maximum tokens to include in the context.
    /// Context will be truncated to fit within this budget.
    /// Default: 4000
    /// </summary>
    /// <remarks>
    /// This is an estimate; actual token count depends on the model's tokenizer.
    /// Use TokenEstimationMethod.Tokenizer for exact counts.
    /// </remarks>
    public int MaxTokens { get; init; } = 4000;

    /// <summary>
    /// Maximum number of chunks to include.
    /// Default: 10
    /// </summary>
    public int MaxChunks { get; init; } = 10;

    /// <summary>
    /// Minimum relevance score for included chunks.
    /// Default: 0.5
    /// </summary>
    public float MinRelevance { get; init; } = 0.5f;

    #endregion

    #region Formatting

    /// <summary>
    /// Output format for the context string.
    /// Default: Markdown
    /// </summary>
    public ContextFormat Format { get; init; } = ContextFormat.Markdown;

    /// <summary>
    /// Whether to include file path headers above each chunk.
    /// Default: true
    /// </summary>
    public bool IncludeFileHeaders { get; init; } = true;

    /// <summary>
    /// Whether to include line numbers in headers.
    /// Default: true
    /// </summary>
    public bool IncludeLineNumbers { get; init; } = true;

    /// <summary>
    /// Whether to include relevance scores in output.
    /// Useful for debugging but may confuse the LLM.
    /// Default: false
    /// </summary>
    public bool IncludeScores { get; init; } = false;

    /// <summary>
    /// Whether to group chunks by file.
    /// When true, all chunks from the same file are grouped together.
    /// Default: true
    /// </summary>
    public bool GroupByFile { get; init; } = true;

    /// <summary>
    /// Separator between chunks in the output.
    /// Default: "\n\n"
    /// </summary>
    public string ChunkSeparator { get; init; } = "\n\n";

    #endregion

    #region Context Expansion

    /// <summary>
    /// Whether to expand context around matched chunks.
    /// Default: true
    /// </summary>
    public bool ExpandContext { get; init; } = true;

    /// <summary>
    /// Lines of context to include around matches.
    /// Default: 5
    /// </summary>
    public int ContextLines { get; init; } = 5;

    #endregion

    #region Filtering

    /// <summary>
    /// File patterns to filter context.
    /// </summary>
    public IReadOnlyList<string>? FilePatterns { get; init; }

    /// <summary>
    /// Language filters for context.
    /// </summary>
    public IReadOnlyList<string>? Languages { get; init; }

    #endregion

    #region Custom Content

    /// <summary>
    /// Optional header to prepend to the context.
    /// </summary>
    /// <example>"The following code snippets are relevant to your question:"</example>
    public string? ContextHeader { get; init; }

    /// <summary>
    /// Optional footer to append to the context.
    /// </summary>
    /// <example>"End of relevant code."</example>
    public string? ContextFooter { get; init; }

    #endregion

    #region Retrieval Settings

    /// <summary>
    /// Reranking strategy to use when retrieving chunks.
    /// Default: KeywordBoost
    /// </summary>
    public RerankingStrategy Reranking { get; init; } = RerankingStrategy.KeywordBoost;

    /// <summary>
    /// Token estimation method.
    /// Default: CharacterBased (fast approximation)
    /// </summary>
    public TokenEstimationMethod TokenEstimation { get; init; } = TokenEstimationMethod.CharacterBased;

    #endregion
}

/// <summary>
/// Output format for context strings.
/// </summary>
/// <remarks>
/// Different LLMs perform better with different context formats.
/// Markdown is the most widely supported.
/// </remarks>
public enum ContextFormat
{
    /// <summary>
    /// Markdown format with code blocks and headers.
    /// Best for models that understand markdown.
    /// </summary>
    /// <example>
    /// ### src/Services/UserService.cs (lines 42-58)
    /// ```csharp
    /// public async Task&lt;User&gt; GetUserAsync(int id) { ... }
    /// ```
    /// </example>
    Markdown = 0,

    /// <summary>
    /// Plain text format with minimal formatting.
    /// Most compatible but loses structure.
    /// </summary>
    Plain = 1,

    /// <summary>
    /// XML format with structured tags.
    /// Best for models trained on XML-structured data (e.g., Claude).
    /// </summary>
    /// <example>
    /// &lt;file path="src/Services/UserService.cs" lines="42-58"&gt;
    ///   &lt;code language="csharp"&gt;...&lt;/code&gt;
    /// &lt;/file&gt;
    /// </example>
    Xml = 2,

    /// <summary>
    /// JSON format for structured output.
    /// Useful for programmatic processing.
    /// </summary>
    Json = 3
}

/// <summary>
/// Method for estimating token count.
/// </summary>
/// <remarks>
/// <para>
/// Token estimation is used for budgeting context size. Different methods
/// offer tradeoffs between speed and accuracy:
/// <list type="bullet">
///   <item>CharacterBased: ~4 chars per token (fastest, good for code)</item>
///   <item>WordBased: ~1.3 tokens per word (better for prose)</item>
///   <item>Tokenizer: Exact count (slowest, requires model-specific tokenizer)</item>
/// </list>
/// </para>
/// </remarks>
public enum TokenEstimationMethod
{
    /// <summary>
    /// Estimate based on character count (~4 chars per token).
    /// Fast but less accurate. Good default for code.
    /// </summary>
    CharacterBased = 0,

    /// <summary>
    /// Estimate based on word count (~1.3 tokens per word).
    /// More accurate for natural language text.
    /// </summary>
    WordBased = 1,

    /// <summary>
    /// Use actual tokenizer for exact count.
    /// Most accurate but slowest. Requires loaded tokenizer.
    /// </summary>
    Tokenizer = 2
}
```

---

### 2. ContextBuildResult.cs

**Location**: `src/SeniorIntern.Core/Models/ContextBuildResult.cs`

```csharp
using System;
using System.Collections.Generic;

namespace SeniorIntern.Core.Models;

/// <summary>
/// Result of context building operation.
/// </summary>
/// <remarks>
/// <para>
/// Contains the assembled context string along with metadata about the build:
/// <list type="bullet">
///   <item>Token count and truncation status</item>
///   <item>Included files and chunk counts</item>
///   <item>Build timing for performance monitoring</item>
///   <item>Average relevance for quality assessment</item>
/// </list>
/// </para>
/// </remarks>
public sealed class ContextBuildResult
{
    /// <summary>
    /// The assembled context string.
    /// </summary>
    public string Context { get; init; } = string.Empty;

    /// <summary>
    /// Estimated token count of the context.
    /// </summary>
    public int EstimatedTokens { get; init; }

    /// <summary>
    /// Number of chunks included in the context.
    /// </summary>
    public int ChunksIncluded { get; init; }

    /// <summary>
    /// Number of chunks that were truncated due to token budget.
    /// </summary>
    public int ChunksTruncated { get; init; }

    /// <summary>
    /// Files included in the context.
    /// </summary>
    public IReadOnlyList<string> FilesIncluded { get; init; } = Array.Empty<string>();

    /// <summary>
    /// Whether the context was truncated to fit the token budget.
    /// </summary>
    public bool WasTruncated { get; init; }

    /// <summary>
    /// The format used for the context.
    /// </summary>
    public ContextFormat Format { get; init; }

    /// <summary>
    /// Time spent building the context.
    /// </summary>
    public TimeSpan BuildTime { get; init; }

    /// <summary>
    /// Average relevance score of included chunks.
    /// </summary>
    public float AverageRelevance { get; init; }

    /// <summary>
    /// Total chunks available before truncation.
    /// </summary>
    public int TotalChunksAvailable => ChunksIncluded + ChunksTruncated;

    /// <summary>
    /// Percentage of available chunks that were included.
    /// </summary>
    public double InclusionPercentage => TotalChunksAvailable > 0 
        ? (double)ChunksIncluded / TotalChunksAvailable * 100 
        : 0;

    /// <summary>
    /// Number of unique files in the context.
    /// </summary>
    public int FileCount => FilesIncluded.Count;

    /// <summary>
    /// Whether the context is empty.
    /// </summary>
    public bool IsEmpty => string.IsNullOrWhiteSpace(Context);

    /// <summary>
    /// Empty result singleton.
    /// </summary>
    public static ContextBuildResult Empty { get; } = new()
    {
        Context = string.Empty,
        FilesIncluded = Array.Empty<string>()
    };
}

/// <summary>
/// Represents a formatted chunk ready for context assembly.
/// </summary>
/// <remarks>
/// <para>
/// Contains the formatted output of a single chunk including headers,
/// code blocks, and any additional formatting based on the ContextFormat.
/// </para>
/// <para>
/// The EstimatedTokens property allows for efficient token budgeting
/// without re-counting during assembly.
/// </para>
/// </remarks>
public sealed class FormattedChunk
{
    /// <summary>
    /// The formatted content (with headers, code blocks, etc.).
    /// </summary>
    public string FormattedContent { get; init; } = string.Empty;

    /// <summary>
    /// Estimated token count for this chunk.
    /// </summary>
    public int EstimatedTokens { get; init; }

    /// <summary>
    /// Source file path.
    /// </summary>
    public string FilePath { get; init; } = string.Empty;

    /// <summary>
    /// Starting line number in the source file.
    /// </summary>
    public int StartLine { get; init; }

    /// <summary>
    /// Ending line number in the source file.
    /// </summary>
    public int EndLine { get; init; }

    /// <summary>
    /// Relevance score of the source chunk.
    /// </summary>
    public float Relevance { get; init; }

    /// <summary>
    /// Programming language of the content.
    /// </summary>
    public string? Language { get; init; }

    /// <summary>
    /// Original chunk for reference.
    /// </summary>
    public KnowledgeChunk? SourceChunk { get; init; }

    /// <summary>
    /// Character count of the formatted content.
    /// </summary>
    public int CharacterCount => FormattedContent.Length;

    /// <summary>
    /// Line range as a formatted string.
    /// </summary>
    public string LineRange => StartLine == EndLine 
        ? $"line {StartLine}" 
        : $"lines {StartLine}-{EndLine}";
}
```

---

## Format Examples

### Markdown Format

```markdown
### src/Services/UserService.cs (lines 42-58)
```csharp
public async Task<User> GetUserAsync(int id)
{
    var user = await _repository.FindByIdAsync(id);
    if (user == null)
        throw new UserNotFoundException(id);
    return user;
}
```

### src/Data/UserRepository.cs (lines 15-28)
```csharp
public async Task<User?> FindByIdAsync(int id)
{
    return await _context.Users.FindAsync(id);
}
```
```

### XML Format

```xml
<context>
  <file path="src/Services/UserService.cs" lines="42-58" language="csharp">
    <code>
public async Task<User> GetUserAsync(int id)
{
    var user = await _repository.FindByIdAsync(id);
    if (user == null)
        throw new UserNotFoundException(id);
    return user;
}
    </code>
  </file>
</context>
```

### Plain Format

```
--- src/Services/UserService.cs (lines 42-58) ---
public async Task<User> GetUserAsync(int id)
{
    var user = await _repository.FindByIdAsync(id);
    ...
}
```

---

## Unit Testing Requirements

| Model | Test Count | Focus Areas |
|-------|------------|-------------|
| `ContextBuildOptions` | 12-15 | Default values, all properties, region combinations |
| `ContextBuildResult` | 10-12 | Computed properties, Empty singleton, edge cases |
| `FormattedChunk` | 6-8 | LineRange formatting, CharacterCount |
| `ContextFormat` | 4-5 | Enum values, default behavior |
| `TokenEstimationMethod` | 3-4 | Enum values |

**Total: ~35-44 tests**

### Test Scenarios

```
ContextBuildOptions Tests:
├── Options_DefaultValues_AreCorrect
├── Options_AllFormattingOptions_CanBeSet
├── Options_WithCustomHeaderFooter_SetsCorrectly
├── Options_WithFilePatterns_SetsCorrectly
├── Options_DefaultReranking_IsKeywordBoost
└── Options_DefaultTokenEstimation_IsCharacterBased

ContextBuildResult Tests:
├── Result_Empty_HasEmptyContext
├── Result_Empty_IsEmptyReturnsTrue
├── Result_WithContent_IsEmptyReturnsFalse
├── Result_TotalChunksAvailable_CalculatesCorrectly
├── Result_InclusionPercentage_CalculatesCorrectly
├── Result_InclusionPercentage_HandlesZeroDivision
└── Result_FileCount_ReturnsCorrectCount

FormattedChunk Tests:
├── Chunk_LineRange_SingleLine_FormatsCorrectly
├── Chunk_LineRange_MultiLine_FormatsCorrectly
├── Chunk_CharacterCount_MatchesContentLength
└── Chunk_WithSourceChunk_PreservesReference
```

---

## Acceptance Criteria

### Functional Requirements
- [ ] `ContextBuildOptions` provides all formatting and budgeting configuration
- [ ] `ContextBuildResult` contains assembled context with complete metadata
- [ ] `FormattedChunk` links formatted output to source chunk
- [ ] `ContextFormat` enum supports Markdown, Plain, XML, and JSON
- [ ] `TokenEstimationMethod` enum supports CharacterBased, WordBased, and Tokenizer

### Quality Requirements
- [ ] All models are sealed classes (immutability)
- [ ] All properties use `init` accessors
- [ ] All public members have XML documentation
- [ ] Static singleton instances use lazy initialization
- [ ] Computed properties handle edge cases (division by zero)

---

## Future Considerations

Items explicitly deferred to later sub-versions:
- **v0.7.4f**: `ContextAssembler` implementation that uses these models
- **v0.7.4f**: Format-specific formatters (MarkdownFormatter, XmlFormatter, etc.)
- **v0.7.5**: UI for selecting context format preferences

---

## Appendix: Type Dependencies

```
v0.7.4c Models
│
├── ContextBuildOptions
│   ├── Uses: ContextFormat (defined here)
│   ├── Uses: TokenEstimationMethod (defined here)
│   └── Uses: RerankingStrategy (from v0.7.4b)
│
├── ContextBuildResult
│   └── Uses: ContextFormat (defined here)
│
└── FormattedChunk
    └── Uses: KnowledgeChunk (from v0.7.4b)
```
