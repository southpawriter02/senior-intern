# Design Specification: The Senior Intern v0.2.2 "Conversation Persistence"

## Executive Summary

This document provides a comprehensive design specification for v0.2.2, which enables saving and loading of conversations, implements the conversation list UI in the sidebar, and adds auto-save functionality. This sub-version transforms the application from a single-session chat into a persistent conversation manager.

### v0.2.2 Scope (from v0.2.0 Design Document)
- Save/load conversations to/from SQLite database
- Conversation list UI in sidebar with grouping by date
- Auto-save functionality with debouncing
- Title auto-generation from first user message
- Search, rename, delete, and archive operations

### Dependencies
- **v0.2.1** must be complete (database foundation, entities, repositories)

---

## Sub-Part Breakdown

| Part | Name | Focus |
|------|------|-------|
| v0.2.2a | Service Layer | DatabaseConversationService, mapping, auto-save logic |
| v0.2.2b | ViewModels | ConversationListViewModel, ConversationSummaryViewModel, events |
| v0.2.2c | Conversation List UI | ConversationListView with grouping, search, context menu |
| v0.2.2d | Chat Integration | Connect chat to persistence, handle conversation switching |
| v0.2.2e | Polish & Edge Cases | Unsaved changes handling, empty states, performance |

---

## Architecture Overview

### Data Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              User Interface                                  │
│  ┌─────────────────────────┐              ┌─────────────────────────────┐  │
│  │  ConversationListView   │              │        ChatView             │  │
│  │  - Search box           │              │  - Message list             │  │
│  │  - Grouped list         │              │  - Input box                │  │
│  │  - Context menu         │              │  - Send/Stop buttons        │  │
│  └───────────┬─────────────┘              └──────────────┬──────────────┘  │
│              │                                           │                  │
│              ▼                                           ▼                  │
│  ┌─────────────────────────┐              ┌─────────────────────────────┐  │
│  │ConversationListViewModel│◄────────────►│      ChatViewModel          │  │
│  │  - Conversations        │   Events     │  - Messages                 │  │
│  │  - SelectedConversation │              │  - CurrentConversation      │  │
│  └───────────┬─────────────┘              └──────────────┬──────────────┘  │
└──────────────┼───────────────────────────────────────────┼──────────────────┘
               │                                           │
               ▼                                           ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                        IConversationService                                  │
│  ┌──────────────────────────────────────────────────────────────────────┐  │
│  │                   DatabaseConversationService                         │  │
│  │  - CurrentConversation (in-memory)                                    │  │
│  │  - Auto-save with debouncing                                          │  │
│  │  - Title generation                                                   │  │
│  │  - Events: ConversationChanged, ConversationListChanged               │  │
│  └──────────────────────────────────────────────────────────────────────┘  │
└──────────────────────────────────────────────────────────────────────────────┘
               │
               ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                        IConversationRepository                               │
│  ┌──────────────────────────────────────────────────────────────────────┐  │
│  │  - CRUD operations                                                    │  │
│  │  - Message management                                                 │  │
│  │  - Search                                                             │  │
│  └──────────────────────────────────────────────────────────────────────┘  │
└──────────────────────────────────────────────────────────────────────────────┘
               │
               ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                           SQLite Database                                    │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │Conversations│  │  Messages   │  │SystemPrompts│  │   Presets   │        │
│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘        │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Auto-Save Flow

```
User sends message
        │
        ▼
┌─────────────────┐
│ Add to in-memory│
│  conversation   │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  Start/Reset    │
│ debounce timer  │
│    (500ms)      │
└────────┬────────┘
         │
         │ Timer expires
         ▼
┌─────────────────┐
│ Check if dirty  │
│   (unsaved)     │
└────────┬────────┘
         │ Yes
         ▼
┌─────────────────┐
│  Save to DB     │
│  (background)   │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Update "Saved"  │
│   indicator     │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│   Fire event    │
│ (list refresh)  │
└─────────────────┘
```

---

## v0.2.2a: Service Layer

### Objective
Implement the `DatabaseConversationService` that manages the current conversation in memory, persists changes to the database, and provides auto-save functionality.

### Domain Models

First, update/create the domain models that bridge entities and ViewModels.

#### Conversation.cs (Update)

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Domain model for a conversation (in-memory representation)
/// </summary>
public sealed class Conversation
{
    public Guid Id { get; set; } = Guid.NewGuid();
    public string Title { get; set; } = "New Conversation";
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;
    public Guid? SystemPromptId { get; set; }
    public string? SystemPromptName { get; set; }
    public string? ModelPath { get; set; }
    public string? ModelName { get; set; }
    public bool IsArchived { get; set; }
    public bool IsPinned { get; set; }
    public bool IsPersisted { get; set; }
    public bool HasUnsavedChanges { get; set; }

    private readonly List<ChatMessage> _messages = new();
    public IReadOnlyList<ChatMessage> Messages => _messages;

    public void AddMessage(ChatMessage message)
    {
        message.SequenceNumber = _messages.Count + 1;
        _messages.Add(message);
        UpdatedAt = DateTime.UtcNow;
        HasUnsavedChanges = true;
    }

    public void UpdateMessage(Guid messageId, Action<ChatMessage> updateAction)
    {
        var message = _messages.FirstOrDefault(m => m.Id == messageId);
        if (message != null)
        {
            updateAction(message);
            UpdatedAt = DateTime.UtcNow;
            HasUnsavedChanges = true;
        }
    }

    public void RemoveMessage(Guid messageId)
    {
        var message = _messages.FirstOrDefault(m => m.Id == messageId);
        if (message != null)
        {
            _messages.Remove(message);
            // Re-sequence remaining messages
            for (int i = 0; i < _messages.Count; i++)
            {
                _messages[i].SequenceNumber = i + 1;
            }
            UpdatedAt = DateTime.UtcNow;
            HasUnsavedChanges = true;
        }
    }

    public void ClearMessages()
    {
        _messages.Clear();
        UpdatedAt = DateTime.UtcNow;
        HasUnsavedChanges = true;
    }

    internal void LoadMessages(IEnumerable<ChatMessage> messages)
    {
        _messages.Clear();
        _messages.AddRange(messages.OrderBy(m => m.SequenceNumber));
    }

    internal void MarkAsSaved()
    {
        HasUnsavedChanges = false;
        IsPersisted = true;
    }
}
```

#### ConversationSummary.cs

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Lightweight summary of a conversation for list display
/// </summary>
public sealed record ConversationSummary
{
    public Guid Id { get; init; }
    public string Title { get; init; } = string.Empty;
    public DateTime CreatedAt { get; init; }
    public DateTime UpdatedAt { get; init; }
    public int MessageCount { get; init; }
    public string? Preview { get; init; }
    public bool IsArchived { get; init; }
    public bool IsPinned { get; init; }
    public string? ModelName { get; init; }

    /// <summary>
    /// Gets the date group for this conversation
    /// </summary>
    public DateGroup GetDateGroup()
    {
        var now = DateTime.UtcNow.Date;
        var date = UpdatedAt.Date;

        if (date == now)
            return DateGroup.Today;
        if (date == now.AddDays(-1))
            return DateGroup.Yesterday;
        if (date >= now.AddDays(-7))
            return DateGroup.Previous7Days;
        if (date >= now.AddDays(-30))
            return DateGroup.Previous30Days;
        return DateGroup.Older;
    }
}

public enum DateGroup
{
    Today,
    Yesterday,
    Previous7Days,
    Previous30Days,
    Older
}
```

### IConversationService Interface (Updated)

```csharp
namespace SeniorIntern.Core.Interfaces;

using SeniorIntern.Core.Models;

/// <summary>
/// Service for managing conversations
/// </summary>
public interface IConversationService
{
    // === Current Conversation State ===

    /// <summary>
    /// The currently active conversation
    /// </summary>
    Conversation CurrentConversation { get; }

    /// <summary>
    /// Whether there are unsaved changes
    /// </summary>
    bool HasUnsavedChanges { get; }

    /// <summary>
    /// Whether a conversation is currently loaded
    /// </summary>
    bool HasActiveConversation { get; }

    // === Message Operations ===

    /// <summary>
    /// Add a message to the current conversation
    /// </summary>
    void AddMessage(ChatMessage message);

    /// <summary>
    /// Update an existing message
    /// </summary>
    void UpdateMessage(Guid messageId, Action<ChatMessage> updateAction);

    /// <summary>
    /// Remove a message from the current conversation
    /// </summary>
    void RemoveMessage(Guid messageId);

    /// <summary>
    /// Get all messages in the current conversation
    /// </summary>
    IReadOnlyList<ChatMessage> GetMessages();

    // === Conversation Operations ===

    /// <summary>
    /// Create a new conversation and set it as current
    /// </summary>
    Task<Conversation> CreateNewConversationAsync(
        string? title = null,
        Guid? systemPromptId = null,
        CancellationToken ct = default);

    /// <summary>
    /// Load an existing conversation by ID
    /// </summary>
    Task<Conversation> LoadConversationAsync(
        Guid conversationId,
        CancellationToken ct = default);

    /// <summary>
    /// Save the current conversation to the database
    /// </summary>
    Task SaveCurrentConversationAsync(CancellationToken ct = default);

    /// <summary>
    /// Delete a conversation
    /// </summary>
    Task DeleteConversationAsync(Guid conversationId, CancellationToken ct = default);

    /// <summary>
    /// Rename a conversation
    /// </summary>
    Task RenameConversationAsync(
        Guid conversationId,
        string newTitle,
        CancellationToken ct = default);

    /// <summary>
    /// Archive a conversation (soft delete)
    /// </summary>
    Task ArchiveConversationAsync(Guid conversationId, CancellationToken ct = default);

    /// <summary>
    /// Unarchive a conversation
    /// </summary>
    Task UnarchiveConversationAsync(Guid conversationId, CancellationToken ct = default);

    /// <summary>
    /// Pin a conversation to the top
    /// </summary>
    Task PinConversationAsync(Guid conversationId, CancellationToken ct = default);

    /// <summary>
    /// Unpin a conversation
    /// </summary>
    Task UnpinConversationAsync(Guid conversationId, CancellationToken ct = default);

    // === List Operations ===

    /// <summary>
    /// Get recent conversations for the sidebar
    /// </summary>
    Task<IReadOnlyList<ConversationSummary>> GetRecentConversationsAsync(
        int count = 50,
        bool includeArchived = false,
        CancellationToken ct = default);

    /// <summary>
    /// Search conversations by title or content
    /// </summary>
    Task<IReadOnlyList<ConversationSummary>> SearchConversationsAsync(
        string query,
        CancellationToken ct = default);

    // === Events ===

    /// <summary>
    /// Fired when the current conversation changes (loaded, created, modified)
    /// </summary>
    event EventHandler<ConversationChangedEventArgs>? ConversationChanged;

    /// <summary>
    /// Fired when the conversation list should be refreshed
    /// </summary>
    event EventHandler<ConversationListChangedEventArgs>? ConversationListChanged;

    /// <summary>
    /// Fired when save state changes
    /// </summary>
    event EventHandler<SaveStateChangedEventArgs>? SaveStateChanged;
}
```

### Event Args

```csharp
namespace SeniorIntern.Core.Events;

using SeniorIntern.Core.Models;

/// <summary>
/// Event args for conversation changes
/// </summary>
public sealed class ConversationChangedEventArgs : EventArgs
{
    public required Conversation Conversation { get; init; }
    public required ConversationChangeType ChangeType { get; init; }
    public Guid? PreviousConversationId { get; init; }
}

public enum ConversationChangeType
{
    Created,
    Loaded,
    MessageAdded,
    MessageUpdated,
    MessageRemoved,
    TitleChanged,
    Saved,
    Cleared
}

/// <summary>
/// Event args for conversation list changes
/// </summary>
public sealed class ConversationListChangedEventArgs : EventArgs
{
    public required ConversationListChangeType ChangeType { get; init; }
    public Guid? AffectedConversationId { get; init; }
}

public enum ConversationListChangeType
{
    ConversationAdded,
    ConversationRemoved,
    ConversationUpdated,
    ListRefreshed
}

/// <summary>
/// Event args for save state changes
/// </summary>
public sealed class SaveStateChangedEventArgs : EventArgs
{
    public required bool IsSaving { get; init; }
    public required bool HasUnsavedChanges { get; init; }
    public DateTime? LastSavedAt { get; init; }
    public string? Error { get; init; }
}
```

### DatabaseConversationService Implementation

```csharp
namespace SeniorIntern.Services;

using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Entities;
using SeniorIntern.Core.Enums;
using SeniorIntern.Core.Events;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Data.Repositories;
using System.Timers;

/// <summary>
/// Conversation service backed by SQLite database
/// </summary>
public sealed class DatabaseConversationService : IConversationService, IDisposable
{
    private readonly IConversationRepository _repository;
    private readonly ISystemPromptRepository _systemPromptRepository;
    private readonly ILogger<DatabaseConversationService> _logger;

    private Conversation _currentConversation = new();
    private readonly System.Timers.Timer _autoSaveTimer;
    private readonly SemaphoreSlim _saveLock = new(1, 1);
    private bool _isDisposed;
    private DateTime? _lastSavedAt;

    private const int AutoSaveDelayMs = 500;
    private const int TitleMaxLength = 50;

    public Conversation CurrentConversation => _currentConversation;
    public bool HasUnsavedChanges => _currentConversation.HasUnsavedChanges;
    public bool HasActiveConversation => _currentConversation.IsPersisted ||
                                         _currentConversation.Messages.Count > 0;

    public event EventHandler<ConversationChangedEventArgs>? ConversationChanged;
    public event EventHandler<ConversationListChangedEventArgs>? ConversationListChanged;
    public event EventHandler<SaveStateChangedEventArgs>? SaveStateChanged;

    public DatabaseConversationService(
        IConversationRepository repository,
        ISystemPromptRepository systemPromptRepository,
        ILogger<DatabaseConversationService> logger)
    {
        _repository = repository;
        _systemPromptRepository = systemPromptRepository;
        _logger = logger;

        // Setup auto-save timer
        _autoSaveTimer = new System.Timers.Timer(AutoSaveDelayMs)
        {
            AutoReset = false
        };
        _autoSaveTimer.Elapsed += OnAutoSaveTimerElapsed;
    }

    // === Message Operations ===

    public void AddMessage(ChatMessage message)
    {
        _currentConversation.AddMessage(message);

        // Auto-generate title from first user message
        if (_currentConversation.Messages.Count == 1 &&
            message.Role == MessageRole.User &&
            _currentConversation.Title == "New Conversation")
        {
            _currentConversation.Title = GenerateTitle(message.Content);
        }

        OnConversationChanged(ConversationChangeType.MessageAdded);
        ScheduleAutoSave();
    }

    public void UpdateMessage(Guid messageId, Action<ChatMessage> updateAction)
    {
        _currentConversation.UpdateMessage(messageId, updateAction);
        OnConversationChanged(ConversationChangeType.MessageUpdated);
        ScheduleAutoSave();
    }

    public void RemoveMessage(Guid messageId)
    {
        _currentConversation.RemoveMessage(messageId);
        OnConversationChanged(ConversationChangeType.MessageRemoved);
        ScheduleAutoSave();
    }

    public IReadOnlyList<ChatMessage> GetMessages()
    {
        return _currentConversation.Messages;
    }

    // === Conversation Operations ===

    public async Task<Conversation> CreateNewConversationAsync(
        string? title = null,
        Guid? systemPromptId = null,
        CancellationToken ct = default)
    {
        // Save current if has unsaved changes
        if (_currentConversation.HasUnsavedChanges)
        {
            await SaveCurrentConversationAsync(ct);
        }

        var previousId = _currentConversation.IsPersisted ? _currentConversation.Id : (Guid?)null;

        // Create new conversation
        _currentConversation = new Conversation
        {
            Id = Guid.NewGuid(),
            Title = title ?? "New Conversation",
            SystemPromptId = systemPromptId,
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };

        // Load system prompt name if specified
        if (systemPromptId.HasValue)
        {
            var prompt = await _systemPromptRepository.GetByIdAsync(systemPromptId.Value, ct);
            _currentConversation.SystemPromptName = prompt?.Name;
        }

        _logger.LogDebug("Created new conversation {Id}", _currentConversation.Id);

        OnConversationChanged(ConversationChangeType.Created, previousId);

        return _currentConversation;
    }

    public async Task<Conversation> LoadConversationAsync(
        Guid conversationId,
        CancellationToken ct = default)
    {
        // Save current if has unsaved changes
        if (_currentConversation.HasUnsavedChanges)
        {
            await SaveCurrentConversationAsync(ct);
        }

        var previousId = _currentConversation.IsPersisted ? _currentConversation.Id : (Guid?)null;

        // Load from database
        var entity = await _repository.GetByIdWithMessagesAsync(conversationId, ct);
        if (entity == null)
        {
            throw new InvalidOperationException($"Conversation {conversationId} not found");
        }

        // Map to domain model
        _currentConversation = MapToDomain(entity);

        _logger.LogDebug("Loaded conversation {Id}: {Title}",
            _currentConversation.Id, _currentConversation.Title);

        OnConversationChanged(ConversationChangeType.Loaded, previousId);

        return _currentConversation;
    }

    public async Task SaveCurrentConversationAsync(CancellationToken ct = default)
    {
        if (!_currentConversation.HasUnsavedChanges && _currentConversation.IsPersisted)
        {
            return; // Nothing to save
        }

        await _saveLock.WaitAsync(ct);
        try
        {
            OnSaveStateChanged(isSaving: true);

            var entity = MapToEntity(_currentConversation);

            if (_currentConversation.IsPersisted)
            {
                // Update existing
                await _repository.UpdateAsync(entity, ct);

                // Sync messages
                await SyncMessagesAsync(entity.Id, ct);
            }
            else
            {
                // Create new
                await _repository.CreateAsync(entity, ct);
                _currentConversation.IsPersisted = true;

                // Add all messages
                foreach (var message in _currentConversation.Messages)
                {
                    var messageEntity = MapMessageToEntity(message, entity.Id);
                    await _repository.AddMessageAsync(entity.Id, messageEntity, ct);
                }

                OnConversationListChanged(ConversationListChangeType.ConversationAdded, entity.Id);
            }

            _currentConversation.MarkAsSaved();
            _lastSavedAt = DateTime.UtcNow;

            OnSaveStateChanged(isSaving: false);
            OnConversationChanged(ConversationChangeType.Saved);

            _logger.LogDebug("Saved conversation {Id}", _currentConversation.Id);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to save conversation {Id}", _currentConversation.Id);
            OnSaveStateChanged(isSaving: false, error: ex.Message);
            throw;
        }
        finally
        {
            _saveLock.Release();
        }
    }

    public async Task DeleteConversationAsync(Guid conversationId, CancellationToken ct = default)
    {
        await _repository.DeleteAsync(conversationId, ct);

        // If deleting current conversation, create a new one
        if (_currentConversation.Id == conversationId)
        {
            await CreateNewConversationAsync(ct: ct);
        }

        OnConversationListChanged(ConversationListChangeType.ConversationRemoved, conversationId);

        _logger.LogDebug("Deleted conversation {Id}", conversationId);
    }

    public async Task RenameConversationAsync(
        Guid conversationId,
        string newTitle,
        CancellationToken ct = default)
    {
        var entity = await _repository.GetByIdAsync(conversationId, ct);
        if (entity == null)
            return;

        entity.Title = newTitle.Trim();
        await _repository.UpdateAsync(entity, ct);

        // Update in-memory if current
        if (_currentConversation.Id == conversationId)
        {
            _currentConversation.Title = newTitle.Trim();
            OnConversationChanged(ConversationChangeType.TitleChanged);
        }

        OnConversationListChanged(ConversationListChangeType.ConversationUpdated, conversationId);

        _logger.LogDebug("Renamed conversation {Id} to {Title}", conversationId, newTitle);
    }

    public async Task ArchiveConversationAsync(Guid conversationId, CancellationToken ct = default)
    {
        await _repository.ArchiveAsync(conversationId, ct);

        if (_currentConversation.Id == conversationId)
        {
            _currentConversation.IsArchived = true;
        }

        OnConversationListChanged(ConversationListChangeType.ConversationRemoved, conversationId);
    }

    public async Task UnarchiveConversationAsync(Guid conversationId, CancellationToken ct = default)
    {
        await _repository.UnarchiveAsync(conversationId, ct);
        OnConversationListChanged(ConversationListChangeType.ConversationAdded, conversationId);
    }

    public async Task PinConversationAsync(Guid conversationId, CancellationToken ct = default)
    {
        await _repository.PinAsync(conversationId, ct);

        if (_currentConversation.Id == conversationId)
        {
            _currentConversation.IsPinned = true;
        }

        OnConversationListChanged(ConversationListChangeType.ConversationUpdated, conversationId);
    }

    public async Task UnpinConversationAsync(Guid conversationId, CancellationToken ct = default)
    {
        await _repository.UnpinAsync(conversationId, ct);

        if (_currentConversation.Id == conversationId)
        {
            _currentConversation.IsPinned = false;
        }

        OnConversationListChanged(ConversationListChangeType.ConversationUpdated, conversationId);
    }

    // === List Operations ===

    public async Task<IReadOnlyList<ConversationSummary>> GetRecentConversationsAsync(
        int count = 50,
        bool includeArchived = false,
        CancellationToken ct = default)
    {
        var entities = await _repository.GetRecentAsync(count, includeArchived, ct);
        return entities.Select(MapToSummary).ToList();
    }

    public async Task<IReadOnlyList<ConversationSummary>> SearchConversationsAsync(
        string query,
        CancellationToken ct = default)
    {
        if (string.IsNullOrWhiteSpace(query))
        {
            return await GetRecentConversationsAsync(ct: ct);
        }

        var entities = await _repository.SearchAsync(query, ct: ct);
        return entities.Select(MapToSummary).ToList();
    }

    // === Auto-Save ===

    private void ScheduleAutoSave()
    {
        _autoSaveTimer.Stop();
        _autoSaveTimer.Start();

        OnSaveStateChanged(isSaving: false, hasUnsavedChanges: true);
    }

    private async void OnAutoSaveTimerElapsed(object? sender, ElapsedEventArgs e)
    {
        if (_currentConversation.HasUnsavedChanges &&
            _currentConversation.Messages.Count > 0)
        {
            try
            {
                await SaveCurrentConversationAsync();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Auto-save failed");
            }
        }
    }

    // === Mapping ===

    private Conversation MapToDomain(ConversationEntity entity)
    {
        var conversation = new Conversation
        {
            Id = entity.Id,
            Title = entity.Title,
            CreatedAt = entity.CreatedAt,
            UpdatedAt = entity.UpdatedAt,
            SystemPromptId = entity.SystemPromptId,
            SystemPromptName = entity.SystemPrompt?.Name,
            ModelPath = entity.ModelPath,
            ModelName = entity.ModelName,
            IsArchived = entity.IsArchived,
            IsPinned = entity.IsPinned,
            IsPersisted = true,
            HasUnsavedChanges = false
        };

        if (entity.Messages.Any())
        {
            var messages = entity.Messages
                .OrderBy(m => m.SequenceNumber)
                .Select(MapMessageToDomain);
            conversation.LoadMessages(messages);
        }

        return conversation;
    }

    private ConversationEntity MapToEntity(Conversation conversation)
    {
        return new ConversationEntity
        {
            Id = conversation.Id,
            Title = conversation.Title,
            CreatedAt = conversation.CreatedAt,
            UpdatedAt = conversation.UpdatedAt,
            SystemPromptId = conversation.SystemPromptId,
            ModelPath = conversation.ModelPath,
            ModelName = conversation.ModelName,
            IsArchived = conversation.IsArchived,
            IsPinned = conversation.IsPinned,
            MessageCount = conversation.Messages.Count,
            TotalTokenCount = conversation.Messages.Sum(m => m.TokenCount ?? 0)
        };
    }

    private ChatMessage MapMessageToDomain(MessageEntity entity)
    {
        return new ChatMessage
        {
            Id = entity.Id,
            Role = entity.Role,
            Content = entity.Content,
            Timestamp = entity.Timestamp,
            TokenCount = entity.TokenCount,
            GenerationTimeMs = entity.GenerationTimeMs,
            TokensPerSecond = entity.TokensPerSecond,
            SequenceNumber = entity.SequenceNumber,
            IsComplete = entity.IsComplete,
            IsEdited = entity.IsEdited
        };
    }

    private MessageEntity MapMessageToEntity(ChatMessage message, Guid conversationId)
    {
        return new MessageEntity
        {
            Id = message.Id,
            ConversationId = conversationId,
            Role = message.Role,
            Content = message.Content,
            Timestamp = message.Timestamp,
            TokenCount = message.TokenCount,
            GenerationTimeMs = message.GenerationTimeMs,
            TokensPerSecond = message.TokensPerSecond,
            SequenceNumber = message.SequenceNumber,
            IsComplete = message.IsComplete,
            IsEdited = message.IsEdited
        };
    }

    private ConversationSummary MapToSummary(ConversationEntity entity)
    {
        var firstUserMessage = entity.Messages
            .Where(m => m.Role == MessageRole.User)
            .OrderBy(m => m.SequenceNumber)
            .FirstOrDefault();

        return new ConversationSummary
        {
            Id = entity.Id,
            Title = entity.Title,
            CreatedAt = entity.CreatedAt,
            UpdatedAt = entity.UpdatedAt,
            MessageCount = entity.MessageCount,
            Preview = TruncatePreview(firstUserMessage?.Content, 80),
            IsArchived = entity.IsArchived,
            IsPinned = entity.IsPinned,
            ModelName = entity.ModelName
        };
    }

    // === Helpers ===

    private async Task SyncMessagesAsync(Guid conversationId, CancellationToken ct)
    {
        // Get existing messages from DB
        var existingMessages = await _repository.GetMessagesAsync(conversationId, ct: ct);
        var existingIds = existingMessages.Select(m => m.Id).ToHashSet();
        var currentIds = _currentConversation.Messages.Select(m => m.Id).ToHashSet();

        // Add new messages
        foreach (var message in _currentConversation.Messages)
        {
            if (!existingIds.Contains(message.Id))
            {
                var entity = MapMessageToEntity(message, conversationId);
                await _repository.AddMessageAsync(conversationId, entity, ct);
            }
            else
            {
                // Update existing (for streaming completion, edits)
                var entity = MapMessageToEntity(message, conversationId);
                await _repository.UpdateMessageAsync(entity, ct);
            }
        }

        // Note: We don't delete messages that were removed from memory
        // This could be added if needed
    }

    private static string GenerateTitle(string content)
    {
        if (string.IsNullOrWhiteSpace(content))
            return "New Conversation";

        // Clean up the content
        var cleaned = content
            .Replace("\n", " ")
            .Replace("\r", " ")
            .Trim();

        if (cleaned.Length <= TitleMaxLength)
            return cleaned;

        // Find last word boundary
        var truncated = cleaned[..TitleMaxLength];
        var lastSpace = truncated.LastIndexOf(' ');

        if (lastSpace > TitleMaxLength / 2)
            return truncated[..lastSpace] + "...";

        return truncated + "...";
    }

    private static string? TruncatePreview(string? content, int maxLength)
    {
        if (string.IsNullOrWhiteSpace(content))
            return null;

        var cleaned = content.Replace("\n", " ").Replace("\r", " ").Trim();

        if (cleaned.Length <= maxLength)
            return cleaned;

        return cleaned[..maxLength] + "...";
    }

    // === Events ===

    private void OnConversationChanged(ConversationChangeType changeType, Guid? previousId = null)
    {
        ConversationChanged?.Invoke(this, new ConversationChangedEventArgs
        {
            Conversation = _currentConversation,
            ChangeType = changeType,
            PreviousConversationId = previousId
        });
    }

    private void OnConversationListChanged(ConversationListChangeType changeType, Guid? conversationId = null)
    {
        ConversationListChanged?.Invoke(this, new ConversationListChangedEventArgs
        {
            ChangeType = changeType,
            AffectedConversationId = conversationId
        });
    }

    private void OnSaveStateChanged(bool isSaving, bool? hasUnsavedChanges = null, string? error = null)
    {
        SaveStateChanged?.Invoke(this, new SaveStateChangedEventArgs
        {
            IsSaving = isSaving,
            HasUnsavedChanges = hasUnsavedChanges ?? _currentConversation.HasUnsavedChanges,
            LastSavedAt = _lastSavedAt,
            Error = error
        });
    }

    public void Dispose()
    {
        if (_isDisposed) return;
        _isDisposed = true;

        _autoSaveTimer.Stop();
        _autoSaveTimer.Elapsed -= OnAutoSaveTimerElapsed;
        _autoSaveTimer.Dispose();
        _saveLock.Dispose();
    }
}
```

### v0.2.2a Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Models/ConversationSummary.cs` | Summary model for list display |
| `src/SeniorIntern.Core/Events/ConversationChangedEventArgs.cs` | Conversation change events |
| `src/SeniorIntern.Core/Events/ConversationListChangedEventArgs.cs` | List change events |
| `src/SeniorIntern.Core/Events/SaveStateChangedEventArgs.cs` | Save state events |
| `src/SeniorIntern.Services/DatabaseConversationService.cs` | Service implementation |

### v0.2.2a Files to Modify

| File | Changes |
|------|---------|
| `src/SeniorIntern.Core/Models/Conversation.cs` | Add persistence-related properties |
| `src/SeniorIntern.Core/Interfaces/IConversationService.cs` | Update interface |

---

## v0.2.2b: ViewModels

### Objective
Create the ViewModels for the conversation list, including grouping logic, selection handling, and context menu commands.

### ConversationListViewModel

```csharp
namespace SeniorIntern.Desktop.ViewModels;

using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using SeniorIntern.Core.Events;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using System.Collections.ObjectModel;
using System.Collections.Specialized;

/// <summary>
/// ViewModel for the conversation list in the sidebar
/// </summary>
public partial class ConversationListViewModel : ViewModelBase, IDisposable
{
    private readonly IConversationService _conversationService;
    private readonly IDispatcher _dispatcher;
    private CancellationTokenSource? _searchCts;

    [ObservableProperty]
    private ObservableCollection<ConversationGroupViewModel> _groups = new();

    [ObservableProperty]
    private ConversationSummaryViewModel? _selectedConversation;

    [ObservableProperty]
    private string _searchQuery = string.Empty;

    [ObservableProperty]
    private bool _isLoading;

    [ObservableProperty]
    private bool _isEmpty;

    [ObservableProperty]
    private bool _isSearching;

    [ObservableProperty]
    private string? _errorMessage;

    public ConversationListViewModel(
        IConversationService conversationService,
        IDispatcher dispatcher)
    {
        _conversationService = conversationService;
        _dispatcher = dispatcher;

        // Subscribe to service events
        _conversationService.ConversationListChanged += OnConversationListChanged;
        _conversationService.ConversationChanged += OnConversationChanged;
    }

    /// <summary>
    /// Initialize and load conversations
    /// </summary>
    public async Task InitializeAsync()
    {
        await LoadConversationsAsync();
    }

    /// <summary>
    /// Load conversations from the database
    /// </summary>
    [RelayCommand]
    private async Task LoadConversationsAsync()
    {
        try
        {
            IsLoading = true;
            ErrorMessage = null;

            var conversations = await _conversationService.GetRecentConversationsAsync();
            await _dispatcher.InvokeAsync(() =>
            {
                UpdateGroups(conversations);
                UpdateSelection();
            });
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Failed to load conversations: {ex.Message}";
        }
        finally
        {
            IsLoading = false;
        }
    }

    /// <summary>
    /// Create a new conversation
    /// </summary>
    [RelayCommand]
    private async Task CreateNewConversationAsync()
    {
        try
        {
            var conversation = await _conversationService.CreateNewConversationAsync();
            // Selection will be updated via event
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Failed to create conversation: {ex.Message}";
        }
    }

    /// <summary>
    /// Select and load a conversation
    /// </summary>
    [RelayCommand]
    private async Task SelectConversationAsync(ConversationSummaryViewModel? summary)
    {
        if (summary == null || summary.Id == _conversationService.CurrentConversation.Id)
            return;

        try
        {
            IsLoading = true;
            await _conversationService.LoadConversationAsync(summary.Id);
            SelectedConversation = summary;
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Failed to load conversation: {ex.Message}";
        }
        finally
        {
            IsLoading = false;
        }
    }

    /// <summary>
    /// Delete a conversation
    /// </summary>
    [RelayCommand]
    private async Task DeleteConversationAsync(ConversationSummaryViewModel summary)
    {
        try
        {
            await _conversationService.DeleteConversationAsync(summary.Id);
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Failed to delete conversation: {ex.Message}";
        }
    }

    /// <summary>
    /// Rename a conversation
    /// </summary>
    [RelayCommand]
    private async Task RenameConversationAsync(ConversationSummaryViewModel summary)
    {
        // This will be triggered from the UI rename dialog
        // The actual rename happens via ConfirmRenameAsync
        summary.IsRenaming = true;
        summary.EditingTitle = summary.Title;
    }

    /// <summary>
    /// Confirm the rename operation
    /// </summary>
    [RelayCommand]
    private async Task ConfirmRenameAsync(ConversationSummaryViewModel summary)
    {
        if (summary.EditingTitle == summary.Title)
        {
            summary.IsRenaming = false;
            return;
        }

        try
        {
            await _conversationService.RenameConversationAsync(
                summary.Id,
                summary.EditingTitle);
            summary.Title = summary.EditingTitle;
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Failed to rename conversation: {ex.Message}";
        }
        finally
        {
            summary.IsRenaming = false;
        }
    }

    /// <summary>
    /// Cancel the rename operation
    /// </summary>
    [RelayCommand]
    private void CancelRename(ConversationSummaryViewModel summary)
    {
        summary.IsRenaming = false;
        summary.EditingTitle = summary.Title;
    }

    /// <summary>
    /// Archive a conversation
    /// </summary>
    [RelayCommand]
    private async Task ArchiveConversationAsync(ConversationSummaryViewModel summary)
    {
        try
        {
            await _conversationService.ArchiveConversationAsync(summary.Id);
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Failed to archive conversation: {ex.Message}";
        }
    }

    /// <summary>
    /// Pin a conversation
    /// </summary>
    [RelayCommand]
    private async Task TogglePinAsync(ConversationSummaryViewModel summary)
    {
        try
        {
            if (summary.IsPinned)
            {
                await _conversationService.UnpinConversationAsync(summary.Id);
                summary.IsPinned = false;
            }
            else
            {
                await _conversationService.PinConversationAsync(summary.Id);
                summary.IsPinned = true;
            }
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Failed to update pin status: {ex.Message}";
        }
    }

    /// <summary>
    /// Search conversations (with debouncing)
    /// </summary>
    partial void OnSearchQueryChanged(string value)
    {
        // Cancel previous search
        _searchCts?.Cancel();
        _searchCts = new CancellationTokenSource();

        // Debounce 300ms
        _ = SearchWithDebounceAsync(value, _searchCts.Token);
    }

    private async Task SearchWithDebounceAsync(string query, CancellationToken ct)
    {
        try
        {
            await Task.Delay(300, ct);

            if (ct.IsCancellationRequested)
                return;

            IsSearching = !string.IsNullOrWhiteSpace(query);

            var conversations = await _conversationService.SearchConversationsAsync(query, ct);

            if (ct.IsCancellationRequested)
                return;

            await _dispatcher.InvokeAsync(() => UpdateGroups(conversations));
        }
        catch (OperationCanceledException)
        {
            // Expected when cancelled
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Search failed: {ex.Message}";
        }
    }

    /// <summary>
    /// Clear the search
    /// </summary>
    [RelayCommand]
    private void ClearSearch()
    {
        SearchQuery = string.Empty;
    }

    // === Helper Methods ===

    private void UpdateGroups(IReadOnlyList<ConversationSummary> conversations)
    {
        Groups.Clear();

        if (!conversations.Any())
        {
            IsEmpty = true;
            return;
        }

        IsEmpty = false;

        // Group by date
        var grouped = conversations
            .GroupBy(c => c.GetDateGroup())
            .OrderBy(g => g.Key);

        foreach (var group in grouped)
        {
            var groupVm = new ConversationGroupViewModel
            {
                DateGroup = group.Key,
                Title = GetGroupTitle(group.Key),
                IsExpanded = true
            };

            foreach (var conv in group.OrderByDescending(c => c.IsPinned).ThenByDescending(c => c.UpdatedAt))
            {
                groupVm.Conversations.Add(new ConversationSummaryViewModel
                {
                    Id = conv.Id,
                    Title = conv.Title,
                    UpdatedAt = conv.UpdatedAt,
                    MessageCount = conv.MessageCount,
                    Preview = conv.Preview,
                    IsPinned = conv.IsPinned,
                    ModelName = conv.ModelName
                });
            }

            Groups.Add(groupVm);
        }
    }

    private void UpdateSelection()
    {
        var currentId = _conversationService.CurrentConversation.Id;

        foreach (var group in Groups)
        {
            foreach (var conv in group.Conversations)
            {
                conv.IsSelected = conv.Id == currentId;
                if (conv.IsSelected)
                {
                    SelectedConversation = conv;
                }
            }
        }
    }

    private static string GetGroupTitle(DateGroup group) => group switch
    {
        DateGroup.Today => "Today",
        DateGroup.Yesterday => "Yesterday",
        DateGroup.Previous7Days => "Previous 7 Days",
        DateGroup.Previous30Days => "Previous 30 Days",
        DateGroup.Older => "Older",
        _ => "Other"
    };

    // === Event Handlers ===

    private async void OnConversationListChanged(object? sender, ConversationListChangedEventArgs e)
    {
        await _dispatcher.InvokeAsync(async () =>
        {
            await LoadConversationsAsync();
        });
    }

    private void OnConversationChanged(object? sender, ConversationChangedEventArgs e)
    {
        _dispatcher.InvokeAsync(() =>
        {
            // Update selection when conversation changes
            if (e.ChangeType == ConversationChangeType.Loaded ||
                e.ChangeType == ConversationChangeType.Created)
            {
                UpdateSelection();
            }
        });
    }

    public void Dispose()
    {
        _conversationService.ConversationListChanged -= OnConversationListChanged;
        _conversationService.ConversationChanged -= OnConversationChanged;
        _searchCts?.Cancel();
        _searchCts?.Dispose();
    }
}
```

### ConversationGroupViewModel

```csharp
namespace SeniorIntern.Desktop.ViewModels;

using CommunityToolkit.Mvvm.ComponentModel;
using SeniorIntern.Core.Models;
using System.Collections.ObjectModel;

/// <summary>
/// ViewModel for a group of conversations (by date)
/// </summary>
public partial class ConversationGroupViewModel : ViewModelBase
{
    public DateGroup DateGroup { get; init; }

    [ObservableProperty]
    private string _title = string.Empty;

    [ObservableProperty]
    private bool _isExpanded = true;

    public ObservableCollection<ConversationSummaryViewModel> Conversations { get; } = new();

    public int Count => Conversations.Count;
}
```

### ConversationSummaryViewModel

```csharp
namespace SeniorIntern.Desktop.ViewModels;

using CommunityToolkit.Mvvm.ComponentModel;

/// <summary>
/// ViewModel for a single conversation in the list
/// </summary>
public partial class ConversationSummaryViewModel : ViewModelBase
{
    public Guid Id { get; init; }

    [ObservableProperty]
    private string _title = string.Empty;

    [ObservableProperty]
    private DateTime _updatedAt;

    [ObservableProperty]
    private int _messageCount;

    [ObservableProperty]
    private string? _preview;

    [ObservableProperty]
    private bool _isSelected;

    [ObservableProperty]
    private bool _isPinned;

    [ObservableProperty]
    private string? _modelName;

    [ObservableProperty]
    private bool _isRenaming;

    [ObservableProperty]
    private string _editingTitle = string.Empty;

    /// <summary>
    /// Gets a human-readable relative time
    /// </summary>
    public string RelativeTime => GetRelativeTime(UpdatedAt);

    /// <summary>
    /// Gets the message count display text
    /// </summary>
    public string MessageCountText => MessageCount switch
    {
        0 => "No messages",
        1 => "1 message",
        _ => $"{MessageCount} messages"
    };

    private static string GetRelativeTime(DateTime dateTime)
    {
        var now = DateTime.UtcNow;
        var diff = now - dateTime;

        if (diff.TotalMinutes < 1)
            return "Just now";
        if (diff.TotalMinutes < 60)
            return $"{(int)diff.TotalMinutes}m ago";
        if (diff.TotalHours < 24)
            return $"{(int)diff.TotalHours}h ago";
        if (diff.TotalDays < 7)
            return $"{(int)diff.TotalDays}d ago";
        if (diff.TotalDays < 30)
            return $"{(int)(diff.TotalDays / 7)}w ago";

        return dateTime.ToString("MMM d");
    }
}
```

### IDispatcher Interface

```csharp
namespace SeniorIntern.Desktop;

/// <summary>
/// Abstraction for UI thread dispatching
/// </summary>
public interface IDispatcher
{
    /// <summary>
    /// Invoke an action on the UI thread
    /// </summary>
    Task InvokeAsync(Action action);

    /// <summary>
    /// Invoke a function on the UI thread
    /// </summary>
    Task<T> InvokeAsync<T>(Func<T> func);

    /// <summary>
    /// Invoke an async action on the UI thread
    /// </summary>
    Task InvokeAsync(Func<Task> action);
}

/// <summary>
/// Avalonia implementation of IDispatcher
/// </summary>
public sealed class AvaloniaDispatcher : IDispatcher
{
    public async Task InvokeAsync(Action action)
    {
        await Avalonia.Threading.Dispatcher.UIThread.InvokeAsync(action);
    }

    public async Task<T> InvokeAsync<T>(Func<T> func)
    {
        return await Avalonia.Threading.Dispatcher.UIThread.InvokeAsync(func);
    }

    public async Task InvokeAsync(Func<Task> action)
    {
        await Avalonia.Threading.Dispatcher.UIThread.InvokeAsync(action);
    }
}
```

### v0.2.2b Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/ViewModels/ConversationListViewModel.cs` | List ViewModel |
| `src/SeniorIntern.Desktop/ViewModels/ConversationGroupViewModel.cs` | Group ViewModel |
| `src/SeniorIntern.Desktop/ViewModels/ConversationSummaryViewModel.cs` | Item ViewModel |
| `src/SeniorIntern.Desktop/IDispatcher.cs` | UI thread abstraction |
| `src/SeniorIntern.Desktop/AvaloniaDispatcher.cs` | Avalonia dispatcher implementation |

---

## v0.2.2c: Conversation List UI

### Objective
Create the ConversationListView XAML with grouped list, search box, context menu, and keyboard navigation.

### ConversationListView Layout

```
┌─────────────────────────────────────────────────────────────────┐
│  Conversations                                    [+] New       │
├─────────────────────────────────────────────────────────────────┤
│  ┌───────────────────────────────────────────────────────────┐  │
│  │ 🔍 Search conversations...                          [×]   │  │
│  └───────────────────────────────────────────────────────────┘  │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ▾ Today                                                         │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │ 📌 API refactoring help                                   │  │
│  │    Help me refactor the authentication API...   2m ago    │  │
│  │    3 messages                                             │  │
│  └───────────────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │ Debug memory leak                                [●]      │  │ ← Selected
│  │    I'm seeing a memory leak in my service...    1h ago    │  │
│  │    12 messages                                            │  │
│  └───────────────────────────────────────────────────────────┘  │
│                                                                  │
│  ▾ Yesterday                                                     │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │ Project setup questions                                   │  │
│  │    How do I configure the build process...      23h ago   │  │
│  │    8 messages                                             │  │
│  └───────────────────────────────────────────────────────────┘  │
│                                                                  │
│  ▸ Previous 7 Days (2)                                           │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### ConversationListView.axaml

```xml
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:vm="using:SeniorIntern.Desktop.ViewModels"
             xmlns:controls="using:SeniorIntern.Desktop.Controls"
             x:Class="SeniorIntern.Desktop.Views.ConversationListView"
             x:DataType="vm:ConversationListViewModel">

    <UserControl.Resources>
        <!-- Conversation Item Template -->
        <DataTemplate x:Key="ConversationItemTemplate" x:DataType="vm:ConversationSummaryViewModel">
            <Border Classes="conversation-item"
                    Classes.selected="{Binding IsSelected}"
                    Classes.pinned="{Binding IsPinned}"
                    Padding="12,8"
                    Margin="0,2"
                    CornerRadius="6"
                    Background="Transparent"
                    PointerPressed="OnConversationPointerPressed">

                <Border.ContextMenu>
                    <ContextMenu>
                        <MenuItem Header="Rename"
                                  Command="{Binding $parent[UserControl].((vm:ConversationListViewModel)DataContext).RenameConversationCommand}"
                                  CommandParameter="{Binding}">
                            <MenuItem.Icon>
                                <PathIcon Data="{StaticResource EditIcon}" />
                            </MenuItem.Icon>
                        </MenuItem>
                        <MenuItem Header="{Binding IsPinned, Converter={StaticResource PinTextConverter}}"
                                  Command="{Binding $parent[UserControl].((vm:ConversationListViewModel)DataContext).TogglePinCommand}"
                                  CommandParameter="{Binding}">
                            <MenuItem.Icon>
                                <PathIcon Data="{StaticResource PinIcon}" />
                            </MenuItem.Icon>
                        </MenuItem>
                        <Separator />
                        <MenuItem Header="Archive"
                                  Command="{Binding $parent[UserControl].((vm:ConversationListViewModel)DataContext).ArchiveConversationCommand}"
                                  CommandParameter="{Binding}">
                            <MenuItem.Icon>
                                <PathIcon Data="{StaticResource ArchiveIcon}" />
                            </MenuItem.Icon>
                        </MenuItem>
                        <MenuItem Header="Delete"
                                  Command="{Binding $parent[UserControl].((vm:ConversationListViewModel)DataContext).DeleteConversationCommand}"
                                  CommandParameter="{Binding}"
                                  Classes="destructive">
                            <MenuItem.Icon>
                                <PathIcon Data="{StaticResource DeleteIcon}" />
                            </MenuItem.Icon>
                        </MenuItem>
                    </ContextMenu>
                </Border.ContextMenu>

                <Grid RowDefinitions="Auto,Auto,Auto">
                    <!-- Title Row -->
                    <Grid Grid.Row="0" ColumnDefinitions="Auto,*,Auto">
                        <!-- Pin indicator -->
                        <PathIcon Grid.Column="0"
                                  Data="{StaticResource PinIcon}"
                                  Width="12" Height="12"
                                  Margin="0,0,6,0"
                                  IsVisible="{Binding IsPinned}"
                                  Foreground="{DynamicResource AccentColor}" />

                        <!-- Title (or edit box) -->
                        <TextBlock Grid.Column="1"
                                   Text="{Binding Title}"
                                   IsVisible="{Binding !IsRenaming}"
                                   FontWeight="SemiBold"
                                   TextTrimming="CharacterEllipsis" />

                        <TextBox Grid.Column="1"
                                 Text="{Binding EditingTitle, Mode=TwoWay}"
                                 IsVisible="{Binding IsRenaming}"
                                 Classes="inline-edit"
                                 KeyDown="OnRenameKeyDown"
                                 LostFocus="OnRenameLostFocus" />

                        <!-- Timestamp -->
                        <TextBlock Grid.Column="2"
                                   Text="{Binding RelativeTime}"
                                   FontSize="11"
                                   Foreground="{DynamicResource TextSecondaryColor}"
                                   VerticalAlignment="Center"
                                   Margin="8,0,0,0" />
                    </Grid>

                    <!-- Preview -->
                    <TextBlock Grid.Row="1"
                               Text="{Binding Preview}"
                               FontSize="12"
                               Foreground="{DynamicResource TextSecondaryColor}"
                               TextTrimming="CharacterEllipsis"
                               Margin="0,4,0,0"
                               IsVisible="{Binding Preview, Converter={x:Static StringConverters.IsNotNullOrEmpty}}" />

                    <!-- Message count -->
                    <TextBlock Grid.Row="2"
                               Text="{Binding MessageCountText}"
                               FontSize="11"
                               Foreground="{DynamicResource TextTertiaryColor}"
                               Margin="0,4,0,0" />
                </Grid>
            </Border>
        </DataTemplate>

        <!-- Group Header Template -->
        <DataTemplate x:Key="GroupHeaderTemplate" x:DataType="vm:ConversationGroupViewModel">
            <Expander IsExpanded="{Binding IsExpanded, Mode=TwoWay}"
                      Padding="8,4"
                      Classes="group-header">
                <Expander.Header>
                    <Grid ColumnDefinitions="*,Auto">
                        <TextBlock Text="{Binding Title}"
                                   FontWeight="SemiBold"
                                   FontSize="12"
                                   Foreground="{DynamicResource TextSecondaryColor}" />
                        <TextBlock Grid.Column="1"
                                   Text="{Binding Count}"
                                   FontSize="11"
                                   Foreground="{DynamicResource TextTertiaryColor}"
                                   Margin="8,0,0,0" />
                    </Grid>
                </Expander.Header>

                <ItemsControl ItemsSource="{Binding Conversations}"
                              ItemTemplate="{StaticResource ConversationItemTemplate}" />
            </Expander>
        </DataTemplate>
    </UserControl.Resources>

    <Grid RowDefinitions="Auto,Auto,*">
        <!-- Header -->
        <Grid Grid.Row="0"
              ColumnDefinitions="*,Auto"
              Margin="12,12,12,8">
            <TextBlock Text="Conversations"
                       FontWeight="Bold"
                       FontSize="14"
                       VerticalAlignment="Center" />

            <Button Grid.Column="1"
                    Command="{Binding CreateNewConversationCommand}"
                    ToolTip.Tip="New Conversation (Ctrl+N)"
                    Classes="icon-button">
                <PathIcon Data="{StaticResource PlusIcon}"
                          Width="16" Height="16" />
            </Button>
        </Grid>

        <!-- Search Box -->
        <Border Grid.Row="1"
                Margin="12,0,12,8"
                Padding="8,6"
                CornerRadius="6"
                Background="{DynamicResource ControlBackgroundColor}">
            <Grid ColumnDefinitions="Auto,*,Auto">
                <PathIcon Grid.Column="0"
                          Data="{StaticResource SearchIcon}"
                          Width="14" Height="14"
                          Foreground="{DynamicResource TextSecondaryColor}"
                          Margin="0,0,8,0" />

                <TextBox Grid.Column="1"
                         Text="{Binding SearchQuery, Mode=TwoWay}"
                         Watermark="Search conversations..."
                         Classes="borderless"
                         KeyDown="OnSearchKeyDown" />

                <Button Grid.Column="2"
                        Command="{Binding ClearSearchCommand}"
                        IsVisible="{Binding SearchQuery, Converter={x:Static StringConverters.IsNotNullOrEmpty}}"
                        Classes="icon-button small">
                    <PathIcon Data="{StaticResource CloseIcon}"
                              Width="12" Height="12" />
                </Button>
            </Grid>
        </Border>

        <!-- Conversation List -->
        <ScrollViewer Grid.Row="2"
                      HorizontalScrollBarVisibility="Disabled"
                      VerticalScrollBarVisibility="Auto">

            <Panel>
                <!-- Loading Indicator -->
                <StackPanel IsVisible="{Binding IsLoading}"
                            HorizontalAlignment="Center"
                            VerticalAlignment="Center"
                            Spacing="8">
                    <ProgressRing Width="24" Height="24" />
                    <TextBlock Text="Loading..."
                               FontSize="12"
                               Foreground="{DynamicResource TextSecondaryColor}" />
                </StackPanel>

                <!-- Empty State -->
                <StackPanel IsVisible="{Binding IsEmpty}"
                            HorizontalAlignment="Center"
                            VerticalAlignment="Center"
                            Margin="20"
                            Spacing="12">
                    <PathIcon Data="{StaticResource ChatIcon}"
                              Width="48" Height="48"
                              Foreground="{DynamicResource TextTertiaryColor}" />
                    <TextBlock Text="No conversations yet"
                               FontSize="14"
                               Foreground="{DynamicResource TextSecondaryColor}"
                               HorizontalAlignment="Center" />
                    <TextBlock Text="Start a new conversation to begin"
                               FontSize="12"
                               Foreground="{DynamicResource TextTertiaryColor}"
                               HorizontalAlignment="Center" />
                    <Button Content="New Conversation"
                            Command="{Binding CreateNewConversationCommand}"
                            HorizontalAlignment="Center"
                            Classes="accent"
                            Margin="0,8,0,0" />
                </StackPanel>

                <!-- Grouped List -->
                <ItemsControl ItemsSource="{Binding Groups}"
                              ItemTemplate="{StaticResource GroupHeaderTemplate}"
                              IsVisible="{Binding !IsEmpty}"
                              Margin="4,0" />
            </Panel>
        </ScrollViewer>

        <!-- Error Message -->
        <Border Grid.Row="2"
                IsVisible="{Binding ErrorMessage, Converter={x:Static StringConverters.IsNotNullOrEmpty}}"
                Background="{DynamicResource ErrorBackgroundColor}"
                Padding="12,8"
                Margin="12"
                CornerRadius="6"
                VerticalAlignment="Bottom">
            <TextBlock Text="{Binding ErrorMessage}"
                       Foreground="{DynamicResource ErrorForegroundColor}"
                       TextWrapping="Wrap" />
        </Border>
    </Grid>
</UserControl>
```

### ConversationListView.axaml.cs

```csharp
namespace SeniorIntern.Desktop.Views;

using Avalonia.Controls;
using Avalonia.Input;
using Avalonia.Interactivity;
using SeniorIntern.Desktop.ViewModels;

public partial class ConversationListView : UserControl
{
    public ConversationListView()
    {
        InitializeComponent();
    }

    private ConversationListViewModel? ViewModel => DataContext as ConversationListViewModel;

    private async void OnConversationPointerPressed(object? sender, PointerPressedEventArgs e)
    {
        if (sender is Border border &&
            border.DataContext is ConversationSummaryViewModel summary &&
            e.GetCurrentPoint(border).Properties.IsLeftButtonPressed)
        {
            // Don't select if renaming
            if (summary.IsRenaming)
                return;

            await ViewModel?.SelectConversationCommand.ExecuteAsync(summary)!;
        }
    }

    private async void OnRenameKeyDown(object? sender, KeyEventArgs e)
    {
        if (sender is TextBox textBox &&
            textBox.DataContext is ConversationSummaryViewModel summary)
        {
            if (e.Key == Key.Enter)
            {
                await ViewModel?.ConfirmRenameCommand.ExecuteAsync(summary)!;
                e.Handled = true;
            }
            else if (e.Key == Key.Escape)
            {
                ViewModel?.CancelRenameCommand.Execute(summary);
                e.Handled = true;
            }
        }
    }

    private async void OnRenameLostFocus(object? sender, RoutedEventArgs e)
    {
        if (sender is TextBox textBox &&
            textBox.DataContext is ConversationSummaryViewModel summary &&
            summary.IsRenaming)
        {
            await ViewModel?.ConfirmRenameCommand.ExecuteAsync(summary)!;
        }
    }

    private void OnSearchKeyDown(object? sender, KeyEventArgs e)
    {
        if (e.Key == Key.Escape)
        {
            ViewModel?.ClearSearchCommand.Execute(null);
            e.Handled = true;
        }
    }
}
```

### Conversation List Styles

```xml
<!-- In Dark.axaml or a separate ConversationList.axaml styles file -->
<Style Selector="Border.conversation-item">
    <Setter Property="Cursor" Value="Hand" />
</Style>

<Style Selector="Border.conversation-item:pointerover">
    <Setter Property="Background" Value="{DynamicResource ControlHoverBackgroundColor}" />
</Style>

<Style Selector="Border.conversation-item.selected">
    <Setter Property="Background" Value="{DynamicResource AccentBackgroundColor}" />
</Style>

<Style Selector="Border.conversation-item.selected:pointerover">
    <Setter Property="Background" Value="{DynamicResource AccentHoverBackgroundColor}" />
</Style>

<Style Selector="TextBox.inline-edit">
    <Setter Property="BorderThickness" Value="0" />
    <Setter Property="Padding" Value="0" />
    <Setter Property="Background" Value="Transparent" />
    <Setter Property="FontWeight" Value="SemiBold" />
</Style>

<Style Selector="TextBox.borderless">
    <Setter Property="BorderThickness" Value="0" />
    <Setter Property="Background" Value="Transparent" />
</Style>

<Style Selector="Button.icon-button">
    <Setter Property="Padding" Value="6" />
    <Setter Property="Background" Value="Transparent" />
    <Setter Property="BorderThickness" Value="0" />
    <Setter Property="CornerRadius" Value="4" />
</Style>

<Style Selector="Button.icon-button:pointerover">
    <Setter Property="Background" Value="{DynamicResource ControlHoverBackgroundColor}" />
</Style>

<Style Selector="MenuItem.destructive">
    <Setter Property="Foreground" Value="{DynamicResource ErrorForegroundColor}" />
</Style>
```

### v0.2.2c Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/Views/ConversationListView.axaml` | Conversation list UI |
| `src/SeniorIntern.Desktop/Views/ConversationListView.axaml.cs` | Code-behind |
| `src/SeniorIntern.Desktop/Converters/PinTextConverter.cs` | Pin/Unpin text converter |

### v0.2.2c Files to Modify

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/Themes/Dark.axaml` | Add conversation list styles |

---

## v0.2.2d: Chat Integration

### Objective
Connect the ChatViewModel to the conversation service, handle conversation switching, and integrate with the main window.

### ChatViewModel Updates

```csharp
namespace SeniorIntern.Desktop.ViewModels;

// Updates to existing ChatViewModel

public partial class ChatViewModel : ViewModelBase, IDisposable
{
    private readonly IConversationService _conversationService;
    private readonly ILlmService _llmService;
    private readonly IDispatcher _dispatcher;

    [ObservableProperty]
    private ObservableCollection<ChatMessageViewModel> _messages = new();

    [ObservableProperty]
    private string _inputText = string.Empty;

    [ObservableProperty]
    private bool _isGenerating;

    [ObservableProperty]
    private bool _canSend;

    [ObservableProperty]
    private string _conversationTitle = "New Conversation";

    [ObservableProperty]
    private bool _hasUnsavedChanges;

    [ObservableProperty]
    private string? _saveStatus;

    public ChatViewModel(
        IConversationService conversationService,
        ILlmService llmService,
        IDispatcher dispatcher)
    {
        _conversationService = conversationService;
        _llmService = llmService;
        _dispatcher = dispatcher;

        // Subscribe to conversation changes
        _conversationService.ConversationChanged += OnConversationChanged;
        _conversationService.SaveStateChanged += OnSaveStateChanged;

        // Load current conversation
        RefreshFromConversation();
    }

    private void OnConversationChanged(object? sender, ConversationChangedEventArgs e)
    {
        _dispatcher.InvokeAsync(() =>
        {
            switch (e.ChangeType)
            {
                case ConversationChangeType.Created:
                case ConversationChangeType.Loaded:
                case ConversationChangeType.Cleared:
                    RefreshFromConversation();
                    break;

                case ConversationChangeType.TitleChanged:
                    ConversationTitle = e.Conversation.Title;
                    break;

                case ConversationChangeType.Saved:
                    SaveStatus = "Saved";
                    break;
            }
        });
    }

    private void OnSaveStateChanged(object? sender, SaveStateChangedEventArgs e)
    {
        _dispatcher.InvokeAsync(() =>
        {
            HasUnsavedChanges = e.HasUnsavedChanges;

            if (e.IsSaving)
            {
                SaveStatus = "Saving...";
            }
            else if (e.Error != null)
            {
                SaveStatus = "Save failed";
            }
            else if (!e.HasUnsavedChanges)
            {
                SaveStatus = "Saved";
            }
            else
            {
                SaveStatus = null;
            }
        });
    }

    private void RefreshFromConversation()
    {
        Messages.Clear();

        var conversation = _conversationService.CurrentConversation;
        ConversationTitle = conversation.Title;
        HasUnsavedChanges = conversation.HasUnsavedChanges;

        foreach (var message in conversation.Messages)
        {
            Messages.Add(new ChatMessageViewModel(message));
        }
    }

    [RelayCommand(CanExecute = nameof(CanSendMessage))]
    private async Task SendMessageAsync()
    {
        if (string.IsNullOrWhiteSpace(InputText))
            return;

        var userMessage = new ChatMessage
        {
            Id = Guid.NewGuid(),
            Role = MessageRole.User,
            Content = InputText.Trim(),
            Timestamp = DateTime.UtcNow
        };

        // Add user message
        _conversationService.AddMessage(userMessage);
        Messages.Add(new ChatMessageViewModel(userMessage));

        var userInput = InputText;
        InputText = string.Empty;

        // Generate response
        await GenerateResponseAsync(userInput);
    }

    private async Task GenerateResponseAsync(string userInput)
    {
        IsGenerating = true;

        var assistantMessage = new ChatMessage
        {
            Id = Guid.NewGuid(),
            Role = MessageRole.Assistant,
            Content = string.Empty,
            Timestamp = DateTime.UtcNow,
            IsComplete = false
        };

        _conversationService.AddMessage(assistantMessage);
        var messageVm = new ChatMessageViewModel(assistantMessage);
        Messages.Add(messageVm);

        try
        {
            var startTime = DateTime.UtcNow;
            var tokenCount = 0;

            await foreach (var token in _llmService.GenerateStreamingAsync(
                _conversationService.GetMessages(),
                new InferenceOptions(), // Use current settings
                _generationCts?.Token ?? default))
            {
                messageVm.Content += token;
                tokenCount++;

                // Update the underlying message
                _conversationService.UpdateMessage(assistantMessage.Id, msg =>
                {
                    msg.Content = messageVm.Content;
                });
            }

            // Mark as complete
            var duration = DateTime.UtcNow - startTime;
            _conversationService.UpdateMessage(assistantMessage.Id, msg =>
            {
                msg.IsComplete = true;
                msg.TokenCount = tokenCount;
                msg.GenerationTimeMs = (int)duration.TotalMilliseconds;
                msg.TokensPerSecond = (float)(tokenCount / duration.TotalSeconds);
            });

            messageVm.IsComplete = true;
        }
        catch (OperationCanceledException)
        {
            // User cancelled
            _conversationService.UpdateMessage(assistantMessage.Id, msg =>
            {
                msg.IsComplete = false;
            });
        }
        catch (Exception ex)
        {
            messageVm.Content += $"\n\n[Error: {ex.Message}]";
            _conversationService.UpdateMessage(assistantMessage.Id, msg =>
            {
                msg.Content = messageVm.Content;
                msg.IsComplete = false;
            });
        }
        finally
        {
            IsGenerating = false;
        }
    }

    // ... other existing methods ...

    public void Dispose()
    {
        _conversationService.ConversationChanged -= OnConversationChanged;
        _conversationService.SaveStateChanged -= OnSaveStateChanged;
    }
}
```

### MainWindowViewModel Updates

```csharp
namespace SeniorIntern.Desktop.ViewModels;

public partial class MainWindowViewModel : ViewModelBase
{
    [ObservableProperty]
    private ChatViewModel _chatViewModel;

    [ObservableProperty]
    private ConversationListViewModel _conversationListViewModel;

    [ObservableProperty]
    private ModelSelectorViewModel _modelSelectorViewModel;

    [ObservableProperty]
    private string? _statusText;

    [ObservableProperty]
    private bool _isSidebarVisible = true;

    public MainWindowViewModel(
        ChatViewModel chatViewModel,
        ConversationListViewModel conversationListViewModel,
        ModelSelectorViewModel modelSelectorViewModel)
    {
        _chatViewModel = chatViewModel;
        _conversationListViewModel = conversationListViewModel;
        _modelSelectorViewModel = modelSelectorViewModel;
    }

    public async Task InitializeAsync()
    {
        await _conversationListViewModel.InitializeAsync();
    }

    [RelayCommand]
    private void ToggleSidebar()
    {
        IsSidebarVisible = !IsSidebarVisible;
    }
}
```

### MainWindow.axaml Updates

```xml
<!-- Updated sidebar section -->
<SplitView IsPaneOpen="{Binding IsSidebarVisible}"
           DisplayMode="Inline"
           OpenPaneLength="280"
           CompactPaneLength="0">

    <SplitView.Pane>
        <Border Background="{DynamicResource SidebarBackgroundColor}"
                BorderBrush="{DynamicResource BorderColor}"
                BorderThickness="0,0,1,0">
            <Grid RowDefinitions="Auto,*">
                <!-- Model Selector -->
                <views:ModelSelectorView Grid.Row="0"
                                         DataContext="{Binding ModelSelectorViewModel}"
                                         Margin="0,0,0,8" />

                <!-- Conversation List -->
                <views:ConversationListView Grid.Row="1"
                                            DataContext="{Binding ConversationListViewModel}" />
            </Grid>
        </Border>
    </SplitView.Pane>

    <SplitView.Content>
        <views:ChatView DataContext="{Binding ChatViewModel}" />
    </SplitView.Content>
</SplitView>
```

### v0.2.2d Files to Modify

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/ViewModels/ChatViewModel.cs` | Add conversation integration |
| `src/SeniorIntern.Desktop/ViewModels/MainWindowViewModel.cs` | Add ConversationListViewModel |
| `src/SeniorIntern.Desktop/Views/MainWindow.axaml` | Add conversation list to sidebar |
| `src/SeniorIntern.Desktop/Extensions/ServiceCollectionExtensions.cs` | Register services |

---

## v0.2.2e: Polish & Edge Cases

### Objective
Handle edge cases, add unsaved changes confirmation, implement empty states, and optimize performance.

### Unsaved Changes Dialog

```csharp
namespace SeniorIntern.Desktop.Dialogs;

/// <summary>
/// Dialog for confirming unsaved changes
/// </summary>
public static class UnsavedChangesDialog
{
    public enum Result
    {
        Save,
        DontSave,
        Cancel
    }

    public static async Task<Result> ShowAsync(Window owner, string conversationTitle)
    {
        var dialog = new Window
        {
            Title = "Unsaved Changes",
            Width = 400,
            Height = 150,
            WindowStartupLocation = WindowStartupLocation.CenterOwner,
            CanResize = false
        };

        var result = Result.Cancel;

        var content = new StackPanel
        {
            Margin = new Thickness(20),
            Spacing = 16
        };

        content.Children.Add(new TextBlock
        {
            Text = $"Save changes to \"{conversationTitle}\"?",
            TextWrapping = TextWrapping.Wrap
        });

        var buttonPanel = new StackPanel
        {
            Orientation = Orientation.Horizontal,
            HorizontalAlignment = HorizontalAlignment.Right,
            Spacing = 8
        };

        var saveButton = new Button { Content = "Save", Classes = { "accent" } };
        var dontSaveButton = new Button { Content = "Don't Save" };
        var cancelButton = new Button { Content = "Cancel" };

        saveButton.Click += (s, e) => { result = Result.Save; dialog.Close(); };
        dontSaveButton.Click += (s, e) => { result = Result.DontSave; dialog.Close(); };
        cancelButton.Click += (s, e) => { result = Result.Cancel; dialog.Close(); };

        buttonPanel.Children.Add(cancelButton);
        buttonPanel.Children.Add(dontSaveButton);
        buttonPanel.Children.Add(saveButton);

        content.Children.Add(buttonPanel);
        dialog.Content = content;

        await dialog.ShowDialog(owner);
        return result;
    }
}
```

### Delete Confirmation Dialog

```csharp
namespace SeniorIntern.Desktop.Dialogs;

public static class DeleteConfirmationDialog
{
    public static async Task<bool> ShowAsync(Window owner, string itemName)
    {
        var dialog = new Window
        {
            Title = "Delete Conversation",
            Width = 400,
            Height = 150,
            WindowStartupLocation = WindowStartupLocation.CenterOwner,
            CanResize = false
        };

        var confirmed = false;

        var content = new StackPanel
        {
            Margin = new Thickness(20),
            Spacing = 16
        };

        content.Children.Add(new TextBlock
        {
            Text = $"Are you sure you want to delete \"{itemName}\"?\n\nThis action cannot be undone.",
            TextWrapping = TextWrapping.Wrap
        });

        var buttonPanel = new StackPanel
        {
            Orientation = Orientation.Horizontal,
            HorizontalAlignment = HorizontalAlignment.Right,
            Spacing = 8
        };

        var deleteButton = new Button
        {
            Content = "Delete",
            Classes = { "destructive" }
        };
        var cancelButton = new Button { Content = "Cancel" };

        deleteButton.Click += (s, e) => { confirmed = true; dialog.Close(); };
        cancelButton.Click += (s, e) => { confirmed = false; dialog.Close(); };

        buttonPanel.Children.Add(cancelButton);
        buttonPanel.Children.Add(deleteButton);

        content.Children.Add(buttonPanel);
        dialog.Content = content;

        await dialog.ShowDialog(owner);
        return confirmed;
    }
}
```

### Performance Optimizations

```csharp
// In ConversationRepository - Add pagination support
public async Task<IReadOnlyList<MessageEntity>> GetMessagesPagedAsync(
    Guid conversationId,
    int pageNumber,
    int pageSize = 50,
    CancellationToken ct = default)
{
    return await _context.Messages
        .Where(m => m.ConversationId == conversationId)
        .OrderByDescending(m => m.SequenceNumber) // Most recent first for lazy loading
        .Skip((pageNumber - 1) * pageSize)
        .Take(pageSize)
        .OrderBy(m => m.SequenceNumber) // Re-order for display
        .ToListAsync(ct);
}

// Lazy message loading for large conversations
public async Task<Conversation> LoadConversationLazyAsync(
    Guid conversationId,
    int initialMessageCount = 50,
    CancellationToken ct = default)
{
    // Load conversation without messages
    var entity = await _repository.GetByIdAsync(conversationId, ct);
    if (entity == null)
        throw new InvalidOperationException($"Conversation {conversationId} not found");

    var conversation = MapToDomain(entity);

    // Load only recent messages
    var recentMessages = await _repository.GetMessagesPagedAsync(
        conversationId, 1, initialMessageCount, ct);

    conversation.LoadMessages(recentMessages.Select(MapMessageToDomain));
    conversation.HasMoreMessages = entity.MessageCount > initialMessageCount;

    return conversation;
}
```

### Keyboard Shortcuts

```csharp
// In MainWindow.axaml.cs
protected override void OnKeyDown(KeyEventArgs e)
{
    base.OnKeyDown(e);

    if (e.KeyModifiers == KeyModifiers.Control)
    {
        switch (e.Key)
        {
            case Key.N:
                // New conversation
                ViewModel?.ConversationListViewModel.CreateNewConversationCommand.Execute(null);
                e.Handled = true;
                break;

            case Key.S:
                // Save current conversation
                _ = ViewModel?.ChatViewModel.SaveCommand.ExecuteAsync(null);
                e.Handled = true;
                break;

            case Key.K:
                // Focus search
                // Implementation depends on how you expose the search box
                e.Handled = true;
                break;
        }
    }
}
```

### v0.2.2e Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/Dialogs/UnsavedChangesDialog.cs` | Unsaved changes confirmation |
| `src/SeniorIntern.Desktop/Dialogs/DeleteConfirmationDialog.cs` | Delete confirmation |

### v0.2.2e Files to Modify

| File | Changes |
|------|---------|
| `src/SeniorIntern.Data/Repositories/ConversationRepository.cs` | Add pagination methods |
| `src/SeniorIntern.Desktop/Views/MainWindow.axaml.cs` | Add keyboard shortcuts |
| `src/SeniorIntern.Desktop/ViewModels/ConversationListViewModel.cs` | Add delete confirmation |

---

## Files Summary

### Files to Create (Total: 14)

| Part | File |
|------|------|
| v0.2.2a | `src/SeniorIntern.Core/Models/ConversationSummary.cs` |
| v0.2.2a | `src/SeniorIntern.Core/Events/ConversationChangedEventArgs.cs` |
| v0.2.2a | `src/SeniorIntern.Core/Events/ConversationListChangedEventArgs.cs` |
| v0.2.2a | `src/SeniorIntern.Core/Events/SaveStateChangedEventArgs.cs` |
| v0.2.2a | `src/SeniorIntern.Services/DatabaseConversationService.cs` |
| v0.2.2b | `src/SeniorIntern.Desktop/ViewModels/ConversationListViewModel.cs` |
| v0.2.2b | `src/SeniorIntern.Desktop/ViewModels/ConversationGroupViewModel.cs` |
| v0.2.2b | `src/SeniorIntern.Desktop/ViewModels/ConversationSummaryViewModel.cs` |
| v0.2.2b | `src/SeniorIntern.Desktop/IDispatcher.cs` |
| v0.2.2b | `src/SeniorIntern.Desktop/AvaloniaDispatcher.cs` |
| v0.2.2c | `src/SeniorIntern.Desktop/Views/ConversationListView.axaml` |
| v0.2.2c | `src/SeniorIntern.Desktop/Views/ConversationListView.axaml.cs` |
| v0.2.2e | `src/SeniorIntern.Desktop/Dialogs/UnsavedChangesDialog.cs` |
| v0.2.2e | `src/SeniorIntern.Desktop/Dialogs/DeleteConfirmationDialog.cs` |

### Files to Modify (Total: 8)

| Part | File | Changes |
|------|------|---------|
| v0.2.2a | `src/SeniorIntern.Core/Models/Conversation.cs` | Add persistence properties |
| v0.2.2a | `src/SeniorIntern.Core/Interfaces/IConversationService.cs` | Update interface |
| v0.2.2c | `src/SeniorIntern.Desktop/Themes/Dark.axaml` | Add list styles |
| v0.2.2d | `src/SeniorIntern.Desktop/ViewModels/ChatViewModel.cs` | Integrate with service |
| v0.2.2d | `src/SeniorIntern.Desktop/ViewModels/MainWindowViewModel.cs` | Add list ViewModel |
| v0.2.2d | `src/SeniorIntern.Desktop/Views/MainWindow.axaml` | Add list to sidebar |
| v0.2.2d | `src/SeniorIntern.Desktop/Extensions/ServiceCollectionExtensions.cs` | Register services |
| v0.2.2e | `src/SeniorIntern.Data/Repositories/ConversationRepository.cs` | Add pagination |

---

## Testing Strategy

### Unit Tests

```csharp
public class DatabaseConversationServiceTests
{
    [Fact]
    public void AddMessage_ShouldScheduleAutoSave()
    {
        // Arrange
        var service = CreateService();

        // Act
        service.AddMessage(new ChatMessage { Content = "Test" });

        // Assert
        Assert.True(service.HasUnsavedChanges);
    }

    [Fact]
    public void AddMessage_ShouldAutoGenerateTitle()
    {
        // Arrange
        var service = CreateService();

        // Act
        service.AddMessage(new ChatMessage
        {
            Role = MessageRole.User,
            Content = "Help me debug this memory leak issue"
        });

        // Assert
        Assert.Equal("Help me debug this memory leak issue", service.CurrentConversation.Title);
    }

    [Fact]
    public async Task LoadConversation_ShouldSaveCurrentFirst()
    {
        // Test that loading a new conversation saves the current one
    }
}

public class ConversationListViewModelTests
{
    [Fact]
    public void SearchQuery_ShouldDebounce()
    {
        // Test that search is debounced by 300ms
    }

    [Fact]
    public void Groups_ShouldBeOrderedByDate()
    {
        // Test that conversations are grouped correctly
    }
}
```

### Integration Tests

```csharp
public class ConversationPersistenceIntegrationTests
{
    [Fact]
    public async Task FullWorkflow_CreateSaveLoadDelete()
    {
        // Create conversation
        // Add messages
        // Save
        // Reload application (simulate)
        // Load conversation
        // Verify messages
        // Delete
        // Verify deleted
    }
}
```

---

## Acceptance Criteria

### v0.2.2a - Service Layer
- [ ] DatabaseConversationService compiles and is registered
- [ ] Messages are added to in-memory conversation
- [ ] Auto-save triggers after 500ms debounce
- [ ] Conversations persist to database
- [ ] Title auto-generates from first user message
- [ ] Events fire correctly

### v0.2.2b - ViewModels
- [ ] ConversationListViewModel loads conversations
- [ ] Conversations are grouped by date
- [ ] Selection updates correctly
- [ ] Search works with 300ms debounce
- [ ] Rename inline editing works

### v0.2.2c - UI
- [ ] Conversation list displays in sidebar
- [ ] Groups collapse/expand
- [ ] Context menu works (rename, delete, archive, pin)
- [ ] Search filters conversations
- [ ] Empty state displays correctly
- [ ] Loading state displays correctly

### v0.2.2d - Integration
- [ ] Chat messages save to current conversation
- [ ] Switching conversations loads correct messages
- [ ] New conversation clears chat
- [ ] Title updates in chat header

### v0.2.2e - Polish
- [ ] Unsaved changes dialog appears when needed
- [ ] Delete confirmation prevents accidental deletion
- [ ] Keyboard shortcuts work (Ctrl+N, Ctrl+S)
- [ ] Large conversations load efficiently

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Auto-save race conditions | Medium | Medium | SemaphoreSlim lock, careful state management |
| Memory issues with large conversations | Low | Medium | Pagination, lazy loading |
| UI freezes during save | Low | High | All DB operations async, background save |
| Lost data on crash | Low | High | Frequent auto-save, consider WAL mode |
| Search performance | Low | Medium | SQLite FTS (future), basic LIKE for now |
