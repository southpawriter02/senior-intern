# Design Specification: The Senior Intern v0.2.4 "System Prompt Editor"

## Executive Summary

This document provides a comprehensive design specification for v0.2.4, which introduces a full-featured system prompt editor allowing users to create, edit, and manage multiple system prompts. The feature includes a library of built-in templates, quick prompt switching in the chat interface, and seamless integration with conversations.

### v0.2.4 Scope (from v0.2.0 Design Document)
- System prompt CRUD operations (Create, Read, Update, Delete)
- Built-in prompt templates library
- Quick prompt selector in chat header
- Character and token count display
- Prompt-to-conversation association
- Default prompt management

### Dependencies
- **v0.2.1** must be complete (database foundation with SystemPromptEntity)
- **v0.2.2** must be complete (conversation persistence)
- **v0.2.3** must be complete (settings service patterns)

---

## Sub-Part Breakdown

| Part | Name | Focus |
|------|------|-------|
| v0.2.4a | Models & Repository | SystemPrompt model, repository, built-in templates |
| v0.2.4b | System Prompt Service | ISystemPromptService, CRUD operations, template management |
| v0.2.4c | Editor ViewModels | SystemPromptEditorViewModel, SystemPromptViewModel |
| v0.2.4d | Editor Window UI | Full editor dialog with prompt list and text editor |
| v0.2.4e | Chat Integration | Quick selector, conversation binding, LLM context integration |

---

## Architecture Overview

### Component Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                              User Interface                                  â”‚
â”‚                                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                     SystemPromptEditorWindow                           â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚  â”‚
â”‚  â”‚  â”‚   Prompt List       â”‚  â”‚         Editor Panel                     â”‚ â”‚  â”‚
â”‚  â”‚  â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚  Name: [________________]                â”‚ â”‚  â”‚
â”‚  â”‚  â”‚   â”‚ My Prompts   â”‚  â”‚  â”‚  Description: [_________]                â”‚ â”‚  â”‚
â”‚  â”‚  â”‚   â”‚ â˜… Default    â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚ â”‚  â”‚
â”‚  â”‚  â”‚   â”‚   Custom 1   â”‚  â”‚  â”‚  â”‚                                     â”‚â”‚ â”‚  â”‚
â”‚  â”‚  â”‚   â”‚   Custom 2   â”‚  â”‚  â”‚  â”‚     System Prompt Content           â”‚â”‚ â”‚  â”‚
â”‚  â”‚  â”‚   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚  â”‚  â”‚         Text Editor                 â”‚â”‚ â”‚  â”‚
â”‚  â”‚  â”‚   â”‚ Templates    â”‚  â”‚  â”‚  â”‚                                     â”‚â”‚ â”‚  â”‚
â”‚  â”‚  â”‚   â”‚   Snarky...  â”‚  â”‚  â”‚  â”‚                                     â”‚â”‚ â”‚  â”‚
â”‚  â”‚  â”‚   â”‚   Code Exp.. â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚ â”‚  â”‚
â”‚  â”‚  â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚  Chars: 847 | Tokens: ~212              â”‚ â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                        ChatView Header                                 â”‚  â”‚
â”‚  â”‚   Using: [â˜… Snarky Intern â–¾]                         [Edit Prompts]   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
                                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        ViewModels                                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ SystemPromptEditorViewModelâ”‚  â”‚ SystemPromptSelectorViewModel          â”‚ â”‚
â”‚  â”‚ - Prompts collection       â”‚  â”‚ - AvailablePrompts                     â”‚ â”‚
â”‚  â”‚ - SelectedPrompt           â”‚  â”‚ - SelectedPrompt                       â”‚ â”‚
â”‚  â”‚ - EditorContent            â”‚  â”‚ - ApplyToConversation                  â”‚ â”‚
â”‚  â”‚ - CRUD Commands            â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
                                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        ISystemPromptService                                  â”‚
â”‚  - GetAllPromptsAsync()           - CreatePromptAsync()                      â”‚
â”‚  - GetTemplatesAsync()            - UpdatePromptAsync()                      â”‚
â”‚  - GetDefaultPromptAsync()        - DeletePromptAsync()                      â”‚
â”‚  - SetAsDefaultAsync()            - DuplicatePromptAsync()                   â”‚
â”‚  - GetPromptForConversationAsync()                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â–¼                                   â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ISystemPromptRepositoryâ”‚           â”‚ SystemPromptTemplates â”‚
        â”‚  - Database CRUD      â”‚           â”‚ - Built-in prompts    â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚   SQLite Database     â”‚
        â”‚   SystemPrompts       â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Data Flow: Applying System Prompt to Chat

```
User selects prompt from dropdown
              â”‚
              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SystemPromptSelectorViewModelâ”‚
â”‚   SelectedPrompt = X        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   IConversationService      â”‚
â”‚ UpdateSystemPrompt(convId,X)â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Conversation.SystemPromptId â”‚
â”‚         updated             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      ILlmService            â”‚â”€â”€â”€â”€â–ºâ”‚   LLM Inference         â”‚
â”‚ PrependSystemPrompt(conv)   â”‚     â”‚ [System] + [Messages]   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## v0.2.4a: Models & Repository

### Objective
Define the system prompt domain model, enhance the entity, implement the repository, and create the built-in templates library.

### SystemPrompt Domain Model

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Domain model for a system prompt
/// </summary>
public sealed class SystemPrompt
{
    public Guid Id { get; set; } = Guid.NewGuid();
    public string Name { get; set; } = string.Empty;
    public string Content { get; set; } = string.Empty;
    public string? Description { get; set; }
    public string Category { get; set; } = "Custom";
    public IReadOnlyList<string> Tags { get; set; } = Array.Empty<string>();
    public bool IsBuiltIn { get; set; }
    public bool IsDefault { get; set; }
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;
    public int UsageCount { get; set; }

    /// <summary>
    /// Character count of the content
    /// </summary>
    public int CharacterCount => Content?.Length ?? 0;

    /// <summary>
    /// Estimated token count (rough approximation: ~4 chars per token)
    /// </summary>
    public int EstimatedTokenCount => CharacterCount / 4;

    /// <summary>
    /// Creates a copy of this prompt with a new ID
    /// </summary>
    public SystemPrompt Duplicate(string? newName = null) => new()
    {
        Id = Guid.NewGuid(),
        Name = newName ?? $"{Name} (Copy)",
        Content = Content,
        Description = Description,
        Category = "Custom",
        Tags = Tags.ToList(),
        IsBuiltIn = false,
        IsDefault = false,
        CreatedAt = DateTime.UtcNow,
        UpdatedAt = DateTime.UtcNow
    };

    /// <summary>
    /// Validates the prompt
    /// </summary>
    public ValidationResult Validate()
    {
        var errors = new List<string>();

        if (string.IsNullOrWhiteSpace(Name))
            errors.Add("Name is required");

        if (Name?.Length > 100)
            errors.Add("Name must be 100 characters or less");

        if (string.IsNullOrWhiteSpace(Content))
            errors.Add("Content is required");

        if (Content?.Length > 50000)
            errors.Add("Content must be 50,000 characters or less");

        if (Description?.Length > 500)
            errors.Add("Description must be 500 characters or less");

        return new ValidationResult(errors.Count == 0, errors);
    }
}

/// <summary>
/// Validation result
/// </summary>
public sealed record ValidationResult(bool IsValid, IReadOnlyList<string> Errors);
```

### SystemPromptEntity (Enhanced)

```csharp
namespace SeniorIntern.Core.Entities;

/// <summary>
/// Database entity for system prompts
/// </summary>
public sealed class SystemPromptEntity
{
    public Guid Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string Content { get; set; } = string.Empty;
    public string? Description { get; set; }
    public string Category { get; set; } = "Custom";
    public string? TagsJson { get; set; }  // JSON array of strings
    public bool IsBuiltIn { get; set; }
    public bool IsDefault { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime UpdatedAt { get; set; }
    public int UsageCount { get; set; }

    // Navigation
    public ICollection<ConversationEntity> Conversations { get; set; } = new List<ConversationEntity>();
}
```

### SystemPromptConfiguration (EF Core)

```csharp
namespace SeniorIntern.Data.Configurations;

using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using SeniorIntern.Core.Entities;

public sealed class SystemPromptConfiguration : IEntityTypeConfiguration<SystemPromptEntity>
{
    public void Configure(EntityTypeBuilder<SystemPromptEntity> builder)
    {
        builder.ToTable("SystemPrompts");

        builder.HasKey(e => e.Id);

        builder.Property(e => e.Name)
            .IsRequired()
            .HasMaxLength(100);

        builder.Property(e => e.Content)
            .IsRequired()
            .HasMaxLength(50000);

        builder.Property(e => e.Description)
            .HasMaxLength(500);

        builder.Property(e => e.Category)
            .IsRequired()
            .HasMaxLength(50)
            .HasDefaultValue("Custom");

        builder.Property(e => e.TagsJson)
            .HasMaxLength(1000);

        builder.Property(e => e.CreatedAt)
            .IsRequired();

        builder.Property(e => e.UpdatedAt)
            .IsRequired();

        builder.HasIndex(e => e.Name)
            .IsUnique();

        builder.HasIndex(e => e.IsDefault);

        builder.HasIndex(e => e.Category);
    }
}
```

### ISystemPromptRepository Interface

```csharp
namespace SeniorIntern.Data.Repositories;

using SeniorIntern.Core.Entities;

/// <summary>
/// Repository for system prompts
/// </summary>
public interface ISystemPromptRepository
{
    /// <summary>
    /// Get all prompts ordered by category, then by name
    /// </summary>
    Task<IReadOnlyList<SystemPromptEntity>> GetAllAsync(CancellationToken ct = default);

    /// <summary>
    /// Get only user-created prompts (non-built-in)
    /// </summary>
    Task<IReadOnlyList<SystemPromptEntity>> GetUserPromptsAsync(CancellationToken ct = default);

    /// <summary>
    /// Get only built-in prompts (templates)
    /// </summary>
    Task<IReadOnlyList<SystemPromptEntity>> GetBuiltInPromptsAsync(CancellationToken ct = default);

    /// <summary>
    /// Get prompts by category
    /// </summary>
    Task<IReadOnlyList<SystemPromptEntity>> GetByCategoryAsync(
        string category,
        CancellationToken ct = default);

    /// <summary>
    /// Get a prompt by ID
    /// </summary>
    Task<SystemPromptEntity?> GetByIdAsync(Guid id, CancellationToken ct = default);

    /// <summary>
    /// Get a prompt by name
    /// </summary>
    Task<SystemPromptEntity?> GetByNameAsync(string name, CancellationToken ct = default);

    /// <summary>
    /// Get the default prompt
    /// </summary>
    Task<SystemPromptEntity?> GetDefaultAsync(CancellationToken ct = default);

    /// <summary>
    /// Search prompts by name or content
    /// </summary>
    Task<IReadOnlyList<SystemPromptEntity>> SearchAsync(
        string query,
        CancellationToken ct = default);

    /// <summary>
    /// Create a new prompt
    /// </summary>
    Task<SystemPromptEntity> CreateAsync(
        SystemPromptEntity prompt,
        CancellationToken ct = default);

    /// <summary>
    /// Update an existing prompt
    /// </summary>
    Task UpdateAsync(SystemPromptEntity prompt, CancellationToken ct = default);

    /// <summary>
    /// Delete a prompt (cannot delete built-in)
    /// </summary>
    Task DeleteAsync(Guid id, CancellationToken ct = default);

    /// <summary>
    /// Set a prompt as default (clears previous default)
    /// </summary>
    Task SetAsDefaultAsync(Guid id, CancellationToken ct = default);

    /// <summary>
    /// Increment usage count
    /// </summary>
    Task IncrementUsageAsync(Guid id, CancellationToken ct = default);

    /// <summary>
    /// Check if a name exists
    /// </summary>
    Task<bool> NameExistsAsync(
        string name,
        Guid? excludeId = null,
        CancellationToken ct = default);

    /// <summary>
    /// Seed built-in templates if they don't exist
    /// </summary>
    Task SeedBuiltInPromptsAsync(CancellationToken ct = default);
}
```

### SystemPromptRepository Implementation

```csharp
namespace SeniorIntern.Data.Repositories;

using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Entities;

public sealed class SystemPromptRepository : ISystemPromptRepository
{
    private readonly SeniorInternDbContext _context;
    private readonly ILogger<SystemPromptRepository> _logger;

    public SystemPromptRepository(
        SeniorInternDbContext context,
        ILogger<SystemPromptRepository> logger)
    {
        _context = context;
        _logger = logger;
    }

    public async Task<IReadOnlyList<SystemPromptEntity>> GetAllAsync(CancellationToken ct = default)
    {
        return await _context.SystemPrompts
            .OrderByDescending(p => p.IsDefault)
            .ThenBy(p => p.IsBuiltIn)
            .ThenBy(p => p.Category)
            .ThenBy(p => p.Name)
            .ToListAsync(ct);
    }

    public async Task<IReadOnlyList<SystemPromptEntity>> GetUserPromptsAsync(CancellationToken ct = default)
    {
        return await _context.SystemPrompts
            .Where(p => !p.IsBuiltIn)
            .OrderByDescending(p => p.IsDefault)
            .ThenByDescending(p => p.UpdatedAt)
            .ToListAsync(ct);
    }

    public async Task<IReadOnlyList<SystemPromptEntity>> GetBuiltInPromptsAsync(CancellationToken ct = default)
    {
        return await _context.SystemPrompts
            .Where(p => p.IsBuiltIn)
            .OrderBy(p => p.Category)
            .ThenBy(p => p.Name)
            .ToListAsync(ct);
    }

    public async Task<IReadOnlyList<SystemPromptEntity>> GetByCategoryAsync(
        string category,
        CancellationToken ct = default)
    {
        return await _context.SystemPrompts
            .Where(p => p.Category == category)
            .OrderBy(p => p.Name)
            .ToListAsync(ct);
    }

    public async Task<SystemPromptEntity?> GetByIdAsync(Guid id, CancellationToken ct = default)
    {
        return await _context.SystemPrompts.FindAsync(new object[] { id }, ct);
    }

    public async Task<SystemPromptEntity?> GetByNameAsync(string name, CancellationToken ct = default)
    {
        return await _context.SystemPrompts
            .FirstOrDefaultAsync(p => p.Name == name, ct);
    }

    public async Task<SystemPromptEntity?> GetDefaultAsync(CancellationToken ct = default)
    {
        return await _context.SystemPrompts
            .FirstOrDefaultAsync(p => p.IsDefault, ct);
    }

    public async Task<IReadOnlyList<SystemPromptEntity>> SearchAsync(
        string query,
        CancellationToken ct = default)
    {
        if (string.IsNullOrWhiteSpace(query))
            return await GetAllAsync(ct);

        var lowerQuery = query.ToLowerInvariant();

        return await _context.SystemPrompts
            .Where(p => p.Name.ToLower().Contains(lowerQuery) ||
                       (p.Description != null && p.Description.ToLower().Contains(lowerQuery)) ||
                       p.Content.ToLower().Contains(lowerQuery))
            .OrderByDescending(p => p.Name.ToLower().StartsWith(lowerQuery))
            .ThenBy(p => p.Name)
            .ToListAsync(ct);
    }

    public async Task<SystemPromptEntity> CreateAsync(
        SystemPromptEntity prompt,
        CancellationToken ct = default)
    {
        prompt.CreatedAt = DateTime.UtcNow;
        prompt.UpdatedAt = DateTime.UtcNow;

        _context.SystemPrompts.Add(prompt);
        await _context.SaveChangesAsync(ct);

        _logger.LogDebug("Created system prompt: {Name}", prompt.Name);
        return prompt;
    }

    public async Task UpdateAsync(SystemPromptEntity prompt, CancellationToken ct = default)
    {
        var existing = await _context.SystemPrompts.FindAsync(new object[] { prompt.Id }, ct);
        if (existing == null)
        {
            throw new InvalidOperationException($"System prompt {prompt.Id} not found");
        }

        if (existing.IsBuiltIn)
        {
            throw new InvalidOperationException("Cannot modify built-in system prompts");
        }

        existing.Name = prompt.Name;
        existing.Content = prompt.Content;
        existing.Description = prompt.Description;
        existing.Category = prompt.Category;
        existing.TagsJson = prompt.TagsJson;
        existing.UpdatedAt = DateTime.UtcNow;

        await _context.SaveChangesAsync(ct);
        _logger.LogDebug("Updated system prompt: {Name}", prompt.Name);
    }

    public async Task DeleteAsync(Guid id, CancellationToken ct = default)
    {
        var prompt = await _context.SystemPrompts.FindAsync(new object[] { id }, ct);
        if (prompt == null)
            return;

        if (prompt.IsBuiltIn)
        {
            throw new InvalidOperationException("Cannot delete built-in system prompts");
        }

        // Check if any conversations are using this prompt
        var inUseCount = await _context.Conversations
            .CountAsync(c => c.SystemPromptId == id, ct);

        if (inUseCount > 0)
        {
            // Set those conversations to use no system prompt
            var conversations = await _context.Conversations
                .Where(c => c.SystemPromptId == id)
                .ToListAsync(ct);

            foreach (var conv in conversations)
            {
                conv.SystemPromptId = null;
            }
        }

        _context.SystemPrompts.Remove(prompt);
        await _context.SaveChangesAsync(ct);

        _logger.LogDebug("Deleted system prompt: {Name}", prompt.Name);
    }

    public async Task SetAsDefaultAsync(Guid id, CancellationToken ct = default)
    {
        // Clear existing default
        var currentDefault = await _context.SystemPrompts
            .FirstOrDefaultAsync(p => p.IsDefault, ct);

        if (currentDefault != null)
        {
            currentDefault.IsDefault = false;
        }

        // Set new default
        var newDefault = await _context.SystemPrompts.FindAsync(new object[] { id }, ct);
        if (newDefault != null)
        {
            newDefault.IsDefault = true;
            await _context.SaveChangesAsync(ct);
            _logger.LogDebug("Set default system prompt: {Name}", newDefault.Name);
        }
    }

    public async Task IncrementUsageAsync(Guid id, CancellationToken ct = default)
    {
        var prompt = await _context.SystemPrompts.FindAsync(new object[] { id }, ct);
        if (prompt != null)
        {
            prompt.UsageCount++;
            await _context.SaveChangesAsync(ct);
        }
    }

    public async Task<bool> NameExistsAsync(
        string name,
        Guid? excludeId = null,
        CancellationToken ct = default)
    {
        var query = _context.SystemPrompts.Where(p => p.Name == name);

        if (excludeId.HasValue)
        {
            query = query.Where(p => p.Id != excludeId.Value);
        }

        return await query.AnyAsync(ct);
    }

    public async Task SeedBuiltInPromptsAsync(CancellationToken ct = default)
    {
        var existingBuiltIn = await _context.SystemPrompts
            .AnyAsync(p => p.IsBuiltIn, ct);

        if (existingBuiltIn)
        {
            _logger.LogDebug("Built-in system prompts already seeded");
            return;
        }

        var builtInPrompts = SystemPromptTemplates.GetAllTemplates();

        _context.SystemPrompts.AddRange(builtInPrompts);
        await _context.SaveChangesAsync(ct);

        _logger.LogInformation("Seeded {Count} built-in system prompts", builtInPrompts.Count);
    }
}
```

### SystemPromptTemplates (Built-in Templates)

```csharp
namespace SeniorIntern.Core.Templates;

using SeniorIntern.Core.Entities;
using System.Text.Json;

/// <summary>
/// Built-in system prompt templates
/// </summary>
public static class SystemPromptTemplates
{
    /// <summary>
    /// Get all built-in templates as entities ready for database seeding
    /// </summary>
    public static IReadOnlyList<SystemPromptEntity> GetAllTemplates() => new List<SystemPromptEntity>
    {
        CreateDefaultAssistant(),
        CreateSnarkyIntern(),
        CreateCodeExpert(),
        CreateTechnicalWriter(),
        CreateRubberDuck(),
        CreateSocraticTutor(),
        CreateCodeReviewer(),
        CreateDebugger()
    };

    private static SystemPromptEntity CreateDefaultAssistant() => new()
    {
        Id = Guid.Parse("00000002-0000-0000-0000-000000000001"),
        Name = "Default Assistant",
        Description = "A balanced, helpful assistant for general conversations and tasks.",
        Category = "General",
        TagsJson = JsonSerializer.Serialize(new[] { "general", "helpful", "balanced" }),
        IsBuiltIn = true,
        IsDefault = true,
        Content = """
            You are a helpful AI assistant. You provide clear, accurate, and well-structured responses to help users with their questions and tasks.

            Guidelines:
            - Be concise but thorough
            - Ask clarifying questions when the request is ambiguous
            - Provide examples when they would be helpful
            - Acknowledge when you're uncertain about something
            - Focus on being genuinely helpful rather than just agreeable
            """
    };

    private static SystemPromptEntity CreateSnarkyIntern() => new()
    {
        Id = Guid.Parse("00000002-0000-0000-0000-000000000002"),
        Name = "The Senior Intern",
        Description = "The classic Senior Intern personality - technically brilliant with a dash of sarcasm.",
        Category = "Creative",
        TagsJson = JsonSerializer.Serialize(new[] { "personality", "snarky", "coding", "humor" }),
        IsBuiltIn = true,
        IsDefault = false,
        Content = """
            You are "The Senior Intern" - an AI assistant with the knowledge of a senior developer but the enthusiasm of a new hire. You're technically brilliant but sometimes make sarcastic observations about code quality or architecture decisions. You help users with coding tasks while occasionally dropping witty remarks about the state of the codebase or industry trends.

            Key traits:
            - Technically accurate and thorough
            - Occasionally sarcastic but never mean
            - Enthusiastic about good practices
            - Mildly judgmental about bad practices
            - Uses programming humor when appropriate

            Always prioritize being helpful over being funny. If the user seems frustrated or the task is urgent, dial back the personality and focus on solutions.

            When reviewing code:
            - Point out issues directly but not harshly
            - Celebrate good patterns and clean code
            - Make gentle jokes about common anti-patterns
            - Suggest improvements constructively

            Remember: You're the intern who somehow knows everything, not a jaded senior dev who's given up. Stay enthusiastic!
            """
    };

    private static SystemPromptEntity CreateCodeExpert() => new()
    {
        Id = Guid.Parse("00000002-0000-0000-0000-000000000003"),
        Name = "Code Expert",
        Description = "Focused on programming tasks with precise, technical responses.",
        Category = "Code",
        TagsJson = JsonSerializer.Serialize(new[] { "coding", "technical", "precise", "programming" }),
        IsBuiltIn = true,
        IsDefault = false,
        Content = """
            You are an expert software developer assistant. Your primary focus is helping with programming tasks, code review, debugging, and software architecture decisions.

            Guidelines:
            - Provide precise, technically accurate answers
            - Include code examples with proper formatting
            - Explain the reasoning behind recommendations
            - Consider performance, security, and maintainability
            - Follow best practices and design patterns
            - Use appropriate language-specific conventions

            When writing code:
            - Use meaningful variable and function names
            - Add comments only where the logic isn't self-evident
            - Handle edge cases and errors appropriately
            - Keep solutions simple and focused

            When reviewing code:
            - Identify bugs, security issues, and performance problems
            - Suggest specific improvements with examples
            - Explain why changes are beneficial
            - Prioritize issues by severity

            Languages and frameworks you're expert in include: C#, .NET, Python, JavaScript/TypeScript, SQL, and common frameworks like ASP.NET, React, and Node.js.
            """
    };

    private static SystemPromptEntity CreateTechnicalWriter() => new()
    {
        Id = Guid.Parse("00000002-0000-0000-0000-000000000004"),
        Name = "Technical Writer",
        Description = "Specialized in documentation, explanations, and technical writing.",
        Category = "Technical",
        TagsJson = JsonSerializer.Serialize(new[] { "documentation", "writing", "explanation", "technical" }),
        IsBuiltIn = true,
        IsDefault = false,
        Content = """
            You are a technical writing assistant specialized in creating clear, well-structured documentation and explanations.

            Your strengths:
            - Writing clear API documentation
            - Creating README files and guides
            - Explaining complex technical concepts simply
            - Structuring information logically
            - Using consistent terminology

            Documentation principles:
            - Start with a clear overview
            - Use headers to organize content
            - Include practical examples
            - Anticipate common questions
            - Keep paragraphs focused and scannable

            When explaining concepts:
            - Build from fundamentals to advanced topics
            - Use analogies when they clarify
            - Provide both the "what" and the "why"
            - Include diagrams or ASCII art when visual representation helps

            Always consider your audience's technical level and adjust complexity accordingly.
            """
    };

    private static SystemPromptEntity CreateRubberDuck() => new()
    {
        Id = Guid.Parse("00000002-0000-0000-0000-000000000005"),
        Name = "Rubber Duck",
        Description = "Helps debug by asking clarifying questions and guiding your thinking.",
        Category = "Code",
        TagsJson = JsonSerializer.Serialize(new[] { "debugging", "questions", "thinking", "rubber-duck" }),
        IsBuiltIn = true,
        IsDefault = false,
        Content = """
            You are a rubber duck debugging assistant. Your role is to help developers debug problems by asking thoughtful questions that guide them to discover solutions themselves.

            Approach:
            - Ask clarifying questions rather than jumping to solutions
            - Help the user articulate what they expect vs. what's happening
            - Guide them through systematic debugging steps
            - Encourage them to explain their code's logic out loud

            Key questions to ask:
            - "What exactly did you expect to happen?"
            - "What actually happened instead?"
            - "When did this last work correctly?"
            - "What changed between then and now?"
            - "Have you verified that [assumption] is true?"
            - "What have you already tried?"

            When the user is stuck:
            - Suggest specific debugging techniques
            - Help them isolate the problem
            - Guide them to check assumptions
            - Encourage breaking the problem into smaller parts

            Sometimes the best help is simply being a patient listener while they explain their code. Often, the act of explanation reveals the bug.
            """
    };

    private static SystemPromptEntity CreateSocraticTutor() => new()
    {
        Id = Guid.Parse("00000002-0000-0000-0000-000000000006"),
        Name = "Socratic Tutor",
        Description = "Teaches through questions, helping you discover answers yourself.",
        Category = "General",
        TagsJson = JsonSerializer.Serialize(new[] { "teaching", "learning", "questions", "education" }),
        IsBuiltIn = true,
        IsDefault = false,
        Content = """
            You are a Socratic tutor. Your goal is to help users learn by guiding them to discover answers through thoughtful questioning rather than direct instruction.

            Teaching approach:
            - Ask questions that lead to understanding
            - Build on what the user already knows
            - Let them work through problems step by step
            - Provide hints rather than answers when they're stuck
            - Celebrate their discoveries and progress

            When a user asks a question:
            1. Assess what they already understand
            2. Ask a question that builds on that knowledge
            3. Guide them toward the next insight
            4. Let them articulate the answer themselves

            If they're completely stuck:
            - Provide a small hint, not the full answer
            - Break the problem into smaller questions
            - Return to fundamentals if needed

            Your questions should be:
            - Open-ended when exploring concepts
            - Specific when narrowing down to solutions
            - Encouraging and never condescending
            - Progressively building toward understanding

            The goal is not just to solve the immediate problem, but to build the user's ability to solve similar problems independently.
            """
    };

    private static SystemPromptEntity CreateCodeReviewer() => new()
    {
        Id = Guid.Parse("00000002-0000-0000-0000-000000000007"),
        Name = "Code Reviewer",
        Description = "Thorough code review with constructive feedback.",
        Category = "Code",
        TagsJson = JsonSerializer.Serialize(new[] { "code-review", "feedback", "quality", "best-practices" }),
        IsBuiltIn = true,
        IsDefault = false,
        Content = """
            You are an experienced code reviewer. Your role is to provide thorough, constructive code reviews that help improve code quality and help developers grow.

            Review checklist:
            - Correctness: Does the code do what it's supposed to?
            - Security: Are there any vulnerabilities?
            - Performance: Are there obvious inefficiencies?
            - Readability: Is the code clear and well-organized?
            - Maintainability: Will this be easy to modify later?
            - Testing: Is the code testable? Are edge cases handled?
            - Standards: Does it follow project/language conventions?

            Feedback guidelines:
            - Be specific about what to change and why
            - Distinguish between must-fix issues and suggestions
            - Explain the reasoning behind recommendations
            - Acknowledge what's done well, not just problems
            - Suggest alternatives rather than just criticizing

            Severity levels:
            - ğŸ”´ Critical: Bugs, security issues, data loss risks
            - ğŸŸ¡ Important: Performance issues, maintainability concerns
            - ğŸ”µ Suggestion: Style improvements, nice-to-haves
            - âœ… Praise: Good patterns worth highlighting

            Remember: Code review is about improving code AND helping developers learn. Be kind, be clear, be helpful.
            """
    };

    private static SystemPromptEntity CreateDebugger() => new()
    {
        Id = Guid.Parse("00000002-0000-0000-0000-000000000008"),
        Name = "Debugger",
        Description = "Systematic debugging assistance for tracking down bugs.",
        Category = "Code",
        TagsJson = JsonSerializer.Serialize(new[] { "debugging", "troubleshooting", "bugs", "systematic" }),
        IsBuiltIn = true,
        IsDefault = false,
        Content = """
            You are a debugging specialist. Your role is to help systematically track down and fix bugs in code.

            Debugging methodology:
            1. Reproduce: Understand exactly how to trigger the bug
            2. Isolate: Narrow down where the bug occurs
            3. Identify: Find the root cause
            4. Fix: Implement the correct solution
            5. Verify: Confirm the fix works without side effects

            When helping debug:
            - Ask about error messages, stack traces, and logs
            - Help identify what changed recently
            - Suggest strategic logging/breakpoint locations
            - Look for common bug patterns
            - Consider edge cases and race conditions

            Common bug sources to check:
            - Off-by-one errors
            - Null/undefined references
            - Async/timing issues
            - Type mismatches
            - Incorrect assumptions about data
            - Resource leaks
            - Boundary conditions

            Debugging tools to suggest:
            - Print/log statements
            - Debugger breakpoints
            - Unit tests to isolate behavior
            - Binary search through commits (git bisect)
            - Rubber duck explanation

            Stay systematic and patient. Most bugs are logical once you find them.
            """
    };
}
```

### v0.2.4a Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Models/SystemPrompt.cs` | Domain model |
| `src/SeniorIntern.Core/Templates/SystemPromptTemplates.cs` | Built-in templates |
| `src/SeniorIntern.Data/Repositories/ISystemPromptRepository.cs` | Repository interface |
| `src/SeniorIntern.Data/Repositories/SystemPromptRepository.cs` | Repository implementation |

### v0.2.4a Files to Modify

| File | Changes |
|------|---------|
| `src/SeniorIntern.Core/Entities/SystemPromptEntity.cs` | Add TagsJson, UsageCount |
| `src/SeniorIntern.Data/Configurations/SystemPromptConfiguration.cs` | Update configuration |

---

## v0.2.4b: System Prompt Service

### Objective
Implement the service layer for managing system prompts, including CRUD operations, template management, and conversation integration.

### ISystemPromptService Interface

```csharp
namespace SeniorIntern.Core.Interfaces;

using SeniorIntern.Core.Models;

/// <summary>
/// Service for managing system prompts
/// </summary>
public interface ISystemPromptService
{
    /// <summary>
    /// Currently active prompt (used for new conversations)
    /// </summary>
    SystemPrompt? CurrentPrompt { get; }

    /// <summary>
    /// Get all user prompts (non-built-in)
    /// </summary>
    Task<IReadOnlyList<SystemPrompt>> GetUserPromptsAsync(CancellationToken ct = default);

    /// <summary>
    /// Get all built-in templates
    /// </summary>
    Task<IReadOnlyList<SystemPrompt>> GetTemplatesAsync(CancellationToken ct = default);

    /// <summary>
    /// Get all prompts (user + built-in)
    /// </summary>
    Task<IReadOnlyList<SystemPrompt>> GetAllPromptsAsync(CancellationToken ct = default);

    /// <summary>
    /// Get a prompt by ID
    /// </summary>
    Task<SystemPrompt?> GetByIdAsync(Guid id, CancellationToken ct = default);

    /// <summary>
    /// Get the default prompt
    /// </summary>
    Task<SystemPrompt?> GetDefaultPromptAsync(CancellationToken ct = default);

    /// <summary>
    /// Get the prompt for a specific conversation
    /// </summary>
    Task<SystemPrompt?> GetPromptForConversationAsync(
        Guid conversationId,
        CancellationToken ct = default);

    /// <summary>
    /// Search prompts
    /// </summary>
    Task<IReadOnlyList<SystemPrompt>> SearchPromptsAsync(
        string query,
        CancellationToken ct = default);

    /// <summary>
    /// Create a new prompt
    /// </summary>
    Task<SystemPrompt> CreatePromptAsync(
        string name,
        string content,
        string? description = null,
        CancellationToken ct = default);

    /// <summary>
    /// Create a prompt from a template
    /// </summary>
    Task<SystemPrompt> CreateFromTemplateAsync(
        Guid templateId,
        string? newName = null,
        CancellationToken ct = default);

    /// <summary>
    /// Update an existing prompt
    /// </summary>
    Task UpdatePromptAsync(
        Guid id,
        string? name = null,
        string? content = null,
        string? description = null,
        CancellationToken ct = default);

    /// <summary>
    /// Delete a prompt
    /// </summary>
    Task DeletePromptAsync(Guid id, CancellationToken ct = default);

    /// <summary>
    /// Duplicate a prompt
    /// </summary>
    Task<SystemPrompt> DuplicatePromptAsync(
        Guid id,
        string? newName = null,
        CancellationToken ct = default);

    /// <summary>
    /// Set a prompt as default
    /// </summary>
    Task SetAsDefaultAsync(Guid id, CancellationToken ct = default);

    /// <summary>
    /// Set the current prompt (for new conversations)
    /// </summary>
    Task SetCurrentPromptAsync(Guid? id, CancellationToken ct = default);

    /// <summary>
    /// Format a prompt for use in LLM context
    /// </summary>
    string FormatPromptForContext(SystemPrompt prompt);

    /// <summary>
    /// Fired when the prompt list changes
    /// </summary>
    event EventHandler<PromptListChangedEventArgs>? PromptListChanged;

    /// <summary>
    /// Fired when the current prompt changes
    /// </summary>
    event EventHandler<CurrentPromptChangedEventArgs>? CurrentPromptChanged;
}
```

### Event Args

```csharp
namespace SeniorIntern.Core.Events;

using SeniorIntern.Core.Models;

/// <summary>
/// Event args for prompt list changes
/// </summary>
public sealed class PromptListChangedEventArgs : EventArgs
{
    public required PromptListChangeType ChangeType { get; init; }
    public Guid? AffectedPromptId { get; init; }
    public string? AffectedPromptName { get; init; }
}

public enum PromptListChangeType
{
    PromptCreated,
    PromptUpdated,
    PromptDeleted,
    DefaultChanged,
    ListRefreshed
}

/// <summary>
/// Event args for current prompt changes
/// </summary>
public sealed class CurrentPromptChangedEventArgs : EventArgs
{
    public SystemPrompt? NewPrompt { get; init; }
    public SystemPrompt? PreviousPrompt { get; init; }
}
```

### SystemPromptService Implementation

```csharp
namespace SeniorIntern.Services;

using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Events;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Data.Repositories;
using System.Text.Json;

/// <summary>
/// Service for managing system prompts
/// </summary>
public sealed class SystemPromptService : ISystemPromptService
{
    private readonly ISystemPromptRepository _repository;
    private readonly IConversationRepository _conversationRepository;
    private readonly ISettingsService _settingsService;
    private readonly ILogger<SystemPromptService> _logger;

    private SystemPrompt? _currentPrompt;

    public SystemPrompt? CurrentPrompt => _currentPrompt;

    public event EventHandler<PromptListChangedEventArgs>? PromptListChanged;
    public event EventHandler<CurrentPromptChangedEventArgs>? CurrentPromptChanged;

    public SystemPromptService(
        ISystemPromptRepository repository,
        IConversationRepository conversationRepository,
        ISettingsService settingsService,
        ILogger<SystemPromptService> logger)
    {
        _repository = repository;
        _conversationRepository = conversationRepository;
        _settingsService = settingsService;
        _logger = logger;
    }

    /// <summary>
    /// Initialize the service
    /// </summary>
    public async Task InitializeAsync(CancellationToken ct = default)
    {
        await _repository.SeedBuiltInPromptsAsync(ct);

        // Load current prompt from settings
        var settings = _settingsService.GetSettings();
        if (settings.CurrentSystemPromptId.HasValue)
        {
            var prompt = await GetByIdAsync(settings.CurrentSystemPromptId.Value, ct);
            _currentPrompt = prompt;
        }
        else
        {
            // Fall back to default
            _currentPrompt = await GetDefaultPromptAsync(ct);
        }
    }

    public async Task<IReadOnlyList<SystemPrompt>> GetUserPromptsAsync(CancellationToken ct = default)
    {
        var entities = await _repository.GetUserPromptsAsync(ct);
        return entities.Select(MapToDomain).ToList();
    }

    public async Task<IReadOnlyList<SystemPrompt>> GetTemplatesAsync(CancellationToken ct = default)
    {
        var entities = await _repository.GetBuiltInPromptsAsync(ct);
        return entities.Select(MapToDomain).ToList();
    }

    public async Task<IReadOnlyList<SystemPrompt>> GetAllPromptsAsync(CancellationToken ct = default)
    {
        var entities = await _repository.GetAllAsync(ct);
        return entities.Select(MapToDomain).ToList();
    }

    public async Task<SystemPrompt?> GetByIdAsync(Guid id, CancellationToken ct = default)
    {
        var entity = await _repository.GetByIdAsync(id, ct);
        return entity != null ? MapToDomain(entity) : null;
    }

    public async Task<SystemPrompt?> GetDefaultPromptAsync(CancellationToken ct = default)
    {
        var entity = await _repository.GetDefaultAsync(ct);
        return entity != null ? MapToDomain(entity) : null;
    }

    public async Task<SystemPrompt?> GetPromptForConversationAsync(
        Guid conversationId,
        CancellationToken ct = default)
    {
        var conversation = await _conversationRepository.GetByIdAsync(conversationId, ct);
        if (conversation?.SystemPromptId == null)
            return null;

        return await GetByIdAsync(conversation.SystemPromptId.Value, ct);
    }

    public async Task<IReadOnlyList<SystemPrompt>> SearchPromptsAsync(
        string query,
        CancellationToken ct = default)
    {
        var entities = await _repository.SearchAsync(query, ct);
        return entities.Select(MapToDomain).ToList();
    }

    public async Task<SystemPrompt> CreatePromptAsync(
        string name,
        string content,
        string? description = null,
        CancellationToken ct = default)
    {
        // Validate
        if (string.IsNullOrWhiteSpace(name))
            throw new ArgumentException("Name is required", nameof(name));

        if (string.IsNullOrWhiteSpace(content))
            throw new ArgumentException("Content is required", nameof(content));

        if (await _repository.NameExistsAsync(name, ct: ct))
            throw new InvalidOperationException($"A prompt named '{name}' already exists");

        var entity = new SystemPromptEntity
        {
            Id = Guid.NewGuid(),
            Name = name.Trim(),
            Content = content,
            Description = description?.Trim(),
            Category = "Custom",
            IsBuiltIn = false,
            IsDefault = false
        };

        await _repository.CreateAsync(entity, ct);

        _logger.LogInformation("Created system prompt: {Name}", name);

        var prompt = MapToDomain(entity);
        OnPromptListChanged(PromptListChangeType.PromptCreated, prompt.Id, prompt.Name);

        return prompt;
    }

    public async Task<SystemPrompt> CreateFromTemplateAsync(
        Guid templateId,
        string? newName = null,
        CancellationToken ct = default)
    {
        var template = await _repository.GetByIdAsync(templateId, ct);
        if (template == null)
            throw new InvalidOperationException($"Template {templateId} not found");

        var name = newName ?? $"{template.Name} (Custom)";

        // Ensure unique name
        var baseName = name;
        var counter = 1;
        while (await _repository.NameExistsAsync(name, ct: ct))
        {
            name = $"{baseName} ({counter++})";
        }

        return await CreatePromptAsync(name, template.Content, template.Description, ct);
    }

    public async Task UpdatePromptAsync(
        Guid id,
        string? name = null,
        string? content = null,
        string? description = null,
        CancellationToken ct = default)
    {
        var entity = await _repository.GetByIdAsync(id, ct);
        if (entity == null)
            throw new InvalidOperationException($"Prompt {id} not found");

        if (entity.IsBuiltIn)
            throw new InvalidOperationException("Cannot modify built-in prompts");

        if (name != null)
        {
            if (await _repository.NameExistsAsync(name, id, ct))
                throw new InvalidOperationException($"A prompt named '{name}' already exists");

            entity.Name = name.Trim();
        }

        if (content != null)
            entity.Content = content;

        if (description != null)
            entity.Description = description.Trim();

        await _repository.UpdateAsync(entity, ct);

        _logger.LogDebug("Updated system prompt: {Name}", entity.Name);

        OnPromptListChanged(PromptListChangeType.PromptUpdated, id, entity.Name);

        // Update current prompt if it was the one modified
        if (_currentPrompt?.Id == id)
        {
            var previous = _currentPrompt;
            _currentPrompt = MapToDomain(entity);
            OnCurrentPromptChanged(_currentPrompt, previous);
        }
    }

    public async Task DeletePromptAsync(Guid id, CancellationToken ct = default)
    {
        var entity = await _repository.GetByIdAsync(id, ct);
        if (entity == null)
            return;

        if (entity.IsBuiltIn)
            throw new InvalidOperationException("Cannot delete built-in prompts");

        var name = entity.Name;
        await _repository.DeleteAsync(id, ct);

        _logger.LogInformation("Deleted system prompt: {Name}", name);

        OnPromptListChanged(PromptListChangeType.PromptDeleted, id, name);

        // Clear current prompt if it was deleted
        if (_currentPrompt?.Id == id)
        {
            var previous = _currentPrompt;
            _currentPrompt = await GetDefaultPromptAsync(ct);
            OnCurrentPromptChanged(_currentPrompt, previous);
        }
    }

    public async Task<SystemPrompt> DuplicatePromptAsync(
        Guid id,
        string? newName = null,
        CancellationToken ct = default)
    {
        var entity = await _repository.GetByIdAsync(id, ct);
        if (entity == null)
            throw new InvalidOperationException($"Prompt {id} not found");

        var baseName = newName ?? $"{entity.Name} (Copy)";
        var name = baseName;
        var counter = 1;

        while (await _repository.NameExistsAsync(name, ct: ct))
        {
            name = $"{baseName} ({counter++})";
        }

        return await CreatePromptAsync(name, entity.Content, entity.Description, ct);
    }

    public async Task SetAsDefaultAsync(Guid id, CancellationToken ct = default)
    {
        await _repository.SetAsDefaultAsync(id, ct);

        _logger.LogDebug("Set default system prompt: {Id}", id);

        OnPromptListChanged(PromptListChangeType.DefaultChanged, id);
    }

    public async Task SetCurrentPromptAsync(Guid? id, CancellationToken ct = default)
    {
        var previous = _currentPrompt;

        if (id.HasValue)
        {
            var prompt = await GetByIdAsync(id.Value, ct);
            _currentPrompt = prompt;

            // Track usage
            if (prompt != null)
            {
                await _repository.IncrementUsageAsync(id.Value, ct);
            }
        }
        else
        {
            _currentPrompt = null;
        }

        // Persist to settings
        var settings = _settingsService.GetSettings();
        settings.CurrentSystemPromptId = id;
        await _settingsService.SaveSettingsAsync(settings, ct);

        OnCurrentPromptChanged(_currentPrompt, previous);
    }

    public string FormatPromptForContext(SystemPrompt prompt)
    {
        // Basic formatting - can be enhanced based on model requirements
        return prompt.Content.Trim();
    }

    // === Mapping ===

    private static SystemPrompt MapToDomain(SystemPromptEntity entity)
    {
        var tags = new List<string>();
        if (!string.IsNullOrEmpty(entity.TagsJson))
        {
            try
            {
                tags = JsonSerializer.Deserialize<List<string>>(entity.TagsJson) ?? new List<string>();
            }
            catch
            {
                // Ignore JSON errors
            }
        }

        return new SystemPrompt
        {
            Id = entity.Id,
            Name = entity.Name,
            Content = entity.Content,
            Description = entity.Description,
            Category = entity.Category,
            Tags = tags,
            IsBuiltIn = entity.IsBuiltIn,
            IsDefault = entity.IsDefault,
            CreatedAt = entity.CreatedAt,
            UpdatedAt = entity.UpdatedAt,
            UsageCount = entity.UsageCount
        };
    }

    // === Events ===

    private void OnPromptListChanged(PromptListChangeType changeType, Guid? id = null, string? name = null)
    {
        PromptListChanged?.Invoke(this, new PromptListChangedEventArgs
        {
            ChangeType = changeType,
            AffectedPromptId = id,
            AffectedPromptName = name
        });
    }

    private void OnCurrentPromptChanged(SystemPrompt? newPrompt, SystemPrompt? previousPrompt)
    {
        CurrentPromptChanged?.Invoke(this, new CurrentPromptChangedEventArgs
        {
            NewPrompt = newPrompt,
            PreviousPrompt = previousPrompt
        });
    }
}
```

### AppSettings Updates

```csharp
namespace SeniorIntern.Core.Models;

public sealed class AppSettings
{
    // ... existing properties ...

    /// <summary>
    /// ID of the currently selected system prompt for new conversations
    /// </summary>
    public Guid? CurrentSystemPromptId { get; set; }
}
```

### v0.2.4b Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/ISystemPromptService.cs` | Service interface |
| `src/SeniorIntern.Core/Events/PromptListChangedEventArgs.cs` | List change events |
| `src/SeniorIntern.Core/Events/CurrentPromptChangedEventArgs.cs` | Current prompt events |
| `src/SeniorIntern.Services/SystemPromptService.cs` | Service implementation |

### v0.2.4b Files to Modify

| File | Changes |
|------|---------|
| `src/SeniorIntern.Core/Models/AppSettings.cs` | Add CurrentSystemPromptId |

---

## v0.2.4c: Editor ViewModels

### Objective
Create ViewModels for the system prompt editor window, including the main editor ViewModel, prompt list item ViewModel, and template browsing.

### SystemPromptEditorViewModel

```csharp
namespace SeniorIntern.Desktop.ViewModels;

using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using SeniorIntern.Core.Events;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using System.Collections.ObjectModel;

/// <summary>
/// ViewModel for the system prompt editor window
/// </summary>
public partial class SystemPromptEditorViewModel : ViewModelBase, IDisposable
{
    private readonly ISystemPromptService _promptService;
    private readonly IDispatcher _dispatcher;
    private SystemPrompt? _originalPrompt;

    // === Prompt Lists ===

    [ObservableProperty]
    private ObservableCollection<SystemPromptViewModel> _userPrompts = new();

    [ObservableProperty]
    private ObservableCollection<SystemPromptViewModel> _templates = new();

    [ObservableProperty]
    private SystemPromptViewModel? _selectedPrompt;

    // === Editor State ===

    [ObservableProperty]
    private string _promptName = string.Empty;

    [ObservableProperty]
    private string _promptDescription = string.Empty;

    [ObservableProperty]
    private string _editorContent = string.Empty;

    [ObservableProperty]
    private bool _isDirty;

    [ObservableProperty]
    private bool _isEditing;

    [ObservableProperty]
    private bool _isNewPrompt;

    [ObservableProperty]
    private bool _canEdit;

    [ObservableProperty]
    private bool _canDelete;

    [ObservableProperty]
    private bool _canSetDefault;

    // === UI State ===

    [ObservableProperty]
    private bool _isLoading;

    [ObservableProperty]
    private string? _errorMessage;

    [ObservableProperty]
    private string? _validationError;

    // === Computed Properties ===

    public int CharacterCount => EditorContent?.Length ?? 0;
    public int EstimatedTokenCount => CharacterCount / 4;
    public string CharacterCountText => $"{CharacterCount:N0} characters";
    public string TokenCountText => $"~{EstimatedTokenCount:N0} tokens";

    public bool HasContent => !string.IsNullOrWhiteSpace(EditorContent);
    public bool HasValidName => !string.IsNullOrWhiteSpace(PromptName);
    public bool CanSave => HasValidName && HasContent && IsDirty && string.IsNullOrEmpty(ValidationError);

    public SystemPromptEditorViewModel(
        ISystemPromptService promptService,
        IDispatcher dispatcher)
    {
        _promptService = promptService;
        _dispatcher = dispatcher;

        _promptService.PromptListChanged += OnPromptListChanged;
    }

    /// <summary>
    /// Initialize the editor
    /// </summary>
    public async Task InitializeAsync(Guid? selectPromptId = null)
    {
        try
        {
            IsLoading = true;
            ErrorMessage = null;

            await LoadPromptsAsync();

            // Select the specified prompt or the first user prompt
            if (selectPromptId.HasValue)
            {
                SelectPromptById(selectPromptId.Value);
            }
            else if (UserPrompts.Count > 0)
            {
                SelectedPrompt = UserPrompts[0];
            }
            else if (Templates.Count > 0)
            {
                // No user prompts, select first template as read-only
                SelectedPrompt = Templates[0];
            }
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Failed to load prompts: {ex.Message}";
        }
        finally
        {
            IsLoading = false;
        }
    }

    // === Property Change Handlers ===

    partial void OnSelectedPromptChanged(SystemPromptViewModel? value)
    {
        if (value == null)
        {
            ClearEditor();
            return;
        }

        LoadPromptIntoEditor(value);
    }

    partial void OnPromptNameChanged(string value)
    {
        UpdateDirtyState();
        ValidateName();
        OnPropertyChanged(nameof(HasValidName));
        OnPropertyChanged(nameof(CanSave));
    }

    partial void OnEditorContentChanged(string value)
    {
        UpdateDirtyState();
        OnPropertyChanged(nameof(CharacterCount));
        OnPropertyChanged(nameof(EstimatedTokenCount));
        OnPropertyChanged(nameof(CharacterCountText));
        OnPropertyChanged(nameof(TokenCountText));
        OnPropertyChanged(nameof(HasContent));
        OnPropertyChanged(nameof(CanSave));
    }

    partial void OnPromptDescriptionChanged(string value)
    {
        UpdateDirtyState();
    }

    // === Commands ===

    [RelayCommand]
    private async Task CreateNewPromptAsync()
    {
        if (IsDirty && !await ConfirmDiscardChangesAsync())
            return;

        // Deselect current
        SelectedPrompt = null;

        // Set up for new prompt
        IsNewPrompt = true;
        IsEditing = true;
        CanEdit = true;
        CanDelete = false;
        CanSetDefault = false;

        PromptName = "New Prompt";
        PromptDescription = string.Empty;
        EditorContent = string.Empty;

        _originalPrompt = null;
        IsDirty = false;
    }

    [RelayCommand(CanExecute = nameof(CanSave))]
    private async Task SavePromptAsync()
    {
        try
        {
            ErrorMessage = null;

            if (IsNewPrompt)
            {
                var prompt = await _promptService.CreatePromptAsync(
                    PromptName.Trim(),
                    EditorContent,
                    string.IsNullOrWhiteSpace(PromptDescription) ? null : PromptDescription.Trim());

                await LoadPromptsAsync();
                SelectPromptById(prompt.Id);

                IsNewPrompt = false;
            }
            else if (_originalPrompt != null)
            {
                await _promptService.UpdatePromptAsync(
                    _originalPrompt.Id,
                    PromptName.Trim(),
                    EditorContent,
                    string.IsNullOrWhiteSpace(PromptDescription) ? null : PromptDescription.Trim());

                // Update original for dirty tracking
                _originalPrompt = await _promptService.GetByIdAsync(_originalPrompt.Id);
            }

            IsDirty = false;
        }
        catch (Exception ex)
        {
            ErrorMessage = ex.Message;
        }
    }

    [RelayCommand(CanExecute = nameof(CanDelete))]
    private async Task DeletePromptAsync()
    {
        if (_originalPrompt == null || _originalPrompt.IsBuiltIn)
            return;

        // Confirm deletion
        var confirmed = await ConfirmDeleteAsync(_originalPrompt.Name);
        if (!confirmed)
            return;

        try
        {
            await _promptService.DeletePromptAsync(_originalPrompt.Id);
            await LoadPromptsAsync();

            // Select another prompt
            if (UserPrompts.Count > 0)
            {
                SelectedPrompt = UserPrompts[0];
            }
            else
            {
                ClearEditor();
            }
        }
        catch (Exception ex)
        {
            ErrorMessage = ex.Message;
        }
    }

    [RelayCommand]
    private async Task DuplicatePromptAsync()
    {
        if (_originalPrompt == null)
            return;

        try
        {
            var duplicate = await _promptService.DuplicatePromptAsync(_originalPrompt.Id);
            await LoadPromptsAsync();
            SelectPromptById(duplicate.Id);
        }
        catch (Exception ex)
        {
            ErrorMessage = ex.Message;
        }
    }

    [RelayCommand(CanExecute = nameof(CanSetDefault))]
    private async Task SetAsDefaultAsync()
    {
        if (_originalPrompt == null)
            return;

        try
        {
            await _promptService.SetAsDefaultAsync(_originalPrompt.Id);
            await LoadPromptsAsync();

            // Re-select to update UI
            SelectPromptById(_originalPrompt.Id);
        }
        catch (Exception ex)
        {
            ErrorMessage = ex.Message;
        }
    }

    [RelayCommand]
    private async Task CreateFromTemplateAsync(SystemPromptViewModel template)
    {
        if (IsDirty && !await ConfirmDiscardChangesAsync())
            return;

        try
        {
            var prompt = await _promptService.CreateFromTemplateAsync(template.Id);
            await LoadPromptsAsync();
            SelectPromptById(prompt.Id);
        }
        catch (Exception ex)
        {
            ErrorMessage = ex.Message;
        }
    }

    [RelayCommand]
    private void LoadTemplate(SystemPromptViewModel template)
    {
        // Load template content into editor for preview/copying
        PromptName = template.Name;
        PromptDescription = template.Description ?? string.Empty;
        EditorContent = template.Content;

        CanEdit = false;
        CanDelete = false;
        CanSetDefault = false;
        IsEditing = false;
    }

    [RelayCommand]
    private void DiscardChanges()
    {
        if (_originalPrompt != null)
        {
            LoadPromptIntoEditor(new SystemPromptViewModel(_originalPrompt));
        }
        else
        {
            ClearEditor();
        }

        IsDirty = false;
        IsNewPrompt = false;
    }

    [RelayCommand]
    private void StartEditing()
    {
        if (CanEdit)
        {
            IsEditing = true;
        }
    }

    // === Helper Methods ===

    private async Task LoadPromptsAsync()
    {
        var userPrompts = await _promptService.GetUserPromptsAsync();
        var templates = await _promptService.GetTemplatesAsync();

        await _dispatcher.InvokeAsync(() =>
        {
            UserPrompts.Clear();
            foreach (var prompt in userPrompts)
            {
                UserPrompts.Add(new SystemPromptViewModel(prompt));
            }

            Templates.Clear();
            foreach (var template in templates)
            {
                Templates.Add(new SystemPromptViewModel(template));
            }
        });
    }

    private void SelectPromptById(Guid id)
    {
        var prompt = UserPrompts.FirstOrDefault(p => p.Id == id)
                  ?? Templates.FirstOrDefault(p => p.Id == id);

        if (prompt != null)
        {
            SelectedPrompt = prompt;
        }
    }

    private void LoadPromptIntoEditor(SystemPromptViewModel viewModel)
    {
        _originalPrompt = new SystemPrompt
        {
            Id = viewModel.Id,
            Name = viewModel.Name,
            Content = viewModel.Content,
            Description = viewModel.Description,
            IsBuiltIn = viewModel.IsBuiltIn,
            IsDefault = viewModel.IsDefault
        };

        PromptName = viewModel.Name;
        PromptDescription = viewModel.Description ?? string.Empty;
        EditorContent = viewModel.Content;

        CanEdit = !viewModel.IsBuiltIn;
        CanDelete = !viewModel.IsBuiltIn;
        CanSetDefault = !viewModel.IsDefault;
        IsEditing = false;
        IsNewPrompt = false;
        IsDirty = false;
        ValidationError = null;
    }

    private void ClearEditor()
    {
        _originalPrompt = null;
        PromptName = string.Empty;
        PromptDescription = string.Empty;
        EditorContent = string.Empty;
        CanEdit = false;
        CanDelete = false;
        CanSetDefault = false;
        IsEditing = false;
        IsNewPrompt = false;
        IsDirty = false;
        ValidationError = null;
    }

    private void UpdateDirtyState()
    {
        if (_originalPrompt == null && !IsNewPrompt)
        {
            IsDirty = false;
            return;
        }

        if (IsNewPrompt)
        {
            IsDirty = !string.IsNullOrWhiteSpace(PromptName) ||
                     !string.IsNullOrWhiteSpace(EditorContent);
            return;
        }

        IsDirty = PromptName != _originalPrompt!.Name ||
                  EditorContent != _originalPrompt.Content ||
                  (PromptDescription ?? string.Empty) != (_originalPrompt.Description ?? string.Empty);
    }

    private void ValidateName()
    {
        if (string.IsNullOrWhiteSpace(PromptName))
        {
            ValidationError = null; // Don't show error for empty
            return;
        }

        if (PromptName.Length > 100)
        {
            ValidationError = "Name must be 100 characters or less";
            return;
        }

        // Check for duplicate name (async validation would need different approach)
        ValidationError = null;
    }

    private Task<bool> ConfirmDiscardChangesAsync()
    {
        // This should show a dialog - implementation depends on dialog service
        // For now, return true (discard changes)
        return Task.FromResult(true);
    }

    private Task<bool> ConfirmDeleteAsync(string promptName)
    {
        // This should show a confirmation dialog
        // Implementation depends on dialog service
        return Task.FromResult(true);
    }

    private async void OnPromptListChanged(object? sender, PromptListChangedEventArgs e)
    {
        await _dispatcher.InvokeAsync(async () =>
        {
            await LoadPromptsAsync();
        });
    }

    public void Dispose()
    {
        _promptService.PromptListChanged -= OnPromptListChanged;
    }
}
```

### SystemPromptViewModel

```csharp
namespace SeniorIntern.Desktop.ViewModels;

using CommunityToolkit.Mvvm.ComponentModel;
using SeniorIntern.Core.Models;

/// <summary>
/// ViewModel for a single system prompt in lists
/// </summary>
public partial class SystemPromptViewModel : ViewModelBase
{
    public Guid Id { get; init; }

    [ObservableProperty]
    private string _name = string.Empty;

    [ObservableProperty]
    private string _content = string.Empty;

    [ObservableProperty]
    private string? _description;

    [ObservableProperty]
    private string _category = "Custom";

    [ObservableProperty]
    private bool _isBuiltIn;

    [ObservableProperty]
    private bool _isDefault;

    [ObservableProperty]
    private bool _isSelected;

    [ObservableProperty]
    private int _usageCount;

    /// <summary>
    /// Character count for display
    /// </summary>
    public int CharacterCount => Content?.Length ?? 0;

    /// <summary>
    /// Estimated token count
    /// </summary>
    public int EstimatedTokenCount => CharacterCount / 4;

    /// <summary>
    /// Short preview of the content
    /// </summary>
    public string ContentPreview
    {
        get
        {
            if (string.IsNullOrWhiteSpace(Content))
                return string.Empty;

            var clean = Content.Replace("\n", " ").Replace("\r", " ").Trim();
            return clean.Length > 100 ? clean[..100] + "..." : clean;
        }
    }

    /// <summary>
    /// Type indicator for display
    /// </summary>
    public string TypeLabel => IsBuiltIn ? "Template" : "Custom";

    /// <summary>
    /// Icon data based on category
    /// </summary>
    public string CategoryIcon => Category switch
    {
        "Code" => "CodeIcon",
        "Creative" => "PaletteIcon",
        "Technical" => "DocumentIcon",
        "General" => "ChatIcon",
        _ => "PromptIcon"
    };

    public SystemPromptViewModel() { }

    public SystemPromptViewModel(SystemPrompt prompt)
    {
        Id = prompt.Id;
        Name = prompt.Name;
        Content = prompt.Content;
        Description = prompt.Description;
        Category = prompt.Category;
        IsBuiltIn = prompt.IsBuiltIn;
        IsDefault = prompt.IsDefault;
        UsageCount = prompt.UsageCount;
    }
}
```

### SystemPromptSelectorViewModel

```csharp
namespace SeniorIntern.Desktop.ViewModels;

using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using SeniorIntern.Core.Events;
using SeniorIntern.Core.Interfaces;
using System.Collections.ObjectModel;

/// <summary>
/// ViewModel for the quick prompt selector in the chat header
/// </summary>
public partial class SystemPromptSelectorViewModel : ViewModelBase, IDisposable
{
    private readonly ISystemPromptService _promptService;
    private readonly IConversationService _conversationService;
    private readonly IDispatcher _dispatcher;

    [ObservableProperty]
    private ObservableCollection<SystemPromptViewModel> _availablePrompts = new();

    [ObservableProperty]
    private SystemPromptViewModel? _selectedPrompt;

    [ObservableProperty]
    private bool _isLoading;

    [ObservableProperty]
    private bool _hasPromptSelected;

    /// <summary>
    /// Display text for the dropdown
    /// </summary>
    public string DisplayText => SelectedPrompt?.Name ?? "No prompt selected";

    public SystemPromptSelectorViewModel(
        ISystemPromptService promptService,
        IConversationService conversationService,
        IDispatcher dispatcher)
    {
        _promptService = promptService;
        _conversationService = conversationService;
        _dispatcher = dispatcher;

        _promptService.PromptListChanged += OnPromptListChanged;
        _promptService.CurrentPromptChanged += OnCurrentPromptChanged;
        _conversationService.ConversationChanged += OnConversationChanged;
    }

    public async Task InitializeAsync()
    {
        await LoadPromptsAsync();
        await SyncWithCurrentConversationAsync();
    }

    partial void OnSelectedPromptChanged(SystemPromptViewModel? value)
    {
        HasPromptSelected = value != null;
        OnPropertyChanged(nameof(DisplayText));
    }

    [RelayCommand]
    private async Task LoadPromptsAsync()
    {
        try
        {
            IsLoading = true;

            var prompts = await _promptService.GetAllPromptsAsync();

            await _dispatcher.InvokeAsync(() =>
            {
                AvailablePrompts.Clear();

                // Add "None" option
                AvailablePrompts.Add(new SystemPromptViewModel
                {
                    Id = Guid.Empty,
                    Name = "(No system prompt)",
                    Category = "None"
                });

                foreach (var prompt in prompts)
                {
                    AvailablePrompts.Add(new SystemPromptViewModel(prompt));
                }
            });
        }
        finally
        {
            IsLoading = false;
        }
    }

    [RelayCommand]
    private async Task ApplyPromptAsync(SystemPromptViewModel? prompt)
    {
        if (prompt == null)
            return;

        var promptId = prompt.Id == Guid.Empty ? (Guid?)null : prompt.Id;

        // Update the service's current prompt
        await _promptService.SetCurrentPromptAsync(promptId);

        // Update current conversation if one is active
        if (_conversationService.HasActiveConversation)
        {
            // The conversation service should handle updating the conversation's SystemPromptId
            // This might require an additional method on IConversationService
        }

        SelectedPrompt = prompt;
    }

    [RelayCommand]
    private async Task OpenEditorAsync()
    {
        // This should open the editor window
        // Implementation depends on window/dialog service
    }

    private async Task SyncWithCurrentConversationAsync()
    {
        var currentPrompt = _promptService.CurrentPrompt;
        if (currentPrompt != null)
        {
            await _dispatcher.InvokeAsync(() =>
            {
                SelectedPrompt = AvailablePrompts.FirstOrDefault(p => p.Id == currentPrompt.Id);
            });
        }
        else
        {
            await _dispatcher.InvokeAsync(() =>
            {
                SelectedPrompt = AvailablePrompts.FirstOrDefault(p => p.Id == Guid.Empty);
            });
        }
    }

    private async void OnPromptListChanged(object? sender, PromptListChangedEventArgs e)
    {
        await _dispatcher.InvokeAsync(async () =>
        {
            await LoadPromptsAsync();
            await SyncWithCurrentConversationAsync();
        });
    }

    private async void OnCurrentPromptChanged(object? sender, CurrentPromptChangedEventArgs e)
    {
        await _dispatcher.InvokeAsync(async () =>
        {
            await SyncWithCurrentConversationAsync();
        });
    }

    private async void OnConversationChanged(object? sender, ConversationChangedEventArgs e)
    {
        if (e.ChangeType == ConversationChangeType.Loaded ||
            e.ChangeType == ConversationChangeType.Created)
        {
            await _dispatcher.InvokeAsync(async () =>
            {
                await SyncWithCurrentConversationAsync();
            });
        }
    }

    public void Dispose()
    {
        _promptService.PromptListChanged -= OnPromptListChanged;
        _promptService.CurrentPromptChanged -= OnCurrentPromptChanged;
        _conversationService.ConversationChanged -= OnConversationChanged;
    }
}
```

### v0.2.4c Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/ViewModels/SystemPromptEditorViewModel.cs` | Main editor ViewModel |
| `src/SeniorIntern.Desktop/ViewModels/SystemPromptViewModel.cs` | Prompt item ViewModel |
| `src/SeniorIntern.Desktop/ViewModels/SystemPromptSelectorViewModel.cs` | Selector ViewModel |

---

## v0.2.4d: Editor Window UI

### Objective
Create the full system prompt editor window with a split-pane layout showing the prompt list and text editor.

### SystemPromptEditorWindow.axaml

```xml
<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:vm="using:SeniorIntern.Desktop.ViewModels"
        x:Class="SeniorIntern.Desktop.Views.SystemPromptEditorWindow"
        x:DataType="vm:SystemPromptEditorViewModel"
        Title="System Prompt Editor"
        Width="900"
        Height="650"
        MinWidth="700"
        MinHeight="500"
        WindowStartupLocation="CenterOwner">

    <Window.Resources>
        <!-- User Prompt Item Template -->
        <DataTemplate x:Key="UserPromptItemTemplate" x:DataType="vm:SystemPromptViewModel">
            <Border Classes="prompt-item"
                    Classes.selected="{Binding IsSelected}"
                    Padding="12,8"
                    Margin="2"
                    CornerRadius="4">
                <Grid RowDefinitions="Auto,Auto">
                    <Grid Grid.Row="0" ColumnDefinitions="Auto,*,Auto">
                        <!-- Default indicator -->
                        <TextBlock Grid.Column="0"
                                   Text="â˜…"
                                   IsVisible="{Binding IsDefault}"
                                   Foreground="{DynamicResource AccentColor}"
                                   FontSize="14"
                                   Margin="0,0,6,0"
                                   VerticalAlignment="Center"
                                   ToolTip.Tip="Default prompt" />

                        <!-- Name -->
                        <TextBlock Grid.Column="1"
                                   Text="{Binding Name}"
                                   FontWeight="SemiBold"
                                   TextTrimming="CharacterEllipsis" />

                        <!-- Usage count -->
                        <TextBlock Grid.Column="2"
                                   Text="{Binding UsageCount, StringFormat='Used {0}x'}"
                                   FontSize="10"
                                   Foreground="{DynamicResource TextTertiaryColor}"
                                   IsVisible="{Binding UsageCount}"
                                   VerticalAlignment="Center"
                                   Margin="8,0,0,0" />
                    </Grid>

                    <!-- Preview -->
                    <TextBlock Grid.Row="1"
                               Text="{Binding ContentPreview}"
                               FontSize="11"
                               Foreground="{DynamicResource TextSecondaryColor}"
                               TextTrimming="CharacterEllipsis"
                               Margin="0,4,0,0" />
                </Grid>
            </Border>
        </DataTemplate>

        <!-- Template Item Template -->
        <DataTemplate x:Key="TemplateItemTemplate" x:DataType="vm:SystemPromptViewModel">
            <Border Classes="template-item"
                    Padding="12,8"
                    Margin="2"
                    CornerRadius="4">
                <Grid RowDefinitions="Auto,Auto" ColumnDefinitions="Auto,*">
                    <!-- Category icon -->
                    <Border Grid.RowSpan="2"
                            Background="{DynamicResource AccentBackgroundColor}"
                            CornerRadius="4"
                            Padding="6"
                            Margin="0,0,10,0"
                            VerticalAlignment="Center">
                        <PathIcon Data="{DynamicResource PromptIcon}"
                                  Width="16" Height="16"
                                  Foreground="{DynamicResource AccentColor}" />
                    </Border>

                    <!-- Name and category -->
                    <StackPanel Grid.Column="1" Grid.Row="0" Orientation="Horizontal" Spacing="8">
                        <TextBlock Text="{Binding Name}"
                                   FontWeight="SemiBold" />
                        <Border Background="{DynamicResource ControlBackgroundColor}"
                                CornerRadius="2"
                                Padding="4,1">
                            <TextBlock Text="{Binding Category}"
                                       FontSize="10"
                                       Foreground="{DynamicResource TextSecondaryColor}" />
                        </Border>
                    </StackPanel>

                    <!-- Description -->
                    <TextBlock Grid.Column="1" Grid.Row="1"
                               Text="{Binding Description}"
                               FontSize="11"
                               Foreground="{DynamicResource TextSecondaryColor}"
                               TextWrapping="Wrap"
                               Margin="0,2,0,0" />
                </Grid>
            </Border>
        </DataTemplate>
    </Window.Resources>

    <Grid RowDefinitions="*,Auto">
        <!-- Main Content -->
        <Grid Grid.Row="0" ColumnDefinitions="260,*">
            <!-- Left Panel: Prompt Lists -->
            <Border Grid.Column="0"
                    Background="{DynamicResource SidebarBackgroundColor}"
                    BorderBrush="{DynamicResource BorderColor}"
                    BorderThickness="0,0,1,0">
                <Grid RowDefinitions="Auto,*,Auto,Auto">
                    <!-- My Prompts Header -->
                    <Grid Grid.Row="0" Margin="12,12,12,8">
                        <TextBlock Text="My Prompts"
                                   FontWeight="Bold"
                                   FontSize="13" />
                        <Button HorizontalAlignment="Right"
                                Command="{Binding CreateNewPromptCommand}"
                                Classes="icon-button"
                                ToolTip.Tip="Create New Prompt">
                            <PathIcon Data="{StaticResource PlusIcon}"
                                      Width="14" Height="14" />
                        </Button>
                    </Grid>

                    <!-- User Prompts List -->
                    <ScrollViewer Grid.Row="1"
                                  HorizontalScrollBarVisibility="Disabled">
                        <ItemsControl ItemsSource="{Binding UserPrompts}"
                                      ItemTemplate="{StaticResource UserPromptItemTemplate}">
                            <ItemsControl.ItemsPanel>
                                <ItemsPanelTemplate>
                                    <StackPanel />
                                </ItemsPanelTemplate>
                            </ItemsControl.ItemsPanel>
                        </ItemsControl>
                    </ScrollViewer>

                    <!-- Templates Header -->
                    <Border Grid.Row="2"
                            Background="{DynamicResource ControlBackgroundColor}"
                            Padding="12,8"
                            Margin="0,8,0,0">
                        <TextBlock Text="Templates"
                                   FontWeight="Bold"
                                   FontSize="13" />
                    </Border>

                    <!-- Templates List -->
                    <ScrollViewer Grid.Row="3"
                                  MaxHeight="200"
                                  HorizontalScrollBarVisibility="Disabled">
                        <ItemsControl ItemsSource="{Binding Templates}"
                                      ItemTemplate="{StaticResource TemplateItemTemplate}">
                            <ItemsControl.ItemsPanel>
                                <ItemsPanelTemplate>
                                    <StackPanel />
                                </ItemsPanelTemplate>
                            </ItemsControl.ItemsPanel>
                        </ItemsControl>
                    </ScrollViewer>
                </Grid>
            </Border>

            <!-- Right Panel: Editor -->
            <Grid Grid.Column="1" RowDefinitions="Auto,Auto,*,Auto" Margin="16">
                <!-- Name Field -->
                <StackPanel Grid.Row="0" Spacing="4">
                    <TextBlock Text="Name" FontWeight="SemiBold" />
                    <TextBox Text="{Binding PromptName}"
                             Watermark="Enter prompt name"
                             IsReadOnly="{Binding !CanEdit}"
                             MaxLength="100" />
                    <TextBlock Text="{Binding ValidationError}"
                               IsVisible="{Binding ValidationError, Converter={x:Static StringConverters.IsNotNullOrEmpty}}"
                               Foreground="{DynamicResource ErrorForegroundColor}"
                               FontSize="11" />
                </StackPanel>

                <!-- Description Field -->
                <StackPanel Grid.Row="1" Spacing="4" Margin="0,12,0,0">
                    <TextBlock Text="Description (optional)" />
                    <TextBox Text="{Binding PromptDescription}"
                             Watermark="Brief description of this prompt"
                             IsReadOnly="{Binding !CanEdit}"
                             MaxLength="500" />
                </StackPanel>

                <!-- Content Editor -->
                <Grid Grid.Row="2" RowDefinitions="Auto,*" Margin="0,16,0,0">
                    <Grid Grid.Row="0" ColumnDefinitions="*,Auto" Margin="0,0,0,8">
                        <TextBlock Text="System Prompt Content"
                                   FontWeight="SemiBold" />

                        <!-- Edit button for built-in prompts -->
                        <Button Grid.Column="1"
                                Content="Create Copy to Edit"
                                Command="{Binding CreateFromTemplateCommand}"
                                CommandParameter="{Binding SelectedPrompt}"
                                IsVisible="{Binding SelectedPrompt.IsBuiltIn}"
                                Classes="link-button" />
                    </Grid>

                    <TextBox Grid.Row="1"
                             Text="{Binding EditorContent}"
                             AcceptsReturn="True"
                             AcceptsTab="True"
                             TextWrapping="Wrap"
                             IsReadOnly="{Binding !CanEdit}"
                             FontFamily="Consolas, Menlo, monospace"
                             FontSize="13"
                             Padding="12"
                             Classes="code-editor" />
                </Grid>

                <!-- Stats Footer -->
                <Border Grid.Row="3"
                        Background="{DynamicResource ControlBackgroundColor}"
                        CornerRadius="4"
                        Padding="12,8"
                        Margin="0,12,0,0">
                    <Grid ColumnDefinitions="*,Auto,Auto">
                        <!-- Character/Token count -->
                        <StackPanel Orientation="Horizontal" Spacing="16">
                            <TextBlock Text="{Binding CharacterCountText}"
                                       FontSize="12"
                                       Foreground="{DynamicResource TextSecondaryColor}" />
                            <TextBlock Text="{Binding TokenCountText}"
                                       FontSize="12"
                                       Foreground="{DynamicResource TextSecondaryColor}" />
                        </StackPanel>

                        <!-- Dirty indicator -->
                        <TextBlock Grid.Column="1"
                                   Text="â€¢ Modified"
                                   IsVisible="{Binding IsDirty}"
                                   Foreground="{DynamicResource WarningColor}"
                                   FontSize="12"
                                   Margin="0,0,16,0" />

                        <!-- Built-in indicator -->
                        <Border Grid.Column="2"
                                IsVisible="{Binding SelectedPrompt.IsBuiltIn}"
                                Background="{DynamicResource InfoBackgroundColor}"
                                CornerRadius="4"
                                Padding="8,2">
                            <TextBlock Text="Read-only Template"
                                       FontSize="11"
                                       Foreground="{DynamicResource InfoForegroundColor}" />
                        </Border>
                    </Grid>
                </Border>
            </Grid>
        </Grid>

        <!-- Bottom Action Bar -->
        <Border Grid.Row="1"
                Background="{DynamicResource PanelBackgroundColor}"
                BorderBrush="{DynamicResource BorderColor}"
                BorderThickness="0,1,0,0"
                Padding="16,12">
            <Grid ColumnDefinitions="Auto,*,Auto">
                <!-- Left actions -->
                <StackPanel Grid.Column="0"
                            Orientation="Horizontal"
                            Spacing="8">
                    <Button Content="Delete"
                            Command="{Binding DeletePromptCommand}"
                            IsEnabled="{Binding CanDelete}"
                            Classes="destructive" />
                    <Button Content="Duplicate"
                            Command="{Binding DuplicatePromptCommand}"
                            IsEnabled="{Binding SelectedPrompt, Converter={x:Static ObjectConverters.IsNotNull}}" />
                    <Button Content="Set as Default"
                            Command="{Binding SetAsDefaultCommand}"
                            IsEnabled="{Binding CanSetDefault}" />
                </StackPanel>

                <!-- Right actions -->
                <StackPanel Grid.Column="2"
                            Orientation="Horizontal"
                            Spacing="8">
                    <Button Content="Discard"
                            Command="{Binding DiscardChangesCommand}"
                            IsVisible="{Binding IsDirty}" />
                    <Button Content="Save"
                            Command="{Binding SavePromptCommand}"
                            Classes="accent"
                            IsEnabled="{Binding CanSave}" />
                </StackPanel>
            </Grid>
        </Border>

        <!-- Loading Overlay -->
        <Border Grid.RowSpan="2"
                IsVisible="{Binding IsLoading}"
                Background="#80000000">
            <StackPanel HorizontalAlignment="Center"
                        VerticalAlignment="Center"
                        Spacing="12">
                <ProgressRing Width="32" Height="32" />
                <TextBlock Text="Loading..."
                           Foreground="White" />
            </StackPanel>
        </Border>

        <!-- Error Message -->
        <Border Grid.Row="0"
                IsVisible="{Binding ErrorMessage, Converter={x:Static StringConverters.IsNotNullOrEmpty}}"
                Background="{DynamicResource ErrorBackgroundColor}"
                Padding="16,12"
                Margin="16"
                CornerRadius="8"
                VerticalAlignment="Top"
                HorizontalAlignment="Center">
            <StackPanel Orientation="Horizontal" Spacing="12">
                <PathIcon Data="{StaticResource ErrorIcon}"
                          Width="20" Height="20"
                          Foreground="{DynamicResource ErrorForegroundColor}" />
                <TextBlock Text="{Binding ErrorMessage}"
                           Foreground="{DynamicResource ErrorForegroundColor}" />
                <Button Content="âœ•"
                        Command="{Binding ClearErrorCommand}"
                        Classes="icon-button small" />
            </StackPanel>
        </Border>
    </Grid>
</Window>
```

### SystemPromptEditorWindow.axaml.cs

```csharp
namespace SeniorIntern.Desktop.Views;

using Avalonia.Controls;
using Avalonia.Input;
using Avalonia.Interactivity;
using SeniorIntern.Desktop.ViewModels;

public partial class SystemPromptEditorWindow : Window
{
    public SystemPromptEditorWindow()
    {
        InitializeComponent();
    }

    private SystemPromptEditorViewModel? ViewModel => DataContext as SystemPromptEditorViewModel;

    protected override void OnLoaded(RoutedEventArgs e)
    {
        base.OnLoaded(e);

        // Initialize the ViewModel
        _ = ViewModel?.InitializeAsync();
    }

    protected override async void OnClosing(WindowClosingEventArgs e)
    {
        if (ViewModel?.IsDirty == true)
        {
            e.Cancel = true;

            // Show confirmation dialog
            var result = await ShowUnsavedChangesDialogAsync();

            switch (result)
            {
                case UnsavedChangesResult.Save:
                    if (ViewModel.SavePromptCommand.CanExecute(null))
                    {
                        await ViewModel.SavePromptCommand.ExecuteAsync(null);
                    }
                    Close();
                    break;

                case UnsavedChangesResult.DontSave:
                    Close();
                    break;

                case UnsavedChangesResult.Cancel:
                    // Already cancelled
                    break;
            }
        }

        base.OnClosing(e);
    }

    protected override void OnKeyDown(KeyEventArgs e)
    {
        base.OnKeyDown(e);

        if (e.KeyModifiers == KeyModifiers.Control)
        {
            switch (e.Key)
            {
                case Key.S:
                    if (ViewModel?.SavePromptCommand.CanExecute(null) == true)
                    {
                        _ = ViewModel.SavePromptCommand.ExecuteAsync(null);
                    }
                    e.Handled = true;
                    break;

                case Key.N:
                    if (ViewModel?.CreateNewPromptCommand.CanExecute(null) == true)
                    {
                        _ = ViewModel.CreateNewPromptCommand.ExecuteAsync(null);
                    }
                    e.Handled = true;
                    break;
            }
        }
        else if (e.Key == Key.Escape)
        {
            if (ViewModel?.IsDirty == true)
            {
                ViewModel.DiscardChangesCommand.Execute(null);
            }
            else
            {
                Close();
            }
            e.Handled = true;
        }
    }

    private Task<UnsavedChangesResult> ShowUnsavedChangesDialogAsync()
    {
        // Implementation of dialog
        return Task.FromResult(UnsavedChangesResult.DontSave);
    }

    private enum UnsavedChangesResult
    {
        Save,
        DontSave,
        Cancel
    }
}
```

### Editor Styles (in Dark.axaml)

```xml
<!-- Prompt Editor Styles -->
<Style Selector="Border.prompt-item">
    <Setter Property="Background" Value="Transparent" />
    <Setter Property="Cursor" Value="Hand" />
</Style>

<Style Selector="Border.prompt-item:pointerover">
    <Setter Property="Background" Value="{DynamicResource ControlHoverBackgroundColor}" />
</Style>

<Style Selector="Border.prompt-item.selected">
    <Setter Property="Background" Value="{DynamicResource AccentBackgroundColor}" />
</Style>

<Style Selector="Border.template-item">
    <Setter Property="Background" Value="Transparent" />
    <Setter Property="Cursor" Value="Hand" />
</Style>

<Style Selector="Border.template-item:pointerover">
    <Setter Property="Background" Value="{DynamicResource ControlHoverBackgroundColor}" />
</Style>

<Style Selector="TextBox.code-editor">
    <Setter Property="BorderThickness" Value="1" />
    <Setter Property="BorderBrush" Value="{DynamicResource BorderColor}" />
    <Setter Property="CornerRadius" Value="4" />
</Style>

<Style Selector="Button.link-button">
    <Setter Property="Background" Value="Transparent" />
    <Setter Property="BorderThickness" Value="0" />
    <Setter Property="Foreground" Value="{DynamicResource AccentColor}" />
    <Setter Property="Padding" Value="0" />
</Style>

<Style Selector="Button.link-button:pointerover">
    <Setter Property="Foreground" Value="{DynamicResource AccentHoverColor}" />
</Style>

<Style Selector="Button.destructive">
    <Setter Property="Background" Value="{DynamicResource ErrorBackgroundColor}" />
    <Setter Property="Foreground" Value="{DynamicResource ErrorForegroundColor}" />
</Style>
```

### v0.2.4d Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/Views/SystemPromptEditorWindow.axaml` | Editor window XAML |
| `src/SeniorIntern.Desktop/Views/SystemPromptEditorWindow.axaml.cs` | Editor code-behind |

### v0.2.4d Files to Modify

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/Themes/Dark.axaml` | Add editor styles |

---

## v0.2.4e: Chat Integration

### Objective
Integrate system prompts with the chat interface, including the quick selector dropdown, conversation-prompt binding, and LLM context formatting.

### SystemPromptSelector.axaml

```xml
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:vm="using:SeniorIntern.Desktop.ViewModels"
             x:Class="SeniorIntern.Desktop.Views.SystemPromptSelector"
             x:DataType="vm:SystemPromptSelectorViewModel">

    <Border Background="{DynamicResource ControlBackgroundColor}"
            CornerRadius="4"
            Padding="8,4">
        <Grid ColumnDefinitions="Auto,*,Auto">
            <!-- Label -->
            <TextBlock Grid.Column="0"
                       Text="Using:"
                       FontSize="12"
                       Foreground="{DynamicResource TextSecondaryColor}"
                       VerticalAlignment="Center"
                       Margin="0,0,8,0" />

            <!-- Prompt Dropdown -->
            <ComboBox Grid.Column="1"
                      ItemsSource="{Binding AvailablePrompts}"
                      SelectedItem="{Binding SelectedPrompt}"
                      HorizontalAlignment="Stretch"
                      MinWidth="150"
                      MaxWidth="300">
                <ComboBox.ItemTemplate>
                    <DataTemplate x:DataType="vm:SystemPromptViewModel">
                        <Grid ColumnDefinitions="Auto,*">
                            <!-- Default indicator -->
                            <TextBlock Text="â˜…"
                                       IsVisible="{Binding IsDefault}"
                                       Foreground="{DynamicResource AccentColor}"
                                       Margin="0,0,6,0"
                                       VerticalAlignment="Center" />

                            <StackPanel Grid.Column="1" Spacing="2">
                                <TextBlock Text="{Binding Name}"
                                           FontWeight="{Binding IsDefault, Converter={StaticResource BoolToFontWeightConverter}}" />
                                <TextBlock Text="{Binding Category}"
                                           FontSize="10"
                                           Foreground="{DynamicResource TextTertiaryColor}"
                                           IsVisible="{Binding Category, Converter={x:Static StringConverters.IsNotNullOrEmpty}}" />
                            </StackPanel>
                        </Grid>
                    </DataTemplate>
                </ComboBox.ItemTemplate>
            </ComboBox>

            <!-- Edit button -->
            <Button Grid.Column="2"
                    Command="{Binding OpenEditorCommand}"
                    ToolTip.Tip="Edit Prompts"
                    Classes="icon-button small"
                    Margin="8,0,0,0">
                <PathIcon Data="{StaticResource EditIcon}"
                          Width="14" Height="14" />
            </Button>
        </Grid>
    </Border>
</UserControl>
```

### SystemPromptSelector.axaml.cs

```csharp
namespace SeniorIntern.Desktop.Views;

using Avalonia.Controls;

public partial class SystemPromptSelector : UserControl
{
    public SystemPromptSelector()
    {
        InitializeComponent();
    }
}
```

### ChatView Updates

```xml
<!-- Add to top of ChatView.axaml, before message list -->
<Grid RowDefinitions="Auto,*,Auto">
    <!-- System Prompt Selector Header -->
    <Border Grid.Row="0"
            Background="{DynamicResource PanelBackgroundColor}"
            Padding="12,8"
            BorderBrush="{DynamicResource BorderColor}"
            BorderThickness="0,0,0,1">
        <views:SystemPromptSelector DataContext="{Binding SystemPromptSelectorViewModel}" />
    </Border>

    <!-- Message List (existing) -->
    <ScrollViewer Grid.Row="1" ... />

    <!-- Input Area (existing) -->
    <Border Grid.Row="2" ... />
</Grid>
```

### ChatViewModel Updates

```csharp
namespace SeniorIntern.Desktop.ViewModels;

public partial class ChatViewModel : ViewModelBase
{
    private readonly ISystemPromptService _systemPromptService;

    [ObservableProperty]
    private SystemPromptSelectorViewModel _systemPromptSelectorViewModel;

    [ObservableProperty]
    private bool _showSystemPromptMessage;

    [ObservableProperty]
    private string? _systemPromptContent;

    [ObservableProperty]
    private string? _systemPromptName;

    public ChatViewModel(
        IConversationService conversationService,
        ILlmService llmService,
        ISystemPromptService systemPromptService,
        IDispatcher dispatcher)
    {
        _conversationService = conversationService;
        _llmService = llmService;
        _systemPromptService = systemPromptService;

        _systemPromptSelectorViewModel = new SystemPromptSelectorViewModel(
            systemPromptService,
            conversationService,
            dispatcher);

        // Subscribe to prompt changes
        _systemPromptService.CurrentPromptChanged += OnCurrentPromptChanged;
    }

    private void OnCurrentPromptChanged(object? sender, CurrentPromptChangedEventArgs e)
    {
        _dispatcher.InvokeAsync(() =>
        {
            if (e.NewPrompt != null)
            {
                ShowSystemPromptMessage = true;
                SystemPromptContent = e.NewPrompt.Content;
                SystemPromptName = e.NewPrompt.Name;
            }
            else
            {
                ShowSystemPromptMessage = false;
                SystemPromptContent = null;
                SystemPromptName = null;
            }
        });
    }

    // Update the generate method to include system prompt
    private async Task GenerateResponseAsync(string userInput)
    {
        // Get current system prompt
        var systemPrompt = _systemPromptService.CurrentPrompt;

        // Build context with system prompt
        var context = BuildContextWithSystemPrompt(systemPrompt);

        // ... rest of generation logic
    }

    private IEnumerable<ChatMessage> BuildContextWithSystemPrompt(SystemPrompt? systemPrompt)
    {
        if (systemPrompt != null)
        {
            yield return new ChatMessage
            {
                Role = MessageRole.System,
                Content = _systemPromptService.FormatPromptForContext(systemPrompt),
                Timestamp = DateTime.UtcNow
            };
        }

        foreach (var message in _conversationService.GetMessages())
        {
            yield return message;
        }
    }
}
```

### LlmService Integration

```csharp
namespace SeniorIntern.Services;

public sealed class LlmService : ILlmService
{
    public async IAsyncEnumerable<string> GenerateStreamingAsync(
        IEnumerable<ChatMessage> conversation,
        InferenceOptions? options = null,
        [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        // Conversation should already include system message if present
        var messages = conversation.ToList();

        // Convert to LLamaSharp chat history
        var chatHistory = new ChatHistory();

        foreach (var message in messages)
        {
            var role = message.Role switch
            {
                MessageRole.System => AuthorRole.System,
                MessageRole.User => AuthorRole.User,
                MessageRole.Assistant => AuthorRole.Assistant,
                _ => AuthorRole.User
            };

            chatHistory.AddMessage(role, message.Content);
        }

        // Generate with the full context including system prompt
        // ... inference logic
    }
}
```

### System Prompt Message Display

```xml
<!-- In ChatView.axaml, at top of message list -->
<Border IsVisible="{Binding ShowSystemPromptMessage}"
        Background="{DynamicResource SystemPromptBackgroundColor}"
        Padding="12"
        Margin="12,12,12,0"
        CornerRadius="8">
    <Expander Header="System Prompt"
              IsExpanded="False">
        <Expander.HeaderTemplate>
            <DataTemplate>
                <StackPanel Orientation="Horizontal" Spacing="8">
                    <PathIcon Data="{StaticResource PromptIcon}"
                              Width="16" Height="16"
                              Foreground="{DynamicResource TextSecondaryColor}" />
                    <TextBlock Text="{Binding $parent[Border].((vm:ChatViewModel)DataContext).SystemPromptName, StringFormat='Using: {0}'}"
                               FontWeight="SemiBold"
                               Foreground="{DynamicResource TextSecondaryColor}" />
                </StackPanel>
            </DataTemplate>
        </Expander.HeaderTemplate>

        <TextBlock Text="{Binding SystemPromptContent}"
                   TextWrapping="Wrap"
                   Foreground="{DynamicResource TextSecondaryColor}"
                   FontSize="12"
                   Margin="24,8,0,0" />
    </Expander>
</Border>
```

### MainWindowViewModel Updates

```csharp
public partial class MainWindowViewModel : ViewModelBase
{
    // ... existing properties ...

    [RelayCommand]
    private async Task OpenSystemPromptEditorAsync()
    {
        var window = new SystemPromptEditorWindow
        {
            DataContext = new SystemPromptEditorViewModel(
                _systemPromptService,
                _dispatcher)
        };

        await window.ShowDialog(GetMainWindow());
    }
}
```

### v0.2.4e Files to Create

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/Views/SystemPromptSelector.axaml` | Quick selector control |
| `src/SeniorIntern.Desktop/Views/SystemPromptSelector.axaml.cs` | Selector code-behind |

### v0.2.4e Files to Modify

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/Views/ChatView.axaml` | Add selector header, prompt display |
| `src/SeniorIntern.Desktop/ViewModels/ChatViewModel.cs` | Integrate with system prompts |
| `src/SeniorIntern.Desktop/ViewModels/MainWindowViewModel.cs` | Add open editor command |
| `src/SeniorIntern.Services/LlmService.cs` | Handle system messages |
| `src/SeniorIntern.Desktop/Extensions/ServiceCollectionExtensions.cs` | Register services |

---

## Files Summary

### Files to Create (Total: 14)

| Part | File |
|------|------|
| v0.2.4a | `src/SeniorIntern.Core/Models/SystemPrompt.cs` |
| v0.2.4a | `src/SeniorIntern.Core/Templates/SystemPromptTemplates.cs` |
| v0.2.4a | `src/SeniorIntern.Data/Repositories/ISystemPromptRepository.cs` |
| v0.2.4a | `src/SeniorIntern.Data/Repositories/SystemPromptRepository.cs` |
| v0.2.4b | `src/SeniorIntern.Core/Interfaces/ISystemPromptService.cs` |
| v0.2.4b | `src/SeniorIntern.Core/Events/PromptListChangedEventArgs.cs` |
| v0.2.4b | `src/SeniorIntern.Core/Events/CurrentPromptChangedEventArgs.cs` |
| v0.2.4b | `src/SeniorIntern.Services/SystemPromptService.cs` |
| v0.2.4c | `src/SeniorIntern.Desktop/ViewModels/SystemPromptEditorViewModel.cs` |
| v0.2.4c | `src/SeniorIntern.Desktop/ViewModels/SystemPromptViewModel.cs` |
| v0.2.4c | `src/SeniorIntern.Desktop/ViewModels/SystemPromptSelectorViewModel.cs` |
| v0.2.4d | `src/SeniorIntern.Desktop/Views/SystemPromptEditorWindow.axaml` |
| v0.2.4d | `src/SeniorIntern.Desktop/Views/SystemPromptEditorWindow.axaml.cs` |
| v0.2.4e | `src/SeniorIntern.Desktop/Views/SystemPromptSelector.axaml` |

### Files to Modify (Total: 9)

| Part | File | Changes |
|------|------|---------|
| v0.2.4a | `src/SeniorIntern.Core/Entities/SystemPromptEntity.cs` | Add fields |
| v0.2.4a | `src/SeniorIntern.Data/Configurations/SystemPromptConfiguration.cs` | Update config |
| v0.2.4b | `src/SeniorIntern.Core/Models/AppSettings.cs` | Add CurrentSystemPromptId |
| v0.2.4d | `src/SeniorIntern.Desktop/Themes/Dark.axaml` | Add editor styles |
| v0.2.4e | `src/SeniorIntern.Desktop/Views/ChatView.axaml` | Add selector, prompt display |
| v0.2.4e | `src/SeniorIntern.Desktop/ViewModels/ChatViewModel.cs` | Integrate prompts |
| v0.2.4e | `src/SeniorIntern.Desktop/ViewModels/MainWindowViewModel.cs` | Add editor command |
| v0.2.4e | `src/SeniorIntern.Services/LlmService.cs` | Handle system messages |
| v0.2.4e | `src/SeniorIntern.Desktop/Extensions/ServiceCollectionExtensions.cs` | Register services |

---

## Testing Strategy

### Unit Tests

```csharp
public class SystemPromptServiceTests
{
    [Fact]
    public async Task CreatePrompt_ShouldValidateName()
    {
        var service = CreateService();

        await Assert.ThrowsAsync<ArgumentException>(
            () => service.CreatePromptAsync("", "content"));
    }

    [Fact]
    public async Task CreatePrompt_ShouldPreventDuplicateNames()
    {
        var service = CreateService();
        await service.CreatePromptAsync("Test", "content");

        await Assert.ThrowsAsync<InvalidOperationException>(
            () => service.CreatePromptAsync("Test", "other content"));
    }

    [Fact]
    public async Task DeletePrompt_ShouldNotDeleteBuiltIn()
    {
        var service = CreateService();
        var templates = await service.GetTemplatesAsync();
        var snarky = templates.First(t => t.Name == "The Senior Intern");

        await Assert.ThrowsAsync<InvalidOperationException>(
            () => service.DeletePromptAsync(snarky.Id));
    }

    [Fact]
    public async Task SetAsDefault_ShouldClearPreviousDefault()
    {
        var service = CreateService();
        var prompt1 = await service.CreatePromptAsync("P1", "content");
        var prompt2 = await service.CreatePromptAsync("P2", "content");

        await service.SetAsDefaultAsync(prompt1.Id);
        await service.SetAsDefaultAsync(prompt2.Id);

        var all = await service.GetAllPromptsAsync();
        Assert.Single(all.Where(p => p.IsDefault));
    }
}

public class SystemPromptEditorViewModelTests
{
    [Fact]
    public void CharacterCount_ShouldUpdateWithContent()
    {
        var vm = CreateViewModel();
        vm.EditorContent = "Hello World";

        Assert.Equal(11, vm.CharacterCount);
    }

    [Fact]
    public void IsDirty_ShouldBeTrue_WhenContentChanges()
    {
        var vm = CreateViewModel();
        vm.EditorContent = "Original";
        vm.IsDirty = false; // Reset

        vm.EditorContent = "Modified";

        Assert.True(vm.IsDirty);
    }

    [Fact]
    public void CanEdit_ShouldBeFalse_ForBuiltInPrompts()
    {
        var vm = CreateViewModel();
        vm.SelectedPrompt = new SystemPromptViewModel { IsBuiltIn = true };

        Assert.False(vm.CanEdit);
    }
}
```

### Integration Tests

```csharp
public class SystemPromptIntegrationTests
{
    [Fact]
    public async Task FullWorkflow_CreateEditDeletePrompt()
    {
        // Create
        var prompt = await service.CreatePromptAsync("Test", "Content");
        Assert.NotNull(prompt);

        // Update
        await service.UpdatePromptAsync(prompt.Id, content: "New Content");
        var updated = await service.GetByIdAsync(prompt.Id);
        Assert.Equal("New Content", updated?.Content);

        // Delete
        await service.DeletePromptAsync(prompt.Id);
        var deleted = await service.GetByIdAsync(prompt.Id);
        Assert.Null(deleted);
    }

    [Fact]
    public async Task SystemPrompt_ShouldBeSentToLlm()
    {
        // Set a system prompt
        var prompt = await promptService.CreatePromptAsync("Test", "You are helpful");
        await promptService.SetCurrentPromptAsync(prompt.Id);

        // Generate a response
        // Verify the system message is included in the context
    }
}
```

---

## Acceptance Criteria

### v0.2.4a - Models & Repository
- [ ] SystemPrompt model validates all fields
- [ ] Repository CRUD operations work correctly
- [ ] 8 built-in templates are seeded on first run
- [ ] Cannot delete or modify built-in prompts
- [ ] Name uniqueness is enforced

### v0.2.4b - Service Layer
- [ ] Service initializes and loads default prompt
- [ ] Create, update, delete operations work
- [ ] Events fire correctly
- [ ] Current prompt persists across restarts

### v0.2.4c - ViewModels
- [ ] Editor ViewModel loads prompts and templates
- [ ] Character/token counts update in real-time
- [ ] Dirty state tracking works
- [ ] All commands execute correctly

### v0.2.4d - Editor Window
- [ ] Window displays prompt list and editor
- [ ] Can select, edit, and save prompts
- [ ] Templates are read-only but can be duplicated
- [ ] Keyboard shortcuts work (Ctrl+S, Ctrl+N, Esc)
- [ ] Unsaved changes warning appears on close

### v0.2.4e - Chat Integration
- [ ] Quick selector shows all prompts
- [ ] Selecting prompt updates conversation
- [ ] System prompt is sent to LLM
- [ ] Prompt message displays in chat (collapsible)
- [ ] "Edit Prompts" button opens editor

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Large prompts slow inference | Medium | Medium | Show token count, warn at limits |
| Prompt injection | Low | High | Sanitize/escape if needed |
| Lost prompt content | Low | High | Auto-save, confirm on close |
| Template confusion | Medium | Low | Clear built-in vs custom UI |
| Context window overflow | Medium | High | Validate prompt + history fits |

---

## Future Considerations

### v0.2.5+ Enhancements
- Import/export prompts as files
- Prompt variables ({{name}}, {{date}})
- Prompt chaining (multiple system messages)
- Community prompt sharing
- Prompt versioning/history

### Performance Optimization
- Cache prompts in memory
- Lazy-load prompt content for lists
- Background validation

---

## References

- [LLamaSharp Chat API](https://github.com/SciSharp/LLamaSharp/wiki/Chat-API)
- [System Prompt Best Practices](https://platform.openai.com/docs/guides/prompt-engineering)
- [Avalonia Window Documentation](https://docs.avaloniaui.net/docs/controls/window)
