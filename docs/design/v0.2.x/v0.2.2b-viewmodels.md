# Design Specification: AIntern v0.2.2b "ViewModels"

## Executive Summary

This document provides a detailed implementation specification for v0.2.2b, which creates the ViewModels for the conversation list sidebar. These ViewModels bridge the service layer (v0.2.2a) with the UI layer (v0.2.2c), implementing grouping logic, selection handling, debounced search, inline renaming, and context menu commands.

v0.2.2b establishes the reactive data binding layer that enables the sidebar to dynamically update as conversations are created, modified, archived, or deleted.

### v0.2.2b Scope (from v0.2.2 Design Document)

- Create `ConversationListViewModel` with grouping and command logic
- Create `ConversationGroupViewModel` for date-based groups
- Create `ConversationSummaryViewModel` for individual items
- Implement `IDispatcher` abstraction for UI thread marshalling
- Create `AvaloniaDispatcher` implementation
- Handle service events and update UI state reactively

### Key Deliverables

| Deliverable | Description |
|-------------|-------------|
| ConversationListViewModel | Main ViewModel with 12 commands, search debouncing, event handling |
| ConversationGroupViewModel | Group container with expand/collapse, title, and item collection |
| ConversationSummaryViewModel | Item ViewModel with selection, rename state, relative time display |
| IDispatcher | Abstraction for testable UI thread dispatching |
| AvaloniaDispatcher | Production implementation using Avalonia's Dispatcher |

---

## Feature Overview

```
┌──────────────────────────────────────────────────────────────────┐
│                     v0.2.2b Feature Tree                          │
├──────────────────────────────────────────────────────────────────┤
│                                                                   │
│  ViewModels                                                       │
│  ├── ConversationListViewModel                                    │
│  │   ├── Properties                                               │
│  │   │   ├── Groups (ObservableCollection<GroupVM>)               │
│  │   │   ├── SelectedConversation                                 │
│  │   │   ├── SearchQuery (with debounce)                          │
│  │   │   ├── IsLoading, IsEmpty, IsSearching                      │
│  │   │   └── ErrorMessage                                         │
│  │   │                                                            │
│  │   ├── Commands                                                 │
│  │   │   ├── LoadConversationsCommand                             │
│  │   │   ├── CreateNewConversationCommand                         │
│  │   │   ├── SelectConversationCommand                            │
│  │   │   ├── DeleteConversationCommand                            │
│  │   │   ├── RenameConversationCommand                            │
│  │   │   ├── ConfirmRenameCommand                                 │
│  │   │   ├── CancelRenameCommand                                  │
│  │   │   ├── ArchiveConversationCommand                           │
│  │   │   ├── TogglePinCommand                                     │
│  │   │   └── ClearSearchCommand                                   │
│  │   │                                                            │
│  │   └── Event Handlers                                           │
│  │       ├── OnConversationListChanged → Reload list              │
│  │       └── OnConversationChanged → Update selection             │
│  │                                                                │
│  ├── ConversationGroupViewModel                                   │
│  │   ├── DateGroup (enum value)                                   │
│  │   ├── Title ("Today", "Yesterday", etc.)                       │
│  │   ├── IsExpanded (for collapse/expand)                         │
│  │   ├── Conversations (ObservableCollection<SummaryVM>)          │
│  │   └── Count (computed from Conversations)                      │
│  │                                                                │
│  ├── ConversationSummaryViewModel                                 │
│  │   ├── Identity: Id, Title, UpdatedAt                           │
│  │   ├── Display: Preview, MessageCount, ModelName                │
│  │   ├── State: IsSelected, IsPinned                              │
│  │   ├── Rename: IsRenaming, EditingTitle                         │
│  │   └── Computed: RelativeTime, MessageCountText                 │
│  │                                                                │
│  └── IDispatcher + AvaloniaDispatcher                             │
│      ├── InvokeAsync(Action)                                      │
│      ├── InvokeAsync<T>(Func<T>)                                  │
│      └── InvokeAsync(Func<Task>)                                  │
│                                                                   │
└──────────────────────────────────────────────────────────────────┘
```

---

## Architecture Diagrams

### ViewModel Layer Position

```
┌─────────────────────────────────────────────────────────────────┐
│                    SeniorIntern.Desktop                          │
│                    (Presentation Layer)                          │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────────┐ │
│  │                        Views (AXAML)                         │ │
│  │  ConversationListView    MainWindow    ChatView              │ │
│  └──────────────────────────────┬──────────────────────────────┘ │
│                                 │ DataBinding                    │
│  ┌──────────────────────────────▼──────────────────────────────┐ │
│  │                       ViewModels                             │ │
│  │  ┌─────────────────┐  ┌─────────────────┐                   │ │
│  │  │Conversation     │  │ MainWindow      │                   │ │
│  │  │ ListViewModel   │  │ ViewModel       │                   │ │
│  │  │                 │  │                 │                   │ │
│  │  │ ┌─────────────┐ │  │                 │                   │ │
│  │  │ │GroupVM      │ │  │                 │                   │ │
│  │  │ │ ┌─────────┐ │ │  │                 │                   │ │
│  │  │ │ │SummaryVM│ │ │  │                 │                   │ │
│  │  │ │ └─────────┘ │ │  │                 │                   │ │
│  │  │ └─────────────┘ │  │                 │                   │ │
│  │  └────────┬────────┘  └────────┬────────┘                   │ │
│  └───────────┼────────────────────┼────────────────────────────┘ │
│              │                    │                              │
│  ┌───────────▼────────────────────▼────────────────────────────┐ │
│  │                       IDispatcher                            │ │
│  │                    (UI Thread Marshalling)                    │ │
│  │                           │                                  │ │
│  │                ┌──────────▼──────────┐                       │ │
│  │                │ AvaloniaDispatcher  │                       │ │
│  │                │ (Dispatcher.UIThread│                       │ │
│  │                └─────────────────────┘                       │ │
│  └──────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────┘
                              │ Uses
┌─────────────────────────────▼───────────────────────────────────┐
│                    SeniorIntern.Services                         │
│                    (Application Layer)                           │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │  IConversationService (→ Events to ViewModels)             │  │
│  └───────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
```

### Data Flow: Selection Change

```
┌─────────────────────────────────────────────────────────────────┐
│                    Selection Change Flow                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  User clicks conversation item                                   │
│              │                                                   │
│              ▼                                                   │
│  ┌──────────────────────┐                                        │
│  │ View: PointerPressed │                                        │
│  │ → SelectConversation │                                        │
│  │    Command           │                                        │
│  └───────────┬──────────┘                                        │
│              │                                                   │
│              ▼                                                   │
│  ┌──────────────────────────────────────────────────────────┐    │
│  │ ConversationListViewModel.SelectConversationAsync()        │    │
│  │  1. Check if same as current → return                      │    │
│  │  2. Set IsLoading = true                                   │    │
│  │  3. Call service.LoadConversationAsync(id)                 │    │
│  │  4. Set SelectedConversation = item                        │    │
│  │  5. Set IsLoading = false                                  │    │
│  └───────────┬──────────────────────────────────────────────┘    │
│              │                                                   │
│              ▼                                                   │
│  ┌──────────────────────────────────────────────────────────┐    │
│  │ IConversationService.LoadConversationAsync()               │    │
│  │  - Saves current if dirty                                  │    │
│  │  - Loads from repository                                   │    │
│  │  - Fires ConversationChanged(Loaded)                       │    │
│  └───────────┬──────────────────────────────────────────────┘    │
│              │                                                   │
│              ▼                                                   │
│  ┌──────────────────────────────────────────────────────────┐    │
│  │ ConversationListViewModel.OnConversationChanged()          │    │
│  │  - Dispatches to UI thread                                 │    │
│  │  - Calls UpdateSelection()                                 │    │
│  │  - Sets IsSelected on correct item                         │    │
│  └──────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Data Flow: Search with Debounce

```
┌─────────────────────────────────────────────────────────────────┐
│                    Search Debounce Flow                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  User types in search box                                        │
│     "he" → "hel" → "help" (200ms between keystrokes)             │
│              │                                                   │
│              ▼                                                   │
│  ┌──────────────────────────────────────────────────────────┐    │
│  │ SearchQuery property setter (CommunityToolkit gen)         │    │
│  │  → OnSearchQueryChanged partial method                     │    │
│  └───────────┬──────────────────────────────────────────────┘    │
│              │                                                   │
│              ▼                                                   │
│  ┌──────────────────────────────────────────────────────────┐    │
│  │ OnSearchQueryChanged("he")                                 │    │
│  │  1. Cancel previous CTS                                    │    │
│  │  2. Create new CTS                                         │    │
│  │  3. Start SearchWithDebounceAsync("he", cts.Token)         │    │
│  │     → Task.Delay(300ms)   ← "hel" arrives at 200ms         │    │
│  └───────────────────────────────────────────────────────────┘    │
│                                                                  │
│  ┌──────────────────────────────────────────────────────────┐    │
│  │ OnSearchQueryChanged("hel")                                │    │
│  │  1. Cancel previous CTS  ← Cancels "he" search             │    │
│  │  2. Create new CTS                                         │    │
│  │  3. Start SearchWithDebounceAsync("hel", cts.Token)        │    │
│  │     → Task.Delay(300ms)   ← "help" arrives at 200ms        │    │
│  └───────────────────────────────────────────────────────────┘    │
│                                                                  │
│  ┌──────────────────────────────────────────────────────────┐    │
│  │ OnSearchQueryChanged("help")                               │    │
│  │  1. Cancel previous CTS  ← Cancels "hel" search            │    │
│  │  2. Create new CTS                                         │    │
│  │  3. Start SearchWithDebounceAsync("help", cts.Token)       │    │
│  │     → Task.Delay(300ms)   ← No more input                  │    │
│  │     → 300ms elapses...                                     │    │
│  │     → Execute search!                                      │    │
│  └───────────┬──────────────────────────────────────────────┘    │
│              │                                                   │
│              ▼                                                   │
│  ┌──────────────────────────────────────────────────────────┐    │
│  │ SearchWithDebounceAsync (after 300ms delay)                │    │
│  │  1. Set IsSearching = true                                 │    │
│  │  2. Call service.SearchConversationsAsync("help")          │    │
│  │  3. Dispatch to UI thread                                  │    │
│  │  4. Call UpdateGroups(results)                             │    │
│  └──────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## Prerequisites

Before implementing v0.2.2b, ensure:
- v0.2.1 is complete (Database foundation fully implemented)
- v0.2.2a is complete (DatabaseConversationService, event args)
- Solution builds successfully
- CommunityToolkit.Mvvm is installed

---

## Directory Structure

After v0.2.2b implementation:

```
src/SeniorIntern.Desktop/
├── SeniorIntern.Desktop.csproj
├── IDispatcher.cs                                    (NEW)
├── AvaloniaDispatcher.cs                             (NEW)
├── ViewModels/
│   ├── ViewModelBase.cs                              (existing)
│   ├── MainWindowViewModel.cs                        (existing)
│   ├── ChatViewModel.cs                              (existing)
│   ├── ConversationListViewModel.cs                  (NEW)
│   ├── ConversationGroupViewModel.cs                 (NEW)
│   └── ConversationSummaryViewModel.cs               (NEW)
└── Extensions/
    └── ServiceCollectionExtensions.cs                (UPDATED - register VMs)
```

---

## Implementation Details

### Task 1: Create IDispatcher Interface

**File:** `src/SeniorIntern.Desktop/IDispatcher.cs`

Abstraction for UI thread dispatching to enable unit testing.

```csharp
namespace SeniorIntern.Desktop;

/// <summary>
/// Abstraction for UI thread dispatching.
/// Enables unit testing of ViewModels without Avalonia runtime.
/// </summary>
public interface IDispatcher
{
    /// <summary>
    /// Invokes an action on the UI thread.
    /// </summary>
    /// <param name="action">The action to invoke.</param>
    Task InvokeAsync(Action action);

    /// <summary>
    /// Invokes a function on the UI thread and returns the result.
    /// </summary>
    /// <typeparam name="T">The return type.</typeparam>
    /// <param name="func">The function to invoke.</param>
    /// <returns>The result of the function.</returns>
    Task<T> InvokeAsync<T>(Func<T> func);

    /// <summary>
    /// Invokes an async action on the UI thread.
    /// </summary>
    /// <param name="action">The async action to invoke.</param>
    Task InvokeAsync(Func<Task> action);
}
```

---

### Task 2: Create AvaloniaDispatcher Implementation

**File:** `src/SeniorIntern.Desktop/AvaloniaDispatcher.cs`

Production implementation that wraps Avalonia's Dispatcher.

```csharp
namespace SeniorIntern.Desktop;

using Avalonia.Threading;

/// <summary>
/// Avalonia implementation of IDispatcher.
/// Uses Avalonia.Threading.Dispatcher.UIThread.
/// </summary>
public sealed class AvaloniaDispatcher : IDispatcher
{
    /// <inheritdoc />
    public async Task InvokeAsync(Action action)
    {
        await Dispatcher.UIThread.InvokeAsync(action);
    }

    /// <inheritdoc />
    public async Task<T> InvokeAsync<T>(Func<T> func)
    {
        return await Dispatcher.UIThread.InvokeAsync(func);
    }

    /// <inheritdoc />
    public async Task InvokeAsync(Func<Task> action)
    {
        await Dispatcher.UIThread.InvokeAsync(action);
    }
}
```

---

### Task 3: Create ConversationSummaryViewModel

**File:** `src/SeniorIntern.Desktop/ViewModels/ConversationSummaryViewModel.cs`

ViewModel for a single conversation item in the list.

```csharp
namespace SeniorIntern.Desktop.ViewModels;

using CommunityToolkit.Mvvm.ComponentModel;

/// <summary>
/// ViewModel for a single conversation item in the sidebar list.
/// </summary>
public partial class ConversationSummaryViewModel : ViewModelBase
{
    #region Identity

    /// <summary>Gets the unique identifier.</summary>
    public Guid Id { get; init; }

    #endregion

    #region Display Properties

    /// <summary>Gets or sets the conversation title.</summary>
    [ObservableProperty]
    private string _title = string.Empty;

    /// <summary>Gets or sets when the conversation was last updated.</summary>
    [ObservableProperty]
    private DateTime _updatedAt;

    /// <summary>Gets or sets the total message count.</summary>
    [ObservableProperty]
    private int _messageCount;

    /// <summary>Gets or sets the preview text (first user message).</summary>
    [ObservableProperty]
    private string? _preview;

    /// <summary>Gets or sets the model name used.</summary>
    [ObservableProperty]
    private string? _modelName;

    #endregion

    #region State Properties

    /// <summary>Gets or sets whether this conversation is selected.</summary>
    [ObservableProperty]
    private bool _isSelected;

    /// <summary>Gets or sets whether this conversation is pinned.</summary>
    [ObservableProperty]
    private bool _isPinned;

    #endregion

    #region Rename State

    /// <summary>Gets or sets whether the user is currently renaming this conversation.</summary>
    [ObservableProperty]
    private bool _isRenaming;

    /// <summary>Gets or sets the title being edited during rename.</summary>
    [ObservableProperty]
    private string _editingTitle = string.Empty;

    #endregion

    #region Computed Properties

    /// <summary>
    /// Gets a human-readable relative time string.
    /// </summary>
    /// <example>"Just now", "5m ago", "2h ago", "3d ago", "Jan 15"</example>
    public string RelativeTime => GetRelativeTime(UpdatedAt);

    /// <summary>
    /// Gets a human-readable message count string.
    /// </summary>
    /// <example>"No messages", "1 message", "12 messages"</example>
    public string MessageCountText => MessageCount switch
    {
        0 => "No messages",
        1 => "1 message",
        _ => $"{MessageCount} messages"
    };

    #endregion

    #region Helpers

    private static string GetRelativeTime(DateTime dateTime)
    {
        var now = DateTime.UtcNow;
        var diff = now - dateTime;

        if (diff.TotalMinutes < 1)
            return "Just now";
        if (diff.TotalMinutes < 60)
            return $"{(int)diff.TotalMinutes}m ago";
        if (diff.TotalHours < 24)
            return $"{(int)diff.TotalHours}h ago";
        if (diff.TotalDays < 7)
            return $"{(int)diff.TotalDays}d ago";
        if (diff.TotalDays < 30)
            return $"{(int)(diff.TotalDays / 7)}w ago";

        return dateTime.ToString("MMM d");
    }

    #endregion
}
```

---

### Task 4: Create ConversationGroupViewModel

**File:** `src/SeniorIntern.Desktop/ViewModels/ConversationGroupViewModel.cs`

ViewModel for a date-based group of conversations.

```csharp
namespace SeniorIntern.Desktop.ViewModels;

using CommunityToolkit.Mvvm.ComponentModel;
using SeniorIntern.Core.Enums;
using System.Collections.ObjectModel;

/// <summary>
/// ViewModel for a group of conversations organized by date.
/// </summary>
public partial class ConversationGroupViewModel : ViewModelBase
{
    /// <summary>Gets the date group category.</summary>
    public DateGroup DateGroup { get; init; }

    /// <summary>Gets or sets the display title for this group.</summary>
    [ObservableProperty]
    private string _title = string.Empty;

    /// <summary>Gets or sets whether the group is expanded (vs collapsed).</summary>
    [ObservableProperty]
    private bool _isExpanded = true;

    /// <summary>Gets the collection of conversations in this group.</summary>
    public ObservableCollection<ConversationSummaryViewModel> Conversations { get; } = new();

    /// <summary>Gets the number of conversations in this group.</summary>
    public int Count => Conversations.Count;
}
```

---

### Task 5: Create ConversationListViewModel

**File:** `src/SeniorIntern.Desktop/ViewModels/ConversationListViewModel.cs`

Main ViewModel for the conversation list sidebar.

```csharp
namespace SeniorIntern.Desktop.ViewModels;

using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using SeniorIntern.Core.Enums;
using SeniorIntern.Core.Events;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using System.Collections.ObjectModel;

/// <summary>
/// ViewModel for the conversation list in the sidebar.
/// Handles loading, searching, grouping, and CRUD operations.
/// </summary>
public partial class ConversationListViewModel : ViewModelBase, IDisposable
{
    private readonly IConversationService _conversationService;
    private readonly IDispatcher _dispatcher;
    private CancellationTokenSource? _searchCts;
    private bool _isDisposed;

    private const int SearchDebounceMs = 300;

    #region Observable Properties

    /// <summary>Gets or sets the conversation groups (organized by date).</summary>
    [ObservableProperty]
    private ObservableCollection<ConversationGroupViewModel> _groups = new();

    /// <summary>Gets or sets the currently selected conversation.</summary>
    [ObservableProperty]
    private ConversationSummaryViewModel? _selectedConversation;

    /// <summary>Gets or sets the search query text.</summary>
    [ObservableProperty]
    private string _searchQuery = string.Empty;

    /// <summary>Gets or sets whether conversations are being loaded.</summary>
    [ObservableProperty]
    private bool _isLoading;

    /// <summary>Gets or sets whether the conversation list is empty.</summary>
    [ObservableProperty]
    private bool _isEmpty;

    /// <summary>Gets or sets whether a search is active.</summary>
    [ObservableProperty]
    private bool _isSearching;

    /// <summary>Gets or sets any error message to display.</summary>
    [ObservableProperty]
    private string? _errorMessage;

    #endregion

    #region Constructor

    /// <summary>
    /// Creates a new ConversationListViewModel.
    /// </summary>
    /// <param name="conversationService">The conversation service.</param>
    /// <param name="dispatcher">The UI thread dispatcher.</param>
    public ConversationListViewModel(
        IConversationService conversationService,
        IDispatcher dispatcher)
    {
        _conversationService = conversationService ?? throw new ArgumentNullException(nameof(conversationService));
        _dispatcher = dispatcher ?? throw new ArgumentNullException(nameof(dispatcher));

        // Subscribe to service events
        _conversationService.ConversationListChanged += OnConversationListChanged;
        _conversationService.ConversationChanged += OnConversationChanged;
    }

    #endregion

    #region Initialization

    /// <summary>
    /// Initializes the ViewModel and loads conversations.
    /// </summary>
    public async Task InitializeAsync()
    {
        await LoadConversationsAsync();
    }

    #endregion

    #region Commands

    /// <summary>Loads conversations from the database.</summary>
    [RelayCommand]
    private async Task LoadConversationsAsync()
    {
        try
        {
            IsLoading = true;
            ErrorMessage = null;

            var conversations = await _conversationService.GetRecentConversationsAsync();
            await _dispatcher.InvokeAsync(() =>
            {
                UpdateGroups(conversations);
                UpdateSelection();
            });
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Failed to load conversations: {ex.Message}";
        }
        finally
        {
            IsLoading = false;
        }
    }

    /// <summary>Creates a new conversation.</summary>
    [RelayCommand]
    private async Task CreateNewConversationAsync()
    {
        try
        {
            await _conversationService.CreateNewConversationAsync();
            // Selection will be updated via event
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Failed to create conversation: {ex.Message}";
        }
    }

    /// <summary>Selects and loads a conversation.</summary>
    [RelayCommand]
    private async Task SelectConversationAsync(ConversationSummaryViewModel? summary)
    {
        if (summary == null || summary.Id == _conversationService.CurrentConversation.Id)
            return;

        try
        {
            IsLoading = true;
            await _conversationService.LoadConversationAsync(summary.Id);
            SelectedConversation = summary;
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Failed to load conversation: {ex.Message}";
        }
        finally
        {
            IsLoading = false;
        }
    }

    /// <summary>Deletes a conversation.</summary>
    [RelayCommand]
    private async Task DeleteConversationAsync(ConversationSummaryViewModel summary)
    {
        try
        {
            await _conversationService.DeleteConversationAsync(summary.Id);
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Failed to delete conversation: {ex.Message}";
        }
    }

    /// <summary>Begins renaming a conversation.</summary>
    [RelayCommand]
    private void RenameConversation(ConversationSummaryViewModel summary)
    {
        summary.IsRenaming = true;
        summary.EditingTitle = summary.Title;
    }

    /// <summary>Confirms the rename operation.</summary>
    [RelayCommand]
    private async Task ConfirmRenameAsync(ConversationSummaryViewModel summary)
    {
        if (summary.EditingTitle == summary.Title)
        {
            summary.IsRenaming = false;
            return;
        }

        try
        {
            await _conversationService.RenameConversationAsync(summary.Id, summary.EditingTitle);
            summary.Title = summary.EditingTitle;
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Failed to rename conversation: {ex.Message}";
        }
        finally
        {
            summary.IsRenaming = false;
        }
    }

    /// <summary>Cancels the rename operation.</summary>
    [RelayCommand]
    private void CancelRename(ConversationSummaryViewModel summary)
    {
        summary.IsRenaming = false;
        summary.EditingTitle = summary.Title;
    }

    /// <summary>Archives a conversation.</summary>
    [RelayCommand]
    private async Task ArchiveConversationAsync(ConversationSummaryViewModel summary)
    {
        try
        {
            await _conversationService.ArchiveConversationAsync(summary.Id);
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Failed to archive conversation: {ex.Message}";
        }
    }

    /// <summary>Toggles the pin status of a conversation.</summary>
    [RelayCommand]
    private async Task TogglePinAsync(ConversationSummaryViewModel summary)
    {
        try
        {
            if (summary.IsPinned)
            {
                await _conversationService.UnpinConversationAsync(summary.Id);
                summary.IsPinned = false;
            }
            else
            {
                await _conversationService.PinConversationAsync(summary.Id);
                summary.IsPinned = true;
            }
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Failed to update pin status: {ex.Message}";
        }
    }

    /// <summary>Clears the search query.</summary>
    [RelayCommand]
    private void ClearSearch()
    {
        SearchQuery = string.Empty;
    }

    #endregion

    #region Search

    /// <summary>
    /// Called when SearchQuery changes. Implements debounced search.
    /// </summary>
    partial void OnSearchQueryChanged(string value)
    {
        // Cancel previous search
        _searchCts?.Cancel();
        _searchCts = new CancellationTokenSource();

        // Debounce 300ms
        _ = SearchWithDebounceAsync(value, _searchCts.Token);
    }

    private async Task SearchWithDebounceAsync(string query, CancellationToken ct)
    {
        try
        {
            await Task.Delay(SearchDebounceMs, ct);

            if (ct.IsCancellationRequested)
                return;

            IsSearching = !string.IsNullOrWhiteSpace(query);

            var conversations = await _conversationService.SearchConversationsAsync(query, ct);

            if (ct.IsCancellationRequested)
                return;

            await _dispatcher.InvokeAsync(() => UpdateGroups(conversations));
        }
        catch (OperationCanceledException)
        {
            // Expected when cancelled - ignore
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Search failed: {ex.Message}";
        }
    }

    #endregion

    #region Helper Methods

    private void UpdateGroups(IReadOnlyList<ConversationSummary> conversations)
    {
        Groups.Clear();

        if (!conversations.Any())
        {
            IsEmpty = true;
            return;
        }

        IsEmpty = false;

        // Group by date
        var grouped = conversations
            .GroupBy(c => c.GetDateGroup())
            .OrderBy(g => g.Key);

        foreach (var group in grouped)
        {
            var groupVm = new ConversationGroupViewModel
            {
                DateGroup = group.Key,
                Title = GetGroupTitle(group.Key),
                IsExpanded = true
            };

            // Within group: pinned first, then by UpdatedAt descending
            foreach (var conv in group
                .OrderByDescending(c => c.IsPinned)
                .ThenByDescending(c => c.UpdatedAt))
            {
                groupVm.Conversations.Add(new ConversationSummaryViewModel
                {
                    Id = conv.Id,
                    Title = conv.Title,
                    UpdatedAt = conv.UpdatedAt,
                    MessageCount = conv.MessageCount,
                    Preview = conv.Preview,
                    IsPinned = conv.IsPinned,
                    ModelName = conv.ModelName
                });
            }

            Groups.Add(groupVm);
        }
    }

    private void UpdateSelection()
    {
        var currentId = _conversationService.CurrentConversation.Id;

        foreach (var group in Groups)
        {
            foreach (var conv in group.Conversations)
            {
                conv.IsSelected = conv.Id == currentId;
                if (conv.IsSelected)
                {
                    SelectedConversation = conv;
                }
            }
        }
    }

    private static string GetGroupTitle(DateGroup group) => group switch
    {
        DateGroup.Today => "Today",
        DateGroup.Yesterday => "Yesterday",
        DateGroup.Previous7Days => "Previous 7 Days",
        DateGroup.Previous30Days => "Previous 30 Days",
        DateGroup.Older => "Older",
        _ => "Other"
    };

    #endregion

    #region Event Handlers

    private async void OnConversationListChanged(object? sender, ConversationListChangedEventArgs e)
    {
        await _dispatcher.InvokeAsync(async () =>
        {
            await LoadConversationsAsync();
        });
    }

    private void OnConversationChanged(object? sender, ConversationChangedEventArgs e)
    {
        _dispatcher.InvokeAsync(() =>
        {
            // Update selection when conversation changes
            if (e.ChangeType == ConversationChangeType.Loaded ||
                e.ChangeType == ConversationChangeType.Created)
            {
                UpdateSelection();
            }
        });
    }

    #endregion

    #region IDisposable

    /// <summary>
    /// Disposes of the ViewModel, unsubscribing from events.
    /// </summary>
    public void Dispose()
    {
        if (_isDisposed) return;
        _isDisposed = true;

        _conversationService.ConversationListChanged -= OnConversationListChanged;
        _conversationService.ConversationChanged -= OnConversationChanged;
        _searchCts?.Cancel();
        _searchCts?.Dispose();
    }

    #endregion
}
```

---

### Task 6: Register ViewModels in DI

**File:** `src/SeniorIntern.Desktop/Extensions/ServiceCollectionExtensions.cs`

Add the following registrations:

```csharp
// Dispatcher
services.AddSingleton<IDispatcher, AvaloniaDispatcher>();

// ViewModels
services.AddTransient<ConversationListViewModel>();
services.AddTransient<ConversationGroupViewModel>();
services.AddTransient<ConversationSummaryViewModel>();
```

---

## Logging Specifications

### Log Levels by Operation

| Level | Operations |
|-------|------------|
| Debug | Load, Search, Select, Command invocations |
| Information | User actions (create, delete, archive, pin) |
| Warning | Failed operations that are recoverable |
| Error | Unrecoverable failures |

### Note on ViewModel Logging

ViewModels typically set `ErrorMessage` for user-visible errors rather than logging directly. The underlying service layer handles detailed logging.

---

## Unit Testing Requirements

### Test Summary

| Component | Test Count | Focus Areas |
|-----------|------------|-------------|
| ConversationSummaryViewModel | 6 | RelativeTime, MessageCountText, state changes |
| ConversationGroupViewModel | 3 | Conversations collection, Count, expand state |
| ConversationListViewModel | 18 | Commands, search debounce, grouping, events |
| **Total** | **27** | |

### Key Test Scenarios

```csharp
// ConversationSummaryViewModel Tests
[Theory]
[InlineData(0, "Just now")]
[InlineData(5, "5m ago")]
[InlineData(90, "1h ago")]
[InlineData(1440, "1d ago")]
public void RelativeTime_ReturnsCorrectFormat(int minutesAgo, string expected)
{
    var vm = new ConversationSummaryViewModel
    {
        UpdatedAt = DateTime.UtcNow.AddMinutes(-minutesAgo)
    };
    
    Assert.Equal(expected, vm.RelativeTime);
}

[Theory]
[InlineData(0, "No messages")]
[InlineData(1, "1 message")]
[InlineData(5, "5 messages")]
public void MessageCountText_ReturnsCorrectFormat(int count, string expected)
{
    var vm = new ConversationSummaryViewModel { MessageCount = count };
    Assert.Equal(expected, vm.MessageCountText);
}

// ConversationListViewModel Tests
[Fact]
public async Task LoadConversationsAsync_GroupsByDateCorrectly()
{
    var mockService = new Mock<IConversationService>();
    mockService.Setup(s => s.GetRecentConversationsAsync(It.IsAny<int>(), It.IsAny<bool>(), It.IsAny<CancellationToken>()))
        .ReturnsAsync(new List<ConversationSummary>
        {
            new() { Id = Guid.NewGuid(), Title = "Today", UpdatedAt = DateTime.UtcNow },
            new() { Id = Guid.NewGuid(), Title = "Yesterday", UpdatedAt = DateTime.UtcNow.AddDays(-1) },
            new() { Id = Guid.NewGuid(), Title = "Last week", UpdatedAt = DateTime.UtcNow.AddDays(-5) }
        });
    
    var vm = CreateViewModel(mockService.Object);
    await vm.InitializeAsync();
    
    Assert.Equal(3, vm.Groups.Count);
    Assert.Equal("Today", vm.Groups[0].Title);
    Assert.Equal("Yesterday", vm.Groups[1].Title);
    Assert.Equal("Previous 7 Days", vm.Groups[2].Title);
}

[Fact]
public async Task SearchQuery_Change_DebouncesProperly()
{
    var mockService = new Mock<IConversationService>();
    var searchCalls = 0;
    mockService.Setup(s => s.SearchConversationsAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
        .Callback(() => searchCalls++)
        .ReturnsAsync(Array.Empty<ConversationSummary>());
    
    var vm = CreateViewModel(mockService.Object);
    
    // Type rapidly
    vm.SearchQuery = "h";
    vm.SearchQuery = "he";
    vm.SearchQuery = "hel";
    vm.SearchQuery = "help";
    
    // Wait for debounce
    await Task.Delay(400);
    
    // Should only call search once (for "help")
    Assert.Equal(1, searchCalls);
}

[Fact]
public async Task SelectConversationAsync_UpdatesSelectedConversation()
{
    var conversationId = Guid.NewGuid();
    var mockService = new Mock<IConversationService>();
    mockService.Setup(s => s.CurrentConversation)
        .Returns(new Conversation { Id = Guid.NewGuid() }); // Different ID
    
    var vm = CreateViewModel(mockService.Object);
    var summary = new ConversationSummaryViewModel { Id = conversationId };
    
    await vm.SelectConversationCommand.ExecuteAsync(summary);
    
    mockService.Verify(s => s.LoadConversationAsync(conversationId, It.IsAny<CancellationToken>()), Times.Once);
    Assert.Equal(summary, vm.SelectedConversation);
}

[Fact]
public async Task TogglePinAsync_TogglesPinState()
{
    var mockService = new Mock<IConversationService>();
    var vm = CreateViewModel(mockService.Object);
    var summary = new ConversationSummaryViewModel { Id = Guid.NewGuid(), IsPinned = false };
    
    await vm.TogglePinCommand.ExecuteAsync(summary);
    
    mockService.Verify(s => s.PinConversationAsync(summary.Id, It.IsAny<CancellationToken>()), Times.Once);
    Assert.True(summary.IsPinned);
    
    await vm.TogglePinCommand.ExecuteAsync(summary);
    
    mockService.Verify(s => s.UnpinConversationAsync(summary.Id, It.IsAny<CancellationToken>()), Times.Once);
    Assert.False(summary.IsPinned);
}

[Fact]
public void Dispose_UnsubscribesFromEvents()
{
    var mockService = new Mock<IConversationService>();
    var vm = CreateViewModel(mockService.Object);
    
    vm.Dispose();
    
    // Verify event handlers were removed
    mockService.VerifyRemove(s => s.ConversationListChanged -= It.IsAny<EventHandler<ConversationListChangedEventArgs>>());
    mockService.VerifyRemove(s => s.ConversationChanged -= It.IsAny<EventHandler<ConversationChangedEventArgs>>());
}
```

---

## Use Cases

### UC-001: Load Conversation List on Startup

| Attribute | Value |
|-----------|-------|
| **Actor** | MainWindowViewModel |
| **Trigger** | Application startup |
| **Success Scenario** | Conversations loaded and grouped by date |
| **Postcondition** | Sidebar displays grouped conversation list |

#### Flow
1. MainWindow initializes ConversationListViewModel
2. `InitializeAsync()` is called
3. Service returns recent conversations
4. ViewModel groups by DateGroup
5. Groups ObservableCollection is populated
6. UI binds and displays grouped list

---

### UC-002: Search Conversations

| Attribute | Value |
|-----------|-------|
| **Actor** | User |
| **Trigger** | User types in search box |
| **Success Scenario** | Results filtered after 300ms debounce |
| **Postcondition** | List shows only matching conversations |

---

### UC-003: Inline Rename Conversation

| Attribute | Value |
|-----------|-------|
| **Actor** | User |
| **Trigger** | User selects "Rename" from context menu |
| **Success Scenario** | Title becomes editable, Enter saves |
| **Postcondition** | Conversation title updated in DB and UI |

#### Flow
1. User right-clicks conversation → selects "Rename"
2. `RenameConversationCommand` sets `IsRenaming = true`
3. UI shows TextBox instead of TextBlock
4. User types new title, presses Enter
5. `ConfirmRenameCommand` calls service.RenameAsync
6. Title property updated, `IsRenaming = false`

---

### UC-004: Toggle Pin Status

| Attribute | Value |
|-----------|-------|
| **Actor** | User |
| **Trigger** | User clicks pin icon or context menu |
| **Success Scenario** | Pin status toggled, list reordered |
| **Postcondition** | Pinned conversations appear at top of group |

---

## Deliverable Checklist

### Presentation Layer (SeniorIntern.Desktop)
- [ ] IDispatcher.cs
- [ ] AvaloniaDispatcher.cs
- [ ] ViewModels/ConversationListViewModel.cs
- [ ] ViewModels/ConversationGroupViewModel.cs
- [ ] ViewModels/ConversationSummaryViewModel.cs
- [ ] Extensions/ServiceCollectionExtensions.cs (UPDATED)

### Tests
- [ ] SeniorIntern.Desktop.Tests - ViewModel unit tests

---

## Files Summary

### Files to Create (5)

| File | Purpose | Lines (approx) |
|------|---------|----------------|
| `IDispatcher.cs` | UI thread abstraction interface | 25 |
| `AvaloniaDispatcher.cs` | Avalonia implementation | 25 |
| `ViewModels/ConversationSummaryViewModel.cs` | Item ViewModel | 80 |
| `ViewModels/ConversationGroupViewModel.cs` | Group ViewModel | 30 |
| `ViewModels/ConversationListViewModel.cs` | Main list ViewModel | 300 |

### Files to Modify (1)

| File | Changes |
|------|---------|
| `Extensions/ServiceCollectionExtensions.cs` | Register IDispatcher and ViewModels |

---

## Verification Steps

### Step 1: Verify Compilation

```bash
dotnet build src/SeniorIntern.Desktop
```

### Step 2: Run Unit Tests

```bash
dotnet test tests/SeniorIntern.Desktop.Tests
```

### Step 3: Manual Verification

1. Inject ViewModel into a test view
2. Verify groups populate correctly
3. Verify search debouncing works
4. Verify selection updates work

---

## Acceptance Criteria

| ID | Criterion | Verification |
|----|-----------|--------------|
| AC-1 | ViewModels compile | `dotnet build` succeeds |
| AC-2 | Groups populated correctly | Today/Yesterday/etc. groups created |
| AC-3 | Search debounces at 300ms | Rapid typing results in single search |
| AC-4 | Selection updates on load | Selected item matches current conversation |
| AC-5 | RelativeTime formats correctly | "5m ago", "2h ago", etc. display |
| AC-6 | MessageCountText formats correctly | "No messages", "1 message", etc. |
| AC-7 | Commands execute successfully | All 10 commands work |
| AC-8 | Events handled on UI thread | No cross-thread exceptions |
| AC-9 | ViewModel disposes properly | Events unsubscribed, CTS disposed |
| AC-10 | IDispatcher is mockable | Unit tests can run without Avalonia |

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Cross-thread access | Medium | High | IDispatcher abstraction enforces UI thread |
| Memory leak from events | Low | Medium | IDisposable pattern with event unsubscribe |
| Search spamming service | Low | Low | Debounce with CancellationToken |
| RelativeTime becomes stale | Low | Low | Optional: add refresh timer |

---

## Design Decisions

### Decision 1: IDispatcher Abstraction

**Decision:** Create `IDispatcher` interface instead of using Avalonia directly.
**Rationale:** Enables unit testing ViewModels without Avalonia runtime.

### Decision 2: 300ms Search Debounce

**Decision:** Use 300ms debounce for search queries.
**Rationale:** Balances responsiveness with reducing unnecessary API calls.

### Decision 3: Observable Properties via CommunityToolkit

**Decision:** Use `[ObservableProperty]` source generators.
**Rationale:** Reduces boilerplate, ensures consistent INotifyPropertyChanged.

### Decision 4: Commands as RelayCommands

**Decision:** Use `[RelayCommand]` for all user actions.
**Rationale:** Auto-generates ICommand implementations with async support.

### Decision 5: Inline Renaming State

**Decision:** Store `IsRenaming` and `EditingTitle` on `ConversationSummaryViewModel`.
**Rationale:** Keeps rename state local to the item being edited.

---

## Future Considerations

| Item | Target Version | Rationale |
|------|----------------|-----------|
| Drag-and-drop reordering | v0.3.0+ | Complex interaction |
| Keyboard navigation | v0.2.2c | Part of UI implementation |
| Virtualization for large lists | v0.3.0+ | Performance optimization |
| RelativeTime auto-refresh | v0.3.0+ | Minor enhancement |

---

## Timeline Estimate

| Version | Estimated Effort | Key Deliverables |
|---------|------------------|------------------|
| v0.2.2b | 1 day | 5 ViewModel files, DI registration |

---

## References

- [CommunityToolkit.Mvvm](https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/)
- [Avalonia Threading](https://docs.avaloniaui.net/docs/guides/basics/threading)
- [Observable Collections in Avalonia](https://docs.avaloniaui.net/docs/basics/data/data-binding/creating-and-binding-to-data-models)
- [Debouncing Pattern](https://css-tricks.com/debouncing-throttling-explained-examples/)
