# Design Specification: AIntern v0.2.2d "Chat Integration"

## Executive Summary

This document provides a detailed implementation specification for v0.2.2d, which connects the ChatViewModel to the conversation service, handles conversation switching, and integrates all components into the MainWindow. This version completes the end-to-end flow where users can send messages, have them persisted, switch between conversations, and see their chat history restored.

v0.2.2d is the integration layer that brings together the service (v0.2.2a), ViewModels (v0.2.2b), and UI (v0.2.2c) into a cohesive user experience.

### v0.2.2d Scope (from v0.2.2 Design Document)

- Update `ChatViewModel` to integrate with `IConversationService`
- Subscribe to `ConversationChanged` and `SaveStateChanged` events
- Implement message sending that persists through the service
- Implement streaming response generation with real-time updates
- Update `MainWindowViewModel` to compose child ViewModels
- Update `MainWindow.axaml` to include SplitView sidebar layout
- Update DI registration for all components

### Key Deliverables

| Deliverable | Description |
|-------------|-------------|
| ChatViewModel Updates | Integration with IConversationService, event handling, message persistence |
| ChatMessageViewModel | ViewModel wrapper for ChatMessage display |
| MainWindowViewModel Updates | Composition of child ViewModels, initialization |
| MainWindow.axaml Updates | SplitView layout with sidebar and chat area |
| DI Registration Updates | Complete service and ViewModel wiring |

---

## Feature Overview

```
┌──────────────────────────────────────────────────────────────────┐
│                     v0.2.2d Feature Tree                          │
├──────────────────────────────────────────────────────────────────┤
│                                                                   │
│  Chat Integration                                                 │
│  ├── ChatViewModel Updates                                        │
│  │   ├── Dependencies                                             │
│  │   │   ├── IConversationService (injected)                      │
│  │   │   ├── ILlmService (existing)                               │
│  │   │   └── IDispatcher (for UI thread)                          │
│  │   │                                                            │
│  │   ├── Properties                                               │
│  │   │   ├── Messages (ObservableCollection<MessageVM>)           │
│  │   │   ├── InputText                                            │
│  │   │   ├── IsGenerating                                         │
│  │   │   ├── CanSend                                              │
│  │   │   ├── ConversationTitle                                    │
│  │   │   ├── HasUnsavedChanges                                    │
│  │   │   └── SaveStatus ("Saving...", "Saved", null)              │
│  │   │                                                            │
│  │   ├── Event Handlers                                           │
│  │   │   ├── OnConversationChanged → RefreshFromConversation      │
│  │   │   └── OnSaveStateChanged → Update SaveStatus               │
│  │   │                                                            │
│  │   ├── Commands                                                 │
│  │   │   ├── SendMessageCommand → Add user + generate response    │
│  │   │   ├── CancelGenerationCommand → Stop streaming             │
│  │   │   └── ClearConversationCommand → Clear messages            │
│  │   │                                                            │
│  │   └── Methods                                                  │
│  │       ├── RefreshFromConversation() → Sync UI with service     │
│  │       └── GenerateResponseAsync() → Stream LLM response        │
│  │                                                                │
│  ├── ChatMessageViewModel                                         │
│  │   ├── Wraps ChatMessage domain model                           │
│  │   ├── Observable Content property                              │
│  │   └── Observable IsComplete, IsGenerating properties           │
│  │                                                                │
│  ├── MainWindowViewModel Updates                                  │
│  │   ├── Child ViewModels (injected)                              │
│  │   │   ├── ChatViewModel                                        │
│  │   │   ├── ConversationListViewModel                            │
│  │   │   └── ModelSelectorViewModel                               │
│  │   │                                                            │
│  │   ├── Properties                                               │
│  │   │   ├── IsSidebarVisible                                     │
│  │   │   └── StatusText                                           │
│  │   │                                                            │
│  │   ├── Commands                                                 │
│  │   │   └── ToggleSidebarCommand                                 │
│  │   │                                                            │
│  │   └── InitializeAsync() → Load conversation list               │
│  │                                                                │
│  └── MainWindow.axaml Updates                                     │
│      ├── SplitView for sidebar/content layout                     │
│      ├── Pane: Model selector + Conversation list                 │
│      └── Content: Chat view                                       │
│                                                                   │
└──────────────────────────────────────────────────────────────────┘
```

---

## Architecture Diagrams

### Component Integration Overview

```
┌─────────────────────────────────────────────────────────────────┐
│                        MainWindow                                │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │                  MainWindowViewModel                       │  │
│  │                                                            │  │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐     │  │
│  │  │ModelSelector │  │Conversation  │  │  Chat        │     │  │
│  │  │ViewModel     │  │ListViewModel │  │  ViewModel   │     │  │
│  │  └──────────────┘  └──────────────┘  └──────┬───────┘     │  │
│  │                                              │              │  │
│  │                   All subscribe to ──────────┤              │  │
│  │                                              ▼              │  │
│  │  ┌──────────────────────────────────────────────────────┐  │  │
│  │  │              IConversationService                     │  │  │
│  │  │  ┌─────────────────┐  ┌─────────────────────────┐    │  │  │
│  │  │  │ CurrentConvers. │  │ Events:                  │    │  │  │
│  │  │  │ (in-memory)     │  │ - ConversationChanged   │    │  │  │
│  │  │  └─────────────────┘  │ - SaveStateChanged      │    │  │  │
│  │  │                       │ - ListChanged           │    │  │  │
│  │  │                       └─────────────────────────┘    │  │  │
│  │  └──────────────────────────────────────────────────────┘  │  │
│  └───────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
```

### Message Send Flow

```
┌─────────────────────────────────────────────────────────────────┐
│                    Message Send Flow                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  User types message + presses Enter                              │
│              │                                                   │
│              ▼                                                   │
│  ┌──────────────────────────────────────────────────────────┐    │
│  │ ChatViewModel.SendMessageAsync()                          │    │
│  │  1. Validate InputText not empty                          │    │
│  │  2. Create ChatMessage (User role)                        │    │
│  │  3. Call service.AddMessage(userMessage)   ─────────────┐ │    │
│  │  4. Add to Messages collection (UI)                     │ │    │
│  │  5. Clear InputText                                     │ │    │
│  │  6. Call GenerateResponseAsync()                        │ │    │
│  └───────────┬─────────────────────────────────────────────┘ │    │
│              │                                               │    │
│              │                                               │    │
│              ▼                               ┌───────────────┘    │
│  ┌──────────────────────────────────────────▼────────────────┐   │
│  │ IConversationService.AddMessage()                          │   │
│  │  - Adds to CurrentConversation.Messages                    │   │
│  │  - Sets HasUnsavedChanges = true                           │   │
│  │  - Schedules auto-save (500ms debounce)                    │   │
│  │  - Fires ConversationChanged(MessageAdded)                 │   │
│  └────────────────────────────────────────────────────────────┘   │
│              │                                                   │
│              ▼                                                   │
│  ┌──────────────────────────────────────────────────────────┐    │
│  │ GenerateResponseAsync()                                    │    │
│  │  1. Set IsGenerating = true                                │    │
│  │  2. Create empty ChatMessage (Assistant role)              │    │
│  │  3. Call service.AddMessage(assistantMessage)              │    │
│  │  4. Add ChatMessageViewModel to Messages                   │    │
│  │  5. Start streaming from ILlmService                       │    │
│  └───────────┬──────────────────────────────────────────────┘    │
│              │                                                   │
│              ▼                                                   │
│  ┌──────────────────────────────────────────────────────────┐    │
│  │ foreach (token in LlmService.GenerateStreamingAsync())     │    │
│  │  1. Append token to messageVm.Content                      │    │
│  │  2. Update via service.UpdateMessage()                     │    │
│  │     (triggers debounced auto-save)                         │    │
│  └───────────┬──────────────────────────────────────────────┘    │
│              │                                                   │
│              ▼                                                   │
│  ┌──────────────────────────────────────────────────────────┐    │
│  │ Streaming complete                                         │    │
│  │  1. Set IsComplete = true                                  │    │
│  │  2. Calculate TokenCount, TokensPerSecond                  │    │
│  │  3. Final service.UpdateMessage() with stats               │    │
│  │  4. Set IsGenerating = false                               │    │
│  └──────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Conversation Switch Flow

```
┌─────────────────────────────────────────────────────────────────┐
│                   Conversation Switch Flow                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  User clicks different conversation in sidebar                   │
│              │                                                   │
│              ▼                                                   │
│  ┌──────────────────────────────────────────────────────────┐    │
│  │ ConversationListViewModel.SelectConversationAsync()        │    │
│  │  → Calls service.LoadConversationAsync(id)                 │    │
│  └───────────┬──────────────────────────────────────────────┘    │
│              │                                                   │
│              ▼                                                   │
│  ┌──────────────────────────────────────────────────────────┐    │
│  │ IConversationService.LoadConversationAsync()               │    │
│  │  1. If HasUnsavedChanges → Save current                    │    │
│  │  2. Load target from repository                            │    │
│  │  3. Map entity → Conversation domain model                 │    │
│  │  4. Set as CurrentConversation                             │    │
│  │  5. Fire ConversationChanged(Loaded)                       │    │
│  └───────────┬──────────────────────────────────────────────┘    │
│              │                                                   │
│              ▼                                                   │
│  ┌──────────────────────────────────────────────────────────┐    │
│  │ ChatViewModel.OnConversationChanged()                      │    │
│  │  - Receives event via IDispatcher.InvokeAsync              │    │
│  │  - Detects ChangeType == Loaded                            │    │
│  │  - Calls RefreshFromConversation()                         │    │
│  └───────────┬──────────────────────────────────────────────┘    │
│              │                                                   │
│              ▼                                                   │
│  ┌──────────────────────────────────────────────────────────┐    │
│  │ ChatViewModel.RefreshFromConversation()                    │    │
│  │  1. Messages.Clear()                                       │    │
│  │  2. ConversationTitle = conversation.Title                 │    │
│  │  3. foreach message: Messages.Add(new MessageVM(msg))      │    │
│  │  4. HasUnsavedChanges = conversation.HasUnsavedChanges     │    │
│  └──────────────────────────────────────────────────────────┘    │
│              │                                                   │
│              ▼                                                   │
│         UI updates via data binding                              │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## Prerequisites

Before implementing v0.2.2d, ensure:
- v0.2.1 is complete (Database foundation)
- v0.2.2a is complete (DatabaseConversationService)
- v0.2.2b is complete (ConversationListViewModel)
- v0.2.2c is complete (ConversationListView)
- Existing ChatViewModel and ChatView exist from prior work
- Solution builds successfully

---

## Directory Structure

After v0.2.2d implementation:

```
src/SeniorIntern.Desktop/
├── SeniorIntern.Desktop.csproj
├── ViewModels/
│   ├── ViewModelBase.cs                              (existing)
│   ├── MainWindowViewModel.cs                        (UPDATED)
│   ├── ChatViewModel.cs                              (UPDATED)
│   ├── ChatMessageViewModel.cs                       (NEW or UPDATED)
│   ├── ConversationListViewModel.cs                  (from v0.2.2b)
│   ├── ConversationGroupViewModel.cs                 (from v0.2.2b)
│   ├── ConversationSummaryViewModel.cs               (from v0.2.2b)
│   └── ModelSelectorViewModel.cs                     (existing)
├── Views/
│   ├── MainWindow.axaml                              (UPDATED)
│   ├── MainWindow.axaml.cs                           (UPDATED)
│   ├── ChatView.axaml                                (existing)
│   ├── ConversationListView.axaml                    (from v0.2.2c)
│   └── ModelSelectorView.axaml                       (existing)
└── Extensions/
    └── ServiceCollectionExtensions.cs                (UPDATED)
```

---

## Implementation Details

### Task 1: Create/Update ChatMessageViewModel

**File:** `src/SeniorIntern.Desktop/ViewModels/ChatMessageViewModel.cs`

ViewModel wrapper for ChatMessage with observable properties for real-time updates.

```csharp
namespace SeniorIntern.Desktop.ViewModels;

using CommunityToolkit.Mvvm.ComponentModel;
using SeniorIntern.Core.Entities;
using SeniorIntern.Core.Models;

/// <summary>
/// ViewModel for a single chat message.
/// Wraps ChatMessage with observable properties for streaming updates.
/// </summary>
public partial class ChatMessageViewModel : ViewModelBase
{
    private readonly ChatMessage _message;

    public ChatMessageViewModel(ChatMessage message)
    {
        _message = message ?? throw new ArgumentNullException(nameof(message));
        _content = message.Content;
        _isComplete = message.IsComplete;
    }

    #region Identity

    /// <summary>Gets the message ID.</summary>
    public Guid Id => _message.Id;

    /// <summary>Gets the message role.</summary>
    public MessageRole Role => _message.Role;

    /// <summary>Gets the timestamp.</summary>
    public DateTime Timestamp => _message.Timestamp;

    #endregion

    #region Observable Content

    /// <summary>Gets or sets the message content (updated during streaming).</summary>
    [ObservableProperty]
    private string _content;

    /// <summary>Gets or sets whether the message generation is complete.</summary>
    [ObservableProperty]
    private bool _isComplete;

    #endregion

    #region Statistics (read-only, from model)

    /// <summary>Gets the token count.</summary>
    public int? TokenCount => _message.TokenCount;

    /// <summary>Gets the generation time in milliseconds.</summary>
    public int? GenerationTimeMs => _message.GenerationTimeMs;

    /// <summary>Gets the tokens per second.</summary>
    public float? TokensPerSecond => _message.TokensPerSecond;

    #endregion

    #region Display Helpers

    /// <summary>Gets whether this is a user message.</summary>
    public bool IsUser => Role == MessageRole.User;

    /// <summary>Gets whether this is an assistant message.</summary>
    public bool IsAssistant => Role == MessageRole.Assistant;

    /// <summary>Gets whether this is a system message.</summary>
    public bool IsSystem => Role == MessageRole.System;

    /// <summary>Gets whether the message is currently generating (streaming).</summary>
    public bool IsGenerating => IsAssistant && !IsComplete;

    /// <summary>Gets a formatted timestamp for display.</summary>
    public string FormattedTime => Timestamp.ToLocalTime().ToString("h:mm tt");

    /// <summary>Gets performance stats if available.</summary>
    public string? PerformanceStats
    {
        get
        {
            if (TokensPerSecond.HasValue && TokenCount.HasValue)
            {
                return $"{TokenCount} tokens • {TokensPerSecond:F1} tok/s";
            }
            return null;
        }
    }

    #endregion
}
```

---

### Task 2: Update ChatViewModel

**File:** `src/SeniorIntern.Desktop/ViewModels/ChatViewModel.cs`

Full update with conversation service integration.

```csharp
namespace SeniorIntern.Desktop.ViewModels;

using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using SeniorIntern.Core.Entities;
using SeniorIntern.Core.Events;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using System.Collections.ObjectModel;

/// <summary>
/// ViewModel for the chat interface.
/// Integrates with IConversationService for persistence.
/// </summary>
public partial class ChatViewModel : ViewModelBase, IDisposable
{
    private readonly IConversationService _conversationService;
    private readonly ILlmService _llmService;
    private readonly IDispatcher _dispatcher;
    private CancellationTokenSource? _generationCts;
    private bool _isDisposed;

    #region Observable Properties

    /// <summary>Gets the collection of messages in the current conversation.</summary>
    [ObservableProperty]
    private ObservableCollection<ChatMessageViewModel> _messages = new();

    /// <summary>Gets or sets the user's input text.</summary>
    [ObservableProperty]
    private string _inputText = string.Empty;

    /// <summary>Gets or sets whether a response is being generated.</summary>
    [ObservableProperty]
    private bool _isGenerating;

    /// <summary>Gets whether the user can send a message.</summary>
    [ObservableProperty]
    private bool _canSend;

    /// <summary>Gets or sets the current conversation title.</summary>
    [ObservableProperty]
    private string _conversationTitle = "New Conversation";

    /// <summary>Gets or sets whether there are unsaved changes.</summary>
    [ObservableProperty]
    private bool _hasUnsavedChanges;

    /// <summary>Gets or sets the save status text.</summary>
    [ObservableProperty]
    private string? _saveStatus;

    #endregion

    #region Constructor

    /// <summary>
    /// Creates a new ChatViewModel.
    /// </summary>
    public ChatViewModel(
        IConversationService conversationService,
        ILlmService llmService,
        IDispatcher dispatcher)
    {
        _conversationService = conversationService ?? throw new ArgumentNullException(nameof(conversationService));
        _llmService = llmService ?? throw new ArgumentNullException(nameof(llmService));
        _dispatcher = dispatcher ?? throw new ArgumentNullException(nameof(dispatcher));

        // Subscribe to service events
        _conversationService.ConversationChanged += OnConversationChanged;
        _conversationService.SaveStateChanged += OnSaveStateChanged;

        // Load current conversation
        RefreshFromConversation();
    }

    #endregion

    #region Event Handlers

    private void OnConversationChanged(object? sender, ConversationChangedEventArgs e)
    {
        _dispatcher.InvokeAsync(() =>
        {
            switch (e.ChangeType)
            {
                case ConversationChangeType.Created:
                case ConversationChangeType.Loaded:
                case ConversationChangeType.Cleared:
                    RefreshFromConversation();
                    break;

                case ConversationChangeType.TitleChanged:
                    ConversationTitle = e.Conversation.Title;
                    break;

                case ConversationChangeType.Saved:
                    SaveStatus = "Saved";
                    break;
            }
        });
    }

    private void OnSaveStateChanged(object? sender, SaveStateChangedEventArgs e)
    {
        _dispatcher.InvokeAsync(() =>
        {
            HasUnsavedChanges = e.HasUnsavedChanges;

            if (e.IsSaving)
            {
                SaveStatus = "Saving...";
            }
            else if (e.Error != null)
            {
                SaveStatus = "Save failed";
            }
            else if (!e.HasUnsavedChanges)
            {
                SaveStatus = "Saved";
            }
            else
            {
                SaveStatus = null;
            }
        });
    }

    #endregion

    #region Refresh

    /// <summary>
    /// Refreshes the UI from the current conversation in the service.
    /// </summary>
    private void RefreshFromConversation()
    {
        Messages.Clear();

        var conversation = _conversationService.CurrentConversation;
        ConversationTitle = conversation.Title;
        HasUnsavedChanges = conversation.HasUnsavedChanges;

        foreach (var message in conversation.Messages)
        {
            Messages.Add(new ChatMessageViewModel(message));
        }

        UpdateCanSend();
    }

    #endregion

    #region Commands

    /// <summary>Sends the current input as a user message.</summary>
    [RelayCommand(CanExecute = nameof(CanSendMessage))]
    private async Task SendMessageAsync()
    {
        if (string.IsNullOrWhiteSpace(InputText))
            return;

        var userMessage = new ChatMessage
        {
            Id = Guid.NewGuid(),
            Role = MessageRole.User,
            Content = InputText.Trim(),
            Timestamp = DateTime.UtcNow,
            IsComplete = true
        };

        // Add user message via service (triggers auto-save)
        _conversationService.AddMessage(userMessage);
        Messages.Add(new ChatMessageViewModel(userMessage));

        var userInput = InputText;
        InputText = string.Empty;

        // Generate response
        await GenerateResponseAsync(userInput);
    }

    /// <summary>Cancels the current generation.</summary>
    [RelayCommand]
    private void CancelGeneration()
    {
        _generationCts?.Cancel();
    }

    /// <summary>Clears all messages in the current conversation.</summary>
    [RelayCommand]
    private void ClearConversation()
    {
        // This would typically require confirmation dialog
        // Implemented in v0.2.2e
    }

    private bool CanSendMessage()
    {
        return !IsGenerating && 
               !string.IsNullOrWhiteSpace(InputText) && 
               _llmService.IsModelLoaded;
    }

    #endregion

    #region Generation

    private async Task GenerateResponseAsync(string userInput)
    {
        IsGenerating = true;
        _generationCts = new CancellationTokenSource();
        UpdateCanSend();

        var assistantMessage = new ChatMessage
        {
            Id = Guid.NewGuid(),
            Role = MessageRole.Assistant,
            Content = string.Empty,
            Timestamp = DateTime.UtcNow,
            IsComplete = false
        };

        // Add placeholder message
        _conversationService.AddMessage(assistantMessage);
        var messageVm = new ChatMessageViewModel(assistantMessage);
        Messages.Add(messageVm);

        try
        {
            var startTime = DateTime.UtcNow;
            var tokenCount = 0;

            await foreach (var token in _llmService.GenerateStreamingAsync(
                _conversationService.GetMessages(),
                new InferenceOptions(), // Use current/default settings
                _generationCts.Token))
            {
                messageVm.Content += token;
                tokenCount++;

                // Update the underlying message in service
                _conversationService.UpdateMessage(assistantMessage.Id, msg =>
                {
                    msg.Content = messageVm.Content;
                });
            }

            // Mark as complete with stats
            var duration = DateTime.UtcNow - startTime;
            _conversationService.UpdateMessage(assistantMessage.Id, msg =>
            {
                msg.IsComplete = true;
                msg.TokenCount = tokenCount;
                msg.GenerationTimeMs = (int)duration.TotalMilliseconds;
                msg.TokensPerSecond = duration.TotalSeconds > 0 
                    ? (float)(tokenCount / duration.TotalSeconds) 
                    : 0;
            });

            messageVm.IsComplete = true;
        }
        catch (OperationCanceledException)
        {
            // User cancelled - mark as incomplete
            _conversationService.UpdateMessage(assistantMessage.Id, msg =>
            {
                msg.IsComplete = false;
            });
            messageVm.Content += " [Generation cancelled]";
        }
        catch (Exception ex)
        {
            // Error occurred
            messageVm.Content += $"\n\n[Error: {ex.Message}]";
            _conversationService.UpdateMessage(assistantMessage.Id, msg =>
            {
                msg.Content = messageVm.Content;
                msg.IsComplete = false;
            });
        }
        finally
        {
            IsGenerating = false;
            _generationCts?.Dispose();
            _generationCts = null;
            UpdateCanSend();
        }
    }

    #endregion

    #region Helpers

    partial void OnInputTextChanged(string value)
    {
        UpdateCanSend();
    }

    partial void OnIsGeneratingChanged(bool value)
    {
        UpdateCanSend();
    }

    private void UpdateCanSend()
    {
        CanSend = CanSendMessage();
    }

    #endregion

    #region IDisposable

    public void Dispose()
    {
        if (_isDisposed) return;
        _isDisposed = true;

        _conversationService.ConversationChanged -= OnConversationChanged;
        _conversationService.SaveStateChanged -= OnSaveStateChanged;
        _generationCts?.Cancel();
        _generationCts?.Dispose();
    }

    #endregion
}
```

---

### Task 3: Update MainWindowViewModel

**File:** `src/SeniorIntern.Desktop/ViewModels/MainWindowViewModel.cs`

Compose child ViewModels and manage sidebar state.

```csharp
namespace SeniorIntern.Desktop.ViewModels;

using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;

/// <summary>
/// ViewModel for the main application window.
/// Composes child ViewModels for sidebar and chat area.
/// </summary>
public partial class MainWindowViewModel : ViewModelBase
{
    #region Child ViewModels

    /// <summary>Gets the chat ViewModel.</summary>
    [ObservableProperty]
    private ChatViewModel _chatViewModel;

    /// <summary>Gets the conversation list ViewModel.</summary>
    [ObservableProperty]
    private ConversationListViewModel _conversationListViewModel;

    /// <summary>Gets the model selector ViewModel.</summary>
    [ObservableProperty]
    private ModelSelectorViewModel _modelSelectorViewModel;

    #endregion

    #region Properties

    /// <summary>Gets or sets the status bar text.</summary>
    [ObservableProperty]
    private string? _statusText;

    /// <summary>Gets or sets whether the sidebar is visible.</summary>
    [ObservableProperty]
    private bool _isSidebarVisible = true;

    /// <summary>Gets or sets the sidebar width (for persistence).</summary>
    [ObservableProperty]
    private double _sidebarWidth = 280;

    #endregion

    #region Constructor

    /// <summary>
    /// Creates a new MainWindowViewModel.
    /// </summary>
    public MainWindowViewModel(
        ChatViewModel chatViewModel,
        ConversationListViewModel conversationListViewModel,
        ModelSelectorViewModel modelSelectorViewModel)
    {
        _chatViewModel = chatViewModel ?? throw new ArgumentNullException(nameof(chatViewModel));
        _conversationListViewModel = conversationListViewModel ?? throw new ArgumentNullException(nameof(conversationListViewModel));
        _modelSelectorViewModel = modelSelectorViewModel ?? throw new ArgumentNullException(nameof(modelSelectorViewModel));
    }

    #endregion

    #region Initialization

    /// <summary>
    /// Initializes the ViewModel and child ViewModels.
    /// </summary>
    public async Task InitializeAsync()
    {
        StatusText = "Loading conversations...";
        
        try
        {
            await _conversationListViewModel.InitializeAsync();
            StatusText = null;
        }
        catch (Exception ex)
        {
            StatusText = $"Error: {ex.Message}";
        }
    }

    #endregion

    #region Commands

    /// <summary>Toggles the sidebar visibility.</summary>
    [RelayCommand]
    private void ToggleSidebar()
    {
        IsSidebarVisible = !IsSidebarVisible;
    }

    /// <summary>Creates a new conversation (keyboard shortcut handler).</summary>
    [RelayCommand]
    private async Task NewConversationAsync()
    {
        await _conversationListViewModel.CreateNewConversationCommand.ExecuteAsync(null);
    }

    /// <summary>Focuses the search box (keyboard shortcut handler).</summary>
    [RelayCommand]
    private void FocusSearch()
    {
        // This will be handled by the View via event
        // Placeholder for keyboard shortcut binding
    }

    #endregion
}
```

---

### Task 4: Update MainWindow.axaml

**File:** `src/SeniorIntern.Desktop/Views/MainWindow.axaml`

SplitView layout with sidebar and chat content.

```xml
<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:vm="using:SeniorIntern.Desktop.ViewModels"
        xmlns:views="using:SeniorIntern.Desktop.Views"
        x:Class="SeniorIntern.Desktop.Views.MainWindow"
        x:DataType="vm:MainWindowViewModel"
        Title="Senior Intern"
        Width="1200" Height="800"
        MinWidth="800" MinHeight="600"
        WindowStartupLocation="CenterScreen">

    <Window.KeyBindings>
        <!-- Global keyboard shortcuts -->
        <KeyBinding Gesture="Ctrl+N" Command="{Binding NewConversationCommand}" />
        <KeyBinding Gesture="Ctrl+B" Command="{Binding ToggleSidebarCommand}" />
        <KeyBinding Gesture="Ctrl+F" Command="{Binding FocusSearchCommand}" />
    </Window.KeyBindings>

    <Grid RowDefinitions="*,Auto">
        <!-- Main Content Area -->
        <SplitView Grid.Row="0"
                   IsPaneOpen="{Binding IsSidebarVisible}"
                   DisplayMode="Inline"
                   OpenPaneLength="{Binding SidebarWidth}"
                   CompactPaneLength="0">

            <!-- Sidebar Pane -->
            <SplitView.Pane>
                <Border Background="{DynamicResource SidebarBackgroundColor}"
                        BorderBrush="{DynamicResource BorderColor}"
                        BorderThickness="0,0,1,0">
                    <Grid RowDefinitions="Auto,*">
                        <!-- Model Selector -->
                        <views:ModelSelectorView Grid.Row="0"
                                                 DataContext="{Binding ModelSelectorViewModel}"
                                                 Margin="0,0,0,8" />

                        <!-- Conversation List -->
                        <views:ConversationListView Grid.Row="1"
                                                    DataContext="{Binding ConversationListViewModel}" />
                    </Grid>
                </Border>
            </SplitView.Pane>

            <!-- Main Chat Content -->
            <SplitView.Content>
                <Grid>
                    <!-- Chat View -->
                    <views:ChatView DataContext="{Binding ChatViewModel}" />

                    <!-- Sidebar Toggle Button (when hidden) -->
                    <Button HorizontalAlignment="Left"
                            VerticalAlignment="Top"
                            Margin="8"
                            Command="{Binding ToggleSidebarCommand}"
                            IsVisible="{Binding !IsSidebarVisible}"
                            Classes="icon-button"
                            ToolTip.Tip="Show Sidebar (Ctrl+B)">
                        <PathIcon Data="{StaticResource MenuIcon}"
                                  Width="16" Height="16" />
                    </Button>
                </Grid>
            </SplitView.Content>
        </SplitView>

        <!-- Status Bar -->
        <Border Grid.Row="1"
                Background="{DynamicResource StatusBarBackgroundColor}"
                Padding="12,4"
                IsVisible="{Binding StatusText, Converter={x:Static StringConverters.IsNotNullOrEmpty}}">
            <TextBlock Text="{Binding StatusText}"
                       FontSize="12"
                       Foreground="{DynamicResource TextSecondaryColor}" />
        </Border>
    </Grid>
</Window>
```

---

### Task 5: Update MainWindow.axaml.cs

**File:** `src/SeniorIntern.Desktop/Views/MainWindow.axaml.cs`

Code-behind with initialization.

```csharp
namespace SeniorIntern.Desktop.Views;

using Avalonia.Controls;
using SeniorIntern.Desktop.ViewModels;

/// <summary>
/// Code-behind for the main application window.
/// </summary>
public partial class MainWindow : Window
{
    public MainWindow()
    {
        InitializeComponent();
    }

    /// <summary>
    /// Initializes the window and its ViewModels.
    /// </summary>
    public async Task InitializeAsync()
    {
        if (DataContext is MainWindowViewModel viewModel)
        {
            await viewModel.InitializeAsync();
        }
    }

    /// <summary>
    /// Called when the window is loaded.
    /// </summary>
    protected override async void OnOpened(EventArgs e)
    {
        base.OnOpened(e);
        await InitializeAsync();
    }
}
```

---

### Task 6: Update DI Registration

**File:** `src/SeniorIntern.Desktop/Extensions/ServiceCollectionExtensions.cs`

Complete service and ViewModel registration.

```csharp
namespace SeniorIntern.Desktop.Extensions;

using Microsoft.Extensions.DependencyInjection;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Data;
using SeniorIntern.Data.Repositories;
using SeniorIntern.Services;
using SeniorIntern.Desktop.ViewModels;

/// <summary>
/// Extension methods for service collection configuration.
/// </summary>
public static class ServiceCollectionExtensions
{
    /// <summary>
    /// Adds all application services to the service collection.
    /// </summary>
    public static IServiceCollection AddApplicationServices(this IServiceCollection services)
    {
        // Database
        services.AddDbContext<SeniorInternDbContext>();

        // Repositories
        services.AddScoped<IConversationRepository, ConversationRepository>();
        services.AddScoped<ISystemPromptRepository, SystemPromptRepository>();
        services.AddScoped<IInferencePresetRepository, InferencePresetRepository>();

        // Services
        services.AddSingleton<IConversationService, DatabaseConversationService>();
        services.AddSingleton<ILlmService, LlmService>(); // Existing

        // Dispatcher
        services.AddSingleton<IDispatcher, AvaloniaDispatcher>();

        // ViewModels
        services.AddSingleton<MainWindowViewModel>();
        services.AddSingleton<ChatViewModel>();
        services.AddSingleton<ConversationListViewModel>();
        services.AddSingleton<ModelSelectorViewModel>();

        return services;
    }
}
```

---

### Task 7: Add Menu Icon Resource

**File:** `src/SeniorIntern.Desktop/Assets/Icons.axaml` (append)

```xml
<!-- Menu/Hamburger Icon for sidebar toggle -->
<StreamGeometry x:Key="MenuIcon">M4 6h16M4 12h16M4 18h16</StreamGeometry>
```

---

## Logging Specifications

### Log Levels by Operation

| Level | Operations |
|-------|------------|
| Debug | Message send, generation start/complete, conversation switch |
| Information | User-initiated actions (new conversation, switch) |
| Warning | Generation cancelled, retry |
| Error | Generation failure, service exceptions |

### Note on ViewModel Logging

The ChatViewModel delegates most logging to the underlying services. Key actions should be logged at the service layer.

---

## Unit Testing Requirements

### Test Summary

| Component | Test Count | Focus Areas |
|-----------|------------|-------------|
| ChatMessageViewModel | 6 | Properties, display helpers |
| ChatViewModel | 14 | Commands, event handling, refresh |
| MainWindowViewModel | 4 | Initialization, sidebar toggle |
| **Total** | **24** | |

### Key Test Scenarios

```csharp
// ChatMessageViewModel Tests
[Fact]
public void IsUser_ReturnsTrue_ForUserRole()
{
    var message = new ChatMessage { Role = MessageRole.User };
    var vm = new ChatMessageViewModel(message);
    
    Assert.True(vm.IsUser);
    Assert.False(vm.IsAssistant);
}

[Fact]
public void IsGenerating_ReturnsTrue_WhenAssistantAndNotComplete()
{
    var message = new ChatMessage 
    { 
        Role = MessageRole.Assistant, 
        IsComplete = false 
    };
    var vm = new ChatMessageViewModel(message);
    
    Assert.True(vm.IsGenerating);
}

// ChatViewModel Tests
[Fact]
public void RefreshFromConversation_PopulatesMessages()
{
    var mockService = new Mock<IConversationService>();
    var conversation = new Conversation();
    conversation.AddMessage(new ChatMessage { Content = "Test" });
    mockService.Setup(s => s.CurrentConversation).Returns(conversation);
    
    var vm = CreateViewModel(mockService.Object);
    
    Assert.Single(vm.Messages);
    Assert.Equal("Test", vm.Messages[0].Content);
}

[Fact]
public async Task SendMessageAsync_AddsUserMessage_AndGeneratesResponse()
{
    var mockService = new Mock<IConversationService>();
    var mockLlm = new Mock<ILlmService>();
    mockLlm.Setup(l => l.IsModelLoaded).Returns(true);
    mockLlm.Setup(l => l.GenerateStreamingAsync(
        It.IsAny<IEnumerable<ChatMessage>>(),
        It.IsAny<InferenceOptions>(),
        It.IsAny<CancellationToken>()))
        .Returns(AsyncEnumerable("Hello", " world"));
    
    var vm = CreateViewModel(mockService.Object, mockLlm.Object);
    vm.InputText = "Test input";
    
    await vm.SendMessageCommand.ExecuteAsync(null);
    
    mockService.Verify(s => s.AddMessage(It.Is<ChatMessage>(m => m.Role == MessageRole.User)), Times.Once);
    mockService.Verify(s => s.AddMessage(It.Is<ChatMessage>(m => m.Role == MessageRole.Assistant)), Times.Once);
}

[Fact]
public void OnConversationChanged_Loaded_RefreshesMessages()
{
    var mockService = new Mock<IConversationService>();
    var mockDispatcher = new TestDispatcher();
    var vm = CreateViewModel(mockService.Object, dispatcher: mockDispatcher);
    
    var newConversation = new Conversation { Title = "New Title" };
    newConversation.AddMessage(new ChatMessage { Content = "From DB" });
    mockService.Setup(s => s.CurrentConversation).Returns(newConversation);
    
    // Simulate event
    mockService.Raise(s => s.ConversationChanged += null, 
        new ConversationChangedEventArgs 
        { 
            Conversation = newConversation, 
            ChangeType = ConversationChangeType.Loaded 
        });
    
    Assert.Equal("New Title", vm.ConversationTitle);
    Assert.Single(vm.Messages);
}

[Fact]
public void OnSaveStateChanged_UpdatesStatus()
{
    var mockService = new Mock<IConversationService>();
    var mockDispatcher = new TestDispatcher();
    var vm = CreateViewModel(mockService.Object, dispatcher: mockDispatcher);
    
    // Simulate saving
    mockService.Raise(s => s.SaveStateChanged += null,
        new SaveStateChangedEventArgs { IsSaving = true, HasUnsavedChanges = true });
    
    Assert.Equal("Saving...", vm.SaveStatus);
    
    // Simulate saved
    mockService.Raise(s => s.SaveStateChanged += null,
        new SaveStateChangedEventArgs { IsSaving = false, HasUnsavedChanges = false });
    
    Assert.Equal("Saved", vm.SaveStatus);
}

// MainWindowViewModel Tests
[Fact]
public async Task InitializeAsync_LoadsConversationList()
{
    var mockChatVm = new Mock<ChatViewModel>();
    var mockListVm = new Mock<ConversationListViewModel>();
    var mockSelectorVm = new Mock<ModelSelectorViewModel>();
    
    var vm = new MainWindowViewModel(
        mockChatVm.Object, 
        mockListVm.Object, 
        mockSelectorVm.Object);
    
    await vm.InitializeAsync();
    
    mockListVm.Verify(l => l.InitializeAsync(), Times.Once);
}

[Fact]
public void ToggleSidebar_TogglesVisibility()
{
    var vm = CreateMainWindowViewModel();
    
    Assert.True(vm.IsSidebarVisible);
    
    vm.ToggleSidebarCommand.Execute(null);
    Assert.False(vm.IsSidebarVisible);
    
    vm.ToggleSidebarCommand.Execute(null);
    Assert.True(vm.IsSidebarVisible);
}
```

---

## Use Cases

### UC-001: Send Message with Persistent Response

| Attribute | Value |
|-----------|-------|
| **Actor** | User |
| **Trigger** | User types message and presses Enter |
| **Success Scenario** | Message sent, response streamed, both persisted |
| **Postcondition** | Conversation auto-saved to database |

#### Flow
1. User types message in input box
2. User presses Enter or clicks Send
3. User message appears immediately
4. Service adds message → triggers auto-save timer
5. Assistant placeholder message appears
6. Tokens stream in, updating content in real-time
7. On completion, stats calculated
8. Auto-save timer fires, persisting to database

---

### UC-002: Switch Conversation

| Attribute | Value |
|-----------|-------|
| **Actor** | User |
| **Trigger** | User clicks different conversation in sidebar |
| **Success Scenario** | Chat area shows selected conversation's messages |
| **Postcondition** | Previous conversation saved, new one displayed |

---

### UC-003: Cancel Generation

| Attribute | Value |
|-----------|-------|
| **Actor** | User |
| **Trigger** | User clicks Cancel during generation |
| **Success Scenario** | Generation stops, partial response preserved |
| **Postcondition** | Message marked incomplete, saved to database |

---

### UC-004: Toggle Sidebar

| Attribute | Value |
|-----------|-------|
| **Actor** | User |
| **Trigger** | User presses Ctrl+B or clicks toggle button |
| **Success Scenario** | Sidebar shows/hides |
| **Postcondition** | More space for chat when hidden |

---

## Deliverable Checklist

### Presentation Layer (SeniorIntern.Desktop)
- [ ] ViewModels/ChatMessageViewModel.cs (NEW or UPDATED)
- [ ] ViewModels/ChatViewModel.cs (UPDATED)
- [ ] ViewModels/MainWindowViewModel.cs (UPDATED)
- [ ] Views/MainWindow.axaml (UPDATED)
- [ ] Views/MainWindow.axaml.cs (UPDATED)
- [ ] Extensions/ServiceCollectionExtensions.cs (UPDATED)
- [ ] Assets/Icons.axaml (UPDATED - add MenuIcon)

### Tests
- [ ] SeniorIntern.Desktop.Tests - ViewModel tests

---

## Files Summary

### Files to Create (1)

| File | Purpose | Lines (approx) |
|------|---------|----------------|
| `ViewModels/ChatMessageViewModel.cs` | Message display wrapper | 100 |

### Files to Modify (5)

| File | Changes |
|------|---------|
| `ViewModels/ChatViewModel.cs` | Add service integration, events, generation |
| `ViewModels/MainWindowViewModel.cs` | Add child VMs, initialization, sidebar |
| `Views/MainWindow.axaml` | SplitView layout, keyboard bindings |
| `Views/MainWindow.axaml.cs` | OnOpened initialization |
| `Extensions/ServiceCollectionExtensions.cs` | Complete DI registration |
| `Assets/Icons.axaml` | Add MenuIcon |

---

## Verification Steps

### Step 1: Verify Compilation

```bash
dotnet build src/SeniorIntern.Desktop
```

### Step 2: Run Unit Tests

```bash
dotnet test tests/SeniorIntern.Desktop.Tests
```

### Step 3: Integration Testing

1. Run application
2. Verify sidebar displays with conversation list
3. Create new conversation → verify it appears in list
4. Send message → verify response streams
5. Wait 600ms → verify auto-save occurs
6. Switch conversation → verify chat updates
7. Toggle sidebar → verify shows/hides
8. Press Ctrl+N → verify new conversation

### Step 4: Persistence Verification

1. Close application
2. Reopen application
3. Verify conversations load
4. Select previous conversation
5. Verify messages load

---

## Acceptance Criteria

| ID | Criterion | Verification |
|----|-----------|--------------|
| AC-1 | ChatViewModel subscribes to service events | Events handled correctly |
| AC-2 | Messages persist via service.AddMessage | Database contains messages |
| AC-3 | Streaming updates content in real-time | UI shows tokens as they arrive |
| AC-4 | Cancel stops generation | Generation terminates, message preserved |
| AC-5 | Conversation switch loads messages | RefreshFromConversation populates UI |
| AC-6 | Save status shows in UI | "Saving...", "Saved", or null |
| AC-7 | MainWindow composes child VMs | All ViewModels wired correctly |
| AC-8 | Sidebar toggles | Ctrl+B and button work |
| AC-9 | Keyboard shortcuts work | Ctrl+N, Ctrl+B, Ctrl+F |
| AC-10 | DI registration complete | App starts without DI errors |

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Event handler memory leaks | Low | Medium | Implement IDisposable everywhere |
| Race conditions in generation | Medium | Medium | CancellationToken properly propagated |
| Streaming performance | Low | Low | Update message in batches if needed |
| Sidebar layout issues | Low | Low | Test on various window sizes |

---

## Design Decisions

### Decision 1: Singleton ViewModels

**Decision:** Register ChatViewModel and ConversationListViewModel as singletons.
**Rationale:** They share state with IConversationService (also singleton); ensures consistent state.

### Decision 2: Event-Based Communication

**Decision:** ViewModels subscribe to service events rather than direct calls.
**Rationale:** Loose coupling, testability, supports multiple subscribers.

### Decision 3: Dispatcher for All Events

**Decision:** Always dispatch event handlers to UI thread.
**Rationale:** Service events may fire from background threads (timer, async).

### Decision 4: SplitView for Layout

**Decision:** Use Avalonia's SplitView control.
**Rationale:** Built-in pane behavior, familiar UX pattern.

### Decision 5: OnOpened for Async Init

**Decision:** Call InitializeAsync in Window.OnOpened.
**Rationale:** Constructor can't be async; OnOpened is appropriate lifecycle hook.

---

## Future Considerations

| Item | Target Version | Rationale |
|------|----------------|-----------|
| Unsaved changes dialog | v0.2.2e | Better confirmation UX |
| Delete confirmation | v0.2.2e | Prevent accidental deletion |
| Message editing | v0.3.0+ | Allow editing sent messages |
| Message deletion | v0.3.0+ | Allow removing messages |

---

## Timeline Estimate

| Version | Estimated Effort | Key Deliverables |
|---------|------------------|------------------|
| v0.2.2d | 1-2 days | Full integration, 6 files modified |

---

## References

- [Avalonia SplitView](https://docs.avaloniaui.net/docs/controls/splitview)
- [Avalonia KeyBindings](https://docs.avaloniaui.net/docs/input/keybindings)
- [CommunityToolkit.Mvvm Commands](https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/generators/relaycommand)
- [Async Streams in C#](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-await-foreach-statement)
