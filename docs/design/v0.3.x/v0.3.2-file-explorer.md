# Design Specification: The Senior Intern v0.3.2 "File Explorer"

## Executive Summary

This document provides a comprehensive design specification for v0.3.2, which implements a full-featured file explorer sidebar with tree view navigation, context menus, file operations, keyboard shortcuts, and file filtering. The file explorer serves as the primary interface for users to browse and interact with their project files within the workspace.

### v0.3.2 Scope (from v0.3.0 Design Document)
- Tree view UI for displaying workspace files and folders
- Lazy-loading directory expansion
- File/folder context menus with operations (new, rename, delete, copy path)
- File filtering/search within the explorer
- Keyboard navigation and shortcuts
- File icons based on file type/extension
- Integration with workspace service for state persistence
- "Attach to Context" action for chat integration (v0.3.4 prerequisite)

### Dependencies
- **v0.3.1** must be complete (Workspace Service, File System Service, Language Detector)

---

## Sub-Part Breakdown

| Part | Name | Focus |
|------|------|-------|
| v0.3.2a | File Tree Item ViewModel | FileTreeItemViewModel with lazy loading, icons, states |
| v0.3.2b | File Explorer ViewModel | FileExplorerViewModel, commands, filtering, workspace integration |
| v0.3.2c | File Icon System | FileIconProvider, icon resources, converter |
| v0.3.2d | Tree View UI | FileExplorerView.axaml with TreeView, templates, empty states |
| v0.3.2e | Context Menus | File and folder context menus, operations |
| v0.3.2f | Keyboard & Interactions | Keyboard shortcuts, inline rename, delete confirmation |
| v0.3.2g | Main Window Integration | Sidebar layout, workspace header, refresh on changes |

---

## Architecture Overview

### Component Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              MainWindow                                       │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │                         MainWindowViewModel                             │  │
│  │                                │                                        │  │
│  │          ┌─────────────────────┼─────────────────────┐                 │  │
│  │          ▼                     ▼                     ▼                 │  │
│  │  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐        │  │
│  │  │FileExplorerVM   │  │ EditorPanelVM   │  │  ChatViewModel  │        │  │
│  │  │ (v0.3.2)        │  │ (v0.3.3)        │  │  (v0.2.0)       │        │  │
│  │  └─────────────────┘  └─────────────────┘  └─────────────────┘        │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────┘
                │
                ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                         FileExplorerViewModel                                 │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │ Properties:                                                             │  │
│  │ • RootItems: ObservableCollection<FileTreeItemViewModel>               │  │
│  │ • SelectedItem: FileTreeItemViewModel?                                 │  │
│  │ • SearchFilter: string                                                 │  │
│  │ • HasWorkspace, WorkspaceName, IsLoading                               │  │
│  ├───────────────────────────────────────────────────────────────────────┤  │
│  │ Commands:                                                               │  │
│  │ • OpenWorkspace, CloseWorkspace, Refresh                               │  │
│  │ • OpenFile, ExpandFolder, CollapseFolder                               │  │
│  │ • NewFile, NewFolder, Rename, Delete                                   │  │
│  │ • CopyPath, CopyRelativePath, RevealInFinder                          │  │
│  │ • AttachToContext                                                      │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                │                                                             │
│                ▼                                                             │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │                    FileTreeItemViewModel                                │  │
│  │ • Name, Path, ItemType                                                  │  │
│  │ • IsExpanded, IsSelected, IsLoading, IsRenaming                        │  │
│  │ • Children: ObservableCollection<FileTreeItemViewModel>                │  │
│  │ • IconKey, IsModified                                                   │  │
│  │ • HasChildren (for lazy load indicator)                                │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────┘
                │
                ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                            Service Layer                                      │
│  ┌─────────────────────────┐        ┌─────────────────────────────────┐     │
│  │    IWorkspaceService    │        │      IFileSystemService          │     │
│  │ • CurrentWorkspace      │        │ • GetDirectoryContentsAsync     │     │
│  │ • WorkspaceChanged      │        │ • CreateFileAsync               │     │
│  │ • UpdateExpandedFolders │        │ • CreateDirectoryAsync          │     │
│  └─────────────────────────┘        │ • RenameAsync                   │     │
│                                      │ • DeleteFileAsync               │     │
│                                      │ • DeleteDirectoryAsync          │     │
│                                      │ • ShouldIgnore                  │     │
│                                      └─────────────────────────────────┘     │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Data Flow: Loading Directory Contents

```
User expands folder (clicks arrow or double-clicks)
                │
                ▼
┌──────────────────────────────┐
│ FileTreeItemViewModel        │
│ .IsExpanded = true           │
└──────────────────────────────┘
                │
                ▼
┌──────────────────────────────┐
│ FileExplorerViewModel        │
│ .ExpandFolderAsync()         │
└──────────────────────────────┘
                │
                ▼
┌──────────────────────────────┐
│ Check if Children already    │
│ loaded (lazy loading)        │
└──────────────────────────────┘
                │
        ┌───────┴───────┐
        ▼               ▼
   [Loaded]        [Not Loaded]
        │               │
        │               ▼
        │   ┌──────────────────────────┐
        │   │ IFileSystemService       │
        │   │ .GetDirectoryContentsAsync│
        │   └──────────────────────────┘
        │               │
        │               ▼
        │   ┌──────────────────────────┐
        │   │ Filter by .gitignore     │
        │   │ and ShowHiddenFiles      │
        │   └──────────────────────────┘
        │               │
        │               ▼
        │   ┌──────────────────────────┐
        │   │ Create FileTreeItemVM    │
        │   │ for each item            │
        │   └──────────────────────────┘
        │               │
        └───────┬───────┘
                ▼
┌──────────────────────────────┐
│ Update Children collection   │
│ (UI auto-updates via binding)│
└──────────────────────────────┘
                │
                ▼
┌──────────────────────────────┐
│ IWorkspaceService            │
│ .UpdateExpandedFolders()     │
│ (persist state)              │
└──────────────────────────────┘
```

### Data Flow: File Filtering

```
User types in filter TextBox
                │
                ▼
┌──────────────────────────────┐
│ SearchFilter property        │
│ changes (debounced 200ms)    │
└──────────────────────────────┘
                │
                ▼
┌──────────────────────────────┐
│ ApplyFilterAsync()           │
└──────────────────────────────┘
                │
                ▼
┌──────────────────────────────┐
│ Recursively walk tree:       │
│ • Set IsVisible on items     │
│ • Auto-expand matching items │
│ • Highlight matches          │
└──────────────────────────────┘
                │
                ▼
┌──────────────────────────────┐
│ UI updates via binding       │
│ (filtered items visible)     │
└──────────────────────────────┘
```

---

## v0.3.2a: File Tree Item ViewModel

### Objective
Create the ViewModel for individual tree items supporting lazy loading, multiple states, and icon management.

### FileTreeItemViewModel Implementation

```csharp
// src/SeniorIntern.Desktop/ViewModels/FileTreeItemViewModel.cs
namespace SeniorIntern.Desktop.ViewModels;

using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using SeniorIntern.Core.Models;
using SeniorIntern.Core.Utilities;
using System.Collections.ObjectModel;

/// <summary>
/// ViewModel for a file or folder in the file explorer tree.
/// Supports lazy loading, inline rename, and various display states.
/// </summary>
public partial class FileTreeItemViewModel : ViewModelBase
{
    private readonly FileExplorerViewModel _parent;
    private bool _childrenLoaded;

    #region Observable Properties

    /// <summary>
    /// Display name of the file or folder.
    /// </summary>
    [ObservableProperty]
    private string _name = string.Empty;

    /// <summary>
    /// Absolute path to the item.
    /// </summary>
    [ObservableProperty]
    private string _path = string.Empty;

    /// <summary>
    /// Type of item (file, directory, symbolic link).
    /// </summary>
    [ObservableProperty]
    private FileSystemItemType _itemType;

    /// <summary>
    /// Whether this folder is expanded in the tree.
    /// </summary>
    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(IconKey))]
    private bool _isExpanded;

    /// <summary>
    /// Whether this item is currently selected.
    /// </summary>
    [ObservableProperty]
    private bool _isSelected;

    /// <summary>
    /// Whether children are currently being loaded.
    /// </summary>
    [ObservableProperty]
    private bool _isLoading;

    /// <summary>
    /// Whether the item is in inline rename mode.
    /// </summary>
    [ObservableProperty]
    private bool _isRenaming;

    /// <summary>
    /// The name being edited during rename.
    /// </summary>
    [ObservableProperty]
    private string _editingName = string.Empty;

    /// <summary>
    /// Whether the file has unsaved changes (for editor integration).
    /// </summary>
    [ObservableProperty]
    private bool _isModified;

    /// <summary>
    /// Whether this item is visible after filtering.
    /// </summary>
    [ObservableProperty]
    private bool _isVisible = true;

    /// <summary>
    /// Whether to highlight this item (matches filter).
    /// </summary>
    [ObservableProperty]
    private bool _isHighlighted;

    /// <summary>
    /// Child items (for directories).
    /// </summary>
    public ObservableCollection<FileTreeItemViewModel> Children { get; } = [];

    /// <summary>
    /// Whether this directory has children (for expansion indicator).
    /// Set from FileSystemItem.HasChildren during creation.
    /// </summary>
    [ObservableProperty]
    private bool _hasChildren;

    /// <summary>
    /// Depth level in the tree (for indentation).
    /// </summary>
    [ObservableProperty]
    private int _depth;

    #endregion

    #region Computed Properties

    /// <summary>
    /// Whether this is a directory.
    /// </summary>
    public bool IsDirectory => ItemType == FileSystemItemType.Directory;

    /// <summary>
    /// Whether this is a file.
    /// </summary>
    public bool IsFile => ItemType == FileSystemItemType.File;

    /// <summary>
    /// File extension including dot (e.g., ".cs").
    /// </summary>
    public string Extension => IsFile ? System.IO.Path.GetExtension(Path) : string.Empty;

    /// <summary>
    /// Detected programming language.
    /// </summary>
    public string? Language => IsFile ? LanguageDetector.DetectByFileName(Name) : null;

    /// <summary>
    /// Icon key based on item type, extension, and expansion state.
    /// </summary>
    public string IconKey => GetIconKey();

    /// <summary>
    /// Whether children have been loaded (for lazy loading).
    /// </summary>
    public bool ChildrenLoaded => _childrenLoaded;

    /// <summary>
    /// Whether to show the expansion arrow.
    /// </summary>
    public bool ShowExpander => IsDirectory && HasChildren;

    #endregion

    #region Constructor

    public FileTreeItemViewModel(FileExplorerViewModel parent)
    {
        _parent = parent;
    }

    /// <summary>
    /// Creates a FileTreeItemViewModel from a FileSystemItem.
    /// </summary>
    public static FileTreeItemViewModel FromFileSystemItem(
        FileSystemItem item,
        FileExplorerViewModel parent,
        int depth = 0)
    {
        return new FileTreeItemViewModel(parent)
        {
            Name = item.Name,
            Path = item.Path,
            ItemType = item.Type,
            HasChildren = item.HasChildren,
            Depth = depth,
            _childrenLoaded = false
        };
    }

    #endregion

    #region Expansion

    /// <summary>
    /// Called when IsExpanded changes.
    /// </summary>
    partial void OnIsExpandedChanged(bool value)
    {
        if (value && !_childrenLoaded && IsDirectory)
        {
            _ = LoadChildrenAsync();
        }

        // Notify parent to persist expanded state
        _parent.OnItemExpansionChanged(this);
    }

    /// <summary>
    /// Loads children for this directory.
    /// </summary>
    public async Task LoadChildrenAsync()
    {
        if (_childrenLoaded || !IsDirectory)
            return;

        IsLoading = true;
        try
        {
            var children = await _parent.LoadChildrenForItemAsync(this);

            await Avalonia.Threading.Dispatcher.UIThread.InvokeAsync(() =>
            {
                Children.Clear();
                foreach (var child in children)
                {
                    Children.Add(child);
                }
            });

            _childrenLoaded = true;
        }
        finally
        {
            IsLoading = false;
        }
    }

    /// <summary>
    /// Forces a reload of children.
    /// </summary>
    public async Task RefreshChildrenAsync()
    {
        _childrenLoaded = false;
        Children.Clear();

        if (IsExpanded)
        {
            await LoadChildrenAsync();
        }
    }

    #endregion

    #region Rename Support

    /// <summary>
    /// Starts inline rename mode.
    /// </summary>
    public void BeginRename()
    {
        EditingName = Name;
        IsRenaming = true;
    }

    /// <summary>
    /// Commits the rename operation.
    /// </summary>
    [RelayCommand]
    private async Task CommitRenameAsync()
    {
        if (!IsRenaming)
            return;

        var newName = EditingName.Trim();

        if (string.IsNullOrEmpty(newName) || newName == Name)
        {
            CancelRename();
            return;
        }

        // Validate name
        if (newName.IndexOfAny(System.IO.Path.GetInvalidFileNameChars()) >= 0)
        {
            // TODO: Show error message
            CancelRename();
            return;
        }

        await _parent.RenameItemAsync(this, newName);
        IsRenaming = false;
    }

    /// <summary>
    /// Cancels the rename operation.
    /// </summary>
    [RelayCommand]
    private void CancelRename()
    {
        IsRenaming = false;
        EditingName = Name;
    }

    #endregion

    #region Filtering

    /// <summary>
    /// Checks if this item matches the given filter.
    /// </summary>
    public bool MatchesFilter(string filter)
    {
        if (string.IsNullOrWhiteSpace(filter))
            return true;

        return Name.Contains(filter, StringComparison.OrdinalIgnoreCase);
    }

    /// <summary>
    /// Applies filter to this item and its children.
    /// Returns true if this item or any descendant matches.
    /// </summary>
    public bool ApplyFilter(string filter)
    {
        if (string.IsNullOrWhiteSpace(filter))
        {
            IsVisible = true;
            IsHighlighted = false;

            foreach (var child in Children)
            {
                child.ApplyFilter(filter);
            }

            return true;
        }

        var selfMatches = MatchesFilter(filter);
        var childMatches = false;

        foreach (var child in Children)
        {
            if (child.ApplyFilter(filter))
            {
                childMatches = true;
            }
        }

        IsVisible = selfMatches || childMatches;
        IsHighlighted = selfMatches;

        // Auto-expand if children match
        if (childMatches && !IsExpanded && IsDirectory)
        {
            IsExpanded = true;
        }

        return IsVisible;
    }

    #endregion

    #region Icon Resolution

    private string GetIconKey()
    {
        if (IsDirectory)
        {
            return IsExpanded ? "folder-open" : "folder";
        }

        // Use extension-based icon
        return FileIconProvider.GetIconKeyForExtension(Extension);
    }

    #endregion

    #region Equality

    public override bool Equals(object? obj)
    {
        return obj is FileTreeItemViewModel other && Path == other.Path;
    }

    public override int GetHashCode()
    {
        return Path.GetHashCode();
    }

    #endregion
}
```

### Files to Create (v0.3.2a)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/ViewModels/FileTreeItemViewModel.cs` | Tree item ViewModel |

---

## v0.3.2b: File Explorer ViewModel

### Objective
Create the main ViewModel for the file explorer with workspace integration, commands, and filtering.

### FileExplorerViewModel Implementation

```csharp
// src/SeniorIntern.Desktop/ViewModels/FileExplorerViewModel.cs
namespace SeniorIntern.Desktop.ViewModels;

using Avalonia.Platform.Storage;
using Avalonia.Threading;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Timers;

/// <summary>
/// ViewModel for the file explorer sidebar.
/// </summary>
public partial class FileExplorerViewModel : ViewModelBase, IDisposable
{
    private readonly IWorkspaceService _workspaceService;
    private readonly IFileSystemService _fileSystemService;
    private readonly ISettingsService _settingsService;
    private readonly ILogger<FileExplorerViewModel> _logger;
    private readonly Timer _filterDebounceTimer;
    private readonly IStorageProvider _storageProvider;

    private string _pendingFilter = string.Empty;
    private IReadOnlyList<string> _ignorePatterns = [];

    #region Observable Properties

    /// <summary>
    /// Root items in the tree (workspace root contents).
    /// </summary>
    public ObservableCollection<FileTreeItemViewModel> RootItems { get; } = [];

    /// <summary>
    /// Currently selected item in the tree.
    /// </summary>
    [ObservableProperty]
    private FileTreeItemViewModel? _selectedItem;

    /// <summary>
    /// Whether a workspace is currently open.
    /// </summary>
    [ObservableProperty]
    private bool _hasWorkspace;

    /// <summary>
    /// Display name of the current workspace.
    /// </summary>
    [ObservableProperty]
    private string _workspaceName = string.Empty;

    /// <summary>
    /// Root path of the current workspace.
    /// </summary>
    [ObservableProperty]
    private string _workspacePath = string.Empty;

    /// <summary>
    /// Whether tree is currently loading.
    /// </summary>
    [ObservableProperty]
    private bool _isLoading;

    /// <summary>
    /// Current filter text.
    /// </summary>
    [ObservableProperty]
    private string _searchFilter = string.Empty;

    /// <summary>
    /// Whether filter is currently being applied.
    /// </summary>
    [ObservableProperty]
    private bool _isFiltering;

    /// <summary>
    /// Error message to display (if any).
    /// </summary>
    [ObservableProperty]
    private string? _errorMessage;

    /// <summary>
    /// Number of items matching current filter.
    /// </summary>
    [ObservableProperty]
    private int _filteredItemCount;

    #endregion

    #region Events

    /// <summary>
    /// Raised when a file should be opened in the editor.
    /// </summary>
    public event EventHandler<FileOpenRequestedEventArgs>? FileOpenRequested;

    /// <summary>
    /// Raised when a file should be attached to chat context.
    /// </summary>
    public event EventHandler<FileAttachRequestedEventArgs>? FileAttachRequested;

    #endregion

    #region Constructor

    public FileExplorerViewModel(
        IWorkspaceService workspaceService,
        IFileSystemService fileSystemService,
        ISettingsService settingsService,
        IStorageProvider storageProvider,
        ILogger<FileExplorerViewModel> logger)
    {
        _workspaceService = workspaceService;
        _fileSystemService = fileSystemService;
        _settingsService = settingsService;
        _storageProvider = storageProvider;
        _logger = logger;

        // Filter debounce timer (200ms)
        _filterDebounceTimer = new Timer(200) { AutoReset = false };
        _filterDebounceTimer.Elapsed += OnFilterDebounceElapsed;

        // Subscribe to workspace events
        _workspaceService.WorkspaceChanged += OnWorkspaceChanged;

        // Initialize from current workspace
        if (_workspaceService.CurrentWorkspace != null)
        {
            _ = LoadWorkspaceAsync(_workspaceService.CurrentWorkspace);
        }
    }

    #endregion

    #region Filter Handling

    partial void OnSearchFilterChanged(string value)
    {
        _pendingFilter = value;
        _filterDebounceTimer.Stop();
        _filterDebounceTimer.Start();
    }

    private async void OnFilterDebounceElapsed(object? sender, ElapsedEventArgs e)
    {
        await Dispatcher.UIThread.InvokeAsync(() => ApplyFilter(_pendingFilter));
    }

    private void ApplyFilter(string filter)
    {
        IsFiltering = true;
        var matchCount = 0;

        try
        {
            foreach (var item in RootItems)
            {
                if (item.ApplyFilter(filter))
                {
                    matchCount++;
                }
            }

            FilteredItemCount = matchCount;
        }
        finally
        {
            IsFiltering = false;
        }
    }

    /// <summary>
    /// Clears the current filter.
    /// </summary>
    [RelayCommand]
    private void ClearFilter()
    {
        SearchFilter = string.Empty;
    }

    #endregion

    #region Workspace Commands

    /// <summary>
    /// Opens a folder selection dialog to choose a workspace.
    /// </summary>
    [RelayCommand]
    private async Task OpenWorkspaceAsync()
    {
        try
        {
            var folders = await _storageProvider.OpenFolderPickerAsync(new FolderPickerOpenOptions
            {
                Title = "Open Folder",
                AllowMultiple = false
            });

            if (folders.Count == 0)
                return;

            var folder = folders[0];
            var path = folder.Path.LocalPath;

            await _workspaceService.OpenWorkspaceAsync(path);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to open workspace");
            ErrorMessage = $"Failed to open folder: {ex.Message}";
        }
    }

    /// <summary>
    /// Closes the current workspace.
    /// </summary>
    [RelayCommand]
    private async Task CloseWorkspaceAsync()
    {
        await _workspaceService.CloseWorkspaceAsync();
    }

    /// <summary>
    /// Refreshes the entire tree.
    /// </summary>
    [RelayCommand]
    private async Task RefreshAsync()
    {
        if (_workspaceService.CurrentWorkspace == null)
            return;

        await LoadWorkspaceAsync(_workspaceService.CurrentWorkspace);
    }

    #endregion

    #region File/Folder Operations

    /// <summary>
    /// Opens a file in the editor.
    /// </summary>
    [RelayCommand]
    private void OpenFile(FileTreeItemViewModel? item)
    {
        if (item == null || !item.IsFile)
            return;

        FileOpenRequested?.Invoke(this, new FileOpenRequestedEventArgs(item.Path));
    }

    /// <summary>
    /// Expands a folder.
    /// </summary>
    [RelayCommand]
    private async Task ExpandFolderAsync(FileTreeItemViewModel? item)
    {
        if (item == null || !item.IsDirectory)
            return;

        item.IsExpanded = true;
        await item.LoadChildrenAsync();
    }

    /// <summary>
    /// Collapses a folder.
    /// </summary>
    [RelayCommand]
    private void CollapseFolder(FileTreeItemViewModel? item)
    {
        if (item == null || !item.IsDirectory)
            return;

        item.IsExpanded = false;
    }

    /// <summary>
    /// Creates a new file in the specified folder (or workspace root).
    /// </summary>
    [RelayCommand]
    private async Task NewFileAsync(FileTreeItemViewModel? parentFolder)
    {
        var targetPath = GetTargetDirectoryPath(parentFolder);
        if (targetPath == null) return;

        try
        {
            // Generate unique name
            var baseName = "untitled";
            var extension = ".txt";
            var name = baseName + extension;
            var counter = 1;

            while (File.Exists(Path.Combine(targetPath, name)))
            {
                name = $"{baseName}-{counter++}{extension}";
            }

            var filePath = Path.Combine(targetPath, name);
            var newItem = await _fileSystemService.CreateFileAsync(filePath);

            // Add to tree and start rename
            var viewModel = FileTreeItemViewModel.FromFileSystemItem(newItem, this);

            if (parentFolder != null)
            {
                await EnsureExpandedAsync(parentFolder);
                parentFolder.Children.Add(viewModel);
            }
            else
            {
                RootItems.Add(viewModel);
            }

            SelectedItem = viewModel;
            viewModel.BeginRename();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to create file");
            ErrorMessage = $"Failed to create file: {ex.Message}";
        }
    }

    /// <summary>
    /// Creates a new folder in the specified location.
    /// </summary>
    [RelayCommand]
    private async Task NewFolderAsync(FileTreeItemViewModel? parentFolder)
    {
        var targetPath = GetTargetDirectoryPath(parentFolder);
        if (targetPath == null) return;

        try
        {
            // Generate unique name
            var baseName = "New Folder";
            var name = baseName;
            var counter = 1;

            while (Directory.Exists(Path.Combine(targetPath, name)))
            {
                name = $"{baseName} {counter++}";
            }

            var folderPath = Path.Combine(targetPath, name);
            var newItem = await _fileSystemService.CreateDirectoryAsync(folderPath);

            // Add to tree and start rename
            var viewModel = FileTreeItemViewModel.FromFileSystemItem(newItem, this);

            if (parentFolder != null)
            {
                await EnsureExpandedAsync(parentFolder);
                // Insert folders before files
                var insertIndex = parentFolder.Children
                    .TakeWhile(c => c.IsDirectory)
                    .Count();
                parentFolder.Children.Insert(insertIndex, viewModel);
            }
            else
            {
                var insertIndex = RootItems
                    .TakeWhile(c => c.IsDirectory)
                    .Count();
                RootItems.Insert(insertIndex, viewModel);
            }

            SelectedItem = viewModel;
            viewModel.BeginRename();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to create folder");
            ErrorMessage = $"Failed to create folder: {ex.Message}";
        }
    }

    /// <summary>
    /// Starts rename mode for the selected item.
    /// </summary>
    [RelayCommand]
    private void Rename(FileTreeItemViewModel? item)
    {
        item ??= SelectedItem;
        item?.BeginRename();
    }

    /// <summary>
    /// Deletes the selected item with confirmation.
    /// </summary>
    [RelayCommand]
    private async Task DeleteAsync(FileTreeItemViewModel? item)
    {
        item ??= SelectedItem;
        if (item == null) return;

        // Confirmation is handled by the view via DeleteConfirmationRequested event
        await DeleteItemInternalAsync(item);
    }

    /// <summary>
    /// Actually deletes an item (called after confirmation).
    /// </summary>
    internal async Task DeleteItemInternalAsync(FileTreeItemViewModel item)
    {
        try
        {
            if (item.IsDirectory)
            {
                await _fileSystemService.DeleteDirectoryAsync(item.Path);
            }
            else
            {
                await _fileSystemService.DeleteFileAsync(item.Path);
            }

            // Remove from tree
            RemoveItemFromTree(item);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to delete {Path}", item.Path);
            ErrorMessage = $"Failed to delete: {ex.Message}";
        }
    }

    /// <summary>
    /// Renames an item (called from FileTreeItemViewModel).
    /// </summary>
    internal async Task RenameItemAsync(FileTreeItemViewModel item, string newName)
    {
        try
        {
            var renamed = await _fileSystemService.RenameAsync(item.Path, newName);
            item.Name = renamed.Name;
            item.Path = renamed.Path;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to rename {Path} to {NewName}", item.Path, newName);
            ErrorMessage = $"Failed to rename: {ex.Message}";
        }
    }

    #endregion

    #region Path Operations

    /// <summary>
    /// Copies the absolute path to clipboard.
    /// </summary>
    [RelayCommand]
    private async Task CopyPathAsync(FileTreeItemViewModel? item)
    {
        item ??= SelectedItem;
        if (item == null) return;

        var clipboard = Avalonia.Application.Current?.Clipboard;
        if (clipboard != null)
        {
            await clipboard.SetTextAsync(item.Path);
        }
    }

    /// <summary>
    /// Copies the relative path to clipboard.
    /// </summary>
    [RelayCommand]
    private async Task CopyRelativePathAsync(FileTreeItemViewModel? item)
    {
        item ??= SelectedItem;
        if (item == null || _workspaceService.CurrentWorkspace == null) return;

        var relativePath = _workspaceService.CurrentWorkspace.GetRelativePath(item.Path);

        var clipboard = Avalonia.Application.Current?.Clipboard;
        if (clipboard != null)
        {
            await clipboard.SetTextAsync(relativePath);
        }
    }

    /// <summary>
    /// Opens the item's location in the system file manager.
    /// </summary>
    [RelayCommand]
    private void RevealInFinder(FileTreeItemViewModel? item)
    {
        item ??= SelectedItem;
        if (item == null) return;

        var path = item.IsDirectory ? item.Path : Path.GetDirectoryName(item.Path);
        if (string.IsNullOrEmpty(path)) return;

        try
        {
            if (OperatingSystem.IsMacOS())
            {
                Process.Start("open", $"-R \"{item.Path}\"");
            }
            else if (OperatingSystem.IsWindows())
            {
                Process.Start("explorer.exe", $"/select,\"{item.Path}\"");
            }
            else if (OperatingSystem.IsLinux())
            {
                Process.Start("xdg-open", path);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to reveal in finder: {Path}", item.Path);
        }
    }

    #endregion

    #region Context Attachment

    /// <summary>
    /// Attaches the selected file to the chat context.
    /// </summary>
    [RelayCommand]
    private void AttachToContext(FileTreeItemViewModel? item)
    {
        item ??= SelectedItem;
        if (item == null || !item.IsFile) return;

        FileAttachRequested?.Invoke(this, new FileAttachRequestedEventArgs(item.Path));
    }

    #endregion

    #region Tree Loading

    private async Task LoadWorkspaceAsync(Workspace workspace)
    {
        IsLoading = true;
        ErrorMessage = null;

        try
        {
            HasWorkspace = true;
            WorkspaceName = workspace.DisplayName;
            WorkspacePath = workspace.RootPath;

            // Load ignore patterns
            _ignorePatterns = workspace.GitIgnorePatterns;

            // Load settings
            var settings = await _settingsService.GetSettingsAsync();

            // Load root contents
            var contents = await _fileSystemService.GetDirectoryContentsAsync(
                workspace.RootPath,
                includeHidden: settings.ShowHiddenFiles);

            // Filter by ignore patterns
            var filteredContents = contents
                .Where(item => !_fileSystemService.ShouldIgnore(
                    item.Path,
                    workspace.RootPath,
                    _ignorePatterns))
                .ToList();

            // Create ViewModels
            await Dispatcher.UIThread.InvokeAsync(() =>
            {
                RootItems.Clear();

                foreach (var item in filteredContents)
                {
                    var viewModel = FileTreeItemViewModel.FromFileSystemItem(item, this, depth: 0);
                    RootItems.Add(viewModel);
                }
            });

            // Restore expanded folders
            await RestoreExpandedFoldersAsync(workspace.ExpandedFolders);

            _logger.LogInformation("Loaded workspace: {Name} with {Count} root items",
                workspace.DisplayName, RootItems.Count);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to load workspace");
            ErrorMessage = $"Failed to load workspace: {ex.Message}";
        }
        finally
        {
            IsLoading = false;
        }
    }

    /// <summary>
    /// Loads children for a directory item.
    /// Called by FileTreeItemViewModel.
    /// </summary>
    internal async Task<IReadOnlyList<FileTreeItemViewModel>> LoadChildrenForItemAsync(
        FileTreeItemViewModel parent)
    {
        var settings = await _settingsService.GetSettingsAsync();

        var contents = await _fileSystemService.GetDirectoryContentsAsync(
            parent.Path,
            includeHidden: settings.ShowHiddenFiles);

        // Filter by ignore patterns
        var filteredContents = contents
            .Where(item => !_fileSystemService.ShouldIgnore(
                item.Path,
                _workspaceService.CurrentWorkspace?.RootPath ?? parent.Path,
                _ignorePatterns))
            .ToList();

        return filteredContents
            .Select(item => FileTreeItemViewModel.FromFileSystemItem(item, this, parent.Depth + 1))
            .ToList();
    }

    private async Task RestoreExpandedFoldersAsync(IReadOnlyList<string> expandedPaths)
    {
        if (expandedPaths.Count == 0 || _workspaceService.CurrentWorkspace == null)
            return;

        foreach (var relativePath in expandedPaths)
        {
            var absolutePath = _workspaceService.CurrentWorkspace.GetAbsolutePath(relativePath);
            var item = FindItemByPath(absolutePath);

            if (item != null && item.IsDirectory)
            {
                item.IsExpanded = true;
                await item.LoadChildrenAsync();
            }
        }
    }

    #endregion

    #region State Management

    /// <summary>
    /// Called when an item's expansion state changes.
    /// </summary>
    internal void OnItemExpansionChanged(FileTreeItemViewModel item)
    {
        if (_workspaceService.CurrentWorkspace == null)
            return;

        // Collect all expanded folder paths
        var expandedPaths = CollectExpandedPaths(RootItems)
            .Select(p => _workspaceService.CurrentWorkspace.GetRelativePath(p))
            .ToList();

        _workspaceService.UpdateExpandedFolders(expandedPaths);
    }

    private IEnumerable<string> CollectExpandedPaths(IEnumerable<FileTreeItemViewModel> items)
    {
        foreach (var item in items)
        {
            if (item.IsDirectory && item.IsExpanded)
            {
                yield return item.Path;

                foreach (var childPath in CollectExpandedPaths(item.Children))
                {
                    yield return childPath;
                }
            }
        }
    }

    #endregion

    #region Helper Methods

    private string? GetTargetDirectoryPath(FileTreeItemViewModel? item)
    {
        if (item == null)
        {
            return _workspaceService.CurrentWorkspace?.RootPath;
        }

        return item.IsDirectory ? item.Path : Path.GetDirectoryName(item.Path);
    }

    private async Task EnsureExpandedAsync(FileTreeItemViewModel folder)
    {
        if (!folder.IsExpanded)
        {
            folder.IsExpanded = true;
            await folder.LoadChildrenAsync();
        }
    }

    private FileTreeItemViewModel? FindItemByPath(string path)
    {
        return FindItemByPathRecursive(RootItems, path);
    }

    private FileTreeItemViewModel? FindItemByPathRecursive(
        IEnumerable<FileTreeItemViewModel> items,
        string path)
    {
        foreach (var item in items)
        {
            if (item.Path.Equals(path, StringComparison.OrdinalIgnoreCase))
                return item;

            if (item.IsDirectory && item.Children.Count > 0)
            {
                var found = FindItemByPathRecursive(item.Children, path);
                if (found != null)
                    return found;
            }
        }

        return null;
    }

    private void RemoveItemFromTree(FileTreeItemViewModel item)
    {
        // Try to remove from root
        if (RootItems.Remove(item))
            return;

        // Search in children
        RemoveItemFromTreeRecursive(RootItems, item);
    }

    private bool RemoveItemFromTreeRecursive(
        IEnumerable<FileTreeItemViewModel> items,
        FileTreeItemViewModel target)
    {
        foreach (var item in items)
        {
            if (item.Children.Remove(target))
                return true;

            if (RemoveItemFromTreeRecursive(item.Children, target))
                return true;
        }

        return false;
    }

    #endregion

    #region Event Handlers

    private async void OnWorkspaceChanged(object? sender, WorkspaceChangedEventArgs e)
    {
        await Dispatcher.UIThread.InvokeAsync(async () =>
        {
            if (e.ChangeType == WorkspaceChangeType.Closed)
            {
                HasWorkspace = false;
                WorkspaceName = string.Empty;
                WorkspacePath = string.Empty;
                RootItems.Clear();
                SearchFilter = string.Empty;
            }
            else if (e.CurrentWorkspace != null)
            {
                await LoadWorkspaceAsync(e.CurrentWorkspace);
            }
        });
    }

    #endregion

    #region IDisposable

    public void Dispose()
    {
        _filterDebounceTimer.Dispose();
        _workspaceService.WorkspaceChanged -= OnWorkspaceChanged;
    }

    #endregion
}

#region Event Args

public sealed class FileOpenRequestedEventArgs : EventArgs
{
    public string FilePath { get; }

    public FileOpenRequestedEventArgs(string filePath)
    {
        FilePath = filePath;
    }
}

public sealed class FileAttachRequestedEventArgs : EventArgs
{
    public string FilePath { get; }

    public FileAttachRequestedEventArgs(string filePath)
    {
        FilePath = filePath;
    }
}

#endregion
```

### Files to Create (v0.3.2b)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/ViewModels/FileExplorerViewModel.cs` | Main explorer ViewModel |

---

## v0.3.2c: File Icon System

### Objective
Create a comprehensive file icon system with SVG path data for common file types.

### FileIconProvider Implementation

```csharp
// src/SeniorIntern.Desktop/Services/FileIconProvider.cs
namespace SeniorIntern.Desktop.Services;

/// <summary>
/// Provides icon keys and SVG path data for file types.
/// </summary>
public static class FileIconProvider
{
    /// <summary>
    /// Maps icon keys to SVG path data.
    /// Icons are designed for 24x24 viewBox.
    /// </summary>
    private static readonly Dictionary<string, string> IconPaths = new()
    {
        // Folders
        ["folder"] = "M10 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2h-8l-2-2z",
        ["folder-open"] = "M20 6h-8l-2-2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm0 12H4V8h16v10z",

        // Generic files
        ["file"] = "M14 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V8l-6-6zm4 18H6V4h7v5h5v11z",
        ["file-code"] = "M14 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V8l-6-6zm4 18H6V4h7v5h5v11zM9.5 13.5L7 16l2.5 2.5 1-1L8.5 16l2-1.5-1-1zm5.5 5L17.5 16 15 13.5l-1 1 2 1.5-2 1.5 1 1z",
        ["file-text"] = "M14 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V8l-6-6zm4 18H6V4h7v5h5v11zM8 12h8v2H8v-2zm0 4h8v2H8v-2z",

        // Programming languages - C#/.NET
        ["file-csharp"] = "M14 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V8l-6-6zm4 18H6V4h7v5h5v11zM11.5 13h-1v-1h-1v1h-1v1h1v1h1v-1h1v2h-3v-1h-1v-3h1v-1h3v1zm4 0h-1v-1h-1v1h-1v1h1v1h1v-1h1v2h-3v-1h-1v-3h1v-1h3v1z",

        // JavaScript/TypeScript
        ["file-javascript"] = "M14 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V8l-6-6zm4 18H6V4h7v5h5v11zM9 18v-1.5c0-.8-.7-1.5-1.5-1.5s-1.5.7-1.5 1.5V18h-1v-1.5C5 15.1 6.1 14 7.5 14s2.5 1.1 2.5 2.5V18H9zm5-3.5c0 .8-.7 1.5-1.5 1.5H11v1.5h2V19h-3v-3h1.5c.8 0 1.5-.7 1.5-1.5V14h1v.5z",
        ["file-typescript"] = "M14 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V8l-6-6zm4 18H6V4h7v5h5v11zM8 14h4v1H10.5v4h-1v-4H8v-1zm6.5 0H18v1h-1.5v4h-1v-4h-1v-1z",

        // Python
        ["file-python"] = "M14 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.89 2-2V8l-6-6zm4 18H6V4h7v5h5v11zM12.5 12c-.83 0-1.5.67-1.5 1.5v1c0 .83.67 1.5 1.5 1.5h1c.28 0 .5.22.5.5v.5h-2.5v1h2.5c.83 0 1.5-.67 1.5-1.5v-1c0-.83-.67-1.5-1.5-1.5h-1c-.28 0-.5-.22-.5-.5v-.5h2.5v-1h-2.5z",

        // Web files
        ["file-html"] = "M14 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.89 2-2V8l-6-6zm4 18H6V4h7v5h5v11zM8 12l-2 4 2 4h1.5l-2-4 2-4H8zm6.5 0l2 4-2 4H16l2-4-2-4h-1.5z",
        ["file-css"] = "M14 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.89 2-2V8l-6-6zm4 18H6V4h7v5h5v11zM10 14v4c0 .55-.45 1-1 1H7v-1h2v-1H7v-1h2v-1H7v-1h2c.55 0 1 .45 1 1zm6-1h-3v1h2v1h-2v1h2v1h-3v-4c0-.55.45-1 1-1h2c.55 0 1 .45 1 1v1z",

        // Data files
        ["file-json"] = "M14 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.89 2-2V8l-6-6zm4 18H6V4h7v5h5v11zM8 12v1.5c0 .28-.22.5-.5.5H7v1h.5c.28 0 .5.22.5.5V17c0 .55.45 1 1 1h1v-1H9v-1.5c0-.55-.45-1-1-1 .55 0 1-.45 1-1V12c0-.55-.45-1-1-1H7v1h1zm8 5c0 .55-.45 1-1 1h-1v-1h1v-1.5c0-.55.45-1 1-1-.55 0-1-.45-1-1V12h1v1h1c.55 0 1 .45 1 1v1.5c0 .28-.22.5-.5.5h-.5v1h.5c.28 0 .5.22.5.5V17z",
        ["file-xml"] = "M14 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.89 2-2V8l-6-6zm4 18H6V4h7v5h5v11zM8 12l-1.5 3 1.5 3H9l-1.5-3L9 12H8zm5 0l1.5 3-1.5 3h1l1.5-3-1.5-3h-1z",
        ["file-yaml"] = "M14 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.89 2-2V8l-6-6zm4 18H6V4h7v5h5v11zM8 13l1.5 2.5V18h1v-2.5L12 13h-1l-1 1.5-1-1.5H8z",

        // Markdown
        ["file-markdown"] = "M14 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.89 2-2V8l-6-6zm4 18H6V4h7v5h5v11zM6.5 17.5v-5h1.5l1.5 2 1.5-2h1.5v5h-1.5v-2.5l-1.5 2-1.5-2v2.5h-1.5zm9-5v3.5l1.5-1.5v1l-2.5 2-2.5-2v-1l1.5 1.5v-3.5h2z",

        // Images
        ["file-image"] = "M14 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.89 2-2V8l-6-6zm4 18H6V4h7v5h5v11zm-5-7c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm-4.5 5.5l1.5-2 1.5 2.5 2-3 2.5 3H7.5z",

        // Git
        ["file-git"] = "M14 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.89 2-2V8l-6-6zm4 18H6V4h7v5h5v11zm-6-6c-1.1 0-2 .9-2 2 0 .74.4 1.38 1 1.73v1.27h2v-1.27c.6-.35 1-.99 1-1.73 0-1.1-.9-2-2-2z",

        // Config
        ["file-config"] = "M14 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.89 2-2V8l-6-6zm4 18H6V4h7v5h5v11zM12 12c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3zm0 4.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z",

        // Database
        ["file-database"] = "M14 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.89 2-2V8l-6-6zm4 18H6V4h7v5h5v11zM12 11c-2.21 0-4 .9-4 2v4c0 1.1 1.79 2 4 2s4-.9 4-2v-4c0-1.1-1.79-2-4-2zm0 6c-1.66 0-3-.45-3-1v-1.2c.66.45 1.78.7 3 .7s2.34-.25 3-.7V16c0 .55-1.34 1-3 1z",

        // Shell
        ["file-shell"] = "M14 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.89 2-2V8l-6-6zm4 18H6V4h7v5h5v11zM8 14l3 2-3 2v-1l1.5-1L8 15v-1zm4 3h4v1h-4v-1z",

        // Rust
        ["file-rust"] = "M14 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.89 2-2V8l-6-6zm4 18H6V4h7v5h5v11zM12 12c-1.93 0-3.5 1.57-3.5 3.5S10.07 19 12 19c.17 0 .34-.01.5-.04V17.4c-.16.04-.33.06-.5.06-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2v.5h1.5v-.5c0-1.93-1.57-3.5-3.5-3.5z",

        // Go
        ["file-go"] = "M14 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.89 2-2V8l-6-6zm4 18H6V4h7v5h5v11zM12 12c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm1 5.5h-2v-1h2v1zm0-2h-2v-2h2v2z",

        // Java
        ["file-java"] = "M14 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.89 2-2V8l-6-6zm4 18H6V4h7v5h5v11zM10 18v-1c0-.83.67-1.5 1.5-1.5h1c.28 0 .5-.22.5-.5V14h1v1c0 .83-.67 1.5-1.5 1.5h-1c-.28 0-.5.22-.5.5V18h-1z",
    };

    /// <summary>
    /// Maps file extensions to icon keys.
    /// </summary>
    private static readonly Dictionary<string, string> ExtensionIconMap = new(StringComparer.OrdinalIgnoreCase)
    {
        // C# / .NET
        [".cs"] = "file-csharp",
        [".csx"] = "file-csharp",
        [".vb"] = "file-code",
        [".fs"] = "file-code",
        [".fsx"] = "file-code",
        [".csproj"] = "file-xml",
        [".fsproj"] = "file-xml",
        [".vbproj"] = "file-xml",
        [".sln"] = "file-config",
        [".props"] = "file-xml",
        [".targets"] = "file-xml",

        // Avalonia / XAML
        [".axaml"] = "file-xml",
        [".xaml"] = "file-xml",

        // JavaScript / TypeScript
        [".js"] = "file-javascript",
        [".mjs"] = "file-javascript",
        [".cjs"] = "file-javascript",
        [".jsx"] = "file-javascript",
        [".ts"] = "file-typescript",
        [".mts"] = "file-typescript",
        [".cts"] = "file-typescript",
        [".tsx"] = "file-typescript",

        // Python
        [".py"] = "file-python",
        [".pyi"] = "file-python",
        [".pyw"] = "file-python",

        // Web
        [".html"] = "file-html",
        [".htm"] = "file-html",
        [".css"] = "file-css",
        [".scss"] = "file-css",
        [".sass"] = "file-css",
        [".less"] = "file-css",

        // Data / Config
        [".json"] = "file-json",
        [".jsonc"] = "file-json",
        [".xml"] = "file-xml",
        [".yaml"] = "file-yaml",
        [".yml"] = "file-yaml",
        [".toml"] = "file-config",
        [".ini"] = "file-config",
        [".cfg"] = "file-config",
        [".conf"] = "file-config",
        [".env"] = "file-config",

        // Markdown
        [".md"] = "file-markdown",
        [".mdx"] = "file-markdown",
        [".markdown"] = "file-markdown",

        // Images
        [".png"] = "file-image",
        [".jpg"] = "file-image",
        [".jpeg"] = "file-image",
        [".gif"] = "file-image",
        [".svg"] = "file-image",
        [".ico"] = "file-image",
        [".webp"] = "file-image",

        // Git
        [".gitignore"] = "file-git",
        [".gitattributes"] = "file-git",
        [".gitmodules"] = "file-git",

        // Shell
        [".sh"] = "file-shell",
        [".bash"] = "file-shell",
        [".zsh"] = "file-shell",
        [".ps1"] = "file-shell",
        [".bat"] = "file-shell",
        [".cmd"] = "file-shell",

        // Database
        [".sql"] = "file-database",
        [".db"] = "file-database",
        [".sqlite"] = "file-database",

        // Rust / Go / Java
        [".rs"] = "file-rust",
        [".go"] = "file-go",
        [".java"] = "file-java",
        [".kt"] = "file-java",
    };

    /// <summary>
    /// Gets the icon key for a file extension.
    /// </summary>
    public static string GetIconKeyForExtension(string extension)
    {
        if (string.IsNullOrEmpty(extension))
            return "file";

        return ExtensionIconMap.TryGetValue(extension, out var key)
            ? key
            : "file-code";
    }

    /// <summary>
    /// Gets the icon key for a file name (handles special files).
    /// </summary>
    public static string GetIconKeyForFileName(string fileName)
    {
        // Check special file names
        return fileName.ToLowerInvariant() switch
        {
            "dockerfile" => "file-config",
            "docker-compose.yml" or "docker-compose.yaml" => "file-config",
            "makefile" => "file-shell",
            "rakefile" => "file-code",
            "gemfile" => "file-code",
            "package.json" => "file-json",
            "tsconfig.json" => "file-json",
            ".editorconfig" => "file-config",
            ".prettierrc" => "file-config",
            ".eslintrc" => "file-config",
            "license" or "license.md" or "license.txt" => "file-text",
            "readme" or "readme.md" or "readme.txt" => "file-markdown",
            _ => GetIconKeyForExtension(Path.GetExtension(fileName))
        };
    }

    /// <summary>
    /// Gets the SVG path data for an icon key.
    /// </summary>
    public static string GetIconPath(string iconKey)
    {
        return IconPaths.TryGetValue(iconKey, out var path)
            ? path
            : IconPaths["file"];
    }

    /// <summary>
    /// Gets all available icon keys.
    /// </summary>
    public static IReadOnlyCollection<string> GetAllIconKeys()
        => IconPaths.Keys;
}
```

### FileIconConverter Implementation

```csharp
// src/SeniorIntern.Desktop/Converters/FileIconConverter.cs
namespace SeniorIntern.Desktop.Converters;

using Avalonia.Data.Converters;
using Avalonia.Media;
using SeniorIntern.Desktop.Services;
using System.Globalization;

/// <summary>
/// Converts an icon key to a StreamGeometry for PathIcon.
/// </summary>
public class FileIconConverter : IValueConverter
{
    public static FileIconConverter Instance { get; } = new();

    public object? Convert(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        var iconKey = value as string ?? "file";
        var pathData = FileIconProvider.GetIconPath(iconKey);

        return StreamGeometry.Parse(pathData);
    }

    public object? ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        throw new NotSupportedException();
    }
}
```

### Icon Resources XAML

```xml
<!-- src/SeniorIntern.Desktop/Assets/FileIcons.axaml -->
<ResourceDictionary xmlns="https://github.com/avaloniaui"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
                    xmlns:converters="using:SeniorIntern.Desktop.Converters">

    <!-- Icon Converter -->
    <converters:FileIconConverter x:Key="FileIconConverter" />

    <!-- Icon Colors -->
    <SolidColorBrush x:Key="FolderIconBrush" Color="#E8A838" />
    <SolidColorBrush x:Key="FileIconBrush" Color="#8B8B8B" />
    <SolidColorBrush x:Key="CSharpIconBrush" Color="#68217A" />
    <SolidColorBrush x:Key="JavaScriptIconBrush" Color="#F7DF1E" />
    <SolidColorBrush x:Key="TypeScriptIconBrush" Color="#3178C6" />
    <SolidColorBrush x:Key="PythonIconBrush" Color="#3776AB" />
    <SolidColorBrush x:Key="JsonIconBrush" Color="#CBB078" />
    <SolidColorBrush x:Key="MarkdownIconBrush" Color="#083FA1" />
    <SolidColorBrush x:Key="HtmlIconBrush" Color="#E34F26" />
    <SolidColorBrush x:Key="CssIconBrush" Color="#1572B6" />
    <SolidColorBrush x:Key="GitIconBrush" Color="#F05032" />

    <!-- Static icon geometries for common use -->
    <StreamGeometry x:Key="FolderIcon">M10 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2h-8l-2-2z</StreamGeometry>
    <StreamGeometry x:Key="FolderOpenIcon">M20 6h-8l-2-2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm0 12H4V8h16v10z</StreamGeometry>
    <StreamGeometry x:Key="FileIcon">M14 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V8l-6-6zm4 18H6V4h7v5h5v11z</StreamGeometry>
    <StreamGeometry x:Key="NewFileIcon">M14 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V8l-6-6zm2 14h-3v3h-2v-3H8v-2h3v-3h2v3h3v2z</StreamGeometry>
    <StreamGeometry x:Key="NewFolderIcon">M20 6h-8l-2-2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm-3 9h-2v2h-2v-2H11v-2h2v-2h2v2h2v2z</StreamGeometry>
    <StreamGeometry x:Key="RefreshIcon">M17.65 6.35A7.958 7.958 0 0012 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08A5.99 5.99 0 0112 18c-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z</StreamGeometry>
    <StreamGeometry x:Key="CloseIcon">M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z</StreamGeometry>
    <StreamGeometry x:Key="AttachIcon">M16.5 6v11.5c0 2.21-1.79 4-4 4s-4-1.79-4-4V5c0-1.38 1.12-2.5 2.5-2.5s2.5 1.12 2.5 2.5v10.5c0 .55-.45 1-1 1s-1-.45-1-1V6H10v9.5c0 1.38 1.12 2.5 2.5 2.5s2.5-1.12 2.5-2.5V5c0-2.21-1.79-4-4-4S7 2.79 7 5v12.5c0 3.04 2.46 5.5 5.5 5.5s5.5-2.46 5.5-5.5V6h-1.5z</StreamGeometry>
    <StreamGeometry x:Key="DeleteIcon">M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z</StreamGeometry>
    <StreamGeometry x:Key="RenameIcon">M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04a.996.996 0 000-1.41l-2.34-2.34a.996.996 0 00-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z</StreamGeometry>
    <StreamGeometry x:Key="CopyIcon">M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z</StreamGeometry>
    <StreamGeometry x:Key="SearchIcon">M15.5 14h-.79l-.28-.27A6.471 6.471 0 0016 9.5 6.5 6.5 0 109.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z</StreamGeometry>
    <StreamGeometry x:Key="ClearIcon">M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z</StreamGeometry>
    <StreamGeometry x:Key="ChevronRightIcon">M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z</StreamGeometry>
    <StreamGeometry x:Key="ChevronDownIcon">M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z</StreamGeometry>

</ResourceDictionary>
```

### Files to Create (v0.3.2c)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/Services/FileIconProvider.cs` | Icon key/path provider |
| `src/SeniorIntern.Desktop/Converters/FileIconConverter.cs` | Icon converter for bindings |
| `src/SeniorIntern.Desktop/Assets/FileIcons.axaml` | Icon resources |

---

## v0.3.2d: Tree View UI

### Objective
Create the main file explorer view with tree view, templates, and empty states.

### FileExplorerView.axaml

```xml
<!-- src/SeniorIntern.Desktop/Views/FileExplorerView.axaml -->
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:vm="using:SeniorIntern.Desktop.ViewModels"
             xmlns:converters="using:SeniorIntern.Desktop.Converters"
             x:Class="SeniorIntern.Desktop.Views.FileExplorerView"
             x:DataType="vm:FileExplorerViewModel">

    <UserControl.Resources>
        <converters:FileIconConverter x:Key="FileIconConverter" />
    </UserControl.Resources>

    <UserControl.Styles>
        <!-- Tree item styles -->
        <Style Selector="TreeViewItem">
            <Setter Property="IsExpanded" Value="{Binding IsExpanded, Mode=TwoWay}" />
            <Setter Property="IsVisible" Value="{Binding IsVisible}" />
        </Style>

        <!-- Icon button style -->
        <Style Selector="Button.icon-button">
            <Setter Property="Background" Value="Transparent" />
            <Setter Property="BorderThickness" Value="0" />
            <Setter Property="Padding" Value="4" />
            <Setter Property="Width" Value="28" />
            <Setter Property="Height" Value="28" />
        </Style>
        <Style Selector="Button.icon-button:pointerover">
            <Setter Property="Background" Value="{DynamicResource SystemControlHighlightListLowBrush}" />
        </Style>

        <!-- Highlighted item style -->
        <Style Selector="TreeViewItem:selected TextBlock.item-name">
            <Setter Property="FontWeight" Value="SemiBold" />
        </Style>
        <Style Selector="TextBlock.highlighted">
            <Setter Property="Background" Value="{DynamicResource SystemAccentColorLight2}" />
        </Style>

        <!-- Loading indicator style -->
        <Style Selector="ProgressBar.tree-loading">
            <Setter Property="IsIndeterminate" Value="True" />
            <Setter Property="Height" Value="2" />
            <Setter Property="Margin" Value="16,4" />
        </Style>
    </UserControl.Styles>

    <Grid RowDefinitions="Auto,Auto,Auto,*">

        <!-- Header with workspace name and actions -->
        <Border Grid.Row="0"
                Background="{DynamicResource SystemControlBackgroundChromeMediumBrush}"
                Padding="12,8">
            <Grid ColumnDefinitions="*,Auto,Auto,Auto">
                <!-- Workspace name or "Explorer" -->
                <TextBlock Grid.Column="0"
                           Text="{Binding WorkspaceName, FallbackValue='Explorer'}"
                           FontWeight="SemiBold"
                           VerticalAlignment="Center"
                           TextTrimming="CharacterEllipsis"
                           ToolTip.Tip="{Binding WorkspacePath}" />

                <!-- New File button -->
                <Button Grid.Column="1"
                        Command="{Binding NewFileCommand}"
                        CommandParameter="{Binding SelectedItem}"
                        ToolTip.Tip="New File (Ctrl+N)"
                        Classes="icon-button"
                        IsVisible="{Binding HasWorkspace}">
                    <PathIcon Data="{StaticResource NewFileIcon}"
                              Width="16" Height="16" />
                </Button>

                <!-- New Folder button -->
                <Button Grid.Column="2"
                        Command="{Binding NewFolderCommand}"
                        CommandParameter="{Binding SelectedItem}"
                        ToolTip.Tip="New Folder (Ctrl+Shift+N)"
                        Classes="icon-button"
                        IsVisible="{Binding HasWorkspace}">
                    <PathIcon Data="{StaticResource NewFolderIcon}"
                              Width="16" Height="16" />
                </Button>

                <!-- Refresh button -->
                <Button Grid.Column="3"
                        Command="{Binding RefreshCommand}"
                        ToolTip.Tip="Refresh (Ctrl+R)"
                        Classes="icon-button"
                        IsVisible="{Binding HasWorkspace}">
                    <PathIcon Data="{StaticResource RefreshIcon}"
                              Width="16" Height="16" />
                </Button>
            </Grid>
        </Border>

        <!-- Search/Filter box -->
        <Border Grid.Row="1"
                Padding="8,4"
                IsVisible="{Binding HasWorkspace}">
            <Grid ColumnDefinitions="*,Auto">
                <TextBox Grid.Column="0"
                         Text="{Binding SearchFilter, Mode=TwoWay}"
                         Watermark="Filter files..."
                         x:Name="FilterTextBox">
                    <TextBox.InnerLeftContent>
                        <PathIcon Data="{StaticResource SearchIcon}"
                                  Width="14" Height="14"
                                  Margin="8,0,4,0"
                                  Foreground="{DynamicResource SystemBaseMediumColor}" />
                    </TextBox.InnerLeftContent>
                </TextBox>
                <Button Grid.Column="1"
                        Command="{Binding ClearFilterCommand}"
                        IsVisible="{Binding SearchFilter.Length}"
                        Classes="icon-button"
                        Margin="4,0,0,0">
                    <PathIcon Data="{StaticResource ClearIcon}"
                              Width="12" Height="12" />
                </Button>
            </Grid>
        </Border>

        <!-- Loading indicator -->
        <ProgressBar Grid.Row="2"
                     Classes="tree-loading"
                     IsVisible="{Binding IsLoading}" />

        <!-- Tree View -->
        <TreeView Grid.Row="3"
                  x:Name="FileTree"
                  ItemsSource="{Binding RootItems}"
                  SelectedItem="{Binding SelectedItem, Mode=TwoWay}"
                  IsVisible="{Binding HasWorkspace}"
                  SelectionMode="Single"
                  DoubleTapped="OnTreeViewDoubleTapped"
                  KeyDown="OnTreeViewKeyDown">

            <TreeView.ItemTemplate>
                <TreeDataTemplate ItemsSource="{Binding Children}">
                    <Grid ColumnDefinitions="Auto,*,Auto"
                          Background="Transparent"
                          ToolTip.Tip="{Binding Path}">

                        <!-- Expander arrow (for directories) -->
                        <Panel Grid.Column="0"
                               Width="16"
                               IsVisible="{Binding ShowExpander}">
                            <PathIcon Data="{StaticResource ChevronRightIcon}"
                                      Width="12" Height="12"
                                      IsVisible="{Binding !IsExpanded}" />
                            <PathIcon Data="{StaticResource ChevronDownIcon}"
                                      Width="12" Height="12"
                                      IsVisible="{Binding IsExpanded}" />
                        </Panel>

                        <!-- File/Folder Icon -->
                        <PathIcon Grid.Column="0"
                                  Data="{Binding IconKey, Converter={StaticResource FileIconConverter}}"
                                  Width="16" Height="16"
                                  Margin="0,0,6,0"
                                  IsVisible="{Binding !ShowExpander}">
                            <PathIcon.Foreground>
                                <MultiBinding Converter="{x:Static converters:IconColorConverter.Instance}">
                                    <Binding Path="IconKey" />
                                    <Binding Path="IsDirectory" />
                                </MultiBinding>
                            </PathIcon.Foreground>
                        </PathIcon>

                        <!-- Loading spinner (for expanding directories) -->
                        <ProgressBar Grid.Column="0"
                                     IsIndeterminate="True"
                                     Width="16" Height="16"
                                     IsVisible="{Binding IsLoading}"
                                     Classes="circular" />

                        <!-- Name display (normal mode) -->
                        <TextBlock Grid.Column="1"
                                   Text="{Binding Name}"
                                   Classes="item-name"
                                   Classes.highlighted="{Binding IsHighlighted}"
                                   IsVisible="{Binding !IsRenaming}"
                                   VerticalAlignment="Center"
                                   TextTrimming="CharacterEllipsis" />

                        <!-- Name editor (rename mode) -->
                        <TextBox Grid.Column="1"
                                 Text="{Binding EditingName, Mode=TwoWay}"
                                 IsVisible="{Binding IsRenaming}"
                                 x:Name="RenameTextBox"
                                 KeyDown="OnRenameKeyDown"
                                 LostFocus="OnRenameLostFocus"
                                 Padding="2"
                                 MinWidth="100" />

                        <!-- Modified indicator -->
                        <Ellipse Grid.Column="2"
                                 Width="8" Height="8"
                                 Fill="{DynamicResource SystemAccentColor}"
                                 IsVisible="{Binding IsModified}"
                                 Margin="6,0,0,0"
                                 ToolTip.Tip="Unsaved changes" />
                    </Grid>
                </TreeDataTemplate>
            </TreeView.ItemTemplate>

            <!-- Context Menu -->
            <TreeView.ContextMenu>
                <ContextMenu>
                    <!-- File-only operations -->
                    <MenuItem Header="Open"
                              Command="{Binding OpenFileCommand}"
                              CommandParameter="{Binding SelectedItem}"
                              IsVisible="{Binding SelectedItem.IsFile}"
                              InputGesture="Enter">
                        <MenuItem.Icon>
                            <PathIcon Data="{StaticResource FileIcon}" Width="16" Height="16" />
                        </MenuItem.Icon>
                    </MenuItem>

                    <MenuItem Header="Attach to Chat"
                              Command="{Binding AttachToContextCommand}"
                              CommandParameter="{Binding SelectedItem}"
                              IsVisible="{Binding SelectedItem.IsFile}">
                        <MenuItem.Icon>
                            <PathIcon Data="{StaticResource AttachIcon}" Width="16" Height="16" />
                        </MenuItem.Icon>
                    </MenuItem>

                    <Separator IsVisible="{Binding SelectedItem.IsFile}" />

                    <!-- Create operations -->
                    <MenuItem Header="New File"
                              Command="{Binding NewFileCommand}"
                              CommandParameter="{Binding SelectedItem}"
                              InputGesture="Ctrl+N">
                        <MenuItem.Icon>
                            <PathIcon Data="{StaticResource NewFileIcon}" Width="16" Height="16" />
                        </MenuItem.Icon>
                    </MenuItem>

                    <MenuItem Header="New Folder"
                              Command="{Binding NewFolderCommand}"
                              CommandParameter="{Binding SelectedItem}"
                              InputGesture="Ctrl+Shift+N">
                        <MenuItem.Icon>
                            <PathIcon Data="{StaticResource NewFolderIcon}" Width="16" Height="16" />
                        </MenuItem.Icon>
                    </MenuItem>

                    <Separator />

                    <!-- Edit operations -->
                    <MenuItem Header="Rename"
                              Command="{Binding RenameCommand}"
                              CommandParameter="{Binding SelectedItem}"
                              InputGesture="F2">
                        <MenuItem.Icon>
                            <PathIcon Data="{StaticResource RenameIcon}" Width="16" Height="16" />
                        </MenuItem.Icon>
                    </MenuItem>

                    <MenuItem Header="Delete"
                              Command="{Binding DeleteCommand}"
                              CommandParameter="{Binding SelectedItem}"
                              InputGesture="Delete">
                        <MenuItem.Icon>
                            <PathIcon Data="{StaticResource DeleteIcon}" Width="16" Height="16" />
                        </MenuItem.Icon>
                    </MenuItem>

                    <Separator />

                    <!-- Path operations -->
                    <MenuItem Header="Copy Path"
                              Command="{Binding CopyPathCommand}"
                              CommandParameter="{Binding SelectedItem}"
                              InputGesture="Ctrl+C">
                        <MenuItem.Icon>
                            <PathIcon Data="{StaticResource CopyIcon}" Width="16" Height="16" />
                        </MenuItem.Icon>
                    </MenuItem>

                    <MenuItem Header="Copy Relative Path"
                              Command="{Binding CopyRelativePathCommand}"
                              CommandParameter="{Binding SelectedItem}"
                              InputGesture="Ctrl+Shift+C" />

                    <MenuItem Header="Reveal in File Manager"
                              Command="{Binding RevealInFinderCommand}"
                              CommandParameter="{Binding SelectedItem}" />
                </ContextMenu>
            </TreeView.ContextMenu>
        </TreeView>

        <!-- Empty state: No workspace -->
        <StackPanel Grid.Row="3"
                    IsVisible="{Binding !HasWorkspace}"
                    HorizontalAlignment="Center"
                    VerticalAlignment="Center"
                    Spacing="16">
            <PathIcon Data="{StaticResource FolderIcon}"
                      Width="48" Height="48"
                      Foreground="{DynamicResource SystemBaseMediumColor}" />
            <TextBlock Text="No folder opened"
                       HorizontalAlignment="Center"
                       Foreground="{DynamicResource SystemBaseMediumColor}" />
            <Button Command="{Binding OpenWorkspaceCommand}"
                    Content="Open Folder"
                    HorizontalAlignment="Center"
                    Classes="accent" />
        </StackPanel>

        <!-- Error message -->
        <Border Grid.Row="3"
                IsVisible="{Binding ErrorMessage, Converter={x:Static StringConverters.IsNotNullOrEmpty}}"
                Background="{DynamicResource SystemErrorBackgroundBrush}"
                Padding="12"
                Margin="8"
                CornerRadius="4"
                VerticalAlignment="Bottom">
            <Grid ColumnDefinitions="*,Auto">
                <TextBlock Grid.Column="0"
                           Text="{Binding ErrorMessage}"
                           TextWrapping="Wrap"
                           Foreground="{DynamicResource SystemErrorTextBrush}" />
                <Button Grid.Column="1"
                        Content="Dismiss"
                        Command="{Binding ClearErrorCommand}"
                        Classes="link-button"
                        Margin="8,0,0,0" />
            </Grid>
        </Border>
    </Grid>
</UserControl>
```

### FileExplorerView.axaml.cs

```csharp
// src/SeniorIntern.Desktop/Views/FileExplorerView.axaml.cs
namespace SeniorIntern.Desktop.Views;

using Avalonia.Controls;
using Avalonia.Input;
using Avalonia.Interactivity;
using SeniorIntern.Desktop.ViewModels;

public partial class FileExplorerView : UserControl
{
    public FileExplorerView()
    {
        InitializeComponent();
    }

    private FileExplorerViewModel? ViewModel => DataContext as FileExplorerViewModel;

    #region Tree View Events

    private void OnTreeViewDoubleTapped(object? sender, TappedEventArgs e)
    {
        if (ViewModel?.SelectedItem == null)
            return;

        var item = ViewModel.SelectedItem;

        if (item.IsFile)
        {
            ViewModel.OpenFileCommand.Execute(item);
        }
        else if (item.IsDirectory)
        {
            item.IsExpanded = !item.IsExpanded;
        }
    }

    private void OnTreeViewKeyDown(object? sender, KeyEventArgs e)
    {
        if (ViewModel?.SelectedItem == null)
            return;

        var item = ViewModel.SelectedItem;

        switch (e.Key)
        {
            case Key.Enter:
                if (item.IsFile)
                {
                    ViewModel.OpenFileCommand.Execute(item);
                }
                else
                {
                    item.IsExpanded = !item.IsExpanded;
                }
                e.Handled = true;
                break;

            case Key.F2:
                item.BeginRename();
                e.Handled = true;
                break;

            case Key.Delete:
                _ = ConfirmAndDeleteAsync(item);
                e.Handled = true;
                break;

            case Key.Right:
                if (item.IsDirectory && !item.IsExpanded)
                {
                    item.IsExpanded = true;
                    e.Handled = true;
                }
                break;

            case Key.Left:
                if (item.IsDirectory && item.IsExpanded)
                {
                    item.IsExpanded = false;
                    e.Handled = true;
                }
                break;

            case Key.C when e.KeyModifiers.HasFlag(KeyModifiers.Control):
                if (e.KeyModifiers.HasFlag(KeyModifiers.Shift))
                {
                    ViewModel.CopyRelativePathCommand.Execute(item);
                }
                else
                {
                    ViewModel.CopyPathCommand.Execute(item);
                }
                e.Handled = true;
                break;

            case Key.N when e.KeyModifiers.HasFlag(KeyModifiers.Control):
                if (e.KeyModifiers.HasFlag(KeyModifiers.Shift))
                {
                    ViewModel.NewFolderCommand.Execute(item);
                }
                else
                {
                    ViewModel.NewFileCommand.Execute(item);
                }
                e.Handled = true;
                break;

            case Key.R when e.KeyModifiers.HasFlag(KeyModifiers.Control):
                ViewModel.RefreshCommand.Execute(null);
                e.Handled = true;
                break;
        }
    }

    #endregion

    #region Rename Events

    private void OnRenameKeyDown(object? sender, KeyEventArgs e)
    {
        if (sender is not TextBox textBox)
            return;

        var item = textBox.DataContext as FileTreeItemViewModel;
        if (item == null)
            return;

        switch (e.Key)
        {
            case Key.Enter:
                item.CommitRenameCommand.Execute(null);
                e.Handled = true;
                break;

            case Key.Escape:
                item.CancelRenameCommand.Execute(null);
                e.Handled = true;
                break;
        }
    }

    private void OnRenameLostFocus(object? sender, RoutedEventArgs e)
    {
        if (sender is not TextBox textBox)
            return;

        var item = textBox.DataContext as FileTreeItemViewModel;
        if (item?.IsRenaming == true)
        {
            item.CommitRenameCommand.Execute(null);
        }
    }

    #endregion

    #region Delete Confirmation

    private async Task ConfirmAndDeleteAsync(FileTreeItemViewModel item)
    {
        if (ViewModel == null)
            return;

        var itemType = item.IsDirectory ? "folder" : "file";
        var message = item.IsDirectory
            ? $"Are you sure you want to delete '{item.Name}' and all its contents?"
            : $"Are you sure you want to delete '{item.Name}'?";

        // Show confirmation dialog
        var window = TopLevel.GetTopLevel(this) as Window;
        if (window == null)
            return;

        var dialog = new ContentDialog
        {
            Title = $"Delete {itemType}",
            Content = message,
            PrimaryButtonText = "Delete",
            CloseButtonText = "Cancel",
            DefaultButton = ContentDialogButton.Close
        };

        var result = await dialog.ShowAsync(window);

        if (result == ContentDialogResult.Primary)
        {
            await ViewModel.DeleteItemInternalAsync(item);
        }
    }

    #endregion

    #region Focus Management

    protected override void OnLoaded(RoutedEventArgs e)
    {
        base.OnLoaded(e);

        // Focus rename textbox when item enters rename mode
        if (DataContext is FileExplorerViewModel vm)
        {
            // This could be enhanced with proper focus management
        }
    }

    #endregion
}
```

### Files to Create (v0.3.2d)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/Views/FileExplorerView.axaml` | Explorer UI |
| `src/SeniorIntern.Desktop/Views/FileExplorerView.axaml.cs` | Code-behind |

---

## v0.3.2e: Context Menus

### Objective
Implement context menus for files and folders with appropriate operations.

Context menus are already defined in v0.3.2d within the TreeView. This section adds the additional converter needed for dynamic menu visibility.

### IconColorConverter

```csharp
// src/SeniorIntern.Desktop/Converters/IconColorConverter.cs
namespace SeniorIntern.Desktop.Converters;

using Avalonia.Data.Converters;
using Avalonia.Media;
using System.Globalization;

/// <summary>
/// Converts icon key and item type to appropriate icon color.
/// </summary>
public class IconColorConverter : IMultiValueConverter
{
    public static IconColorConverter Instance { get; } = new();

    public object? Convert(IList<object?> values, Type targetType, object? parameter, CultureInfo culture)
    {
        if (values.Count < 2)
            return Brushes.Gray;

        var iconKey = values[0] as string ?? "file";
        var isDirectory = values[1] is bool b && b;

        if (isDirectory)
        {
            return new SolidColorBrush(Color.Parse("#E8A838")); // Folder yellow
        }

        return iconKey switch
        {
            "file-csharp" => new SolidColorBrush(Color.Parse("#68217A")),  // Purple
            "file-javascript" => new SolidColorBrush(Color.Parse("#F7DF1E")),  // Yellow
            "file-typescript" => new SolidColorBrush(Color.Parse("#3178C6")),  // Blue
            "file-python" => new SolidColorBrush(Color.Parse("#3776AB")),  // Blue
            "file-json" => new SolidColorBrush(Color.Parse("#CBB078")),  // Gold
            "file-html" => new SolidColorBrush(Color.Parse("#E34F26")),  // Orange
            "file-css" => new SolidColorBrush(Color.Parse("#1572B6")),  // Blue
            "file-markdown" => new SolidColorBrush(Color.Parse("#083FA1")),  // Blue
            "file-git" => new SolidColorBrush(Color.Parse("#F05032")),  // Red
            "file-rust" => new SolidColorBrush(Color.Parse("#DEA584")),  // Rust orange
            "file-go" => new SolidColorBrush(Color.Parse("#00ADD8")),  // Go blue
            "file-java" => new SolidColorBrush(Color.Parse("#B07219")),  // Java brown
            "file-shell" => new SolidColorBrush(Color.Parse("#89E051")),  // Green
            _ => new SolidColorBrush(Color.Parse("#8B8B8B"))  // Gray default
        };
    }
}
```

### Files to Create (v0.3.2e)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/Converters/IconColorConverter.cs` | Icon color converter |

---

## v0.3.2f: Keyboard & Interactions

### Objective
Implement keyboard shortcuts, inline rename flow, and delete confirmation.

### Keyboard Shortcuts Summary

| Shortcut | Action | Context |
|----------|--------|---------|
| `Enter` | Open file / Toggle folder | Selected item |
| `F2` | Start rename | Selected item |
| `Delete` | Delete with confirmation | Selected item |
| `Ctrl+C` | Copy absolute path | Selected item |
| `Ctrl+Shift+C` | Copy relative path | Selected item |
| `Ctrl+N` | New file | Current folder |
| `Ctrl+Shift+N` | New folder | Current folder |
| `Ctrl+R` | Refresh tree | Explorer |
| `Right Arrow` | Expand folder | Selected folder |
| `Left Arrow` | Collapse folder | Selected folder |
| `Up/Down Arrow` | Navigate tree | Explorer |
| `Escape` | Cancel rename / Clear filter | Rename mode / Filter |

### Delete Confirmation Dialog

The delete confirmation is handled in `FileExplorerView.axaml.cs` using Avalonia's `ContentDialog`. For dangerous operations like deleting folders with contents, we show a warning.

### Inline Rename Flow

```
1. User presses F2 or selects "Rename" from context menu
2. FileTreeItemViewModel.BeginRename() called
3. IsRenaming = true, EditingName = Name
4. TextBox becomes visible, TextBlock hidden
5. User edits name
6. On Enter: CommitRenameAsync() validates and renames
7. On Escape: CancelRename() reverts
8. On LostFocus: Commits the rename
```

### Files to Create (v0.3.2f)

No additional files - keyboard handling is in `FileExplorerView.axaml.cs`.

---

## v0.3.2g: Main Window Integration

### Objective
Integrate the file explorer into the main window sidebar layout.

### MainWindow.axaml Updates

```xml
<!-- Add to MainWindow.axaml - Sidebar section -->
<Grid ColumnDefinitions="280,Auto,*">

    <!-- Sidebar -->
    <Border Grid.Column="0"
            Background="{DynamicResource SidebarBackgroundBrush}">
        <Grid RowDefinitions="Auto,*,Auto,Auto">

            <!-- Model Selector (existing) -->
            <views:ModelSelectorView Grid.Row="0" />

            <!-- File Explorer (NEW) -->
            <views:FileExplorerView Grid.Row="1"
                                    DataContext="{Binding FileExplorer}" />

            <!-- Conversations List (existing from v0.2.0) -->
            <Expander Grid.Row="2"
                      Header="Conversations"
                      IsExpanded="True">
                <views:ConversationListView DataContext="{Binding ConversationList}" />
            </Expander>

            <!-- Settings button (existing) -->
            <Button Grid.Row="3"
                    Content="Settings"
                    Command="{Binding OpenSettingsCommand}"
                    Margin="8" />
        </Grid>
    </Border>

    <!-- Splitter -->
    <GridSplitter Grid.Column="1"
                  Width="4"
                  Background="{DynamicResource SplitterBrush}" />

    <!-- Main Content -->
    <Grid Grid.Column="2" RowDefinitions="*,Auto,Auto">
        <!-- Editor Panel (v0.3.3) -->
        <views:EditorPanel Grid.Row="0"
                           DataContext="{Binding EditorPanel}"
                           IsVisible="{Binding HasOpenWorkspace}" />

        <!-- Chat Panel -->
        <views:ChatView Grid.Row="1"
                        DataContext="{Binding Chat}" />

        <!-- Status Bar -->
        <views:StatusBarView Grid.Row="2"
                             DataContext="{Binding StatusBar}" />
    </Grid>
</Grid>
```

### MainWindowViewModel Updates

```csharp
// Add to MainWindowViewModel.cs
public partial class MainWindowViewModel : ViewModelBase
{
    // ... existing properties ...

    [ObservableProperty]
    private FileExplorerViewModel _fileExplorer;

    [ObservableProperty]
    private bool _hasOpenWorkspace;

    public MainWindowViewModel(
        // ... existing parameters ...
        FileExplorerViewModel fileExplorer)
    {
        // ... existing initialization ...

        FileExplorer = fileExplorer;

        // Subscribe to file explorer events
        FileExplorer.FileOpenRequested += OnFileOpenRequested;
        FileExplorer.FileAttachRequested += OnFileAttachRequested;

        // Update HasOpenWorkspace
        _workspaceService.WorkspaceChanged += (s, e) =>
        {
            HasOpenWorkspace = e.CurrentWorkspace != null;
        };
    }

    private void OnFileOpenRequested(object? sender, FileOpenRequestedEventArgs e)
    {
        // Forward to editor panel (v0.3.3)
        EditorPanel?.OpenFileCommand.Execute(e.FilePath);
    }

    private void OnFileAttachRequested(object? sender, FileAttachRequestedEventArgs e)
    {
        // Forward to chat view model (v0.3.4)
        Chat?.AttachFileCommand.Execute(e.FilePath);
    }
}
```

### Theme Updates

```xml
<!-- Add to Dark.axaml -->

<!-- Sidebar -->
<SolidColorBrush x:Key="SidebarBackgroundBrush" Color="#1E1E2E" />
<SolidColorBrush x:Key="SplitterBrush" Color="#313244" />

<!-- Tree View -->
<SolidColorBrush x:Key="TreeViewItemSelectedBackground" Color="#45475A" />
<SolidColorBrush x:Key="TreeViewItemHoverBackground" Color="#313244" />

<!-- File Explorer specific -->
<Style Selector="TreeViewItem:selected /template/ Border#PART_LayoutRoot">
    <Setter Property="Background" Value="{DynamicResource TreeViewItemSelectedBackground}" />
</Style>

<Style Selector="TreeViewItem:pointerover /template/ Border#PART_LayoutRoot">
    <Setter Property="Background" Value="{DynamicResource TreeViewItemHoverBackground}" />
</Style>
```

### Files to Modify (v0.3.2g)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/Views/MainWindow.axaml` | Add FileExplorerView to sidebar |
| `src/SeniorIntern.Desktop/ViewModels/MainWindowViewModel.cs` | Add FileExplorerViewModel, wire events |
| `src/SeniorIntern.Desktop/Themes/Dark.axaml` | Add file explorer styles |
| `src/SeniorIntern.Desktop/Extensions/ServiceCollectionExtensions.cs` | Register FileExplorerViewModel |
| `src/SeniorIntern.Desktop/App.axaml` | Include FileIcons.axaml resources |

---

## Files Summary

### Files to Create (9 total)

| Part | File | Purpose |
|------|------|---------|
| v0.3.2a | `src/SeniorIntern.Desktop/ViewModels/FileTreeItemViewModel.cs` | Tree item ViewModel |
| v0.3.2b | `src/SeniorIntern.Desktop/ViewModels/FileExplorerViewModel.cs` | Main explorer ViewModel |
| v0.3.2c | `src/SeniorIntern.Desktop/Services/FileIconProvider.cs` | Icon key/path provider |
| v0.3.2c | `src/SeniorIntern.Desktop/Converters/FileIconConverter.cs` | Icon converter |
| v0.3.2c | `src/SeniorIntern.Desktop/Assets/FileIcons.axaml` | Icon resources |
| v0.3.2d | `src/SeniorIntern.Desktop/Views/FileExplorerView.axaml` | Explorer UI |
| v0.3.2d | `src/SeniorIntern.Desktop/Views/FileExplorerView.axaml.cs` | Code-behind |
| v0.3.2e | `src/SeniorIntern.Desktop/Converters/IconColorConverter.cs` | Icon color converter |

### Files to Modify (5 total)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/Views/MainWindow.axaml` | Add FileExplorerView to sidebar |
| `src/SeniorIntern.Desktop/ViewModels/MainWindowViewModel.cs` | Add FileExplorerViewModel |
| `src/SeniorIntern.Desktop/Themes/Dark.axaml` | Add file explorer styles |
| `src/SeniorIntern.Desktop/Extensions/ServiceCollectionExtensions.cs` | Register services |
| `src/SeniorIntern.Desktop/App.axaml` | Include icon resources |

---

## Testing Strategy

### Unit Tests

```csharp
// tests/SeniorIntern.Desktop.Tests/ViewModels/FileTreeItemViewModelTests.cs
public class FileTreeItemViewModelTests
{
    [Fact]
    public void FromFileSystemItem_CreatesCorrectViewModel()
    {
        // Arrange
        var item = new FileSystemItem
        {
            Name = "test.cs",
            Path = "/project/test.cs",
            Type = FileSystemItemType.File
        };

        // Act
        var vm = FileTreeItemViewModel.FromFileSystemItem(item, Mock.Of<FileExplorerViewModel>());

        // Assert
        Assert.Equal("test.cs", vm.Name);
        Assert.True(vm.IsFile);
        Assert.Equal("csharp", vm.Language);
    }

    [Fact]
    public void ApplyFilter_MatchingName_SetsVisibleAndHighlighted()
    {
        // Arrange
        var vm = new FileTreeItemViewModel(Mock.Of<FileExplorerViewModel>())
        {
            Name = "Program.cs"
        };

        // Act
        vm.ApplyFilter("prog");

        // Assert
        Assert.True(vm.IsVisible);
        Assert.True(vm.IsHighlighted);
    }

    [Fact]
    public void ApplyFilter_NoMatch_SetsInvisible()
    {
        // Arrange
        var vm = new FileTreeItemViewModel(Mock.Of<FileExplorerViewModel>())
        {
            Name = "test.txt"
        };

        // Act
        vm.ApplyFilter("xyz");

        // Assert
        Assert.False(vm.IsVisible);
        Assert.False(vm.IsHighlighted);
    }

    [Fact]
    public void BeginRename_SetsRenamingMode()
    {
        // Arrange
        var vm = new FileTreeItemViewModel(Mock.Of<FileExplorerViewModel>())
        {
            Name = "original.txt"
        };

        // Act
        vm.BeginRename();

        // Assert
        Assert.True(vm.IsRenaming);
        Assert.Equal("original.txt", vm.EditingName);
    }
}
```

```csharp
// tests/SeniorIntern.Desktop.Tests/ViewModels/FileExplorerViewModelTests.cs
public class FileExplorerViewModelTests
{
    [Fact]
    public async Task LoadWorkspace_PopulatesRootItems()
    {
        // Arrange
        var mockWorkspaceService = new Mock<IWorkspaceService>();
        var mockFileSystemService = new Mock<IFileSystemService>();

        mockFileSystemService
            .Setup(x => x.GetDirectoryContentsAsync(It.IsAny<string>(), It.IsAny<bool>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(new List<FileSystemItem>
            {
                new() { Name = "src", Path = "/test/src", Type = FileSystemItemType.Directory },
                new() { Name = "README.md", Path = "/test/README.md", Type = FileSystemItemType.File }
            });

        var workspace = new Workspace { RootPath = "/test", Name = "Test Project" };
        mockWorkspaceService.Setup(x => x.CurrentWorkspace).Returns(workspace);

        var vm = CreateViewModel(mockWorkspaceService.Object, mockFileSystemService.Object);

        // Trigger workspace load
        // (in real test, would invoke via event or direct call)

        // Assert
        Assert.Equal(2, vm.RootItems.Count);
        Assert.True(vm.HasWorkspace);
        Assert.Equal("Test Project", vm.WorkspaceName);
    }

    [Fact]
    public void Filter_DebouncesProperly()
    {
        // Test that rapid filter changes only trigger one actual filter operation
    }
}
```

```csharp
// tests/SeniorIntern.Desktop.Tests/Services/FileIconProviderTests.cs
public class FileIconProviderTests
{
    [Theory]
    [InlineData(".cs", "file-csharp")]
    [InlineData(".js", "file-javascript")]
    [InlineData(".ts", "file-typescript")]
    [InlineData(".py", "file-python")]
    [InlineData(".unknown", "file-code")]
    public void GetIconKeyForExtension_ReturnsCorrectKey(string extension, string expectedKey)
    {
        var result = FileIconProvider.GetIconKeyForExtension(extension);
        Assert.Equal(expectedKey, result);
    }

    [Theory]
    [InlineData("Dockerfile", "file-config")]
    [InlineData("Makefile", "file-shell")]
    [InlineData("package.json", "file-json")]
    [InlineData("random.txt", "file-text")]
    public void GetIconKeyForFileName_HandlesSpecialFiles(string fileName, string expectedKey)
    {
        var result = FileIconProvider.GetIconKeyForFileName(fileName);
        Assert.Equal(expectedKey, result);
    }
}
```

### UI Tests

```csharp
// tests/SeniorIntern.Desktop.Tests/Views/FileExplorerViewTests.cs
public class FileExplorerViewTests
{
    [Fact]
    public void DoubleClick_OnFile_TriggersOpenFile()
    {
        // Test that double-clicking a file opens it
    }

    [Fact]
    public void DoubleClick_OnFolder_TogglesExpansion()
    {
        // Test that double-clicking a folder expands/collapses it
    }

    [Fact]
    public void F2_StartsRename()
    {
        // Test that F2 key starts inline rename
    }

    [Fact]
    public void ContextMenu_ShowsAppropriateOptions()
    {
        // Test that context menu shows correct options for file vs folder
    }
}
```

---

## Acceptance Criteria

### v0.3.2a - File Tree Item ViewModel
- [ ] FileTreeItemViewModel correctly represents files and folders
- [ ] Lazy loading works (children loaded on expansion)
- [ ] Icon keys are resolved correctly by extension
- [ ] Inline rename mode works (begin, commit, cancel)
- [ ] Filter highlighting works

### v0.3.2b - File Explorer ViewModel
- [ ] Workspace loading populates tree
- [ ] Filter debounces and works correctly
- [ ] New file/folder commands work
- [ ] Delete commands work with confirmation
- [ ] Rename via ViewModel works
- [ ] Copy path commands work
- [ ] Reveal in finder works (platform-specific)
- [ ] State persistence (expanded folders) works

### v0.3.2c - File Icon System
- [ ] Icons display correctly for 20+ file types
- [ ] Folder icons change on expand/collapse
- [ ] Icon colors are appropriate
- [ ] Converter works with PathIcon

### v0.3.2d - Tree View UI
- [ ] Tree displays files and folders
- [ ] Expansion/collapse works
- [ ] Selection works
- [ ] Empty state shows when no workspace
- [ ] Loading indicator shows during load
- [ ] Error messages display correctly

### v0.3.2e - Context Menus
- [ ] Context menu appears on right-click
- [ ] File-specific options show for files
- [ ] Folder-specific options show for folders
- [ ] All menu commands work

### v0.3.2f - Keyboard & Interactions
- [ ] Enter opens file / toggles folder
- [ ] F2 starts rename
- [ ] Delete shows confirmation
- [ ] Ctrl+C copies path
- [ ] Ctrl+Shift+C copies relative path
- [ ] Ctrl+N creates new file
- [ ] Ctrl+Shift+N creates new folder
- [ ] Ctrl+R refreshes
- [ ] Arrow keys navigate

### v0.3.2g - Main Window Integration
- [ ] File explorer appears in sidebar
- [ ] File open events reach editor (when implemented)
- [ ] File attach events reach chat (when implemented)
- [ ] Theme styles apply correctly

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| TreeView performance with large directories | Medium | Medium | Virtualization, lazy loading, pagination |
| Context menu binding issues | Low | Medium | Test thoroughly, use proper DataContext |
| Cross-platform path issues | Medium | Medium | Use Path.Combine, normalize paths |
| Keyboard shortcut conflicts | Low | Low | Document shortcuts, allow customization |
| Icon rendering performance | Low | Low | Cache StreamGeometry, use StaticResource |

---

## Performance Considerations

### Tree Virtualization
- Avalonia TreeView virtualizes by default
- Only visible items are rendered
- Important for large directories (1000+ items)

### Lazy Loading
- Children are not loaded until folder is expanded
- Reduces initial load time
- Reduces memory usage for unexpanded folders

### Filter Performance
- Debounce filter input (200ms)
- Filter operation is O(n) where n = total items
- Consider cancellation for very large trees

### Icon Caching
- StreamGeometry parsed once via StaticResource
- FileIconConverter caches parsed geometries
- Color brushes are static resources

---

## References

- [Avalonia TreeView Documentation](https://docs.avaloniaui.net/docs/controls/treeview)
- [CommunityToolkit.Mvvm](https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/)
- [VSCode File Icons](https://github.com/vscode-icons/vscode-icons)
- [Material Design Icons](https://materialdesignicons.com/)
