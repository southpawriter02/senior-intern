# Design Specification: The Senior Intern v0.3.4b "Context Formatter"

## Executive Summary

This document provides a detailed implementation specification for v0.3.4b, which implements the `IContextFormatter` service - a utility for formatting attached file contexts into structured prompts for LLM consumption and readable displays for the UI. This ensures attached code is presented optimally for both AI understanding and human readability.

### v0.3.4b Scope

- Create `IContextFormatter` interface with formatting methods
- Create `ContextFormatter` implementation
- Create `ContextPromptTemplates` static class with template strings
- Format code with markdown syntax highlighting hints
- Handle file metadata (path, language, line numbers)
- Implement truncation with informative notices
- Support both prompt formatting and UI display formatting

### Key Deliverables

| Deliverable | Description |
|-------------|-------------|
| IContextFormatter | Interface for context formatting |
| ContextFormatter | Formatting implementation |
| ContextPromptTemplates | Template strings for prompts |
| FormatForPrompt | Full prompt with all contexts |
| FormatForDisplay | UI-friendly display with preview |
| FormatForStorage | JSON metadata for persistence |

---

## Feature Overview

```
┌──────────────────────────────────────────────────────────────────┐
│                     v0.3.4b Feature Tree                          │
├──────────────────────────────────────────────────────────────────┤
│                                                                   │
│  IContextFormatter                                                │
│  ├── FormatForPrompt(contexts) → string                          │
│  │   ├── Header: "I'm providing you with the following context" │
│  │   ├── For each context: FormatSingleContext()                │
│  │   └── Footer: "Please consider this context..."             │
│  │                                                                │
│  ├── FormatSingleContext(context) → string                       │
│  │   ├── File header: "### File: `filename` (language)"         │
│  │   ├── Line range (if selection): "Lines 10-25"               │
│  │   └── Code block: ```language\ncontent\n```                  │
│  │                                                                │
│  ├── FormatForDisplay(contexts, expanded) → string               │
│  │   ├── File name in bold: **filename**                        │
│  │   ├── Line range if partial                                  │
│  │   ├── If expanded: full code block                           │
│  │   └── If collapsed: truncated preview + "N more lines"       │
│  │                                                                │
│  ├── FormatCodeBlock(content, language) → string                 │
│  │   └── Returns: ```language\ncontent\n```                     │
│  │                                                                │
│  ├── FormatContextHeader(context) → string                       │
│  │   ├── File name with language                                │
│  │   ├── Line range (if selection)                              │
│  │   └── Relative path (if different from filename)             │
│  │                                                                │
│  └── FormatForStorage(contexts) → string (JSON)                  │
│      ├── Id, FilePath, FileName, Language                       │
│      ├── StartLine, EndLine, EstimatedTokens, AttachedAt        │
│      └── ContentHash (not full content), ContentLength          │
│                                                                   │
│  ContextPromptTemplates (static class)                            │
│  ├── SingleFileTemplate                                          │
│  ├── ContextHeaderTemplate                                       │
│  ├── TruncationNotice                                            │
│  └── SelectionTemplate                                           │
│                                                                   │
│  Helper Methods (private)                                         │
│  ├── GetPreview(content, maxLines) → truncated preview          │
│  ├── GetDisplayPath(fullPath) → shortened path                  │
│  └── ComputeHash(content) → SHA256 hash prefix                  │
│                                                                   │
└──────────────────────────────────────────────────────────────────┘
```

---

## Architecture Diagrams

### Prompt Formatting Flow

```
┌─────────────────────────────────────────────────────────────────┐
│                    Prompt Formatting Flow                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  FormatForPrompt([context1, context2])                           │
│         │                                                        │
│         ▼                                                        │
│  ┌────────────────────────────────────────────────────────────┐  │
│  │ OUTPUT:                                                     │  │
│  │                                                             │  │
│  │ I'm providing you with the following code context:         │  │
│  │                                                             │  │
│  │ ### File: `UserService.cs` (csharp)                        │  │
│  │ _Path: src/Services/UserService.cs_                        │  │
│  │ ```csharp                                                   │  │
│  │ public class UserService : IUserService                    │  │
│  │ {                                                           │  │
│  │     public async Task<User> GetByIdAsync(int id)           │  │
│  │     {                                                       │  │
│  │         return await _repository.FindAsync(id);            │  │
│  │     }                                                       │  │
│  │ }                                                           │  │
│  │ ```                                                         │  │
│  │                                                             │  │
│  │ ### Selected Code from `Program.cs` (lines 15-22)          │  │
│  │ ```csharp                                                   │  │
│  │ services.AddScoped<IUserService, UserService>();           │  │
│  │ services.AddScoped<IRepository, Repository>();             │  │
│  │ ```                                                         │  │
│  │                                                             │  │
│  │ Please consider this context when responding. If you need  │  │
│  │ to reference specific code, use the file names and line    │  │
│  │ numbers provided.                                          │  │
│  │                                                             │  │
│  │ ---                                                         │  │
│  │                                                             │  │
│  └────────────────────────────────────────────────────────────┘  │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Display Formatting Flow

```
┌─────────────────────────────────────────────────────────────────┐
│                    Display Formatting Flow                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  FormatForDisplay([context], expanded: false)                    │
│         │                                                        │
│         ▼                                                        │
│  ┌────────────────────────────────────────────────────────────┐  │
│  │ OUTPUT (Collapsed):                                        │  │
│  │                                                             │  │
│  │ **UserService.cs**                                         │  │
│  │ ```csharp                                                   │  │
│  │ public class UserService : IUserService                    │  │
│  │ {                                                           │  │
│  │     public async Task<User> GetByIdAsync(int id)           │  │
│  │     {                                                       │  │
│  │         return await _repository.FindAsync(id);            │  │
│  │     }                                                       │  │
│  │ // ... (45 more lines)                                     │  │
│  │ ```                                                         │  │
│  └────────────────────────────────────────────────────────────┘  │
│                                                                  │
│  ═══════════════════════════════════════════════════════════════ │
│                                                                  │
│  FormatForDisplay([context], expanded: true)                     │
│         │                                                        │
│         ▼                                                        │
│  ┌────────────────────────────────────────────────────────────┐  │
│  │ OUTPUT (Expanded):                                         │  │
│  │                                                             │  │
│  │ **UserService.cs**                                         │  │
│  │ _Lines 10-25_                                              │  │
│  │ ```csharp                                                   │  │
│  │ [Full content without truncation...]                       │  │
│  │ ```                                                         │  │
│  └────────────────────────────────────────────────────────────┘  │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Storage Format

```
┌─────────────────────────────────────────────────────────────────┐
│                    Storage Format                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  FormatForStorage([context])                                     │
│         │                                                        │
│         ▼                                                        │
│  ┌────────────────────────────────────────────────────────────┐  │
│  │ JSON OUTPUT:                                                │  │
│  │                                                             │  │
│  │ [                                                           │  │
│  │   {                                                         │  │
│  │     "Id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",         │  │
│  │     "FilePath": "/Users/dev/project/src/UserService.cs",  │  │
│  │     "FileName": "UserService.cs",                          │  │
│  │     "Language": "csharp",                                  │  │
│  │     "StartLine": null,                                     │  │
│  │     "EndLine": null,                                       │  │
│  │     "EstimatedTokens": 156,                                │  │
│  │     "AttachedAt": "2026-01-10T08:30:00Z",                 │  │
│  │     "ContentHash": "A1B2C3D4E5F67890",                    │  │
│  │     "ContentLength": 1245                                  │  │
│  │   }                                                         │  │
│  │ ]                                                           │  │
│  │                                                             │  │
│  │ Note: Content is NOT stored (only hash for change detect) │  │
│  └────────────────────────────────────────────────────────────┘  │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## Directory Structure

```
src/SeniorIntern.Core/
├── Interfaces/
│   └── IContextFormatter.cs                          (NEW)
└── Models/
    └── ContextPromptTemplates.cs                     (NEW)

src/SeniorIntern.Services/
└── ContextFormatter.cs                               (NEW)
```

---

## Implementation Details

### Task 1: Create IContextFormatter Interface

**File:** `src/SeniorIntern.Core/Interfaces/IContextFormatter.cs`

```csharp
namespace SeniorIntern.Core.Interfaces;

using SeniorIntern.Core.Models;

/// <summary>
/// Service for formatting file contexts into LLM prompts and UI displays.
/// </summary>
public interface IContextFormatter
{
    /// <summary>
    /// Formats contexts for inclusion in an LLM prompt.
    /// Creates a structured prompt with file headers, code blocks, and instructions.
    /// </summary>
    /// <param name="contexts">Collection of file contexts to format.</param>
    /// <returns>Formatted prompt string ready for LLM consumption.</returns>
    string FormatForPrompt(IEnumerable<FileContext> contexts);

    /// <summary>
    /// Formats a single context for prompt inclusion.
    /// </summary>
    /// <param name="context">The file context to format.</param>
    /// <returns>Formatted context with header and code block.</returns>
    string FormatSingleContext(FileContext context);

    /// <summary>
    /// Formats contexts for display in the chat history UI.
    /// </summary>
    /// <param name="contexts">Collection of file contexts to format.</param>
    /// <param name="expanded">If true, shows full content; if false, shows truncated preview.</param>
    /// <returns>Markdown-formatted display string.</returns>
    string FormatForDisplay(IEnumerable<FileContext> contexts, bool expanded = false);

    /// <summary>
    /// Creates a markdown code block with syntax highlighting hint.
    /// </summary>
    /// <param name="content">The code content.</param>
    /// <param name="language">Language identifier for syntax highlighting.</param>
    /// <returns>Formatted code block string.</returns>
    string FormatCodeBlock(string content, string? language);

    /// <summary>
    /// Formats the context header with file metadata.
    /// </summary>
    /// <param name="context">The file context.</param>
    /// <returns>Formatted header with filename, language, and path.</returns>
    string FormatContextHeader(FileContext context);

    /// <summary>
    /// Formats contexts for storage in message history.
    /// Stores metadata without full content (uses hash for change detection).
    /// </summary>
    /// <param name="contexts">Collection of file contexts to serialize.</param>
    /// <returns>JSON string for persistence.</returns>
    string FormatForStorage(IEnumerable<FileContext> contexts);
}
```

### Task 2: Create ContextPromptTemplates

**File:** `src/SeniorIntern.Core/Models/ContextPromptTemplates.cs`

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Templates for context formatting in prompts.
/// </summary>
public static class ContextPromptTemplates
{
    /// <summary>
    /// Template for single file context.
    /// Placeholders: {FileName}, {Language}, {LineRange}, {Content}
    /// </summary>
    public const string SingleFileTemplate = """
        ### File: `{FileName}` ({Language})
        {LineRange}
        ```{Language}
        {Content}
        ```
        """;

    /// <summary>
    /// Template for context header in prompts.
    /// Placeholder: {FormattedContexts}
    /// </summary>
    public const string ContextHeaderTemplate = """
        I'm providing you with the following code context to help you understand my question:

        {FormattedContexts}

        Please consider this context when responding. If you need to reference specific code, use the file names and line numbers provided.

        ---

        """;

    /// <summary>
    /// Template for when context has been truncated.
    /// Placeholders: {TotalLines}, {TotalTokens}
    /// </summary>
    public const string TruncationNotice = """

        *Note: This file has been truncated to fit within context limits. The full file is {TotalLines} lines ({TotalTokens} tokens estimated).*
        """;

    /// <summary>
    /// Template for selection context.
    /// Placeholders: {FileName}, {StartLine}, {EndLine}, {Language}, {Content}
    /// </summary>
    public const string SelectionTemplate = """
        ### Selected Code from `{FileName}` (lines {StartLine}-{EndLine})
        ```{Language}
        {Content}
        ```
        """;

    /// <summary>
    /// Separator between multiple contexts.
    /// </summary>
    public const string ContextSeparator = "\n---\n";

    /// <summary>
    /// Comment indicating truncation in preview.
    /// Placeholder: {RemainingLines}
    /// </summary>
    public const string PreviewTruncationComment = "// ... ({RemainingLines} more lines)";
}
```

### Task 3: Create ContextFormatter Implementation

**File:** `src/SeniorIntern.Services/ContextFormatter.cs`

```csharp
namespace SeniorIntern.Services;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Text.Json;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;

/// <summary>
/// Formats file contexts for LLM prompts and UI display.
/// </summary>
public sealed class ContextFormatter : IContextFormatter
{
    private const int MaxDisplayLines = 10;

    /// <inheritdoc />
    public string FormatForPrompt(IEnumerable<FileContext> contexts)
    {
        var contextList = contexts.ToList();
        if (contextList.Count == 0)
            return string.Empty;

        var sb = new StringBuilder();

        // Header indicating context is provided
        sb.AppendLine("I'm providing you with the following code context:");
        sb.AppendLine();

        foreach (var context in contextList)
        {
            sb.Append(FormatSingleContext(context));
            sb.AppendLine();
        }

        sb.AppendLine("Please consider this context when responding to my question below.");
        sb.AppendLine();

        return sb.ToString();
    }

    /// <inheritdoc />
    public string FormatSingleContext(FileContext context)
    {
        var sb = new StringBuilder();

        // File header
        sb.AppendLine(FormatContextHeader(context));

        // Code block with syntax highlighting
        sb.Append(FormatCodeBlock(context.Content, context.Language));

        return sb.ToString();
    }

    /// <inheritdoc />
    public string FormatForDisplay(IEnumerable<FileContext> contexts, bool expanded = false)
    {
        var contextList = contexts.ToList();
        if (contextList.Count == 0)
            return string.Empty;

        var sb = new StringBuilder();

        foreach (var context in contextList)
        {
            sb.AppendLine($"**{context.FileName}**");

            if (context.IsPartialContent)
            {
                sb.AppendLine($"_Lines {context.StartLine}-{context.EndLine}_");
            }

            if (expanded)
            {
                sb.Append(FormatCodeBlock(context.Content, context.Language));
            }
            else
            {
                // Truncated preview
                var preview = GetPreview(context.Content, MaxDisplayLines);
                sb.Append(FormatCodeBlock(preview, context.Language));
            }

            sb.AppendLine();
        }

        return sb.ToString();
    }

    /// <inheritdoc />
    public string FormatCodeBlock(string content, string? language)
    {
        var sb = new StringBuilder();

        sb.Append("```");
        sb.AppendLine(language ?? string.Empty);
        sb.AppendLine(content.TrimEnd());
        sb.AppendLine("```");

        return sb.ToString();
    }

    /// <inheritdoc />
    public string FormatContextHeader(FileContext context)
    {
        var sb = new StringBuilder();

        sb.Append($"### File: `{context.FileName}`");

        if (!string.IsNullOrEmpty(context.Language))
        {
            sb.Append($" ({context.Language})");
        }

        sb.AppendLine();

        // Add line range if it's a selection
        if (context.IsPartialContent)
        {
            sb.AppendLine($"**Lines {context.StartLine}-{context.EndLine}**");
        }

        // Add relative path if available and different from filename
        if (!string.IsNullOrEmpty(context.FilePath))
        {
            var relativePath = GetDisplayPath(context.FilePath);
            if (relativePath != context.FileName)
            {
                sb.AppendLine($"_Path: {relativePath}_");
            }
        }

        return sb.ToString();
    }

    /// <inheritdoc />
    public string FormatForStorage(IEnumerable<FileContext> contexts)
    {
        var storageItems = contexts.Select(c => new
        {
            c.Id,
            c.FilePath,
            c.FileName,
            c.Language,
            c.StartLine,
            c.EndLine,
            c.EstimatedTokens,
            c.AttachedAt,
            ContentHash = ComputeHash(c.Content),
            ContentLength = c.Content.Length
        });

        return JsonSerializer.Serialize(storageItems, new JsonSerializerOptions
        {
            WriteIndented = false
        });
    }

    #region Private Helpers

    /// <summary>
    /// Creates a truncated preview of content.
    /// </summary>
    private static string GetPreview(string content, int maxLines)
    {
        var lines = content.Split('\n');
        if (lines.Length <= maxLines)
            return content;

        var preview = string.Join('\n', lines.Take(maxLines));
        var remaining = lines.Length - maxLines;
        return $"{preview}\n// ... ({remaining} more lines)";
    }

    /// <summary>
    /// Extracts a meaningful display path from a full path.
    /// </summary>
    private static string GetDisplayPath(string fullPath)
    {
        // Extract meaningful path portion
        // e.g., "src/Services/MyService.cs" instead of full path
        var parts = fullPath.Replace('\\', '/').Split('/');

        // Take last 3 parts at most
        var meaningfulParts = parts.TakeLast(3);
        return string.Join('/', meaningfulParts);
    }

    /// <summary>
    /// Computes a SHA256 hash prefix for content.
    /// </summary>
    private static string ComputeHash(string content)
    {
        var bytes = Encoding.UTF8.GetBytes(content);
        var hash = SHA256.HashData(bytes);
        return Convert.ToHexString(hash)[..16]; // First 16 chars of hash
    }

    #endregion
}
```

---

## Output Examples

### FormatForPrompt Output

```markdown
I'm providing you with the following code context:

### File: `UserService.cs` (csharp)
_Path: src/Services/UserService.cs_
```csharp
public class UserService : IUserService
{
    private readonly IUserRepository _repository;

    public async Task<User> GetByIdAsync(int id)
    {
        return await _repository.FindAsync(id);
    }
}
```

### Selected Code from `Program.cs` (lines 15-22)
```csharp
services.AddScoped<IUserService, UserService>();
services.AddScoped<IRepository, Repository>();
```

Please consider this context when responding to my question below.

```

### FormatForDisplay Output (Collapsed)

```markdown
**UserService.cs**
```csharp
public class UserService : IUserService
{
    private readonly IUserRepository _repository;

    public async Task<User> GetByIdAsync(int id)
    {
        return await _repository.FindAsync(id);
    }
// ... (45 more lines)
```

```

---

## Unit Testing Requirements

| Component | Test Count | Focus Areas |
|-----------|------------|-------------|
| FormatForPrompt | 3 | Empty, single, multiple contexts |
| FormatSingleContext | 3 | File, selection, with language |
| FormatForDisplay | 4 | Empty, collapsed, expanded, selection |
| FormatCodeBlock | 3 | With language, without, special chars |
| FormatContextHeader | 4 | Basic, with line range, with path, both |
| FormatForStorage | 2 | Single, multiple contexts |
| GetPreview | 3 | Under limit, at limit, over limit |
| GetDisplayPath | 3 | Short path, long path, Windows paths |
| ComputeHash | 2 | Consistent hash, different content |
| **Total** | **27** | |

---

## Files Summary

### Files to Create (3)

| File | Lines |
|------|-------|
| `Core/Interfaces/IContextFormatter.cs` | 55 |
| `Core/Models/ContextPromptTemplates.cs` | 60 |
| `Services/ContextFormatter.cs` | 150 |

### Files to Modify (0)

None.

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | FormatForPrompt creates well-structured LLM prompts |
| AC-2 | Code blocks include correct language hints |
| AC-3 | Line numbers shown for selections (Lines X-Y) |
| AC-4 | Truncation notice appears when content is truncated |
| AC-5 | FormatForDisplay creates readable markdown |
| AC-6 | File paths are shortened to last 3 segments |
| AC-7 | FormatForStorage creates valid JSON |
| AC-8 | Content hash is generated for change detection |
| AC-9 | Full content is NOT stored in FormatForStorage output |
| AC-10 | Empty context list returns empty string |

---

## Dependencies

| Part | Dependency Description |
|------|------------------------|
| v0.3.1 | FileContext model |
| System.Text.Json | JSON serialization |
| System.Security.Cryptography | SHA256 hashing |

---

## Timeline Estimate

| Version | Estimated Effort |
|---------|------------------|
| v0.3.4b | 0.5 day |
