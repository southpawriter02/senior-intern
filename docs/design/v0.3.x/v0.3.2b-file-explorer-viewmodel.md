# Design Specification: The Senior Intern v0.3.2b "File Explorer ViewModel"

## Executive Summary

This document provides a detailed implementation specification for v0.3.2b, which implements the main ViewModel for the file explorer sidebar. The `FileExplorerViewModel` manages workspace state, tree loading, file operations, filtering, and coordinates between the UI and backend services.

### v0.3.2b Scope (from v0.3.2 Design Document)

- Create `FileExplorerViewModel` with CommunityToolkit.Mvvm
- Implement workspace open/close/refresh commands
- Implement file/folder operation commands (new, rename, delete)
- Implement path commands (copy path, reveal in finder)
- Implement debounced filter with 200ms delay
- Implement workspace event handling
- Expose events for file open/attach requests

### Key Deliverables

| Deliverable | Description |
|-------------|-------------|
| FileExplorerViewModel | Main ViewModel for file explorer |
| Workspace Commands | Open, close, refresh |
| File Operations | New file/folder, rename, delete |
| Path Operations | Copy path, copy relative, reveal in finder |
| Filter System | Debounced 200ms filter |
| Events | FileOpenRequested, FileAttachRequested |
| Event Args | FileOpenRequestedEventArgs, FileAttachRequestedEventArgs |

---

## Feature Overview

```
┌──────────────────────────────────────────────────────────────────┐
│                     v0.3.2b Feature Tree                          │
├──────────────────────────────────────────────────────────────────┤
│                                                                   │
│  FileExplorerViewModel                                            │
│  ├── Observable Properties                                        │
│  │   ├── RootItems: ObservableCollection<FileTreeItemViewModel>  │
│  │   ├── SelectedItem: FileTreeItemViewModel?                    │
│  │   ├── HasWorkspace (bool)                                     │
│  │   ├── WorkspaceName (string)                                  │
│  │   ├── WorkspacePath (string)                                  │
│  │   ├── IsLoading (bool)                                        │
│  │   ├── SearchFilter (string) - triggers debounced filter       │
│  │   ├── IsFiltering (bool)                                      │
│  │   ├── ErrorMessage (string?)                                  │
│  │   └── FilteredItemCount (int)                                 │
│  │                                                                │
│  ├── Workspace Commands                                           │
│  │   ├── OpenWorkspaceCommand                                    │
│  │   │   └── Opens FolderPickerAsync, calls WorkspaceService     │
│  │   ├── CloseWorkspaceCommand                                   │
│  │   │   └── Calls WorkspaceService.CloseWorkspaceAsync()        │
│  │   └── RefreshCommand                                          │
│  │       └── Reloads tree from current workspace                 │
│  │                                                                │
│  ├── File/Folder Commands                                         │
│  │   ├── OpenFileCommand(item)                                   │
│  │   │   └── Raises FileOpenRequested event                      │
│  │   ├── ExpandFolderCommand(item)                               │
│  │   ├── CollapseFolderCommand(item)                             │
│  │   ├── NewFileCommand(parentFolder?)                           │
│  │   │   └── Creates untitled.txt, starts inline rename          │
│  │   ├── NewFolderCommand(parentFolder?)                         │
│  │   │   └── Creates "New Folder", starts inline rename          │
│  │   ├── RenameCommand(item?)                                    │
│  │   │   └── Calls item.BeginRename()                            │
│  │   └── DeleteCommand(item?)                                    │
│  │       └── Deletes file/folder via FileSystemService           │
│  │                                                                │
│  ├── Path Commands                                                │
│  │   ├── CopyPathCommand(item?)                                  │
│  │   │   └── Copies absolute path to clipboard                   │
│  │   ├── CopyRelativePathCommand(item?)                          │
│  │   │   └── Copies workspace-relative path to clipboard         │
│  │   └── RevealInFinderCommand(item?)                            │
│  │       └── Opens system file manager (Mac/Win/Linux)           │
│  │                                                                │
│  ├── Context Attachment                                           │
│  │   └── AttachToContextCommand(item?)                           │
│  │       └── Raises FileAttachRequested event                    │
│  │                                                                │
│  ├── Filter (200ms debounce)                                      │
│  │   ├── OnSearchFilterChanged() → start timer                   │
│  │   ├── OnFilterDebounceElapsed() → ApplyFilter()               │
│  │   ├── ApplyFilter(filter)                                     │
│  │   │   └── Recursively calls item.ApplyFilter()                │
│  │   └── ClearFilterCommand                                      │
│  │                                                                │
│  ├── Tree Loading                                                 │
│  │   ├── LoadWorkspaceAsync(workspace)                           │
│  │   │   ├── Set HasWorkspace, WorkspaceName, WorkspacePath      │
│  │   │   ├── Load .gitignore patterns                            │
│  │   │   ├── GetDirectoryContentsAsync with settings             │
│  │   │   ├── Filter by ShouldIgnore                              │
│  │   │   ├── Create FileTreeItemViewModels                       │
│  │   │   └── RestoreExpandedFoldersAsync                         │
│  │   │                                                            │
│  │   └── LoadChildrenForItemAsync(parent) [internal]             │
│  │       └── Called by FileTreeItemViewModel                     │
│  │                                                                │
│  ├── State Management                                             │
│  │   ├── OnItemExpansionChanged(item)                            │
│  │   │   └── Collects expanded paths, updates WorkspaceService   │
│  │   └── CollectExpandedPaths() - recursive                      │
│  │                                                                │
│  ├── Helper Methods                                               │
│  │   ├── GetTargetDirectoryPath(item?)                           │
│  │   ├── EnsureExpandedAsync(folder)                             │
│  │   ├── FindItemByPath(path)                                    │
│  │   ├── RemoveItemFromTree(item)                                │
│  │   └── GetRelativePath(absolutePath) [exposed to items]        │
│  │                                                                │
│  ├── Events                                                       │
│  │   ├── FileOpenRequested (EventHandler<FileOpenRequestedArgs>) │
│  │   └── FileAttachRequested (EventHandler<FileAttachArgs>)      │
│  │                                                                │
│  └── Event Handlers                                               │
│      └── OnWorkspaceChanged(sender, args)                        │
│          ├── Opened → LoadWorkspaceAsync                         │
│          └── Closed → Clear tree and state                       │
│                                                                   │
└──────────────────────────────────────────────────────────────────┘
```

---

## Architecture Diagrams

### ViewModel Dependencies

```
┌─────────────────────────────────────────────────────────────────┐
│                    ViewModel Dependencies                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  FileExplorerViewModel                                           │
│       │                                                          │
│       ├─────────────────────────────────────────────────────────►│
│       │   IWorkspaceService                                      │
│       │   ├── CurrentWorkspace                                   │
│       │   ├── OpenWorkspaceAsync(path)                          │
│       │   ├── CloseWorkspaceAsync()                             │
│       │   ├── UpdateExpandedFolders(paths)                      │
│       │   └── WorkspaceChanged event (subscribe)                │
│       │                                                          │
│       ├─────────────────────────────────────────────────────────►│
│       │   IFileSystemService                                     │
│       │   ├── GetDirectoryContentsAsync(path, includeHidden)    │
│       │   ├── CreateFileAsync(path)                             │
│       │   ├── CreateDirectoryAsync(path)                        │
│       │   ├── RenameAsync(path, newName)                        │
│       │   ├── DeleteFileAsync(path)                             │
│       │   ├── DeleteDirectoryAsync(path)                        │
│       │   └── ShouldIgnore(path, basePath, patterns)            │
│       │                                                          │
│       ├─────────────────────────────────────────────────────────►│
│       │   ISettingsService                                       │
│       │   └── GetSettingsAsync() → ShowHiddenFiles             │
│       │                                                          │
│       └─────────────────────────────────────────────────────────►│
│           IStorageProvider (Avalonia)                            │
│           └── OpenFolderPickerAsync()                           │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Command Flow: New File

```
┌─────────────────────────────────────────────────────────────────┐
│                    New File Command Flow                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  User: Right-click folder → "New File"                           │
│              │                                                   │
│              ▼                                                   │
│  ┌────────────────────────────────────────────────────────────┐  │
│  │ NewFileCommand(parentFolder)                               │  │
│  │                                                             │  │
│  │ 1. targetPath = GetTargetDirectoryPath(parentFolder)       │  │
│  │    • If folder selected → folder.Path                      │  │
│  │    • If file selected → file's directory                   │  │
│  │    • If nothing selected → workspace root                  │  │
│  └────────────────────────────────────────────────────────────┘  │
│              │                                                   │
│              ▼                                                   │
│  ┌────────────────────────────────────────────────────────────┐  │
│  │ 2. Generate unique filename                                │  │
│  │                                                             │  │
│  │    baseName = "untitled"                                    │  │
│  │    extension = ".txt"                                       │  │
│  │    counter = 1                                              │  │
│  │                                                             │  │
│  │    while (File.Exists(targetPath + name)):                 │  │
│  │        name = "untitled-{counter++}.txt"                   │  │
│  │                                                             │  │
│  │    → "untitled.txt" or "untitled-1.txt" etc.               │  │
│  └────────────────────────────────────────────────────────────┘  │
│              │                                                   │
│              ▼                                                   │
│  ┌────────────────────────────────────────────────────────────┐  │
│  │ 3. Create file on disk                                     │  │
│  │                                                             │  │
│  │ newItem = await _fileSystemService.CreateFileAsync(path)   │  │
│  └────────────────────────────────────────────────────────────┘  │
│              │                                                   │
│              ▼                                                   │
│  ┌────────────────────────────────────────────────────────────┐  │
│  │ 4. Add to tree                                             │  │
│  │                                                             │  │
│  │ viewModel = FileTreeItemViewModel.FromFileSystemItem(...)  │  │
│  │                                                             │  │
│  │ if (parentFolder != null):                                 │  │
│  │     await EnsureExpandedAsync(parentFolder)                │  │
│  │     parentFolder.Children.Add(viewModel)                   │  │
│  │ else:                                                       │  │
│  │     RootItems.Add(viewModel)                               │  │
│  └────────────────────────────────────────────────────────────┘  │
│              │                                                   │
│              ▼                                                   │
│  ┌────────────────────────────────────────────────────────────┐  │
│  │ 5. Select and start rename                                 │  │
│  │                                                             │  │
│  │ SelectedItem = viewModel                                   │  │
│  │ viewModel.BeginRename()  → UI shows inline TextBox         │  │
│  └────────────────────────────────────────────────────────────┘  │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Workspace Changed Event Handling

```
┌─────────────────────────────────────────────────────────────────┐
│                  Workspace Changed Handler                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  WorkspaceService.WorkspaceChanged += OnWorkspaceChanged         │
│              │                                                   │
│              ▼                                                   │
│  ┌────────────────────────────────────────────────────────────┐  │
│  │ OnWorkspaceChanged(sender, args)                           │  │
│  │                                                             │  │
│  │ await Dispatcher.UIThread.InvokeAsync(async () => {        │  │
│  │     ...                                                     │  │
│  │ });                                                         │  │
│  └────────────────────────────────────────────────────────────┘  │
│              │                                                   │
│      ┌───────┴───────┐                                          │
│      │               │                                          │
│      ▼               ▼                                          │
│  [ChangeType =    [ChangeType =                                  │
│   Closed]          Opened/Refreshed]                             │
│      │               │                                          │
│      ▼               ▼                                          │
│  ┌───────────────┐ ┌────────────────────────────────────────┐   │
│  │ HasWorkspace  │ │ await LoadWorkspaceAsync(workspace)    │   │
│  │   = false     │ │                                        │   │
│  │ WorkspaceName │ │ 1. HasWorkspace = true                 │   │
│  │   = ""        │ │ 2. WorkspaceName = DisplayName         │   │
│  │ WorkspacePath │ │ 3. Load .gitignore patterns            │   │
│  │   = ""        │ │ 4. Load settings (ShowHiddenFiles)     │   │
│  │ RootItems     │ │ 5. GetDirectoryContentsAsync           │   │
│  │   .Clear()    │ │ 6. Filter by ShouldIgnore              │   │
│  │ SearchFilter  │ │ 7. Create ViewModels                   │   │
│  │   = ""        │ │ 8. RestoreExpandedFoldersAsync         │   │
│  └───────────────┘ └────────────────────────────────────────┘   │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Filter Debounce

```
┌─────────────────────────────────────────────────────────────────┐
│                    Filter Debounce Flow                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  User types: "t" → "te" → "tes" → "test"  (rapid keystrokes)    │
│              │     │       │       │                             │
│              ▼     ▼       ▼       ▼                             │
│  ┌────────────────────────────────────────────────────────────┐  │
│  │ OnSearchFilterChanged("t")   │   Timer: Reset to 200ms     │  │
│  │ OnSearchFilterChanged("te")  │   Timer: Reset to 200ms     │  │
│  │ OnSearchFilterChanged("tes") │   Timer: Reset to 200ms     │  │
│  │ OnSearchFilterChanged("test")│   Timer: Reset to 200ms     │  │
│  └────────────────────────────────────────────────────────────┘  │
│                                       │                          │
│                                       │ (200ms passes)           │
│                                       ▼                          │
│  ┌────────────────────────────────────────────────────────────┐  │
│  │ OnFilterDebounceElapsed()                                  │  │
│  │                                                             │  │
│  │ Dispatcher.UIThread.InvokeAsync(() =>                      │  │
│  │     ApplyFilter(_pendingFilter));  // "test"               │  │
│  └────────────────────────────────────────────────────────────┘  │
│                                       │                          │
│                                       ▼                          │
│  ┌────────────────────────────────────────────────────────────┐  │
│  │ ApplyFilter("test")                                        │  │
│  │                                                             │  │
│  │ IsFiltering = true                                         │  │
│  │                                                             │  │
│  │ foreach (var item in RootItems):                           │  │
│  │     item.ApplyFilter("test")  // Recursive                 │  │
│  │                                                             │  │
│  │ FilteredItemCount = matchCount                             │  │
│  │                                                             │  │
│  │ IsFiltering = false                                        │  │
│  └────────────────────────────────────────────────────────────┘  │
│                                                                  │
│  Result: Only ONE filter operation runs, not four               │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## Directory Structure

```
src/SeniorIntern.Desktop/
└── ViewModels/
    └── FileExplorerViewModel.cs                      (NEW)
```

---

## Implementation Details

### Task 1: Create FileExplorerViewModel

**File:** `src/SeniorIntern.Desktop/ViewModels/FileExplorerViewModel.cs`

```csharp
namespace SeniorIntern.Desktop.ViewModels;

using Avalonia.Platform.Storage;
using Avalonia.Threading;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Events;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Timers;

/// <summary>
/// ViewModel for the file explorer sidebar.
/// </summary>
public partial class FileExplorerViewModel : ViewModelBase, IDisposable
{
    private readonly IWorkspaceService _workspaceService;
    private readonly IFileSystemService _fileSystemService;
    private readonly ISettingsService _settingsService;
    private readonly IStorageProvider _storageProvider;
    private readonly ILogger<FileExplorerViewModel> _logger;
    private readonly Timer _filterDebounceTimer;

    private string _pendingFilter = string.Empty;
    private IReadOnlyList<string> _ignorePatterns = [];
    private bool _disposed;

    #region Observable Properties

    /// <summary>Root items in the tree (workspace root contents).</summary>
    public ObservableCollection<FileTreeItemViewModel> RootItems { get; } = [];

    /// <summary>Currently selected item in the tree.</summary>
    [ObservableProperty]
    private FileTreeItemViewModel? _selectedItem;

    /// <summary>Whether a workspace is currently open.</summary>
    [ObservableProperty]
    private bool _hasWorkspace;

    /// <summary>Display name of the current workspace.</summary>
    [ObservableProperty]
    private string _workspaceName = string.Empty;

    /// <summary>Root path of the current workspace.</summary>
    [ObservableProperty]
    private string _workspacePath = string.Empty;

    /// <summary>Whether tree is currently loading.</summary>
    [ObservableProperty]
    private bool _isLoading;

    /// <summary>Current filter text.</summary>
    [ObservableProperty]
    private string _searchFilter = string.Empty;

    /// <summary>Whether filter is currently being applied.</summary>
    [ObservableProperty]
    private bool _isFiltering;

    /// <summary>Error message to display (if any).</summary>
    [ObservableProperty]
    private string? _errorMessage;

    /// <summary>Number of items matching current filter.</summary>
    [ObservableProperty]
    private int _filteredItemCount;

    #endregion

    #region Events

    /// <summary>Raised when a file should be opened in the editor.</summary>
    public event EventHandler<FileOpenRequestedEventArgs>? FileOpenRequested;

    /// <summary>Raised when a file should be attached to chat context.</summary>
    public event EventHandler<FileAttachRequestedEventArgs>? FileAttachRequested;

    /// <summary>Raised when delete confirmation is needed.</summary>
    public event EventHandler<DeleteConfirmationEventArgs>? DeleteConfirmationRequested;

    #endregion

    #region Constructor

    public FileExplorerViewModel(
        IWorkspaceService workspaceService,
        IFileSystemService fileSystemService,
        ISettingsService settingsService,
        IStorageProvider storageProvider,
        ILogger<FileExplorerViewModel> logger)
    {
        _workspaceService = workspaceService;
        _fileSystemService = fileSystemService;
        _settingsService = settingsService;
        _storageProvider = storageProvider;
        _logger = logger;

        // Filter debounce timer (200ms)
        _filterDebounceTimer = new Timer(200) { AutoReset = false };
        _filterDebounceTimer.Elapsed += OnFilterDebounceElapsed;

        // Subscribe to workspace events
        _workspaceService.WorkspaceChanged += OnWorkspaceChanged;

        // Initialize from current workspace if already open
        if (_workspaceService.CurrentWorkspace != null)
        {
            _ = LoadWorkspaceAsync(_workspaceService.CurrentWorkspace);
        }
    }

    #endregion

    #region Filter Handling

    partial void OnSearchFilterChanged(string value)
    {
        _pendingFilter = value;
        _filterDebounceTimer.Stop();
        _filterDebounceTimer.Start();
    }

    private async void OnFilterDebounceElapsed(object? sender, ElapsedEventArgs e)
    {
        await Dispatcher.UIThread.InvokeAsync(() => ApplyFilter(_pendingFilter));
    }

    private void ApplyFilter(string filter)
    {
        IsFiltering = true;
        var matchCount = 0;

        try
        {
            foreach (var item in RootItems)
            {
                if (item.ApplyFilter(filter))
                {
                    matchCount++;
                }
            }

            FilteredItemCount = matchCount;
        }
        finally
        {
            IsFiltering = false;
        }
    }

    /// <summary>Clears the current filter.</summary>
    [RelayCommand]
    private void ClearFilter()
    {
        SearchFilter = string.Empty;
    }

    #endregion

    #region Workspace Commands

    /// <summary>Opens a folder selection dialog to choose a workspace.</summary>
    [RelayCommand]
    private async Task OpenWorkspaceAsync()
    {
        try
        {
            var folders = await _storageProvider.OpenFolderPickerAsync(new FolderPickerOpenOptions
            {
                Title = "Open Folder",
                AllowMultiple = false
            });

            if (folders.Count == 0)
                return;

            var folder = folders[0];
            var path = folder.Path.LocalPath;

            await _workspaceService.OpenWorkspaceAsync(path);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to open workspace");
            ErrorMessage = $"Failed to open folder: {ex.Message}";
        }
    }

    /// <summary>Closes the current workspace.</summary>
    [RelayCommand]
    private async Task CloseWorkspaceAsync()
    {
        await _workspaceService.CloseWorkspaceAsync();
    }

    /// <summary>Refreshes the entire tree.</summary>
    [RelayCommand]
    private async Task RefreshAsync()
    {
        if (_workspaceService.CurrentWorkspace == null)
            return;

        await LoadWorkspaceAsync(_workspaceService.CurrentWorkspace);
    }

    #endregion

    #region File/Folder Operation Commands

    /// <summary>Opens a file in the editor.</summary>
    [RelayCommand]
    private void OpenFile(FileTreeItemViewModel? item)
    {
        if (item == null || !item.IsFile)
            return;

        FileOpenRequested?.Invoke(this, new FileOpenRequestedEventArgs(item.Path));
    }

    /// <summary>Expands a folder.</summary>
    [RelayCommand]
    private async Task ExpandFolderAsync(FileTreeItemViewModel? item)
    {
        if (item == null || !item.IsDirectory)
            return;

        item.IsExpanded = true;
        await item.LoadChildrenAsync();
    }

    /// <summary>Collapses a folder.</summary>
    [RelayCommand]
    private void CollapseFolder(FileTreeItemViewModel? item)
    {
        if (item == null || !item.IsDirectory)
            return;

        item.IsExpanded = false;
    }

    /// <summary>Creates a new file in the specified folder (or workspace root).</summary>
    [RelayCommand]
    private async Task NewFileAsync(FileTreeItemViewModel? parentFolder)
    {
        var targetPath = GetTargetDirectoryPath(parentFolder);
        if (targetPath == null) return;

        try
        {
            // Generate unique name
            var baseName = "untitled";
            var extension = ".txt";
            var name = baseName + extension;
            var counter = 1;

            while (File.Exists(Path.Combine(targetPath, name)))
            {
                name = $"{baseName}-{counter++}{extension}";
            }

            var filePath = Path.Combine(targetPath, name);
            var newItem = await _fileSystemService.CreateFileAsync(filePath);

            // Add to tree and start rename
            var viewModel = FileTreeItemViewModel.FromFileSystemItem(newItem, this);

            if (parentFolder != null)
            {
                await EnsureExpandedAsync(parentFolder);
                parentFolder.Children.Add(viewModel);
            }
            else
            {
                RootItems.Add(viewModel);
            }

            SelectedItem = viewModel;
            viewModel.BeginRename();

            _logger.LogInformation("Created new file: {Path}", filePath);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to create file");
            ErrorMessage = $"Failed to create file: {ex.Message}";
        }
    }

    /// <summary>Creates a new folder in the specified location.</summary>
    [RelayCommand]
    private async Task NewFolderAsync(FileTreeItemViewModel? parentFolder)
    {
        var targetPath = GetTargetDirectoryPath(parentFolder);
        if (targetPath == null) return;

        try
        {
            // Generate unique name
            var baseName = "New Folder";
            var name = baseName;
            var counter = 1;

            while (Directory.Exists(Path.Combine(targetPath, name)))
            {
                name = $"{baseName} {counter++}";
            }

            var folderPath = Path.Combine(targetPath, name);
            var newItem = await _fileSystemService.CreateDirectoryAsync(folderPath);

            // Add to tree and start rename
            var viewModel = FileTreeItemViewModel.FromFileSystemItem(newItem, this);

            if (parentFolder != null)
            {
                await EnsureExpandedAsync(parentFolder);
                // Insert folders before files (maintain sort order)
                var insertIndex = parentFolder.Children.TakeWhile(c => c.IsDirectory).Count();
                parentFolder.Children.Insert(insertIndex, viewModel);
            }
            else
            {
                var insertIndex = RootItems.TakeWhile(c => c.IsDirectory).Count();
                RootItems.Insert(insertIndex, viewModel);
            }

            SelectedItem = viewModel;
            viewModel.BeginRename();

            _logger.LogInformation("Created new folder: {Path}", folderPath);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to create folder");
            ErrorMessage = $"Failed to create folder: {ex.Message}";
        }
    }

    /// <summary>Starts rename mode for the selected item.</summary>
    [RelayCommand]
    private void Rename(FileTreeItemViewModel? item)
    {
        item ??= SelectedItem;
        item?.BeginRename();
    }

    /// <summary>Deletes the selected item.</summary>
    [RelayCommand]
    private async Task DeleteAsync(FileTreeItemViewModel? item)
    {
        item ??= SelectedItem;
        if (item == null) return;

        await DeleteItemInternalAsync(item);
    }

    /// <summary>Actually deletes an item (called after confirmation).</summary>
    internal async Task DeleteItemInternalAsync(FileTreeItemViewModel item)
    {
        try
        {
            if (item.IsDirectory)
            {
                await _fileSystemService.DeleteDirectoryAsync(item.Path);
            }
            else
            {
                await _fileSystemService.DeleteFileAsync(item.Path);
            }

            RemoveItemFromTree(item);
            _logger.LogInformation("Deleted: {Path}", item.Path);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to delete {Path}", item.Path);
            ErrorMessage = $"Failed to delete: {ex.Message}";
        }
    }

    /// <summary>Renames an item (called from FileTreeItemViewModel).</summary>
    internal async Task RenameItemAsync(FileTreeItemViewModel item, string newName)
    {
        try
        {
            var renamed = await _fileSystemService.RenameAsync(item.Path, newName);
            item.Name = renamed.Name;
            item.Path = renamed.Path;

            _logger.LogInformation("Renamed to: {Path}", renamed.Path);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to rename {Path} to {NewName}", item.Path, newName);
            throw; // Rethrow for item to handle
        }
    }

    #endregion

    #region Path Commands

    /// <summary>Copies the absolute path to clipboard.</summary>
    [RelayCommand]
    private async Task CopyPathAsync(FileTreeItemViewModel? item)
    {
        item ??= SelectedItem;
        if (item == null) return;

        await CopyToClipboardAsync(item.Path);
    }

    /// <summary>Copies the relative path to clipboard.</summary>
    [RelayCommand]
    private async Task CopyRelativePathAsync(FileTreeItemViewModel? item)
    {
        item ??= SelectedItem;
        if (item == null || _workspaceService.CurrentWorkspace == null) return;

        var relativePath = _workspaceService.CurrentWorkspace.GetRelativePath(item.Path);
        await CopyToClipboardAsync(relativePath);
    }

    /// <summary>Opens the item's location in the system file manager.</summary>
    [RelayCommand]
    private void RevealInFinder(FileTreeItemViewModel? item)
    {
        item ??= SelectedItem;
        if (item == null) return;

        var path = item.IsDirectory ? item.Path : Path.GetDirectoryName(item.Path);
        if (string.IsNullOrEmpty(path)) return;

        try
        {
            if (OperatingSystem.IsMacOS())
            {
                Process.Start("open", $"-R \"{item.Path}\"");
            }
            else if (OperatingSystem.IsWindows())
            {
                Process.Start("explorer.exe", $"/select,\"{item.Path}\"");
            }
            else if (OperatingSystem.IsLinux())
            {
                Process.Start("xdg-open", path);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to reveal in finder: {Path}", item.Path);
        }
    }

    private async Task CopyToClipboardAsync(string text)
    {
        try
        {
            var clipboard = Avalonia.Application.Current?.Clipboard;
            if (clipboard != null)
            {
                await clipboard.SetTextAsync(text);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to copy to clipboard");
        }
    }

    #endregion

    #region Context Attachment

    /// <summary>Attaches the selected file to the chat context.</summary>
    [RelayCommand]
    private void AttachToContext(FileTreeItemViewModel? item)
    {
        item ??= SelectedItem;
        if (item == null || !item.IsFile) return;

        FileAttachRequested?.Invoke(this, new FileAttachRequestedEventArgs(item.Path));
    }

    #endregion

    #region Tree Loading

    private async Task LoadWorkspaceAsync(Workspace workspace)
    {
        IsLoading = true;
        ErrorMessage = null;

        try
        {
            HasWorkspace = true;
            WorkspaceName = workspace.DisplayName;
            WorkspacePath = workspace.RootPath;

            // Load ignore patterns
            _ignorePatterns = workspace.GitIgnorePatterns;

            // Load settings
            var settings = await _settingsService.GetSettingsAsync();

            // Load root contents
            var contents = await _fileSystemService.GetDirectoryContentsAsync(
                workspace.RootPath,
                includeHidden: settings.ShowHiddenFiles);

            // Filter by ignore patterns
            var filteredContents = contents
                .Where(item => !_fileSystemService.ShouldIgnore(
                    item.Path,
                    workspace.RootPath,
                    _ignorePatterns))
                .ToList();

            // Create ViewModels
            await Dispatcher.UIThread.InvokeAsync(() =>
            {
                RootItems.Clear();
                foreach (var item in filteredContents)
                {
                    var viewModel = FileTreeItemViewModel.FromFileSystemItem(item, this, depth: 0);
                    RootItems.Add(viewModel);
                }
            });

            // Restore expanded folders
            await RestoreExpandedFoldersAsync(workspace.ExpandedFolders);

            _logger.LogInformation("Loaded workspace: {Name} with {Count} root items",
                workspace.DisplayName, RootItems.Count);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to load workspace");
            ErrorMessage = $"Failed to load workspace: {ex.Message}";
        }
        finally
        {
            IsLoading = false;
        }
    }

    /// <summary>Loads children for a directory item. Called by FileTreeItemViewModel.</summary>
    internal async Task<IReadOnlyList<FileTreeItemViewModel>> LoadChildrenForItemAsync(
        FileTreeItemViewModel parent)
    {
        var settings = await _settingsService.GetSettingsAsync();

        var contents = await _fileSystemService.GetDirectoryContentsAsync(
            parent.Path,
            includeHidden: settings.ShowHiddenFiles);

        // Filter by ignore patterns
        var workspaceRoot = _workspaceService.CurrentWorkspace?.RootPath ?? parent.Path;
        var filteredContents = contents
            .Where(item => !_fileSystemService.ShouldIgnore(item.Path, workspaceRoot, _ignorePatterns))
            .ToList();

        return filteredContents
            .Select(item => FileTreeItemViewModel.FromFileSystemItem(item, this, parent.Depth + 1))
            .ToList();
    }

    private async Task RestoreExpandedFoldersAsync(IReadOnlyList<string> expandedPaths)
    {
        if (expandedPaths.Count == 0 || _workspaceService.CurrentWorkspace == null)
            return;

        foreach (var relativePath in expandedPaths)
        {
            var absolutePath = _workspaceService.CurrentWorkspace.GetAbsolutePath(relativePath);
            var item = FindItemByPath(absolutePath);

            if (item != null && item.IsDirectory)
            {
                item.IsExpanded = true;
                await item.LoadChildrenAsync();
            }
        }
    }

    #endregion

    #region State Management

    /// <summary>Called when an item's expansion state changes.</summary>
    internal void OnItemExpansionChanged(FileTreeItemViewModel item)
    {
        if (_workspaceService.CurrentWorkspace == null)
            return;

        var expandedPaths = CollectExpandedPaths(RootItems)
            .Select(p => _workspaceService.CurrentWorkspace.GetRelativePath(p))
            .ToList();

        _workspaceService.UpdateExpandedFolders(expandedPaths);
    }

    private IEnumerable<string> CollectExpandedPaths(IEnumerable<FileTreeItemViewModel> items)
    {
        foreach (var item in items)
        {
            if (item.IsDirectory && item.IsExpanded)
            {
                yield return item.Path;
                foreach (var childPath in CollectExpandedPaths(item.Children))
                {
                    yield return childPath;
                }
            }
        }
    }

    /// <summary>Shows an error message (called by items).</summary>
    internal void ShowError(string message)
    {
        ErrorMessage = message;
    }

    /// <summary>Gets relative path from workspace root (exposed to items).</summary>
    internal string GetRelativePath(string absolutePath)
    {
        return _workspaceService.CurrentWorkspace?.GetRelativePath(absolutePath) ?? absolutePath;
    }

    #endregion

    #region Helper Methods

    private string? GetTargetDirectoryPath(FileTreeItemViewModel? item)
    {
        if (item == null)
            return _workspaceService.CurrentWorkspace?.RootPath;

        return item.IsDirectory ? item.Path : Path.GetDirectoryName(item.Path);
    }

    private async Task EnsureExpandedAsync(FileTreeItemViewModel folder)
    {
        if (!folder.IsExpanded)
        {
            folder.IsExpanded = true;
            await folder.LoadChildrenAsync();
        }
    }

    private FileTreeItemViewModel? FindItemByPath(string path)
    {
        return FindItemByPathRecursive(RootItems, path);
    }

    private FileTreeItemViewModel? FindItemByPathRecursive(
        IEnumerable<FileTreeItemViewModel> items,
        string path)
    {
        foreach (var item in items)
        {
            if (item.Path.Equals(path, StringComparison.OrdinalIgnoreCase))
                return item;

            if (item.IsDirectory && item.Children.Count > 0)
            {
                var found = FindItemByPathRecursive(item.Children, path);
                if (found != null)
                    return found;
            }
        }
        return null;
    }

    private void RemoveItemFromTree(FileTreeItemViewModel item)
    {
        if (RootItems.Remove(item))
            return;

        RemoveFromTreeRecursive(RootItems, item);
    }

    private bool RemoveFromTreeRecursive(
        IEnumerable<FileTreeItemViewModel> items,
        FileTreeItemViewModel target)
    {
        foreach (var item in items)
        {
            if (item.Children.Remove(target))
                return true;

            if (RemoveFromTreeRecursive(item.Children, target))
                return true;
        }
        return false;
    }

    #endregion

    #region Event Handlers

    private async void OnWorkspaceChanged(object? sender, WorkspaceChangedEventArgs e)
    {
        await Dispatcher.UIThread.InvokeAsync(async () =>
        {
            if (e.ChangeType == WorkspaceChangeType.Closed)
            {
                HasWorkspace = false;
                WorkspaceName = string.Empty;
                WorkspacePath = string.Empty;
                RootItems.Clear();
                SearchFilter = string.Empty;
            }
            else if (e.CurrentWorkspace != null)
            {
                await LoadWorkspaceAsync(e.CurrentWorkspace);
            }
        });
    }

    #endregion

    #region IDisposable

    public void Dispose()
    {
        if (_disposed) return;
        _disposed = true;

        _filterDebounceTimer.Dispose();
        _workspaceService.WorkspaceChanged -= OnWorkspaceChanged;
    }

    #endregion
}

#region Event Args

/// <summary>Event args when a file open is requested.</summary>
public sealed class FileOpenRequestedEventArgs : EventArgs
{
    public string FilePath { get; }

    public FileOpenRequestedEventArgs(string filePath)
    {
        FilePath = filePath;
    }
}

/// <summary>Event args when file attach to context is requested.</summary>
public sealed class FileAttachRequestedEventArgs : EventArgs
{
    public string FilePath { get; }

    public FileAttachRequestedEventArgs(string filePath)
    {
        FilePath = filePath;
    }
}

/// <summary>Event args when delete confirmation is needed.</summary>
public sealed class DeleteConfirmationEventArgs : EventArgs
{
    public FileTreeItemViewModel Item { get; }
    public bool Confirmed { get; set; }

    public DeleteConfirmationEventArgs(FileTreeItemViewModel item)
    {
        Item = item;
    }
}

#endregion
```

---

## Unit Testing Requirements

| Component | Test Count | Focus Areas |
|-----------|------------|-------------|
| Constructor | 2 | Subscriptions, initial load |
| Filter Debounce | 3 | Timer, apply, clear |
| OpenWorkspaceCommand | 2 | Success, cancel |
| CloseWorkspaceCommand | 1 | Clears state |
| RefreshCommand | 1 | Reloads tree |
| NewFileCommand | 3 | In folder, at root, unique name |
| NewFolderCommand | 3 | Insert order, unique name |
| RenameCommand | 2 | Selected, passed item |
| DeleteCommand | 2 | File, directory |
| CopyPathCommand | 2 | Absolute, relative |
| RevealInFinderCommand | 1 | Platform detection |
| AttachToContextCommand | 2 | Raises event, files only |
| LoadWorkspaceAsync | 3 | Load, filter, restore expanded |
| OnWorkspaceChanged | 2 | Opened, closed |
| **Total** | **29** | |

### Key Test Scenarios

```csharp
// Filter Debounce Tests
[Fact]
public async Task SearchFilter_DebouncesPreviousInput()
{
    _viewModel.SearchFilter = "t";
    _viewModel.SearchFilter = "te";
    _viewModel.SearchFilter = "test";
    
    await Task.Delay(100); // Before debounce
    Assert.False(_viewModel.IsFiltering);
    
    await Task.Delay(150); // After debounce
    // ApplyFilter should have been called once with "test"
}

// New File Tests
[Fact]
public async Task NewFileAsync_GeneratesUniqueName()
{
    await CreateFileAtPath("/workspace/untitled.txt");
    await CreateFileAtPath("/workspace/untitled-1.txt");

    await _viewModel.NewFileCommand.ExecuteAsync(null);

    Assert.Contains(RootItems, i => i.Name == "untitled-2.txt");
}

[Fact]
public async Task NewFileAsync_StartsInlineRename()
{
    await _viewModel.NewFileCommand.ExecuteAsync(null);

    Assert.True(RootItems.Last().IsRenaming);
}

// New Folder Tests
[Fact]
public async Task NewFolderAsync_InsertsBeforeFiles()
{
    // Setup: root has file.txt
    RootItems.Add(new FileTreeItemViewModel(_viewModel) { Name = "file.txt", ItemType = FileSystemItemType.File });

    await _viewModel.NewFolderCommand.ExecuteAsync(null);

    Assert.True(RootItems[0].IsDirectory);
}

// Workspace Changed Tests
[Fact]
public async Task OnWorkspaceChanged_Closed_ClearsState()
{
    _viewModel.HasWorkspace = true;
    _viewModel.RootItems.Add(CreateItem("test.cs"));

    RaiseWorkspaceChanged(WorkspaceChangeType.Closed);
    await Task.Delay(50);

    Assert.False(_viewModel.HasWorkspace);
    Assert.Empty(_viewModel.RootItems);
    Assert.Empty(_viewModel.SearchFilter);
}

// AttachToContext Tests
[Fact]
public void AttachToContextCommand_IgnoresDirectories()
{
    var folder = CreateFolderItem();
    FileAttachRequestedEventArgs? eventArgs = null;
    _viewModel.FileAttachRequested += (s, e) => eventArgs = e;

    _viewModel.AttachToContextCommand.Execute(folder);

    Assert.Null(eventArgs); // Should not fire
}

// Copy Path Tests
[Fact]
public async Task CopyRelativePathAsync_UsesWorkspaceRoot()
{
    _mockWorkspace.Setup(w => w.GetRelativePath("/workspace/src/file.cs"))
        .Returns("src/file.cs");
    var item = CreateItem("/workspace/src/file.cs");

    await _viewModel.CopyRelativePathCommand.ExecuteAsync(item);

    _mockClipboard.Verify(c => c.SetTextAsync("src/file.cs"), Times.Once);
}
```

---

## Files Summary

### Files to Create (1)

| File | Lines (approx) |
|------|----------------|
| `ViewModels/FileExplorerViewModel.cs` | 550 |

### Files to Modify (0)

No files need modification for v0.3.2b.

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | OpenWorkspaceCommand shows folder picker |
| AC-2 | CloseWorkspaceCommand clears tree and state |
| AC-3 | RefreshCommand reloads current workspace |
| AC-4 | NewFileCommand creates file with unique name |
| AC-5 | NewFolderCommand inserts folders before files |
| AC-6 | SearchFilter debounces 200ms |
| AC-7 | CopyPathCommand copies to clipboard |
| AC-8 | RevealInFinderCommand works on Mac/Win/Linux |
| AC-9 | AttachToContextCommand raises event for files only |
| AC-10 | WorkspaceChanged event updates tree state |

---

## Design Decisions

| Decision | Rationale |
|----------|-----------|
| 200ms debounce | Balance between responsiveness and performance |
| untitled.txt default | Simple default that suggests editing |
| Insert folders before files | Consistent with OS file managers |
| Relative paths for persistence | Portable across different machines |
| Fire-and-forget for events | Don't block UI for async handlers |

---

## Dependencies

| Part | Dependency Description |
|------|------------------------|
| v0.3.1d | IFileSystemService |
| v0.3.1e | IWorkspaceService |
| v0.3.2a | FileTreeItemViewModel |
| CommunityToolkit.Mvvm | ObservableProperty, RelayCommand |
| Avalonia | IStorageProvider, Dispatcher |

---

## Timeline Estimate

| Version | Estimated Effort |
|---------|------------------|
| v0.3.2b | 1 day |
