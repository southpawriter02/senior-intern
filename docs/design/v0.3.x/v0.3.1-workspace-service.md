# Design Specification: The Senior Intern v0.3.1 "Workspace Service"

## Executive Summary

This document provides a comprehensive design specification for v0.3.1, the first sub-version of v0.3.0 "Workspace Awareness". This version establishes the workspace abstraction layer that manages open project folders, tracks file state, provides file system operations, and persists recent workspaces. It lays the foundation for the file explorer, code editor, and context attachment features in subsequent versions.

### v0.3.1 Scope (from v0.3.0 Design Document)
- Workspace model and service for managing project folders
- File system service for file/directory operations
- Recent workspaces persistence and retrieval
- Language detection utility for file types
- Database entities for workspace and file context history
- File watching for live updates
- .gitignore pattern support

### Dependencies
- **v0.2.0** must be complete (Memory Management with database foundation)
- Specifically requires v0.2.1 (database), v0.2.2 (persistence patterns)

---

## Sub-Part Breakdown

| Part | Name | Focus |
|------|------|-------|
| v0.3.1a | Core Models | Workspace, FileSystemItem, FileContext models |
| v0.3.1b | Database Entities | RecentWorkspaceEntity, FileContextEntity, migrations |
| v0.3.1c | Language Detection | LanguageDetector utility, extension mapping |
| v0.3.1d | File System Service | IFileSystemService implementation, file watching |
| v0.3.1e | Workspace Service | IWorkspaceService implementation, state management |
| v0.3.1f | Repository Layer | IWorkspaceRepository, persistence operations |

---

## Architecture Overview

### Component Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         Application Layer (Desktop)                          │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                    MainWindowViewModel (future)                       │    │
│  │                              │                                         │    │
│  │                              ▼                                         │    │
│  │  ┌─────────────────────────────────────────────────────────────┐     │    │
│  │  │              FileExplorerViewModel (v0.3.2)                   │     │    │
│  │  └─────────────────────────────────────────────────────────────┘     │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                            Service Layer                                      │
│  ┌───────────────────────────────┐    ┌───────────────────────────────┐     │
│  │       IWorkspaceService        │    │      IFileSystemService        │     │
│  ├───────────────────────────────┤    ├───────────────────────────────┤     │
│  │ • CurrentWorkspace             │    │ • GetDirectoryContentsAsync   │     │
│  │ • OpenWorkspaceAsync           │    │ • ReadFileAsync               │     │
│  │ • CloseWorkspaceAsync          │    │ • WriteFileAsync              │     │
│  │ • GetRecentWorkspacesAsync     │    │ • WatchDirectory              │     │
│  │ • SaveWorkspaceStateAsync      │    │ • LoadGitIgnorePatternsAsync  │     │
│  │ • RestoreLastWorkspaceAsync    │    │ • ShouldIgnore                │     │
│  └───────────────────────────────┘    └───────────────────────────────┘     │
│                 │                                    │                        │
│                 ▼                                    ▼                        │
│  ┌───────────────────────────────────────────────────────────────────┐      │
│  │                      Event System                                    │      │
│  │  • WorkspaceChanged          • FileSystemChangeEvent                │      │
│  │  • WorkspaceStateChanged                                            │      │
│  └───────────────────────────────────────────────────────────────────┘      │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                             Data Layer                                        │
│  ┌───────────────────────────────┐    ┌───────────────────────────────┐     │
│  │    IWorkspaceRepository        │    │       LanguageDetector         │     │
│  ├───────────────────────────────┤    ├───────────────────────────────┤     │
│  │ • GetRecentAsync               │    │ • DetectByExtension           │     │
│  │ • AddOrUpdateAsync             │    │ • DetectByFileName            │     │
│  │ • RemoveAsync                  │    │ • GetAllSupportedExtensions   │     │
│  │ • GetByPathAsync               │    │                                │     │
│  └───────────────────────────────┘    └───────────────────────────────┘     │
│                 │                                                             │
│                 ▼                                                             │
│  ┌───────────────────────────────────────────────────────────────────┐      │
│  │                    SeniorInternDbContext                            │      │
│  │  ┌─────────────────────┐    ┌─────────────────────────────────┐   │      │
│  │  │  RecentWorkspaces    │    │     FileContextHistory           │   │      │
│  │  └─────────────────────┘    └─────────────────────────────────┘   │      │
│  └───────────────────────────────────────────────────────────────────┘      │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Data Flow: Opening a Workspace

```
User selects folder
        │
        ▼
┌─────────────────────┐
│ IWorkspaceService   │
│ .OpenWorkspaceAsync │
└─────────────────────┘
        │
        ├──────────────────────────────────────┐
        ▼                                      ▼
┌─────────────────────┐              ┌─────────────────────┐
│ Validate path       │              │ IFileSystemService   │
│ (exists, readable)  │              │ .LoadGitIgnoreAsync  │
└─────────────────────┘              └─────────────────────┘
        │                                      │
        ▼                                      ▼
┌─────────────────────┐              ┌─────────────────────┐
│ Create Workspace    │              │ Parse .gitignore    │
│ model               │              │ patterns            │
└─────────────────────┘              └─────────────────────┘
        │                                      │
        ▼                                      │
┌─────────────────────┐                        │
│ IWorkspaceRepository│◄───────────────────────┘
│ .AddOrUpdateAsync   │
└─────────────────────┘
        │
        ▼
┌─────────────────────┐
│ Start file watcher  │
│ for workspace root  │
└─────────────────────┘
        │
        ▼
┌─────────────────────┐
│ Raise Workspace     │
│ Changed event       │
└─────────────────────┘
        │
        ▼
┌─────────────────────┐
│ Update Current      │
│ Workspace property  │
└─────────────────────┘
```

---

## v0.3.1a: Core Models

### Objective
Define the core domain models for workspaces, file system items, and file context.

### Workspace Model

```csharp
// src/SeniorIntern.Core/Models/Workspace.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Represents an open project workspace (folder).
/// </summary>
public sealed class Workspace
{
    /// <summary>
    /// Unique identifier for the workspace.
    /// </summary>
    public Guid Id { get; init; } = Guid.NewGuid();

    /// <summary>
    /// Optional custom name for the workspace.
    /// If empty, DisplayName falls back to the folder name.
    /// </summary>
    public string Name { get; set; } = string.Empty;

    /// <summary>
    /// Absolute path to the workspace root directory.
    /// </summary>
    public required string RootPath { get; init; }

    /// <summary>
    /// When the workspace was first opened.
    /// </summary>
    public DateTime OpenedAt { get; init; } = DateTime.UtcNow;

    /// <summary>
    /// When the workspace was last accessed.
    /// Updated each time the workspace is opened or interacted with.
    /// </summary>
    public DateTime LastAccessedAt { get; set; } = DateTime.UtcNow;

    /// <summary>
    /// List of currently open file paths (relative to RootPath).
    /// </summary>
    public IReadOnlyList<string> OpenFiles { get; set; } = [];

    /// <summary>
    /// Currently active/focused file path (relative to RootPath).
    /// </summary>
    public string? ActiveFilePath { get; set; }

    /// <summary>
    /// List of expanded folder paths in the explorer (relative to RootPath).
    /// Used to restore tree state.
    /// </summary>
    public IReadOnlyList<string> ExpandedFolders { get; set; } = [];

    /// <summary>
    /// Whether this workspace is pinned in the recent list.
    /// </summary>
    public bool IsPinned { get; set; }

    /// <summary>
    /// Git ignore patterns loaded from .gitignore files in the workspace.
    /// </summary>
    public IReadOnlyList<string> GitIgnorePatterns { get; set; } = [];

    /// <summary>
    /// Display name for UI (custom name or folder name).
    /// </summary>
    public string DisplayName => string.IsNullOrWhiteSpace(Name)
        ? Path.GetFileName(RootPath) ?? RootPath
        : Name;

    /// <summary>
    /// Whether the workspace root directory exists.
    /// </summary>
    public bool Exists => Directory.Exists(RootPath);

    /// <summary>
    /// Gets the absolute path for a relative file path.
    /// </summary>
    public string GetAbsolutePath(string relativePath)
        => Path.GetFullPath(Path.Combine(RootPath, relativePath));

    /// <summary>
    /// Gets the relative path for an absolute file path.
    /// </summary>
    public string GetRelativePath(string absolutePath)
        => Path.GetRelativePath(RootPath, absolutePath);
}
```

### FileSystemItem Model

```csharp
// src/SeniorIntern.Core/Models/FileSystemItem.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Represents a file or directory in the file system.
/// </summary>
public sealed class FileSystemItem
{
    /// <summary>
    /// Absolute path to the item.
    /// </summary>
    public required string Path { get; init; }

    /// <summary>
    /// File or folder name.
    /// </summary>
    public required string Name { get; init; }

    /// <summary>
    /// Type of file system item.
    /// </summary>
    public required FileSystemItemType Type { get; init; }

    /// <summary>
    /// File size in bytes (null for directories).
    /// </summary>
    public long? Size { get; init; }

    /// <summary>
    /// Last modified timestamp.
    /// </summary>
    public DateTime ModifiedAt { get; init; }

    /// <summary>
    /// Last accessed timestamp.
    /// </summary>
    public DateTime AccessedAt { get; init; }

    /// <summary>
    /// Creation timestamp.
    /// </summary>
    public DateTime CreatedAt { get; init; }

    /// <summary>
    /// Whether the item is hidden (starts with . or has hidden attribute).
    /// </summary>
    public bool IsHidden { get; init; }

    /// <summary>
    /// Whether the item is read-only.
    /// </summary>
    public bool IsReadOnly { get; init; }

    /// <summary>
    /// For directories: whether the directory has any children.
    /// Used for lazy loading indicator.
    /// </summary>
    public bool HasChildren { get; init; }

    /// <summary>
    /// For directories: current expansion state in tree view.
    /// </summary>
    public bool IsExpanded { get; set; }

    /// <summary>
    /// For directories: loaded children (null if not loaded yet).
    /// </summary>
    public IReadOnlyList<FileSystemItem>? Children { get; set; }

    /// <summary>
    /// File extension including the dot (e.g., ".cs").
    /// Empty string for directories.
    /// </summary>
    public string Extension => Type == FileSystemItemType.File
        ? System.IO.Path.GetExtension(Path)
        : string.Empty;

    /// <summary>
    /// Detected programming language based on extension.
    /// </summary>
    public string? Language => Type == FileSystemItemType.File
        ? LanguageDetector.DetectByExtension(Extension)
        : null;

    /// <summary>
    /// Whether this is a directory.
    /// </summary>
    public bool IsDirectory => Type == FileSystemItemType.Directory;

    /// <summary>
    /// Whether this is a file.
    /// </summary>
    public bool IsFile => Type == FileSystemItemType.File;

    /// <summary>
    /// Human-readable file size (e.g., "1.2 KB").
    /// </summary>
    public string FormattedSize => Size.HasValue
        ? FormatFileSize(Size.Value)
        : string.Empty;

    private static string FormatFileSize(long bytes)
    {
        string[] suffixes = ["B", "KB", "MB", "GB", "TB"];
        int suffixIndex = 0;
        double size = bytes;

        while (size >= 1024 && suffixIndex < suffixes.Length - 1)
        {
            size /= 1024;
            suffixIndex++;
        }

        return suffixIndex == 0
            ? $"{size:F0} {suffixes[suffixIndex]}"
            : $"{size:F1} {suffixes[suffixIndex]}";
    }
}

/// <summary>
/// Type of file system item.
/// </summary>
public enum FileSystemItemType
{
    /// <summary>
    /// Regular file.
    /// </summary>
    File,

    /// <summary>
    /// Directory/folder.
    /// </summary>
    Directory,

    /// <summary>
    /// Symbolic link.
    /// </summary>
    SymbolicLink
}
```

### FileContext Model

```csharp
// src/SeniorIntern.Core/Models/FileContext.cs
namespace SeniorIntern.Core.Models;

/// <summary>
/// Represents file content attached to a chat message as context.
/// </summary>
public sealed class FileContext
{
    /// <summary>
    /// Unique identifier for the context attachment.
    /// </summary>
    public Guid Id { get; init; } = Guid.NewGuid();

    /// <summary>
    /// Absolute path to the file.
    /// </summary>
    public required string FilePath { get; init; }

    /// <summary>
    /// File name extracted from the path.
    /// </summary>
    public string FileName => Path.GetFileName(FilePath);

    /// <summary>
    /// The actual file content (or selection content).
    /// </summary>
    public required string Content { get; init; }

    /// <summary>
    /// Detected programming language.
    /// </summary>
    public string? Language { get; init; }

    /// <summary>
    /// Total line count of the content.
    /// </summary>
    public int LineCount { get; init; }

    /// <summary>
    /// Estimated token count for LLM context budget.
    /// </summary>
    public int EstimatedTokens { get; init; }

    /// <summary>
    /// When the context was attached.
    /// </summary>
    public DateTime AttachedAt { get; init; } = DateTime.UtcNow;

    /// <summary>
    /// Starting line number if partial content (1-indexed).
    /// Null if entire file is attached.
    /// </summary>
    public int? StartLine { get; init; }

    /// <summary>
    /// Ending line number if partial content (1-indexed, inclusive).
    /// Null if entire file is attached.
    /// </summary>
    public int? EndLine { get; init; }

    /// <summary>
    /// Hash of the content for detecting changes.
    /// </summary>
    public string ContentHash { get; init; } = string.Empty;

    /// <summary>
    /// Whether this is a partial file (selection) or full file.
    /// </summary>
    public bool IsPartialContent => StartLine.HasValue || EndLine.HasValue;

    /// <summary>
    /// Display label for UI showing file name and line range if applicable.
    /// </summary>
    public string DisplayLabel => IsPartialContent
        ? $"{FileName} (lines {StartLine}-{EndLine})"
        : FileName;

    /// <summary>
    /// Creates a FileContext from a file path.
    /// </summary>
    public static FileContext FromFile(string filePath, string content)
    {
        var lineCount = content.Count(c => c == '\n') + 1;
        var language = LanguageDetector.DetectByFileName(Path.GetFileName(filePath));

        return new FileContext
        {
            FilePath = filePath,
            Content = content,
            Language = language,
            LineCount = lineCount,
            EstimatedTokens = TokenEstimator.Estimate(content),
            ContentHash = ComputeHash(content)
        };
    }

    /// <summary>
    /// Creates a FileContext from a code selection.
    /// </summary>
    public static FileContext FromSelection(
        string filePath,
        string content,
        int startLine,
        int endLine)
    {
        var lineCount = endLine - startLine + 1;
        var language = LanguageDetector.DetectByFileName(Path.GetFileName(filePath));

        return new FileContext
        {
            FilePath = filePath,
            Content = content,
            Language = language,
            LineCount = lineCount,
            EstimatedTokens = TokenEstimator.Estimate(content),
            StartLine = startLine,
            EndLine = endLine,
            ContentHash = ComputeHash(content)
        };
    }

    private static string ComputeHash(string content)
    {
        var bytes = System.Text.Encoding.UTF8.GetBytes(content);
        var hashBytes = System.Security.Cryptography.SHA256.HashData(bytes);
        return Convert.ToHexString(hashBytes)[..16]; // First 16 chars is sufficient
    }
}
```

### Token Estimator Utility

```csharp
// src/SeniorIntern.Core/Utilities/TokenEstimator.cs
namespace SeniorIntern.Core.Utilities;

/// <summary>
/// Estimates token count for content to help manage LLM context budgets.
/// </summary>
public static class TokenEstimator
{
    /// <summary>
    /// Average characters per token. This varies by language and content type.
    /// Code typically has more symbols resulting in more tokens per character.
    /// </summary>
    private const double CharsPerToken = 3.5;

    /// <summary>
    /// Estimates the number of tokens in the given content.
    /// </summary>
    /// <param name="content">The text content to estimate.</param>
    /// <returns>Estimated token count.</returns>
    public static int Estimate(string content)
    {
        if (string.IsNullOrEmpty(content))
            return 0;

        // Rough estimate based on character count
        // More accurate would require actual tokenizer, but this is sufficient for UI
        return (int)Math.Ceiling(content.Length / CharsPerToken);
    }

    /// <summary>
    /// Estimates tokens with language-specific adjustment.
    /// Code languages tend to have more tokens per character due to symbols.
    /// </summary>
    public static int Estimate(string content, string? language)
    {
        if (string.IsNullOrEmpty(content))
            return 0;

        var multiplier = language switch
        {
            "csharp" or "java" or "cpp" or "c" => 1.2, // More symbols
            "python" or "ruby" => 1.0,                  // More readable
            "json" or "xml" or "html" => 1.3,          // Verbose markup
            "markdown" => 0.9,                          // Mostly prose
            _ => 1.0
        };

        return (int)Math.Ceiling(content.Length / CharsPerToken * multiplier);
    }
}
```

### Files to Create (v0.3.1a)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Models/Workspace.cs` | Workspace model |
| `src/SeniorIntern.Core/Models/FileSystemItem.cs` | File/folder model |
| `src/SeniorIntern.Core/Models/FileContext.cs` | Attached file context model |
| `src/SeniorIntern.Core/Utilities/TokenEstimator.cs` | Token estimation utility |

---

## v0.3.1b: Database Entities

### Objective
Create database entities and migrations for persisting workspace and file context data.

### RecentWorkspaceEntity

```csharp
// src/SeniorIntern.Core/Entities/RecentWorkspaceEntity.cs
namespace SeniorIntern.Core.Entities;

/// <summary>
/// Database entity for storing recent workspace information.
/// </summary>
public sealed class RecentWorkspaceEntity
{
    /// <summary>
    /// Unique identifier.
    /// </summary>
    public Guid Id { get; set; }

    /// <summary>
    /// Optional custom name for the workspace.
    /// </summary>
    public string? Name { get; set; }

    /// <summary>
    /// Absolute path to workspace root. Must be unique.
    /// </summary>
    public required string RootPath { get; set; }

    /// <summary>
    /// When the workspace was last accessed.
    /// </summary>
    public DateTime LastAccessedAt { get; set; }

    /// <summary>
    /// JSON array of open file paths (relative).
    /// </summary>
    public string? OpenFilesJson { get; set; }

    /// <summary>
    /// Currently active file path (relative).
    /// </summary>
    public string? ActiveFilePath { get; set; }

    /// <summary>
    /// JSON array of expanded folder paths (relative).
    /// </summary>
    public string? ExpandedFoldersJson { get; set; }

    /// <summary>
    /// Whether this workspace is pinned.
    /// </summary>
    public bool IsPinned { get; set; }

    /// <summary>
    /// Converts entity to domain model.
    /// </summary>
    public Workspace ToWorkspace()
    {
        return new Workspace
        {
            Id = Id,
            Name = Name ?? string.Empty,
            RootPath = RootPath,
            LastAccessedAt = LastAccessedAt,
            OpenFiles = DeserializeStringList(OpenFilesJson),
            ActiveFilePath = ActiveFilePath,
            ExpandedFolders = DeserializeStringList(ExpandedFoldersJson),
            IsPinned = IsPinned
        };
    }

    /// <summary>
    /// Creates entity from domain model.
    /// </summary>
    public static RecentWorkspaceEntity FromWorkspace(Workspace workspace)
    {
        return new RecentWorkspaceEntity
        {
            Id = workspace.Id,
            Name = string.IsNullOrWhiteSpace(workspace.Name) ? null : workspace.Name,
            RootPath = workspace.RootPath,
            LastAccessedAt = workspace.LastAccessedAt,
            OpenFilesJson = SerializeStringList(workspace.OpenFiles),
            ActiveFilePath = workspace.ActiveFilePath,
            ExpandedFoldersJson = SerializeStringList(workspace.ExpandedFolders),
            IsPinned = workspace.IsPinned
        };
    }

    private static string? SerializeStringList(IReadOnlyList<string> list)
    {
        if (list.Count == 0) return null;
        return System.Text.Json.JsonSerializer.Serialize(list);
    }

    private static IReadOnlyList<string> DeserializeStringList(string? json)
    {
        if (string.IsNullOrEmpty(json)) return [];
        try
        {
            return System.Text.Json.JsonSerializer.Deserialize<List<string>>(json) ?? [];
        }
        catch
        {
            return [];
        }
    }
}
```

### FileContextEntity

```csharp
// src/SeniorIntern.Core/Entities/FileContextEntity.cs
namespace SeniorIntern.Core.Entities;

/// <summary>
/// Database entity for file context history attached to messages.
/// </summary>
public sealed class FileContextEntity
{
    /// <summary>
    /// Unique identifier.
    /// </summary>
    public Guid Id { get; set; }

    /// <summary>
    /// The conversation this context belongs to.
    /// </summary>
    public Guid ConversationId { get; set; }

    /// <summary>
    /// The message this context was attached to.
    /// </summary>
    public Guid MessageId { get; set; }

    /// <summary>
    /// Absolute file path.
    /// </summary>
    public required string FilePath { get; set; }

    /// <summary>
    /// File name (for display when file is deleted/moved).
    /// </summary>
    public required string FileName { get; set; }

    /// <summary>
    /// Detected programming language.
    /// </summary>
    public string? Language { get; set; }

    /// <summary>
    /// Hash of content at time of attachment.
    /// </summary>
    public required string ContentHash { get; set; }

    /// <summary>
    /// Line count of attached content.
    /// </summary>
    public int LineCount { get; set; }

    /// <summary>
    /// Estimated token count.
    /// </summary>
    public int EstimatedTokens { get; set; }

    /// <summary>
    /// Starting line if partial content.
    /// </summary>
    public int? StartLine { get; set; }

    /// <summary>
    /// Ending line if partial content.
    /// </summary>
    public int? EndLine { get; set; }

    /// <summary>
    /// When the context was attached.
    /// </summary>
    public DateTime AttachedAt { get; set; }

    // Navigation properties
    public ConversationEntity? Conversation { get; set; }
    public MessageEntity? Message { get; set; }
}
```

### Entity Configurations

```csharp
// src/SeniorIntern.Data/Configurations/RecentWorkspaceConfiguration.cs
namespace SeniorIntern.Data.Configurations;

using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using SeniorIntern.Core.Entities;

public sealed class RecentWorkspaceConfiguration : IEntityTypeConfiguration<RecentWorkspaceEntity>
{
    public void Configure(EntityTypeBuilder<RecentWorkspaceEntity> builder)
    {
        builder.ToTable("RecentWorkspaces");

        builder.HasKey(e => e.Id);

        builder.Property(e => e.RootPath)
            .IsRequired()
            .HasMaxLength(1024);

        builder.HasIndex(e => e.RootPath)
            .IsUnique();

        builder.HasIndex(e => e.LastAccessedAt)
            .IsDescending();

        builder.Property(e => e.Name)
            .HasMaxLength(256);

        builder.Property(e => e.ActiveFilePath)
            .HasMaxLength(1024);

        builder.Property(e => e.OpenFilesJson)
            .HasColumnType("TEXT");

        builder.Property(e => e.ExpandedFoldersJson)
            .HasColumnType("TEXT");
    }
}
```

```csharp
// src/SeniorIntern.Data/Configurations/FileContextConfiguration.cs
namespace SeniorIntern.Data.Configurations;

using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using SeniorIntern.Core.Entities;

public sealed class FileContextConfiguration : IEntityTypeConfiguration<FileContextEntity>
{
    public void Configure(EntityTypeBuilder<FileContextEntity> builder)
    {
        builder.ToTable("FileContextHistory");

        builder.HasKey(e => e.Id);

        builder.Property(e => e.FilePath)
            .IsRequired()
            .HasMaxLength(1024);

        builder.Property(e => e.FileName)
            .IsRequired()
            .HasMaxLength(256);

        builder.Property(e => e.Language)
            .HasMaxLength(50);

        builder.Property(e => e.ContentHash)
            .IsRequired()
            .HasMaxLength(64);

        builder.HasIndex(e => e.ConversationId);
        builder.HasIndex(e => e.MessageId);
        builder.HasIndex(e => e.AttachedAt);

        builder.HasOne(e => e.Conversation)
            .WithMany()
            .HasForeignKey(e => e.ConversationId)
            .OnDelete(DeleteBehavior.Cascade);

        builder.HasOne(e => e.Message)
            .WithMany()
            .HasForeignKey(e => e.MessageId)
            .OnDelete(DeleteBehavior.Cascade);
    }
}
```

### Migration

```csharp
// src/SeniorIntern.Data/Migrations/XXXXXXXX_AddWorkspaceEntities.cs
namespace SeniorIntern.Data.Migrations;

using Microsoft.EntityFrameworkCore.Migrations;

public partial class AddWorkspaceEntities : Migration
{
    protected override void Up(MigrationBuilder migrationBuilder)
    {
        migrationBuilder.CreateTable(
            name: "RecentWorkspaces",
            columns: table => new
            {
                Id = table.Column<Guid>(type: "TEXT", nullable: false),
                Name = table.Column<string>(type: "TEXT", maxLength: 256, nullable: true),
                RootPath = table.Column<string>(type: "TEXT", maxLength: 1024, nullable: false),
                LastAccessedAt = table.Column<DateTime>(type: "TEXT", nullable: false),
                OpenFilesJson = table.Column<string>(type: "TEXT", nullable: true),
                ActiveFilePath = table.Column<string>(type: "TEXT", maxLength: 1024, nullable: true),
                ExpandedFoldersJson = table.Column<string>(type: "TEXT", nullable: true),
                IsPinned = table.Column<bool>(type: "INTEGER", nullable: false, defaultValue: false)
            },
            constraints: table =>
            {
                table.PrimaryKey("PK_RecentWorkspaces", x => x.Id);
            });

        migrationBuilder.CreateIndex(
            name: "IX_RecentWorkspaces_RootPath",
            table: "RecentWorkspaces",
            column: "RootPath",
            unique: true);

        migrationBuilder.CreateIndex(
            name: "IX_RecentWorkspaces_LastAccessedAt",
            table: "RecentWorkspaces",
            column: "LastAccessedAt",
            descending: new[] { true });

        migrationBuilder.CreateTable(
            name: "FileContextHistory",
            columns: table => new
            {
                Id = table.Column<Guid>(type: "TEXT", nullable: false),
                ConversationId = table.Column<Guid>(type: "TEXT", nullable: false),
                MessageId = table.Column<Guid>(type: "TEXT", nullable: false),
                FilePath = table.Column<string>(type: "TEXT", maxLength: 1024, nullable: false),
                FileName = table.Column<string>(type: "TEXT", maxLength: 256, nullable: false),
                Language = table.Column<string>(type: "TEXT", maxLength: 50, nullable: true),
                ContentHash = table.Column<string>(type: "TEXT", maxLength: 64, nullable: false),
                LineCount = table.Column<int>(type: "INTEGER", nullable: false),
                EstimatedTokens = table.Column<int>(type: "INTEGER", nullable: false),
                StartLine = table.Column<int>(type: "INTEGER", nullable: true),
                EndLine = table.Column<int>(type: "INTEGER", nullable: true),
                AttachedAt = table.Column<DateTime>(type: "TEXT", nullable: false)
            },
            constraints: table =>
            {
                table.PrimaryKey("PK_FileContextHistory", x => x.Id);
                table.ForeignKey(
                    name: "FK_FileContextHistory_Conversations_ConversationId",
                    column: x => x.ConversationId,
                    principalTable: "Conversations",
                    principalColumn: "Id",
                    onDelete: ReferentialAction.Cascade);
                table.ForeignKey(
                    name: "FK_FileContextHistory_Messages_MessageId",
                    column: x => x.MessageId,
                    principalTable: "Messages",
                    principalColumn: "Id",
                    onDelete: ReferentialAction.Cascade);
            });

        migrationBuilder.CreateIndex(
            name: "IX_FileContextHistory_ConversationId",
            table: "FileContextHistory",
            column: "ConversationId");

        migrationBuilder.CreateIndex(
            name: "IX_FileContextHistory_MessageId",
            table: "FileContextHistory",
            column: "MessageId");

        migrationBuilder.CreateIndex(
            name: "IX_FileContextHistory_AttachedAt",
            table: "FileContextHistory",
            column: "AttachedAt");
    }

    protected override void Down(MigrationBuilder migrationBuilder)
    {
        migrationBuilder.DropTable(name: "FileContextHistory");
        migrationBuilder.DropTable(name: "RecentWorkspaces");
    }
}
```

### Files to Create (v0.3.1b)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Entities/RecentWorkspaceEntity.cs` | Workspace database entity |
| `src/SeniorIntern.Core/Entities/FileContextEntity.cs` | File context database entity |
| `src/SeniorIntern.Data/Configurations/RecentWorkspaceConfiguration.cs` | EF configuration |
| `src/SeniorIntern.Data/Configurations/FileContextConfiguration.cs` | EF configuration |
| `src/SeniorIntern.Data/Migrations/XXXXXXXX_AddWorkspaceEntities.cs` | Database migration |

### Files to Modify (v0.3.1b)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Data/SeniorInternDbContext.cs` | Add DbSets for new entities |

---

## v0.3.1c: Language Detection

### Objective
Implement a comprehensive language detection utility based on file extensions and special file names.

### LanguageDetector Implementation

```csharp
// src/SeniorIntern.Core/Utilities/LanguageDetector.cs
namespace SeniorIntern.Core.Utilities;

/// <summary>
/// Detects programming language based on file extension or name.
/// </summary>
public static class LanguageDetector
{
    /// <summary>
    /// Maps file extensions to language identifiers.
    /// Language identifiers follow VSCode/TextMate conventions.
    /// </summary>
    private static readonly Dictionary<string, string> ExtensionMap = new(StringComparer.OrdinalIgnoreCase)
    {
        // .NET / C#
        [".cs"] = "csharp",
        [".csx"] = "csharp",
        [".vb"] = "vb",
        [".fs"] = "fsharp",
        [".fsx"] = "fsharp",
        [".csproj"] = "xml",
        [".fsproj"] = "xml",
        [".vbproj"] = "xml",
        [".sln"] = "text",
        [".props"] = "xml",
        [".targets"] = "xml",
        [".nuspec"] = "xml",

        // Avalonia / XAML
        [".axaml"] = "xml",
        [".xaml"] = "xml",
        [".paml"] = "xml",

        // JavaScript / TypeScript
        [".js"] = "javascript",
        [".mjs"] = "javascript",
        [".cjs"] = "javascript",
        [".jsx"] = "javascriptreact",
        [".ts"] = "typescript",
        [".mts"] = "typescript",
        [".cts"] = "typescript",
        [".tsx"] = "typescriptreact",

        // Python
        [".py"] = "python",
        [".pyi"] = "python",
        [".pyw"] = "python",
        [".pyx"] = "python",

        // Ruby
        [".rb"] = "ruby",
        [".rake"] = "ruby",
        [".gemspec"] = "ruby",

        // Go
        [".go"] = "go",
        [".mod"] = "go",
        [".sum"] = "text",

        // Rust
        [".rs"] = "rust",
        [".toml"] = "toml",

        // Java / Kotlin
        [".java"] = "java",
        [".kt"] = "kotlin",
        [".kts"] = "kotlin",
        [".gradle"] = "groovy",

        // Swift / Objective-C
        [".swift"] = "swift",
        [".m"] = "objective-c",
        [".mm"] = "objective-cpp",

        // C / C++
        [".c"] = "c",
        [".h"] = "c",
        [".cpp"] = "cpp",
        [".cc"] = "cpp",
        [".cxx"] = "cpp",
        [".hpp"] = "cpp",
        [".hxx"] = "cpp",

        // Web
        [".html"] = "html",
        [".htm"] = "html",
        [".xhtml"] = "html",
        [".css"] = "css",
        [".scss"] = "scss",
        [".sass"] = "sass",
        [".less"] = "less",
        [".vue"] = "vue",
        [".svelte"] = "svelte",

        // Data / Config
        [".json"] = "json",
        [".jsonc"] = "jsonc",
        [".json5"] = "json5",
        [".xml"] = "xml",
        [".xsl"] = "xml",
        [".xslt"] = "xml",
        [".yaml"] = "yaml",
        [".yml"] = "yaml",
        [".toml"] = "toml",
        [".ini"] = "ini",
        [".cfg"] = "ini",
        [".conf"] = "ini",
        [".config"] = "xml",
        [".env"] = "properties",
        [".properties"] = "properties",

        // Shell / Scripts
        [".sh"] = "shellscript",
        [".bash"] = "shellscript",
        [".zsh"] = "shellscript",
        [".fish"] = "shellscript",
        [".ps1"] = "powershell",
        [".psm1"] = "powershell",
        [".psd1"] = "powershell",
        [".bat"] = "bat",
        [".cmd"] = "bat",

        // Markup / Documentation
        [".md"] = "markdown",
        [".mdx"] = "mdx",
        [".markdown"] = "markdown",
        [".rst"] = "restructuredtext",
        [".tex"] = "latex",
        [".ltx"] = "latex",
        [".bib"] = "bibtex",

        // Database
        [".sql"] = "sql",
        [".pgsql"] = "sql",
        [".mysql"] = "sql",

        // Docker / Containers
        [".dockerfile"] = "dockerfile",
        [".containerfile"] = "dockerfile",

        // Ignore files
        [".gitignore"] = "ignore",
        [".dockerignore"] = "ignore",
        [".npmignore"] = "ignore",
        [".eslintignore"] = "ignore",

        // Other
        [".r"] = "r",
        [".R"] = "r",
        [".lua"] = "lua",
        [".pl"] = "perl",
        [".pm"] = "perl",
        [".php"] = "php",
        [".scala"] = "scala",
        [".clj"] = "clojure",
        [".cljs"] = "clojure",
        [".erl"] = "erlang",
        [".ex"] = "elixir",
        [".exs"] = "elixir",
        [".hs"] = "haskell",
        [".ml"] = "ocaml",
        [".mli"] = "ocaml",
        [".dart"] = "dart",
        [".graphql"] = "graphql",
        [".gql"] = "graphql",
        [".proto"] = "protobuf",
        [".tf"] = "terraform",
        [".tfvars"] = "terraform",
    };

    /// <summary>
    /// Maps special file names (without extension) to language identifiers.
    /// </summary>
    private static readonly Dictionary<string, string> FileNameMap = new(StringComparer.OrdinalIgnoreCase)
    {
        ["Dockerfile"] = "dockerfile",
        ["Containerfile"] = "dockerfile",
        ["Makefile"] = "makefile",
        ["GNUmakefile"] = "makefile",
        ["makefile"] = "makefile",
        ["Rakefile"] = "ruby",
        ["Gemfile"] = "ruby",
        ["Podfile"] = "ruby",
        ["Vagrantfile"] = "ruby",
        ["CMakeLists.txt"] = "cmake",
        ["Jenkinsfile"] = "groovy",
        ["Procfile"] = "text",
        [".gitattributes"] = "properties",
        [".editorconfig"] = "ini",
        [".prettierrc"] = "json",
        [".eslintrc"] = "json",
        [".babelrc"] = "json",
        ["tsconfig.json"] = "jsonc",
        ["jsconfig.json"] = "jsonc",
        ["package.json"] = "json",
        ["composer.json"] = "json",
        ["Cargo.toml"] = "toml",
        ["go.mod"] = "go",
        ["requirements.txt"] = "pip-requirements",
        ["setup.py"] = "python",
        ["setup.cfg"] = "ini",
        ["pyproject.toml"] = "toml",
    };

    /// <summary>
    /// Detects the programming language based on file extension.
    /// </summary>
    /// <param name="extension">The file extension including the dot (e.g., ".cs").</param>
    /// <returns>The language identifier or null if not recognized.</returns>
    public static string? DetectByExtension(string? extension)
    {
        if (string.IsNullOrEmpty(extension))
            return null;

        return ExtensionMap.TryGetValue(extension, out var language)
            ? language
            : null;
    }

    /// <summary>
    /// Detects the programming language based on file name.
    /// Checks special file names first, then falls back to extension.
    /// </summary>
    /// <param name="fileName">The file name (e.g., "Program.cs" or "Dockerfile").</param>
    /// <returns>The language identifier or null if not recognized.</returns>
    public static string? DetectByFileName(string? fileName)
    {
        if (string.IsNullOrEmpty(fileName))
            return null;

        // Check special file names first
        if (FileNameMap.TryGetValue(fileName, out var language))
            return language;

        // Fall back to extension
        var extension = Path.GetExtension(fileName);
        return DetectByExtension(extension);
    }

    /// <summary>
    /// Gets all supported file extensions.
    /// </summary>
    public static IReadOnlyCollection<string> GetAllSupportedExtensions()
        => ExtensionMap.Keys;

    /// <summary>
    /// Gets all special file names that have language mappings.
    /// </summary>
    public static IReadOnlyCollection<string> GetAllSpecialFileNames()
        => FileNameMap.Keys;

    /// <summary>
    /// Gets all unique language identifiers.
    /// </summary>
    public static IReadOnlyCollection<string> GetAllLanguages()
        => ExtensionMap.Values.Concat(FileNameMap.Values).Distinct().ToList();

    /// <summary>
    /// Gets a human-readable display name for a language identifier.
    /// </summary>
    public static string GetDisplayName(string? language)
    {
        if (string.IsNullOrEmpty(language))
            return "Plain Text";

        return language switch
        {
            "csharp" => "C#",
            "fsharp" => "F#",
            "javascript" => "JavaScript",
            "javascriptreact" => "JavaScript (React)",
            "typescript" => "TypeScript",
            "typescriptreact" => "TypeScript (React)",
            "cpp" => "C++",
            "objective-c" => "Objective-C",
            "objective-cpp" => "Objective-C++",
            "shellscript" => "Shell Script",
            "powershell" => "PowerShell",
            "restructuredtext" => "reStructuredText",
            "jsonc" => "JSON with Comments",
            _ => char.ToUpper(language[0]) + language[1..] // Capitalize first letter
        };
    }
}
```

### Files to Create (v0.3.1c)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Utilities/LanguageDetector.cs` | Language detection utility |

---

## v0.3.1d: File System Service

### Objective
Implement the file system service for file/directory operations, file watching, and .gitignore support.

### IFileSystemService Interface

```csharp
// src/SeniorIntern.Core/Interfaces/IFileSystemService.cs
namespace SeniorIntern.Core.Interfaces;

using SeniorIntern.Core.Models;

/// <summary>
/// Provides file system operations with workspace-aware features.
/// </summary>
public interface IFileSystemService
{
    #region Directory Operations

    /// <summary>
    /// Gets the contents of a directory.
    /// </summary>
    /// <param name="path">Absolute path to the directory.</param>
    /// <param name="includeHidden">Whether to include hidden files and folders.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>List of file system items sorted by type (folders first) then name.</returns>
    Task<IReadOnlyList<FileSystemItem>> GetDirectoryContentsAsync(
        string path,
        bool includeHidden = false,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets information about a specific file or directory.
    /// </summary>
    Task<FileSystemItem> GetItemInfoAsync(
        string path,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Creates a new directory.
    /// </summary>
    Task<FileSystemItem> CreateDirectoryAsync(
        string path,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Deletes a directory and all its contents.
    /// </summary>
    Task DeleteDirectoryAsync(
        string path,
        CancellationToken cancellationToken = default);

    #endregion

    #region File Operations

    /// <summary>
    /// Reads a file's content as text.
    /// </summary>
    Task<string> ReadFileAsync(
        string path,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Reads a file's content as bytes.
    /// </summary>
    Task<byte[]> ReadFileBytesAsync(
        string path,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Writes text content to a file.
    /// </summary>
    Task WriteFileAsync(
        string path,
        string content,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Creates a new empty file.
    /// </summary>
    Task<FileSystemItem> CreateFileAsync(
        string path,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Deletes a file.
    /// </summary>
    Task DeleteFileAsync(
        string path,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Renames a file or directory.
    /// </summary>
    Task<FileSystemItem> RenameAsync(
        string path,
        string newName,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Copies a file to a new location.
    /// </summary>
    Task<FileSystemItem> CopyFileAsync(
        string sourcePath,
        string destinationPath,
        bool overwrite = false,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Moves a file or directory to a new location.
    /// </summary>
    Task<FileSystemItem> MoveAsync(
        string sourcePath,
        string destinationPath,
        CancellationToken cancellationToken = default);

    #endregion

    #region Existence Checks

    /// <summary>
    /// Checks if a file exists.
    /// </summary>
    Task<bool> FileExistsAsync(string path);

    /// <summary>
    /// Checks if a directory exists.
    /// </summary>
    Task<bool> DirectoryExistsAsync(string path);

    #endregion

    #region File Watching

    /// <summary>
    /// Starts watching a directory for changes.
    /// </summary>
    /// <param name="path">Absolute path to watch.</param>
    /// <param name="onChange">Callback for change events.</param>
    /// <param name="includeSubdirectories">Whether to watch subdirectories.</param>
    /// <returns>Disposable to stop watching.</returns>
    IDisposable WatchDirectory(
        string path,
        Action<FileSystemChangeEvent> onChange,
        bool includeSubdirectories = true);

    #endregion

    #region Utilities

    /// <summary>
    /// Gets the relative path from a base path to a full path.
    /// </summary>
    string GetRelativePath(string fullPath, string basePath);

    /// <summary>
    /// Determines if a file is likely a text file (vs binary).
    /// </summary>
    bool IsTextFile(string path);

    /// <summary>
    /// Gets the size of a file in bytes.
    /// </summary>
    long GetFileSize(string path);

    /// <summary>
    /// Gets the line count of a text file.
    /// </summary>
    Task<int> GetLineCountAsync(string path, CancellationToken cancellationToken = default);

    #endregion

    #region Ignore Patterns

    /// <summary>
    /// Determines if a path should be ignored based on patterns.
    /// </summary>
    /// <param name="path">The path to check.</param>
    /// <param name="basePath">The workspace root path.</param>
    /// <param name="ignorePatterns">List of gitignore-style patterns.</param>
    bool ShouldIgnore(string path, string basePath, IReadOnlyList<string> ignorePatterns);

    /// <summary>
    /// Loads .gitignore patterns from a workspace.
    /// </summary>
    Task<IReadOnlyList<string>> LoadGitIgnorePatternsAsync(
        string workspacePath,
        CancellationToken cancellationToken = default);

    #endregion
}

/// <summary>
/// Event data for file system change notifications.
/// </summary>
public sealed class FileSystemChangeEvent
{
    /// <summary>
    /// Absolute path that changed.
    /// </summary>
    public required string Path { get; init; }

    /// <summary>
    /// Old path (for rename events).
    /// </summary>
    public string? OldPath { get; init; }

    /// <summary>
    /// Type of change.
    /// </summary>
    public required FileSystemChangeType ChangeType { get; init; }

    /// <summary>
    /// When the change occurred.
    /// </summary>
    public DateTime Timestamp { get; init; } = DateTime.UtcNow;

    /// <summary>
    /// Whether the path is a directory.
    /// </summary>
    public bool IsDirectory { get; init; }
}

/// <summary>
/// Type of file system change.
/// </summary>
public enum FileSystemChangeType
{
    Created,
    Modified,
    Deleted,
    Renamed
}
```

### FileSystemService Implementation

```csharp
// src/SeniorIntern.Services/FileSystemService.cs
namespace SeniorIntern.Services;

using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Core.Utilities;
using System.Text;
using System.Text.RegularExpressions;

public sealed class FileSystemService : IFileSystemService
{
    private readonly ILogger<FileSystemService> _logger;

    // Binary file signatures for detection
    private static readonly byte[][] BinarySignatures =
    [
        [0x89, 0x50, 0x4E, 0x47], // PNG
        [0xFF, 0xD8, 0xFF],       // JPEG
        [0x47, 0x49, 0x46],       // GIF
        [0x25, 0x50, 0x44, 0x46], // PDF
        [0x50, 0x4B, 0x03, 0x04], // ZIP/DOCX/XLSX
        [0x7F, 0x45, 0x4C, 0x46], // ELF
        [0x4D, 0x5A],             // Windows EXE/DLL
    ];

    // Extensions that are always considered text
    private static readonly HashSet<string> TextExtensions = new(StringComparer.OrdinalIgnoreCase)
    {
        ".txt", ".md", ".cs", ".js", ".ts", ".py", ".rb", ".go", ".rs",
        ".java", ".kt", ".swift", ".c", ".h", ".cpp", ".hpp", ".json",
        ".xml", ".html", ".css", ".scss", ".yaml", ".yml", ".toml",
        ".ini", ".cfg", ".conf", ".sh", ".bash", ".ps1", ".bat", ".sql",
        ".graphql", ".proto", ".dockerfile", ".gitignore", ".env"
    };

    public FileSystemService(ILogger<FileSystemService> logger)
    {
        _logger = logger;
    }

    #region Directory Operations

    public async Task<IReadOnlyList<FileSystemItem>> GetDirectoryContentsAsync(
        string path,
        bool includeHidden = false,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(path);

        if (!Directory.Exists(path))
            throw new DirectoryNotFoundException($"Directory not found: {path}");

        return await Task.Run(() =>
        {
            var items = new List<FileSystemItem>();
            var dirInfo = new DirectoryInfo(path);

            // Get directories
            foreach (var dir in dirInfo.EnumerateDirectories())
            {
                cancellationToken.ThrowIfCancellationRequested();

                if (!includeHidden && IsHidden(dir))
                    continue;

                items.Add(CreateFileSystemItem(dir));
            }

            // Get files
            foreach (var file in dirInfo.EnumerateFiles())
            {
                cancellationToken.ThrowIfCancellationRequested();

                if (!includeHidden && IsHidden(file))
                    continue;

                items.Add(CreateFileSystemItem(file));
            }

            // Sort: directories first, then alphabetically
            return items
                .OrderByDescending(i => i.IsDirectory)
                .ThenBy(i => i.Name, StringComparer.OrdinalIgnoreCase)
                .ToList();
        }, cancellationToken);
    }

    public async Task<FileSystemItem> GetItemInfoAsync(
        string path,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(path);

        return await Task.Run(() =>
        {
            if (Directory.Exists(path))
            {
                return CreateFileSystemItem(new DirectoryInfo(path));
            }

            if (File.Exists(path))
            {
                return CreateFileSystemItem(new FileInfo(path));
            }

            throw new FileNotFoundException($"Path not found: {path}");
        }, cancellationToken);
    }

    public async Task<FileSystemItem> CreateDirectoryAsync(
        string path,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(path);

        return await Task.Run(() =>
        {
            var dirInfo = Directory.CreateDirectory(path);
            _logger.LogInformation("Created directory: {Path}", path);
            return CreateFileSystemItem(dirInfo);
        }, cancellationToken);
    }

    public async Task DeleteDirectoryAsync(
        string path,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(path);

        await Task.Run(() =>
        {
            Directory.Delete(path, recursive: true);
            _logger.LogInformation("Deleted directory: {Path}", path);
        }, cancellationToken);
    }

    #endregion

    #region File Operations

    public async Task<string> ReadFileAsync(
        string path,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(path);

        if (!File.Exists(path))
            throw new FileNotFoundException($"File not found: {path}");

        return await File.ReadAllTextAsync(path, cancellationToken);
    }

    public async Task<byte[]> ReadFileBytesAsync(
        string path,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(path);

        if (!File.Exists(path))
            throw new FileNotFoundException($"File not found: {path}");

        return await File.ReadAllBytesAsync(path, cancellationToken);
    }

    public async Task WriteFileAsync(
        string path,
        string content,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(path);

        // Ensure directory exists
        var directory = Path.GetDirectoryName(path);
        if (!string.IsNullOrEmpty(directory) && !Directory.Exists(directory))
        {
            Directory.CreateDirectory(directory);
        }

        await File.WriteAllTextAsync(path, content, cancellationToken);
        _logger.LogDebug("Wrote file: {Path}", path);
    }

    public async Task<FileSystemItem> CreateFileAsync(
        string path,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(path);

        // Ensure directory exists
        var directory = Path.GetDirectoryName(path);
        if (!string.IsNullOrEmpty(directory) && !Directory.Exists(directory))
        {
            Directory.CreateDirectory(directory);
        }

        await File.WriteAllTextAsync(path, string.Empty, cancellationToken);
        _logger.LogInformation("Created file: {Path}", path);

        return CreateFileSystemItem(new FileInfo(path));
    }

    public async Task DeleteFileAsync(
        string path,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(path);

        await Task.Run(() =>
        {
            File.Delete(path);
            _logger.LogInformation("Deleted file: {Path}", path);
        }, cancellationToken);
    }

    public async Task<FileSystemItem> RenameAsync(
        string path,
        string newName,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(path);
        ArgumentException.ThrowIfNullOrWhiteSpace(newName);

        return await Task.Run(() =>
        {
            var directory = Path.GetDirectoryName(path)!;
            var newPath = Path.Combine(directory, newName);

            if (Directory.Exists(path))
            {
                Directory.Move(path, newPath);
                _logger.LogInformation("Renamed directory: {OldPath} -> {NewPath}", path, newPath);
                return CreateFileSystemItem(new DirectoryInfo(newPath));
            }

            if (File.Exists(path))
            {
                File.Move(path, newPath);
                _logger.LogInformation("Renamed file: {OldPath} -> {NewPath}", path, newPath);
                return CreateFileSystemItem(new FileInfo(newPath));
            }

            throw new FileNotFoundException($"Path not found: {path}");
        }, cancellationToken);
    }

    public async Task<FileSystemItem> CopyFileAsync(
        string sourcePath,
        string destinationPath,
        bool overwrite = false,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(sourcePath);
        ArgumentException.ThrowIfNullOrWhiteSpace(destinationPath);

        return await Task.Run(() =>
        {
            File.Copy(sourcePath, destinationPath, overwrite);
            _logger.LogInformation("Copied file: {Source} -> {Dest}", sourcePath, destinationPath);
            return CreateFileSystemItem(new FileInfo(destinationPath));
        }, cancellationToken);
    }

    public async Task<FileSystemItem> MoveAsync(
        string sourcePath,
        string destinationPath,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(sourcePath);
        ArgumentException.ThrowIfNullOrWhiteSpace(destinationPath);

        return await Task.Run(() =>
        {
            if (Directory.Exists(sourcePath))
            {
                Directory.Move(sourcePath, destinationPath);
                _logger.LogInformation("Moved directory: {Source} -> {Dest}", sourcePath, destinationPath);
                return CreateFileSystemItem(new DirectoryInfo(destinationPath));
            }

            if (File.Exists(sourcePath))
            {
                File.Move(sourcePath, destinationPath);
                _logger.LogInformation("Moved file: {Source} -> {Dest}", sourcePath, destinationPath);
                return CreateFileSystemItem(new FileInfo(destinationPath));
            }

            throw new FileNotFoundException($"Path not found: {sourcePath}");
        }, cancellationToken);
    }

    #endregion

    #region Existence Checks

    public Task<bool> FileExistsAsync(string path)
        => Task.FromResult(File.Exists(path));

    public Task<bool> DirectoryExistsAsync(string path)
        => Task.FromResult(Directory.Exists(path));

    #endregion

    #region File Watching

    public IDisposable WatchDirectory(
        string path,
        Action<FileSystemChangeEvent> onChange,
        bool includeSubdirectories = true)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(path);
        ArgumentNullException.ThrowIfNull(onChange);

        var watcher = new FileSystemWatcher(path)
        {
            IncludeSubdirectories = includeSubdirectories,
            NotifyFilter = NotifyFilters.FileName
                         | NotifyFilters.DirectoryName
                         | NotifyFilters.LastWrite
                         | NotifyFilters.Size
        };

        // Debounce timer to batch rapid changes
        var debounceTimer = new System.Timers.Timer(200) { AutoReset = false };
        var pendingEvents = new Dictionary<string, FileSystemChangeEvent>();
        var lockObj = new object();

        debounceTimer.Elapsed += (s, e) =>
        {
            List<FileSystemChangeEvent> events;
            lock (lockObj)
            {
                events = pendingEvents.Values.ToList();
                pendingEvents.Clear();
            }

            foreach (var evt in events)
            {
                try
                {
                    onChange(evt);
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error in file watcher callback for {Path}", evt.Path);
                }
            }
        };

        void QueueEvent(FileSystemChangeEvent evt)
        {
            lock (lockObj)
            {
                pendingEvents[evt.Path] = evt;
            }
            debounceTimer.Stop();
            debounceTimer.Start();
        }

        watcher.Created += (s, e) => QueueEvent(new FileSystemChangeEvent
        {
            Path = e.FullPath,
            ChangeType = FileSystemChangeType.Created,
            IsDirectory = Directory.Exists(e.FullPath)
        });

        watcher.Deleted += (s, e) => QueueEvent(new FileSystemChangeEvent
        {
            Path = e.FullPath,
            ChangeType = FileSystemChangeType.Deleted
        });

        watcher.Changed += (s, e) => QueueEvent(new FileSystemChangeEvent
        {
            Path = e.FullPath,
            ChangeType = FileSystemChangeType.Modified,
            IsDirectory = Directory.Exists(e.FullPath)
        });

        watcher.Renamed += (s, e) => QueueEvent(new FileSystemChangeEvent
        {
            Path = e.FullPath,
            OldPath = e.OldFullPath,
            ChangeType = FileSystemChangeType.Renamed,
            IsDirectory = Directory.Exists(e.FullPath)
        });

        watcher.Error += (s, e) =>
        {
            _logger.LogError(e.GetException(), "File watcher error for {Path}", path);
        };

        watcher.EnableRaisingEvents = true;
        _logger.LogDebug("Started watching directory: {Path}", path);

        return new FileWatcherDisposable(watcher, debounceTimer, () =>
        {
            _logger.LogDebug("Stopped watching directory: {Path}", path);
        });
    }

    private sealed class FileWatcherDisposable : IDisposable
    {
        private readonly FileSystemWatcher _watcher;
        private readonly System.Timers.Timer _timer;
        private readonly Action _onDispose;
        private bool _disposed;

        public FileWatcherDisposable(FileSystemWatcher watcher, System.Timers.Timer timer, Action onDispose)
        {
            _watcher = watcher;
            _timer = timer;
            _onDispose = onDispose;
        }

        public void Dispose()
        {
            if (_disposed) return;
            _disposed = true;

            _watcher.EnableRaisingEvents = false;
            _timer.Stop();
            _watcher.Dispose();
            _timer.Dispose();
            _onDispose();
        }
    }

    #endregion

    #region Utilities

    public string GetRelativePath(string fullPath, string basePath)
        => Path.GetRelativePath(basePath, fullPath);

    public bool IsTextFile(string path)
    {
        if (!File.Exists(path))
            return false;

        // Check extension first
        var extension = Path.GetExtension(path);
        if (TextExtensions.Contains(extension))
            return true;

        // Check file header for binary signatures
        try
        {
            using var stream = File.OpenRead(path);
            var buffer = new byte[8];
            var bytesRead = stream.Read(buffer, 0, buffer.Length);

            if (bytesRead == 0)
                return true; // Empty file is considered text

            foreach (var signature in BinarySignatures)
            {
                if (bytesRead >= signature.Length &&
                    buffer.Take(signature.Length).SequenceEqual(signature))
                {
                    return false;
                }
            }

            // Check for null bytes (common in binary files)
            stream.Position = 0;
            var checkBuffer = new byte[Math.Min(8192, stream.Length)];
            bytesRead = stream.Read(checkBuffer, 0, checkBuffer.Length);

            return !checkBuffer.Take(bytesRead).Contains((byte)0);
        }
        catch
        {
            return false;
        }
    }

    public long GetFileSize(string path)
        => new FileInfo(path).Length;

    public async Task<int> GetLineCountAsync(string path, CancellationToken cancellationToken = default)
    {
        if (!File.Exists(path))
            return 0;

        var lineCount = 0;
        using var reader = new StreamReader(path);

        while (await reader.ReadLineAsync(cancellationToken) is not null)
        {
            lineCount++;
        }

        return lineCount;
    }

    #endregion

    #region Ignore Patterns

    public bool ShouldIgnore(string path, string basePath, IReadOnlyList<string> ignorePatterns)
    {
        if (ignorePatterns.Count == 0)
            return false;

        var relativePath = GetRelativePath(path, basePath);
        var isDirectory = Directory.Exists(path);

        // Normalize path separators
        relativePath = relativePath.Replace('\\', '/');
        if (isDirectory && !relativePath.EndsWith('/'))
            relativePath += '/';

        foreach (var pattern in ignorePatterns)
        {
            if (string.IsNullOrWhiteSpace(pattern) || pattern.StartsWith('#'))
                continue;

            var trimmed = pattern.Trim();
            var isNegation = trimmed.StartsWith('!');
            if (isNegation)
                trimmed = trimmed[1..];

            // Convert gitignore pattern to regex
            var regex = ConvertGitIgnorePatternToRegex(trimmed);

            if (regex.IsMatch(relativePath))
            {
                return !isNegation;
            }
        }

        return false;
    }

    public async Task<IReadOnlyList<string>> LoadGitIgnorePatternsAsync(
        string workspacePath,
        CancellationToken cancellationToken = default)
    {
        var patterns = new List<string>();

        // Load root .gitignore
        var gitignorePath = Path.Combine(workspacePath, ".gitignore");
        if (File.Exists(gitignorePath))
        {
            var lines = await File.ReadAllLinesAsync(gitignorePath, cancellationToken);
            patterns.AddRange(lines);
        }

        // Add common patterns that should always be ignored
        patterns.AddRange(new[]
        {
            ".git/",
            ".vs/",
            ".idea/",
            "node_modules/",
            "bin/",
            "obj/",
            "*.user",
            "*.suo",
            ".DS_Store",
            "Thumbs.db"
        });

        return patterns.Distinct().ToList();
    }

    private static Regex ConvertGitIgnorePatternToRegex(string pattern)
    {
        var regexPattern = new StringBuilder("^");

        var isDirectoryOnly = pattern.EndsWith('/');
        if (isDirectoryOnly)
            pattern = pattern[..^1];

        var hasLeadingSlash = pattern.StartsWith('/');
        if (hasLeadingSlash)
            pattern = pattern[1..];

        // Escape regex special characters except * and ?
        pattern = Regex.Escape(pattern)
            .Replace("\\*\\*", ".*")           // ** matches everything
            .Replace("\\*", "[^/]*")           // * matches everything except /
            .Replace("\\?", "[^/]");           // ? matches single character

        if (!hasLeadingSlash && !pattern.Contains('/'))
        {
            // Pattern without slash matches anywhere
            regexPattern.Append("(.*/)?" + pattern);
        }
        else
        {
            regexPattern.Append(pattern);
        }

        if (isDirectoryOnly)
        {
            regexPattern.Append('/');
        }
        else
        {
            regexPattern.Append("(/|$)");
        }

        return new Regex(regexPattern.ToString(), RegexOptions.IgnoreCase | RegexOptions.Compiled);
    }

    #endregion

    #region Helpers

    private static FileSystemItem CreateFileSystemItem(DirectoryInfo dirInfo)
    {
        var hasChildren = false;
        try
        {
            hasChildren = dirInfo.EnumerateFileSystemInfos().Any();
        }
        catch
        {
            // Access denied or other error
        }

        return new FileSystemItem
        {
            Path = dirInfo.FullName,
            Name = dirInfo.Name,
            Type = FileSystemItemType.Directory,
            ModifiedAt = dirInfo.LastWriteTimeUtc,
            AccessedAt = dirInfo.LastAccessTimeUtc,
            CreatedAt = dirInfo.CreationTimeUtc,
            IsHidden = IsHidden(dirInfo),
            IsReadOnly = false,
            HasChildren = hasChildren
        };
    }

    private static FileSystemItem CreateFileSystemItem(FileInfo fileInfo)
    {
        return new FileSystemItem
        {
            Path = fileInfo.FullName,
            Name = fileInfo.Name,
            Type = FileSystemItemType.File,
            Size = fileInfo.Length,
            ModifiedAt = fileInfo.LastWriteTimeUtc,
            AccessedAt = fileInfo.LastAccessTimeUtc,
            CreatedAt = fileInfo.CreationTimeUtc,
            IsHidden = IsHidden(fileInfo),
            IsReadOnly = fileInfo.IsReadOnly
        };
    }

    private static bool IsHidden(FileSystemInfo info)
    {
        // Check hidden attribute (Windows)
        if ((info.Attributes & FileAttributes.Hidden) == FileAttributes.Hidden)
            return true;

        // Check dot prefix (Unix convention)
        return info.Name.StartsWith('.');
    }

    #endregion
}
```

### Files to Create (v0.3.1d)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/IFileSystemService.cs` | File system service interface |
| `src/SeniorIntern.Services/FileSystemService.cs` | File system service implementation |

---

## v0.3.1e: Workspace Service

### Objective
Implement the workspace service for managing open workspaces, state persistence, and recent workspaces.

### IWorkspaceService Interface

```csharp
// src/SeniorIntern.Core/Interfaces/IWorkspaceService.cs
namespace SeniorIntern.Core.Interfaces;

using SeniorIntern.Core.Models;

/// <summary>
/// Manages workspace lifecycle and state.
/// </summary>
public interface IWorkspaceService
{
    #region Properties

    /// <summary>
    /// The currently open workspace, or null if none.
    /// </summary>
    Workspace? CurrentWorkspace { get; }

    /// <summary>
    /// Whether a workspace is currently open.
    /// </summary>
    bool HasOpenWorkspace { get; }

    #endregion

    #region Workspace Operations

    /// <summary>
    /// Opens a workspace from a folder path.
    /// </summary>
    /// <param name="folderPath">Absolute path to the folder.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>The opened workspace.</returns>
    Task<Workspace> OpenWorkspaceAsync(
        string folderPath,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Closes the current workspace.
    /// </summary>
    Task CloseWorkspaceAsync();

    /// <summary>
    /// Gets the list of recently opened workspaces.
    /// </summary>
    /// <param name="count">Maximum number to return.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    Task<IReadOnlyList<Workspace>> GetRecentWorkspacesAsync(
        int count = 10,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Removes a workspace from the recent list.
    /// </summary>
    Task RemoveFromRecentAsync(Guid workspaceId);

    /// <summary>
    /// Clears all recent workspaces.
    /// </summary>
    Task ClearRecentWorkspacesAsync();

    /// <summary>
    /// Pins or unpins a workspace in the recent list.
    /// </summary>
    Task SetPinnedAsync(Guid workspaceId, bool isPinned);

    /// <summary>
    /// Updates the workspace name.
    /// </summary>
    Task RenameWorkspaceAsync(Guid workspaceId, string newName);

    #endregion

    #region State Management

    /// <summary>
    /// Saves the current workspace state (open files, expanded folders, etc).
    /// </summary>
    Task SaveWorkspaceStateAsync();

    /// <summary>
    /// Restores the last opened workspace on application startup.
    /// </summary>
    /// <returns>The restored workspace, or null if none or restoration disabled.</returns>
    Task<Workspace?> RestoreLastWorkspaceAsync();

    /// <summary>
    /// Updates the list of open files in the current workspace.
    /// </summary>
    void UpdateOpenFiles(IReadOnlyList<string> openFiles, string? activeFile);

    /// <summary>
    /// Updates the list of expanded folders in the current workspace.
    /// </summary>
    void UpdateExpandedFolders(IReadOnlyList<string> expandedFolders);

    #endregion

    #region Events

    /// <summary>
    /// Raised when the workspace changes (opened, closed, refreshed).
    /// </summary>
    event EventHandler<WorkspaceChangedEventArgs>? WorkspaceChanged;

    /// <summary>
    /// Raised when workspace state changes (open files, expanded folders).
    /// </summary>
    event EventHandler<WorkspaceStateChangedEventArgs>? StateChanged;

    #endregion
}
```

### Workspace Events

```csharp
// src/SeniorIntern.Core/Events/WorkspaceEvents.cs
namespace SeniorIntern.Core.Events;

using SeniorIntern.Core.Models;

/// <summary>
/// Event args for workspace open/close/refresh events.
/// </summary>
public sealed class WorkspaceChangedEventArgs : EventArgs
{
    /// <summary>
    /// The workspace before the change (null if opening first workspace).
    /// </summary>
    public Workspace? PreviousWorkspace { get; init; }

    /// <summary>
    /// The workspace after the change (null if closing).
    /// </summary>
    public Workspace? CurrentWorkspace { get; init; }

    /// <summary>
    /// The type of change that occurred.
    /// </summary>
    public required WorkspaceChangeType ChangeType { get; init; }
}

/// <summary>
/// Type of workspace change.
/// </summary>
public enum WorkspaceChangeType
{
    /// <summary>
    /// A workspace was opened.
    /// </summary>
    Opened,

    /// <summary>
    /// The workspace was closed.
    /// </summary>
    Closed,

    /// <summary>
    /// The workspace was refreshed (e.g., files reloaded).
    /// </summary>
    Refreshed
}

/// <summary>
/// Event args for workspace state changes.
/// </summary>
public sealed class WorkspaceStateChangedEventArgs : EventArgs
{
    /// <summary>
    /// The workspace whose state changed.
    /// </summary>
    public required Workspace Workspace { get; init; }

    /// <summary>
    /// The type of state change.
    /// </summary>
    public required WorkspaceStateChangeType ChangeType { get; init; }
}

/// <summary>
/// Type of workspace state change.
/// </summary>
public enum WorkspaceStateChangeType
{
    /// <summary>
    /// Open files list changed.
    /// </summary>
    OpenFilesChanged,

    /// <summary>
    /// Active file changed.
    /// </summary>
    ActiveFileChanged,

    /// <summary>
    /// Expanded folders changed.
    /// </summary>
    ExpandedFoldersChanged
}
```

### WorkspaceService Implementation

```csharp
// src/SeniorIntern.Services/WorkspaceService.cs
namespace SeniorIntern.Services;

using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Events;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Data.Repositories;

public sealed class WorkspaceService : IWorkspaceService, IDisposable
{
    private readonly IWorkspaceRepository _repository;
    private readonly IFileSystemService _fileSystemService;
    private readonly ISettingsService _settingsService;
    private readonly ILogger<WorkspaceService> _logger;

    private Workspace? _currentWorkspace;
    private IDisposable? _fileWatcher;
    private readonly SemaphoreSlim _lock = new(1, 1);
    private readonly System.Timers.Timer _autoSaveTimer;
    private bool _stateChanged;

    public Workspace? CurrentWorkspace => _currentWorkspace;
    public bool HasOpenWorkspace => _currentWorkspace != null;

    public event EventHandler<WorkspaceChangedEventArgs>? WorkspaceChanged;
    public event EventHandler<WorkspaceStateChangedEventArgs>? StateChanged;

    public WorkspaceService(
        IWorkspaceRepository repository,
        IFileSystemService fileSystemService,
        ISettingsService settingsService,
        ILogger<WorkspaceService> logger)
    {
        _repository = repository;
        _fileSystemService = fileSystemService;
        _settingsService = settingsService;
        _logger = logger;

        // Auto-save workspace state every 30 seconds
        _autoSaveTimer = new System.Timers.Timer(30_000);
        _autoSaveTimer.Elapsed += async (s, e) => await AutoSaveStateAsync();
        _autoSaveTimer.Start();
    }

    #region Workspace Operations

    public async Task<Workspace> OpenWorkspaceAsync(
        string folderPath,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(folderPath);

        folderPath = Path.GetFullPath(folderPath);

        if (!Directory.Exists(folderPath))
            throw new DirectoryNotFoundException($"Folder not found: {folderPath}");

        await _lock.WaitAsync(cancellationToken);
        try
        {
            _logger.LogInformation("Opening workspace: {Path}", folderPath);

            // Close current workspace if any
            if (_currentWorkspace != null)
            {
                await CloseWorkspaceInternalAsync();
            }

            // Check if workspace exists in recent
            var existing = await _repository.GetByPathAsync(folderPath, cancellationToken);

            Workspace workspace;
            if (existing != null)
            {
                // Restore existing workspace
                workspace = existing;
                workspace.LastAccessedAt = DateTime.UtcNow;
            }
            else
            {
                // Create new workspace
                workspace = new Workspace
                {
                    RootPath = folderPath,
                    OpenedAt = DateTime.UtcNow,
                    LastAccessedAt = DateTime.UtcNow
                };
            }

            // Load .gitignore patterns
            var ignorePatterns = await _fileSystemService.LoadGitIgnorePatternsAsync(
                folderPath, cancellationToken);
            workspace.GitIgnorePatterns = ignorePatterns;

            // Save to recent
            await _repository.AddOrUpdateAsync(workspace, cancellationToken);

            // Start file watcher
            _fileWatcher = _fileSystemService.WatchDirectory(
                folderPath,
                OnFileSystemChange,
                includeSubdirectories: true);

            _currentWorkspace = workspace;

            // Raise event
            var eventArgs = new WorkspaceChangedEventArgs
            {
                PreviousWorkspace = null,
                CurrentWorkspace = workspace,
                ChangeType = WorkspaceChangeType.Opened
            };
            WorkspaceChanged?.Invoke(this, eventArgs);

            _logger.LogInformation("Opened workspace: {Name} at {Path}",
                workspace.DisplayName, workspace.RootPath);

            return workspace;
        }
        finally
        {
            _lock.Release();
        }
    }

    public async Task CloseWorkspaceAsync()
    {
        await _lock.WaitAsync();
        try
        {
            await CloseWorkspaceInternalAsync();
        }
        finally
        {
            _lock.Release();
        }
    }

    private async Task CloseWorkspaceInternalAsync()
    {
        if (_currentWorkspace == null)
            return;

        _logger.LogInformation("Closing workspace: {Name}", _currentWorkspace.DisplayName);

        // Save state before closing
        await SaveWorkspaceStateInternalAsync();

        // Stop file watcher
        _fileWatcher?.Dispose();
        _fileWatcher = null;

        var previousWorkspace = _currentWorkspace;
        _currentWorkspace = null;

        // Raise event
        var eventArgs = new WorkspaceChangedEventArgs
        {
            PreviousWorkspace = previousWorkspace,
            CurrentWorkspace = null,
            ChangeType = WorkspaceChangeType.Closed
        };
        WorkspaceChanged?.Invoke(this, eventArgs);
    }

    public async Task<IReadOnlyList<Workspace>> GetRecentWorkspacesAsync(
        int count = 10,
        CancellationToken cancellationToken = default)
    {
        var workspaces = await _repository.GetRecentAsync(count, cancellationToken);

        // Filter out workspaces that no longer exist
        var validWorkspaces = workspaces
            .Where(w => Directory.Exists(w.RootPath))
            .ToList();

        // Clean up invalid entries in background
        var invalidIds = workspaces
            .Where(w => !Directory.Exists(w.RootPath))
            .Select(w => w.Id)
            .ToList();

        if (invalidIds.Count > 0)
        {
            _ = Task.Run(async () =>
            {
                foreach (var id in invalidIds)
                {
                    await _repository.RemoveAsync(id);
                }
            });
        }

        return validWorkspaces;
    }

    public async Task RemoveFromRecentAsync(Guid workspaceId)
    {
        await _repository.RemoveAsync(workspaceId);
        _logger.LogInformation("Removed workspace from recent: {Id}", workspaceId);
    }

    public async Task ClearRecentWorkspacesAsync()
    {
        await _repository.ClearAllAsync();
        _logger.LogInformation("Cleared all recent workspaces");
    }

    public async Task SetPinnedAsync(Guid workspaceId, bool isPinned)
    {
        await _repository.SetPinnedAsync(workspaceId, isPinned);
        _logger.LogInformation("Set workspace {Id} pinned: {IsPinned}", workspaceId, isPinned);
    }

    public async Task RenameWorkspaceAsync(Guid workspaceId, string newName)
    {
        await _repository.RenameAsync(workspaceId, newName);
        _logger.LogInformation("Renamed workspace {Id} to: {Name}", workspaceId, newName);
    }

    #endregion

    #region State Management

    public async Task SaveWorkspaceStateAsync()
    {
        await _lock.WaitAsync();
        try
        {
            await SaveWorkspaceStateInternalAsync();
        }
        finally
        {
            _lock.Release();
        }
    }

    private async Task SaveWorkspaceStateInternalAsync()
    {
        if (_currentWorkspace == null)
            return;

        await _repository.AddOrUpdateAsync(_currentWorkspace);
        _stateChanged = false;
        _logger.LogDebug("Saved workspace state: {Name}", _currentWorkspace.DisplayName);
    }

    public async Task<Workspace?> RestoreLastWorkspaceAsync()
    {
        var settings = await _settingsService.GetSettingsAsync();

        if (!settings.RestoreLastWorkspace)
        {
            _logger.LogDebug("Workspace restoration disabled in settings");
            return null;
        }

        var recent = await _repository.GetRecentAsync(1);
        if (recent.Count == 0)
        {
            _logger.LogDebug("No recent workspaces to restore");
            return null;
        }

        var last = recent[0];
        if (!Directory.Exists(last.RootPath))
        {
            _logger.LogWarning("Last workspace no longer exists: {Path}", last.RootPath);
            return null;
        }

        _logger.LogInformation("Restoring last workspace: {Path}", last.RootPath);
        return await OpenWorkspaceAsync(last.RootPath);
    }

    public void UpdateOpenFiles(IReadOnlyList<string> openFiles, string? activeFile)
    {
        if (_currentWorkspace == null)
            return;

        _currentWorkspace.OpenFiles = openFiles;
        _currentWorkspace.ActiveFilePath = activeFile;
        _stateChanged = true;

        StateChanged?.Invoke(this, new WorkspaceStateChangedEventArgs
        {
            Workspace = _currentWorkspace,
            ChangeType = WorkspaceStateChangeType.OpenFilesChanged
        });
    }

    public void UpdateExpandedFolders(IReadOnlyList<string> expandedFolders)
    {
        if (_currentWorkspace == null)
            return;

        _currentWorkspace.ExpandedFolders = expandedFolders;
        _stateChanged = true;

        StateChanged?.Invoke(this, new WorkspaceStateChangedEventArgs
        {
            Workspace = _currentWorkspace,
            ChangeType = WorkspaceStateChangeType.ExpandedFoldersChanged
        });
    }

    private async Task AutoSaveStateAsync()
    {
        if (!_stateChanged || _currentWorkspace == null)
            return;

        try
        {
            await SaveWorkspaceStateAsync();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to auto-save workspace state");
        }
    }

    #endregion

    #region File Watcher Handler

    private void OnFileSystemChange(FileSystemChangeEvent e)
    {
        _logger.LogDebug("File system change: {Type} - {Path}", e.ChangeType, e.Path);

        // Could raise an event here for UI refresh
        // For now, just log the change
    }

    #endregion

    public void Dispose()
    {
        _autoSaveTimer.Stop();
        _autoSaveTimer.Dispose();
        _fileWatcher?.Dispose();
        _lock.Dispose();
    }
}
```

### Files to Create (v0.3.1e)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/IWorkspaceService.cs` | Workspace service interface |
| `src/SeniorIntern.Core/Events/WorkspaceEvents.cs` | Workspace event args |
| `src/SeniorIntern.Services/WorkspaceService.cs` | Workspace service implementation |

---

## v0.3.1f: Repository Layer

### Objective
Implement the workspace repository for database persistence.

### IWorkspaceRepository Interface

```csharp
// src/SeniorIntern.Data/Repositories/IWorkspaceRepository.cs
namespace SeniorIntern.Data.Repositories;

using SeniorIntern.Core.Models;

/// <summary>
/// Repository for workspace persistence operations.
/// </summary>
public interface IWorkspaceRepository
{
    /// <summary>
    /// Gets recent workspaces ordered by last accessed time.
    /// </summary>
    Task<IReadOnlyList<Workspace>> GetRecentAsync(
        int count = 10,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets a workspace by its root path.
    /// </summary>
    Task<Workspace?> GetByPathAsync(
        string rootPath,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets a workspace by its ID.
    /// </summary>
    Task<Workspace?> GetByIdAsync(
        Guid id,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Adds or updates a workspace.
    /// </summary>
    Task AddOrUpdateAsync(
        Workspace workspace,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Removes a workspace from the database.
    /// </summary>
    Task RemoveAsync(Guid id, CancellationToken cancellationToken = default);

    /// <summary>
    /// Clears all workspaces.
    /// </summary>
    Task ClearAllAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// Sets the pinned status of a workspace.
    /// </summary>
    Task SetPinnedAsync(Guid id, bool isPinned, CancellationToken cancellationToken = default);

    /// <summary>
    /// Renames a workspace.
    /// </summary>
    Task RenameAsync(Guid id, string newName, CancellationToken cancellationToken = default);
}
```

### WorkspaceRepository Implementation

```csharp
// src/SeniorIntern.Data/Repositories/WorkspaceRepository.cs
namespace SeniorIntern.Data.Repositories;

using Microsoft.EntityFrameworkCore;
using SeniorIntern.Core.Entities;
using SeniorIntern.Core.Models;

public sealed class WorkspaceRepository : IWorkspaceRepository
{
    private readonly SeniorInternDbContext _dbContext;

    public WorkspaceRepository(SeniorInternDbContext dbContext)
    {
        _dbContext = dbContext;
    }

    public async Task<IReadOnlyList<Workspace>> GetRecentAsync(
        int count = 10,
        CancellationToken cancellationToken = default)
    {
        var entities = await _dbContext.RecentWorkspaces
            .OrderByDescending(w => w.IsPinned)
            .ThenByDescending(w => w.LastAccessedAt)
            .Take(count)
            .ToListAsync(cancellationToken);

        return entities.Select(e => e.ToWorkspace()).ToList();
    }

    public async Task<Workspace?> GetByPathAsync(
        string rootPath,
        CancellationToken cancellationToken = default)
    {
        // Normalize path for comparison
        rootPath = Path.GetFullPath(rootPath);

        var entity = await _dbContext.RecentWorkspaces
            .FirstOrDefaultAsync(w => w.RootPath == rootPath, cancellationToken);

        return entity?.ToWorkspace();
    }

    public async Task<Workspace?> GetByIdAsync(
        Guid id,
        CancellationToken cancellationToken = default)
    {
        var entity = await _dbContext.RecentWorkspaces
            .FindAsync([id], cancellationToken);

        return entity?.ToWorkspace();
    }

    public async Task AddOrUpdateAsync(
        Workspace workspace,
        CancellationToken cancellationToken = default)
    {
        var existing = await _dbContext.RecentWorkspaces
            .FirstOrDefaultAsync(w => w.RootPath == workspace.RootPath, cancellationToken);

        if (existing != null)
        {
            // Update existing
            existing.Name = string.IsNullOrWhiteSpace(workspace.Name) ? null : workspace.Name;
            existing.LastAccessedAt = workspace.LastAccessedAt;
            existing.OpenFilesJson = SerializeList(workspace.OpenFiles);
            existing.ActiveFilePath = workspace.ActiveFilePath;
            existing.ExpandedFoldersJson = SerializeList(workspace.ExpandedFolders);
            existing.IsPinned = workspace.IsPinned;
        }
        else
        {
            // Add new
            var entity = RecentWorkspaceEntity.FromWorkspace(workspace);
            _dbContext.RecentWorkspaces.Add(entity);
        }

        await _dbContext.SaveChangesAsync(cancellationToken);

        // Enforce max recent workspaces limit
        await EnforceMaxRecentAsync(cancellationToken);
    }

    public async Task RemoveAsync(Guid id, CancellationToken cancellationToken = default)
    {
        var entity = await _dbContext.RecentWorkspaces.FindAsync([id], cancellationToken);
        if (entity != null)
        {
            _dbContext.RecentWorkspaces.Remove(entity);
            await _dbContext.SaveChangesAsync(cancellationToken);
        }
    }

    public async Task ClearAllAsync(CancellationToken cancellationToken = default)
    {
        await _dbContext.RecentWorkspaces.ExecuteDeleteAsync(cancellationToken);
    }

    public async Task SetPinnedAsync(Guid id, bool isPinned, CancellationToken cancellationToken = default)
    {
        await _dbContext.RecentWorkspaces
            .Where(w => w.Id == id)
            .ExecuteUpdateAsync(
                setters => setters.SetProperty(w => w.IsPinned, isPinned),
                cancellationToken);
    }

    public async Task RenameAsync(Guid id, string newName, CancellationToken cancellationToken = default)
    {
        var name = string.IsNullOrWhiteSpace(newName) ? null : newName;

        await _dbContext.RecentWorkspaces
            .Where(w => w.Id == id)
            .ExecuteUpdateAsync(
                setters => setters.SetProperty(w => w.Name, name),
                cancellationToken);
    }

    private async Task EnforceMaxRecentAsync(CancellationToken cancellationToken)
    {
        const int maxRecent = 20;

        var count = await _dbContext.RecentWorkspaces.CountAsync(cancellationToken);
        if (count <= maxRecent)
            return;

        // Get IDs of workspaces to remove (oldest, non-pinned)
        var toRemove = await _dbContext.RecentWorkspaces
            .Where(w => !w.IsPinned)
            .OrderBy(w => w.LastAccessedAt)
            .Take(count - maxRecent)
            .Select(w => w.Id)
            .ToListAsync(cancellationToken);

        if (toRemove.Count > 0)
        {
            await _dbContext.RecentWorkspaces
                .Where(w => toRemove.Contains(w.Id))
                .ExecuteDeleteAsync(cancellationToken);
        }
    }

    private static string? SerializeList(IReadOnlyList<string> list)
    {
        if (list.Count == 0) return null;
        return System.Text.Json.JsonSerializer.Serialize(list);
    }
}
```

### DbContext Updates

```csharp
// Update to SeniorInternDbContext.cs
public DbSet<RecentWorkspaceEntity> RecentWorkspaces => Set<RecentWorkspaceEntity>();
public DbSet<FileContextEntity> FileContextHistory => Set<FileContextEntity>();
```

### AppSettings Updates

```csharp
// Update to AppSettings.cs
public sealed class AppSettings
{
    // ... existing properties ...

    // Workspace settings (v0.3.0)
    public bool RestoreLastWorkspace { get; set; } = true;
    public bool ShowHiddenFiles { get; set; } = false;
    public bool UseGitIgnore { get; set; } = true;
    public int MaxRecentWorkspaces { get; set; } = 10;
    public IReadOnlyList<string> CustomIgnorePatterns { get; set; } = [];

    // Editor settings (v0.3.0)
    public bool WordWrap { get; set; } = false;
    public int TabSize { get; set; } = 4;
    public bool ShowLineNumbers { get; set; } = true;
    public bool HighlightCurrentLine { get; set; } = true;
    public string EditorFontFamily { get; set; } = "Cascadia Code, Consolas, monospace";
    public int EditorFontSize { get; set; } = 14;
}
```

### Files to Create (v0.3.1f)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Data/Repositories/IWorkspaceRepository.cs` | Repository interface |
| `src/SeniorIntern.Data/Repositories/WorkspaceRepository.cs` | Repository implementation |

### Files to Modify (v0.3.1f)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Data/SeniorInternDbContext.cs` | Add DbSets |
| `src/SeniorIntern.Core/Models/AppSettings.cs` | Add workspace/editor settings |
| `src/SeniorIntern.Desktop/Extensions/ServiceCollectionExtensions.cs` | Register new services |
| `Directory.Packages.props` | Add AvaloniaEdit packages |

---

## Files Summary

### Files to Create (15 total)

| Part | File | Purpose |
|------|------|---------|
| v0.3.1a | `src/SeniorIntern.Core/Models/Workspace.cs` | Workspace model |
| v0.3.1a | `src/SeniorIntern.Core/Models/FileSystemItem.cs` | File/folder model |
| v0.3.1a | `src/SeniorIntern.Core/Models/FileContext.cs` | Attached file context model |
| v0.3.1a | `src/SeniorIntern.Core/Utilities/TokenEstimator.cs` | Token estimation utility |
| v0.3.1b | `src/SeniorIntern.Core/Entities/RecentWorkspaceEntity.cs` | Workspace database entity |
| v0.3.1b | `src/SeniorIntern.Core/Entities/FileContextEntity.cs` | File context database entity |
| v0.3.1b | `src/SeniorIntern.Data/Configurations/RecentWorkspaceConfiguration.cs` | EF configuration |
| v0.3.1b | `src/SeniorIntern.Data/Configurations/FileContextConfiguration.cs` | EF configuration |
| v0.3.1b | `src/SeniorIntern.Data/Migrations/XXXXXXXX_AddWorkspaceEntities.cs` | Database migration |
| v0.3.1c | `src/SeniorIntern.Core/Utilities/LanguageDetector.cs` | Language detection utility |
| v0.3.1d | `src/SeniorIntern.Core/Interfaces/IFileSystemService.cs` | File system service interface |
| v0.3.1d | `src/SeniorIntern.Services/FileSystemService.cs` | File system service implementation |
| v0.3.1e | `src/SeniorIntern.Core/Interfaces/IWorkspaceService.cs` | Workspace service interface |
| v0.3.1e | `src/SeniorIntern.Core/Events/WorkspaceEvents.cs` | Workspace event args |
| v0.3.1e | `src/SeniorIntern.Services/WorkspaceService.cs` | Workspace service implementation |
| v0.3.1f | `src/SeniorIntern.Data/Repositories/IWorkspaceRepository.cs` | Repository interface |
| v0.3.1f | `src/SeniorIntern.Data/Repositories/WorkspaceRepository.cs` | Repository implementation |

### Files to Modify (4 total)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Data/SeniorInternDbContext.cs` | Add DbSets for RecentWorkspaces, FileContextHistory |
| `src/SeniorIntern.Core/Models/AppSettings.cs` | Add workspace/editor settings |
| `src/SeniorIntern.Desktop/Extensions/ServiceCollectionExtensions.cs` | Register IWorkspaceService, IFileSystemService, IWorkspaceRepository |
| `Directory.Packages.props` | Add AvaloniaEdit package references (for future versions) |

---

## Testing Strategy

### Unit Tests

```csharp
// tests/SeniorIntern.Core.Tests/Utilities/LanguageDetectorTests.cs
public class LanguageDetectorTests
{
    [Theory]
    [InlineData(".cs", "csharp")]
    [InlineData(".JS", "javascript")]
    [InlineData(".py", "python")]
    [InlineData(".unknown", null)]
    public void DetectByExtension_ReturnsCorrectLanguage(string extension, string? expected)
    {
        var result = LanguageDetector.DetectByExtension(extension);
        Assert.Equal(expected, result);
    }

    [Theory]
    [InlineData("Dockerfile", "dockerfile")]
    [InlineData("Makefile", "makefile")]
    [InlineData("Program.cs", "csharp")]
    public void DetectByFileName_ReturnsCorrectLanguage(string fileName, string expected)
    {
        var result = LanguageDetector.DetectByFileName(fileName);
        Assert.Equal(expected, result);
    }
}
```

```csharp
// tests/SeniorIntern.Core.Tests/Utilities/TokenEstimatorTests.cs
public class TokenEstimatorTests
{
    [Theory]
    [InlineData("", 0)]
    [InlineData("Hello world", 4)] // ~11 chars / 3.5 = ~3.14 -> 4
    [InlineData("A longer piece of text that should estimate more tokens", 16)]
    public void Estimate_ReturnsReasonableTokenCount(string content, int expectedApprox)
    {
        var result = TokenEstimator.Estimate(content);
        Assert.InRange(result, expectedApprox - 2, expectedApprox + 2);
    }
}
```

```csharp
// tests/SeniorIntern.Services.Tests/FileSystemServiceTests.cs
public class FileSystemServiceTests : IDisposable
{
    private readonly string _testDir;
    private readonly FileSystemService _service;

    public FileSystemServiceTests()
    {
        _testDir = Path.Combine(Path.GetTempPath(), $"test_{Guid.NewGuid():N}");
        Directory.CreateDirectory(_testDir);
        _service = new FileSystemService(NullLogger<FileSystemService>.Instance);
    }

    [Fact]
    public async Task GetDirectoryContentsAsync_ReturnsFilesAndFolders()
    {
        // Arrange
        Directory.CreateDirectory(Path.Combine(_testDir, "subdir"));
        await File.WriteAllTextAsync(Path.Combine(_testDir, "test.txt"), "content");

        // Act
        var items = await _service.GetDirectoryContentsAsync(_testDir);

        // Assert
        Assert.Equal(2, items.Count);
        Assert.Contains(items, i => i.Name == "subdir" && i.IsDirectory);
        Assert.Contains(items, i => i.Name == "test.txt" && i.IsFile);
    }

    [Fact]
    public async Task ReadFileAsync_ReturnsFileContent()
    {
        // Arrange
        var path = Path.Combine(_testDir, "test.txt");
        await File.WriteAllTextAsync(path, "Hello, World!");

        // Act
        var content = await _service.ReadFileAsync(path);

        // Assert
        Assert.Equal("Hello, World!", content);
    }

    [Fact]
    public void IsTextFile_ReturnsTrueForTextFiles()
    {
        var path = Path.Combine(_testDir, "test.cs");
        File.WriteAllText(path, "public class Test {}");

        Assert.True(_service.IsTextFile(path));
    }

    [Fact]
    public async Task ShouldIgnore_RespectsGitIgnorePatterns()
    {
        var patterns = new List<string> { "*.log", "node_modules/", "bin/" };

        Assert.True(_service.ShouldIgnore(
            Path.Combine(_testDir, "debug.log"), _testDir, patterns));

        Assert.True(_service.ShouldIgnore(
            Path.Combine(_testDir, "node_modules", "package"), _testDir, patterns));

        Assert.False(_service.ShouldIgnore(
            Path.Combine(_testDir, "src", "main.cs"), _testDir, patterns));
    }

    public void Dispose()
    {
        try { Directory.Delete(_testDir, recursive: true); } catch { }
    }
}
```

```csharp
// tests/SeniorIntern.Services.Tests/WorkspaceServiceTests.cs
public class WorkspaceServiceTests : IAsyncDisposable
{
    private readonly string _testDir;
    private readonly Mock<IWorkspaceRepository> _mockRepository;
    private readonly Mock<IFileSystemService> _mockFileSystem;
    private readonly Mock<ISettingsService> _mockSettings;
    private readonly WorkspaceService _service;

    public WorkspaceServiceTests()
    {
        _testDir = Path.Combine(Path.GetTempPath(), $"test_{Guid.NewGuid():N}");
        Directory.CreateDirectory(_testDir);

        _mockRepository = new Mock<IWorkspaceRepository>();
        _mockFileSystem = new Mock<IFileSystemService>();
        _mockSettings = new Mock<ISettingsService>();

        _mockFileSystem
            .Setup(x => x.LoadGitIgnorePatternsAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(new List<string>());

        _mockFileSystem
            .Setup(x => x.WatchDirectory(It.IsAny<string>(), It.IsAny<Action<FileSystemChangeEvent>>(), It.IsAny<bool>()))
            .Returns(Mock.Of<IDisposable>());

        _service = new WorkspaceService(
            _mockRepository.Object,
            _mockFileSystem.Object,
            _mockSettings.Object,
            NullLogger<WorkspaceService>.Instance);
    }

    [Fact]
    public async Task OpenWorkspaceAsync_CreatesNewWorkspace()
    {
        // Arrange
        _mockRepository
            .Setup(x => x.GetByPathAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync((Workspace?)null);

        // Act
        var workspace = await _service.OpenWorkspaceAsync(_testDir);

        // Assert
        Assert.NotNull(workspace);
        Assert.Equal(_testDir, workspace.RootPath);
        Assert.True(_service.HasOpenWorkspace);

        _mockRepository.Verify(
            x => x.AddOrUpdateAsync(It.IsAny<Workspace>(), It.IsAny<CancellationToken>()),
            Times.Once);
    }

    [Fact]
    public async Task OpenWorkspaceAsync_RaisesWorkspaceChangedEvent()
    {
        // Arrange
        WorkspaceChangedEventArgs? eventArgs = null;
        _service.WorkspaceChanged += (s, e) => eventArgs = e;

        // Act
        await _service.OpenWorkspaceAsync(_testDir);

        // Assert
        Assert.NotNull(eventArgs);
        Assert.Equal(WorkspaceChangeType.Opened, eventArgs.ChangeType);
        Assert.NotNull(eventArgs.CurrentWorkspace);
    }

    public async ValueTask DisposeAsync()
    {
        _service.Dispose();
        try { Directory.Delete(_testDir, recursive: true); } catch { }
        await Task.CompletedTask;
    }
}
```

### Integration Tests

```csharp
// tests/SeniorIntern.Integration.Tests/WorkspaceIntegrationTests.cs
public class WorkspaceIntegrationTests : IClassFixture<DatabaseFixture>, IDisposable
{
    private readonly string _testDir;
    private readonly DatabaseFixture _fixture;

    public WorkspaceIntegrationTests(DatabaseFixture fixture)
    {
        _fixture = fixture;
        _testDir = Path.Combine(Path.GetTempPath(), $"test_{Guid.NewGuid():N}");
        Directory.CreateDirectory(_testDir);
    }

    [Fact]
    public async Task Workspace_PersistsAcrossServiceInstances()
    {
        // Create and open workspace with first service instance
        using (var scope = _fixture.CreateScope())
        {
            var service = scope.GetRequiredService<IWorkspaceService>();
            await service.OpenWorkspaceAsync(_testDir);
            await service.SaveWorkspaceStateAsync();
        }

        // Verify workspace exists with second service instance
        using (var scope = _fixture.CreateScope())
        {
            var service = scope.GetRequiredService<IWorkspaceService>();
            var recent = await service.GetRecentWorkspacesAsync();

            Assert.Contains(recent, w => w.RootPath == _testDir);
        }
    }

    public void Dispose()
    {
        try { Directory.Delete(_testDir, recursive: true); } catch { }
    }
}
```

---

## Acceptance Criteria

### v0.3.1a - Core Models
- [ ] Workspace model stores all required properties (Id, RootPath, OpenFiles, etc.)
- [ ] FileSystemItem correctly identifies files vs directories
- [ ] FileContext properly calculates estimated tokens
- [ ] TokenEstimator provides reasonable estimates

### v0.3.1b - Database Entities
- [ ] Migration creates RecentWorkspaces and FileContextHistory tables
- [ ] RecentWorkspaceEntity correctly serializes/deserializes JSON arrays
- [ ] Foreign key constraints work properly
- [ ] Indexes are created for frequently queried columns

### v0.3.1c - Language Detection
- [ ] Detects 50+ common file extensions
- [ ] Handles special files (Dockerfile, Makefile, etc.)
- [ ] Case-insensitive extension matching
- [ ] Returns null for unknown extensions

### v0.3.1d - File System Service
- [ ] GetDirectoryContentsAsync returns sorted items (folders first)
- [ ] ReadFileAsync/WriteFileAsync work correctly
- [ ] WatchDirectory detects file changes with debouncing
- [ ] ShouldIgnore correctly matches gitignore patterns
- [ ] IsTextFile correctly identifies binary vs text files

### v0.3.1e - Workspace Service
- [ ] OpenWorkspaceAsync creates/restores workspace
- [ ] CloseWorkspaceAsync saves state and stops watcher
- [ ] GetRecentWorkspacesAsync returns valid workspaces only
- [ ] RestoreLastWorkspaceAsync respects settings
- [ ] Events fire correctly on workspace changes
- [ ] Auto-save timer persists state periodically

### v0.3.1f - Repository Layer
- [ ] AddOrUpdateAsync handles both insert and update
- [ ] GetRecentAsync returns workspaces sorted correctly (pinned first)
- [ ] Max recent limit is enforced
- [ ] SetPinnedAsync and RenameAsync work correctly

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| File watcher missing events | Medium | Low | Debounce + manual refresh option |
| Large directories slow to load | Medium | Medium | Lazy loading, pagination |
| Cross-platform path issues | Medium | High | Use Path.Combine, normalize paths |
| .gitignore pattern edge cases | Medium | Low | Test with real-world patterns |
| Concurrent workspace access | Low | Medium | SemaphoreSlim for thread safety |

---

## Performance Considerations

### Directory Loading
- Lazy load directory contents (don't pre-load entire tree)
- Use `EnumerateDirectories`/`EnumerateFiles` instead of `GetDirectories`/`GetFiles`
- Consider virtualization for large directories (>1000 items)

### File Watching
- Debounce file system events (200ms) to batch rapid changes
- Only watch workspace root, not individual files
- Stop watcher when workspace is closed

### Database Access
- Use indexes on frequently queried columns (RootPath, LastAccessedAt)
- Limit recent workspaces to prevent unbounded growth
- Use ExecuteUpdateAsync for single-property updates

---

## References

- [FileSystemWatcher Best Practices](https://docs.microsoft.com/en-us/dotnet/api/system.io.filesystemwatcher)
- [.gitignore Pattern Format](https://git-scm.com/docs/gitignore)
- [VSCode Language Identifiers](https://code.visualstudio.com/docs/languages/identifiers)
- [Entity Framework Core Performance](https://docs.microsoft.com/en-us/ef/core/performance/)
