# Design Specification: The Senior Intern v0.3.3 "Code Editor Integration"

## Executive Summary

This document provides a comprehensive design specification for v0.3.3, which integrates AvaloniaEdit as the primary code editor with syntax highlighting via TextMate grammars, a multi-tab interface, and standard editor features (save, undo/redo, find/replace, go-to-line). The code editor serves as the central workspace view where users read, write, and navigate code before attaching context to LLM conversations.

### v0.3.3 Scope (from v0.3.0 Design Document)
- AvaloniaEdit setup and configuration
- Syntax highlighting via TextMateSharp for 15+ languages
- Multi-tab editor interface with tab management
- Standard editor features: save, save all, undo/redo
- Find and replace functionality
- Go-to-line dialog
- Dirty state tracking and unsaved changes prompts
- Editor settings (font, tab size, line numbers, word wrap)
- Integration with File Explorer for opening files

### Dependencies
- **v0.3.1** must be complete (Workspace Service, File System Service)
- **v0.3.2** must be complete (File Explorer for file opening)

### New NuGet Packages

| Package | Version | Purpose |
|---------|---------|---------|
| AvaloniaEdit | 11.1.0 | Syntax-highlighting code editor control |
| TextMateSharp | 1.0.63 | TextMate grammar engine |
| TextMateSharp.Grammars | 1.0.63 | Pre-bundled language grammars |

---

## Sub-Part Breakdown

| Part | Name | Focus |
|------|------|-------|
| v0.3.3a | Editor Tab ViewModel | EditorTabViewModel with document, dirty state, caret tracking |
| v0.3.3b | Editor Panel ViewModel | EditorPanelViewModel with tab management, commands |
| v0.3.3c | Syntax Highlighting Service | TextMate integration, grammar loading, theme support |
| v0.3.3d | Editor Configuration | Editor setup, options binding, settings application |
| v0.3.3e | Editor Panel UI | Tab bar, editor area, empty state |
| v0.3.3f | Find & Replace | Search panel integration, find/replace functionality |
| v0.3.3g | Dialogs & Integration | Go-to-line dialog, unsaved changes, main window integration |

---

## Architecture Overview

### Component Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              MainWindow                                       │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │                         MainWindowViewModel                             │  │
│  │                                │                                        │  │
│  │          ┌─────────────────────┼─────────────────────┐                 │  │
│  │          ▼                     ▼                     ▼                 │  │
│  │  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐        │  │
│  │  │FileExplorerVM   │  │ EditorPanelVM   │  │  ChatViewModel  │        │  │
│  │  │ (v0.3.2)        │──│ (v0.3.3)        │  │  (v0.2.0)       │        │  │
│  │  └─────────────────┘  └─────────────────┘  └─────────────────┘        │  │
│  │          │                     │                                        │  │
│  │          │    OpenFile event   │                                        │  │
│  │          └────────────────────►│                                        │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────┘
                │
                ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                          EditorPanelViewModel                                 │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │ Properties:                                                             │  │
│  │ • Tabs: ObservableCollection<EditorTabViewModel>                       │  │
│  │ • ActiveTab: EditorTabViewModel?                                       │  │
│  │ • HasUnsavedChanges: bool                                              │  │
│  │ • HasOpenTabs: bool                                                    │  │
│  ├───────────────────────────────────────────────────────────────────────┤  │
│  │ Commands:                                                               │  │
│  │ • OpenFile, Save, SaveAs, SaveAll                                      │  │
│  │ • CloseTab, CloseAllTabs, CloseOtherTabs                               │  │
│  │ • ActivateTab, NextTab, PreviousTab                                    │  │
│  │ • Undo, Redo, Find, Replace, GoToLine                                  │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                │                                                             │
│                ▼                                                             │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │                       EditorTabViewModel                                │  │
│  │ • FilePath, FileName, DisplayTitle                                      │  │
│  │ • Document: TextDocument                                                │  │
│  │ • Language: string?                                                     │  │
│  │ • IsDirty, IsActive, IsReadOnly                                        │  │
│  │ • CaretLine, CaretColumn, Encoding, LineEnding                         │  │
│  │ • TextMateInstallation (for highlighting)                              │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────┘
                │
                ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                            Service Layer                                      │
│  ┌─────────────────────────┐        ┌─────────────────────────────────┐     │
│  │  SyntaxHighlightingService │      │      IFileSystemService          │     │
│  │ • GetRegistryOptions()   │        │ • ReadFileAsync                 │     │
│  │ • ApplyHighlighting()    │        │ • WriteFileAsync                │     │
│  │ • GetScopeForLanguage()  │        │ • FileExistsAsync               │     │
│  │ • ChangeTheme()          │        └─────────────────────────────────┘     │
│  └─────────────────────────┘                                                 │
│                                                                              │
│  ┌─────────────────────────┐        ┌─────────────────────────────────┐     │
│  │   EditorConfiguration   │        │     IDialogService              │     │
│  │ • ApplySettings()       │        │ • ShowSaveDialogAsync           │     │
│  │ • GetDefaultOptions()   │        │ • ShowConfirmDialogAsync        │     │
│  │ • BindToSettings()      │        │ • ShowGoToLineDialogAsync       │     │
│  └─────────────────────────┘        └─────────────────────────────────┘     │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Data Flow: Opening a File

```
User double-clicks file in File Explorer
                │
                ▼
┌──────────────────────────────┐
│ FileExplorerViewModel        │
│ .OpenFileCommand executed    │
└──────────────────────────────┘
                │
                ▼
┌──────────────────────────────┐
│ FileOpenRequested event      │
│ raised with file path        │
└──────────────────────────────┘
                │
                ▼
┌──────────────────────────────┐
│ EditorPanelViewModel         │
│ .OpenFileAsync(path)         │
└──────────────────────────────┘
                │
                ▼
┌──────────────────────────────┐
│ Check if file already open   │
│ (search Tabs by FilePath)    │
└──────────────────────────────┘
                │
        ┌───────┴───────┐
        ▼               ▼
   [Already Open]   [Not Open]
        │               │
        │               ▼
        │   ┌──────────────────────────┐
        │   │ IFileSystemService       │
        │   │ .ReadFileAsync(path)     │
        │   └──────────────────────────┘
        │               │
        │               ▼
        │   ┌──────────────────────────┐
        │   │ Detect language          │
        │   │ LanguageDetector.Detect  │
        │   └──────────────────────────┘
        │               │
        │               ▼
        │   ┌──────────────────────────┐
        │   │ Create EditorTabViewModel│
        │   │ • Set Document content   │
        │   │ • Set Language           │
        │   │ • Mark as saved          │
        │   └──────────────────────────┘
        │               │
        │               ▼
        │   ┌──────────────────────────┐
        │   │ SyntaxHighlightingService│
        │   │ .ApplyHighlighting()     │
        │   └──────────────────────────┘
        │               │
        │               ▼
        │   ┌──────────────────────────┐
        │   │ Add tab to Tabs          │
        │   │ collection               │
        │   └──────────────────────────┘
        │               │
        └───────┬───────┘
                ▼
┌──────────────────────────────┐
│ ActiveTab = tab              │
│ (UI binds and shows editor)  │
└──────────────────────────────┘
```

### Data Flow: Saving a File

```
User presses Ctrl+S (or clicks Save)
                │
                ▼
┌──────────────────────────────┐
│ SaveCommand executed         │
│ on EditorPanelViewModel      │
└──────────────────────────────┘
                │
                ▼
┌──────────────────────────────┐
│ Check if ActiveTab exists    │
│ and has changes              │
└──────────────────────────────┘
                │
        ┌───────┴───────┐
        ▼               ▼
   [No changes]     [Has changes]
        │               │
        │               ▼
        │   ┌──────────────────────────┐
        │   │ Check if file has path   │
        │   │ (new file vs existing)   │
        │   └──────────────────────────┘
        │               │
        │       ┌───────┴───────┐
        │       ▼               ▼
        │   [Has Path]      [No Path]
        │       │               │
        │       │               ▼
        │       │   ┌──────────────────────────┐
        │       │   │ IDialogService           │
        │       │   │ .ShowSaveDialogAsync()   │
        │       │   └──────────────────────────┘
        │       │               │
        │       │               ▼
        │       │   ┌──────────────────────────┐
        │       │   │ User selects path        │
        │       │   │ (or cancels)             │
        │       │   └──────────────────────────┘
        │       │               │
        │       └───────┬───────┘
        │               ▼
        │   ┌──────────────────────────┐
        │   │ IFileSystemService       │
        │   │ .WriteFileAsync()        │
        │   └──────────────────────────┘
        │               │
        │               ▼
        │   ┌──────────────────────────┐
        │   │ EditorTabViewModel       │
        │   │ .MarkAsSaved()           │
        │   │ IsDirty = false          │
        │   └──────────────────────────┘
        │               │
        └───────┬───────┘
                ▼
┌──────────────────────────────┐
│ UI updates                   │
│ (dirty indicator removed)    │
└──────────────────────────────┘
```

### Data Flow: Closing Tab with Unsaved Changes

```
User clicks X on tab or presses Ctrl+W
                │
                ▼
┌──────────────────────────────┐
│ CloseTabCommand executed     │
└──────────────────────────────┘
                │
                ▼
┌──────────────────────────────┐
│ Check tab.IsDirty            │
└──────────────────────────────┘
                │
        ┌───────┴───────┐
        ▼               ▼
   [Not Dirty]      [Is Dirty]
        │               │
        │               ▼
        │   ┌──────────────────────────┐
        │   │ IDialogService           │
        │   │ .ShowConfirmDialogAsync  │
        │   │ "Save changes to X?"     │
        │   │ [Save] [Don't Save]      │
        │   │ [Cancel]                 │
        │   └──────────────────────────┘
        │               │
        │       ┌───────┼───────┐
        │       ▼       ▼       ▼
        │    [Save]  [Don't] [Cancel]
        │       │    [Save]     │
        │       │       │       │
        │       ▼       │       │
        │   ┌────────┐  │       │
        │   │ Save   │  │       │
        │   │ file   │  │       │
        │   └────────┘  │       │
        │       │       │       │
        └───────┴───────┘       │
                │               │
                ▼               │
┌──────────────────────────────┐│
│ Remove tab from Tabs         ││
│ Activate next/prev tab       ││
└──────────────────────────────┘│
                                │
                        ┌───────┘
                        ▼
        ┌──────────────────────────┐
        │ Close cancelled          │
        │ (tab remains open)       │
        └──────────────────────────┘
```

---

## v0.3.3a: Editor Tab ViewModel

### Objective
Create the ViewModel for individual editor tabs managing document state, dirty tracking, caret position, and syntax highlighting configuration.

### EditorTabViewModel Implementation

```csharp
namespace SeniorIntern.Desktop.ViewModels;

using System;
using System.IO;
using System.Text;
using AvaloniaEdit.Document;
using CommunityToolkit.Mvvm.ComponentModel;
using SeniorIntern.Core.Utilities;

/// <summary>
/// ViewModel for a single editor tab representing an open file.
/// </summary>
public partial class EditorTabViewModel : ViewModelBase
{
    /// <summary>
    /// Unique identifier for this tab.
    /// </summary>
    [ObservableProperty]
    private Guid _id = Guid.NewGuid();

    /// <summary>
    /// Full path to the file on disk. Empty for new unsaved files.
    /// </summary>
    [ObservableProperty]
    private string _filePath = string.Empty;

    /// <summary>
    /// File name without path (e.g., "main.cs").
    /// </summary>
    [ObservableProperty]
    private string _fileName = string.Empty;

    /// <summary>
    /// The AvaloniaEdit document containing the text content.
    /// </summary>
    [ObservableProperty]
    private TextDocument _document = new();

    /// <summary>
    /// Detected language identifier (e.g., "csharp", "javascript").
    /// </summary>
    [ObservableProperty]
    private string? _language;

    /// <summary>
    /// Whether the document has unsaved changes.
    /// </summary>
    [ObservableProperty]
    private bool _isDirty;

    /// <summary>
    /// Whether this tab is currently active/focused.
    /// </summary>
    [ObservableProperty]
    private bool _isActive;

    /// <summary>
    /// Whether the file is read-only.
    /// </summary>
    [ObservableProperty]
    private bool _isReadOnly;

    /// <summary>
    /// Current caret line number (1-based).
    /// </summary>
    [ObservableProperty]
    private int _caretLine = 1;

    /// <summary>
    /// Current caret column number (1-based).
    /// </summary>
    [ObservableProperty]
    private int _caretColumn = 1;

    /// <summary>
    /// Character count of current selection (0 if no selection).
    /// </summary>
    [ObservableProperty]
    private int _selectionLength;

    /// <summary>
    /// File encoding (e.g., "UTF-8", "UTF-16").
    /// </summary>
    [ObservableProperty]
    private string _encoding = "UTF-8";

    /// <summary>
    /// Line ending type (e.g., "LF", "CRLF").
    /// </summary>
    [ObservableProperty]
    private string _lineEnding = "LF";

    /// <summary>
    /// Hash of the content when last saved, used for dirty detection.
    /// </summary>
    private int _savedContentHash;

    /// <summary>
    /// Display title for the tab (includes dirty indicator).
    /// </summary>
    public string DisplayTitle => IsDirty ? $"{FileName} •" : FileName;

    /// <summary>
    /// Whether this is a new file that hasn't been saved yet.
    /// </summary>
    public bool IsNewFile => string.IsNullOrEmpty(FilePath);

    /// <summary>
    /// Total line count in the document.
    /// </summary>
    public int LineCount => Document.LineCount;

    /// <summary>
    /// File extension including the dot (e.g., ".cs").
    /// </summary>
    public string Extension => Path.GetExtension(FileName);

    /// <summary>
    /// Cursor position display string (e.g., "Ln 45, Col 12").
    /// </summary>
    public string CursorPositionDisplay => SelectionLength > 0
        ? $"Ln {CaretLine}, Col {CaretColumn} ({SelectionLength} selected)"
        : $"Ln {CaretLine}, Col {CaretColumn}";

    /// <summary>
    /// Creates a new EditorTabViewModel for an existing file.
    /// </summary>
    public static EditorTabViewModel FromFile(string filePath, string content)
    {
        var tab = new EditorTabViewModel
        {
            FilePath = filePath,
            FileName = Path.GetFileName(filePath),
            Language = LanguageDetector.DetectByFileName(Path.GetFileName(filePath)),
        };

        // Detect encoding and line endings from content
        tab.DetectEncodingAndLineEnding(content);

        // Set document content
        tab.Document.Text = content;
        tab._savedContentHash = content.GetHashCode();

        // Subscribe to document changes
        tab.Document.TextChanged += tab.OnDocumentTextChanged;

        return tab;
    }

    /// <summary>
    /// Creates a new EditorTabViewModel for a new unsaved file.
    /// </summary>
    public static EditorTabViewModel CreateNew(string? suggestedName = null, string? language = null)
    {
        var fileName = suggestedName ?? "Untitled";
        var counter = 1;

        // Add number suffix if needed (handled by caller typically)
        var tab = new EditorTabViewModel
        {
            FileName = fileName,
            Language = language,
            IsDirty = false, // New empty files start as not dirty
        };

        tab._savedContentHash = string.Empty.GetHashCode();
        tab.Document.TextChanged += tab.OnDocumentTextChanged;

        return tab;
    }

    /// <summary>
    /// Marks the document as saved, resetting dirty state.
    /// </summary>
    public void MarkAsSaved(string? newFilePath = null)
    {
        if (!string.IsNullOrEmpty(newFilePath))
        {
            FilePath = newFilePath;
            FileName = Path.GetFileName(newFilePath);
            Language = LanguageDetector.DetectByFileName(FileName);
        }

        _savedContentHash = Document.Text.GetHashCode();
        IsDirty = false;
        OnPropertyChanged(nameof(DisplayTitle));
    }

    /// <summary>
    /// Gets the current document content as a string.
    /// </summary>
    public string GetContent()
    {
        return Document.Text;
    }

    /// <summary>
    /// Updates caret position from the editor.
    /// </summary>
    public void UpdateCaretPosition(int line, int column, int selectionLength = 0)
    {
        CaretLine = line;
        CaretColumn = column;
        SelectionLength = selectionLength;
        OnPropertyChanged(nameof(CursorPositionDisplay));
    }

    /// <summary>
    /// Navigates to a specific line in the document.
    /// </summary>
    public int GetOffsetForLine(int lineNumber)
    {
        if (lineNumber < 1) lineNumber = 1;
        if (lineNumber > Document.LineCount) lineNumber = Document.LineCount;

        return Document.GetLineByNumber(lineNumber).Offset;
    }

    private void OnDocumentTextChanged(object? sender, EventArgs e)
    {
        var currentHash = Document.Text.GetHashCode();
        var wasDirty = IsDirty;
        IsDirty = currentHash != _savedContentHash;

        if (wasDirty != IsDirty)
        {
            OnPropertyChanged(nameof(DisplayTitle));
        }

        OnPropertyChanged(nameof(LineCount));
    }

    private void DetectEncodingAndLineEnding(string content)
    {
        // Detect line ending
        if (content.Contains("\r\n"))
        {
            LineEnding = "CRLF";
        }
        else if (content.Contains('\r'))
        {
            LineEnding = "CR";
        }
        else
        {
            LineEnding = "LF";
        }

        // Encoding is typically determined when reading the file
        // Default to UTF-8 for now; actual detection happens in FileSystemService
        Encoding = "UTF-8";
    }

    /// <summary>
    /// Cleanup when tab is closed.
    /// </summary>
    public void Dispose()
    {
        Document.TextChanged -= OnDocumentTextChanged;
    }
}
```

### EditorTabViewModel Properties Summary

| Property | Type | Description |
|----------|------|-------------|
| `Id` | `Guid` | Unique tab identifier |
| `FilePath` | `string` | Full file path (empty for new files) |
| `FileName` | `string` | File name for display |
| `Document` | `TextDocument` | AvaloniaEdit document |
| `Language` | `string?` | Language identifier |
| `IsDirty` | `bool` | Has unsaved changes |
| `IsActive` | `bool` | Currently selected tab |
| `IsReadOnly` | `bool` | File is read-only |
| `CaretLine` | `int` | Current line (1-based) |
| `CaretColumn` | `int` | Current column (1-based) |
| `SelectionLength` | `int` | Selected characters count |
| `Encoding` | `string` | File encoding display |
| `LineEnding` | `string` | Line ending type |

### Files to Create (v0.3.3a)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/ViewModels/EditorTabViewModel.cs` | Editor tab ViewModel |

### Files to Modify (v0.3.3a)

None - this is a standalone component.

### Acceptance Criteria (v0.3.3a)
- [ ] EditorTabViewModel can be created from file path and content
- [ ] EditorTabViewModel can be created as new unsaved file
- [ ] Document changes are tracked for dirty state
- [ ] Dirty state updates correctly on edit and save
- [ ] Caret position tracking works
- [ ] Line count updates on document change

---

## v0.3.3b: Editor Panel ViewModel

### Objective
Create the main ViewModel managing multiple editor tabs, tab operations, and editor commands.

### EditorPanelViewModel Implementation

```csharp
namespace SeniorIntern.Desktop.ViewModels;

using System;
using System.Collections.ObjectModel;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Utilities;
using SeniorIntern.Desktop.Services;

/// <summary>
/// ViewModel for the editor panel managing multiple tabs and editor operations.
/// </summary>
public partial class EditorPanelViewModel : ViewModelBase
{
    private readonly IFileSystemService _fileSystemService;
    private readonly SyntaxHighlightingService _syntaxService;
    private readonly IDialogService _dialogService;
    private int _untitledCounter = 1;

    /// <summary>
    /// Collection of open editor tabs.
    /// </summary>
    [ObservableProperty]
    private ObservableCollection<EditorTabViewModel> _tabs = new();

    /// <summary>
    /// Currently active/focused tab.
    /// </summary>
    [ObservableProperty]
    private EditorTabViewModel? _activeTab;

    /// <summary>
    /// Whether any tab has unsaved changes.
    /// </summary>
    public bool HasUnsavedChanges => Tabs.Any(t => t.IsDirty);

    /// <summary>
    /// Whether there are any open tabs.
    /// </summary>
    public bool HasOpenTabs => Tabs.Count > 0;

    /// <summary>
    /// Number of tabs with unsaved changes.
    /// </summary>
    public int UnsavedTabsCount => Tabs.Count(t => t.IsDirty);

    /// <summary>
    /// Event raised when a file should be revealed in the file explorer.
    /// </summary>
    public event EventHandler<string>? RevealInExplorerRequested;

    public EditorPanelViewModel(
        IFileSystemService fileSystemService,
        SyntaxHighlightingService syntaxService,
        IDialogService dialogService)
    {
        _fileSystemService = fileSystemService;
        _syntaxService = syntaxService;
        _dialogService = dialogService;

        // Update computed properties when tabs change
        Tabs.CollectionChanged += (s, e) =>
        {
            OnPropertyChanged(nameof(HasUnsavedChanges));
            OnPropertyChanged(nameof(HasOpenTabs));
            OnPropertyChanged(nameof(UnsavedTabsCount));
        };
    }

    partial void OnActiveTabChanged(EditorTabViewModel? oldValue, EditorTabViewModel? newValue)
    {
        // Deactivate old tab
        if (oldValue != null)
        {
            oldValue.IsActive = false;
        }

        // Activate new tab
        if (newValue != null)
        {
            newValue.IsActive = true;
        }
    }

    #region File Operations

    /// <summary>
    /// Opens a file in a new tab or activates existing tab if already open.
    /// </summary>
    [RelayCommand]
    public async Task OpenFileAsync(string filePath, CancellationToken ct = default)
    {
        // Check if already open
        var existingTab = Tabs.FirstOrDefault(t =>
            string.Equals(t.FilePath, filePath, StringComparison.OrdinalIgnoreCase));

        if (existingTab != null)
        {
            ActiveTab = existingTab;
            return;
        }

        try
        {
            // Read file content
            var content = await _fileSystemService.ReadFileAsync(filePath, ct);

            // Create tab
            var tab = EditorTabViewModel.FromFile(filePath, content);

            // Add to collection
            Tabs.Add(tab);
            ActiveTab = tab;
        }
        catch (Exception ex)
        {
            await _dialogService.ShowErrorAsync(
                "Error Opening File",
                $"Could not open {Path.GetFileName(filePath)}: {ex.Message}");
        }
    }

    /// <summary>
    /// Creates a new untitled file in a new tab.
    /// </summary>
    [RelayCommand]
    public void NewFile()
    {
        var fileName = $"Untitled-{_untitledCounter++}";
        var tab = EditorTabViewModel.CreateNew(fileName);

        Tabs.Add(tab);
        ActiveTab = tab;
    }

    /// <summary>
    /// Saves the active tab.
    /// </summary>
    [RelayCommand]
    public async Task SaveAsync(CancellationToken ct = default)
    {
        if (ActiveTab == null) return;
        await SaveTabAsync(ActiveTab, ct);
    }

    /// <summary>
    /// Saves the active tab with a new file name.
    /// </summary>
    [RelayCommand]
    public async Task SaveAsAsync(CancellationToken ct = default)
    {
        if (ActiveTab == null) return;
        await SaveTabAsAsync(ActiveTab, ct);
    }

    /// <summary>
    /// Saves all tabs with unsaved changes.
    /// </summary>
    [RelayCommand]
    public async Task SaveAllAsync(CancellationToken ct = default)
    {
        foreach (var tab in Tabs.Where(t => t.IsDirty))
        {
            await SaveTabAsync(tab, ct);
        }
    }

    private async Task<bool> SaveTabAsync(EditorTabViewModel tab, CancellationToken ct = default)
    {
        // If new file, prompt for save location
        if (tab.IsNewFile)
        {
            return await SaveTabAsAsync(tab, ct);
        }

        try
        {
            await _fileSystemService.WriteFileAsync(tab.FilePath, tab.GetContent(), ct);
            tab.MarkAsSaved();
            OnPropertyChanged(nameof(HasUnsavedChanges));
            OnPropertyChanged(nameof(UnsavedTabsCount));
            return true;
        }
        catch (Exception ex)
        {
            await _dialogService.ShowErrorAsync(
                "Error Saving File",
                $"Could not save {tab.FileName}: {ex.Message}");
            return false;
        }
    }

    private async Task<bool> SaveTabAsAsync(EditorTabViewModel tab, CancellationToken ct = default)
    {
        var suggestedName = tab.IsNewFile ? tab.FileName + ".txt" : tab.FileName;

        var filePath = await _dialogService.ShowSaveDialogAsync(
            "Save File As",
            suggestedName,
            GetFileFilters(tab.Language));

        if (string.IsNullOrEmpty(filePath)) return false;

        try
        {
            await _fileSystemService.WriteFileAsync(filePath, tab.GetContent(), ct);
            tab.MarkAsSaved(filePath);
            OnPropertyChanged(nameof(HasUnsavedChanges));
            OnPropertyChanged(nameof(UnsavedTabsCount));
            return true;
        }
        catch (Exception ex)
        {
            await _dialogService.ShowErrorAsync(
                "Error Saving File",
                $"Could not save to {filePath}: {ex.Message}");
            return false;
        }
    }

    #endregion

    #region Tab Management

    /// <summary>
    /// Activates a specific tab.
    /// </summary>
    [RelayCommand]
    public void ActivateTab(EditorTabViewModel tab)
    {
        if (Tabs.Contains(tab))
        {
            ActiveTab = tab;
        }
    }

    /// <summary>
    /// Closes a specific tab, prompting for save if dirty.
    /// </summary>
    [RelayCommand]
    public async Task CloseTabAsync(EditorTabViewModel tab, CancellationToken ct = default)
    {
        if (!await PromptSaveChangesAsync(tab, ct)) return;

        var index = Tabs.IndexOf(tab);
        tab.Dispose();
        Tabs.Remove(tab);

        // Activate adjacent tab if this was active
        if (ActiveTab == tab && Tabs.Count > 0)
        {
            var newIndex = Math.Min(index, Tabs.Count - 1);
            ActiveTab = Tabs[newIndex];
        }
        else if (Tabs.Count == 0)
        {
            ActiveTab = null;
        }
    }

    /// <summary>
    /// Closes all tabs, prompting for save if any are dirty.
    /// </summary>
    [RelayCommand]
    public async Task CloseAllTabsAsync(CancellationToken ct = default)
    {
        // Process tabs in reverse to handle removal safely
        for (int i = Tabs.Count - 1; i >= 0; i--)
        {
            var tab = Tabs[i];
            if (!await PromptSaveChangesAsync(tab, ct)) return; // Cancelled

            tab.Dispose();
            Tabs.RemoveAt(i);
        }

        ActiveTab = null;
    }

    /// <summary>
    /// Closes all tabs except the specified one.
    /// </summary>
    [RelayCommand]
    public async Task CloseOtherTabsAsync(EditorTabViewModel keepTab, CancellationToken ct = default)
    {
        var tabsToClose = Tabs.Where(t => t != keepTab).ToList();

        foreach (var tab in tabsToClose)
        {
            if (!await PromptSaveChangesAsync(tab, ct)) return;

            tab.Dispose();
            Tabs.Remove(tab);
        }

        ActiveTab = keepTab;
    }

    /// <summary>
    /// Closes tabs to the right of the specified tab.
    /// </summary>
    [RelayCommand]
    public async Task CloseTabsToRightAsync(EditorTabViewModel tab, CancellationToken ct = default)
    {
        var index = Tabs.IndexOf(tab);
        if (index < 0) return;

        for (int i = Tabs.Count - 1; i > index; i--)
        {
            var tabToClose = Tabs[i];
            if (!await PromptSaveChangesAsync(tabToClose, ct)) return;

            tabToClose.Dispose();
            Tabs.RemoveAt(i);
        }
    }

    /// <summary>
    /// Activates the next tab (wraps around).
    /// </summary>
    [RelayCommand]
    public void NextTab()
    {
        if (Tabs.Count < 2 || ActiveTab == null) return;

        var index = Tabs.IndexOf(ActiveTab);
        var nextIndex = (index + 1) % Tabs.Count;
        ActiveTab = Tabs[nextIndex];
    }

    /// <summary>
    /// Activates the previous tab (wraps around).
    /// </summary>
    [RelayCommand]
    public void PreviousTab()
    {
        if (Tabs.Count < 2 || ActiveTab == null) return;

        var index = Tabs.IndexOf(ActiveTab);
        var prevIndex = (index - 1 + Tabs.Count) % Tabs.Count;
        ActiveTab = Tabs[prevIndex];
    }

    /// <summary>
    /// Reorders tabs via drag-drop.
    /// </summary>
    public void MoveTab(int fromIndex, int toIndex)
    {
        if (fromIndex < 0 || fromIndex >= Tabs.Count) return;
        if (toIndex < 0 || toIndex >= Tabs.Count) return;
        if (fromIndex == toIndex) return;

        var tab = Tabs[fromIndex];
        Tabs.RemoveAt(fromIndex);
        Tabs.Insert(toIndex, tab);
    }

    #endregion

    #region Editor Commands

    /// <summary>
    /// Executes undo on the active editor.
    /// </summary>
    [RelayCommand]
    public void Undo()
    {
        // Handled by the view binding to TextEditor.Undo
        // This command is for menu/toolbar binding
        UndoRequested?.Invoke(this, EventArgs.Empty);
    }

    /// <summary>
    /// Executes redo on the active editor.
    /// </summary>
    [RelayCommand]
    public void Redo()
    {
        RedoRequested?.Invoke(this, EventArgs.Empty);
    }

    /// <summary>
    /// Opens the find panel.
    /// </summary>
    [RelayCommand]
    public void Find()
    {
        FindRequested?.Invoke(this, EventArgs.Empty);
    }

    /// <summary>
    /// Opens the replace panel.
    /// </summary>
    [RelayCommand]
    public void Replace()
    {
        ReplaceRequested?.Invoke(this, EventArgs.Empty);
    }

    /// <summary>
    /// Opens the go-to-line dialog.
    /// </summary>
    [RelayCommand]
    public async Task GoToLineAsync()
    {
        if (ActiveTab == null) return;

        var lineNumber = await _dialogService.ShowGoToLineDialogAsync(
            ActiveTab.LineCount,
            ActiveTab.CaretLine);

        if (lineNumber.HasValue)
        {
            GoToLineRequested?.Invoke(this, lineNumber.Value);
        }
    }

    /// <summary>
    /// Reveals the active file in the file explorer.
    /// </summary>
    [RelayCommand]
    public void RevealInExplorer()
    {
        if (ActiveTab == null || ActiveTab.IsNewFile) return;
        RevealInExplorerRequested?.Invoke(this, ActiveTab.FilePath);
    }

    // Events for view to handle editor-specific operations
    public event EventHandler? UndoRequested;
    public event EventHandler? RedoRequested;
    public event EventHandler? FindRequested;
    public event EventHandler? ReplaceRequested;
    public event EventHandler<int>? GoToLineRequested;

    #endregion

    #region Helpers

    /// <summary>
    /// Prompts user to save changes if tab is dirty.
    /// </summary>
    /// <returns>True if operation should continue, false if cancelled.</returns>
    public async Task<bool> PromptSaveChangesAsync(EditorTabViewModel tab, CancellationToken ct = default)
    {
        if (!tab.IsDirty) return true;

        var result = await _dialogService.ShowConfirmDialogAsync(
            "Unsaved Changes",
            $"Do you want to save changes to {tab.FileName}?",
            new[] { "Save", "Don't Save", "Cancel" });

        return result switch
        {
            "Save" => await SaveTabAsync(tab, ct),
            "Don't Save" => true,
            _ => false // Cancel
        };
    }

    /// <summary>
    /// Checks if it's safe to close the application (no unsaved changes or user confirmed).
    /// </summary>
    public async Task<bool> CanCloseAsync(CancellationToken ct = default)
    {
        foreach (var tab in Tabs.Where(t => t.IsDirty))
        {
            if (!await PromptSaveChangesAsync(tab, ct)) return false;
        }
        return true;
    }

    /// <summary>
    /// Gets the tab for a specific file path, if open.
    /// </summary>
    public EditorTabViewModel? GetTabByPath(string filePath)
    {
        return Tabs.FirstOrDefault(t =>
            string.Equals(t.FilePath, filePath, StringComparison.OrdinalIgnoreCase));
    }

    /// <summary>
    /// Checks if a file is currently open.
    /// </summary>
    public bool IsFileOpen(string filePath)
    {
        return GetTabByPath(filePath) != null;
    }

    private static IReadOnlyList<(string Name, string[] Extensions)> GetFileFilters(string? language)
    {
        return language switch
        {
            "csharp" => new[] { ("C# Files", new[] { "*.cs" }), ("All Files", new[] { "*.*" }) },
            "javascript" => new[] { ("JavaScript Files", new[] { "*.js", "*.jsx" }), ("All Files", new[] { "*.*" }) },
            "typescript" => new[] { ("TypeScript Files", new[] { "*.ts", "*.tsx" }), ("All Files", new[] { "*.*" }) },
            "python" => new[] { ("Python Files", new[] { "*.py" }), ("All Files", new[] { "*.*" }) },
            "json" => new[] { ("JSON Files", new[] { "*.json" }), ("All Files", new[] { "*.*" }) },
            "xml" => new[] { ("XML Files", new[] { "*.xml", "*.axaml" }), ("All Files", new[] { "*.*" }) },
            _ => new[] { ("All Files", new[] { "*.*" }) }
        };
    }

    #endregion
}
```

### EditorPanelViewModel Commands Summary

| Command | Description | Shortcut |
|---------|-------------|----------|
| `OpenFileCommand` | Opens a file in a new or existing tab | - |
| `NewFileCommand` | Creates a new untitled file | Ctrl+N |
| `SaveCommand` | Saves the active tab | Ctrl+S |
| `SaveAsCommand` | Saves with new name | Ctrl+Shift+S |
| `SaveAllCommand` | Saves all dirty tabs | Ctrl+Alt+S |
| `CloseTabCommand` | Closes a tab | Ctrl+W |
| `CloseAllTabsCommand` | Closes all tabs | Ctrl+Shift+W |
| `CloseOtherTabsCommand` | Closes all except one | - |
| `NextTabCommand` | Activates next tab | Ctrl+Tab |
| `PreviousTabCommand` | Activates previous tab | Ctrl+Shift+Tab |
| `UndoCommand` | Undo last edit | Ctrl+Z |
| `RedoCommand` | Redo last undo | Ctrl+Y |
| `FindCommand` | Open find panel | Ctrl+F |
| `ReplaceCommand` | Open replace panel | Ctrl+H |
| `GoToLineCommand` | Go to line dialog | Ctrl+G |

### Files to Create (v0.3.3b)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/ViewModels/EditorPanelViewModel.cs` | Editor panel ViewModel |

### Files to Modify (v0.3.3b)

None - depends on services created in later parts.

### Acceptance Criteria (v0.3.3b)
- [ ] Can open files in new tabs
- [ ] Already-open files activate existing tab
- [ ] Can create new untitled files
- [ ] Save/SaveAs/SaveAll work correctly
- [ ] Close tab prompts for unsaved changes
- [ ] Tab navigation (next/previous) works
- [ ] Close other tabs / close all works

---

## v0.3.3c: Syntax Highlighting Service

### Objective
Integrate TextMateSharp for syntax highlighting with support for 15+ languages and theme switching.

### SyntaxHighlightingService Implementation

```csharp
namespace SeniorIntern.Desktop.Services;

using System;
using System.Collections.Generic;
using AvaloniaEdit;
using TextMateSharp.Grammars;
using TextMateSharp.Registry;
using TextMateSharp.Themes;
using AvaloniaEdit.TextMate;

/// <summary>
/// Provides syntax highlighting using TextMate grammars.
/// </summary>
public sealed class SyntaxHighlightingService : IDisposable
{
    private readonly RegistryOptions _registryOptions;
    private readonly Dictionary<string, string> _languageToScope;
    private readonly Dictionary<TextEditor, TextMate.Installation> _installations = new();
    private ThemeName _currentTheme;

    public SyntaxHighlightingService(bool useDarkTheme = true)
    {
        _currentTheme = useDarkTheme ? ThemeName.DarkPlus : ThemeName.LightPlus;
        _registryOptions = new RegistryOptions(_currentTheme);

        _languageToScope = BuildLanguageScopeMap();
    }

    /// <summary>
    /// Available themes for syntax highlighting.
    /// </summary>
    public static IReadOnlyList<ThemeName> AvailableThemes { get; } = new[]
    {
        ThemeName.DarkPlus,
        ThemeName.LightPlus,
        ThemeName.Monokai,
        ThemeName.SolarizedDark,
        ThemeName.SolarizedLight,
        ThemeName.HighContrastDark,
        ThemeName.HighContrastLight,
    };

    /// <summary>
    /// Currently active theme.
    /// </summary>
    public ThemeName CurrentTheme => _currentTheme;

    /// <summary>
    /// Gets the TextMate registry options.
    /// </summary>
    public RegistryOptions RegistryOptions => _registryOptions;

    /// <summary>
    /// Applies syntax highlighting to an editor for the specified language.
    /// </summary>
    public TextMate.Installation ApplyHighlighting(TextEditor editor, string? language)
    {
        // Remove existing installation if any
        if (_installations.TryGetValue(editor, out var existing))
        {
            existing.Dispose();
            _installations.Remove(editor);
        }

        // Create new installation
        var installation = editor.InstallTextMate(_registryOptions);

        // Set grammar if language is specified
        if (!string.IsNullOrEmpty(language) && _languageToScope.TryGetValue(language, out var scope))
        {
            try
            {
                installation.SetGrammar(scope);
            }
            catch (Exception)
            {
                // Grammar not found, continue without highlighting
            }
        }

        _installations[editor] = installation;
        return installation;
    }

    /// <summary>
    /// Updates the grammar for an existing editor installation.
    /// </summary>
    public void SetLanguage(TextEditor editor, string? language)
    {
        if (!_installations.TryGetValue(editor, out var installation)) return;

        if (string.IsNullOrEmpty(language))
        {
            // Clear grammar
            installation.SetGrammar(null);
            return;
        }

        if (_languageToScope.TryGetValue(language, out var scope))
        {
            try
            {
                installation.SetGrammar(scope);
            }
            catch (Exception)
            {
                // Grammar not found
            }
        }
    }

    /// <summary>
    /// Changes the theme for all registered editors.
    /// </summary>
    public void ChangeTheme(ThemeName theme)
    {
        if (_currentTheme == theme) return;

        _currentTheme = theme;

        // Update registry options
        var newOptions = new RegistryOptions(theme);

        // Re-apply to all editors
        foreach (var (editor, installation) in _installations.ToArray())
        {
            var currentScope = GetCurrentScope(installation);

            installation.Dispose();
            _installations.Remove(editor);

            var newInstallation = editor.InstallTextMate(newOptions);
            if (!string.IsNullOrEmpty(currentScope))
            {
                try
                {
                    newInstallation.SetGrammar(currentScope);
                }
                catch { }
            }

            _installations[editor] = newInstallation;
        }
    }

    /// <summary>
    /// Removes syntax highlighting from an editor.
    /// </summary>
    public void RemoveHighlighting(TextEditor editor)
    {
        if (_installations.TryGetValue(editor, out var installation))
        {
            installation.Dispose();
            _installations.Remove(editor);
        }
    }

    /// <summary>
    /// Gets the scope name for a language identifier.
    /// </summary>
    public string? GetScopeForLanguage(string language)
    {
        return _languageToScope.TryGetValue(language, out var scope) ? scope : null;
    }

    /// <summary>
    /// Gets all supported languages.
    /// </summary>
    public IReadOnlyList<string> SupportedLanguages => _languageToScope.Keys.ToList();

    private static Dictionary<string, string> BuildLanguageScopeMap()
    {
        return new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
        {
            // .NET Languages
            ["csharp"] = "source.cs",
            ["fsharp"] = "source.fsharp",
            ["vb"] = "source.asp.vb.net",

            // Web Languages
            ["javascript"] = "source.js",
            ["javascriptreact"] = "source.js.jsx",
            ["typescript"] = "source.ts",
            ["typescriptreact"] = "source.tsx",
            ["html"] = "text.html.basic",
            ["css"] = "source.css",
            ["scss"] = "source.css.scss",
            ["less"] = "source.css.less",
            ["vue"] = "source.vue",

            // Systems Languages
            ["c"] = "source.c",
            ["cpp"] = "source.cpp",
            ["rust"] = "source.rust",
            ["go"] = "source.go",

            // Scripting Languages
            ["python"] = "source.python",
            ["ruby"] = "source.ruby",
            ["php"] = "source.php",
            ["perl"] = "source.perl",
            ["lua"] = "source.lua",

            // JVM Languages
            ["java"] = "source.java",
            ["kotlin"] = "source.kotlin",
            ["scala"] = "source.scala",
            ["groovy"] = "source.groovy",

            // Shell/Scripts
            ["shellscript"] = "source.shell",
            ["bash"] = "source.shell",
            ["powershell"] = "source.powershell",
            ["bat"] = "source.batchfile",

            // Data/Config
            ["json"] = "source.json",
            ["jsonc"] = "source.json.comments",
            ["xml"] = "text.xml",
            ["yaml"] = "source.yaml",
            ["toml"] = "source.toml",
            ["ini"] = "source.ini",
            ["properties"] = "source.ini",

            // Markup
            ["markdown"] = "text.html.markdown",
            ["latex"] = "text.tex.latex",
            ["restructuredtext"] = "text.restructuredtext",

            // Database
            ["sql"] = "source.sql",

            // Other
            ["dockerfile"] = "source.dockerfile",
            ["makefile"] = "source.makefile",
            ["cmake"] = "source.cmake",
            ["diff"] = "source.diff",
            ["gitignore"] = "source.ignore",
            ["r"] = "source.r",
            ["swift"] = "source.swift",
            ["objective-c"] = "source.objc",
        };
    }

    private static string? GetCurrentScope(TextMate.Installation installation)
    {
        // TextMate.Installation doesn't expose current scope directly
        // We'll need to track this separately if needed
        return null;
    }

    public void Dispose()
    {
        foreach (var installation in _installations.Values)
        {
            installation.Dispose();
        }
        _installations.Clear();
    }
}
```

### Language Support Summary

| Category | Languages |
|----------|-----------|
| **.NET** | C#, F#, VB.NET |
| **Web** | JavaScript, TypeScript, JSX, TSX, HTML, CSS, SCSS, Less, Vue |
| **Systems** | C, C++, Rust, Go |
| **Scripting** | Python, Ruby, PHP, Perl, Lua |
| **JVM** | Java, Kotlin, Scala, Groovy |
| **Shell** | Bash, PowerShell, Batch |
| **Data/Config** | JSON, XML, YAML, TOML, INI |
| **Markup** | Markdown, LaTeX, reStructuredText |
| **Other** | SQL, Dockerfile, Makefile, CMake, Swift, Objective-C |

### Files to Create (v0.3.3c)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/Services/SyntaxHighlightingService.cs` | TextMate integration |

### Files to Modify (v0.3.3c)

None.

### Acceptance Criteria (v0.3.3c)
- [ ] SyntaxHighlightingService initializes with TextMate registry
- [ ] Can apply highlighting to editor for any supported language
- [ ] Can change grammar without recreating installation
- [ ] Theme switching updates all registered editors
- [ ] Unsupported languages degrade gracefully (no crash)
- [ ] Cleanup properly disposes installations

---

## v0.3.3d: Editor Configuration

### Objective
Create the configuration service that applies user settings to editors and manages editor options.

### EditorConfiguration Implementation

```csharp
namespace SeniorIntern.Desktop.Services;

using System;
using Avalonia.Media;
using AvaloniaEdit;
using AvaloniaEdit.Editing;
using SeniorIntern.Core.Models;

/// <summary>
/// Configures TextEditor instances based on application settings.
/// </summary>
public static class EditorConfiguration
{
    /// <summary>
    /// Default editor font family.
    /// </summary>
    public const string DefaultFontFamily = "Cascadia Code, Consolas, Monaco, monospace";

    /// <summary>
    /// Default editor font size.
    /// </summary>
    public const int DefaultFontSize = 14;

    /// <summary>
    /// Default tab size.
    /// </summary>
    public const int DefaultTabSize = 4;

    /// <summary>
    /// Applies all settings to an editor instance.
    /// </summary>
    public static void ApplySettings(TextEditor editor, AppSettings settings)
    {
        if (editor == null) throw new ArgumentNullException(nameof(editor));
        if (settings == null) throw new ArgumentNullException(nameof(settings));

        // Font settings
        ApplyFontSettings(editor, settings);

        // Display settings
        ApplyDisplaySettings(editor, settings);

        // Editing settings
        ApplyEditingSettings(editor, settings);

        // Behavior settings
        ApplyBehaviorSettings(editor, settings);
    }

    /// <summary>
    /// Applies font-related settings.
    /// </summary>
    public static void ApplyFontSettings(TextEditor editor, AppSettings settings)
    {
        editor.FontFamily = new FontFamily(
            string.IsNullOrEmpty(settings.EditorFontFamily)
                ? DefaultFontFamily
                : settings.EditorFontFamily);

        editor.FontSize = settings.EditorFontSize > 0
            ? settings.EditorFontSize
            : DefaultFontSize;
    }

    /// <summary>
    /// Applies display settings (line numbers, highlighting, etc.).
    /// </summary>
    public static void ApplyDisplaySettings(TextEditor editor, AppSettings settings)
    {
        editor.ShowLineNumbers = settings.ShowLineNumbers;
        editor.WordWrap = settings.WordWrap;
        editor.Options.HighlightCurrentLine = settings.HighlightCurrentLine;

        // Additional display options
        editor.Options.ShowEndOfLine = false;
        editor.Options.ShowSpaces = false;
        editor.Options.ShowTabs = false;
        editor.Options.EnableHyperlinks = true;
        editor.Options.RequireControlModifierForHyperlinkClick = true;
    }

    /// <summary>
    /// Applies editing settings (tabs, indentation).
    /// </summary>
    public static void ApplyEditingSettings(TextEditor editor, AppSettings settings)
    {
        editor.Options.ConvertTabsToSpaces = settings.ConvertTabsToSpaces;
        editor.Options.IndentationSize = settings.TabSize > 0
            ? settings.TabSize
            : DefaultTabSize;

        // Smart indentation
        editor.Options.EnableTextDragDrop = true;
        editor.Options.CutCopyWholeLine = true;
    }

    /// <summary>
    /// Applies behavior settings.
    /// </summary>
    public static void ApplyBehaviorSettings(TextEditor editor, AppSettings settings)
    {
        // Selection and scrolling
        editor.Options.EnableVirtualSpace = false;
        editor.Options.EnableRectangularSelection = true;
        editor.Options.AllowScrollBelowDocument = true;

        // Column ruler (if position > 0)
        if (settings.RulerColumn > 0)
        {
            editor.Options.ShowColumnRuler = true;
            editor.Options.ColumnRulerPosition = settings.RulerColumn;
        }
        else
        {
            editor.Options.ShowColumnRuler = false;
        }
    }

    /// <summary>
    /// Gets default options for a new editor.
    /// </summary>
    public static void ApplyDefaults(TextEditor editor)
    {
        // Font
        editor.FontFamily = new FontFamily(DefaultFontFamily);
        editor.FontSize = DefaultFontSize;

        // Display
        editor.ShowLineNumbers = true;
        editor.WordWrap = false;
        editor.Options.HighlightCurrentLine = true;

        // Editing
        editor.Options.ConvertTabsToSpaces = true;
        editor.Options.IndentationSize = DefaultTabSize;

        // Behavior
        editor.Options.EnableTextDragDrop = true;
        editor.Options.CutCopyWholeLine = true;
        editor.Options.EnableRectangularSelection = true;
        editor.Options.AllowScrollBelowDocument = true;

        // Visual
        editor.Options.ShowEndOfLine = false;
        editor.Options.ShowSpaces = false;
        editor.Options.ShowTabs = false;
        editor.Options.EnableHyperlinks = true;
        editor.Options.ShowColumnRuler = false;
    }

    /// <summary>
    /// Creates bindings between editor and settings for live updates.
    /// </summary>
    public static IDisposable BindToSettings(TextEditor editor, AppSettings settings)
    {
        var subscription = new SettingsBindingSubscription(editor, settings);
        return subscription;
    }

    private sealed class SettingsBindingSubscription : IDisposable
    {
        private readonly TextEditor _editor;
        private readonly AppSettings _settings;
        private bool _disposed;

        public SettingsBindingSubscription(TextEditor editor, AppSettings settings)
        {
            _editor = editor;
            _settings = settings;

            // Subscribe to settings property changes
            if (_settings is System.ComponentModel.INotifyPropertyChanged notifySettings)
            {
                notifySettings.PropertyChanged += OnSettingsPropertyChanged;
            }
        }

        private void OnSettingsPropertyChanged(object? sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            if (_disposed) return;

            // Update specific setting based on property name
            switch (e.PropertyName)
            {
                case nameof(AppSettings.EditorFontFamily):
                case nameof(AppSettings.EditorFontSize):
                    ApplyFontSettings(_editor, _settings);
                    break;

                case nameof(AppSettings.ShowLineNumbers):
                case nameof(AppSettings.WordWrap):
                case nameof(AppSettings.HighlightCurrentLine):
                    ApplyDisplaySettings(_editor, _settings);
                    break;

                case nameof(AppSettings.TabSize):
                case nameof(AppSettings.ConvertTabsToSpaces):
                    ApplyEditingSettings(_editor, _settings);
                    break;

                case nameof(AppSettings.RulerColumn):
                    ApplyBehaviorSettings(_editor, _settings);
                    break;
            }
        }

        public void Dispose()
        {
            if (_disposed) return;
            _disposed = true;

            if (_settings is System.ComponentModel.INotifyPropertyChanged notifySettings)
            {
                notifySettings.PropertyChanged -= OnSettingsPropertyChanged;
            }
        }
    }
}
```

### AppSettings Updates

```csharp
// Add to SeniorIntern.Core/Models/AppSettings.cs

public sealed partial class AppSettings
{
    // ... existing properties ...

    // Editor Settings (v0.3.3)
    public string EditorFontFamily { get; set; } = "Cascadia Code, Consolas, monospace";
    public int EditorFontSize { get; set; } = 14;
    public int TabSize { get; set; } = 4;
    public bool ConvertTabsToSpaces { get; set; } = true;
    public bool ShowLineNumbers { get; set; } = true;
    public bool HighlightCurrentLine { get; set; } = true;
    public bool WordWrap { get; set; } = false;
    public int RulerColumn { get; set; } = 0; // 0 = disabled, 80/120 common values
}
```

### Files to Create (v0.3.3d)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/Services/EditorConfiguration.cs` | Editor configuration utility |

### Files to Modify (v0.3.3d)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Core/Models/AppSettings.cs` | Add editor settings properties |

### Acceptance Criteria (v0.3.3d)
- [ ] ApplySettings correctly configures all editor options
- [ ] Font family and size applied correctly
- [ ] Line numbers, word wrap, current line highlight work
- [ ] Tab size and convert-to-spaces work
- [ ] Settings binding updates editor on settings change
- [ ] Default settings applied to new editors

---

## v0.3.3e: Editor Panel UI

### Objective
Create the EditorPanel view with tab bar, editor area, and empty state display.

### EditorPanel.axaml Implementation

```xml
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             xmlns:ae="using:AvaloniaEdit"
             xmlns:vm="using:SeniorIntern.Desktop.ViewModels"
             xmlns:conv="using:SeniorIntern.Desktop.Converters"
             mc:Ignorable="d" d:DesignWidth="800" d:DesignHeight="600"
             x:Class="SeniorIntern.Desktop.Views.EditorPanel"
             x:DataType="vm:EditorPanelViewModel">

    <UserControl.Resources>
        <conv:LanguageToIconConverter x:Key="LanguageIconConverter" />
        <conv:BoolToVisibilityConverter x:Key="BoolToVisibility" />
    </UserControl.Resources>

    <Grid RowDefinitions="Auto, *">
        <!-- Tab Bar -->
        <Border Grid.Row="0"
                Background="{DynamicResource TabBarBackgroundBrush}"
                BorderBrush="{DynamicResource BorderBrush}"
                BorderThickness="0,0,0,1"
                IsVisible="{Binding HasOpenTabs}">
            <ScrollViewer HorizontalScrollBarVisibility="Auto"
                          VerticalScrollBarVisibility="Disabled"
                          Padding="4,0">
                <ItemsControl ItemsSource="{Binding Tabs}">
                    <ItemsControl.ItemsPanel>
                        <ItemsPanelTemplate>
                            <StackPanel Orientation="Horizontal" Spacing="2" />
                        </ItemsPanelTemplate>
                    </ItemsControl.ItemsPanel>
                    <ItemsControl.ItemTemplate>
                        <DataTemplate x:DataType="vm:EditorTabViewModel">
                            <Button Classes="editor-tab"
                                    Classes.active="{Binding IsActive}"
                                    Classes.dirty="{Binding IsDirty}"
                                    Command="{Binding $parent[UserControl].((vm:EditorPanelViewModel)DataContext).ActivateTabCommand}"
                                    CommandParameter="{Binding}"
                                    ToolTip.Tip="{Binding FilePath}">
                                <Grid ColumnDefinitions="Auto, Auto, Auto" Margin="8,4">
                                    <!-- Language Icon -->
                                    <PathIcon Grid.Column="0"
                                              Data="{Binding Language, Converter={StaticResource LanguageIconConverter}}"
                                              Width="14" Height="14"
                                              Margin="0,0,6,0"
                                              Foreground="{DynamicResource TextSecondaryBrush}" />

                                    <!-- File Name -->
                                    <TextBlock Grid.Column="1"
                                               Text="{Binding DisplayTitle}"
                                               VerticalAlignment="Center"
                                               Foreground="{DynamicResource TextPrimaryBrush}" />

                                    <!-- Close Button -->
                                    <Button Grid.Column="2"
                                            Classes="tab-close-button"
                                            Command="{Binding $parent[UserControl].((vm:EditorPanelViewModel)DataContext).CloseTabCommand}"
                                            CommandParameter="{Binding}"
                                            Margin="8,0,0,0"
                                            ToolTip.Tip="Close (Ctrl+W)">
                                        <PathIcon Data="{StaticResource CloseIcon}"
                                                  Width="10" Height="10" />
                                    </Button>
                                </Grid>
                            </Button>

                            <!-- Tab Context Menu -->
                            <Button.ContextMenu>
                                <ContextMenu>
                                    <MenuItem Header="Close"
                                              Command="{Binding $parent[UserControl].((vm:EditorPanelViewModel)DataContext).CloseTabCommand}"
                                              CommandParameter="{Binding}"
                                              InputGesture="Ctrl+W" />
                                    <MenuItem Header="Close Others"
                                              Command="{Binding $parent[UserControl].((vm:EditorPanelViewModel)DataContext).CloseOtherTabsCommand}"
                                              CommandParameter="{Binding}" />
                                    <MenuItem Header="Close Tabs to the Right"
                                              Command="{Binding $parent[UserControl].((vm:EditorPanelViewModel)DataContext).CloseTabsToRightCommand}"
                                              CommandParameter="{Binding}" />
                                    <MenuItem Header="Close All"
                                              Command="{Binding $parent[UserControl].((vm:EditorPanelViewModel)DataContext).CloseAllTabsCommand}" />
                                    <Separator />
                                    <MenuItem Header="Copy Path"
                                              Command="{Binding $parent[UserControl].((vm:EditorPanelViewModel)DataContext).CopyPathCommand}"
                                              CommandParameter="{Binding FilePath}" />
                                    <MenuItem Header="Reveal in Explorer"
                                              Command="{Binding $parent[UserControl].((vm:EditorPanelViewModel)DataContext).RevealInExplorerCommand}"
                                              IsEnabled="{Binding !IsNewFile}" />
                                </ContextMenu>
                            </Button.ContextMenu>
                        </DataTemplate>
                    </ItemsControl.ItemTemplate>
                </ItemsControl>
            </ScrollViewer>
        </Border>

        <!-- Editor Area -->
        <Grid Grid.Row="1">
            <!-- The actual TextEditor control -->
            <ae:TextEditor x:Name="Editor"
                           IsVisible="{Binding ActiveTab, Converter={x:Static ObjectConverters.IsNotNull}}"
                           HorizontalScrollBarVisibility="Auto"
                           VerticalScrollBarVisibility="Auto"
                           Background="{DynamicResource EditorBackgroundBrush}"
                           Foreground="{DynamicResource EditorForegroundBrush}" />

            <!-- Empty State -->
            <StackPanel IsVisible="{Binding !HasOpenTabs}"
                        HorizontalAlignment="Center"
                        VerticalAlignment="Center"
                        Spacing="16"
                        Opacity="0.6">
                <PathIcon Data="{StaticResource FileCodeIcon}"
                          Width="64" Height="64"
                          Foreground="{DynamicResource TextMutedBrush}" />
                <TextBlock Text="No file open"
                           FontSize="18"
                           FontWeight="SemiBold"
                           HorizontalAlignment="Center"
                           Foreground="{DynamicResource TextSecondaryBrush}" />
                <TextBlock Text="Open a file from the Explorer or use Ctrl+O"
                           HorizontalAlignment="Center"
                           Foreground="{DynamicResource TextMutedBrush}" />
                <StackPanel Orientation="Horizontal"
                            HorizontalAlignment="Center"
                            Spacing="8"
                            Margin="0,16,0,0">
                    <Button Content="Open File"
                            Command="{Binding OpenFileDialogCommand}"
                            Classes="primary" />
                    <Button Content="New File"
                            Command="{Binding NewFileCommand}" />
                </StackPanel>
            </StackPanel>
        </Grid>
    </Grid>
</UserControl>
```

### EditorPanel.axaml.cs Code-Behind

```csharp
namespace SeniorIntern.Desktop.Views;

using System;
using Avalonia.Controls;
using Avalonia.Input;
using Avalonia.Interactivity;
using AvaloniaEdit;
using SeniorIntern.Desktop.Services;
using SeniorIntern.Desktop.ViewModels;

public partial class EditorPanel : UserControl
{
    private EditorPanelViewModel? _viewModel;
    private SyntaxHighlightingService? _syntaxService;
    private IDisposable? _settingsBinding;

    public EditorPanel()
    {
        InitializeComponent();

        // Subscribe to DataContext changes
        DataContextChanged += OnDataContextChanged;
    }

    private void OnDataContextChanged(object? sender, EventArgs e)
    {
        // Unsubscribe from old ViewModel
        if (_viewModel != null)
        {
            _viewModel.PropertyChanged -= OnViewModelPropertyChanged;
            _viewModel.UndoRequested -= OnUndoRequested;
            _viewModel.RedoRequested -= OnRedoRequested;
            _viewModel.FindRequested -= OnFindRequested;
            _viewModel.ReplaceRequested -= OnReplaceRequested;
            _viewModel.GoToLineRequested -= OnGoToLineRequested;
        }

        _viewModel = DataContext as EditorPanelViewModel;

        if (_viewModel != null)
        {
            _viewModel.PropertyChanged += OnViewModelPropertyChanged;
            _viewModel.UndoRequested += OnUndoRequested;
            _viewModel.RedoRequested += OnRedoRequested;
            _viewModel.FindRequested += OnFindRequested;
            _viewModel.ReplaceRequested += OnReplaceRequested;
            _viewModel.GoToLineRequested += OnGoToLineRequested;

            // Update editor for current tab
            UpdateEditorForActiveTab();
        }
    }

    private void OnViewModelPropertyChanged(object? sender, System.ComponentModel.PropertyChangedEventArgs e)
    {
        if (e.PropertyName == nameof(EditorPanelViewModel.ActiveTab))
        {
            UpdateEditorForActiveTab();
        }
    }

    private void UpdateEditorForActiveTab()
    {
        var activeTab = _viewModel?.ActiveTab;

        if (activeTab == null)
        {
            Editor.Document = null;
            return;
        }

        // Set document
        Editor.Document = activeTab.Document;
        Editor.IsReadOnly = activeTab.IsReadOnly;

        // Apply syntax highlighting
        if (_syntaxService != null)
        {
            _syntaxService.SetLanguage(Editor, activeTab.Language);
        }

        // Subscribe to caret position changes
        Editor.TextArea.Caret.PositionChanged += OnCaretPositionChanged;
        Editor.TextArea.SelectionChanged += OnSelectionChanged;

        // Set initial caret position
        UpdateCaretPosition();
    }

    private void OnCaretPositionChanged(object? sender, EventArgs e)
    {
        UpdateCaretPosition();
    }

    private void OnSelectionChanged(object? sender, EventArgs e)
    {
        UpdateCaretPosition();
    }

    private void UpdateCaretPosition()
    {
        if (_viewModel?.ActiveTab == null) return;

        var caret = Editor.TextArea.Caret;
        var selection = Editor.TextArea.Selection;
        var selectionLength = selection.IsEmpty ? 0 : Math.Abs(selection.Length);

        _viewModel.ActiveTab.UpdateCaretPosition(caret.Line, caret.Column, selectionLength);
    }

    // Initialize services (called from App or MainWindow)
    public void Initialize(SyntaxHighlightingService syntaxService, AppSettings settings)
    {
        _syntaxService = syntaxService;

        // Apply initial settings
        EditorConfiguration.ApplySettings(Editor, settings);

        // Bind to settings changes
        _settingsBinding?.Dispose();
        _settingsBinding = EditorConfiguration.BindToSettings(Editor, settings);

        // Apply syntax highlighting
        _syntaxService.ApplyHighlighting(Editor, null);
    }

    // Editor command handlers
    private void OnUndoRequested(object? sender, EventArgs e) => Editor.Undo();
    private void OnRedoRequested(object? sender, EventArgs e) => Editor.Redo();

    private void OnFindRequested(object? sender, EventArgs e)
    {
        // AvaloniaEdit has built-in search panel
        var searchPanel = AvaloniaEdit.Search.SearchPanel.Install(Editor);
        searchPanel.Open();
    }

    private void OnReplaceRequested(object? sender, EventArgs e)
    {
        var searchPanel = AvaloniaEdit.Search.SearchPanel.Install(Editor);
        searchPanel.Open();
        // Note: AvaloniaEdit's SearchPanel includes replace functionality
    }

    private void OnGoToLineRequested(object? sender, int lineNumber)
    {
        if (_viewModel?.ActiveTab == null) return;

        var offset = _viewModel.ActiveTab.GetOffsetForLine(lineNumber);
        Editor.TextArea.Caret.Offset = offset;
        Editor.TextArea.Caret.BringCaretToView();
        Editor.Focus();
    }

    protected override void OnKeyDown(KeyEventArgs e)
    {
        base.OnKeyDown(e);

        // Handle keyboard shortcuts
        if (e.KeyModifiers == KeyModifiers.Control)
        {
            switch (e.Key)
            {
                case Key.S:
                    _viewModel?.SaveCommand.Execute(null);
                    e.Handled = true;
                    break;
                case Key.W:
                    if (_viewModel?.ActiveTab != null)
                    {
                        _viewModel.CloseTabCommand.Execute(_viewModel.ActiveTab);
                    }
                    e.Handled = true;
                    break;
                case Key.Tab:
                    if (e.KeyModifiers.HasFlag(KeyModifiers.Shift))
                        _viewModel?.PreviousTabCommand.Execute(null);
                    else
                        _viewModel?.NextTabCommand.Execute(null);
                    e.Handled = true;
                    break;
                case Key.G:
                    _viewModel?.GoToLineCommand.Execute(null);
                    e.Handled = true;
                    break;
                case Key.F:
                    _viewModel?.FindCommand.Execute(null);
                    e.Handled = true;
                    break;
                case Key.H:
                    _viewModel?.ReplaceCommand.Execute(null);
                    e.Handled = true;
                    break;
            }
        }
    }

    protected override void OnUnloaded(RoutedEventArgs e)
    {
        base.OnUnloaded(e);

        _settingsBinding?.Dispose();
        _syntaxService?.RemoveHighlighting(Editor);

        if (_viewModel != null)
        {
            _viewModel.PropertyChanged -= OnViewModelPropertyChanged;
            _viewModel.UndoRequested -= OnUndoRequested;
            _viewModel.RedoRequested -= OnRedoRequested;
            _viewModel.FindRequested -= OnFindRequested;
            _viewModel.ReplaceRequested -= OnReplaceRequested;
            _viewModel.GoToLineRequested -= OnGoToLineRequested;
        }
    }
}
```

### Tab Bar Styles (Add to Theme)

```xml
<!-- Add to Dark.axaml or Themes -->

<!-- Tab Bar -->
<SolidColorBrush x:Key="TabBarBackgroundBrush" Color="#252526" />
<SolidColorBrush x:Key="TabActiveBackgroundBrush" Color="#1E1E1E" />
<SolidColorBrush x:Key="TabHoverBackgroundBrush" Color="#2D2D2D" />

<!-- Editor Tab Button Style -->
<Style Selector="Button.editor-tab">
    <Setter Property="Background" Value="Transparent" />
    <Setter Property="BorderThickness" Value="0" />
    <Setter Property="Padding" Value="0" />
    <Setter Property="CornerRadius" Value="0" />
    <Setter Property="MinHeight" Value="35" />
</Style>

<Style Selector="Button.editor-tab:pointerover">
    <Setter Property="Background" Value="{DynamicResource TabHoverBackgroundBrush}" />
</Style>

<Style Selector="Button.editor-tab.active">
    <Setter Property="Background" Value="{DynamicResource TabActiveBackgroundBrush}" />
</Style>

<Style Selector="Button.editor-tab.active /template/ ContentPresenter">
    <Setter Property="BorderThickness" Value="0,0,0,2" />
    <Setter Property="BorderBrush" Value="{DynamicResource AccentBrush}" />
</Style>

<!-- Tab Close Button -->
<Style Selector="Button.tab-close-button">
    <Setter Property="Background" Value="Transparent" />
    <Setter Property="BorderThickness" Value="0" />
    <Setter Property="Padding" Value="4" />
    <Setter Property="CornerRadius" Value="4" />
    <Setter Property="Opacity" Value="0.5" />
</Style>

<Style Selector="Button.tab-close-button:pointerover">
    <Setter Property="Background" Value="{DynamicResource HoverBackgroundBrush}" />
    <Setter Property="Opacity" Value="1" />
</Style>

<!-- Editor Colors -->
<SolidColorBrush x:Key="EditorBackgroundBrush" Color="#1E1E1E" />
<SolidColorBrush x:Key="EditorForegroundBrush" Color="#D4D4D4" />
```

### Files to Create (v0.3.3e)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/Views/EditorPanel.axaml` | Editor panel UI |
| `src/SeniorIntern.Desktop/Views/EditorPanel.axaml.cs` | Editor panel code-behind |
| `src/SeniorIntern.Desktop/Converters/LanguageToIconConverter.cs` | Language icon converter |

### Files to Modify (v0.3.3e)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/Themes/Dark.axaml` | Add tab bar and editor styles |
| `src/SeniorIntern.Desktop/Assets/Icons.axaml` | Add CloseIcon, FileCodeIcon |

### Acceptance Criteria (v0.3.3e)
- [ ] Tab bar displays all open tabs
- [ ] Active tab is visually distinguished
- [ ] Dirty indicator (•) shows on modified tabs
- [ ] Tab close button works
- [ ] Tab context menu shows with options
- [ ] Empty state displays when no tabs open
- [ ] Editor displays active tab content
- [ ] Syntax highlighting applied to content

---

## v0.3.3f: Find & Replace

### Objective
Integrate AvaloniaEdit's built-in search panel with find and replace functionality.

### SearchPanel Integration

AvaloniaEdit includes a built-in `SearchPanel` that provides:
- Find text with highlight all matches
- Replace and Replace All
- Regular expression support
- Match case option
- Match whole word option
- Keyboard navigation (F3 for next, Shift+F3 for previous)

### SearchPanel Customization

```csharp
namespace SeniorIntern.Desktop.Services;

using AvaloniaEdit;
using AvaloniaEdit.Search;

/// <summary>
/// Manages the search panel for the editor.
/// </summary>
public static class EditorSearchManager
{
    private static readonly Dictionary<TextEditor, SearchPanel> _searchPanels = new();

    /// <summary>
    /// Opens the search panel for find operations.
    /// </summary>
    public static SearchPanel OpenFind(TextEditor editor)
    {
        var panel = GetOrCreatePanel(editor);
        panel.Open();

        // If there's a selection, use it as the search text
        if (!editor.TextArea.Selection.IsEmpty)
        {
            var selectedText = editor.TextArea.Selection.GetText();
            if (!string.IsNullOrEmpty(selectedText) && !selectedText.Contains('\n'))
            {
                panel.SearchPattern = selectedText;
            }
        }

        return panel;
    }

    /// <summary>
    /// Opens the search panel with replace visible.
    /// </summary>
    public static SearchPanel OpenReplace(TextEditor editor)
    {
        var panel = OpenFind(editor);
        panel.IsReplaceMode = true;
        return panel;
    }

    /// <summary>
    /// Finds the next occurrence.
    /// </summary>
    public static void FindNext(TextEditor editor)
    {
        var panel = GetOrCreatePanel(editor);
        panel.FindNext();
    }

    /// <summary>
    /// Finds the previous occurrence.
    /// </summary>
    public static void FindPrevious(TextEditor editor)
    {
        var panel = GetOrCreatePanel(editor);
        panel.FindPrevious();
    }

    /// <summary>
    /// Closes the search panel.
    /// </summary>
    public static void Close(TextEditor editor)
    {
        if (_searchPanels.TryGetValue(editor, out var panel))
        {
            panel.Close();
        }
    }

    private static SearchPanel GetOrCreatePanel(TextEditor editor)
    {
        if (!_searchPanels.TryGetValue(editor, out var panel))
        {
            panel = SearchPanel.Install(editor);
            _searchPanels[editor] = panel;
        }
        return panel;
    }

    /// <summary>
    /// Removes the search panel from an editor.
    /// </summary>
    public static void Uninstall(TextEditor editor)
    {
        if (_searchPanels.TryGetValue(editor, out var panel))
        {
            panel.Uninstall();
            _searchPanels.Remove(editor);
        }
    }
}
```

### Search Keyboard Shortcuts

| Shortcut | Action |
|----------|--------|
| Ctrl+F | Open Find |
| Ctrl+H | Open Find & Replace |
| F3 | Find Next |
| Shift+F3 | Find Previous |
| Escape | Close Search Panel |
| Enter | Find Next (when in search box) |
| Alt+R | Toggle Replace Mode |
| Alt+C | Toggle Match Case |
| Alt+W | Toggle Whole Word |
| Alt+E | Toggle Regex |

### Files to Create (v0.3.3f)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/Services/EditorSearchManager.cs` | Search panel manager |

### Files to Modify (v0.3.3f)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/Views/EditorPanel.axaml.cs` | Wire up search commands |

### Acceptance Criteria (v0.3.3f)
- [ ] Ctrl+F opens search panel
- [ ] Ctrl+H opens search panel in replace mode
- [ ] Selected text auto-fills search box
- [ ] Find next/previous works (F3/Shift+F3)
- [ ] Replace and Replace All work
- [ ] Escape closes search panel
- [ ] Match case, whole word, regex options work

---

## v0.3.3g: Dialogs & Integration

### Objective
Create dialog services, go-to-line dialog, and integrate the editor panel into the main window.

### IDialogService Interface

```csharp
namespace SeniorIntern.Desktop.Services;

using System.Collections.Generic;
using System.Threading.Tasks;

/// <summary>
/// Service for displaying dialogs.
/// </summary>
public interface IDialogService
{
    /// <summary>
    /// Shows an error message dialog.
    /// </summary>
    Task ShowErrorAsync(string title, string message);

    /// <summary>
    /// Shows an information message dialog.
    /// </summary>
    Task ShowInfoAsync(string title, string message);

    /// <summary>
    /// Shows a confirmation dialog with multiple options.
    /// </summary>
    /// <returns>The selected option text, or null if cancelled.</returns>
    Task<string?> ShowConfirmDialogAsync(string title, string message, IEnumerable<string> options);

    /// <summary>
    /// Shows a save file dialog.
    /// </summary>
    /// <returns>The selected file path, or null if cancelled.</returns>
    Task<string?> ShowSaveDialogAsync(
        string title,
        string defaultFileName,
        IReadOnlyList<(string Name, string[] Extensions)> filters);

    /// <summary>
    /// Shows an open file dialog.
    /// </summary>
    /// <returns>The selected file path, or null if cancelled.</returns>
    Task<string?> ShowOpenFileDialogAsync(
        string title,
        IReadOnlyList<(string Name, string[] Extensions)> filters,
        bool allowMultiple = false);

    /// <summary>
    /// Shows a folder picker dialog.
    /// </summary>
    /// <returns>The selected folder path, or null if cancelled.</returns>
    Task<string?> ShowFolderPickerAsync(string title);

    /// <summary>
    /// Shows the go-to-line dialog.
    /// </summary>
    /// <returns>The line number, or null if cancelled.</returns>
    Task<int?> ShowGoToLineDialogAsync(int maxLine, int currentLine);
}
```

### DialogService Implementation

```csharp
namespace SeniorIntern.Desktop.Services;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Avalonia;
using Avalonia.Controls;
using Avalonia.Controls.ApplicationLifetimes;
using Avalonia.Platform.Storage;
using SeniorIntern.Desktop.Views.Dialogs;

public sealed class DialogService : IDialogService
{
    private Window? GetMainWindow()
    {
        return Application.Current?.ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop
            ? desktop.MainWindow
            : null;
    }

    public async Task ShowErrorAsync(string title, string message)
    {
        var window = GetMainWindow();
        if (window == null) return;

        var dialog = new MessageDialog
        {
            Title = title,
            Message = message,
            Icon = MessageDialogIcon.Error,
            Buttons = new[] { "OK" }
        };

        await dialog.ShowDialog(window);
    }

    public async Task ShowInfoAsync(string title, string message)
    {
        var window = GetMainWindow();
        if (window == null) return;

        var dialog = new MessageDialog
        {
            Title = title,
            Message = message,
            Icon = MessageDialogIcon.Information,
            Buttons = new[] { "OK" }
        };

        await dialog.ShowDialog(window);
    }

    public async Task<string?> ShowConfirmDialogAsync(string title, string message, IEnumerable<string> options)
    {
        var window = GetMainWindow();
        if (window == null) return null;

        var dialog = new MessageDialog
        {
            Title = title,
            Message = message,
            Icon = MessageDialogIcon.Question,
            Buttons = options.ToArray()
        };

        return await dialog.ShowDialog<string?>(window);
    }

    public async Task<string?> ShowSaveDialogAsync(
        string title,
        string defaultFileName,
        IReadOnlyList<(string Name, string[] Extensions)> filters)
    {
        var window = GetMainWindow();
        if (window == null) return null;

        var storageProvider = window.StorageProvider;
        var fileTypes = filters.Select(f => new FilePickerFileType(f.Name)
        {
            Patterns = f.Extensions
        }).ToList();

        var result = await storageProvider.SaveFilePickerAsync(new FilePickerSaveOptions
        {
            Title = title,
            SuggestedFileName = defaultFileName,
            FileTypeChoices = fileTypes
        });

        return result?.Path.LocalPath;
    }

    public async Task<string?> ShowOpenFileDialogAsync(
        string title,
        IReadOnlyList<(string Name, string[] Extensions)> filters,
        bool allowMultiple = false)
    {
        var window = GetMainWindow();
        if (window == null) return null;

        var storageProvider = window.StorageProvider;
        var fileTypes = filters.Select(f => new FilePickerFileType(f.Name)
        {
            Patterns = f.Extensions
        }).ToList();

        var results = await storageProvider.OpenFilePickerAsync(new FilePickerOpenOptions
        {
            Title = title,
            AllowMultiple = allowMultiple,
            FileTypeFilter = fileTypes
        });

        return results.FirstOrDefault()?.Path.LocalPath;
    }

    public async Task<string?> ShowFolderPickerAsync(string title)
    {
        var window = GetMainWindow();
        if (window == null) return null;

        var storageProvider = window.StorageProvider;
        var results = await storageProvider.OpenFolderPickerAsync(new FolderPickerOpenOptions
        {
            Title = title,
            AllowMultiple = false
        });

        return results.FirstOrDefault()?.Path.LocalPath;
    }

    public async Task<int?> ShowGoToLineDialogAsync(int maxLine, int currentLine)
    {
        var window = GetMainWindow();
        if (window == null) return null;

        var dialog = new GoToLineDialog
        {
            MaxLine = maxLine,
            CurrentLine = currentLine
        };

        return await dialog.ShowDialog<int?>(window);
    }
}
```

### GoToLineDialog Implementation

```xml
<!-- GoToLineDialog.axaml -->
<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        x:Class="SeniorIntern.Desktop.Views.Dialogs.GoToLineDialog"
        Title="Go to Line"
        Width="300"
        Height="140"
        WindowStartupLocation="CenterOwner"
        CanResize="False"
        ShowInTaskbar="False"
        ExtendClientAreaToDecorationsHint="False">

    <Grid Margin="16" RowDefinitions="Auto, Auto, Auto">
        <!-- Label -->
        <TextBlock Grid.Row="0"
                   x:Name="PromptText"
                   Text="Go to line (1 - 100):"
                   Margin="0,0,0,8" />

        <!-- Input -->
        <TextBox Grid.Row="1"
                 x:Name="LineNumberInput"
                 Watermark="Line number"
                 Margin="0,0,0,16" />

        <!-- Buttons -->
        <StackPanel Grid.Row="2"
                    Orientation="Horizontal"
                    HorizontalAlignment="Right"
                    Spacing="8">
            <Button Content="Cancel"
                    Click="OnCancelClick"
                    IsCancel="True" />
            <Button Content="Go"
                    Classes="primary"
                    Click="OnGoClick"
                    IsDefault="True" />
        </StackPanel>
    </Grid>
</Window>
```

```csharp
// GoToLineDialog.axaml.cs
namespace SeniorIntern.Desktop.Views.Dialogs;

using Avalonia.Controls;
using Avalonia.Input;
using Avalonia.Interactivity;

public partial class GoToLineDialog : Window
{
    private int _maxLine = 1;
    private int _currentLine = 1;

    public GoToLineDialog()
    {
        InitializeComponent();

        LineNumberInput.KeyDown += OnInputKeyDown;
    }

    public int MaxLine
    {
        get => _maxLine;
        set
        {
            _maxLine = value;
            PromptText.Text = $"Go to line (1 - {_maxLine}):";
        }
    }

    public int CurrentLine
    {
        get => _currentLine;
        set
        {
            _currentLine = value;
            LineNumberInput.Text = value.ToString();
            LineNumberInput.SelectAll();
        }
    }

    protected override void OnOpened(EventArgs e)
    {
        base.OnOpened(e);
        LineNumberInput.Focus();
        LineNumberInput.SelectAll();
    }

    private void OnInputKeyDown(object? sender, KeyEventArgs e)
    {
        if (e.Key == Key.Enter)
        {
            TryGoToLine();
            e.Handled = true;
        }
    }

    private void OnGoClick(object? sender, RoutedEventArgs e)
    {
        TryGoToLine();
    }

    private void OnCancelClick(object? sender, RoutedEventArgs e)
    {
        Close(null);
    }

    private void TryGoToLine()
    {
        if (int.TryParse(LineNumberInput.Text, out var line))
        {
            if (line >= 1 && line <= _maxLine)
            {
                Close(line);
                return;
            }
        }

        // Invalid input - shake or show error
        LineNumberInput.Focus();
        LineNumberInput.SelectAll();
    }
}
```

### MessageDialog Implementation

```xml
<!-- MessageDialog.axaml -->
<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        x:Class="SeniorIntern.Desktop.Views.Dialogs.MessageDialog"
        Width="400"
        SizeToContent="Height"
        WindowStartupLocation="CenterOwner"
        CanResize="False"
        ShowInTaskbar="False"
        ExtendClientAreaToDecorationsHint="False">

    <Grid Margin="16" RowDefinitions="Auto, Auto, Auto">
        <!-- Icon and Message -->
        <Grid Grid.Row="0" ColumnDefinitions="Auto, *" Margin="0,0,0,16">
            <PathIcon Grid.Column="0"
                      x:Name="DialogIcon"
                      Width="32" Height="32"
                      Margin="0,0,16,0"
                      VerticalAlignment="Top" />
            <TextBlock Grid.Column="1"
                       x:Name="MessageText"
                       TextWrapping="Wrap"
                       VerticalAlignment="Center" />
        </Grid>

        <!-- Buttons -->
        <ItemsControl Grid.Row="2"
                      x:Name="ButtonsPanel"
                      HorizontalAlignment="Right">
            <ItemsControl.ItemsPanel>
                <ItemsPanelTemplate>
                    <StackPanel Orientation="Horizontal" Spacing="8" />
                </ItemsPanelTemplate>
            </ItemsControl.ItemsPanel>
        </ItemsControl>
    </Grid>
</Window>
```

```csharp
// MessageDialog.axaml.cs
namespace SeniorIntern.Desktop.Views.Dialogs;

using System.Collections.Generic;
using System.Linq;
using Avalonia.Controls;

public enum MessageDialogIcon
{
    None,
    Information,
    Warning,
    Error,
    Question
}

public partial class MessageDialog : Window
{
    public MessageDialog()
    {
        InitializeComponent();
    }

    public string Message
    {
        get => MessageText.Text ?? string.Empty;
        set => MessageText.Text = value;
    }

    public MessageDialogIcon Icon
    {
        get;
        set
        {
            field = value;
            UpdateIcon();
        }
    }

    public IEnumerable<string> Buttons
    {
        set => CreateButtons(value);
    }

    private void UpdateIcon()
    {
        var iconData = Icon switch
        {
            MessageDialogIcon.Information => Application.Current?.FindResource("InfoIcon"),
            MessageDialogIcon.Warning => Application.Current?.FindResource("WarningIcon"),
            MessageDialogIcon.Error => Application.Current?.FindResource("ErrorIcon"),
            MessageDialogIcon.Question => Application.Current?.FindResource("QuestionIcon"),
            _ => null
        };

        if (iconData is Avalonia.Media.Geometry geometry)
        {
            DialogIcon.Data = geometry;
            DialogIcon.IsVisible = true;
        }
        else
        {
            DialogIcon.IsVisible = false;
        }
    }

    private void CreateButtons(IEnumerable<string> buttonLabels)
    {
        var buttons = buttonLabels.Select((label, index) =>
        {
            var button = new Button
            {
                Content = label,
                MinWidth = 80
            };

            if (index == 0) // First button is primary
            {
                button.Classes.Add("primary");
            }

            button.Click += (s, e) => Close(label);
            return button;
        });

        ButtonsPanel.ItemsSource = buttons.Reverse(); // Right-align with primary on right
    }
}
```

### MainWindow Integration

```xml
<!-- Update MainWindow.axaml -->
<!-- Add EditorPanel to the main content area -->

<Grid ColumnDefinitions="Auto, *, Auto">
    <!-- Sidebar (File Explorer) -->
    <views:Sidebar Grid.Column="0"
                   Width="{Binding SidebarWidth}"
                   IsVisible="{Binding IsSidebarVisible}" />

    <!-- Splitter -->
    <GridSplitter Grid.Column="0"
                  Width="4"
                  Background="Transparent" />

    <!-- Main Content -->
    <Grid Grid.Column="1" RowDefinitions="*, Auto, Auto">
        <!-- Editor Panel -->
        <views:EditorPanel Grid.Row="0"
                           x:Name="EditorPanel"
                           DataContext="{Binding EditorPanel}" />

        <!-- Horizontal Splitter -->
        <GridSplitter Grid.Row="1"
                      Height="4"
                      HorizontalAlignment="Stretch"
                      Background="Transparent"
                      IsVisible="{Binding IsChatPanelVisible}" />

        <!-- Chat Panel (collapsible) -->
        <views:ChatPanel Grid.Row="2"
                         Height="{Binding ChatPanelHeight}"
                         DataContext="{Binding Chat}"
                         IsVisible="{Binding IsChatPanelVisible}" />
    </Grid>

    <!-- Status Bar (spans full width) -->
    <!-- ... -->
</Grid>
```

### MainWindowViewModel Updates

```csharp
// Add to MainWindowViewModel

[ObservableProperty]
private EditorPanelViewModel _editorPanel;

[ObservableProperty]
private bool _isChatPanelVisible = true;

[ObservableProperty]
private double _chatPanelHeight = 300;

// Constructor
public MainWindowViewModel(
    // ... existing dependencies ...
    EditorPanelViewModel editorPanel)
{
    // ... existing initialization ...
    EditorPanel = editorPanel;

    // Wire up file explorer to editor
    FileExplorer.FileOpenRequested += OnFileOpenRequested;
    EditorPanel.RevealInExplorerRequested += OnRevealInExplorerRequested;
}

private async void OnFileOpenRequested(object? sender, string filePath)
{
    await EditorPanel.OpenFileAsync(filePath);
}

private void OnRevealInExplorerRequested(object? sender, string filePath)
{
    FileExplorer.RevealFile(filePath);
}

[RelayCommand]
private void ToggleChatPanel()
{
    IsChatPanelVisible = !IsChatPanelVisible;
}
```

### Files to Create (v0.3.3g)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/Services/IDialogService.cs` | Dialog service interface |
| `src/SeniorIntern.Desktop/Services/DialogService.cs` | Dialog service implementation |
| `src/SeniorIntern.Desktop/Views/Dialogs/GoToLineDialog.axaml` | Go-to-line dialog |
| `src/SeniorIntern.Desktop/Views/Dialogs/GoToLineDialog.axaml.cs` | Go-to-line code-behind |
| `src/SeniorIntern.Desktop/Views/Dialogs/MessageDialog.axaml` | Message dialog |
| `src/SeniorIntern.Desktop/Views/Dialogs/MessageDialog.axaml.cs` | Message dialog code-behind |

### Files to Modify (v0.3.3g)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/Views/MainWindow.axaml` | Add EditorPanel to layout |
| `src/SeniorIntern.Desktop/ViewModels/MainWindowViewModel.cs` | Add EditorPanelViewModel |
| `src/SeniorIntern.Desktop/App.axaml.cs` | Register DialogService, wire up services |
| `Directory.Packages.props` | Add AvaloniaEdit, TextMateSharp packages |

### Acceptance Criteria (v0.3.3g)
- [ ] Go-to-line dialog opens with Ctrl+G
- [ ] Go-to-line validates input and navigates
- [ ] Unsaved changes dialog shows Save/Don't Save/Cancel
- [ ] Save dialog filters by language
- [ ] Editor panel integrated into main window
- [ ] File explorer opens files in editor
- [ ] Status bar shows cursor position and file info

---

## Complete File Summary

### Files to Create

| File | Part |
|------|------|
| `src/SeniorIntern.Desktop/ViewModels/EditorTabViewModel.cs` | v0.3.3a |
| `src/SeniorIntern.Desktop/ViewModels/EditorPanelViewModel.cs` | v0.3.3b |
| `src/SeniorIntern.Desktop/Services/SyntaxHighlightingService.cs` | v0.3.3c |
| `src/SeniorIntern.Desktop/Services/EditorConfiguration.cs` | v0.3.3d |
| `src/SeniorIntern.Desktop/Views/EditorPanel.axaml` | v0.3.3e |
| `src/SeniorIntern.Desktop/Views/EditorPanel.axaml.cs` | v0.3.3e |
| `src/SeniorIntern.Desktop/Converters/LanguageToIconConverter.cs` | v0.3.3e |
| `src/SeniorIntern.Desktop/Services/EditorSearchManager.cs` | v0.3.3f |
| `src/SeniorIntern.Desktop/Services/IDialogService.cs` | v0.3.3g |
| `src/SeniorIntern.Desktop/Services/DialogService.cs` | v0.3.3g |
| `src/SeniorIntern.Desktop/Views/Dialogs/GoToLineDialog.axaml` | v0.3.3g |
| `src/SeniorIntern.Desktop/Views/Dialogs/GoToLineDialog.axaml.cs` | v0.3.3g |
| `src/SeniorIntern.Desktop/Views/Dialogs/MessageDialog.axaml` | v0.3.3g |
| `src/SeniorIntern.Desktop/Views/Dialogs/MessageDialog.axaml.cs` | v0.3.3g |

**Total: 14 files to create**

### Files to Modify

| File | Part | Changes |
|------|------|---------|
| `src/SeniorIntern.Core/Models/AppSettings.cs` | v0.3.3d | Add editor settings |
| `src/SeniorIntern.Desktop/Themes/Dark.axaml` | v0.3.3e | Add editor/tab styles |
| `src/SeniorIntern.Desktop/Assets/Icons.axaml` | v0.3.3e | Add editor icons |
| `src/SeniorIntern.Desktop/Views/MainWindow.axaml` | v0.3.3g | Add EditorPanel |
| `src/SeniorIntern.Desktop/ViewModels/MainWindowViewModel.cs` | v0.3.3g | Add EditorPanelVM |
| `src/SeniorIntern.Desktop/App.axaml.cs` | v0.3.3g | Register services |
| `Directory.Packages.props` | v0.3.3g | Add NuGet packages |

**Total: 7 files to modify**

---

## Testing Strategy

### Unit Tests

```csharp
// EditorTabViewModelTests.cs
public class EditorTabViewModelTests
{
    [Fact]
    public void FromFile_CreatesTabWithCorrectProperties()
    {
        var tab = EditorTabViewModel.FromFile("/path/to/file.cs", "public class Foo {}");

        Assert.Equal("/path/to/file.cs", tab.FilePath);
        Assert.Equal("file.cs", tab.FileName);
        Assert.Equal("csharp", tab.Language);
        Assert.False(tab.IsDirty);
        Assert.False(tab.IsNewFile);
    }

    [Fact]
    public void CreateNew_CreatesUntitledTab()
    {
        var tab = EditorTabViewModel.CreateNew("Untitled-1");

        Assert.Empty(tab.FilePath);
        Assert.Equal("Untitled-1", tab.FileName);
        Assert.True(tab.IsNewFile);
    }

    [Fact]
    public void DocumentChange_SetsDirtyFlag()
    {
        var tab = EditorTabViewModel.FromFile("/path/test.cs", "original");

        tab.Document.Text = "modified";

        Assert.True(tab.IsDirty);
    }

    [Fact]
    public void MarkAsSaved_ClearsDirtyFlag()
    {
        var tab = EditorTabViewModel.FromFile("/path/test.cs", "original");
        tab.Document.Text = "modified";

        tab.MarkAsSaved();

        Assert.False(tab.IsDirty);
    }

    [Fact]
    public void DisplayTitle_IncludesDirtyIndicator()
    {
        var tab = EditorTabViewModel.FromFile("/path/test.cs", "content");
        tab.Document.Text = "modified";

        Assert.Equal("test.cs •", tab.DisplayTitle);
    }
}

// EditorPanelViewModelTests.cs
public class EditorPanelViewModelTests
{
    private readonly Mock<IFileSystemService> _fileSystemMock;
    private readonly Mock<IDialogService> _dialogMock;
    private readonly EditorPanelViewModel _viewModel;

    public EditorPanelViewModelTests()
    {
        _fileSystemMock = new Mock<IFileSystemService>();
        _dialogMock = new Mock<IDialogService>();
        var syntaxService = new SyntaxHighlightingService();

        _viewModel = new EditorPanelViewModel(
            _fileSystemMock.Object,
            syntaxService,
            _dialogMock.Object);
    }

    [Fact]
    public async Task OpenFileAsync_CreatesNewTab()
    {
        _fileSystemMock.Setup(f => f.ReadFileAsync(It.IsAny<string>(), default))
            .ReturnsAsync("file content");

        await _viewModel.OpenFileAsync("/path/test.cs");

        Assert.Single(_viewModel.Tabs);
        Assert.Equal("/path/test.cs", _viewModel.ActiveTab?.FilePath);
    }

    [Fact]
    public async Task OpenFileAsync_ActivatesExistingTab()
    {
        _fileSystemMock.Setup(f => f.ReadFileAsync(It.IsAny<string>(), default))
            .ReturnsAsync("content");

        await _viewModel.OpenFileAsync("/path/test.cs");
        await _viewModel.OpenFileAsync("/path/other.cs");
        await _viewModel.OpenFileAsync("/path/test.cs"); // Open again

        Assert.Equal(2, _viewModel.Tabs.Count); // Still only 2 tabs
        Assert.Equal("/path/test.cs", _viewModel.ActiveTab?.FilePath);
    }

    [Fact]
    public void NewFile_CreatesUntitledTab()
    {
        _viewModel.NewFile();

        Assert.Single(_viewModel.Tabs);
        Assert.StartsWith("Untitled", _viewModel.ActiveTab?.FileName);
    }

    [Fact]
    public async Task CloseTabAsync_RemovesTab()
    {
        _fileSystemMock.Setup(f => f.ReadFileAsync(It.IsAny<string>(), default))
            .ReturnsAsync("content");

        await _viewModel.OpenFileAsync("/path/test.cs");
        var tab = _viewModel.ActiveTab!;

        await _viewModel.CloseTabAsync(tab);

        Assert.Empty(_viewModel.Tabs);
        Assert.Null(_viewModel.ActiveTab);
    }

    [Fact]
    public async Task CloseTabAsync_PromptsSaveForDirtyTab()
    {
        _fileSystemMock.Setup(f => f.ReadFileAsync(It.IsAny<string>(), default))
            .ReturnsAsync("content");
        _dialogMock.Setup(d => d.ShowConfirmDialogAsync(
            It.IsAny<string>(),
            It.IsAny<string>(),
            It.IsAny<IEnumerable<string>>()))
            .ReturnsAsync("Don't Save");

        await _viewModel.OpenFileAsync("/path/test.cs");
        _viewModel.ActiveTab!.Document.Text = "modified";

        await _viewModel.CloseTabAsync(_viewModel.ActiveTab);

        _dialogMock.Verify(d => d.ShowConfirmDialogAsync(
            It.IsAny<string>(),
            It.Is<string>(m => m.Contains("test.cs")),
            It.IsAny<IEnumerable<string>>()), Times.Once);
    }

    [Fact]
    public void NextTab_CyclesThroughTabs()
    {
        _viewModel.NewFile();
        _viewModel.NewFile();
        _viewModel.NewFile();
        _viewModel.ActivateTab(_viewModel.Tabs[0]);

        _viewModel.NextTab();
        Assert.Equal(_viewModel.Tabs[1], _viewModel.ActiveTab);

        _viewModel.NextTab();
        Assert.Equal(_viewModel.Tabs[2], _viewModel.ActiveTab);

        _viewModel.NextTab(); // Wraps around
        Assert.Equal(_viewModel.Tabs[0], _viewModel.ActiveTab);
    }
}

// SyntaxHighlightingServiceTests.cs
public class SyntaxHighlightingServiceTests
{
    [Fact]
    public void GetScopeForLanguage_ReturnsCsharpScope()
    {
        var service = new SyntaxHighlightingService();

        var scope = service.GetScopeForLanguage("csharp");

        Assert.Equal("source.cs", scope);
    }

    [Fact]
    public void GetScopeForLanguage_ReturnsNullForUnknown()
    {
        var service = new SyntaxHighlightingService();

        var scope = service.GetScopeForLanguage("unknown-language");

        Assert.Null(scope);
    }

    [Fact]
    public void SupportedLanguages_ContainsCommonLanguages()
    {
        var service = new SyntaxHighlightingService();

        Assert.Contains("csharp", service.SupportedLanguages);
        Assert.Contains("javascript", service.SupportedLanguages);
        Assert.Contains("python", service.SupportedLanguages);
        Assert.Contains("json", service.SupportedLanguages);
    }
}
```

### Integration Tests

```csharp
// EditorIntegrationTests.cs
public class EditorIntegrationTests
{
    [Fact]
    public async Task OpenFile_DisplaysSyntaxHighlighting()
    {
        // Integration test with actual AvaloniaEdit control
        // Test that C# file gets proper syntax highlighting applied
    }

    [Fact]
    public async Task SaveFile_PersistsContent()
    {
        // Test that saving actually writes to file system
    }

    [Fact]
    public async Task FileChange_UpdatesDirtyIndicator()
    {
        // Test that editing updates the dirty indicator in the tab
    }
}
```

### Manual Testing Checklist

- [ ] Open C#, JavaScript, Python, JSON files - verify syntax highlighting
- [ ] Open same file twice - verify it activates existing tab
- [ ] Edit file - verify dirty indicator appears
- [ ] Save file - verify dirty indicator clears
- [ ] Close dirty file - verify save prompt appears
- [ ] Click "Save" in prompt - verify file saves
- [ ] Click "Don't Save" - verify file closes without saving
- [ ] Click "Cancel" - verify file stays open
- [ ] Ctrl+F opens find panel
- [ ] Find next/previous works
- [ ] Ctrl+H opens find with replace
- [ ] Replace and Replace All work
- [ ] Ctrl+G opens go-to-line dialog
- [ ] Enter valid line number - jumps to line
- [ ] Enter invalid line number - stays in dialog
- [ ] Tab navigation (Ctrl+Tab, Ctrl+Shift+Tab) works
- [ ] Tab context menu (Close, Close Others, etc.) works
- [ ] Double-click file in explorer opens in editor
- [ ] Status bar shows cursor position

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| AvaloniaEdit API changes | Low | High | Pin to specific version, test thoroughly |
| TextMate grammar loading failures | Medium | Low | Fallback to plain text, log errors |
| Large file performance | Medium | Medium | Lazy loading, virtual scrolling built into AvaloniaEdit |
| Memory leaks from tabs | Low | Medium | Proper disposal, weak references for events |
| Cross-platform font rendering | Medium | Low | Use common fonts, test on all platforms |
| Tab dragging complexity | Medium | Low | Defer to v0.3.5 if needed |

---

## Performance Considerations

1. **Document Loading**: Use async file reading for large files
2. **Syntax Highlighting**: TextMate grammars are efficient, but consider disabling for files > 1MB
3. **Tab Count**: Warn or limit when > 20 tabs open (memory usage)
4. **Undo History**: AvaloniaEdit manages this automatically, but consider limits for large edits
5. **Search**: Use AvaloniaEdit's built-in search which is optimized

---

## Keyboard Shortcuts Summary

| Shortcut | Action | Part |
|----------|--------|------|
| Ctrl+N | New file | v0.3.3b |
| Ctrl+O | Open file dialog | v0.3.3g |
| Ctrl+S | Save | v0.3.3b |
| Ctrl+Shift+S | Save As | v0.3.3b |
| Ctrl+Alt+S | Save All | v0.3.3b |
| Ctrl+W | Close tab | v0.3.3b |
| Ctrl+Shift+W | Close all tabs | v0.3.3b |
| Ctrl+Tab | Next tab | v0.3.3b |
| Ctrl+Shift+Tab | Previous tab | v0.3.3b |
| Ctrl+Z | Undo | v0.3.3b |
| Ctrl+Y | Redo | v0.3.3b |
| Ctrl+F | Find | v0.3.3f |
| Ctrl+H | Find & Replace | v0.3.3f |
| F3 | Find Next | v0.3.3f |
| Shift+F3 | Find Previous | v0.3.3f |
| Ctrl+G | Go to Line | v0.3.3g |
| Escape | Close search panel | v0.3.3f |

---

## References

- [AvaloniaEdit Documentation](https://github.com/AvaloniaUI/AvaloniaEdit)
- [AvaloniaEdit Wiki](https://github.com/AvaloniaUI/AvaloniaEdit/wiki)
- [TextMateSharp](https://github.com/danipen/TextMateSharp)
- [VSCode Language Identifiers](https://code.visualstudio.com/docs/languages/identifiers)
- [TextMate Language Grammars](https://macromates.com/manual/en/language_grammars)
- [AvaloniaEdit.TextMate](https://www.nuget.org/packages/AvaloniaEdit.TextMate/)
