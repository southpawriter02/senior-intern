# Design Specification: The Senior Intern v0.3.4 "Context Attachment"

## Executive Summary

This document provides a comprehensive design specification for v0.3.4, which enables attaching files or code selections to chat messages with visual previews and token estimation. This feature transforms The Senior Intern from a generic chat assistant into a context-aware coding assistant that can analyze, explain, and modify specific code within the user's workspace.

### v0.3.4 Scope (from v0.3.0 Design Document)
- Attach files to chat from File Explorer context menu
- Attach code selections from Editor
- Visual context pills/badges in chat input area
- Context preview popup on hover/click
- Token estimation for attached content
- Context formatting in LLM prompts
- Context persistence with message history
- Drag-and-drop file attachment

### Dependencies
- **v0.3.1** must be complete (FileContext model, FileSystemService)
- **v0.3.2** must be complete (File Explorer with context menus)
- **v0.3.3** must be complete (Editor with selection support)

---

## Sub-Part Breakdown

| Part | Name | Focus |
|------|------|-------|
| v0.3.4a | Token Estimation Service | Token counting algorithms, model-specific adjustments |
| v0.3.4b | Context Formatter | Prompt formatting, markdown code blocks, metadata |
| v0.3.4c | File Context ViewModel | FileContextViewModel, attachment state management |
| v0.3.4d | Chat Context Bar UI | Context pills, token display, add/remove buttons |
| v0.3.4e | Context Preview | Preview popup, syntax highlighting, expand/collapse |
| v0.3.4f | Editor Integration | Selection attachment, keyboard shortcuts, toolbar button |
| v0.3.4g | File Explorer Integration | Context menu "Attach to Chat", drag-drop to chat |
| v0.3.4h | Message History Integration | Store/restore context with messages, display in history |

---

## Architecture Overview

### Component Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              MainWindow                                       │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │                         MainWindowViewModel                             │  │
│  │                                │                                        │  │
│  │    ┌───────────────────────────┼───────────────────────────┐           │  │
│  │    ▼                           ▼                           ▼           │  │
│  │  ┌─────────────────┐   ┌─────────────────┐   ┌─────────────────┐      │  │
│  │  │FileExplorerVM   │   │ EditorPanelVM   │   │  ChatViewModel  │      │  │
│  │  │ (v0.3.2)        │   │ (v0.3.3)        │   │  (v0.2.0+)      │      │  │
│  │  └────────┬────────┘   └────────┬────────┘   └────────┬────────┘      │  │
│  │           │                     │                     │               │  │
│  │           │   AttachFile        │  AttachSelection    │               │  │
│  │           └─────────────────────┼─────────────────────┘               │  │
│  │                                 ▼                                      │  │
│  │                    ┌─────────────────────────┐                        │  │
│  │                    │   IContextService       │                        │  │
│  │                    │  • AttachFile           │                        │  │
│  │                    │  • AttachSelection      │                        │  │
│  │                    │  • RemoveContext        │                        │  │
│  │                    │  • GetFormattedPrompt   │                        │  │
│  │                    └─────────────────────────┘                        │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────┘
                │
                ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                            ChatViewModel                                      │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │ Properties:                                                             │  │
│  │ • AttachedContexts: ObservableCollection<FileContextViewModel>         │  │
│  │ • TotalContextTokens: int                                              │  │
│  │ • CanAttachMore: bool                                                  │  │
│  │ • SelectedPreviewContext: FileContextViewModel?                        │  │
│  │ • IsPreviewOpen: bool                                                  │  │
│  ├───────────────────────────────────────────────────────────────────────┤  │
│  │ Commands:                                                               │  │
│  │ • AttachFileCommand, AttachSelectionCommand                            │  │
│  │ • RemoveContextCommand, ClearAllContextsCommand                        │  │
│  │ • ShowPreviewCommand, HidePreviewCommand                               │  │
│  │ • OpenContextFileCommand                                               │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                │                                                             │
│                ▼                                                             │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │                    FileContextViewModel                                 │  │
│  │ • Id, FilePath, FileName, Language                                      │  │
│  │ • Content, PreviewContent (truncated)                                   │  │
│  │ • EstimatedTokens, LineCount                                           │  │
│  │ • StartLine?, EndLine? (for selections)                                │  │
│  │ • IsExpanded, DisplayLabel, TypeIcon                                   │  │
│  │ • AttachmentType (File, Selection, Clipboard)                          │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────┘
                │
                ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                            Service Layer                                      │
│  ┌─────────────────────────┐        ┌─────────────────────────────────┐     │
│  │  ITokenEstimationService │        │      IContextFormatter          │     │
│  │ • EstimateTokens()      │        │ • FormatForPrompt()             │     │
│  │ • EstimateForModel()    │        │ • FormatForDisplay()            │     │
│  │ • GetTokenLimit()       │        │ • FormatCodeBlock()             │     │
│  └─────────────────────────┘        └─────────────────────────────────┘     │
│                                                                              │
│  ┌─────────────────────────┐        ┌─────────────────────────────────┐     │
│  │   IContextService       │        │   IFileSystemService            │     │
│  │ • AttachFile()          │        │ • ReadFileAsync()               │     │
│  │ • AttachSelection()     │        │ • GetFileInfo()                 │     │
│  │ • ValidateContext()     │        └─────────────────────────────────┘     │
│  │ • GetContextsForMessage()│                                               │
│  └─────────────────────────┘                                                │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Data Flow: Attaching a File from Explorer

```
User right-clicks file → selects "Attach to Chat"
                │
                ▼
┌──────────────────────────────┐
│ FileExplorerViewModel        │
│ .AttachToContextCommand      │
└──────────────────────────────┘
                │
                ▼
┌──────────────────────────────┐
│ IContextService              │
│ .AttachFileAsync(filePath)   │
└──────────────────────────────┘
                │
                ▼
┌──────────────────────────────┐
│ Validation:                  │
│ • File exists?               │
│ • File size < MaxSize?       │
│ • Is text file?              │
│ • Already attached?          │
│ • Token limit not exceeded?  │
└──────────────────────────────┘
                │
        ┌───────┴───────┐
        ▼               ▼
   [Valid]         [Invalid]
        │               │
        │               ▼
        │   ┌──────────────────────────┐
        │   │ Show error notification  │
        │   │ "File too large" etc.    │
        │   └──────────────────────────┘
        │
        ▼
┌──────────────────────────────┐
│ IFileSystemService           │
│ .ReadFileAsync(filePath)     │
└──────────────────────────────┘
                │
                ▼
┌──────────────────────────────┐
│ Detect language              │
│ LanguageDetector.Detect()    │
└──────────────────────────────┘
                │
                ▼
┌──────────────────────────────┐
│ ITokenEstimationService      │
│ .EstimateTokens(content)     │
└──────────────────────────────┘
                │
                ▼
┌──────────────────────────────┐
│ Create FileContextViewModel  │
│ • Set all properties         │
│ • Generate preview content   │
└──────────────────────────────┘
                │
                ▼
┌──────────────────────────────┐
│ ChatViewModel                │
│ .AttachedContexts.Add(ctx)   │
│ Update TotalContextTokens    │
└──────────────────────────────┘
                │
                ▼
┌──────────────────────────────┐
│ UI Updates via binding       │
│ • Context pill appears       │
│ • Token count updates        │
└──────────────────────────────┘
```

### Data Flow: Attaching Selection from Editor

```
User selects code → presses Ctrl+Shift+A (or toolbar button)
                │
                ▼
┌──────────────────────────────┐
│ EditorPanel                  │
│ OnAttachSelectionRequested() │
└──────────────────────────────┘
                │
                ▼
┌──────────────────────────────┐
│ Get selection info:          │
│ • ActiveTab.FilePath         │
│ • Selection.StartPosition    │
│ • Selection.EndPosition      │
│ • Selection.GetText()        │
└──────────────────────────────┘
                │
                ▼
┌──────────────────────────────┐
│ Validation:                  │
│ • Selection not empty?       │
│ • Selection size OK?         │
└──────────────────────────────┘
                │
                ▼
┌──────────────────────────────┐
│ IContextService              │
│ .AttachSelectionAsync(       │
│     filePath,                │
│     content,                 │
│     startLine,               │
│     endLine                  │
│ )                            │
└──────────────────────────────┘
                │
                ▼
┌──────────────────────────────┐
│ ITokenEstimationService      │
│ .EstimateTokens(content)     │
└──────────────────────────────┘
                │
                ▼
┌──────────────────────────────┐
│ Create FileContextViewModel  │
│ • AttachmentType = Selection │
│ • StartLine, EndLine set     │
└──────────────────────────────┘
                │
                ▼
┌──────────────────────────────┐
│ ChatViewModel                │
│ .AttachedContexts.Add(ctx)   │
└──────────────────────────────┘
```

### Data Flow: Sending Message with Context

```
User types message and clicks Send
                │
                ▼
┌──────────────────────────────┐
│ ChatViewModel                │
│ .SendMessageCommand          │
└──────────────────────────────┘
                │
                ▼
┌──────────────────────────────┐
│ Check AttachedContexts       │
└──────────────────────────────┘
                │
        ┌───────┴───────┐
        ▼               ▼
   [Has Context]    [No Context]
        │               │
        ▼               │
┌──────────────────────────────┐
│ IContextFormatter            │
│ .FormatForPrompt(contexts)   │
└──────────────────────────────┘
        │               │
        ▼               │
┌──────────────────────────────┐
│ Build full prompt:           │
│ [Formatted Context]          │
│ [User Message]               │
└──────────────────────────────┘
        │               │
        └───────┬───────┘
                ▼
┌──────────────────────────────┐
│ Create ChatMessage           │
│ • Content = user input       │
│ • AttachedContexts = list    │
└──────────────────────────────┘
                │
                ▼
┌──────────────────────────────┐
│ ILlmService.SendAsync(       │
│     fullPrompt,              │
│     conversation             │
│ )                            │
└──────────────────────────────┘
                │
                ▼
┌──────────────────────────────┐
│ Store message with context   │
│ in conversation history      │
└──────────────────────────────┘
                │
                ▼
┌──────────────────────────────┐
│ Clear AttachedContexts       │
│ (contexts sent with message) │
└──────────────────────────────┘
```

---

## v0.3.4a: Token Estimation Service

### Objective
Create a service for estimating token counts for content, with support for different tokenization strategies and model-specific adjustments.

### ITokenEstimationService Interface

```csharp
namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Service for estimating token counts in text content.
/// </summary>
public interface ITokenEstimationService
{
    /// <summary>
    /// Estimates the token count for the given content using the default method.
    /// </summary>
    int EstimateTokens(string content);

    /// <summary>
    /// Estimates token count using a specific estimation method.
    /// </summary>
    int EstimateTokens(string content, TokenEstimationMethod method);

    /// <summary>
    /// Gets the recommended token limit for context based on model capabilities.
    /// </summary>
    int GetRecommendedContextLimit();

    /// <summary>
    /// Checks if adding content would exceed the context limit.
    /// </summary>
    bool WouldExceedLimit(int currentTokens, string newContent);

    /// <summary>
    /// Truncates content to fit within a token limit.
    /// </summary>
    string TruncateToTokenLimit(string content, int maxTokens);

    /// <summary>
    /// Gets a breakdown of token usage.
    /// </summary>
    TokenUsageBreakdown GetUsageBreakdown(IEnumerable<string> contents);
}

/// <summary>
/// Methods for estimating token counts.
/// </summary>
public enum TokenEstimationMethod
{
    /// <summary>
    /// Simple character-based estimation (~4 chars per token).
    /// Fast but less accurate.
    /// </summary>
    CharacterBased,

    /// <summary>
    /// Word and punctuation based estimation.
    /// More accurate for natural language.
    /// </summary>
    WordBased,

    /// <summary>
    /// Tiktoken-compatible BPE estimation.
    /// Most accurate but slower.
    /// </summary>
    BpeApproximate
}

/// <summary>
/// Breakdown of token usage across multiple content items.
/// </summary>
public sealed class TokenUsageBreakdown
{
    public int TotalTokens { get; init; }
    public int RecommendedLimit { get; init; }
    public double UsagePercentage => RecommendedLimit > 0
        ? (double)TotalTokens / RecommendedLimit * 100
        : 0;
    public bool IsOverLimit => TotalTokens > RecommendedLimit;
    public int RemainingTokens => Math.Max(0, RecommendedLimit - TotalTokens);
    public IReadOnlyList<(string Label, int Tokens)> Items { get; init; } = Array.Empty<(string, int)>();
}
```

### TokenEstimationService Implementation

```csharp
namespace SeniorIntern.Services;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using SeniorIntern.Core.Interfaces;

/// <summary>
/// Service for estimating token counts using various methods.
/// </summary>
public sealed class TokenEstimationService : ITokenEstimationService
{
    // Default context limit - can be adjusted based on model
    private const int DefaultContextLimit = 8000;

    // Character-based estimation ratio (conservative)
    private const double CharsPerToken = 3.5;

    // Word-based estimation ratios
    private const double WordsPerToken = 0.75;
    private const double PunctuationWeight = 0.5;

    /// <inheritdoc />
    public int EstimateTokens(string content)
    {
        return EstimateTokens(content, TokenEstimationMethod.WordBased);
    }

    /// <inheritdoc />
    public int EstimateTokens(string content, TokenEstimationMethod method)
    {
        if (string.IsNullOrEmpty(content))
            return 0;

        return method switch
        {
            TokenEstimationMethod.CharacterBased => EstimateByCharacters(content),
            TokenEstimationMethod.WordBased => EstimateByWords(content),
            TokenEstimationMethod.BpeApproximate => EstimateByBpe(content),
            _ => EstimateByWords(content)
        };
    }

    /// <inheritdoc />
    public int GetRecommendedContextLimit()
    {
        // In the future, this could be based on the loaded model's context window
        return DefaultContextLimit;
    }

    /// <inheritdoc />
    public bool WouldExceedLimit(int currentTokens, string newContent)
    {
        var newTokens = EstimateTokens(newContent);
        return (currentTokens + newTokens) > GetRecommendedContextLimit();
    }

    /// <inheritdoc />
    public string TruncateToTokenLimit(string content, int maxTokens)
    {
        if (string.IsNullOrEmpty(content))
            return content;

        var currentTokens = EstimateTokens(content);
        if (currentTokens <= maxTokens)
            return content;

        // Estimate characters needed for target tokens
        var targetChars = (int)(maxTokens * CharsPerToken);

        // Binary search for optimal truncation point
        var low = 0;
        var high = Math.Min(content.Length, targetChars + 100);

        while (low < high)
        {
            var mid = (low + high + 1) / 2;
            var truncated = content[..mid];
            var tokens = EstimateTokens(truncated);

            if (tokens <= maxTokens)
                low = mid;
            else
                high = mid - 1;
        }

        // Truncate at word boundary if possible
        var result = content[..low];
        var lastSpace = result.LastIndexOf(' ');
        if (lastSpace > low * 0.8) // Only if we don't lose too much
        {
            result = result[..lastSpace];
        }

        return result + "\n... (truncated)";
    }

    /// <inheritdoc />
    public TokenUsageBreakdown GetUsageBreakdown(IEnumerable<string> contents)
    {
        var items = contents
            .Select((content, index) => (
                Label: $"Item {index + 1}",
                Tokens: EstimateTokens(content)
            ))
            .ToList();

        return new TokenUsageBreakdown
        {
            TotalTokens = items.Sum(i => i.Tokens),
            RecommendedLimit = GetRecommendedContextLimit(),
            Items = items
        };
    }

    private static int EstimateByCharacters(string content)
    {
        // Simple: ~3.5 characters per token (conservative for code)
        return (int)Math.Ceiling(content.Length / CharsPerToken);
    }

    private static int EstimateByWords(string content)
    {
        // Count words (sequences of word characters)
        var wordCount = Regex.Matches(content, @"\b\w+\b").Count;

        // Count punctuation and special characters (they often become separate tokens)
        var punctuationCount = Regex.Matches(content, @"[^\w\s]").Count;

        // Count newlines (often separate tokens)
        var newlineCount = content.Count(c => c == '\n');

        // Count whitespace sequences > 1 (indentation often becomes tokens)
        var whitespaceSequences = Regex.Matches(content, @"[ \t]{2,}").Count;

        // Weighted combination
        var estimate = (int)Math.Ceiling(
            wordCount / WordsPerToken +
            punctuationCount * PunctuationWeight +
            newlineCount * 0.5 +
            whitespaceSequences * 0.3
        );

        return Math.Max(1, estimate);
    }

    private static int EstimateByBpe(string content)
    {
        // Approximate BPE-style tokenization
        // This is a simplified version - real BPE would use a vocabulary

        var tokens = 0;
        var i = 0;

        while (i < content.Length)
        {
            // Try to match common multi-character tokens first
            var remaining = content.AsSpan(i);

            // Common programming tokens (2-4 chars treated as single tokens)
            if (TryMatchCommonToken(remaining, out var matchLength))
            {
                tokens++;
                i += matchLength;
                continue;
            }

            // Single character
            var c = content[i];

            if (char.IsWhiteSpace(c))
            {
                // Whitespace - usually separate tokens
                tokens++;
                // Skip consecutive whitespace of same type
                while (i + 1 < content.Length && content[i + 1] == c)
                    i++;
            }
            else if (char.IsLetterOrDigit(c))
            {
                // Word characters - count as word then estimate
                var wordStart = i;
                while (i < content.Length && char.IsLetterOrDigit(content[i]))
                    i++;
                var wordLength = i - wordStart;

                // Estimate tokens for word (longer words = more tokens)
                tokens += Math.Max(1, (wordLength + 3) / 4);
                continue;
            }
            else
            {
                // Punctuation/symbols - usually single tokens
                tokens++;
            }

            i++;
        }

        return Math.Max(1, tokens);
    }

    private static bool TryMatchCommonToken(ReadOnlySpan<char> text, out int length)
    {
        // Common multi-character tokens in programming
        string[] commonTokens = {
            "public", "private", "protected", "static", "void", "class", "interface",
            "async", "await", "return", "string", "int", "bool", "var", "const",
            "function", "export", "import", "from", "=>", "->", "==", "!=", "<=", ">=",
            "&&", "||", "++", "--", "+=", "-=", "*=", "/=", "<<", ">>", "::", "..",
            "/**", "*/", "///", "//", "/*"
        };

        foreach (var token in commonTokens)
        {
            if (text.StartsWith(token.AsSpan()))
            {
                length = token.Length;
                return true;
            }
        }

        length = 0;
        return false;
    }
}
```

### Token Limits Configuration

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Configuration for context attachment limits.
/// </summary>
public sealed class ContextLimitsConfig
{
    /// <summary>
    /// Maximum number of files that can be attached at once.
    /// </summary>
    public int MaxFilesAttached { get; set; } = 10;

    /// <summary>
    /// Maximum tokens per individual file.
    /// </summary>
    public int MaxTokensPerFile { get; set; } = 4000;

    /// <summary>
    /// Maximum total tokens across all attached contexts.
    /// </summary>
    public int MaxTotalContextTokens { get; set; } = 8000;

    /// <summary>
    /// Maximum file size in bytes (files larger are rejected).
    /// </summary>
    public int MaxFileSizeBytes { get; set; } = 500_000; // 500KB

    /// <summary>
    /// Warning threshold as percentage of limit (0.0-1.0).
    /// </summary>
    public double WarningThreshold { get; set; } = 0.8;

    /// <summary>
    /// Maximum lines to show in preview.
    /// </summary>
    public int MaxPreviewLines { get; set; } = 20;

    /// <summary>
    /// Maximum characters in preview content.
    /// </summary>
    public int MaxPreviewCharacters { get; set; } = 500;
}
```

### Files to Create (v0.3.4a)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/ITokenEstimationService.cs` | Token estimation interface |
| `src/SeniorIntern.Services/TokenEstimationService.cs` | Token estimation implementation |
| `src/SeniorIntern.Core/Models/ContextLimitsConfig.cs` | Limits configuration |
| `src/SeniorIntern.Core/Models/TokenUsageBreakdown.cs` | Usage breakdown model |

### Files to Modify (v0.3.4a)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Core/Models/AppSettings.cs` | Add ContextLimitsConfig property |

### Acceptance Criteria (v0.3.4a)
- [ ] EstimateTokens returns reasonable estimates for code content
- [ ] Character-based estimation is fast (<1ms for typical files)
- [ ] Word-based estimation is more accurate than character-based
- [ ] TruncateToTokenLimit preserves code structure where possible
- [ ] WouldExceedLimit correctly predicts limit violations
- [ ] Token limits are configurable via settings

---

## v0.3.4b: Context Formatter

### Objective
Create a service that formats attached contexts into prompts suitable for LLM consumption, with proper markdown code blocks and metadata.

### IContextFormatter Interface

```csharp
namespace SeniorIntern.Core.Interfaces;

using SeniorIntern.Core.Models;

/// <summary>
/// Service for formatting file contexts into LLM prompts.
/// </summary>
public interface IContextFormatter
{
    /// <summary>
    /// Formats contexts for inclusion in an LLM prompt.
    /// </summary>
    string FormatForPrompt(IEnumerable<FileContext> contexts);

    /// <summary>
    /// Formats a single context for prompt inclusion.
    /// </summary>
    string FormatSingleContext(FileContext context);

    /// <summary>
    /// Formats contexts for display in the chat history UI.
    /// </summary>
    string FormatForDisplay(IEnumerable<FileContext> contexts, bool expanded = false);

    /// <summary>
    /// Creates a code block with syntax highlighting hint.
    /// </summary>
    string FormatCodeBlock(string content, string? language);

    /// <summary>
    /// Formats the context header with file metadata.
    /// </summary>
    string FormatContextHeader(FileContext context);
}
```

### ContextFormatter Implementation

```csharp
namespace SeniorIntern.Services;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;

/// <summary>
/// Formats file contexts for LLM prompts and UI display.
/// </summary>
public sealed class ContextFormatter : IContextFormatter
{
    private const string ContextSeparator = "\n---\n";
    private const int MaxDisplayLines = 10;

    /// <inheritdoc />
    public string FormatForPrompt(IEnumerable<FileContext> contexts)
    {
        var contextList = contexts.ToList();
        if (contextList.Count == 0)
            return string.Empty;

        var sb = new StringBuilder();

        // Header indicating context is provided
        sb.AppendLine("I'm providing you with the following code context:");
        sb.AppendLine();

        foreach (var context in contextList)
        {
            sb.Append(FormatSingleContext(context));
            sb.AppendLine();
        }

        sb.AppendLine("Please consider this context when responding to my question below.");
        sb.AppendLine();

        return sb.ToString();
    }

    /// <inheritdoc />
    public string FormatSingleContext(FileContext context)
    {
        var sb = new StringBuilder();

        // File header
        sb.AppendLine(FormatContextHeader(context));

        // Code block with syntax highlighting
        sb.Append(FormatCodeBlock(context.Content, context.Language));

        return sb.ToString();
    }

    /// <inheritdoc />
    public string FormatForDisplay(IEnumerable<FileContext> contexts, bool expanded = false)
    {
        var contextList = contexts.ToList();
        if (contextList.Count == 0)
            return string.Empty;

        var sb = new StringBuilder();

        foreach (var context in contextList)
        {
            sb.AppendLine($"**{context.FileName}**");

            if (context.IsPartialContent)
            {
                sb.AppendLine($"_Lines {context.StartLine}-{context.EndLine}_");
            }

            if (expanded)
            {
                sb.Append(FormatCodeBlock(context.Content, context.Language));
            }
            else
            {
                // Truncated preview
                var preview = GetPreview(context.Content, MaxDisplayLines);
                sb.Append(FormatCodeBlock(preview, context.Language));
            }

            sb.AppendLine();
        }

        return sb.ToString();
    }

    /// <inheritdoc />
    public string FormatCodeBlock(string content, string? language)
    {
        var sb = new StringBuilder();

        sb.Append("```");
        sb.AppendLine(language ?? string.Empty);
        sb.AppendLine(content.TrimEnd());
        sb.AppendLine("```");

        return sb.ToString();
    }

    /// <inheritdoc />
    public string FormatContextHeader(FileContext context)
    {
        var sb = new StringBuilder();

        sb.Append($"### File: `{context.FileName}`");

        if (!string.IsNullOrEmpty(context.Language))
        {
            sb.Append($" ({context.Language})");
        }

        sb.AppendLine();

        // Add line range if it's a selection
        if (context.IsPartialContent)
        {
            sb.AppendLine($"**Lines {context.StartLine}-{context.EndLine}**");
        }

        // Add relative path if available and different from filename
        if (!string.IsNullOrEmpty(context.FilePath))
        {
            var relativePath = GetDisplayPath(context.FilePath);
            if (relativePath != context.FileName)
            {
                sb.AppendLine($"_Path: {relativePath}_");
            }
        }

        return sb.ToString();
    }

    /// <summary>
    /// Formats contexts for inclusion in message history storage.
    /// </summary>
    public string FormatForStorage(IEnumerable<FileContext> contexts)
    {
        return System.Text.Json.JsonSerializer.Serialize(contexts.Select(c => new
        {
            c.Id,
            c.FilePath,
            c.FileName,
            c.Language,
            c.StartLine,
            c.EndLine,
            c.EstimatedTokens,
            c.AttachedAt,
            // Don't store full content - store hash for detecting changes
            ContentHash = ComputeHash(c.Content),
            ContentLength = c.Content.Length
        }));
    }

    private static string GetPreview(string content, int maxLines)
    {
        var lines = content.Split('\n');
        if (lines.Length <= maxLines)
            return content;

        var preview = string.Join('\n', lines.Take(maxLines));
        var remaining = lines.Length - maxLines;
        return $"{preview}\n// ... ({remaining} more lines)";
    }

    private static string GetDisplayPath(string fullPath)
    {
        // Extract meaningful path portion
        // e.g., "src/Services/MyService.cs" instead of full path
        var parts = fullPath.Replace('\\', '/').Split('/');

        // Take last 3 parts at most
        var meaningfulParts = parts.TakeLast(3);
        return string.Join('/', meaningfulParts);
    }

    private static string ComputeHash(string content)
    {
        using var sha = System.Security.Cryptography.SHA256.Create();
        var bytes = Encoding.UTF8.GetBytes(content);
        var hash = sha.ComputeHash(bytes);
        return Convert.ToHexString(hash)[..16]; // First 16 chars of hash
    }
}
```

### Prompt Templates

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Templates for context formatting in prompts.
/// </summary>
public static class ContextPromptTemplates
{
    /// <summary>
    /// Template for single file context.
    /// </summary>
    public const string SingleFileTemplate = """
        ### File: `{FileName}` ({Language})
        {LineRange}
        ```{Language}
        {Content}
        ```
        """;

    /// <summary>
    /// Template for context header in prompts.
    /// </summary>
    public const string ContextHeaderTemplate = """
        I'm providing you with the following code context to help you understand my question:

        {FormattedContexts}

        Please consider this context when responding. If you need to reference specific code, use the file names and line numbers provided.

        ---

        """;

    /// <summary>
    /// Template for when context has been truncated.
    /// </summary>
    public const string TruncationNotice = """

        *Note: This file has been truncated to fit within context limits. The full file is {TotalLines} lines ({TotalTokens} tokens estimated).*
        """;

    /// <summary>
    /// Template for selection context.
    /// </summary>
    public const string SelectionTemplate = """
        ### Selected Code from `{FileName}` (lines {StartLine}-{EndLine})
        ```{Language}
        {Content}
        ```
        """;
}
```

### Files to Create (v0.3.4b)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Core/Interfaces/IContextFormatter.cs` | Formatter interface |
| `src/SeniorIntern.Services/ContextFormatter.cs` | Formatter implementation |
| `src/SeniorIntern.Core/Models/ContextPromptTemplates.cs` | Prompt templates |

### Files to Modify (v0.3.4b)

None.

### Acceptance Criteria (v0.3.4b)
- [ ] FormatForPrompt creates well-structured LLM prompts
- [ ] Code blocks include correct language hints
- [ ] Line numbers shown for selections
- [ ] Truncation notice appears when content is cut
- [ ] FormatForDisplay creates readable UI content
- [ ] File paths are shortened for display

---

## v0.3.4c: File Context ViewModel

### Objective
Create the ViewModel for file context attachments that manages display state, preview content, and user interactions.

### FileContextViewModel Implementation

```csharp
namespace SeniorIntern.Desktop.ViewModels;

using System;
using System.IO;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using SeniorIntern.Core.Models;
using SeniorIntern.Core.Utilities;

/// <summary>
/// Type of context attachment.
/// </summary>
public enum ContextAttachmentType
{
    /// <summary>
    /// Entire file attached.
    /// </summary>
    File,

    /// <summary>
    /// Code selection from editor.
    /// </summary>
    Selection,

    /// <summary>
    /// Content from clipboard.
    /// </summary>
    Clipboard
}

/// <summary>
/// ViewModel for an attached file context.
/// </summary>
public partial class FileContextViewModel : ViewModelBase
{
    private const int MaxPreviewLength = 500;
    private const int MaxPreviewLines = 15;

    /// <summary>
    /// Unique identifier for this context.
    /// </summary>
    [ObservableProperty]
    private Guid _id = Guid.NewGuid();

    /// <summary>
    /// Full path to the file (empty for clipboard content).
    /// </summary>
    [ObservableProperty]
    private string _filePath = string.Empty;

    /// <summary>
    /// File name for display.
    /// </summary>
    [ObservableProperty]
    private string _fileName = string.Empty;

    /// <summary>
    /// Detected language identifier.
    /// </summary>
    [ObservableProperty]
    private string? _language;

    /// <summary>
    /// Full content of the context.
    /// </summary>
    [ObservableProperty]
    private string _content = string.Empty;

    /// <summary>
    /// Estimated token count.
    /// </summary>
    [ObservableProperty]
    private int _estimatedTokens;

    /// <summary>
    /// Total line count.
    /// </summary>
    [ObservableProperty]
    private int _lineCount;

    /// <summary>
    /// Starting line number (for selections).
    /// </summary>
    [ObservableProperty]
    private int? _startLine;

    /// <summary>
    /// Ending line number (for selections).
    /// </summary>
    [ObservableProperty]
    private int? _endLine;

    /// <summary>
    /// Type of attachment.
    /// </summary>
    [ObservableProperty]
    private ContextAttachmentType _attachmentType = ContextAttachmentType.File;

    /// <summary>
    /// Whether the preview is expanded.
    /// </summary>
    [ObservableProperty]
    private bool _isExpanded;

    /// <summary>
    /// When the context was attached.
    /// </summary>
    [ObservableProperty]
    private DateTime _attachedAt = DateTime.UtcNow;

    /// <summary>
    /// Whether this context is currently being hovered.
    /// </summary>
    [ObservableProperty]
    private bool _isHovered;

    /// <summary>
    /// Label for display (includes line range for selections).
    /// </summary>
    public string DisplayLabel
    {
        get
        {
            if (AttachmentType == ContextAttachmentType.Clipboard)
                return "Clipboard";

            if (StartLine.HasValue && EndLine.HasValue)
                return $"{FileName}:{StartLine}-{EndLine}";

            return FileName;
        }
    }

    /// <summary>
    /// Short label for compact display.
    /// </summary>
    public string ShortLabel
    {
        get
        {
            var name = FileName;
            if (name.Length > 20)
                name = name[..17] + "...";

            if (StartLine.HasValue)
                return $"{name}:{StartLine}-{EndLine}";

            return name;
        }
    }

    /// <summary>
    /// Preview content (truncated).
    /// </summary>
    public string PreviewContent
    {
        get
        {
            if (string.IsNullOrEmpty(Content))
                return "(empty)";

            var lines = Content.Split('\n');
            if (lines.Length <= MaxPreviewLines && Content.Length <= MaxPreviewLength)
                return Content;

            var preview = string.Join('\n', lines.Take(MaxPreviewLines));
            if (preview.Length > MaxPreviewLength)
                preview = preview[..MaxPreviewLength];

            var remainingLines = lines.Length - MaxPreviewLines;
            if (remainingLines > 0)
                preview += $"\n// ... ({remainingLines} more lines)";
            else if (Content.Length > preview.Length)
                preview += "...";

            return preview;
        }
    }

    /// <summary>
    /// Whether this is a partial selection (not full file).
    /// </summary>
    public bool IsPartialContent => StartLine.HasValue || EndLine.HasValue;

    /// <summary>
    /// Tooltip text for the context pill.
    /// </summary>
    public string Tooltip
    {
        get
        {
            var parts = new List<string>
            {
                DisplayLabel,
                $"{LineCount} lines",
                $"~{EstimatedTokens} tokens"
            };

            if (!string.IsNullOrEmpty(Language))
                parts.Insert(1, Language);

            if (!string.IsNullOrEmpty(FilePath))
                parts.Add(FilePath);

            return string.Join(" • ", parts);
        }
    }

    /// <summary>
    /// Icon key based on language/type.
    /// </summary>
    public string IconKey
    {
        get
        {
            if (AttachmentType == ContextAttachmentType.Clipboard)
                return "ClipboardIcon";

            if (AttachmentType == ContextAttachmentType.Selection)
                return "SelectionIcon";

            return Language switch
            {
                "csharp" => "CSharpIcon",
                "javascript" or "typescript" => "JavaScriptIcon",
                "python" => "PythonIcon",
                "json" => "JsonIcon",
                "xml" or "html" => "XmlIcon",
                "markdown" => "MarkdownIcon",
                _ => "FileCodeIcon"
            };
        }
    }

    /// <summary>
    /// Badge text (e.g., "C#", "JS", "Selection").
    /// </summary>
    public string Badge
    {
        get
        {
            if (AttachmentType == ContextAttachmentType.Selection)
                return "SEL";

            if (AttachmentType == ContextAttachmentType.Clipboard)
                return "CLIP";

            return Language?.ToUpperInvariant() switch
            {
                "CSHARP" => "C#",
                "JAVASCRIPT" => "JS",
                "TYPESCRIPT" => "TS",
                "PYTHON" => "PY",
                _ => Language?.ToUpperInvariant()?[..Math.Min(4, Language.Length)] ?? "TXT"
            };
        }
    }

    /// <summary>
    /// Creates a FileContextViewModel from a file path and content.
    /// </summary>
    public static FileContextViewModel FromFile(
        string filePath,
        string content,
        int estimatedTokens)
    {
        var fileName = Path.GetFileName(filePath);
        var language = LanguageDetector.DetectByFileName(fileName);

        return new FileContextViewModel
        {
            FilePath = filePath,
            FileName = fileName,
            Language = language,
            Content = content,
            EstimatedTokens = estimatedTokens,
            LineCount = content.Split('\n').Length,
            AttachmentType = ContextAttachmentType.File
        };
    }

    /// <summary>
    /// Creates a FileContextViewModel from a selection.
    /// </summary>
    public static FileContextViewModel FromSelection(
        string filePath,
        string content,
        int startLine,
        int endLine,
        int estimatedTokens)
    {
        var fileName = Path.GetFileName(filePath);
        var language = LanguageDetector.DetectByFileName(fileName);

        return new FileContextViewModel
        {
            FilePath = filePath,
            FileName = fileName,
            Language = language,
            Content = content,
            EstimatedTokens = estimatedTokens,
            LineCount = endLine - startLine + 1,
            StartLine = startLine,
            EndLine = endLine,
            AttachmentType = ContextAttachmentType.Selection
        };
    }

    /// <summary>
    /// Creates a FileContextViewModel from clipboard content.
    /// </summary>
    public static FileContextViewModel FromClipboard(
        string content,
        string? language,
        int estimatedTokens)
    {
        return new FileContextViewModel
        {
            FileName = "Clipboard",
            Language = language,
            Content = content,
            EstimatedTokens = estimatedTokens,
            LineCount = content.Split('\n').Length,
            AttachmentType = ContextAttachmentType.Clipboard
        };
    }

    /// <summary>
    /// Converts to core FileContext model.
    /// </summary>
    public FileContext ToFileContext()
    {
        return new FileContext
        {
            Id = Id,
            FilePath = FilePath,
            Content = Content,
            Language = Language,
            LineCount = LineCount,
            EstimatedTokens = EstimatedTokens,
            AttachedAt = AttachedAt,
            StartLine = StartLine,
            EndLine = EndLine
        };
    }
}
```

### Files to Create (v0.3.4c)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/ViewModels/FileContextViewModel.cs` | Context ViewModel |

### Files to Modify (v0.3.4c)

None.

### Acceptance Criteria (v0.3.4c)
- [ ] FromFile creates context from file path and content
- [ ] FromSelection creates context with line range
- [ ] FromClipboard creates context for clipboard content
- [ ] DisplayLabel shows appropriate text for each type
- [ ] PreviewContent truncates long content appropriately
- [ ] IconKey returns correct icon for language
- [ ] ToFileContext converts to core model correctly

---

## v0.3.4d: Chat Context Bar UI

### Objective
Create the context bar UI component that displays attached contexts as pills above the chat input, with token count and management actions.

### ChatContextBar.axaml Implementation

```xml
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             xmlns:vm="using:SeniorIntern.Desktop.ViewModels"
             xmlns:conv="using:SeniorIntern.Desktop.Converters"
             mc:Ignorable="d" d:DesignWidth="600" d:DesignHeight="100"
             x:Class="SeniorIntern.Desktop.Views.ChatContextBar"
             x:DataType="vm:ChatViewModel">

    <UserControl.Resources>
        <conv:TokenCountConverter x:Key="TokenCountConverter" />
        <conv:BoolToOpacityConverter x:Key="BoolToOpacity" />
    </UserControl.Resources>

    <UserControl.Styles>
        <!-- Context Pill Style -->
        <Style Selector="Border.context-pill">
            <Setter Property="Background" Value="{DynamicResource ContextPillBackgroundBrush}" />
            <Setter Property="BorderBrush" Value="{DynamicResource ContextPillBorderBrush}" />
            <Setter Property="BorderThickness" Value="1" />
            <Setter Property="CornerRadius" Value="12" />
            <Setter Property="Padding" Value="8,4,4,4" />
            <Setter Property="Cursor" Value="Hand" />
        </Style>

        <Style Selector="Border.context-pill:pointerover">
            <Setter Property="Background" Value="{DynamicResource ContextPillHoverBrush}" />
        </Style>

        <Style Selector="Border.context-pill.selection">
            <Setter Property="BorderBrush" Value="{DynamicResource SelectionAccentBrush}" />
        </Style>

        <!-- Close Button Style -->
        <Style Selector="Button.pill-close">
            <Setter Property="Background" Value="Transparent" />
            <Setter Property="BorderThickness" Value="0" />
            <Setter Property="Padding" Value="4" />
            <Setter Property="CornerRadius" Value="10" />
            <Setter Property="Width" Value="20" />
            <Setter Property="Height" Value="20" />
            <Setter Property="Opacity" Value="0.6" />
        </Style>

        <Style Selector="Button.pill-close:pointerover">
            <Setter Property="Background" Value="{DynamicResource CloseButtonHoverBrush}" />
            <Setter Property="Opacity" Value="1" />
        </Style>

        <!-- Token Warning Style -->
        <Style Selector="TextBlock.token-warning">
            <Setter Property="Foreground" Value="{DynamicResource WarningBrush}" />
            <Setter Property="FontWeight" Value="SemiBold" />
        </Style>

        <Style Selector="TextBlock.token-danger">
            <Setter Property="Foreground" Value="{DynamicResource ErrorBrush}" />
            <Setter Property="FontWeight" Value="Bold" />
        </Style>
    </UserControl.Styles>

    <!-- Main Container - Only visible when contexts attached -->
    <Border Background="{DynamicResource ContextBarBackgroundBrush}"
            BorderBrush="{DynamicResource BorderBrush}"
            BorderThickness="0,0,0,1"
            Padding="12,8"
            IsVisible="{Binding HasAttachedContexts}">

        <Grid RowDefinitions="Auto, Auto, Auto">
            <!-- Header Row -->
            <Grid Grid.Row="0" ColumnDefinitions="Auto, *, Auto, Auto" Margin="0,0,0,8">
                <!-- Icon and Title -->
                <StackPanel Grid.Column="0" Orientation="Horizontal" Spacing="6">
                    <PathIcon Data="{StaticResource AttachmentIcon}"
                              Width="14" Height="14"
                              Foreground="{DynamicResource TextSecondaryBrush}" />
                    <TextBlock Text="Attached Context"
                               FontWeight="SemiBold"
                               FontSize="12"
                               Foreground="{DynamicResource TextSecondaryBrush}" />
                </StackPanel>

                <!-- Token Count -->
                <StackPanel Grid.Column="2" Orientation="Horizontal" Spacing="4" Margin="0,0,12,0">
                    <TextBlock Text="~"
                               FontSize="11"
                               Foreground="{DynamicResource TextMutedBrush}" />
                    <TextBlock Text="{Binding TotalContextTokens}"
                               FontSize="11"
                               FontWeight="SemiBold"
                               Classes.token-warning="{Binding IsNearTokenLimit}"
                               Classes.token-danger="{Binding IsOverTokenLimit}" />
                    <TextBlock Text="/"
                               FontSize="11"
                               Foreground="{DynamicResource TextMutedBrush}" />
                    <TextBlock Text="{Binding MaxContextTokens}"
                               FontSize="11"
                               Foreground="{DynamicResource TextMutedBrush}" />
                    <TextBlock Text="tokens"
                               FontSize="11"
                               Foreground="{DynamicResource TextMutedBrush}" />
                </StackPanel>

                <!-- Clear All Button -->
                <Button Grid.Column="3"
                        Content="Clear All"
                        Classes="link-button"
                        FontSize="11"
                        Command="{Binding ClearAllContextsCommand}"
                        IsVisible="{Binding HasMultipleContexts}" />
            </Grid>

            <!-- Context Pills -->
            <ItemsControl Grid.Row="1" ItemsSource="{Binding AttachedContexts}">
                <ItemsControl.ItemsPanel>
                    <ItemsPanelTemplate>
                        <WrapPanel Orientation="Horizontal" />
                    </ItemsPanelTemplate>
                </ItemsControl.ItemsPanel>

                <ItemsControl.ItemTemplate>
                    <DataTemplate x:DataType="vm:FileContextViewModel">
                        <Border Classes="context-pill"
                                Classes.selection="{Binding IsPartialContent}"
                                Margin="0,0,6,6"
                                ToolTip.Tip="{Binding Tooltip}"
                                PointerPressed="OnContextPillPressed"
                                PointerEntered="OnContextPillEntered"
                                PointerExited="OnContextPillExited">

                            <Grid ColumnDefinitions="Auto, Auto, Auto, Auto">
                                <!-- Language Badge -->
                                <Border Grid.Column="0"
                                        Background="{DynamicResource BadgeBackgroundBrush}"
                                        CornerRadius="4"
                                        Padding="4,2"
                                        Margin="0,0,6,0"
                                        VerticalAlignment="Center">
                                    <TextBlock Text="{Binding Badge}"
                                               FontSize="9"
                                               FontWeight="Bold"
                                               Foreground="{DynamicResource BadgeForegroundBrush}" />
                                </Border>

                                <!-- File Name -->
                                <TextBlock Grid.Column="1"
                                           Text="{Binding ShortLabel}"
                                           FontSize="12"
                                           VerticalAlignment="Center"
                                           Foreground="{DynamicResource TextPrimaryBrush}" />

                                <!-- Token Count -->
                                <TextBlock Grid.Column="2"
                                           Text="{Binding EstimatedTokens, StringFormat='~{0}'}"
                                           FontSize="10"
                                           Margin="6,0"
                                           VerticalAlignment="Center"
                                           Foreground="{DynamicResource TextMutedBrush}" />

                                <!-- Close Button -->
                                <Button Grid.Column="3"
                                        Classes="pill-close"
                                        Command="{Binding $parent[UserControl].((vm:ChatViewModel)DataContext).RemoveContextCommand}"
                                        CommandParameter="{Binding}"
                                        VerticalAlignment="Center">
                                    <PathIcon Data="{StaticResource CloseIcon}"
                                              Width="8" Height="8" />
                                </Button>
                            </Grid>
                        </Border>
                    </DataTemplate>
                </ItemsControl.ItemTemplate>
            </ItemsControl>

            <!-- Warning Messages -->
            <StackPanel Grid.Row="2" Margin="0,4,0,0">
                <!-- Near limit warning -->
                <Border Background="{DynamicResource WarningBackgroundBrush}"
                        CornerRadius="4"
                        Padding="8,4"
                        IsVisible="{Binding IsNearTokenLimit}">
                    <StackPanel Orientation="Horizontal" Spacing="6">
                        <PathIcon Data="{StaticResource WarningIcon}"
                                  Width="12" Height="12"
                                  Foreground="{DynamicResource WarningBrush}" />
                        <TextBlock Text="Approaching context limit. Consider removing some files."
                                   FontSize="11"
                                   Foreground="{DynamicResource WarningBrush}" />
                    </StackPanel>
                </Border>

                <!-- Over limit error -->
                <Border Background="{DynamicResource ErrorBackgroundBrush}"
                        CornerRadius="4"
                        Padding="8,4"
                        IsVisible="{Binding IsOverTokenLimit}">
                    <StackPanel Orientation="Horizontal" Spacing="6">
                        <PathIcon Data="{StaticResource ErrorIcon}"
                                  Width="12" Height="12"
                                  Foreground="{DynamicResource ErrorBrush}" />
                        <TextBlock Text="Context limit exceeded. Remove some files to send message."
                                   FontSize="11"
                                   Foreground="{DynamicResource ErrorBrush}" />
                    </StackPanel>
                </Border>
            </StackPanel>
        </Grid>
    </Border>
</UserControl>
```

### ChatContextBar.axaml.cs Code-Behind

```csharp
namespace SeniorIntern.Desktop.Views;

using System;
using Avalonia.Controls;
using Avalonia.Input;
using Avalonia.Interactivity;
using SeniorIntern.Desktop.ViewModels;

public partial class ChatContextBar : UserControl
{
    public ChatContextBar()
    {
        InitializeComponent();
    }

    private void OnContextPillPressed(object? sender, PointerPressedEventArgs e)
    {
        if (sender is not Border border) return;
        if (border.DataContext is not FileContextViewModel context) return;

        var viewModel = DataContext as ChatViewModel;
        if (viewModel == null) return;

        // Left click: show preview
        if (e.GetCurrentPoint(border).Properties.IsLeftButtonPressed)
        {
            viewModel.ShowPreviewCommand.Execute(context);
        }
        // Middle click: remove
        else if (e.GetCurrentPoint(border).Properties.IsMiddleButtonPressed)
        {
            viewModel.RemoveContextCommand.Execute(context);
        }
    }

    private void OnContextPillEntered(object? sender, PointerEventArgs e)
    {
        if (sender is Border border && border.DataContext is FileContextViewModel context)
        {
            context.IsHovered = true;
        }
    }

    private void OnContextPillExited(object? sender, PointerEventArgs e)
    {
        if (sender is Border border && border.DataContext is FileContextViewModel context)
        {
            context.IsHovered = false;
        }
    }
}
```

### Context Bar Theme Resources

```xml
<!-- Add to Dark.axaml -->

<!-- Context Bar Colors -->
<SolidColorBrush x:Key="ContextBarBackgroundBrush" Color="#1E1E1E" />
<SolidColorBrush x:Key="ContextPillBackgroundBrush" Color="#2D2D2D" />
<SolidColorBrush x:Key="ContextPillBorderBrush" Color="#3E3E3E" />
<SolidColorBrush x:Key="ContextPillHoverBrush" Color="#383838" />
<SolidColorBrush x:Key="SelectionAccentBrush" Color="#569CD6" />
<SolidColorBrush x:Key="CloseButtonHoverBrush" Color="#4E4E4E" />

<!-- Badge Colors -->
<SolidColorBrush x:Key="BadgeBackgroundBrush" Color="#3E3E3E" />
<SolidColorBrush x:Key="BadgeForegroundBrush" Color="#CCCCCC" />

<!-- Warning/Error Colors -->
<SolidColorBrush x:Key="WarningBrush" Color="#DDB700" />
<SolidColorBrush x:Key="WarningBackgroundBrush" Color="#332D00" />
<SolidColorBrush x:Key="ErrorBrush" Color="#F14C4C" />
<SolidColorBrush x:Key="ErrorBackgroundBrush" Color="#331111" />
```

### Files to Create (v0.3.4d)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/Views/ChatContextBar.axaml` | Context bar UI |
| `src/SeniorIntern.Desktop/Views/ChatContextBar.axaml.cs` | Context bar code-behind |
| `src/SeniorIntern.Desktop/Converters/TokenCountConverter.cs` | Token formatting converter |

### Files to Modify (v0.3.4d)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/Themes/Dark.axaml` | Add context bar styles |
| `src/SeniorIntern.Desktop/Assets/Icons.axaml` | Add AttachmentIcon |

### Acceptance Criteria (v0.3.4d)
- [ ] Context pills display for each attached context
- [ ] Language badge shows correct abbreviation
- [ ] Token count displays per-pill and total
- [ ] Close button removes individual context
- [ ] Clear All removes all contexts
- [ ] Warning shows near token limit
- [ ] Error shows when over limit
- [ ] Clicking pill opens preview

---

## v0.3.4e: Context Preview

### Objective
Create a popup that shows the full or expanded content of an attached context with syntax highlighting.

### ContextPreviewPopup.axaml Implementation

```xml
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             xmlns:ae="using:AvaloniaEdit"
             xmlns:vm="using:SeniorIntern.Desktop.ViewModels"
             mc:Ignorable="d" d:DesignWidth="500" d:DesignHeight="400"
             x:Class="SeniorIntern.Desktop.Views.ContextPreviewPopup"
             x:DataType="vm:FileContextViewModel">

    <Border Background="{DynamicResource PopupBackgroundBrush}"
            BorderBrush="{DynamicResource PopupBorderBrush}"
            BorderThickness="1"
            CornerRadius="8"
            Padding="0"
            MinWidth="400"
            MaxWidth="700"
            MaxHeight="500"
            BoxShadow="0 4 16 0 #40000000">

        <Grid RowDefinitions="Auto, *, Auto">
            <!-- Header -->
            <Border Grid.Row="0"
                    Background="{DynamicResource PopupHeaderBrush}"
                    CornerRadius="8,8,0,0"
                    Padding="12,8">
                <Grid ColumnDefinitions="Auto, *, Auto, Auto">
                    <!-- File Icon -->
                    <PathIcon Grid.Column="0"
                              Data="{Binding IconKey, Converter={StaticResource IconKeyConverter}}"
                              Width="16" Height="16"
                              Margin="0,0,8,0"
                              Foreground="{DynamicResource TextSecondaryBrush}" />

                    <!-- File Name and Path -->
                    <StackPanel Grid.Column="1" Spacing="2">
                        <TextBlock Text="{Binding DisplayLabel}"
                                   FontWeight="SemiBold"
                                   FontSize="13"
                                   Foreground="{DynamicResource TextPrimaryBrush}" />
                        <TextBlock Text="{Binding FilePath}"
                                   FontSize="11"
                                   Foreground="{DynamicResource TextMutedBrush}"
                                   IsVisible="{Binding FilePath, Converter={x:Static StringConverters.IsNotNullOrEmpty}}"
                                   TextTrimming="CharacterEllipsis" />
                    </StackPanel>

                    <!-- Language Badge -->
                    <Border Grid.Column="2"
                            Background="{DynamicResource BadgeBackgroundBrush}"
                            CornerRadius="4"
                            Padding="6,2"
                            Margin="8,0"
                            VerticalAlignment="Center"
                            IsVisible="{Binding Language, Converter={x:Static StringConverters.IsNotNullOrEmpty}}">
                        <TextBlock Text="{Binding Language}"
                                   FontSize="10"
                                   Foreground="{DynamicResource BadgeForegroundBrush}" />
                    </Border>

                    <!-- Close Button -->
                    <Button Grid.Column="3"
                            Classes="icon-button"
                            Command="{Binding $parent[UserControl].CloseCommand}"
                            ToolTip.Tip="Close (Escape)">
                        <PathIcon Data="{StaticResource CloseIcon}"
                                  Width="12" Height="12" />
                    </Button>
                </Grid>
            </Border>

            <!-- Content Area -->
            <Border Grid.Row="1" Padding="1">
                <ae:TextEditor x:Name="PreviewEditor"
                               IsReadOnly="True"
                               ShowLineNumbers="True"
                               FontFamily="Cascadia Code, Consolas, monospace"
                               FontSize="12"
                               Background="{DynamicResource EditorBackgroundBrush}"
                               Foreground="{DynamicResource EditorForegroundBrush}"
                               HorizontalScrollBarVisibility="Auto"
                               VerticalScrollBarVisibility="Auto" />
            </Border>

            <!-- Footer -->
            <Border Grid.Row="2"
                    Background="{DynamicResource PopupFooterBrush}"
                    CornerRadius="0,0,8,8"
                    Padding="12,8">
                <Grid ColumnDefinitions="*, Auto, Auto, Auto">
                    <!-- Stats -->
                    <StackPanel Grid.Column="0" Orientation="Horizontal" Spacing="12">
                        <TextBlock FontSize="11" Foreground="{DynamicResource TextMutedBrush}">
                            <Run Text="{Binding LineCount}" />
                            <Run Text="lines" />
                        </TextBlock>
                        <TextBlock FontSize="11" Foreground="{DynamicResource TextMutedBrush}">
                            <Run Text="~" />
                            <Run Text="{Binding EstimatedTokens}" />
                            <Run Text="tokens" />
                        </TextBlock>
                    </StackPanel>

                    <!-- Actions -->
                    <Button Grid.Column="1"
                            Content="Open in Editor"
                            Classes="link-button"
                            FontSize="11"
                            Command="{Binding $parent[UserControl].OpenInEditorCommand}"
                            IsVisible="{Binding FilePath, Converter={x:Static StringConverters.IsNotNullOrEmpty}}"
                            Margin="0,0,12,0" />

                    <Button Grid.Column="2"
                            Content="Copy"
                            Classes="link-button"
                            FontSize="11"
                            Command="{Binding $parent[UserControl].CopyContentCommand}"
                            Margin="0,0,12,0" />

                    <Button Grid.Column="3"
                            Content="Remove"
                            Classes="link-button danger"
                            FontSize="11"
                            Command="{Binding $parent[UserControl].RemoveCommand}" />
                </Grid>
            </Border>
        </Grid>
    </Border>
</UserControl>
```

### ContextPreviewPopup.axaml.cs Code-Behind

```csharp
namespace SeniorIntern.Desktop.Views;

using System;
using System.Windows.Input;
using Avalonia;
using Avalonia.Controls;
using Avalonia.Input;
using Avalonia.Interactivity;
using CommunityToolkit.Mvvm.Input;
using SeniorIntern.Desktop.Services;
using SeniorIntern.Desktop.ViewModels;

public partial class ContextPreviewPopup : UserControl
{
    private SyntaxHighlightingService? _syntaxService;

    public static readonly StyledProperty<ICommand?> CloseCommandProperty =
        AvaloniaProperty.Register<ContextPreviewPopup, ICommand?>(nameof(CloseCommand));

    public static readonly StyledProperty<ICommand?> OpenInEditorCommandProperty =
        AvaloniaProperty.Register<ContextPreviewPopup, ICommand?>(nameof(OpenInEditorCommand));

    public static readonly StyledProperty<ICommand?> RemoveCommandProperty =
        AvaloniaProperty.Register<ContextPreviewPopup, ICommand?>(nameof(RemoveCommand));

    public ICommand? CloseCommand
    {
        get => GetValue(CloseCommandProperty);
        set => SetValue(CloseCommandProperty, value);
    }

    public ICommand? OpenInEditorCommand
    {
        get => GetValue(OpenInEditorCommandProperty);
        set => SetValue(OpenInEditorCommandProperty, value);
    }

    public ICommand? RemoveCommand
    {
        get => GetValue(RemoveCommandProperty);
        set => SetValue(RemoveCommandProperty, value);
    }

    public ICommand CopyContentCommand { get; }

    public ContextPreviewPopup()
    {
        InitializeComponent();

        CopyContentCommand = new RelayCommand(CopyContent);

        // Handle DataContext changes
        DataContextChanged += OnDataContextChanged;
    }

    public void Initialize(SyntaxHighlightingService syntaxService)
    {
        _syntaxService = syntaxService;
    }

    private void OnDataContextChanged(object? sender, EventArgs e)
    {
        if (DataContext is not FileContextViewModel context) return;

        // Set content
        PreviewEditor.Text = context.Content;

        // Apply syntax highlighting
        if (_syntaxService != null && !string.IsNullOrEmpty(context.Language))
        {
            _syntaxService.ApplyHighlighting(PreviewEditor, context.Language);
        }

        // Scroll to start
        PreviewEditor.TextArea.Caret.Offset = 0;

        // If selection, highlight the line range
        if (context.StartLine.HasValue && context.EndLine.HasValue)
        {
            // Optionally scroll to the start line
            var line = PreviewEditor.Document.GetLineByNumber(
                Math.Min(context.StartLine.Value, PreviewEditor.Document.LineCount));
            PreviewEditor.TextArea.Caret.Offset = line.Offset;
            PreviewEditor.TextArea.Caret.BringCaretToView();
        }
    }

    private async void CopyContent()
    {
        if (DataContext is not FileContextViewModel context) return;

        var clipboard = TopLevel.GetTopLevel(this)?.Clipboard;
        if (clipboard != null)
        {
            await clipboard.SetTextAsync(context.Content);

            // TODO: Show "Copied!" feedback
        }
    }

    protected override void OnKeyDown(KeyEventArgs e)
    {
        base.OnKeyDown(e);

        if (e.Key == Key.Escape)
        {
            CloseCommand?.Execute(null);
            e.Handled = true;
        }
    }
}
```

### Preview Host in ChatView

```xml
<!-- Add to ChatView.axaml -->

<!-- Context Preview Overlay -->
<Panel Grid.Row="0" Grid.RowSpan="3"
       IsVisible="{Binding IsPreviewOpen}"
       ZIndex="100">
    <!-- Backdrop -->
    <Border Background="#80000000"
            PointerPressed="OnPreviewBackdropPressed" />

    <!-- Preview Popup -->
    <views:ContextPreviewPopup DataContext="{Binding SelectedPreviewContext}"
                               CloseCommand="{Binding HidePreviewCommand}"
                               OpenInEditorCommand="{Binding OpenContextFileCommand}"
                               RemoveCommand="{Binding RemoveSelectedContextCommand}"
                               HorizontalAlignment="Center"
                               VerticalAlignment="Center"
                               Margin="40" />
</Panel>
```

### Files to Create (v0.3.4e)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/Views/ContextPreviewPopup.axaml` | Preview popup UI |
| `src/SeniorIntern.Desktop/Views/ContextPreviewPopup.axaml.cs` | Preview popup code-behind |

### Files to Modify (v0.3.4e)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/Views/ChatView.axaml` | Add preview overlay |
| `src/SeniorIntern.Desktop/Themes/Dark.axaml` | Add popup styles |

### Acceptance Criteria (v0.3.4e)
- [ ] Preview shows full content with syntax highlighting
- [ ] Header shows file name, path, and language
- [ ] Footer shows line count and token estimate
- [ ] Close button and Escape key close preview
- [ ] Copy button copies content to clipboard
- [ ] Open in Editor opens file in editor panel
- [ ] Remove button removes context and closes preview

---

## v0.3.4f: Editor Integration

### Objective
Add the ability to attach code selections from the editor to chat context via keyboard shortcuts and toolbar buttons.

### Editor Panel Updates

```csharp
// Add to EditorPanel.axaml.cs

/// <summary>
/// Event raised when user wants to attach the current selection to chat.
/// </summary>
public event EventHandler<SelectionAttachmentEventArgs>? AttachSelectionRequested;

/// <summary>
/// Gets the current selection info for attachment.
/// </summary>
public SelectionInfo? GetCurrentSelection()
{
    if (_viewModel?.ActiveTab == null) return null;

    var selection = Editor.TextArea.Selection;
    if (selection.IsEmpty) return null;

    return new SelectionInfo
    {
        FilePath = _viewModel.ActiveTab.FilePath,
        FileName = _viewModel.ActiveTab.FileName,
        Language = _viewModel.ActiveTab.Language,
        Content = Editor.SelectedText,
        StartLine = selection.StartPosition.Line,
        EndLine = selection.EndPosition.Line,
        StartColumn = selection.StartPosition.Column,
        EndColumn = selection.EndPosition.Column
    };
}

/// <summary>
/// Attaches the current selection to chat context.
/// </summary>
[RelayCommand]
public void AttachSelection()
{
    var selection = GetCurrentSelection();
    if (selection == null)
    {
        // No selection - maybe attach entire file?
        return;
    }

    AttachSelectionRequested?.Invoke(this, new SelectionAttachmentEventArgs(selection));
}

/// <summary>
/// Attaches the entire current file to chat context.
/// </summary>
[RelayCommand]
public void AttachCurrentFile()
{
    if (_viewModel?.ActiveTab == null) return;

    AttachSelectionRequested?.Invoke(this, new SelectionAttachmentEventArgs(new SelectionInfo
    {
        FilePath = _viewModel.ActiveTab.FilePath,
        FileName = _viewModel.ActiveTab.FileName,
        Language = _viewModel.ActiveTab.Language,
        Content = _viewModel.ActiveTab.GetContent(),
        IsFullFile = true
    }));
}

// Handle keyboard shortcut
protected override void OnKeyDown(KeyEventArgs e)
{
    base.OnKeyDown(e);

    // Ctrl+Shift+A: Attach selection
    if (e.KeyModifiers == (KeyModifiers.Control | KeyModifiers.Shift) && e.Key == Key.A)
    {
        AttachSelection();
        e.Handled = true;
    }

    // Ctrl+Shift+F: Attach full file
    if (e.KeyModifiers == (KeyModifiers.Control | KeyModifiers.Shift) && e.Key == Key.F)
    {
        AttachCurrentFile();
        e.Handled = true;
    }
}
```

### SelectionInfo Model

```csharp
namespace SeniorIntern.Desktop.Models;

/// <summary>
/// Information about a code selection for attachment.
/// </summary>
public sealed class SelectionInfo
{
    public string FilePath { get; init; } = string.Empty;
    public string FileName { get; init; } = string.Empty;
    public string? Language { get; init; }
    public string Content { get; init; } = string.Empty;
    public int StartLine { get; init; }
    public int EndLine { get; init; }
    public int StartColumn { get; init; }
    public int EndColumn { get; init; }
    public bool IsFullFile { get; init; }
}

/// <summary>
/// Event args for selection attachment.
/// </summary>
public sealed class SelectionAttachmentEventArgs : EventArgs
{
    public SelectionInfo Selection { get; }

    public SelectionAttachmentEventArgs(SelectionInfo selection)
    {
        Selection = selection;
    }
}
```

### Editor Context Menu Update

```xml
<!-- Add to Editor context menu -->

<Separator />

<MenuItem Header="Attach Selection to Chat"
          Command="{Binding AttachSelectionCommand}"
          InputGesture="Ctrl+Shift+A"
          IsEnabled="{Binding HasSelection}">
    <MenuItem.Icon>
        <PathIcon Data="{StaticResource AttachIcon}" Width="14" Height="14" />
    </MenuItem.Icon>
</MenuItem>

<MenuItem Header="Attach File to Chat"
          Command="{Binding AttachCurrentFileCommand}"
          InputGesture="Ctrl+Shift+F">
    <MenuItem.Icon>
        <PathIcon Data="{StaticResource AttachFileIcon}" Width="14" Height="14" />
    </MenuItem.Icon>
</MenuItem>
```

### Editor Toolbar Button

```xml
<!-- Add to EditorPanel toolbar (if present) -->

<Button Classes="toolbar-button"
        Command="{Binding AttachSelectionCommand}"
        ToolTip.Tip="Attach Selection to Chat (Ctrl+Shift+A)"
        IsEnabled="{Binding HasSelection}">
    <PathIcon Data="{StaticResource AttachIcon}" Width="16" Height="16" />
</Button>
```

### Files to Create (v0.3.4f)

| File | Purpose |
|------|---------|
| `src/SeniorIntern.Desktop/Models/SelectionInfo.cs` | Selection info model |
| `src/SeniorIntern.Desktop/Models/SelectionAttachmentEventArgs.cs` | Event args |

### Files to Modify (v0.3.4f)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/Views/EditorPanel.axaml` | Add context menu items, toolbar button |
| `src/SeniorIntern.Desktop/Views/EditorPanel.axaml.cs` | Add attachment methods, keyboard handling |
| `src/SeniorIntern.Desktop/ViewModels/EditorPanelViewModel.cs` | Add HasSelection property |

### Acceptance Criteria (v0.3.4f)
- [ ] Ctrl+Shift+A attaches current selection
- [ ] Ctrl+Shift+F attaches entire file
- [ ] Context menu shows attach options
- [ ] Attach Selection disabled when no selection
- [ ] Selection info includes line numbers
- [ ] Event raised with correct selection data

---

## v0.3.4g: File Explorer Integration

### Objective
Add "Attach to Chat" option to File Explorer context menu and support drag-drop to chat area.

### File Explorer Context Menu Update

```xml
<!-- Add to FileExplorerView.axaml TreeView.ContextMenu -->

<Separator />

<MenuItem Header="Attach to Chat"
          Command="{Binding AttachToContextCommand}"
          CommandParameter="{Binding SelectedItem}">
    <MenuItem.Icon>
        <PathIcon Data="{StaticResource AttachIcon}" Width="14" Height="14" />
    </MenuItem.Icon>
</MenuItem>
```

### FileExplorerViewModel Updates

```csharp
// Add to FileExplorerViewModel

/// <summary>
/// Event raised when a file should be attached to chat context.
/// </summary>
public event EventHandler<string>? AttachFileRequested;

/// <summary>
/// Attaches the selected file to chat context.
/// </summary>
[RelayCommand]
private void AttachToContext(FileTreeItemViewModel? item)
{
    if (item == null || item.IsDirectory) return;

    AttachFileRequested?.Invoke(this, item.Path);
}

/// <summary>
/// Attaches multiple selected files to chat context.
/// </summary>
[RelayCommand]
private void AttachSelectedToContext()
{
    var selectedFiles = GetSelectedFiles();
    foreach (var filePath in selectedFiles)
    {
        AttachFileRequested?.Invoke(this, filePath);
    }
}

private IEnumerable<string> GetSelectedFiles()
{
    // Return paths of all selected file items (not directories)
    return SelectedItems
        .Where(item => !item.IsDirectory)
        .Select(item => item.Path);
}
```

### Drag-Drop Support

```csharp
// Add to ChatView.axaml.cs

private void InitializeDragDrop()
{
    // Enable drop on the context bar / input area
    AddHandler(DragDrop.DropEvent, OnDrop);
    AddHandler(DragDrop.DragOverEvent, OnDragOver);
}

private void OnDragOver(object? sender, DragEventArgs e)
{
    // Check if files are being dragged
    if (e.Data.Contains(DataFormats.FileNames))
    {
        e.DragEffects = DragDropEffects.Link;
    }
    else
    {
        e.DragEffects = DragDropEffects.None;
    }
}

private async void OnDrop(object? sender, DragEventArgs e)
{
    if (!e.Data.Contains(DataFormats.FileNames)) return;

    var viewModel = DataContext as ChatViewModel;
    if (viewModel == null) return;

    var files = e.Data.GetFileNames()?.ToList();
    if (files == null || files.Count == 0) return;

    foreach (var file in files)
    {
        // Only attach files, not directories
        if (File.Exists(file))
        {
            await viewModel.AttachFileAsync(file);
        }
    }
}

// Also add to ChatContextBar for drop-on-bar functionality
```

### Drag-Drop Visual Feedback

```xml
<!-- Add to ChatView.axaml -->

<!-- Drop Zone Indicator -->
<Border x:Name="DropZoneIndicator"
        Grid.Row="2"
        Background="#402196F3"
        BorderBrush="#2196F3"
        BorderThickness="2"
        CornerRadius="8"
        IsVisible="False"
        IsHitTestVisible="False"
        ZIndex="50">
    <StackPanel HorizontalAlignment="Center"
                VerticalAlignment="Center"
                Spacing="8">
        <PathIcon Data="{StaticResource AttachIcon}"
                  Width="32" Height="32"
                  Foreground="#2196F3" />
        <TextBlock Text="Drop files to attach"
                   FontSize="14"
                   Foreground="#2196F3" />
    </StackPanel>
</Border>
```

### Files to Create (v0.3.4g)

None - modifications only.

### Files to Modify (v0.3.4g)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Desktop/Views/FileExplorerView.axaml` | Add context menu item |
| `src/SeniorIntern.Desktop/ViewModels/FileExplorerViewModel.cs` | Add AttachToContext command |
| `src/SeniorIntern.Desktop/Views/ChatView.axaml` | Add drop zone indicator |
| `src/SeniorIntern.Desktop/Views/ChatView.axaml.cs` | Add drag-drop handlers |

### Acceptance Criteria (v0.3.4g)
- [ ] Right-click file shows "Attach to Chat" option
- [ ] Attach to Chat works for single file
- [ ] Directories cannot be attached (option disabled)
- [ ] Drag file from explorer to chat attaches it
- [ ] Drop zone visual feedback during drag
- [ ] Multiple files can be dropped at once

---

## v0.3.4h: Message History Integration

### Objective
Store attached contexts with messages in conversation history and display them when viewing past messages.

### ChatViewModel Updates for Context

```csharp
// Add to ChatViewModel

[ObservableProperty]
private ObservableCollection<FileContextViewModel> _attachedContexts = new();

[ObservableProperty]
private FileContextViewModel? _selectedPreviewContext;

[ObservableProperty]
private bool _isPreviewOpen;

[ObservableProperty]
private int _totalContextTokens;

[ObservableProperty]
private int _maxContextTokens = 8000;

public bool HasAttachedContexts => AttachedContexts.Count > 0;
public bool HasMultipleContexts => AttachedContexts.Count > 1;
public bool IsNearTokenLimit => TotalContextTokens > MaxContextTokens * 0.8;
public bool IsOverTokenLimit => TotalContextTokens > MaxContextTokens;
public bool CanSendMessage => !string.IsNullOrWhiteSpace(UserInput) && !IsOverTokenLimit;

private readonly ITokenEstimationService _tokenEstimationService;
private readonly IContextFormatter _contextFormatter;
private readonly IFileSystemService _fileSystemService;

partial void OnAttachedContextsChanged(ObservableCollection<FileContextViewModel> value)
{
    UpdateTotalTokens();
    OnPropertyChanged(nameof(HasAttachedContexts));
    OnPropertyChanged(nameof(HasMultipleContexts));
    OnPropertyChanged(nameof(CanSendMessage));
}

private void UpdateTotalTokens()
{
    TotalContextTokens = AttachedContexts.Sum(c => c.EstimatedTokens);
    OnPropertyChanged(nameof(IsNearTokenLimit));
    OnPropertyChanged(nameof(IsOverTokenLimit));
    OnPropertyChanged(nameof(CanSendMessage));
}

[RelayCommand]
public async Task AttachFileAsync(string filePath)
{
    // Validate
    if (!await _fileSystemService.FileExistsAsync(filePath)) return;

    var fileSize = _fileSystemService.GetFileSize(filePath);
    if (fileSize > _settings.ContextLimits.MaxFileSizeBytes)
    {
        // Show error: file too large
        return;
    }

    // Check if already attached
    if (AttachedContexts.Any(c => c.FilePath == filePath))
    {
        // Already attached
        return;
    }

    // Read content
    var content = await _fileSystemService.ReadFileAsync(filePath);
    var tokens = _tokenEstimationService.EstimateTokens(content);

    // Check token limits
    if (tokens > _settings.ContextLimits.MaxTokensPerFile)
    {
        content = _tokenEstimationService.TruncateToTokenLimit(
            content,
            _settings.ContextLimits.MaxTokensPerFile);
        tokens = _settings.ContextLimits.MaxTokensPerFile;
    }

    if (TotalContextTokens + tokens > MaxContextTokens)
    {
        // Would exceed limit - show warning
        return;
    }

    var context = FileContextViewModel.FromFile(filePath, content, tokens);
    AttachedContexts.Add(context);
    UpdateTotalTokens();
}

[RelayCommand]
public void AttachSelection(SelectionInfo selection)
{
    var tokens = _tokenEstimationService.EstimateTokens(selection.Content);

    if (TotalContextTokens + tokens > MaxContextTokens)
    {
        // Would exceed limit
        return;
    }

    var context = selection.IsFullFile
        ? FileContextViewModel.FromFile(selection.FilePath, selection.Content, tokens)
        : FileContextViewModel.FromSelection(
            selection.FilePath,
            selection.Content,
            selection.StartLine,
            selection.EndLine,
            tokens);

    AttachedContexts.Add(context);
    UpdateTotalTokens();
}

[RelayCommand]
public void RemoveContext(FileContextViewModel context)
{
    AttachedContexts.Remove(context);
    UpdateTotalTokens();

    if (SelectedPreviewContext == context)
    {
        HidePreview();
    }
}

[RelayCommand]
public void ClearAllContexts()
{
    AttachedContexts.Clear();
    UpdateTotalTokens();
    HidePreview();
}

[RelayCommand]
public void ShowPreview(FileContextViewModel context)
{
    SelectedPreviewContext = context;
    IsPreviewOpen = true;
}

[RelayCommand]
public void HidePreview()
{
    IsPreviewOpen = false;
    SelectedPreviewContext = null;
}

// Updated Send Message
[RelayCommand]
private async Task SendMessageAsync()
{
    if (!CanSendMessage) return;

    var userInput = UserInput.Trim();
    UserInput = string.Empty;

    // Build context-enhanced prompt
    var contextPrompt = string.Empty;
    var attachedContextsList = AttachedContexts.ToList();

    if (attachedContextsList.Count > 0)
    {
        var fileContexts = attachedContextsList.Select(c => c.ToFileContext()).ToList();
        contextPrompt = _contextFormatter.FormatForPrompt(fileContexts);
    }

    var fullPrompt = string.IsNullOrEmpty(contextPrompt)
        ? userInput
        : contextPrompt + userInput;

    // Create user message with attached contexts
    var userMessage = new ChatMessage
    {
        Role = MessageRole.User,
        Content = userInput,
        AttachedContexts = attachedContextsList.Select(c => c.ToFileContext()).ToList(),
        Timestamp = DateTime.UtcNow
    };

    Messages.Add(new ChatMessageViewModel(userMessage));

    // Clear contexts after sending
    AttachedContexts.Clear();
    UpdateTotalTokens();

    // Send to LLM with full prompt
    IsGenerating = true;
    try
    {
        var response = await _llmService.SendAsync(fullPrompt, CurrentConversation);
        var assistantMessage = new ChatMessage
        {
            Role = MessageRole.Assistant,
            Content = response,
            Timestamp = DateTime.UtcNow
        };
        Messages.Add(new ChatMessageViewModel(assistantMessage));

        // Save to database
        await SaveConversationAsync();
    }
    finally
    {
        IsGenerating = false;
    }
}
```

### ChatMessage Model Update

```csharp
// Update ChatMessage in Core

public sealed class ChatMessage
{
    public Guid Id { get; init; } = Guid.NewGuid();
    public MessageRole Role { get; init; }
    public string Content { get; init; } = string.Empty;
    public DateTime Timestamp { get; init; } = DateTime.UtcNow;

    // v0.3.4: Attached contexts
    public IReadOnlyList<FileContext> AttachedContexts { get; init; } = Array.Empty<FileContext>();
    public bool HasAttachedContexts => AttachedContexts.Count > 0;
}
```

### ChatMessageViewModel Update

```csharp
// Add to ChatMessageViewModel

[ObservableProperty]
private ObservableCollection<FileContextViewModel> _attachedContexts = new();

[ObservableProperty]
private bool _isContextExpanded = false;

public bool HasAttachedContexts => AttachedContexts.Count > 0;
public int AttachedContextCount => AttachedContexts.Count;
public int TotalAttachedTokens => AttachedContexts.Sum(c => c.EstimatedTokens);

public ChatMessageViewModel(ChatMessage message)
{
    // ... existing initialization ...

    // Convert attached contexts
    foreach (var ctx in message.AttachedContexts)
    {
        AttachedContexts.Add(new FileContextViewModel
        {
            Id = ctx.Id,
            FilePath = ctx.FilePath,
            FileName = ctx.FileName,
            Language = ctx.Language,
            Content = ctx.Content,
            EstimatedTokens = ctx.EstimatedTokens,
            LineCount = ctx.LineCount,
            StartLine = ctx.StartLine,
            EndLine = ctx.EndLine,
            AttachmentType = ctx.IsPartialContent
                ? ContextAttachmentType.Selection
                : ContextAttachmentType.File
        });
    }
}

[RelayCommand]
private void ToggleContextExpanded()
{
    IsContextExpanded = !IsContextExpanded;
}
```

### Message UI with Context Display

```xml
<!-- Update message template in ChatView.axaml -->

<DataTemplate x:Key="UserMessageTemplate" x:DataType="vm:ChatMessageViewModel">
    <Border Classes="message user-message" Margin="0,8">
        <StackPanel Spacing="8">
            <!-- Attached Context Summary (collapsed) -->
            <Border Background="{DynamicResource ContextSummaryBackgroundBrush}"
                    CornerRadius="4"
                    Padding="8"
                    IsVisible="{Binding HasAttachedContexts}">
                <Grid ColumnDefinitions="Auto, *, Auto">
                    <PathIcon Grid.Column="0"
                              Data="{StaticResource AttachmentIcon}"
                              Width="12" Height="12"
                              Margin="0,0,6,0" />

                    <TextBlock Grid.Column="1" FontSize="12">
                        <Run Text="{Binding AttachedContextCount}" />
                        <Run Text="file(s) attached •" />
                        <Run Text="~" />
                        <Run Text="{Binding TotalAttachedTokens}" />
                        <Run Text="tokens" />
                    </TextBlock>

                    <Button Grid.Column="2"
                            Classes="link-button"
                            Content="{Binding IsContextExpanded, Converter={StaticResource ExpandCollapseConverter}}"
                            Command="{Binding ToggleContextExpandedCommand}"
                            FontSize="11" />
                </Grid>
            </Border>

            <!-- Expanded Context List -->
            <ItemsControl ItemsSource="{Binding AttachedContexts}"
                          IsVisible="{Binding IsContextExpanded}">
                <ItemsControl.ItemTemplate>
                    <DataTemplate x:DataType="vm:FileContextViewModel">
                        <Border Background="{DynamicResource ContextBlockBackgroundBrush}"
                                CornerRadius="4"
                                Padding="8"
                                Margin="0,4">
                            <StackPanel Spacing="4">
                                <StackPanel Orientation="Horizontal" Spacing="8">
                                    <TextBlock Text="{Binding DisplayLabel}"
                                               FontWeight="SemiBold"
                                               FontSize="12" />
                                    <TextBlock Text="{Binding Language}"
                                               FontSize="11"
                                               Foreground="{DynamicResource TextMutedBrush}" />
                                </StackPanel>
                                <Border Background="{DynamicResource CodeBlockBackgroundBrush}"
                                        CornerRadius="4"
                                        Padding="8">
                                    <TextBlock Text="{Binding PreviewContent}"
                                               FontFamily="Cascadia Code, Consolas"
                                               FontSize="11"
                                               TextWrapping="NoWrap" />
                                </Border>
                            </StackPanel>
                        </Border>
                    </DataTemplate>
                </ItemsControl.ItemTemplate>
            </ItemsControl>

            <!-- Message Content -->
            <TextBlock Text="{Binding Content}"
                       TextWrapping="Wrap" />
        </StackPanel>
    </Border>
</DataTemplate>
```

### Files to Create (v0.3.4h)

None - modifications only.

### Files to Modify (v0.3.4h)

| File | Changes |
|------|---------|
| `src/SeniorIntern.Core/Models/ChatMessage.cs` | Add AttachedContexts property |
| `src/SeniorIntern.Desktop/ViewModels/ChatViewModel.cs` | Add context management |
| `src/SeniorIntern.Desktop/ViewModels/ChatMessageViewModel.cs` | Add context display |
| `src/SeniorIntern.Desktop/Views/ChatView.axaml` | Update message templates |
| `src/SeniorIntern.Data/Entities/MessageEntity.cs` | Add context storage |
| `src/SeniorIntern.Data/Repositories/ConversationRepository.cs` | Save/load contexts |

### Acceptance Criteria (v0.3.4h)
- [ ] Attached contexts sent with message
- [ ] Contexts cleared after sending
- [ ] Past messages show context summary
- [ ] Can expand to see context details
- [ ] Contexts persisted to database
- [ ] Contexts restored when loading conversation

---

## Complete File Summary

### Files to Create

| File | Part |
|------|------|
| `src/SeniorIntern.Core/Interfaces/ITokenEstimationService.cs` | v0.3.4a |
| `src/SeniorIntern.Services/TokenEstimationService.cs` | v0.3.4a |
| `src/SeniorIntern.Core/Models/ContextLimitsConfig.cs` | v0.3.4a |
| `src/SeniorIntern.Core/Models/TokenUsageBreakdown.cs` | v0.3.4a |
| `src/SeniorIntern.Core/Interfaces/IContextFormatter.cs` | v0.3.4b |
| `src/SeniorIntern.Services/ContextFormatter.cs` | v0.3.4b |
| `src/SeniorIntern.Core/Models/ContextPromptTemplates.cs` | v0.3.4b |
| `src/SeniorIntern.Desktop/ViewModels/FileContextViewModel.cs` | v0.3.4c |
| `src/SeniorIntern.Desktop/Views/ChatContextBar.axaml` | v0.3.4d |
| `src/SeniorIntern.Desktop/Views/ChatContextBar.axaml.cs` | v0.3.4d |
| `src/SeniorIntern.Desktop/Converters/TokenCountConverter.cs` | v0.3.4d |
| `src/SeniorIntern.Desktop/Views/ContextPreviewPopup.axaml` | v0.3.4e |
| `src/SeniorIntern.Desktop/Views/ContextPreviewPopup.axaml.cs` | v0.3.4e |
| `src/SeniorIntern.Desktop/Models/SelectionInfo.cs` | v0.3.4f |
| `src/SeniorIntern.Desktop/Models/SelectionAttachmentEventArgs.cs` | v0.3.4f |

**Total: 15 files to create**

### Files to Modify

| File | Part | Changes |
|------|------|---------|
| `src/SeniorIntern.Core/Models/AppSettings.cs` | v0.3.4a | Add ContextLimitsConfig |
| `src/SeniorIntern.Desktop/Themes/Dark.axaml` | v0.3.4d | Add context bar styles |
| `src/SeniorIntern.Desktop/Assets/Icons.axaml` | v0.3.4d | Add AttachmentIcon |
| `src/SeniorIntern.Desktop/Views/ChatView.axaml` | v0.3.4e | Add preview overlay, message templates |
| `src/SeniorIntern.Desktop/Views/EditorPanel.axaml` | v0.3.4f | Add context menu, toolbar |
| `src/SeniorIntern.Desktop/Views/EditorPanel.axaml.cs` | v0.3.4f | Add attachment methods |
| `src/SeniorIntern.Desktop/ViewModels/EditorPanelViewModel.cs` | v0.3.4f | Add HasSelection |
| `src/SeniorIntern.Desktop/Views/FileExplorerView.axaml` | v0.3.4g | Add context menu item |
| `src/SeniorIntern.Desktop/ViewModels/FileExplorerViewModel.cs` | v0.3.4g | Add AttachToContext |
| `src/SeniorIntern.Desktop/Views/ChatView.axaml.cs` | v0.3.4g | Add drag-drop handlers |
| `src/SeniorIntern.Core/Models/ChatMessage.cs` | v0.3.4h | Add AttachedContexts |
| `src/SeniorIntern.Desktop/ViewModels/ChatViewModel.cs` | v0.3.4h | Add context management |
| `src/SeniorIntern.Desktop/ViewModels/ChatMessageViewModel.cs` | v0.3.4h | Add context display |
| `src/SeniorIntern.Data/Entities/MessageEntity.cs` | v0.3.4h | Add context storage |
| `src/SeniorIntern.Data/Repositories/ConversationRepository.cs` | v0.3.4h | Save/load contexts |

**Total: 15 files to modify**

---

## Testing Strategy

### Unit Tests

```csharp
// TokenEstimationServiceTests.cs
public class TokenEstimationServiceTests
{
    private readonly TokenEstimationService _service = new();

    [Fact]
    public void EstimateTokens_EmptyString_ReturnsZero()
    {
        Assert.Equal(0, _service.EstimateTokens(""));
    }

    [Fact]
    public void EstimateTokens_SimpleCode_ReturnsReasonableEstimate()
    {
        var code = "public class Foo { }";
        var tokens = _service.EstimateTokens(code);

        // Should be roughly 5-10 tokens
        Assert.InRange(tokens, 3, 15);
    }

    [Fact]
    public void EstimateTokens_LargeFile_ScalesLinearly()
    {
        var smallCode = "int x = 1;";
        var largeCode = string.Join("\n", Enumerable.Repeat(smallCode, 100));

        var smallTokens = _service.EstimateTokens(smallCode);
        var largeTokens = _service.EstimateTokens(largeCode);

        // Large should be roughly 100x small (with some overhead for newlines)
        Assert.InRange(largeTokens, smallTokens * 80, smallTokens * 120);
    }

    [Fact]
    public void TruncateToTokenLimit_ShortContent_ReturnsUnchanged()
    {
        var content = "short";
        var result = _service.TruncateToTokenLimit(content, 100);

        Assert.Equal(content, result);
    }

    [Fact]
    public void TruncateToTokenLimit_LongContent_Truncates()
    {
        var content = string.Join("\n", Enumerable.Range(1, 1000).Select(i => $"Line {i}"));
        var result = _service.TruncateToTokenLimit(content, 100);

        Assert.True(result.Length < content.Length);
        Assert.Contains("truncated", result);
    }

    [Fact]
    public void WouldExceedLimit_UnderLimit_ReturnsFalse()
    {
        Assert.False(_service.WouldExceedLimit(100, "small"));
    }

    [Fact]
    public void WouldExceedLimit_OverLimit_ReturnsTrue()
    {
        var largeContent = new string('x', 100000);
        Assert.True(_service.WouldExceedLimit(7000, largeContent));
    }
}

// ContextFormatterTests.cs
public class ContextFormatterTests
{
    private readonly ContextFormatter _formatter = new();

    [Fact]
    public void FormatForPrompt_EmptyList_ReturnsEmpty()
    {
        var result = _formatter.FormatForPrompt(Array.Empty<FileContext>());
        Assert.Empty(result);
    }

    [Fact]
    public void FormatForPrompt_SingleFile_IncludesFilename()
    {
        var contexts = new[]
        {
            new FileContext
            {
                FilePath = "/path/to/test.cs",
                Content = "public class Test { }",
                Language = "csharp"
            }
        };

        var result = _formatter.FormatForPrompt(contexts);

        Assert.Contains("test.cs", result);
        Assert.Contains("csharp", result);
        Assert.Contains("public class Test", result);
        Assert.Contains("```", result);
    }

    [Fact]
    public void FormatForPrompt_Selection_IncludesLineNumbers()
    {
        var contexts = new[]
        {
            new FileContext
            {
                FilePath = "/path/to/test.cs",
                Content = "var x = 1;",
                Language = "csharp",
                StartLine = 10,
                EndLine = 15
            }
        };

        var result = _formatter.FormatForPrompt(contexts);

        Assert.Contains("10", result);
        Assert.Contains("15", result);
    }

    [Fact]
    public void FormatCodeBlock_IncludesLanguage()
    {
        var result = _formatter.FormatCodeBlock("code", "csharp");

        Assert.StartsWith("```csharp", result);
        Assert.Contains("code", result);
        Assert.EndsWith("```\n", result);
    }
}

// FileContextViewModelTests.cs
public class FileContextViewModelTests
{
    [Fact]
    public void FromFile_SetsCorrectProperties()
    {
        var vm = FileContextViewModel.FromFile("/path/test.cs", "content", 100);

        Assert.Equal("/path/test.cs", vm.FilePath);
        Assert.Equal("test.cs", vm.FileName);
        Assert.Equal("csharp", vm.Language);
        Assert.Equal("content", vm.Content);
        Assert.Equal(100, vm.EstimatedTokens);
        Assert.Equal(ContextAttachmentType.File, vm.AttachmentType);
    }

    [Fact]
    public void FromSelection_SetsLineRange()
    {
        var vm = FileContextViewModel.FromSelection("/path/test.cs", "content", 10, 20, 50);

        Assert.Equal(10, vm.StartLine);
        Assert.Equal(20, vm.EndLine);
        Assert.True(vm.IsPartialContent);
        Assert.Equal(ContextAttachmentType.Selection, vm.AttachmentType);
    }

    [Fact]
    public void DisplayLabel_FileShowsFilename()
    {
        var vm = FileContextViewModel.FromFile("/path/test.cs", "content", 100);
        Assert.Equal("test.cs", vm.DisplayLabel);
    }

    [Fact]
    public void DisplayLabel_SelectionShowsLineRange()
    {
        var vm = FileContextViewModel.FromSelection("/path/test.cs", "content", 10, 20, 50);
        Assert.Equal("test.cs:10-20", vm.DisplayLabel);
    }

    [Fact]
    public void PreviewContent_TruncatesLongContent()
    {
        var longContent = string.Join("\n", Enumerable.Range(1, 100).Select(i => $"Line {i}"));
        var vm = FileContextViewModel.FromFile("/path/test.cs", longContent, 500);

        Assert.True(vm.PreviewContent.Length < longContent.Length);
        Assert.Contains("more lines", vm.PreviewContent);
    }
}
```

### Integration Tests

```csharp
// ContextAttachmentIntegrationTests.cs
public class ContextAttachmentIntegrationTests
{
    [Fact]
    public async Task AttachFile_AddsToContextList()
    {
        // Setup with mocked services
        var viewModel = CreateChatViewModel();

        await viewModel.AttachFileAsync("/path/test.cs");

        Assert.Single(viewModel.AttachedContexts);
        Assert.Equal("test.cs", viewModel.AttachedContexts[0].FileName);
    }

    [Fact]
    public async Task AttachFile_UpdatesTokenCount()
    {
        var viewModel = CreateChatViewModel();

        await viewModel.AttachFileAsync("/path/test.cs");

        Assert.True(viewModel.TotalContextTokens > 0);
    }

    [Fact]
    public async Task SendMessage_IncludesContextInPrompt()
    {
        // Test that the formatted context is included when sending
    }

    [Fact]
    public async Task SendMessage_ClearsAttachedContexts()
    {
        var viewModel = CreateChatViewModel();
        await viewModel.AttachFileAsync("/path/test.cs");

        viewModel.UserInput = "Test message";
        await viewModel.SendMessageCommand.ExecuteAsync(null);

        Assert.Empty(viewModel.AttachedContexts);
    }
}
```

### Manual Testing Checklist

- [ ] Right-click file in explorer → "Attach to Chat" adds context pill
- [ ] Select code in editor → Ctrl+Shift+A adds selection as context
- [ ] Ctrl+Shift+F attaches entire current file
- [ ] Context pill shows correct icon and label
- [ ] Token count updates as contexts added/removed
- [ ] Close button (X) removes individual context
- [ ] "Clear All" removes all contexts
- [ ] Clicking pill opens preview popup
- [ ] Preview shows syntax highlighting
- [ ] Preview "Copy" copies content
- [ ] Preview "Open in Editor" opens file
- [ ] Warning shows at 80% of token limit
- [ ] Error shows when over limit
- [ ] Cannot send message when over limit
- [ ] Drag file from explorer to chat attaches it
- [ ] Drop zone visual appears during drag
- [ ] Message shows context summary after sending
- [ ] Can expand context in sent message
- [ ] Loading conversation restores context display

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Token estimation inaccuracy | Medium | Low | Conservative estimates, user can adjust |
| Large file performance | Medium | Medium | Size limits, lazy loading, truncation |
| Context limit confusion | Medium | Low | Clear warnings, token display |
| Prompt too long for model | Low | High | Hard limits, user feedback |
| Drag-drop platform issues | Medium | Low | Test on all platforms, fallback to menu |
| Context persistence bloat | Low | Medium | Store hashes, not full content in DB |

---

## Performance Considerations

1. **Token Estimation**: Use fast character-based for UI, word-based for final count
2. **Large Files**: Truncate during attachment, not on send
3. **Preview Rendering**: Lazy-load syntax highlighting
4. **Database Storage**: Store content hash, not full content for history
5. **Drag-Drop**: Debounce drop events, process files sequentially

---

## Keyboard Shortcuts Summary

| Shortcut | Action | Context |
|----------|--------|---------|
| Ctrl+Shift+A | Attach selection | Editor |
| Ctrl+Shift+F | Attach current file | Editor |
| Escape | Close preview popup | Preview |
| Middle-click | Remove context | Context pill |

---

## References

- [Avalonia Drag and Drop](https://docs.avaloniaui.net/docs/input/drag-and-drop)
- [Token Counting Best Practices](https://platform.openai.com/tokenizer)
- [Context Window Management](https://docs.anthropic.com/claude/docs/context-windows)
- [LLaMA Token Limits](https://huggingface.co/docs/transformers/model_doc/llama)
