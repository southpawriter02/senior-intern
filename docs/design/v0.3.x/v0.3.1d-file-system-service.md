# Design Specification: The Senior Intern v0.3.1d "File System Service"

## Executive Summary

This document provides a detailed implementation specification for v0.3.1d, which implements the file system service for file/directory operations, file watching with debouncing, binary file detection, and .gitignore pattern support. This service provides a workspace-aware abstraction over System.IO operations.

### v0.3.1d Scope (from v0.3.1 Design Document)

- Create `IFileSystemService` interface
- Implement directory operations (list, create, delete)
- Implement file operations (read, write, create, delete, rename, copy, move)
- Implement file watching with debounced callbacks
- Implement binary vs text file detection
- Implement .gitignore pattern matching

### Key Deliverables

| Deliverable | Description |
|-------------|-------------|
| IFileSystemService | Interface for file system operations |
| FileSystemService | Implementation with all operations |
| FileSystemChangeEvent | Event data for file watcher |
| FileSystemChangeType | Enum: Created, Modified, Deleted, Renamed |
| .gitignore Support | Pattern loading and matching |

---

## Feature Overview

```
┌──────────────────────────────────────────────────────────────────┐
│                     v0.3.1d Feature Tree                          │
├──────────────────────────────────────────────────────────────────┤
│                                                                   │
│  IFileSystemService                                               │
│  ├── Directory Operations                                         │
│  │   ├── GetDirectoryContentsAsync(path, includeHidden)          │
│  │   ├── GetItemInfoAsync(path) → FileSystemItem                 │
│  │   ├── CreateDirectoryAsync(path)                              │
│  │   └── DeleteDirectoryAsync(path) - recursive                  │
│  │                                                                │
│  ├── File Operations                                              │
│  │   ├── ReadFileAsync(path) → string                            │
│  │   ├── ReadFileBytesAsync(path) → byte[]                       │
│  │   ├── WriteFileAsync(path, content)                           │
│  │   ├── CreateFileAsync(path)                                   │
│  │   ├── DeleteFileAsync(path)                                   │
│  │   ├── RenameAsync(path, newName)                              │
│  │   ├── CopyFileAsync(source, dest, overwrite)                  │
│  │   └── MoveAsync(source, dest)                                 │
│  │                                                                │
│  ├── Existence Checks                                             │
│  │   ├── FileExistsAsync(path)                                   │
│  │   └── DirectoryExistsAsync(path)                              │
│  │                                                                │
│  ├── File Watching                                                │
│  │   └── WatchDirectory(path, onChange, includeSubdirs)          │
│  │       ├── Returns IDisposable to stop watching                │
│  │       ├── Debounces events (200ms window)                     │
│  │       └── Batches rapid changes to same path                  │
│  │                                                                │
│  ├── Utilities                                                    │
│  │   ├── GetRelativePath(fullPath, basePath)                     │
│  │   ├── IsTextFile(path) - binary detection                     │
│  │   ├── GetFileSize(path)                                       │
│  │   └── GetLineCountAsync(path)                                 │
│  │                                                                │
│  └── Ignore Patterns                                              │
│      ├── ShouldIgnore(path, basePath, patterns)                  │
│      └── LoadGitIgnorePatternsAsync(workspacePath)               │
│                                                                   │
│  FileSystemChangeEvent                                            │
│  ├── Path (string) - absolute path that changed                  │
│  ├── OldPath (string?) - for rename events                       │
│  ├── ChangeType (FileSystemChangeType)                           │
│  ├── Timestamp (DateTime)                                         │
│  └── IsDirectory (bool)                                           │
│                                                                   │
│  FileSystemChangeType (Enum)                                      │
│  ├── Created                                                      │
│  ├── Modified                                                     │
│  ├── Deleted                                                      │
│  └── Renamed                                                      │
│                                                                   │
└──────────────────────────────────────────────────────────────────┘
```

---

## Architecture Diagrams

### File Watching with Debounce

```
┌─────────────────────────────────────────────────────────────────┐
│                File Watcher Debounce Flow                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  FileSystemWatcher Events (rapid fire)                           │
│  ┌──────────────────────────────────────────────────────────┐    │
│  │ t=0ms   Changed: /project/src/file.cs                     │    │
│  │ t=5ms   Changed: /project/src/file.cs  (same file)        │    │
│  │ t=10ms  Changed: /project/src/file.cs  (same file)        │    │
│  │ t=50ms  Created: /project/src/new.cs                      │    │
│  └───────────────────────────┬──────────────────────────────┘    │
│                              │                                   │
│                              ▼                                   │
│  Pending Events Dictionary (keyed by path)                       │
│  ┌──────────────────────────────────────────────────────────┐    │
│  │ "/project/src/file.cs" → Modified (t=10ms, latest)        │    │
│  │ "/project/src/new.cs"  → Created (t=50ms)                 │    │
│  └───────────────────────────┬──────────────────────────────┘    │
│                              │                                   │
│                              │ Debounce timer expires (200ms)    │
│                              ▼                                   │
│  Callback invoked with batched events                            │
│  ┌──────────────────────────────────────────────────────────┐    │
│  │ onChange(Modified: /project/src/file.cs)                  │    │
│  │ onChange(Created: /project/src/new.cs)                    │    │
│  └──────────────────────────────────────────────────────────┘    │
│                                                                  │
│  Benefits:                                                       │
│  • Prevents callback spam during rapid saves                     │
│  • Last event wins for same path                                 │
│  • Reduces UI refresh overhead                                   │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Binary File Detection

```
┌─────────────────────────────────────────────────────────────────┐
│                  Binary File Detection Flow                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  IsTextFile("/path/to/file.xyz")                                 │
│              │                                                   │
│              ▼                                                   │
│  ┌──────────────────────────────────────────────────────────┐    │
│  │ 1. Check extension against TextExtensions set             │    │
│  │    → .txt, .cs, .py, .json, etc.                          │    │
│  │    If match → return true                                 │    │
│  └───────────────────────────┬──────────────────────────────┘    │
│                              │ Extension not recognized         │
│                              ▼                                   │
│  ┌──────────────────────────────────────────────────────────┐    │
│  │ 2. Read first 8 bytes, check binary signatures            │    │
│  │                                                           │    │
│  │    PNG:  89 50 4E 47                                      │    │
│  │    JPEG: FF D8 FF                                         │    │
│  │    GIF:  47 49 46                                         │    │
│  │    PDF:  25 50 44 46                                      │    │
│  │    ZIP:  50 4B 03 04                                      │    │
│  │    ELF:  7F 45 4C 46                                      │    │
│  │    EXE:  4D 5A                                            │    │
│  │                                                           │    │
│  │    If signature matches → return false (binary)           │    │
│  └───────────────────────────┬──────────────────────────────┘    │
│                              │ No signature match               │
│                              ▼                                   │
│  ┌──────────────────────────────────────────────────────────┐    │
│  │ 3. Scan first 8KB for null bytes (0x00)                   │    │
│  │    If null bytes found → return false (binary)            │    │
│  │    Otherwise → return true (text)                         │    │
│  └──────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### .gitignore Pattern Matching

```
┌─────────────────────────────────────────────────────────────────┐
│               .gitignore Pattern Matching Flow                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ShouldIgnore("/project/node_modules/pkg/", "/project", patterns)│
│              │                                                   │
│              ▼                                                   │
│  ┌──────────────────────────────────────────────────────────┐    │
│  │ 1. Convert to relative path: "node_modules/pkg/"          │    │
│  │ 2. Normalize separators to /                              │    │
│  │ 3. Append / if directory                                  │    │
│  └───────────────────────────┬──────────────────────────────┘    │
│                              │                                   │
│              ▼                                                   │
│  ┌──────────────────────────────────────────────────────────┐    │
│  │ For each pattern in ignorePatterns:                       │    │
│  │                                                           │    │
│  │   Pattern: "node_modules/"                                │    │
│  │   ↓                                                       │    │
│  │   Convert to regex: ^(.*/)?node_modules/$                 │    │
│  │   ↓                                                       │    │
│  │   Match against "node_modules/pkg/" → true                │    │
│  └───────────────────────────┬──────────────────────────────┘    │
│                              │                                   │
│                              ▼                                   │
│  Pattern Conversions:                                            │
│  ┌──────────────────────────────────────────────────────────┐    │
│  │ *        → [^/]*     (any chars except /)                 │    │
│  │ **       → .*        (any chars including /)              │    │
│  │ ?        → [^/]      (single char)                        │    │
│  │ /pattern → ^pattern  (anchored to root)                   │    │
│  │ pattern/ → pattern/$ (directory only)                     │    │
│  │ !pattern → negation  (un-ignore)                          │    │
│  └──────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## Directory Structure

```
src/SeniorIntern.Core/
└── Interfaces/
    └── IFileSystemService.cs                         (NEW)

src/SeniorIntern.Services/
└── FileSystemService.cs                              (NEW)
```

---

## Implementation Details

### Task 1: Create IFileSystemService Interface

**File:** `src/SeniorIntern.Core/Interfaces/IFileSystemService.cs`

```csharp
namespace SeniorIntern.Core.Interfaces;

using SeniorIntern.Core.Models;

/// <summary>
/// Provides file system operations with workspace-aware features.
/// </summary>
public interface IFileSystemService
{
    #region Directory Operations

    /// <summary>
    /// Gets the contents of a directory, sorted by type (folders first) then name.
    /// </summary>
    Task<IReadOnlyList<FileSystemItem>> GetDirectoryContentsAsync(
        string path,
        bool includeHidden = false,
        CancellationToken cancellationToken = default);

    /// <summary>Gets information about a specific file or directory.</summary>
    Task<FileSystemItem> GetItemInfoAsync(
        string path,
        CancellationToken cancellationToken = default);

    /// <summary>Creates a new directory.</summary>
    Task<FileSystemItem> CreateDirectoryAsync(
        string path,
        CancellationToken cancellationToken = default);

    /// <summary>Deletes a directory and all its contents recursively.</summary>
    Task DeleteDirectoryAsync(
        string path,
        CancellationToken cancellationToken = default);

    #endregion

    #region File Operations

    /// <summary>Reads a file's content as text.</summary>
    Task<string> ReadFileAsync(
        string path,
        CancellationToken cancellationToken = default);

    /// <summary>Reads a file's content as bytes.</summary>
    Task<byte[]> ReadFileBytesAsync(
        string path,
        CancellationToken cancellationToken = default);

    /// <summary>Writes text content to a file (creates directories if needed).</summary>
    Task WriteFileAsync(
        string path,
        string content,
        CancellationToken cancellationToken = default);

    /// <summary>Creates a new empty file.</summary>
    Task<FileSystemItem> CreateFileAsync(
        string path,
        CancellationToken cancellationToken = default);

    /// <summary>Deletes a file.</summary>
    Task DeleteFileAsync(
        string path,
        CancellationToken cancellationToken = default);

    /// <summary>Renames a file or directory.</summary>
    Task<FileSystemItem> RenameAsync(
        string path,
        string newName,
        CancellationToken cancellationToken = default);

    /// <summary>Copies a file to a new location.</summary>
    Task<FileSystemItem> CopyFileAsync(
        string sourcePath,
        string destinationPath,
        bool overwrite = false,
        CancellationToken cancellationToken = default);

    /// <summary>Moves a file or directory to a new location.</summary>
    Task<FileSystemItem> MoveAsync(
        string sourcePath,
        string destinationPath,
        CancellationToken cancellationToken = default);

    #endregion

    #region Existence Checks

    /// <summary>Checks if a file exists.</summary>
    Task<bool> FileExistsAsync(string path);

    /// <summary>Checks if a directory exists.</summary>
    Task<bool> DirectoryExistsAsync(string path);

    #endregion

    #region File Watching

    /// <summary>
    /// Starts watching a directory for changes with debounced callbacks.
    /// </summary>
    /// <param name="path">Absolute path to watch.</param>
    /// <param name="onChange">Callback invoked when changes occur.</param>
    /// <param name="includeSubdirectories">Whether to watch subdirectories.</param>
    /// <returns>Disposable to stop watching.</returns>
    IDisposable WatchDirectory(
        string path,
        Action<FileSystemChangeEvent> onChange,
        bool includeSubdirectories = true);

    #endregion

    #region Utilities

    /// <summary>Gets the relative path from a base path to a full path.</summary>
    string GetRelativePath(string fullPath, string basePath);

    /// <summary>Determines if a file is likely a text file (vs binary).</summary>
    bool IsTextFile(string path);

    /// <summary>Gets the size of a file in bytes.</summary>
    long GetFileSize(string path);

    /// <summary>Gets the line count of a text file.</summary>
    Task<int> GetLineCountAsync(string path, CancellationToken cancellationToken = default);

    #endregion

    #region Ignore Patterns

    /// <summary>
    /// Determines if a path should be ignored based on gitignore-style patterns.
    /// </summary>
    bool ShouldIgnore(string path, string basePath, IReadOnlyList<string> ignorePatterns);

    /// <summary>Loads .gitignore patterns from a workspace plus common defaults.</summary>
    Task<IReadOnlyList<string>> LoadGitIgnorePatternsAsync(
        string workspacePath,
        CancellationToken cancellationToken = default);

    #endregion
}
```

---

### Task 2: Create FileSystemChangeEvent and Enum

**File:** `src/SeniorIntern.Core/Interfaces/IFileSystemService.cs` (same file)

```csharp
/// <summary>Event data for file system change notifications.</summary>
public sealed class FileSystemChangeEvent
{
    /// <summary>Absolute path that changed.</summary>
    public required string Path { get; init; }

    /// <summary>Old path (for rename events only).</summary>
    public string? OldPath { get; init; }

    /// <summary>Type of change.</summary>
    public required FileSystemChangeType ChangeType { get; init; }

    /// <summary>When the change occurred.</summary>
    public DateTime Timestamp { get; init; } = DateTime.UtcNow;

    /// <summary>Whether the path is a directory.</summary>
    public bool IsDirectory { get; init; }
}

/// <summary>Type of file system change.</summary>
public enum FileSystemChangeType
{
    /// <summary>File or directory was created.</summary>
    Created,

    /// <summary>File content was modified.</summary>
    Modified,

    /// <summary>File or directory was deleted.</summary>
    Deleted,

    /// <summary>File or directory was renamed.</summary>
    Renamed
}
```

---

### Task 3: Create FileSystemService Implementation

**File:** `src/SeniorIntern.Services/FileSystemService.cs`

```csharp
namespace SeniorIntern.Services;

using Microsoft.Extensions.Logging;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using System.Text;
using System.Text.RegularExpressions;

public sealed class FileSystemService : IFileSystemService
{
    private readonly ILogger<FileSystemService> _logger;

    // Binary file signatures for detection
    private static readonly byte[][] BinarySignatures =
    [
        [0x89, 0x50, 0x4E, 0x47], // PNG
        [0xFF, 0xD8, 0xFF],       // JPEG
        [0x47, 0x49, 0x46],       // GIF
        [0x25, 0x50, 0x44, 0x46], // PDF
        [0x50, 0x4B, 0x03, 0x04], // ZIP/DOCX/XLSX
        [0x7F, 0x45, 0x4C, 0x46], // ELF
        [0x4D, 0x5A],             // Windows EXE/DLL
    ];

    // Extensions that are always considered text
    private static readonly HashSet<string> TextExtensions = new(StringComparer.OrdinalIgnoreCase)
    {
        ".txt", ".md", ".cs", ".js", ".ts", ".py", ".rb", ".go", ".rs",
        ".java", ".kt", ".swift", ".c", ".h", ".cpp", ".hpp", ".json",
        ".xml", ".html", ".css", ".scss", ".yaml", ".yml", ".toml",
        ".ini", ".cfg", ".conf", ".sh", ".bash", ".ps1", ".bat", ".sql",
        ".graphql", ".proto", ".dockerfile", ".gitignore", ".env"
    };

    // Default patterns to always ignore
    private static readonly string[] DefaultIgnorePatterns =
    [
        ".git/",
        ".vs/",
        ".idea/",
        "node_modules/",
        "bin/",
        "obj/",
        "*.user",
        "*.suo",
        ".DS_Store",
        "Thumbs.db"
    ];

    public FileSystemService(ILogger<FileSystemService> logger)
    {
        _logger = logger;
    }

    #region Directory Operations

    public async Task<IReadOnlyList<FileSystemItem>> GetDirectoryContentsAsync(
        string path,
        bool includeHidden = false,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(path);

        if (!Directory.Exists(path))
            throw new DirectoryNotFoundException($"Directory not found: {path}");

        return await Task.Run(() =>
        {
            var items = new List<FileSystemItem>();
            var dirInfo = new DirectoryInfo(path);

            // Get directories
            foreach (var dir in dirInfo.EnumerateDirectories())
            {
                cancellationToken.ThrowIfCancellationRequested();
                if (!includeHidden && IsHidden(dir)) continue;
                items.Add(CreateFileSystemItem(dir));
            }

            // Get files
            foreach (var file in dirInfo.EnumerateFiles())
            {
                cancellationToken.ThrowIfCancellationRequested();
                if (!includeHidden && IsHidden(file)) continue;
                items.Add(CreateFileSystemItem(file));
            }

            // Sort: directories first, then alphabetically
            return items
                .OrderByDescending(i => i.IsDirectory)
                .ThenBy(i => i.Name, StringComparer.OrdinalIgnoreCase)
                .ToList();
        }, cancellationToken);
    }

    // ... additional implementations as shown in parent doc ...

    #endregion

    #region File Watching

    public IDisposable WatchDirectory(
        string path,
        Action<FileSystemChangeEvent> onChange,
        bool includeSubdirectories = true)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(path);
        ArgumentNullException.ThrowIfNull(onChange);

        var watcher = new FileSystemWatcher(path)
        {
            IncludeSubdirectories = includeSubdirectories,
            NotifyFilter = NotifyFilters.FileName
                         | NotifyFilters.DirectoryName
                         | NotifyFilters.LastWrite
                         | NotifyFilters.Size
        };

        // Debounce timer to batch rapid changes (200ms window)
        var debounceTimer = new System.Timers.Timer(200) { AutoReset = false };
        var pendingEvents = new Dictionary<string, FileSystemChangeEvent>();
        var lockObj = new object();

        debounceTimer.Elapsed += (s, e) =>
        {
            List<FileSystemChangeEvent> events;
            lock (lockObj)
            {
                events = pendingEvents.Values.ToList();
                pendingEvents.Clear();
            }

            foreach (var evt in events)
            {
                try { onChange(evt); }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error in file watcher callback for {Path}", evt.Path);
                }
            }
        };

        void QueueEvent(FileSystemChangeEvent evt)
        {
            lock (lockObj) { pendingEvents[evt.Path] = evt; }
            debounceTimer.Stop();
            debounceTimer.Start();
        }

        watcher.Created += (s, e) => QueueEvent(new FileSystemChangeEvent
        {
            Path = e.FullPath,
            ChangeType = FileSystemChangeType.Created,
            IsDirectory = Directory.Exists(e.FullPath)
        });

        watcher.Deleted += (s, e) => QueueEvent(new FileSystemChangeEvent
        {
            Path = e.FullPath,
            ChangeType = FileSystemChangeType.Deleted
        });

        watcher.Changed += (s, e) => QueueEvent(new FileSystemChangeEvent
        {
            Path = e.FullPath,
            ChangeType = FileSystemChangeType.Modified,
            IsDirectory = Directory.Exists(e.FullPath)
        });

        watcher.Renamed += (s, e) => QueueEvent(new FileSystemChangeEvent
        {
            Path = e.FullPath,
            OldPath = e.OldFullPath,
            ChangeType = FileSystemChangeType.Renamed,
            IsDirectory = Directory.Exists(e.FullPath)
        });

        watcher.Error += (s, e) =>
            _logger.LogError(e.GetException(), "File watcher error for {Path}", path);

        watcher.EnableRaisingEvents = true;
        _logger.LogDebug("Started watching directory: {Path}", path);

        return new FileWatcherDisposable(watcher, debounceTimer, () =>
            _logger.LogDebug("Stopped watching directory: {Path}", path));
    }

    private sealed class FileWatcherDisposable : IDisposable
    {
        private readonly FileSystemWatcher _watcher;
        private readonly System.Timers.Timer _timer;
        private readonly Action _onDispose;
        private bool _disposed;

        public FileWatcherDisposable(FileSystemWatcher watcher, System.Timers.Timer timer, Action onDispose)
        {
            _watcher = watcher;
            _timer = timer;
            _onDispose = onDispose;
        }

        public void Dispose()
        {
            if (_disposed) return;
            _disposed = true;

            _watcher.EnableRaisingEvents = false;
            _timer.Stop();
            _watcher.Dispose();
            _timer.Dispose();
            _onDispose();
        }
    }

    #endregion

    #region Utilities

    public bool IsTextFile(string path)
    {
        if (!File.Exists(path)) return false;

        // Check extension first
        var extension = Path.GetExtension(path);
        if (TextExtensions.Contains(extension)) return true;

        // Check file header for binary signatures
        try
        {
            using var stream = File.OpenRead(path);
            var buffer = new byte[8];
            var bytesRead = stream.Read(buffer, 0, buffer.Length);

            if (bytesRead == 0) return true; // Empty file is text

            foreach (var signature in BinarySignatures)
            {
                if (bytesRead >= signature.Length &&
                    buffer.Take(signature.Length).SequenceEqual(signature))
                    return false;
            }

            // Check for null bytes (common in binary files)
            stream.Position = 0;
            var checkBuffer = new byte[Math.Min(8192, stream.Length)];
            bytesRead = stream.Read(checkBuffer, 0, checkBuffer.Length);

            return !checkBuffer.Take(bytesRead).Contains((byte)0);
        }
        catch { return false; }
    }

    #endregion

    #region Ignore Patterns

    public bool ShouldIgnore(string path, string basePath, IReadOnlyList<string> ignorePatterns)
    {
        if (ignorePatterns.Count == 0) return false;

        var relativePath = GetRelativePath(path, basePath);
        var isDirectory = Directory.Exists(path);

        // Normalize path separators
        relativePath = relativePath.Replace('\\', '/');
        if (isDirectory && !relativePath.EndsWith('/'))
            relativePath += '/';

        foreach (var pattern in ignorePatterns)
        {
            if (string.IsNullOrWhiteSpace(pattern) || pattern.StartsWith('#'))
                continue;

            var trimmed = pattern.Trim();
            var isNegation = trimmed.StartsWith('!');
            if (isNegation) trimmed = trimmed[1..];

            var regex = ConvertGitIgnorePatternToRegex(trimmed);
            if (regex.IsMatch(relativePath))
                return !isNegation;
        }

        return false;
    }

    public async Task<IReadOnlyList<string>> LoadGitIgnorePatternsAsync(
        string workspacePath,
        CancellationToken cancellationToken = default)
    {
        var patterns = new List<string>();

        // Load root .gitignore
        var gitignorePath = Path.Combine(workspacePath, ".gitignore");
        if (File.Exists(gitignorePath))
        {
            var lines = await File.ReadAllLinesAsync(gitignorePath, cancellationToken);
            patterns.AddRange(lines);
        }

        // Add default patterns
        patterns.AddRange(DefaultIgnorePatterns);

        return patterns.Distinct().ToList();
    }

    private static Regex ConvertGitIgnorePatternToRegex(string pattern)
    {
        var regexPattern = new StringBuilder("^");

        var isDirectoryOnly = pattern.EndsWith('/');
        if (isDirectoryOnly) pattern = pattern[..^1];

        var hasLeadingSlash = pattern.StartsWith('/');
        if (hasLeadingSlash) pattern = pattern[1..];

        // Escape regex special characters except * and ?
        pattern = Regex.Escape(pattern)
            .Replace("\\*\\*", ".*")           // ** matches everything
            .Replace("\\*", "[^/]*")           // * matches except /
            .Replace("\\?", "[^/]");           // ? matches single char

        if (!hasLeadingSlash && !pattern.Contains('/'))
            regexPattern.Append("(.*/)?").Append(pattern);
        else
            regexPattern.Append(pattern);

        regexPattern.Append(isDirectoryOnly ? "/" : "(/|$)");

        return new Regex(regexPattern.ToString(), RegexOptions.IgnoreCase | RegexOptions.Compiled);
    }

    #endregion

    #region Helpers

    private static FileSystemItem CreateFileSystemItem(DirectoryInfo dirInfo)
    {
        var hasChildren = false;
        try { hasChildren = dirInfo.EnumerateFileSystemInfos().Any(); }
        catch { /* Access denied */ }

        return new FileSystemItem
        {
            Path = dirInfo.FullName,
            Name = dirInfo.Name,
            Type = FileSystemItemType.Directory,
            ModifiedAt = dirInfo.LastWriteTimeUtc,
            AccessedAt = dirInfo.LastAccessTimeUtc,
            CreatedAt = dirInfo.CreationTimeUtc,
            IsHidden = IsHidden(dirInfo),
            IsReadOnly = false,
            HasChildren = hasChildren
        };
    }

    private static FileSystemItem CreateFileSystemItem(FileInfo fileInfo)
    {
        return new FileSystemItem
        {
            Path = fileInfo.FullName,
            Name = fileInfo.Name,
            Type = FileSystemItemType.File,
            Size = fileInfo.Length,
            ModifiedAt = fileInfo.LastWriteTimeUtc,
            AccessedAt = fileInfo.LastAccessTimeUtc,
            CreatedAt = fileInfo.CreationTimeUtc,
            IsHidden = IsHidden(fileInfo),
            IsReadOnly = fileInfo.IsReadOnly
        };
    }

    private static bool IsHidden(FileSystemInfo info)
    {
        if ((info.Attributes & FileAttributes.Hidden) == FileAttributes.Hidden)
            return true;
        return info.Name.StartsWith('.');
    }

    #endregion
}
```

---

## Unit Testing Requirements

| Component | Test Count | Focus Areas |
|-----------|------------|-------------|
| GetDirectoryContentsAsync | 4 | Sorting, hidden files, empty |
| File CRUD Operations | 8 | Read, write, create, delete |
| Rename/Copy/Move | 4 | Files and directories |
| WatchDirectory | 4 | Events, debounce, dispose |
| IsTextFile | 5 | Extensions, signatures, null bytes |
| ShouldIgnore | 6 | Patterns, negation, directories |
| LoadGitIgnorePatternsAsync | 2 | Load file, defaults |
| **Total** | **33** | |

### Key Test Scenarios

```csharp
// Directory Operations
[Fact]
public async Task GetDirectoryContentsAsync_SortsDirectoriesFirst()
{
    // Create temp dir with files and subdirectories
    var result = await _service.GetDirectoryContentsAsync(tempDir);
    
    // Verify directories come before files
    var lastDirIndex = result.Select((item, i) => (item, i))
        .Where(x => x.item.IsDirectory).Max(x => x.i);
    var firstFileIndex = result.Select((item, i) => (item, i))
        .Where(x => x.item.IsFile).Min(x => x.i);
    
    Assert.True(lastDirIndex < firstFileIndex);
}

[Fact]
public async Task GetDirectoryContentsAsync_ExcludesHiddenByDefault()
{
    // Create hidden file (.hidden)
    var result = await _service.GetDirectoryContentsAsync(tempDir);
    Assert.DoesNotContain(result, x => x.Name == ".hidden");
}

// File Watching
[Fact]
public void WatchDirectory_DebouncesBatchesRapidEvents()
{
    var events = new List<FileSystemChangeEvent>();
    using var watcher = _service.WatchDirectory(tempDir, e => events.Add(e));
    
    // Create file and modify it 5 times rapidly
    File.WriteAllText(Path.Combine(tempDir, "test.txt"), "1");
    File.WriteAllText(Path.Combine(tempDir, "test.txt"), "2");
    File.WriteAllText(Path.Combine(tempDir, "test.txt"), "3");
    
    Thread.Sleep(300); // Wait for debounce
    
    // Should receive batched events, not 5
    Assert.True(events.Count < 5);
}

// Binary Detection
[Theory]
[InlineData(".cs", true)]
[InlineData(".py", true)]
[InlineData("unknown_text", true)]   // Text content, no extension
public void IsTextFile_DetectsTextFiles(string scenario, bool expected)
{
    // Test implementation
}

[Fact]
public void IsTextFile_DetectsPngAsBinary()
{
    var pngPath = CreateTempFile([0x89, 0x50, 0x4E, 0x47, 0x00, 0x00]);
    Assert.False(_service.IsTextFile(pngPath));
}

// Ignore Patterns
[Theory]
[InlineData("node_modules/package/file.js", "node_modules/", true)]
[InlineData("src/node_modules/file.js", "node_modules/", true)]  // Matches anywhere
[InlineData("src/file.js", "node_modules/", false)]
[InlineData("bin/Debug/app.dll", "bin/", true)]
[InlineData(".git/config", ".git/", true)]
public void ShouldIgnore_MatchesGitignorePatterns(string path, string pattern, bool expected)
{
    var patterns = new[] { pattern };
    var result = _service.ShouldIgnore(
        Path.Combine("/project", path), "/project", patterns);
    Assert.Equal(expected, result);
}

[Fact]
public void ShouldIgnore_SupportsNegation()
{
    var patterns = new[] { "*.log", "!important.log" };
    
    Assert.True(_service.ShouldIgnore("/project/debug.log", "/project", patterns));
    Assert.False(_service.ShouldIgnore("/project/important.log", "/project", patterns));
}
```

---

## Files Summary

### Files to Create (2)

| File | Lines (approx) |
|------|----------------|
| `Interfaces/IFileSystemService.cs` | 130 |
| `Services/FileSystemService.cs` | 400 |

### Files to Modify (0)

No files need modification for v0.3.1d.

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | GetDirectoryContentsAsync sorts folders first |
| AC-2 | Hidden files excluded by default |
| AC-3 | File read/write operations work correctly |
| AC-4 | WatchDirectory debounces rapid events |
| AC-5 | WatchDirectory returns disposable to stop |
| AC-6 | IsTextFile detects binary files by signature |
| AC-7 | IsTextFile detects binary by null bytes |
| AC-8 | ShouldIgnore matches gitignore patterns |
| AC-9 | LoadGitIgnorePatternsAsync includes defaults |
| AC-10 | All operations log appropriately |

---

## Design Decisions

| Decision | Rationale |
|----------|-----------|
| 200ms debounce | Balance between responsiveness and batching |
| Last event wins | For same path, most recent state matters |
| Binary signature check | Fast detection without full file scan |
| Default ignore patterns | Common files (.git, node_modules) always ignored |
| Regex for gitignore | Accurate pattern matching, compiled for speed |

---

## Dependencies

| Part | Dependency Description |
|------|------------------------|
| v0.3.1a | FileSystemItem model |
| v0.3.1c | LanguageDetector for file type hints |

---

## Timeline Estimate

| Version | Estimated Effort |
|---------|------------------|
| v0.3.1d | 1 day |
