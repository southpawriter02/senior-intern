# Design Specification: The Senior Intern v0.3.1a "Core Models"

## Executive Summary

This document provides a detailed implementation specification for v0.3.1a, which defines the core domain models for the workspace system. These models establish the foundation for workspace management, file system representation, and file context attachment for LLM conversations.

### v0.3.1a Scope (from v0.3.1 Design Document)

- Create `Workspace` model for project folders
- Create `FileSystemItem` model for files/directories
- Create `FileSystemItemType` enum
- Create `FileContext` model for attached file content
- Create `TokenEstimator` utility for context budgeting

### Key Deliverables

| Deliverable | Description |
|-------------|-------------|
| Workspace | Project folder representation with state |
| FileSystemItem | File/directory model with metadata |
| FileSystemItemType | Enum for File, Directory, SymbolicLink |
| FileContext | Attached file content for chat context |
| TokenEstimator | Token count estimation utility |

---

## Feature Overview

```
┌──────────────────────────────────────────────────────────────────┐
│                     v0.3.1a Feature Tree                          │
├──────────────────────────────────────────────────────────────────┤
│                                                                   │
│  Workspace Model                                                  │
│  ├── Properties                                                   │
│  │   ├── Id (Guid)                                                │
│  │   ├── Name (string) - optional custom name                    │
│  │   ├── RootPath (string) - absolute path to folder             │
│  │   ├── OpenedAt (DateTime) - first opened                      │
│  │   ├── LastAccessedAt (DateTime) - most recent access          │
│  │   ├── OpenFiles (IReadOnlyList<string>) - relative paths      │
│  │   ├── ActiveFilePath (string?) - focused file                 │
│  │   ├── ExpandedFolders (IReadOnlyList<string>) - tree state    │
│  │   ├── IsPinned (bool) - pinned in recent list                 │
│  │   └── GitIgnorePatterns (IReadOnlyList<string>)               │
│  │                                                                │
│  └── Computed Properties                                          │
│      ├── DisplayName - custom name or folder name                │
│      ├── Exists - Directory.Exists(RootPath)                     │
│      ├── GetAbsolutePath(rel) → absolute                         │
│      └── GetRelativePath(abs) → relative                         │
│                                                                   │
│  FileSystemItem Model                                             │
│  ├── Properties                                                   │
│  │   ├── Path (string) - absolute path                           │
│  │   ├── Name (string) - file/folder name                        │
│  │   ├── Type (FileSystemItemType)                               │
│  │   ├── Size (long?) - bytes, null for directories              │
│  │   ├── ModifiedAt, AccessedAt, CreatedAt (DateTime)            │
│  │   ├── IsHidden, IsReadOnly (bool)                             │
│  │   ├── HasChildren (bool) - for lazy loading                   │
│  │   ├── IsExpanded (bool) - tree view state                     │
│  │   └── Children (IReadOnlyList<FileSystemItem>?)               │
│  │                                                                │
│  └── Computed Properties                                          │
│      ├── Extension - ".cs", "" for directories                   │
│      ├── Language - detected from extension                      │
│      ├── IsDirectory, IsFile (bool)                              │
│      └── FormattedSize - "1.2 KB"                                │
│                                                                   │
│  FileSystemItemType (Enum)                                        │
│  ├── File                                                         │
│  ├── Directory                                                    │
│  └── SymbolicLink                                                 │
│                                                                   │
│  FileContext Model                                                │
│  ├── Properties                                                   │
│  │   ├── Id (Guid)                                                │
│  │   ├── FilePath (string) - absolute path                       │
│  │   ├── Content (string) - actual file/selection content        │
│  │   ├── Language (string?) - detected language                  │
│  │   ├── LineCount (int)                                          │
│  │   ├── EstimatedTokens (int) - for context budgeting           │
│  │   ├── AttachedAt (DateTime)                                   │
│  │   ├── StartLine, EndLine (int?) - for selections             │
│  │   └── ContentHash (string) - SHA256 prefix                    │
│  │                                                                │
│  ├── Computed Properties                                          │
│  │   ├── FileName - extracted from path                          │
│  │   ├── IsPartialContent - has line range                       │
│  │   └── DisplayLabel - "file.cs (lines 10-25)"                  │
│  │                                                                │
│  └── Factory Methods                                              │
│      ├── FromFile(path, content) → FileContext                   │
│      └── FromSelection(path, content, start, end) → FileContext  │
│                                                                   │
│  TokenEstimator Utility                                           │
│  ├── Estimate(content) → int                                     │
│  └── Estimate(content, language) → int                           │
│      └── Language-specific multipliers                           │
│                                                                   │
└──────────────────────────────────────────────────────────────────┘
```

---

## Architecture Diagrams

### Model Relationships

```
┌─────────────────────────────────────────────────────────────────┐
│                     Model Relationships                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌────────────────────────────────────────────────────────────┐  │
│  │                      Workspace                              │  │
│  │  • Represents an open project folder                        │  │
│  │  • Manages UI state (open files, expanded folders)          │  │
│  │  • Persists to RecentWorkspaceEntity                        │  │
│  └──────────────────────────┬─────────────────────────────────┘  │
│                             │                                    │
│                             │ contains                           │
│                             ▼                                    │
│  ┌────────────────────────────────────────────────────────────┐  │
│  │                   FileSystemItem                            │  │
│  │  • Represents a file or directory                           │  │
│  │  • Created by IFileSystemService                            │  │
│  │  • Lazy-loaded children for directories                     │  │
│  └──────────────────────────┬─────────────────────────────────┘  │
│                             │                                    │
│                             │ can become                         │
│                             ▼                                    │
│  ┌────────────────────────────────────────────────────────────┐  │
│  │                     FileContext                             │  │
│  │  • File content attached to chat message                    │  │
│  │  • Includes token count for context budgeting               │  │
│  │  • Supports partial content (selections)                    │  │
│  │  • Persists to FileContextEntity                            │  │
│  └────────────────────────────────────────────────────────────┘  │
│                                                                  │
│  Dependencies:                                                   │
│  ┌──────────────────────────────┐                                │
│  │      TokenEstimator          │  ← Used by FileContext         │
│  │      LanguageDetector        │  ← Used by FileSystemItem      │
│  │      (v0.3.1c)               │     and FileContext            │
│  └──────────────────────────────┘                                │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Workspace State Diagram

```
┌─────────────────────────────────────────────────────────────────┐
│                   Workspace State Diagram                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Workspace Persistence Cycle:                                    │
│                                                                  │
│  ┌─────────────┐      User selects folder      ┌─────────────┐  │
│  │ No Active   │ ─────────────────────────────►│ Workspace   │  │
│  │ Workspace   │                               │ Created     │  │
│  └─────────────┘                               └──────┬──────┘  │
│         ▲                                             │         │
│         │ Close                                       │ Save    │
│         │ workspace                                   ▼         │
│  ┌─────────────┐                               ┌─────────────┐  │
│  │ Workspace   │◄──────── App closes ──────────│ Workspace   │  │
│  │ Closed      │ or user closes                │ Active      │  │
│  └─────────────┘                               └──────┬──────┘  │
│                                                       │         │
│                         File operations               │         │
│                         ┌─────────────────────────────┘         │
│                         ▼                                       │
│  State Updates:                                                  │
│  • OpenFiles: user opens/closes files                            │
│  • ActiveFilePath: user switches tabs                            │
│  • ExpandedFolders: user expands/collapses in tree               │
│  • LastAccessedAt: any interaction                               │
│                                                                  │
│  Persistence:                                                    │
│  • On close: save state to RecentWorkspaceEntity                 │
│  • On reopen: restore state from entity                          │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## Directory Structure

```
src/SeniorIntern.Core/
├── Models/
│   ├── Workspace.cs                                  (NEW)
│   ├── FileSystemItem.cs                             (NEW)
│   └── FileContext.cs                                (NEW)
└── Utilities/
    └── TokenEstimator.cs                             (NEW)
```

---

## Implementation Details

### Task 1: Create Workspace Model

**File:** `src/SeniorIntern.Core/Models/Workspace.cs`

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Represents an open project workspace (folder).
/// </summary>
public sealed class Workspace
{
    /// <summary>Unique identifier for the workspace.</summary>
    public Guid Id { get; init; } = Guid.NewGuid();

    /// <summary>
    /// Optional custom name for the workspace.
    /// If empty, DisplayName falls back to the folder name.
    /// </summary>
    public string Name { get; set; } = string.Empty;

    /// <summary>Absolute path to the workspace root directory.</summary>
    public required string RootPath { get; init; }

    /// <summary>When the workspace was first opened.</summary>
    public DateTime OpenedAt { get; init; } = DateTime.UtcNow;

    /// <summary>When the workspace was last accessed.</summary>
    public DateTime LastAccessedAt { get; set; } = DateTime.UtcNow;

    /// <summary>List of currently open file paths (relative to RootPath).</summary>
    public IReadOnlyList<string> OpenFiles { get; set; } = [];

    /// <summary>Currently active/focused file path (relative to RootPath).</summary>
    public string? ActiveFilePath { get; set; }

    /// <summary>
    /// List of expanded folder paths in the explorer (relative to RootPath).
    /// Used to restore tree state.
    /// </summary>
    public IReadOnlyList<string> ExpandedFolders { get; set; } = [];

    /// <summary>Whether this workspace is pinned in the recent list.</summary>
    public bool IsPinned { get; set; }

    /// <summary>Git ignore patterns loaded from .gitignore files in the workspace.</summary>
    public IReadOnlyList<string> GitIgnorePatterns { get; set; } = [];

    /// <summary>Display name for UI (custom name or folder name).</summary>
    public string DisplayName => string.IsNullOrWhiteSpace(Name)
        ? Path.GetFileName(RootPath) ?? RootPath
        : Name;

    /// <summary>Whether the workspace root directory exists.</summary>
    public bool Exists => Directory.Exists(RootPath);

    /// <summary>Gets the absolute path for a relative file path.</summary>
    public string GetAbsolutePath(string relativePath)
        => Path.GetFullPath(Path.Combine(RootPath, relativePath));

    /// <summary>Gets the relative path for an absolute file path.</summary>
    public string GetRelativePath(string absolutePath)
        => Path.GetRelativePath(RootPath, absolutePath);

    /// <summary>Checks if a path is within this workspace.</summary>
    public bool ContainsPath(string absolutePath)
        => absolutePath.StartsWith(RootPath, StringComparison.OrdinalIgnoreCase);

    /// <summary>Updates the last accessed timestamp to now.</summary>
    public void Touch() => LastAccessedAt = DateTime.UtcNow;
}
```

---

### Task 2: Create FileSystemItem Model

**File:** `src/SeniorIntern.Core/Models/FileSystemItem.cs`

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Represents a file or directory in the file system.
/// </summary>
public sealed class FileSystemItem
{
    /// <summary>Absolute path to the item.</summary>
    public required string Path { get; init; }

    /// <summary>File or folder name.</summary>
    public required string Name { get; init; }

    /// <summary>Type of file system item.</summary>
    public required FileSystemItemType Type { get; init; }

    /// <summary>File size in bytes (null for directories).</summary>
    public long? Size { get; init; }

    /// <summary>Last modified timestamp.</summary>
    public DateTime ModifiedAt { get; init; }

    /// <summary>Last accessed timestamp.</summary>
    public DateTime AccessedAt { get; init; }

    /// <summary>Creation timestamp.</summary>
    public DateTime CreatedAt { get; init; }

    /// <summary>Whether the item is hidden (starts with . or has hidden attribute).</summary>
    public bool IsHidden { get; init; }

    /// <summary>Whether the item is read-only.</summary>
    public bool IsReadOnly { get; init; }

    /// <summary>
    /// For directories: whether the directory has any children.
    /// Used for lazy loading indicator in tree view.
    /// </summary>
    public bool HasChildren { get; init; }

    /// <summary>For directories: current expansion state in tree view.</summary>
    public bool IsExpanded { get; set; }

    /// <summary>For directories: loaded children (null if not loaded yet).</summary>
    public IReadOnlyList<FileSystemItem>? Children { get; set; }

    /// <summary>
    /// File extension including the dot (e.g., ".cs").
    /// Empty string for directories.
    /// </summary>
    public string Extension => Type == FileSystemItemType.File
        ? System.IO.Path.GetExtension(Path)
        : string.Empty;

    /// <summary>
    /// Detected programming language based on extension.
    /// Uses LanguageDetector (v0.3.1c).
    /// </summary>
    public string? Language => Type == FileSystemItemType.File
        ? LanguageDetector.DetectByExtension(Extension)
        : null;

    /// <summary>Whether this is a directory.</summary>
    public bool IsDirectory => Type == FileSystemItemType.Directory;

    /// <summary>Whether this is a file.</summary>
    public bool IsFile => Type == FileSystemItemType.File;

    /// <summary>Human-readable file size (e.g., "1.2 KB").</summary>
    public string FormattedSize => Size.HasValue
        ? FormatFileSize(Size.Value)
        : string.Empty;

    /// <summary>Gets the parent directory path.</summary>
    public string? ParentPath => System.IO.Path.GetDirectoryName(Path);

    /// <summary>Creates a FileSystemItem from a FileInfo.</summary>
    public static FileSystemItem FromFileInfo(FileInfo info)
    {
        return new FileSystemItem
        {
            Path = info.FullName,
            Name = info.Name,
            Type = FileSystemItemType.File,
            Size = info.Length,
            ModifiedAt = info.LastWriteTimeUtc,
            AccessedAt = info.LastAccessTimeUtc,
            CreatedAt = info.CreationTimeUtc,
            IsHidden = info.Name.StartsWith('.') || info.Attributes.HasFlag(FileAttributes.Hidden),
            IsReadOnly = info.IsReadOnly
        };
    }

    /// <summary>Creates a FileSystemItem from a DirectoryInfo.</summary>
    public static FileSystemItem FromDirectoryInfo(DirectoryInfo info, bool hasChildren = false)
    {
        return new FileSystemItem
        {
            Path = info.FullName,
            Name = info.Name,
            Type = FileSystemItemType.Directory,
            Size = null,
            ModifiedAt = info.LastWriteTimeUtc,
            AccessedAt = info.LastAccessTimeUtc,
            CreatedAt = info.CreationTimeUtc,
            IsHidden = info.Name.StartsWith('.') || info.Attributes.HasFlag(FileAttributes.Hidden),
            IsReadOnly = info.Attributes.HasFlag(FileAttributes.ReadOnly),
            HasChildren = hasChildren
        };
    }

    private static string FormatFileSize(long bytes)
    {
        string[] suffixes = ["B", "KB", "MB", "GB", "TB"];
        int suffixIndex = 0;
        double size = bytes;

        while (size >= 1024 && suffixIndex < suffixes.Length - 1)
        {
            size /= 1024;
            suffixIndex++;
        }

        return suffixIndex == 0
            ? $"{size:F0} {suffixes[suffixIndex]}"
            : $"{size:F1} {suffixes[suffixIndex]}";
    }
}

/// <summary>Type of file system item.</summary>
public enum FileSystemItemType
{
    /// <summary>Regular file.</summary>
    File,

    /// <summary>Directory/folder.</summary>
    Directory,

    /// <summary>Symbolic link.</summary>
    SymbolicLink
}
```

---

### Task 3: Create FileContext Model

**File:** `src/SeniorIntern.Core/Models/FileContext.cs`

```csharp
namespace SeniorIntern.Core.Models;

using SeniorIntern.Core.Utilities;
using System.Security.Cryptography;
using System.Text;

/// <summary>
/// Represents file content attached to a chat message as context.
/// </summary>
public sealed class FileContext
{
    /// <summary>Unique identifier for the context attachment.</summary>
    public Guid Id { get; init; } = Guid.NewGuid();

    /// <summary>Absolute path to the file.</summary>
    public required string FilePath { get; init; }

    /// <summary>File name extracted from the path.</summary>
    public string FileName => Path.GetFileName(FilePath);

    /// <summary>The actual file content (or selection content).</summary>
    public required string Content { get; init; }

    /// <summary>Detected programming language.</summary>
    public string? Language { get; init; }

    /// <summary>Total line count of the content.</summary>
    public int LineCount { get; init; }

    /// <summary>Estimated token count for LLM context budget.</summary>
    public int EstimatedTokens { get; init; }

    /// <summary>When the context was attached.</summary>
    public DateTime AttachedAt { get; init; } = DateTime.UtcNow;

    /// <summary>Starting line number if partial content (1-indexed). Null if entire file.</summary>
    public int? StartLine { get; init; }

    /// <summary>Ending line number if partial content (1-indexed, inclusive). Null if entire file.</summary>
    public int? EndLine { get; init; }

    /// <summary>Hash of the content for detecting changes.</summary>
    public string ContentHash { get; init; } = string.Empty;

    /// <summary>Whether this is a partial file (selection) or full file.</summary>
    public bool IsPartialContent => StartLine.HasValue || EndLine.HasValue;

    /// <summary>Display label for UI showing file name and line range if applicable.</summary>
    public string DisplayLabel => IsPartialContent
        ? $"{FileName} (lines {StartLine}-{EndLine})"
        : FileName;

    /// <summary>Content size in bytes.</summary>
    public int ContentSizeBytes => Encoding.UTF8.GetByteCount(Content);

    /// <summary>Creates a FileContext from a full file.</summary>
    public static FileContext FromFile(string filePath, string content)
    {
        var lineCount = CountLines(content);
        var language = LanguageDetector.DetectByFileName(Path.GetFileName(filePath));

        return new FileContext
        {
            FilePath = filePath,
            Content = content,
            Language = language,
            LineCount = lineCount,
            EstimatedTokens = TokenEstimator.Estimate(content, language),
            ContentHash = ComputeHash(content)
        };
    }

    /// <summary>Creates a FileContext from a code selection.</summary>
    public static FileContext FromSelection(
        string filePath,
        string content,
        int startLine,
        int endLine)
    {
        var lineCount = endLine - startLine + 1;
        var language = LanguageDetector.DetectByFileName(Path.GetFileName(filePath));

        return new FileContext
        {
            FilePath = filePath,
            Content = content,
            Language = language,
            LineCount = lineCount,
            EstimatedTokens = TokenEstimator.Estimate(content, language),
            StartLine = startLine,
            EndLine = endLine,
            ContentHash = ComputeHash(content)
        };
    }

    /// <summary>Formats the content for LLM context with file info header.</summary>
    public string FormatForLlmContext()
    {
        var header = IsPartialContent
            ? $"// File: {FileName} (lines {StartLine}-{EndLine})"
            : $"// File: {FileName}";

        if (Language is not null)
            header += $" [{Language}]";

        return $"{header}\n{Content}";
    }

    private static int CountLines(string content)
        => string.IsNullOrEmpty(content) ? 0 : content.Count(c => c == '\n') + 1;

    private static string ComputeHash(string content)
    {
        var bytes = Encoding.UTF8.GetBytes(content);
        var hashBytes = SHA256.HashData(bytes);
        return Convert.ToHexString(hashBytes)[..16]; // First 16 chars
    }
}
```

---

### Task 4: Create TokenEstimator Utility

**File:** `src/SeniorIntern.Core/Utilities/TokenEstimator.cs`

```csharp
namespace SeniorIntern.Core.Utilities;

/// <summary>
/// Estimates token count for content to help manage LLM context budgets.
/// </summary>
public static class TokenEstimator
{
    /// <summary>
    /// Average characters per token. Varies by language and content type.
    /// Code typically has more symbols resulting in more tokens per character.
    /// </summary>
    private const double DefaultCharsPerToken = 3.5;

    /// <summary>
    /// Estimates the number of tokens in the given content.
    /// </summary>
    public static int Estimate(string content)
    {
        if (string.IsNullOrEmpty(content))
            return 0;

        return (int)Math.Ceiling(content.Length / DefaultCharsPerToken);
    }

    /// <summary>
    /// Estimates tokens with language-specific adjustment.
    /// Code languages tend to have more tokens per character due to symbols.
    /// </summary>
    public static int Estimate(string? content, string? language)
    {
        if (string.IsNullOrEmpty(content))
            return 0;

        var multiplier = GetLanguageMultiplier(language);
        return (int)Math.Ceiling(content.Length / DefaultCharsPerToken * multiplier);
    }

    /// <summary>
    /// Gets the language-specific token multiplier.
    /// </summary>
    public static double GetLanguageMultiplier(string? language)
    {
        return language?.ToLowerInvariant() switch
        {
            // Symbol-heavy languages (more tokens per char)
            "csharp" or "c#" => 1.2,
            "java" => 1.2,
            "cpp" or "c++" => 1.25,
            "c" => 1.2,
            "typescript" => 1.15,
            "javascript" => 1.1,
            "rust" => 1.2,
            "go" => 1.15,

            // Readable/whitespace languages
            "python" => 1.0,
            "ruby" => 1.0,
            "yaml" => 0.95,

            // Verbose markup
            "json" => 1.3,
            "xml" => 1.35,
            "html" => 1.3,

            // Prose-heavy
            "markdown" or "md" => 0.9,
            "text" or "txt" => 0.85,

            // Default
            _ => 1.0
        };
    }

    /// <summary>
    /// Estimates the maximum content length for a given token budget.
    /// </summary>
    public static int MaxContentLength(int tokenBudget, string? language = null)
    {
        var multiplier = GetLanguageMultiplier(language);
        return (int)(tokenBudget * DefaultCharsPerToken / multiplier);
    }

    /// <summary>
    /// Checks if content exceeds a token budget.
    /// </summary>
    public static bool ExceedsBudget(string content, int tokenBudget, string? language = null)
        => Estimate(content, language) > tokenBudget;
}
```

---

## Unit Testing Requirements

| Component | Test Count | Focus Areas |
|-----------|------------|-------------|
| Workspace | 6 | DisplayName, paths, Contains |
| FileSystemItem | 5 | Factory methods, formatting |
| FileContext | 6 | Factory methods, hash, format |
| TokenEstimator | 5 | Estimates, multipliers, budget |
| **Total** | **22** | |

### Key Test Scenarios

```csharp
// Workspace Tests
[Fact]
public void DisplayName_WithCustomName_ReturnsCustomName()
{
    var workspace = new Workspace { RootPath = "/path/to/project", Name = "My Project" };
    Assert.Equal("My Project", workspace.DisplayName);
}

[Fact]
public void DisplayName_WithoutCustomName_ReturnsFolderName()
{
    var workspace = new Workspace { RootPath = "/path/to/project" };
    Assert.Equal("project", workspace.DisplayName);
}

[Fact]
public void GetRelativePath_ReturnsCorrectPath()
{
    var workspace = new Workspace { RootPath = "/home/user/project" };
    var relative = workspace.GetRelativePath("/home/user/project/src/file.cs");
    Assert.Equal("src/file.cs", relative);
}

[Fact]
public void ContainsPath_InsideWorkspace_ReturnsTrue()
{
    var workspace = new Workspace { RootPath = "/home/user/project" };
    Assert.True(workspace.ContainsPath("/home/user/project/src/file.cs"));
}

// FileSystemItem Tests
[Fact]
public void FromFileInfo_CreatesCorrectItem()
{
    var tempFile = Path.GetTempFileName();
    File.WriteAllText(tempFile, "test content");
    var fileInfo = new FileInfo(tempFile);
    
    var item = FileSystemItem.FromFileInfo(fileInfo);
    
    Assert.Equal(tempFile, item.Path);
    Assert.Equal(FileSystemItemType.File, item.Type);
    Assert.Equal(12, item.Size); // "test content" = 12 bytes
    
    File.Delete(tempFile);
}

[Fact]
public void FormattedSize_FormatsCorrectly()
{
    var item = new FileSystemItem { Path = "/f.txt", Name = "f.txt", Type = FileSystemItemType.File, Size = 1536 };
    Assert.Equal("1.5 KB", item.FormattedSize);
}

// FileContext Tests
[Fact]
public void FromFile_CalculatesLineCount()
{
    var content = "line1\nline2\nline3";
    var context = FileContext.FromFile("/test.cs", content);
    Assert.Equal(3, context.LineCount);
}

[Fact]
public void FromSelection_SetsLineRange()
{
    var context = FileContext.FromSelection("/test.cs", "selected", 10, 25);
    Assert.True(context.IsPartialContent);
    Assert.Equal(10, context.StartLine);
    Assert.Equal(25, context.EndLine);
    Assert.Equal("test.cs (lines 10-25)", context.DisplayLabel);
}

[Fact]
public void ContentHash_IsDeterministic()
{
    var context1 = FileContext.FromFile("/test.cs", "content");
    var context2 = FileContext.FromFile("/test.cs", "content");
    Assert.Equal(context1.ContentHash, context2.ContentHash);
}

// TokenEstimator Tests
[Fact]
public void Estimate_CalculatesApproximateTokens()
{
    var content = new string('a', 350); // 350 chars
    var tokens = TokenEstimator.Estimate(content);
    Assert.Equal(100, tokens); // 350 / 3.5 = 100
}

[Theory]
[InlineData("csharp", 1.2)]
[InlineData("python", 1.0)]
[InlineData("json", 1.3)]
[InlineData("markdown", 0.9)]
public void GetLanguageMultiplier_ReturnsCorrectValue(string language, double expected)
{
    Assert.Equal(expected, TokenEstimator.GetLanguageMultiplier(language));
}
```

---

## Files Summary

### Files to Create (4)

| File | Lines (approx) |
|------|----------------|
| `Models/Workspace.cs` | 70 |
| `Models/FileSystemItem.cs` | 120 |
| `Models/FileContext.cs` | 100 |
| `Utilities/TokenEstimator.cs` | 70 |

### Files to Modify (0)

No files need modification for v0.3.1a.

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | Workspace stores root path and custom name |
| AC-2 | Workspace.DisplayName falls back to folder name |
| AC-3 | Workspace tracks open files and active file |
| AC-4 | FileSystemItem represents files and directories |
| AC-5 | FileSystemItem.FormattedSize displays human-readable sizes |
| AC-6 | FileContext stores file content with token estimate |
| AC-7 | FileContext.FromSelection supports partial content |
| AC-8 | FileContext.ContentHash is deterministic |
| AC-9 | TokenEstimator provides language-specific estimates |
| AC-10 | All factory methods create valid instances |

---

## Design Decisions

| Decision | Rationale |
|----------|-----------|
| Relative paths for OpenFiles | Enables workspace portability |
| SHA256 prefix for hash | 16 chars sufficient for change detection |
| Language multipliers | Code has more tokens per character |
| Lazy-loaded Children | Prevents loading entire file tree initially |
| Optional Name field | Allows custom names while defaulting to folder |

---

## Dependencies on Future Parts

| Part | Dependency |
|------|------------|
| v0.3.1c | LanguageDetector.DetectByExtension/FileName |
| v0.3.1d | FileSystemItem factory methods used by service |
| v0.3.1e | Workspace model used by WorkspaceService |

**Note:** For v0.3.1a to compile standalone, a stub LanguageDetector can be used:

```csharp
// Temporary stub until v0.3.1c
internal static class LanguageDetector
{
    public static string? DetectByExtension(string ext) => null;
    public static string? DetectByFileName(string name) => null;
}
```

---

## Timeline Estimate

| Version | Estimated Effort |
|---------|------------------|
| v0.3.1a | 0.5 day |
