# Design Specification: The Senior Intern v0.3.5c "Quick Open Dialog"

## Executive Summary

This document provides a detailed implementation specification for v0.3.5c, which creates a VS Code-style quick file navigation dialog. The dialog provides fuzzy file search with real-time results, keyboard navigation, recent files display, and matched character highlighting - all triggered via Ctrl+P.

### v0.3.5c Scope

- Create `IFileIndexService` interface for file indexing
- Implement `FileIndexService` with fuzzy matching algorithm
- Create `QuickOpenViewModel` with search, navigation, and selection
- Create `QuickOpenItemViewModel` for result items
- Create `QuickOpenDialog.axaml` with modern floating design
- Implement keyboard navigation (â†‘â†“ Enter Esc)
- Add debounced search with loading state
- Show recent files when search is empty

### Key Deliverables

| Deliverable | Description |
|-------------|-------------|
| IFileIndexService | Interface for workspace indexing |
| FileIndexService | Implementation with fuzzy search |
| FileSearchResult | Search result model |
| QuickOpenViewModel | Dialog ViewModel |
| QuickOpenItemViewModel | Result item ViewModel |
| QuickOpenDialog.axaml | Floating dialog UI |
| Keyboard handling | â†‘â†“ Enter Esc support |

---

## Feature Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     v0.3.5c Feature Tree                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                   â”‚
â”‚  IFileIndexService                                                â”‚
â”‚  â”œâ”€â”€ IndexWorkspaceAsync(path, ct) â†’ Task                       â”‚
â”‚  â”œâ”€â”€ Search(query, maxResults) â†’ IReadOnlyList<FileSearchResult>â”‚
â”‚  â”œâ”€â”€ GetRecentFiles(count) â†’ IReadOnlyList<string>              â”‚
â”‚  â”œâ”€â”€ AddToRecent(filePath) â†’ void                               â”‚
â”‚  â”œâ”€â”€ ClearIndex() â†’ void                                        â”‚
â”‚  â”œâ”€â”€ IsIndexed: bool                                            â”‚
â”‚  â””â”€â”€ IndexedFileCount: int                                      â”‚
â”‚                                                                   â”‚
â”‚  FileIndexService                                                 â”‚
â”‚  â”œâ”€â”€ Private state                                               â”‚
â”‚  â”‚   â”œâ”€â”€ _index: ConcurrentDictionary<string, IndexedFile>      â”‚
â”‚  â”‚   â”œâ”€â”€ _recentFiles: LinkedList<string>                       â”‚
â”‚  â”‚   â””â”€â”€ _workspacePath: string?                                â”‚
â”‚  â”‚                                                                â”‚
â”‚  â”œâ”€â”€ IndexDirectory() - recursive file traversal                â”‚
â”‚  â”œâ”€â”€ ScoreFile() - compute match score                          â”‚
â”‚  â”œâ”€â”€ FuzzyMatch() - character-by-character matching             â”‚
â”‚  â”‚   â”œâ”€â”€ Consecutive match bonus                                â”‚
â”‚  â”‚   â”œâ”€â”€ Prefix match bonus (+5)                                â”‚
â”‚  â”‚   â””â”€â”€ Word boundary bonus (+2)                               â”‚
â”‚  â”‚                                                                â”‚
â”‚  â””â”€â”€ IndexedFile (private class)                                â”‚
â”‚      â”œâ”€â”€ FullPath, FileName, FileNameLower                      â”‚
â”‚      â””â”€â”€ RelativePath, RelativePathLower, Language              â”‚
â”‚                                                                   â”‚
â”‚  FileSearchResult                                                 â”‚
â”‚  â”œâ”€â”€ FilePath, FileName, RelativePath                           â”‚
â”‚  â”œâ”€â”€ Language: string?                                          â”‚
â”‚  â”œâ”€â”€ Score: double                                              â”‚
â”‚  â””â”€â”€ MatchedIndices: IReadOnlyList<int>                         â”‚
â”‚                                                                   â”‚
â”‚  QuickOpenViewModel                                               â”‚
â”‚  â”œâ”€â”€ Properties                                                  â”‚
â”‚  â”‚   â”œâ”€â”€ SearchQuery: string                                    â”‚
â”‚  â”‚   â”œâ”€â”€ Results: ObservableCollection<QuickOpenItemViewModel>  â”‚
â”‚  â”‚   â”œâ”€â”€ SelectedItem: QuickOpenItemViewModel?                  â”‚
â”‚  â”‚   â”œâ”€â”€ SelectedIndex: int                                     â”‚
â”‚  â”‚   â”œâ”€â”€ IsLoading: bool                                        â”‚
â”‚  â”‚   â””â”€â”€ StatusText: string?                                    â”‚
â”‚  â”‚                                                                â”‚
â”‚  â”œâ”€â”€ Commands                                                    â”‚
â”‚  â”‚   â”œâ”€â”€ MoveUp() - â†‘ key                                       â”‚
â”‚  â”‚   â”œâ”€â”€ MoveDown() - â†“ key                                     â”‚
â”‚  â”‚   â”œâ”€â”€ Confirm() - Enter key                                  â”‚
â”‚  â”‚   â””â”€â”€ Cancel() - Esc key                                     â”‚
â”‚  â”‚                                                                â”‚
â”‚  â”œâ”€â”€ Events                                                      â”‚
â”‚  â”‚   â”œâ”€â”€ FileSelected: EventHandler<string>                     â”‚
â”‚  â”‚   â””â”€â”€ CloseRequested: EventHandler                           â”‚
â”‚  â”‚                                                                â”‚
â”‚  â””â”€â”€ Private methods                                             â”‚
â”‚      â”œâ”€â”€ LoadInitialResults() - show recent files               â”‚
â”‚      â”œâ”€â”€ OnSearchQueryChanged() - trigger debounced search      â”‚
â”‚      â””â”€â”€ SearchAsync() - execute search with cancellation       â”‚
â”‚                                                                   â”‚
â”‚  QuickOpenItemViewModel                                           â”‚
â”‚  â”œâ”€â”€ FilePath, FileName, RelativePath                           â”‚
â”‚  â”œâ”€â”€ Language, IsRecent                                         â”‚
â”‚  â”œâ”€â”€ MatchedIndices: IReadOnlyList<int>                         â”‚
â”‚  â””â”€â”€ IconKey (computed from Language)                           â”‚
â”‚                                                                   â”‚
â”‚  QuickOpenDialog (Window)                                         â”‚
â”‚  â”œâ”€â”€ Window properties                                           â”‚
â”‚  â”‚   â”œâ”€â”€ 600Ã—400, CenterOwner, Transparent background           â”‚
â”‚  â”‚   â”œâ”€â”€ ExtendClientAreaToDecorationsHint (frameless)          â”‚
â”‚  â”‚   â””â”€â”€ TransparencyLevelHint: AcrylicBlur                     â”‚
â”‚  â”‚                                                                â”‚
â”‚  â”œâ”€â”€ Search input (top)                                          â”‚
â”‚  â”‚   â”œâ”€â”€ Search icon                                            â”‚
â”‚  â”‚   â”œâ”€â”€ TextBox with watermark                                 â”‚
â”‚  â”‚   â””â”€â”€ Auto-focused on open                                   â”‚
â”‚  â”‚                                                                â”‚
â”‚  â”œâ”€â”€ Results list (middle)                                       â”‚
â”‚  â”‚   â”œâ”€â”€ ListBox with custom template                           â”‚
â”‚  â”‚   â”œâ”€â”€ Icon, FileName, RelativePath                           â”‚
â”‚  â”‚   â””â”€â”€ "recent" badge for recent files                        â”‚
â”‚  â”‚                                                                â”‚
â”‚  â””â”€â”€ Status bar (bottom)                                         â”‚
â”‚      â”œâ”€â”€ Status text (left)                                     â”‚
â”‚      â””â”€â”€ Keyboard hints (right): â†‘â†“ â†µ esc                       â”‚
â”‚                                                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Architecture Diagrams

### Dialog Layout

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Quick Open Dialog Layout                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ ğŸ”  Type to search files...                      â”‚        â”‚   â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚  â”‚                                                            â”‚   â”‚
â”‚  â”‚  ğŸ“„  Program.cs                                 recent    â”‚   â”‚
â”‚  â”‚      src/SeniorIntern.Desktop                             â”‚   â”‚
â”‚  â”‚                                                            â”‚   â”‚
â”‚  â”‚  ğŸ“„  MainWindow.axaml                           recent    â”‚   â”‚
â”‚  â”‚      src/SeniorIntern.Desktop/Views                       â”‚   â”‚
â”‚  â”‚                                                            â”‚   â”‚
â”‚  â”‚  ğŸ“„  ChatViewModel.cs                           recent    â”‚   â”‚
â”‚  â”‚      src/SeniorIntern.Desktop/ViewModels                  â”‚   â”‚
â”‚  â”‚                                                            â”‚   â”‚
â”‚  â”‚  ğŸ“„  AppSettings.cs                             recent    â”‚   â”‚
â”‚  â”‚      src/SeniorIntern.Core/Models                         â”‚   â”‚
â”‚  â”‚                                                            â”‚   â”‚
â”‚  â”‚  ... (more results)                                        â”‚   â”‚
â”‚  â”‚                                                            â”‚   â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚  â”‚ 1,234 files indexed        â†‘â†“ navigate  â†µ open  esc close â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Fuzzy Search Algorithm

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Fuzzy Search Algorithm                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  User types: "progcs"                                            â”‚
â”‚                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Step 1: Score each indexed file                           â”‚  â”‚
â”‚  â”‚                                                             â”‚  â”‚
â”‚  â”‚ File: "Program.cs"                                         â”‚  â”‚
â”‚  â”‚ Query: "progcs"                                            â”‚  â”‚
â”‚  â”‚                                                             â”‚  â”‚
â”‚  â”‚ P r o g r a m . c s                                        â”‚  â”‚
â”‚  â”‚ â†‘   â†‘ â†‘ â†‘     â†‘ â†‘                                          â”‚  â”‚
â”‚  â”‚ p   r o g     c s   â† Matched characters                   â”‚  â”‚
â”‚  â”‚                                                             â”‚  â”‚
â”‚  â”‚ Score calculation:                                          â”‚  â”‚
â”‚  â”‚ - Base: 1 point per matched char = 6                       â”‚  â”‚
â”‚  â”‚ - Consecutive bonus: "prog" = 0.5 + 1.0 + 1.5 = 3         â”‚  â”‚
â”‚  â”‚ - Prefix bonus: starts with "prog" = +5                    â”‚  â”‚
â”‚  â”‚ - Total: 6 + 3 + 5 = 14                                    â”‚  â”‚
â”‚  â”‚ - Normalized: 14 / 6 (query length) = 2.33                 â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚         â”‚                                                        â”‚
â”‚         â–¼                                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Step 2: Combine name and path scores                       â”‚  â”‚
â”‚  â”‚                                                             â”‚  â”‚
â”‚  â”‚ nameScore = 2.33 (weighted Ã—2) = 4.66                      â”‚  â”‚
â”‚  â”‚ pathScore = 1.5 (example)                                  â”‚  â”‚
â”‚  â”‚ finalScore = 4.66 + 1.5 = 6.16                             â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚         â”‚                                                        â”‚
â”‚         â–¼                                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Step 3: Sort and return top 20                             â”‚  â”‚
â”‚  â”‚                                                             â”‚  â”‚
â”‚  â”‚ 1. Program.cs (6.16)                                       â”‚  â”‚
â”‚  â”‚ 2. AppSettings.cs (2.8) â† "s" matches "Settings"          â”‚  â”‚
â”‚  â”‚ 3. Progress.cs (2.1)                                       â”‚  â”‚
â”‚  â”‚ ...                                                         â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Keyboard Navigation Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Keyboard Navigation Flow                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  Ctrl+P pressed (global shortcut)                                â”‚
â”‚         â”‚                                                        â”‚
â”‚         â–¼                                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ QuickOpenDialog opens                                      â”‚  â”‚
â”‚  â”‚ â€¢ Focus on search input                                    â”‚  â”‚
â”‚  â”‚ â€¢ Recent files loaded                                      â”‚  â”‚
â”‚  â”‚ â€¢ SelectedIndex = 0                                        â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚         â”‚                                                        â”‚
â”‚         â–¼ User interaction                                      â”‚
â”‚    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                               â”‚
â”‚    â–¼         â–¼        â–¼         â–¼                               â”‚
â”‚ [Type]    [â†‘ Key]  [â†“ Key]  [Enter]   [Esc]                     â”‚
â”‚    â”‚         â”‚        â”‚         â”‚        â”‚                       â”‚
â”‚    â–¼         â–¼        â–¼         â–¼        â–¼                       â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”                    â”‚
â”‚ â”‚Searchâ”‚ â”‚MoveUpâ”‚ â”‚Move  â”‚ â”‚Confirmâ”‚ â”‚Cancelâ”‚                    â”‚
â”‚ â”‚Async â”‚ â”‚      â”‚ â”‚ Down â”‚ â”‚      â”‚ â”‚      â”‚                    â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”˜                    â”‚
â”‚    â”‚         â”‚        â”‚         â”‚        â”‚                       â”‚
â”‚    â–¼         â–¼        â–¼         â–¼        â–¼                       â”‚
â”‚ Update   Index =  Index =   Add to    Close                     â”‚
â”‚ Results  (Index   (Index    Recent,   dialog                    â”‚
â”‚          - 1)     + 1)      Fire                                â”‚
â”‚          mod n    mod n     FileSelected,                       â”‚
â”‚                             Close                               â”‚
â”‚                                                                  â”‚
â”‚  Key bindings in code-behind:                                    â”‚
â”‚                                                                  â”‚
â”‚  protected override void OnKeyDown(KeyEventArgs e)               â”‚
â”‚  {                                                               â”‚
â”‚      switch (e.Key)                                              â”‚
â”‚      {                                                           â”‚
â”‚          case Key.Up:                                            â”‚
â”‚              ViewModel.MoveUpCommand.Execute(null);              â”‚
â”‚              e.Handled = true;                                   â”‚
â”‚              break;                                              â”‚
â”‚          case Key.Down:                                          â”‚
â”‚              ViewModel.MoveDownCommand.Execute(null);            â”‚
â”‚              e.Handled = true;                                   â”‚
â”‚              break;                                              â”‚
â”‚          case Key.Enter:                                         â”‚
â”‚              ViewModel.ConfirmCommand.Execute(null);             â”‚
â”‚              e.Handled = true;                                   â”‚
â”‚              break;                                              â”‚
â”‚          case Key.Escape:                                        â”‚
â”‚              ViewModel.CancelCommand.Execute(null);              â”‚
â”‚              e.Handled = true;                                   â”‚
â”‚              break;                                              â”‚
â”‚      }                                                           â”‚
â”‚  }                                                               â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Search Debouncing

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Search Debouncing                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  User types rapidly: "p" "r" "o" "g"                             â”‚
â”‚         â”‚                                                        â”‚
â”‚  Time â†’â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’    â”‚
â”‚         â”‚                                                        â”‚
â”‚  t=0    â”‚ OnSearchQueryChanged("p")                             â”‚
â”‚         â”‚ _searchCts = new CancellationTokenSource()            â”‚
â”‚         â”‚ SearchAsync("p", token)                               â”‚
â”‚         â”‚   await Task.Delay(50ms)                              â”‚
â”‚         â”‚                                                        â”‚
â”‚  t=30ms â”‚ OnSearchQueryChanged("pr")                            â”‚
â”‚         â”‚ _searchCts?.Cancel()  â† Cancel previous               â”‚
â”‚         â”‚ _searchCts = new CancellationTokenSource()            â”‚
â”‚         â”‚ SearchAsync("pr", newToken)                           â”‚
â”‚         â”‚   await Task.Delay(50ms)                              â”‚
â”‚         â”‚                                                        â”‚
â”‚  t=45ms â”‚ OnSearchQueryChanged("pro")                           â”‚
â”‚         â”‚ _searchCts?.Cancel()  â† Cancel previous               â”‚
â”‚         â”‚ _searchCts = new CancellationTokenSource()            â”‚
â”‚         â”‚ SearchAsync("pro", newToken)                          â”‚
â”‚         â”‚   await Task.Delay(50ms)                              â”‚
â”‚         â”‚                                                        â”‚
â”‚  t=80ms â”‚ OnSearchQueryChanged("prog")                          â”‚
â”‚         â”‚ _searchCts?.Cancel()  â† Cancel previous               â”‚
â”‚         â”‚ _searchCts = new CancellationTokenSource()            â”‚
â”‚         â”‚ SearchAsync("prog", newToken)                         â”‚
â”‚         â”‚   await Task.Delay(50ms)                              â”‚
â”‚         â”‚                                                        â”‚
â”‚  t=130msâ”‚   (50ms passed, no new input)                         â”‚
â”‚         â”‚   Execute actual search("prog")                       â”‚
â”‚         â”‚   Results.Clear()                                     â”‚
â”‚         â”‚   Results.Add(...matched files...)                    â”‚
â”‚         â”‚                                                        â”‚
â”‚  Result: Only ONE search executed for "prog"                     â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Directory Structure

```
src/SeniorIntern.Core/
â”œâ”€â”€ Interfaces/
â”‚   â””â”€â”€ IFileIndexService.cs                          (NEW)
â””â”€â”€ Models/
    â””â”€â”€ FileSearchResult.cs                           (NEW)

src/SeniorIntern.Services/
â””â”€â”€ FileIndexService.cs                               (NEW)

src/SeniorIntern.Desktop/
â”œâ”€â”€ ViewModels/
â”‚   â”œâ”€â”€ QuickOpenViewModel.cs                         (NEW)
â”‚   â””â”€â”€ QuickOpenItemViewModel.cs                     (NEW)
â”œâ”€â”€ Views/
â”‚   â”œâ”€â”€ QuickOpenDialog.axaml                         (NEW)
â”‚   â””â”€â”€ QuickOpenDialog.axaml.cs                      (NEW)
â””â”€â”€ Themes/
    â””â”€â”€ Dark.axaml                                    (MODIFY)
```

---

## Implementation Details

### Task 1: Create IFileIndexService Interface

**File:** `src/SeniorIntern.Core/Interfaces/IFileIndexService.cs`

```csharp
namespace SeniorIntern.Core.Interfaces;

/// <summary>
/// Service for indexing and searching workspace files.
/// </summary>
public interface IFileIndexService
{
    /// <summary>
    /// Indexes all files in the current workspace.
    /// </summary>
    Task IndexWorkspaceAsync(string workspacePath, CancellationToken ct = default);

    /// <summary>
    /// Searches files using fuzzy matching.
    /// </summary>
    IReadOnlyList<FileSearchResult> Search(string query, int maxResults = 20);

    /// <summary>
    /// Gets recently opened files.
    /// </summary>
    IReadOnlyList<string> GetRecentFiles(int count = 10);

    /// <summary>
    /// Adds a file to the recent files list.
    /// </summary>
    void AddToRecent(string filePath);

    /// <summary>
    /// Clears the file index.
    /// </summary>
    void ClearIndex();

    /// <summary>
    /// Whether the index is ready.
    /// </summary>
    bool IsIndexed { get; }

    /// <summary>
    /// Number of indexed files.
    /// </summary>
    int IndexedFileCount { get; }
}
```

### Task 2: Create FileSearchResult Model

**File:** `src/SeniorIntern.Core/Models/FileSearchResult.cs`

```csharp
namespace SeniorIntern.Core.Models;

/// <summary>
/// Result of a file search.
/// </summary>
public sealed class FileSearchResult
{
    /// <summary>
    /// Full path to the file.
    /// </summary>
    public string FilePath { get; init; } = string.Empty;

    /// <summary>
    /// File name without path.
    /// </summary>
    public string FileName { get; init; } = string.Empty;

    /// <summary>
    /// Path relative to workspace root.
    /// </summary>
    public string RelativePath { get; init; } = string.Empty;

    /// <summary>
    /// Detected language (e.g., "csharp", "javascript").
    /// </summary>
    public string? Language { get; init; }

    /// <summary>
    /// Match score (higher is better).
    /// </summary>
    public double Score { get; init; }

    /// <summary>
    /// Indices of matched characters in the file name.
    /// </summary>
    public IReadOnlyList<int> MatchedIndices { get; init; } = Array.Empty<int>();
}
```

### Task 3: Implement FileIndexService

**File:** `src/SeniorIntern.Services/FileIndexService.cs`

```csharp
namespace SeniorIntern.Services;

using System.Collections.Concurrent;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Core.Models;
using SeniorIntern.Core.Utilities;

public sealed class FileIndexService : IFileIndexService
{
    private readonly IFileSystemService _fileSystemService;
    private readonly ConcurrentDictionary<string, IndexedFile> _index = new();
    private readonly LinkedList<string> _recentFiles = new();
    private readonly object _recentLock = new();
    private const int MaxRecentFiles = 20;

    private string? _workspacePath;
    private bool _isIndexed;

    public bool IsIndexed => _isIndexed;
    public int IndexedFileCount => _index.Count;

    public FileIndexService(IFileSystemService fileSystemService)
    {
        _fileSystemService = fileSystemService;
    }

    public async Task IndexWorkspaceAsync(string workspacePath, CancellationToken ct = default)
    {
        _workspacePath = workspacePath;
        _index.Clear();
        _isIndexed = false;

        var ignorePatterns = await _fileSystemService.LoadGitIgnorePatternsAsync(workspacePath);

        await Task.Run(() =>
        {
            IndexDirectory(workspacePath, workspacePath, ignorePatterns, ct);
        }, ct);

        _isIndexed = true;
    }

    private void IndexDirectory(
        string directory,
        string rootPath,
        IReadOnlyList<string> ignorePatterns,
        CancellationToken ct)
    {
        if (ct.IsCancellationRequested) return;

        try
        {
            foreach (var file in Directory.EnumerateFiles(directory))
            {
                if (ct.IsCancellationRequested) return;

                var relativePath = Path.GetRelativePath(rootPath, file);

                if (_fileSystemService.ShouldIgnore(relativePath, ignorePatterns))
                    continue;

                var fileName = Path.GetFileName(file);
                var language = LanguageDetector.DetectByFileName(fileName);

                _index[file] = new IndexedFile
                {
                    FullPath = file,
                    FileName = fileName,
                    FileNameLower = fileName.ToLowerInvariant(),
                    RelativePath = relativePath,
                    RelativePathLower = relativePath.ToLowerInvariant(),
                    Language = language
                };
            }

            foreach (var subDir in Directory.EnumerateDirectories(directory))
            {
                if (ct.IsCancellationRequested) return;

                var dirName = Path.GetFileName(subDir);
                var relativePath = Path.GetRelativePath(rootPath, subDir);

                if (_fileSystemService.ShouldIgnore(relativePath + "/", ignorePatterns))
                    continue;

                IndexDirectory(subDir, rootPath, ignorePatterns, ct);
            }
        }
        catch (UnauthorizedAccessException)
        {
            // Skip directories we can't access
        }
    }

    public IReadOnlyList<FileSearchResult> Search(string query, int maxResults = 20)
    {
        if (string.IsNullOrWhiteSpace(query))
        {
            // Return recent files when no query
            return GetRecentFiles(maxResults)
                .Where(f => _index.ContainsKey(f))
                .Select(f => new FileSearchResult
                {
                    FilePath = f,
                    FileName = _index[f].FileName,
                    RelativePath = _index[f].RelativePath,
                    Language = _index[f].Language,
                    Score = 1.0
                })
                .ToList();
        }

        var queryLower = query.ToLowerInvariant();

        return _index.Values
            .Select(file => ScoreFile(file, queryLower))
            .Where(r => r.Score > 0)
            .OrderByDescending(r => r.Score)
            .ThenBy(r => r.FileName.Length)
            .Take(maxResults)
            .ToList();
    }

    private FileSearchResult ScoreFile(IndexedFile file, string query)
    {
        // Score based on file name match (weighted higher)
        var nameScore = FuzzyMatch(file.FileNameLower, query, out var nameIndices);

        // Score based on path match
        var pathScore = FuzzyMatch(file.RelativePathLower, query, out var pathIndices);

        // Combine scores with name weighted higher
        var score = nameScore * 2 + pathScore;

        // Boost exact prefix matches
        if (file.FileNameLower.StartsWith(query))
            score += 5;

        // Boost if query appears as word boundary
        if (file.FileNameLower.Contains("_" + query) || file.FileNameLower.Contains("-" + query))
            score += 2;

        return new FileSearchResult
        {
            FilePath = file.FullPath,
            FileName = file.FileName,
            RelativePath = file.RelativePath,
            Language = file.Language,
            Score = score,
            MatchedIndices = nameScore > pathScore ? nameIndices : pathIndices
        };
    }

    private static double FuzzyMatch(string text, string query, out List<int> matchedIndices)
    {
        matchedIndices = new List<int>();

        if (string.IsNullOrEmpty(query)) return 0;

        var textIndex = 0;
        var queryIndex = 0;
        var score = 0.0;
        var consecutiveBonus = 0;

        while (textIndex < text.Length && queryIndex < query.Length)
        {
            if (text[textIndex] == query[queryIndex])
            {
                matchedIndices.Add(textIndex);
                score += 1 + (consecutiveBonus * 0.5);
                consecutiveBonus++;
                queryIndex++;
            }
            else
            {
                consecutiveBonus = 0;
            }
            textIndex++;
        }

        // All query characters must match
        if (queryIndex < query.Length)
        {
            matchedIndices.Clear();
            return 0;
        }

        // Normalize by query length
        return score / query.Length;
    }

    public IReadOnlyList<string> GetRecentFiles(int count = 10)
    {
        lock (_recentLock)
        {
            return _recentFiles.Take(count).ToList();
        }
    }

    public void AddToRecent(string filePath)
    {
        lock (_recentLock)
        {
            // Remove if already exists
            var node = _recentFiles.Find(filePath);
            if (node != null)
                _recentFiles.Remove(node);

            // Add to front
            _recentFiles.AddFirst(filePath);

            // Trim if too long
            while (_recentFiles.Count > MaxRecentFiles)
                _recentFiles.RemoveLast();
        }
    }

    public void ClearIndex()
    {
        _index.Clear();
        _isIndexed = false;
    }

    private sealed class IndexedFile
    {
        public string FullPath { get; init; } = string.Empty;
        public string FileName { get; init; } = string.Empty;
        public string FileNameLower { get; init; } = string.Empty;
        public string RelativePath { get; init; } = string.Empty;
        public string RelativePathLower { get; init; } = string.Empty;
        public string? Language { get; init; }
    }
}
```

### Task 4: Create QuickOpenViewModel

**File:** `src/SeniorIntern.Desktop/ViewModels/QuickOpenViewModel.cs`

```csharp
namespace SeniorIntern.Desktop.ViewModels;

using System.Collections.ObjectModel;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using SeniorIntern.Core.Interfaces;

public partial class QuickOpenViewModel : ViewModelBase
{
    private readonly IFileIndexService _fileIndexService;
    private CancellationTokenSource? _searchCts;

    [ObservableProperty]
    private string _searchQuery = string.Empty;

    [ObservableProperty]
    private ObservableCollection<QuickOpenItemViewModel> _results = new();

    [ObservableProperty]
    private QuickOpenItemViewModel? _selectedItem;

    [ObservableProperty]
    private int _selectedIndex;

    [ObservableProperty]
    private bool _isLoading;

    [ObservableProperty]
    private string? _statusText;

    public event EventHandler<string>? FileSelected;
    public event EventHandler? CloseRequested;

    public QuickOpenViewModel(IFileIndexService fileIndexService)
    {
        _fileIndexService = fileIndexService;
        LoadInitialResults();
    }

    private void LoadInitialResults()
    {
        var recentFiles = _fileIndexService.GetRecentFiles(10);
        Results.Clear();

        foreach (var file in recentFiles)
        {
            var result = _fileIndexService.Search(string.Empty, 1)
                .FirstOrDefault(r => r.FilePath == file);

            if (result != null)
            {
                Results.Add(new QuickOpenItemViewModel(result, isRecent: true));
            }
        }

        StatusText = _fileIndexService.IsIndexed
            ? $"{_fileIndexService.IndexedFileCount:N0} files indexed"
            : "Indexing...";

        if (Results.Count > 0)
            SelectedIndex = 0;
    }

    partial void OnSearchQueryChanged(string value)
    {
        // Cancel previous search
        _searchCts?.Cancel();
        _searchCts = new CancellationTokenSource();

        // Debounce search
        _ = SearchAsync(value, _searchCts.Token);
    }

    private async Task SearchAsync(string query, CancellationToken ct)
    {
        // Short debounce
        await Task.Delay(50, ct);
        if (ct.IsCancellationRequested) return;

        IsLoading = true;

        try
        {
            var results = _fileIndexService.Search(query, 20);

            if (ct.IsCancellationRequested) return;

            Results.Clear();
            foreach (var result in results)
            {
                Results.Add(new QuickOpenItemViewModel(result));
            }

            if (Results.Count > 0)
                SelectedIndex = 0;

            StatusText = Results.Count > 0
                ? $"{Results.Count} results"
                : "No matching files";
        }
        finally
        {
            IsLoading = false;
        }
    }

    [RelayCommand]
    public void MoveUp()
    {
        if (Results.Count == 0) return;
        SelectedIndex = (SelectedIndex - 1 + Results.Count) % Results.Count;
    }

    [RelayCommand]
    public void MoveDown()
    {
        if (Results.Count == 0) return;
        SelectedIndex = (SelectedIndex + 1) % Results.Count;
    }

    [RelayCommand]
    public void Confirm()
    {
        var selected = SelectedIndex >= 0 && SelectedIndex < Results.Count
            ? Results[SelectedIndex]
            : null;

        if (selected != null)
        {
            _fileIndexService.AddToRecent(selected.FilePath);
            FileSelected?.Invoke(this, selected.FilePath);
        }

        CloseRequested?.Invoke(this, EventArgs.Empty);
    }

    [RelayCommand]
    public void Cancel()
    {
        CloseRequested?.Invoke(this, EventArgs.Empty);
    }
}
```

### Task 5: Create QuickOpenItemViewModel

**File:** `src/SeniorIntern.Desktop/ViewModels/QuickOpenItemViewModel.cs`

```csharp
namespace SeniorIntern.Desktop.ViewModels;

using CommunityToolkit.Mvvm.ComponentModel;
using SeniorIntern.Core.Models;

public partial class QuickOpenItemViewModel : ViewModelBase
{
    [ObservableProperty]
    private string _filePath;

    [ObservableProperty]
    private string _fileName;

    [ObservableProperty]
    private string _relativePath;

    [ObservableProperty]
    private string? _language;

    [ObservableProperty]
    private bool _isRecent;

    [ObservableProperty]
    private IReadOnlyList<int> _matchedIndices;

    public string IconKey => Language switch
    {
        "csharp" => "CSharpIcon",
        "javascript" or "typescript" => "JavaScriptIcon",
        "python" => "PythonIcon",
        "json" => "JsonIcon",
        "xml" or "xaml" => "XmlIcon",
        "markdown" => "MarkdownIcon",
        _ => "FileCodeIcon"
    };

    public QuickOpenItemViewModel(FileSearchResult result, bool isRecent = false)
    {
        FilePath = result.FilePath;
        FileName = result.FileName;
        RelativePath = result.RelativePath;
        Language = result.Language;
        MatchedIndices = result.MatchedIndices;
        IsRecent = isRecent;
    }
}
```

### Task 6: Create QuickOpenDialog.axaml

**File:** `src/SeniorIntern.Desktop/Views/QuickOpenDialog.axaml`

```xml
<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:vm="using:SeniorIntern.Desktop.ViewModels"
        x:Class="SeniorIntern.Desktop.Views.QuickOpenDialog"
        x:DataType="vm:QuickOpenViewModel"
        Title="Quick Open"
        Width="600"
        Height="400"
        MinWidth="400"
        MinHeight="200"
        WindowStartupLocation="CenterOwner"
        CanResize="True"
        ShowInTaskbar="False"
        ExtendClientAreaToDecorationsHint="True"
        ExtendClientAreaTitleBarHeightHint="0"
        Background="Transparent"
        TransparencyLevelHint="AcrylicBlur">

    <Border Background="{DynamicResource QuickOpenBackgroundBrush}"
            BorderBrush="{DynamicResource QuickOpenBorderBrush}"
            BorderThickness="1"
            CornerRadius="8"
            Margin="8"
            BoxShadow="0 8 32 0 #60000000">

        <Grid RowDefinitions="Auto, *, Auto">
            <!-- Search Input -->
            <Border Grid.Row="0"
                    Background="{DynamicResource InputBackgroundBrush}"
                    CornerRadius="8,8,0,0"
                    Padding="12">
                <Grid ColumnDefinitions="Auto, *">
                    <PathIcon Grid.Column="0"
                              Data="{StaticResource SearchIcon}"
                              Width="16" Height="16"
                              Margin="0,0,8,0"
                              Foreground="{DynamicResource TextMutedBrush}" />
                    <TextBox Grid.Column="1"
                             x:Name="SearchInput"
                             Text="{Binding SearchQuery, Mode=TwoWay}"
                             Watermark="Type to search files..."
                             BorderThickness="0"
                             Background="Transparent"
                             FontSize="14" />
                </Grid>
            </Border>

            <!-- Results List -->
            <ListBox Grid.Row="1"
                     ItemsSource="{Binding Results}"
                     SelectedIndex="{Binding SelectedIndex}"
                     Background="Transparent"
                     BorderThickness="0"
                     ScrollViewer.HorizontalScrollBarVisibility="Disabled">
                <ListBox.ItemTemplate>
                    <DataTemplate x:DataType="vm:QuickOpenItemViewModel">
                        <Grid ColumnDefinitions="Auto, *, Auto" Margin="8,6">
                            <!-- Icon -->
                            <PathIcon Grid.Column="0"
                                      Data="{Binding IconKey, Converter={StaticResource IconKeyConverter}}"
                                      Width="16" Height="16"
                                      Margin="0,0,10,0" />

                            <!-- File Info -->
                            <StackPanel Grid.Column="1" Spacing="2">
                                <TextBlock Text="{Binding FileName}"
                                           FontWeight="SemiBold"
                                           FontSize="13" />
                                <TextBlock Text="{Binding RelativePath}"
                                           FontSize="11"
                                           Foreground="{DynamicResource TextMutedBrush}"
                                           TextTrimming="CharacterEllipsis" />
                            </StackPanel>

                            <!-- Recent Badge -->
                            <Border Grid.Column="2"
                                    Background="{DynamicResource BadgeBackgroundBrush}"
                                    CornerRadius="4"
                                    Padding="6,2"
                                    VerticalAlignment="Center"
                                    IsVisible="{Binding IsRecent}">
                                <TextBlock Text="recent"
                                           FontSize="10"
                                           Foreground="{DynamicResource TextMutedBrush}" />
                            </Border>
                        </Grid>
                    </DataTemplate>
                </ListBox.ItemTemplate>
            </ListBox>

            <!-- Status Bar -->
            <Border Grid.Row="2"
                    Background="{DynamicResource FooterBackgroundBrush}"
                    CornerRadius="0,0,8,8"
                    Padding="12,8">
                <Grid ColumnDefinitions="*, Auto">
                    <TextBlock Grid.Column="0"
                               Text="{Binding StatusText}"
                               FontSize="11"
                               Foreground="{DynamicResource TextMutedBrush}" />
                    <StackPanel Grid.Column="1" Orientation="Horizontal" Spacing="16">
                        <TextBlock FontSize="11" Foreground="{DynamicResource TextMutedBrush}">
                            <Run Text="â†‘â†“" FontFamily="Segoe UI Symbol" /> navigate
                        </TextBlock>
                        <TextBlock FontSize="11" Foreground="{DynamicResource TextMutedBrush}">
                            <Run Text="â†µ" FontFamily="Segoe UI Symbol" /> open
                        </TextBlock>
                        <TextBlock FontSize="11" Foreground="{DynamicResource TextMutedBrush}">
                            <Run Text="esc" /> close
                        </TextBlock>
                    </StackPanel>
                </Grid>
            </Border>
        </Grid>
    </Border>
</Window>
```

### Task 7: Create QuickOpenDialog.axaml.cs

**File:** `src/SeniorIntern.Desktop/Views/QuickOpenDialog.axaml.cs`

```csharp
namespace SeniorIntern.Desktop.Views;

using Avalonia.Controls;
using Avalonia.Input;
using SeniorIntern.Core.Interfaces;
using SeniorIntern.Desktop.ViewModels;

public partial class QuickOpenDialog : Window
{
    private QuickOpenViewModel? _viewModel;

    public QuickOpenDialog()
    {
        InitializeComponent();
    }

    public void Initialize(IFileIndexService fileIndexService)
    {
        _viewModel = new QuickOpenViewModel(fileIndexService);

        _viewModel.FileSelected += (s, filePath) => Close(filePath);
        _viewModel.CloseRequested += (s, e) => Close(null);

        DataContext = _viewModel;

        // Focus search input when opened
        Opened += (s, e) => SearchInput.Focus();
    }

    protected override void OnKeyDown(KeyEventArgs e)
    {
        if (_viewModel == null)
        {
            base.OnKeyDown(e);
            return;
        }

        switch (e.Key)
        {
            case Key.Up:
                _viewModel.MoveUpCommand.Execute(null);
                e.Handled = true;
                break;
            case Key.Down:
                _viewModel.MoveDownCommand.Execute(null);
                e.Handled = true;
                break;
            case Key.Enter:
                _viewModel.ConfirmCommand.Execute(null);
                e.Handled = true;
                break;
            case Key.Escape:
                _viewModel.CancelCommand.Execute(null);
                e.Handled = true;
                break;
            default:
                base.OnKeyDown(e);
                break;
        }
    }

    /// <summary>
    /// Shows the dialog and returns the selected file path, or null if cancelled.
    /// </summary>
    public static async Task<string?> ShowDialogAsync(Window owner, IFileIndexService fileIndexService)
    {
        var dialog = new QuickOpenDialog();
        dialog.Initialize(fileIndexService);

        return await dialog.ShowDialog<string?>(owner);
    }
}
```

### Task 8: Add Theme Resources

**File:** `src/SeniorIntern.Desktop/Themes/Dark.axaml` (additions)

```xml
<!-- Quick Open Colors -->
<SolidColorBrush x:Key="QuickOpenBackgroundBrush" Color="#E0252526" />
<SolidColorBrush x:Key="QuickOpenBorderBrush" Color="#404040" />
<SolidColorBrush x:Key="InputBackgroundBrush" Color="#2D2D2D" />
<SolidColorBrush x:Key="BadgeBackgroundBrush" Color="#3C3C3C" />
```

---

## Unit Testing Requirements

| Component | Test Count | Focus Areas |
|-----------|------------|-------------|
| FileIndexService.IndexWorkspaceAsync | 3 | Indexes files, respects ignore, cancellation |
| FileIndexService.Search | 5 | Empty query, fuzzy match, scoring, prefix boost |
| FileIndexService.FuzzyMatch | 4 | Exact match, partial, consecutive bonus, no match |
| FileIndexService.RecentFiles | 3 | Add, move to front, max limit |
| QuickOpenViewModel.SearchQuery | 2 | Debouncing, cancellation |
| QuickOpenViewModel.MoveUp/Down | 2 | Wraps around |
| QuickOpenViewModel.Confirm | 2 | Fires event, adds to recent |
| QuickOpenItemViewModel | 2 | Constructor, IconKey |
| **Total** | **23** | |

---

## Files Summary

### Files to Create (6)

| File | Lines |
|------|-------|
| `Core/Interfaces/IFileIndexService.cs` | 35 |
| `Core/Models/FileSearchResult.cs` | 30 |
| `Services/FileIndexService.cs` | 200 |
| `Desktop/ViewModels/QuickOpenViewModel.cs` | 100 |
| `Desktop/ViewModels/QuickOpenItemViewModel.cs` | 45 |
| `Desktop/Views/QuickOpenDialog.axaml` | 100 |
| `Desktop/Views/QuickOpenDialog.axaml.cs` | 70 |

### Files to Modify (1)

| File | Changes |
|------|---------|
| `Themes/Dark.axaml` | Add quick open color resources |

---

## Acceptance Criteria

| ID | Criterion |
|----|-----------|
| AC-1 | Ctrl+P opens quick open dialog |
| AC-2 | Empty search shows recent files with "recent" badge |
| AC-3 | Typing filters files with fuzzy matching |
| AC-4 | Results update as you type (50ms debounce) |
| AC-5 | Arrow keys navigate results (wraps around) |
| AC-6 | Enter opens selected file in editor |
| AC-7 | Escape closes dialog |
| AC-8 | File name score weighted 2x vs path score |
| AC-9 | Prefix matches get +5 bonus |
| AC-10 | Status bar shows file count or "No matching files" |

---

## Dependencies

| Part | Dependency Description |
|------|------------------------|
| v0.3.1 | IFileSystemService, LanguageDetector |
| MainWindowViewModel | For Ctrl+P command registration |
| EditorPanelViewModel | For opening selected file |

---

## Timeline Estimate

| Version | Estimated Effort |
|---------|------------------|
| v0.3.5c | 1 day |
